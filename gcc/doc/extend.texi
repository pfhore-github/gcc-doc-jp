@c Copyright (C) 1988-2017 Free Software Foundation, Inc.

@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node C Extensions
@chapter C言語族への拡張
@cindex extensions, C language
@cindex C language extensions

@opindex pedantic
GNU Cは、ISO標準Cにはないいくつかの言語機能を提供している。（これらの機能のいずれかが使用されている場合、@ option{-pedantic}オプションはGCCに警告メッセージを出力するように指示する）。条件付きコンパイルでこれらの機能が利用できるかどうかをテストするために、あらかじめ定義されたマクロ@code{__ GNUC__}が常にGCCの下で定義されている。

これらの拡張は、CとObjective-Cで利用できる。 それらのほとんどはC ++でも利用可能である。C++に@emph{_のみ_}適用する拡張機能は、@xref{C++ Extensions,,C ++言語の拡張機能}。

ISO C99にはあるがC90やC ++にはない機能のいくつかは、拡張機能として、C90モードとC ++でGCCで受理される。

@menu
* Statement Exprs::     文と宣言を式の中に置く。
* Local Labels::        ブロックにローカルなラベル。
* Labels as Values::    ラベルへのポインタの取得と計算goto。
* Nested Functions::    AlgolとPascalのような、関数のレキシカルスコープ。
* Constructing Calls::  他の関数の呼び出しの派遣
* Typeof::              @code{typeof}: 式の型の参照。
* Conditionals::        @samp{?:}の第２引数の省略。
* __int128::            128ビット整数---@code{__int128}。
* Long Long::           ２ワード整数---@code{long long int}。
* Complex::             複素数のデータ型。
* Floating Types::      追加の浮動小数点型。
* Half-Precision::      半精度浮動小数点型。
* Decimal Float::       10進浮動小数点型。
* Hex Floats::         16進浮動小数点定数。
* Fixed-Point::         固定小数点型。
* Named Address Spaces:: 名前付きアドレス空間。
* Zero Length::         ゼロ長配列。
* Empty Structures::    メンバなしの構造体。
* Variable Length::     実行時に長さが計算される配列。
* Variadic Macros::     引数の数が可変のマクロ。
* Escaped Newlines::    エスケープされた改行のためのやや緩い規則。
* Subscripting::        配列は非左辺値でも添字を取ることができる。
* Pointer Arith::       @code{void}ポインタと関数ポインタでの算術。
* Pointers to Arrays::  修飾子付きの配列へのポインタは期待通りに機能する。
* Initializers::        非定数初期化子。
* Compound Literals::   値として構造体・共用体・配列を与える複合定数。
* Designated Inits::    初期化子の要素にラベルを与える。
* Case Ranges::         `case 1 ... 9'のようなもの。
* Cast to Union::       共用体の任意のメンバから共用体型へのキャスト。
* Mixed Declarations::  宣言とコードの混在。
* Function Attributes:: 関数が、副作用なし、並びに決して戻らないことを宣言する。
* Variable Attributes:: 変数の属性を指定する。
* Type Attributes::     型の属性を指定する。
* Label Attributes::    ラベルの属性を指定する。
* Enumerator Attributes:: 列挙の属性を指定する。
* Statement Attributes:: 文の属性を指定する。
* Attribute Syntax::    属性の正式な構文。
* Function Prototypes:: プロトタイプ宣言と旧式の定義。
* C++ Comments::        C++コメントは認識される。
* Dollar Signs::        ドル記号は識別子に許容される。
* Character Escapes::   @samp{\e}は@key{ESC}文字を表す。
* Alignment::           型または変数のアラインメントの照会。
* Inline::              （マクロと同等に速い）インライン関数の定義。
* Volatiles::           volatileオブジェクトへのアクセスを構成するもの。
* Using Assembly Language with C:: アセンブラとCのインタフェースをとるための命令と拡張。
* Alternate Keywords::  ヘッダファイル用の@code{__const__}, @code{__asm__}など。
* Incomplete Enums::    詳細を下に書く@code{enum foo;}。
* Function Names::      現在の関数の名前である印字可能な文字列。
* Return Address::      関数の戻り値またはフレームアドレスの取得。
* Vector Extensions::   組み込み関数によるベクトル命令の使用。
* Offsetof::            @code{offsetof}を実装する特別な構文。
* __sync Builtins::     アトミックメモリアクセス用の旧式の組み込み関数。
* __atomic Builtins::   メモリモデル付きのアトミック組み込み関数。
* Integer Overflow Builtins:: 算術と算術オーバーフローチェックを行う組み込み関数。
* x86 specific memory model extensions for transactional memory:: x86メモリモデル。
* Object Size Checking:: 制限されたバッファオーバーフローチェック用の組み込み関数。
* Pointer Bounds Checker builtins:: ポインタ範囲チェッカ用の組み込み関数。
* Cilk Plus Builtins::  Cilk Plus言語拡張用の組み込み関数。
* Other Builtins::      他の組み込み関数。
* Target Builtins::     特定のターゲットに固有の組み込み関数。
* Target Format Checks:: 特定のターゲットに固有のフォーマットチェック。
* Pragmas::             GCCによって受理されるプラグマ。
* Unnamed Fields::      構造体・共用体内の名無し構造体・共用体
* Thread-Local::        スレッドごとの変数。
* Binary constants::    @samp{0b}接頭辞を使った2進定数。
@end menu

@node Statement Exprs
@section 式内の文と宣言
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

@c the above section title wrapped and causes an underfull hbox.. i
@c changed it from "within" to "in". --mew 4feb93
括弧で囲まれた複合文は、GNU Cの式として現れてもよい。これにより、式内でループ、スイッチ、およびローカル変数を使用できる。

複合文は中括弧で囲まれた一連の文であることを思い出すこと。 この構造体では、かっこが中括弧の周りにある。 例えば：

@smallexample
(@{ int y = foo (); int z;
   if (y > 0) z = y;
   else z = - y;
   z; @})
@end smallexample

@noindent
は、@code{foo()}の絶対値のための（必要以上に複雑な）有効な式である。

複合文の最後のものは、式の後ろにセミコロンを続ける必要がある。 この部分式の値は構造全体の値として機能する。（丸かっこ内で他の種類の文を最後に使用した場合、構造は@code{void}型であり、実質的に値はない。）

この機能は、マクロ定義を「安全」にするために特に便利である（各オペランドを正確に1回評価するために）。 例えば、「最大」関数は、一般に、標準Cのマクロとして次のように定義される。

@smallexample
#define max(a,b) ((a) > (b) ? (a) : (b))
@end smallexample

@noindent
@cindex side effects, macro argument
しかし、この定義は@var{a}か@var{b}のどちらかを2回計算する。オペランドに副作用があると悪い結果が出る。 GNU Cでは、オペランド（ここでは@code{int}とする）の型を知っていれば、マクロを次のように安全に定義することができる：

@smallexample
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end smallexample

列挙定数の値、ビットフィールドの幅、または静的変数の初期値などの定数式では、埋め込み文は使用できない。

オペランドの型がわからない場合でもこれを行うことができるが、@code{typeof}や@code{__ auto_type}（@pxref{Typeof}）を使用する必要がある。

G++では、文式の結果値は配列と関数ポインタの格下げを受け、その値を囲む式に返される。 たとえば、@code{A}がクラスの場合、

@smallexample
        A a;

        (@{a;@}).Foo ()
@end smallexample

@noindent
は文の式の結果を保持する一時的な@code{A}オブジェクトを構築する。これは@code{Foo}を呼び出すために使用される。したがって、@code{Foo}によって観測される@code{this}ポインタは@code{a}のアドレスではない。

文の式では、文内で作成された一時変数は、その文の最後で破棄される。 これにより、マクロ内の文式は関数呼び出しとは少し異なる。 後者の場合、引数の評価中に導入された一時変数は、関数呼び出しを含む文の最後で破棄される。 文式の場合、それらは文式中に破棄される。 例えば、

@smallexample
#define macro(a)  (@{__typeof__(a) b = (a); b + 3; @})
template<typename T> T function(T a) @{ T b = a; return b + 3; @}

void foo ()
@{
  macro (X ());
  function (X ());
@}
@end smallexample

@noindent
は一時的なものが破壊される場所は異なる。 @code{macro}の場合、一時的な@code{X}は@code {b}の初期化直後に破棄される。 @code{function}の場合、関数が返ってきたら一時値は破壊される。

これらの考慮事項は、C++で動作するように設計されたヘッダーファイルでこの形式の式式を使用することは、おそらく悪い考えであることを意味する。 （一部のバージョンのGNU Cライブラリには、正確にこのバグにつながる文式を使ったヘッダファイルが含まれていた）。

@code{goto}を使うか、式文の中の@code{case}または@code{default}ラベルのある@code{switch}文を使って式文の中にジャンプすることはできない。計算@code{goto}（@pxref{Labels as Values}）で文式にジャンプすると、未定義の動作が発生する。式文からの飛び越しは許可されるが、式文がより大きい式の一部である場合、文の式の前後で評価する特定の部分式が必要な場合を除き、その式の他の部分式が評価されない 。 いずれにしても、関数呼び出しと同様に、文の式の評価は、その包含する式の他の部分の評価とインタリーブされない。 例えば、

@smallexample
  foo (), ((@{ bar1 (); goto a; 0; @}) + bar2 ()), baz();
@end smallexample

@noindent
は@code{foo}と@code{bar1}を呼び出し、@code{baz}を呼び出さずに@code{bar2}を呼び出すかもしれない。 @code{bar2}が呼び出されると、@code{foo}の後で@code{bar1}の前に呼び出される。

@node Local Labels
@section 局所的に宣言されたラベル
@cindex local labels
@cindex macros, local labels

GCCでは、ネストされたブロックスコープの@dfn{local labels}（ローカルラベル）を宣言できる。 ローカルラベルは通常のラベルと同じだが、宣言されている（@code{goto}文、あるいはそのアドレスを取ることで）ブロック内でのみ参照できる。

ローカルラベル宣言は次のようになる。

@smallexample
__label__ @var{label};
@end smallexample

@noindent
または、

@smallexample
__label__ @var{label1}, @var{label2}, /* @r{@dots{}} */;
@end smallexample

ローカルラベルの宣言は、ブロックの先頭、通常の宣言または文の前に来なければならない。

ラベル宣言はラベル@emph{_名_}を定義するが、ラベル自体は定義しない。 @code{@var{label}:}は、文の式の中で通常の方法で行う必要がある。

ローカルラベル機能は、複雑なマクロに便利である。 マクロにネストされたループが含まれている場合、@code{goto}はそれらのループを中断するのに便利である。 ただし、関数全体をスコープとする通常のラベルは使用できない。マクロを1つの関数で複数回展開できる場合、ラベルはその関数で複数定義される。 ローカルラベルはこの問題を回避する。 例えば：

@smallexample
#define SEARCH(value, array, target)              \
do @{                                              \
  __label__ found;                                \
  typeof (target) _SEARCH_target = (target);      \
  typeof (*(array)) *_SEARCH_array = (array);     \
  int i, j;                                       \
  int value;                                      \
  for (i = 0; i < max; i++)                       \
    for (j = 0; j < max; j++)                     \
      if (_SEARCH_array[i][j] == _SEARCH_target)  \
        @{ (value) = i; goto found; @}              \
  (value) = -1;                                   \
 found:;                                          \
@} while (0)
@end smallexample

これは文式を使って書くこともできる：

@smallexample
#define SEARCH(array, target)                     \
(@{                                                \
  __label__ found;                                \
  typeof (target) _SEARCH_target = (target);      \
  typeof (*(array)) *_SEARCH_array = (array);     \
  int i, j;                                       \
  int value;                                      \
  for (i = 0; i < max; i++)                       \
    for (j = 0; j < max; j++)                     \
      if (_SEARCH_array[i][j] == _SEARCH_target)  \
        @{ value = i; goto found; @}                \
  value = -1;                                     \
 found:                                           \
  value;                                          \
@})
@end smallexample

ローカルラベル宣言では、ネストされた関数が存在する場合には、それらがネストされた関数に可視であると宣言するラベルを作成する。  詳細は@xref{Nested Functions}。

@node Labels as Values
@section 値としてのラベル
@cindex labels as values
@cindex computed gotos
@cindex goto with computed label
@cindex address of a label

単項演算子@samp {&&}を使用して、現在の関数（または含む関数）で定義されているラベルのアドレスを取得できる。 値は型@code{void*}を持つ。 この値は定数であり、その型の定数が有効な場合はいつでも使用できる。 例えば：

@smallexample
void *ptr;
/* @r{@dots{}} */
ptr = &&foo;
@end smallexample

これらの値を使用するには、1つにジャンプする必要がある。 これは計算されたgoto文、@code{goto *@var{exp};}で行われる。@footnote{Fortranの類似機能は代入gotoと呼ばれるが、C言語では、単にローカル変数にラベルのアドレスを代入する以上のことを行うため、不適切である。}。例えば、

@smallexample
goto *ptr;
@end smallexample

@noindent
@code {void *}型の式はすべて使用できる。

これらの定数を使用する1つの方法は、ジャンプテーブルとして機能する静的配列を初期化することである。

@smallexample
static void *array[] = @{ &&foo, &&bar, &&hack @};
@end smallexample

@noindent
次に、次のように索引付けするラベルを選択できる。

@smallexample
goto *array[i];
@end smallexample

@noindent
これは、下付き文字が範囲内にあるかどうかをチェックしないことに注意せよ。Cでの配列のインデックス付けはそれを決して行わない。

このようなラベル値の配列は、@code{switch}文のような目的を果たす。 @code{switch}文はより洗練されているので、問題が@code{switch}文によく合わない場合を除き、配列ではなくその文を使用すること。

ラベル値の別の使用法は、スレッド化されたコードのインタプリタにある。インタプリタ関数内のラベルは、超高速ディスパッチのためにスレッドコードに格納することができる。

この機能を使用して、別の機能のコードにジャンプすることはできない。 そうすれば、全く予測できないことが起こる。 これを避ける最善の方法は、自動変数にのみラベルアドレスを格納し、それを引数として渡さないことである。

上記の例を書く別の方法は次のとおりです。

@smallexample
static const int array[] = @{ &&foo - &&foo, &&bar - &&foo,
                             &&hack - &&foo @};
goto *(&&foo + array[i]);
@end smallexample

@noindent
これは、必要な動的再配置の数を減らし、結果としてデータを読み取り専用にすることができるようになり、共有ライブラリでのコードにより適している。AVRターゲットでは、このラベルの差の代替方法はサポートされていない。AVRプログラムの最初の方法を使用すること。

同じラベルの@code{&& foo}式は、インクルードされた関数がインライン化またはクローン化されている場合、異なる値を持つことがある。 プログラムがそれらが常に同じであることに依存する場合、インライン化とクローン化を防ぐために@code{__attribute__((__noinline__,__noclone__))}を使用する必要がある。 @code{&& foo}を静的変数初期化子で使用すると、インライン化とクローン化は禁止される。

@node Nested Functions
@section 入れ子関数
@cindex nested functions
@cindex downward funargs
@cindex thunks

@dfn{nested function}（入れ子関数）は、別の関数の中で定義された関数である。入れ子関数は、GNU Cの拡張としてサポートされているが、GNU C++ではサポートされていない。

入れ子関数の名前は、それが定義されているブロックのローカルである。例えば、ここでは、@code{square}という入れ子関数を定義し、それを2回呼び出している。

@smallexample
@group
foo (double a, double b)
@{
  double square (double z) @{ return z * z; @}

  return square (a) + square (b);
@}
@end group
@end smallexample

入れ子関数は、その定義時点で表示されている包含関数のすべての変数にアクセスできる。 これは@dfn{lexical scoping}（レキシカルスコープ）と呼ばれる。 例えば、ここでは、継承された@code{offset}という名前の変数を使用する入れ子関数を示る。

@smallexample
@group
bar (int *array, int offset, int size)
@{
  int access (int *array, int index)
    @{ return array[index + offset]; @}
  int i;
  /* @r{@dots{}} */
  for (i = 0; i < size; i++)
    /* @r{@dots{}} */ access (array, i) /* @r{@dots{}} */
@}
@end group
@end smallexample

入れ子関数定義は、変数定義が許可されている場所の関数内で使用できる。 つまり、ブロック内の他の宣言とステートメントと混ぜることができる。

その入れ子関数をその名前の範囲外から呼び出すことは、そのアドレスを格納したり、そのアドレスを別の関数に渡したりすることで可能である。

@smallexample
hack (int *array, int size)
@{
  void store (int index, int value)
    @{ array[index] = value; @}

  intermediate (store, size);
@}
@end smallexample

ここで、関数@code{intermediate}は引数として@code{store}のアドレスを受け取る。 @code{intermediate}が@code{store}を呼び出す場合、@code{store}に与えられた引数は@code{array}に格納される。 しかし、このテクニックは、包含する関数（この例では@code{hack}）が終了しない限り動作する。

包含する関数が終了した後にネストされた関数をそのアドレスで呼び出そうとすると、すべての地獄が解放される。 スコープ・レベルが終了した後にコールしようとすると、スコープ・レベルがもはや存在しない変数の一部を参照している場合、幸運だったとしても、リスクを取るのは賢明ではない。 ただし、入れ子関数が範囲を外れたものを参照しない場合は、安全であるはずである。

GCCは、@dfn{trampolines}（トランポリン）と呼ばれる手法を使って入れ子関数のアドレスを取得する。 このテクニックは@cite{Lexical Closures for C ++}（Thomas M. Breuel、USENIX C ++ Conference Proceedings、1988年10月17-21日）に記述されている。

入れ子関数は、ラベルを含んでいる関数から継承したラベルにジャンプすることができる（ただし、ラベルは、その関数内で明示的に宣言されていなければならない@pxref {Local Labels}）。 このようなジャンプは、@code{goto}と中間関数を行ったネストされた関数を終了して、すぐに包含関数に戻る。 次に例を示す。

@smallexample
@group
bar (int *array, int offset, int size)
@{
  __label__ failure;
  int access (int *array, int index)
    @{
      if (index > size)
        goto failure;
      return array[index + offset];
    @}
  int i;
  /* @r{@dots{}} */
  for (i = 0; i < size; i++)
    /* @r{@dots{}} */ access (array, i) /* @r{@dots{}} */
  /* @r{@dots{}} */
  return 0;

 /* @r{Control comes here from @code{access}
    if it detects an error.}  */
 failure:
  return -1;
@}
@end group
@end smallexample

入れ子関数には常にリンケージはない。 @code{extern}または@code{static}で宣言するのは誤りである。 入れ子関数を定義する前に宣言する必要がある場合は、@code{auto}を使用する（関数宣言では意味がない）。

@smallexample
bar (int *array, int offset, int size)
@{
  __label__ failure;
  auto int access (int *, int);
  /* @r{@dots{}} */
  int access (int *array, int index)
    @{
      if (index > size)
        goto failure;
      return array[index + offset];
    @}
  /* @r{@dots{}} */
@}
@end smallexample

@node Constructing Calls
@section 関数呼び出しの構築
@cindex constructing calls
@cindex forwarding calls

以下に説明する組み込み関数を使用すると、関数が受け取った引数を記録し、引数の数や型を知らなくても、同じ引数を持つ別の関数を呼び出すことができる。

その関数呼び出しの戻り値を記録し、関数が返そうとしたデータ型がわからなくても（呼び出し元がそのデータ型を予期している限り）、後でその値を返すことができる。

しかし、これらの組み込み関数は、洗練された機能やその他の言語の拡張機能とうまく対話できないことがある。 したがって、単純なフォワーダとして機能する非常に単純な関数の外でそれらを使用することは推奨されない。

@deftypefn {Built-in Function} {void *} __builtin_apply_args ()
この組み込み関数は、現在の関数に渡されたのと同じ引数を使用して呼び出しを実行する方法を記述するデータへのポインターを返す。

この関数は、argポインタレジスタ、構造体値アドレス、および関数への引数をスタックに割り当てられたメモリブロックに渡すために使用されるすべてのレジスタを保存する。 次に、そのブロックのアドレスを返す。
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_apply (void (*@var{function})(), void *@var{arguments}, size_t @var{size})
この組み込み関数は、@var{arguments}と@var{size}で記述されたパラメータのコピーで@var{function}を呼び出す。

@var{arguments}の値は@code{__ builtin_apply_args}によって返された値でなければならない。 引数@var{size}はスタック引数データのサイズをバイト単位で指定する。

この関数は、@var{function}が返す値を返す方法を記述するデータへのポインタを返す。 データはスタックに割り当てられたメモリブロックに保存される。

@var{size}に適切な値を計算することは必ずしも簡単ではない。 この値は@code{__ builtin_apply}によってスタック上にプッシュされ、入ってくる引数領域からコピーされるべきデータの量を計算するために使われる。
@end deftypefn

@deftypefn {Built-in Function} {void} __builtin_return (void *@var{result})
この組み込み関数は、@var{result}で記述された値を含む関数から返された値を返す。 @code{__ builtin_apply}で返された値を@var{result}に指定する必要がある。
@end deftypefn

@deftypefn {Built-in Function} {} __builtin_va_arg_pack ()
この組み込み関数は、インライン関数のすべての無名引数を表す。@code{__attribute__((__always_inline__))}や@code{__attribute__((__gnu_inline__))}の外部インライン関数を使用するような、常にインライン関数でコンパイルされたインライン関数でのみ使用できる。可変引数を持つ他の関数の最後の引数として渡されなければならない。 これは、プリプロセッサマクロを使用することが望ましくない場合に、可変引数関数用の小さなラッパーインラインを記述するのに便利である。 例えば：
@smallexample
extern int myprintf (FILE *f, const char *format, ...);
extern inline __attribute__ ((__gnu_inline__)) int
myprintf (FILE *f, const char *format, ...)
@{
  int r = fprintf (f, "myprintf: ");
  if (r < 0)
    return r;
  int s = fprintf (f, format, __builtin_va_arg_pack ());
  if (s < 0)
    return s;
  return r + s;
@}
@end smallexample
@end deftypefn

@deftypefn {Built-in Function} {size_t} __builtin_va_arg_pack_len ()
この組み込み関数は、インライン関数の無名引数の数を返す。@code{__attribute__((__always_inline__))}や@code{__attribute__((__gnu_inline__))}の外部インライン関数を使用するような、常にインライン関数でコンパイルされたインライン関数でのみ使用できる。 たとえば、最適化されたコードのopen引数のリンクまたは実行時のチェックは次のようになる。
@smallexample
#ifdef __OPTIMIZE__
extern inline __attribute__((__gnu_inline__)) int
myopen (const char *path, int oflag, ...)
@{
  if (__builtin_va_arg_pack_len () > 1)
    warn_open_too_many_arguments ();

  if (__builtin_constant_p (oflag))
    @{
      if ((oflag & O_CREAT) != 0 && __builtin_va_arg_pack_len () < 1)
        @{
          warn_open_missing_mode ();
          return __open_2 (path, oflag);
        @}
      return open (path, oflag, __builtin_va_arg_pack ());
    @}

  if (__builtin_va_arg_pack_len () < 1)
    return __open_2 (path, oflag);

  return open (path, oflag, __builtin_va_arg_pack ());
@}
#endif
@end smallexample
@end deftypefn

@node Typeof
@section @code{typeof}で型へ参照する
@findex typeof
@findex sizeof
@cindex macros, types of arguments

式の型を参照する別の方法は@code {typeof}である。このキーワードを使用する構文は@code{sizeof}のように見えるが、構文は意味的に@code{typedef}で定義された型名のように機能する。

引数を@code{typeof}に書くには、式を使うか型を書くかの2つの方法がある。 次の式を使用した例を示す。

@smallexample
typeof (x[0](1))
@end smallexample

@noindent
これは、@code{x}が関数へのポインタの配列であることを前提としている。記述されている型は関数の値の型である。

引数としてtypenameを使用した例を次に示す。

@smallexample
typeof (int *)
@end smallexample

@noindent
ここで説明する型は@code{int}へのポインタの型である。

ISO Cプログラムに含まれているときに動作する必要があるヘッダファイルを作成する場合は、@code{typeof}の代わりに@code{__ typeof__}を記述する。
@xref{Alternate Keywords}.

@code{typeof}構文は、typedef名を使うことができるところならどこでも使うことができる。 たとえば、宣言、キャスト、または@code{sizeof}や@code {typeof}の内部で使用できる。

@code{typeof}のオペランドは、可変的に変更された型の式またはそのような型の名前である場合にのみ、その副作用を評価される。

@code{typeof}は、式文（@pxref {Statement Exprs}）と併用すると便利である。ここで2つの方法を組み合わせて、どの算術型でも動作し、それぞれの引数を正確に1回評価する安全な 「最大」'マクロを定義する方法を示す：

@smallexample
#define max(a,b) \
  (@{ typeof (a) _a = (a); \
      typeof (b) _b = (b); \
    _a > _b ? _a : _b; @})
@end smallexample

@cindex underscores in variables in macros
@cindex @samp{_} in variables in macros
@cindex local variables in macros
@cindex variables, local, in macros
@cindex macros, local variables in

ローカル変数に対してアンダースコアで始まる名前を使用する理由は、@code {a}と@code {b}の代わりに使用される式内で発生する変数名との競合を避けるためである。 最終的には、スコープが初期化子の後にのみ始まる変数を宣言できる新しい宣言構文を設計したいと考えている。 このような競合を防ぐより確実な方法になりだろう。

@noindent
@code {typeof}の使用に関するいくつかの例：

@itemize @bullet
@item
これは、@code{y}を@code{x}が指しているものの型で宣言する。

@smallexample
typeof (*x) y;
@end smallexample

@item
これは、そのような値の配列として@code{y}を宣言する。

@smallexample
typeof (*x) y[4];
@end smallexample

@item
これは、文字へのポインタの配列として@code{y}を宣言する。

@smallexample
typeof (typeof (char *)[4]) y;
@end smallexample

@noindent
これは、以下の従来のC宣言と同じである。

@smallexample
char *y[4];
@end smallexample

@code{typeof}を使用して宣言の意味を理解し、それがなぜ有用な方法であるのかを確認するには、次のマクロで書き直す。

@smallexample
#define pointer(T)  typeof(T *)
#define array(T, N) typeof(T [N])
@end smallexample

@noindent
これで宣言は次のように書き換えられる。

@smallexample
array (pointer (char), 4) y;
@end smallexample

@noindent
したがって、@code{array (pointer (char), 4)}は@code {char}への4つのポインタの配列の型である。
@end itemize

GNU C++ではなく、GNU Cでは、変数の型を@code{__auto_type}として宣言することもできる。 その場合、宣言はただ1つの変数を宣言しなければならない。宣言子は識別子でなければならず、宣言は初期化されなければならず、変数の型はイニシャライザによって決定される。 変数の名前は、イニシャライザの後までスコープ内にない。 （C++では、この目的のためにC++11 @code{auto}を使うべきである。）@code{__auto_type}を使うと、上の 「最大」マクロは以下のように書くことができる：

@smallexample
#define max(a,b) \
  (@{ __auto_type _a = (a); \
      __auto_type _b = (b); \
    _a > _b ? _a : _b; @})
@end smallexample

@code{typeof}の代わりに@code{__auto_type}を使うことには2つの利点がある：

@itemize @bullet
@item マクロへの各引数は、マクロの展開で一度だけ表示される。 これにより、そのようなマクロへの呼び出しがそのようなマクロの引数の中に入れ子になったときに、マクロ展開のサイズが指数関数的に増加するのを防ぐ。

@item マクロへの引数が可変的に変更された型の場合、@code{__auto_type}を使用する場合は1回だけ評価されるが、@code{typeof}を使用する場合は2回評価される。
@end itemize

@node Conditionals
@section 省略されたオペランドのある条件式
@cindex conditional expressions, extensions
@cindex omitted middle-operands
@cindex middle-operands, omitted
@cindex extensions, @code{?:}
@cindex @code{?:} extensions

条件式の中間のオペランドは省略することができる。 その時、第1オペランドがゼロ以外の場合、その値は条件式の値になる。

したがって、式

@smallexample
x ? : y
@end smallexample

@noindent
ゼロ以外の場合は、@code {x}の値を持つ。 それ以外の場合は、@code {y}の値となる。

この例は、以下と完全に等価である。

@smallexample
x ? x : y
@end smallexample

@cindex side effect in @code{?:}
@cindex @code{?:} side effect
@noindent
この単純なケースでは、中間のオペランドを省略することは特に有用ではない。 それが有用になるのは、最初のオペランドが副作用を持つ、または持つかもしれないときである。 その時、中間でオペランドを繰り返すと副作用が2回発生する。 中間のオペランドを省略すると、すでに計算された値が再計算の望ましくない影響なしに使用される。

@node __int128
@section 128ビット整数
@cindex @code{__int128} data types

拡張として、整数スカラー型@code {__int128}は、128ビットを保持するのに十分な整数モードを持つターゲットに対してサポートされている。符号なし128ビット整数の場合は@code{__ int128}、符号なし128ビット整数の場合は@code{unsigned __int128}と書くだけである。 GCCでは、@code{long long}整数が128ビット幅未満のターゲットに対して@code{__int128}型の整数定数を表現するためのサポートはない。

@node Long Long
@section 倍長整数
@cindex @code{long long} data types
@cindex double-word arithmetic
@cindex multiprecision arithmetic
@cindex @code{LL} integer suffix
@cindex @code{ULL} integer suffix

ISO C99は、少なくとも64ビット幅の整数のデータ型をサポートしている。拡張としてGCCはC90モードとC++でそれらをサポートしている。符号付き整数の場合は@code{long long int}、符号なし整数の場合は@code{unsigned long long int}と書くだけである。 @code{long long int}型の整数定数を作成するには、接尾辞@samp{LL}を整数に追加する。 @code{unsigned long long int}型の整数定数を作るには、接尾辞@samp{ULL}を整数に加える。

これらの型は、他の整数型のように算術演算で使用できる。これらの型に対する加算、減算、およびビット単位の論理演算は、すべてのタイプのマシンでオープンコード化されている。 マシンがフルワードからダブルワードへの拡大乗算命令をサポートしている場合、乗算はオープンコーディングされている。 除算とシフトは特別なサポートを提供するマシンでのみ開かれている。 オープンコーディングされていない操作では、GCCに付属する特別なライブラリルーチンが使用される。

関数のプロトタイプなしで関数の引数に@code{long long}型を使用すると、落とし穴が生じることがある。 関数がその引数に@code{int}型を期待していて、@code{long long int}型の値を渡すと、呼び出し元とサブルーチンが引数のバイト数について不一致になるので混乱が生じる。 同様に、関数が@code{long long int}を期待し、@code{int}を渡してもである。 このような問題を避ける最善の方法は、プロトタイプを使用することである。

@node Complex
@section 複素数
@cindex complex numbers
@cindex @code{_Complex} keyword
@cindex @code{__complex__} keyword

ISO C99は浮動小数点複素数データ型をサポートしていて、拡張としてGCCはC90モードとC++でそれらをサポートしている。 GCCは、ISO C99の一部ではない整数複素数データ型もサポートしている。 キーワード@code{_Complex}を使用して複素数型を宣言できる。 拡張として、古いGNUキーワード@code{__complex__}もサポートされている。

たとえば、@samp{_Complex double x;}は、実数部と虚数部の両方が@code{double}型の変数として@code{x}を宣言する。 @samp{_Complex short int y;}は、@code{y}が@code {short int}型の実数部と虚数部を持つことを宣言する。 これは有用ではない可能性があるが、複素数型のセットが完全であることを示している。

複雑なデータ型を持つ定数を書くには、接尾辞@samp{i}または@samp{j}（どちらか、それらは同等である）を使用する。 たとえば、@code{2.5fi}は@code{_Complex float}型を持ち、@code{3i}は@code{_Complex int}型を持つ。 このような定数は、常に純粋な虚数値を持つが、実定数を加えることで、好きな複素数を作ることができる。 これはGNU拡張である。 ISO C99に準拠したCライブラリ（GNU Cライブラリなど）を持ち、浮動小数点型の複素定数を構築したい場合は、@code{<complex.h>}をインクルードし、代わりに@code{I}または@code {_Complex_I}マクロを使うべきである。

@cindex @code{__real__} keyword
@cindex @code{__imag__} keyword
複素数値式@var {exp}の実数部を抽出するには、@code{__real__ @var{exp}}と書く。 同様に、@ code{__imag__}を使用して虚数部分を抽出する。 これはGNU拡張である。 浮動小数点型の値については、@code{<complex.h>}で宣言され、GCCの組み込み関数としても提供されているISO C99関数@code{crealf}、@code{creal}、@code{creall}、@code{cimagf}、@code{cimag}、@code{cimagl}を使うべきである。

@cindex complex conjugation
演算子@samp{~}は、複合型の値に使用されたときに複合共役を実行する。 これはGNU拡張である。 浮動小数点型の値については、@code{<complex.h>}で宣言され、GCCによって組み込み関数として提供されるISO C99関数@code {conjf}、@code {conj}と@code {conjl}を使うべきである。 

GCCは複素自動変数を不連続な方法で割り当てることができる。 虚数部がスタックにある一方、実数部がレジスタに入ることも可能である（またはその逆）。 DWARFデバッグ情報形式のみがこれを表すことができるので、DWARFを使用することを推奨する。 stabsデバッグ情報形式を使用している場合、GCCは、非コンプレックス型の2つの別々の変数であるかのように、非連続型複合変数を記述する。 変数の実際の名前が@code{foo}の場合、2つの架空の変数は@code{foo$real}と@code{foo$imag}という名前になる。 これらの2つの架空の変数は、デバッガで調べて設定できる。

@node Floating Types
@section 追加の浮動小数点型
@cindex additional floating types
@cindex @code{_Float@var{n}} data types
@cindex @code{_Float@var{n}x} data types
@cindex @code{__float80} data type
@cindex @code{__float128} data type
@cindex @code{__ibm128} data type
@cindex @code{w} floating point suffix
@cindex @code{q} floating point suffix
@cindex @code{W} floating point suffix
@cindex @code{Q} floating point suffix

ISO/IEC TS 18661-3：2015は、追加の浮動小数点型@code{_Float @var{n}}と@code{_Float @var{n}x}のCサポートを定義している。 サポートされる型のセットは、ターゲット・アーキテクチャーによって異なる。 これらの型は、C++のコンパイル時にはサポートされていない。これらの型の定数は、接尾辞@code{f@var{n}}または@code{F@var{n}}と@code{f@var{n}x}または@code{F@var{n}x}である。これらの型名は、@code {_Complex}とともに使用して、複素数型を宣言することができる。

拡張として、GNU CとGNU C++は、すべてのターゲットでサポートされていない追加の浮動型をサポートしている。

@itemize @bullet
@item @code{__ float128}は、i386、x86_64、IA-64、hppa HP-UX、およびベクトルスカラー（VSX）命令セットを有効にするPowerPC GNU/Linuxターゲットで利用できる。 @code{__ float128}は128ビット浮動型をサポートしている。 HP-UX以外のi386、x86_64、PowerPC、およびIA-64では、@code{__float128}は@code {_Float128}の別名である。hppaとIA-64 HP-UXでは、@code{__ float128}は@code{long double}の別名である。

@item @code{__float80}は、i386、x86_64、IA-64ターゲットで使用でき、80ビット（@code{XFmode}）浮動小数点型をサポートする。 これらのターゲット上のタイプ名@code {_Float64x}の別名である。

@item @code{__ ibm128}はPowerPCターゲットで使用でき、@code{long double}に使用される現在のフォーマットであるIBM拡張倍精度フォーマットへのアクセスを提供する。 将来、PowerPC上で@code{long double}が@code{__float128}に移行するとき、@code {__ ibm128}は2つのタイプ間の変換に使用される。
@end itemize

これらの追加タイプのサポートには、算術演算子が含まれる。加算、減算、乗算、除算; 単項算術演算子; 関係演算子; 等価演算子; 整数や他の浮動小数点型との変換などがある。 @code{__ float80}型及び@code{__ ibm128}型のリテラル定数に@samp{w}や@samp{W}の接尾辞を使用する。 @code{_float128}には、接尾辞@samp {q}または@samp {Q}を使用する。

PowerPC Linuxシステムで@code{_Float128}、@code{__ float128}、@code{__ ibm128}を使用するには、@option{-mfloat128}オプションを使用する必要がある。 GCCの将来のバージョンでは、@code{_Float128}と@code{__float128}が自動的に有効になることが期待される。

@code{_Float128}タイプは、@code{__float128}がサポートされているか、@code{long double}がIEEE binary128フォーマットを持つすべてのシステムでサポートされている。 @code{_Float64x}タイプは、@code{__ float128}がサポートされているすべてのシステムでサポートされている。 @code{_Float32}タイプは、IEEE binary32をサポートするすべてのシステムでサポートされている。 @code{_Float64}および@code{_Float32x}タイプは、IEEE binary64をサポートするすべてのシステムでサポートされている。 @code{_Float16}タイプは、デフォルトではAArch64システムでサポートされ、ARMシステムでは、@option{-mfp16-format = ieee}で16ビット浮動小数点タイプのIEEEフォーマットが選択されている場合にサポートされる。 GCCは現在、どのシステムでも@code{_Float128x}をサポートしていない。

i386、x86_64、IA-64、およびHP-UXターゲットでは、@code{__float80}型の@code{XCmode}と@code{__float128}型の@code{TCmode}を使用して、複素数型を宣言することができる：

@smallexample
typedef _Complex float __attribute__((mode(TC))) _Complex128;
typedef _Complex float __attribute__((mode(XC))) _Complex80;
@end smallexample

PowerPC Linux VSXターゲットでは、対応する内部複素数型@code{__ float128}型の@code{KCmode}と@code{__ibm128}型の@code {ICmode}を使用して複素数型を宣言できる。

@smallexample
typedef _Complex float __attribute__((mode(KC))) _Complex_float128;
typedef _Complex float __attribute__((mode(IC))) _Complex_ibm128;
@end smallexample

@node Half-Precision
@section 半精度浮動小数点型
@cindex half-precision floating point
@cindex @code{__fp16} data type

RMおよびAArch64ターゲットでは、GCCはARM C言語拡張で定義された@code{__ fp16}型を使用して、半精度（16ビット）浮動小数点をサポートしている。ARMシステムでは、この型を使用するには@option{-mfp16-format}コマンドラインオプションで明示的に有効にする必要がある。

ARMターゲットは、半精度の浮動小数点値に対して2つの互換性のない表現をサポートしている。 表現の1つを選択し、プログラムで一貫して使用する必要がある。

@option{-mfp16-format=ieee}を指定すると、IEEE 754-2008形式が選択される。この形式は、@math{2^{-14}}〜65504の範囲の正規化された値を表すことができる。有効精度は11ビット、10進数で約３桁である。

@option{-mfp16-format=alternative}を指定すると、ARM代替フォーマットが選択される。 この表現はIEEE形式に似ているが、無限またはNaNをサポートしていない。 代わりに指数の範囲が拡張され、この形式は@math{2^{-14}}から131008の範囲の正規化された値を表すことができる。

AArch64のGCCポートは、IEEE 754-2008フォーマットのみをサポートしているため、@option{-mfp16-format}コマンドラインオプションを使用する必要はない。

@code{__ fp16}型は、@code{<arm_fp16.h>}で定義された組み込み関数の引数として、または格納形式としてのみ使用できる。 算術演算およびその他の演算のために、CまたはC++式の@code {__ fp16}の値は自動的に@code{float}に昇格される。

ARMターゲットは、VFPおよびNEON（拡張SIMD）の拡張機能として@code{__ fp16}値と@code {float}値の間の変換をハードウェアでサポートし、ARMv8はハードウェアで@code{__ fp16}と@code{double}の値の変換をサポートする。GCCは、それらのハードウェア命令を提供するFPUを選択するオプションでコンパイルする場合、これらのハードウェア命令を使用してコードを生成する。 例えば、半精度形式を選択するための@option{-mfp16-format}オプションに加えて、@option{-mfpu=neon-fp16 -mfloat-abi=softfp}を使う。

@code{__ fp16}データ型の言語レベルのサポートは、GCCがハードウェア浮動小数点命令を使用してコードを生成するかどうかに依存しない。 ハードウェアのサポートが指定されていない場合、GCCは@code{__ fp16}と他の型との間の変換をライブラリ呼び出しとして実装する。

移植性のあるコードは、ISO / IEC TS 18661-3：2015で定義されている@code {_Float16}タイプを使用することを推奨する。 @xref{Floating Types}.

@node Decimal Float
@section 10進浮動小数点型
@cindex decimal floating types
@cindex @code{_Decimal32} data type
@cindex @code{_Decimal64} data type
@cindex @code{_Decimal128} data type
@cindex @code{df} integer suffix
@cindex @code{dd} integer suffix
@cindex @code{dl} integer suffix
@cindex @code{DF} integer suffix
@cindex @code{DD} integer suffix
@cindex @code{DL} integer suffix

拡張として、GNU Cは、ISO/IEC WDTR24732のN1312ドラフトで定義されているような、10進浮動小数点型をサポートしている。 テクニカルレポート草案の変更に伴い、GCCの10進浮動型のサポートが進化する。ターゲットの呼び出し規則も変更される可能性がある。 すべてのターゲットが10進浮動型をサポートしているわけではない。

10進浮動型は、@code{_Decimal32}、@code{_Decimal64}、@code{_Decimal128}である。 基数がC標準で指定されていないが通常は2である浮動小数点型@code{float}、@code{double}、@code{long double}とは異なり、10の基数を使用する。

小数浮動小数点型のサポートには、算術演算子の加算、減算、乗算、除算、単項算術演算子、関係演算子、等価演算子、整数や他の浮動小数点型との変換などがある。@code{_Decimal32}のリテラル定数の接尾辞には@samp{df}または@samp{DF}、@code{_Decimal64}には@samp {dd}または@samp {DD}、@code{_Decimal128}の場合は@samp {dl}と@samp{DL}を使う。

ドラフト技術レポートで指定されている小数点浮動小数点のGCCサポートは不完全である：

@itemize @bullet
@item
10進浮動小数点型の値を、それが変換される整数型で表現できない場合、結果は、技術報告書草案で指定された結果値ではなく、未定義である。

@item
GCCは、@file{math.h}、@file{fenv.h}、@file{stdio.h}、@file{stdlib.h}、および@file{wchar.h}に関連するCライブラリ機能を提供していない。 これは、別個のCライブラリ実装から来なければならない。このため、GNU Cコンパイラは、実装が技術レポートに準拠していることを示すためにマクロ@code{__STDC_DEC_FP__}を定義していない。
@end itemize

タイプ@code{_Decimal32}、@code{_Decimal64}、@code{_Decimal128}は、DWARFデバッグ情報フォーマットでサポートされている。

@node Hex Floats
@section 16進浮動小数点数
@cindex hex floats

ISO C99は、@code{1.55e1}のような通常の10進表記だけでなく、16進形式で書かれた@code{0x1.fp3}のような数字で書いた浮動小数点数もサポートしている。 GNU拡張として、GCCはこれをC90モード（厳密に準拠している場合を除く）とC++でサポートしている。 そのフォーマットでは、@samp{0x}16進数導入子と@samp{p}または@samp{P}指数フィールドは必須である。 指数は、有意な部分が乗算される2の累乗を示す10進数である。従って@samp {0x1.f}は
@tex
$1 {15\over16}$,
@end tex
@ifnottex
1 15/16,
@end ifnottex
@samp {p3}は8を乗じ、@code{0x1.fp3}の値は@code {1.55e1}と同じである。

10進表記の浮動小数点数とは異なり、指数は常に16進表記で必要である。 さもなければ、コンパイラは、例えば@code{0x1.f}のあいまい性を解決することができない。@samp{f}は@code{float}型の浮動小数点定数の拡張でもあるので、これは@code{1.0f}または@code{1.9375}を意味する。

@node Fixed-Point
@section 固定小数点型
@cindex fixed-point types
@cindex @code{_Fract} data type
@cindex @code{_Accum} data type
@cindex @code{_Sat} data type
@cindex @code{hr} fixed-suffix
@cindex @code{r} fixed-suffix
@cindex @code{lr} fixed-suffix
@cindex @code{llr} fixed-suffix
@cindex @code{uhr} fixed-suffix
@cindex @code{ur} fixed-suffix
@cindex @code{ulr} fixed-suffix
@cindex @code{ullr} fixed-suffix
@cindex @code{hk} fixed-suffix
@cindex @code{k} fixed-suffix
@cindex @code{lk} fixed-suffix
@cindex @code{llk} fixed-suffix
@cindex @code{uhk} fixed-suffix
@cindex @code{uk} fixed-suffix
@cindex @code{ulk} fixed-suffix
@cindex @code{ullk} fixed-suffix
@cindex @code{HR} fixed-suffix
@cindex @code{R} fixed-suffix
@cindex @code{LR} fixed-suffix
@cindex @code{LLR} fixed-suffix
@cindex @code{UHR} fixed-suffix
@cindex @code{UR} fixed-suffix
@cindex @code{ULR} fixed-suffix
@cindex @code{ULLR} fixed-suffix
@cindex @code{HK} fixed-suffix
@cindex @code{K} fixed-suffix
@cindex @code{LK} fixed-suffix
@cindex @code{LLK} fixed-suffix
@cindex @code{UHK} fixed-suffix
@cindex @code{UK} fixed-suffix
@cindex @code{ULK} fixed-suffix
@cindex @code{ULLK} fixed-suffix

GNU Cは、ISO/IEC DTR 18037のN1169草案で定義されている固定小数点型をサポートしている。GCCの固定小数点型のサポートは、技術報告書のドラフトが変更されるにつれて進化する。 ターゲットの呼び出し規則も変更される可能性がある。 すべてのターゲットが固定小数点タイプをサポートするわけではない。

固定小数点型は
@code{short _Fract},
@code{_Fract},
@code{long _Fract},
@code{long long _Fract},
@code{unsigned short _Fract},
@code{unsigned _Fract},
@code{unsigned long _Fract},
@code{unsigned long long _Fract},
@code{_Sat short _Fract},
@code{_Sat _Fract},
@code{_Sat long _Fract},
@code{_Sat long long _Fract},
@code{_Sat unsigned short _Fract},
@code{_Sat unsigned _Fract},
@code{_Sat unsigned long _Fract},
@code{_Sat unsigned long long _Fract},
@code{short _Accum},
@code{_Accum},
@code{long _Accum},
@code{long long _Accum},
@code{unsigned short _Accum},
@code{unsigned _Accum},
@code{unsigned long _Accum},
@code{unsigned long long _Accum},
@code{_Sat short _Accum},
@code{_Sat _Accum},
@code{_Sat long _Accum},
@code{_Sat long long _Accum},
@code{_Sat unsigned short _Accum},
@code{_Sat unsigned _Accum},
@code{_Sat unsigned long _Accum},
@code{_Sat unsigned long long _Accum}である。

固定小数点データ値には、小数部分とオプションの整数部分が含まれる。固定小数点データのフォーマットは、ターゲットマシンによって異なる。

固定小数点型のサポートはいかを含む。
@itemize @bullet
@item
前置と後置のインクリメント・デクリメント演算子 (@code{++}, @code{--})
@item
単項算術演算子 (@code{+}, @code{-}, @code{!})
@item
二項算術演算子 (@code{+}, @code{-}, @code{*}, @code{/})
@item
2進シフト演算子 (@code{<<}, @code{>>})
@item
関係演算子 (@code{<}, @code{<=}, @code{>=}, @code{>})
@item
等価演算子 (@code{==}, @code{!=})
@item
代入演算子 (@code{+=}, @code{-=}, @code{*=}, @code{/=}, @code{<<=}, @code{>>=})
@item
整数・浮動小数点数・固定小数点の相互変換
@end itemize

固定小数点リテラル定数の接尾辞には以下を使う。
@itemize
@item @code{short _Fract}と@code{_Sat short _Fract}には@samp{hr}または@samp{HR}
@item @code{_Fract}と@code{_Sat _Fract}には@samp{r}または@samp{R}
@item @code{long _Fract}と@code{_Sat long _Fract}には@samp{lr}または@samp{LR}
@item @code{long long _Fract}と@code{_Sat long long _Fract}には@samp{llr}または@samp{LLR}
@item @code{unsigned short _Fract}と@code{_Sat unsigned short _Fract}には@samp{uhr}または@samp{UHR}
@item @code{unsigned _Fract}と@code{_Sat unsigned _Fract}には@samp{ur}または@samp{UR}
@item @code{unsigned long _Fract}と@code{_Sat unsigned long _Fract}には@samp{ulr}または@samp{ULR}
@item @code{unsigned long long _Fract}と@code{_Sat unsigned long long _Fract}には@samp{ullr}または@samp{ULLR}
@item @code{short _Accum}と@code{_Sat short _Accum}には@samp{hk}または@samp{HK}
@item @code{_Accum}と@code{_Sat _Accum}には@samp{k}または@samp{K}
@item @code{long _Accum}と@code{_Sat long _Accum}には@samp{lk}または@samp{LK}
@item @code{long long _Accum}と@code{_Sat long long _Accum}には@samp{llk}または@samp{LLK}
@item @code{unsigned short _Accum}と@code{_Sat unsigned short _Accum}には@samp{uhk}または@samp{UHK}
@item @code{unsigned _Accum}と@code{_Sat unsigned _Accum}には@samp{uk}または@samp{UK}
@item @code{unsigned long _Accum}と@code{_Sat unsigned long _Accum}には@samp{ulk}または@samp{ULK}
@item @code{unsigned long long _Accum}と@code{_Sat unsigned long long _Accum}には@samp{ullk}または@samp{ULLK}
@end itemize

テクニカルレポート草案で指定された固定小数点型のGCCサポートは不完全である：

@itemize @bullet
@item
オーバーフローや丸めの動作を制御するプラグマは実装されていない。
@end itemize

固定小数点タイプは、DWARFデバッグ情報フォーマットでサポートされている。

@node Named Address Spaces
@section 名前付きアドレス空間
@cindex Named Address Spaces

拡張として、GNU Cは、ISO/IEC DTR 18037のN1275ドラフトで定義されている名前付きアドレス空間をサポートしている。GCCの名前付きアドレス空間のサポートは、テクニカルレポート草案の変更に伴い進化する。 ターゲットの呼び出し規則も変更される可能性がある。 現在、AVR、SPU、M32C、RL78、およびx86ターゲットのみが汎用アドレス空間以外のアドレス空間をサポートしている。

アドレス空間識別子は、他のC型修飾子（例えば、@code{const}や@code{volatile}など）と全く同じように使用できる。 詳細については、N1275のマニュアルを参照せよ。

@anchor{AVR Named Address Spaces}
@subsection AVR名前付きアドレス空間

AVRターゲットには、読み込み専用のデータをフラッシュメモリに格納し、そのフラッシュから読み込みに必要な特別な命令@code{LPM}または@code{ELPM}を使用してそのデータにアクセスするために使用できるいくつかのアドレス空間がある 。

デフォルトでは、読み出し専用データを含むデータはすべてRAM（汎用アドレス空間）に配置され、フラッシュメモリ内の読み出し専用データを検索し、@emph{_かつ_}アセンブラコードを使用せずにこのデータにアクセスするための正しい命令を生成するために非汎用アドレス空間が必要である。

@table @code
@item __flash
@cindex @code{__flash} AVR Named Address Spaces
@code{__ flash}修飾子は、データを@code{.progmem.data}セクションに配置する。 データは@code{LPM}命令を使用して読み込まれる。 このアドレス空間へのポインタは16ビット幅である。

@item __flash1
@itemx __flash2
@itemx __flash3
@itemx __flash4
@itemx __flash5
@cindex @code{__flash1} AVR Named Address Spaces
@cindex @code{__flash2} AVR Named Address Spaces
@cindex @code{__flash3} AVR Named Address Spaces
@cindex @code{__flash4} AVR Named Address Spaces
@cindex @code{__flash5} AVR Named Address Spaces
これらは、@code{.progmem@var{N}.data}セクションのデータを検索する16ビットのアドレス空間である。ここで、@var{N}はアドレス空間@code {__flash@var{N}}を指す。コンパイラは、@code{ELPM}命令でデータを読み取る前に、@code{RAMPZ}セグメントレジスタを適切に設定する。

@item __memx
@cindex @code{__memx} AVR Named Address Spaces
これは、フラッシュとRAMを線形化する24ビットのアドレス空間である。アドレスの上位ビットがセットされると、下位2バイトをRAMアドレスとしてRAMからデータが読み出される。アドレスの上位ビットがクリアされている場合、アドレスの上位バイトに従って@code{RAMPZ}がセットされた状態でフラッシュからデータが読み出される。
@xref{AVR Built-in Functions,,@code{__builtin_avr_flash_segment}}.

このアドレス空間のオブジェクトは@code{.progmemx.data}にある。
@end table

@b{例}

@smallexample
char my_read (const __flash char ** p)
@{
    /* pはフラッシュへのポインタを指すRAMへのポインタである。
        pの最初の間接指定はRAMからのフラッシュポインタを読み込み、
        2番目の間接指定はこのフラッシュアドレスからcharを読み込む。 */

    return **p;
@}

/* フラッシュメモリにarray[]を配置する */
const __flash int array[] = @{ 3, 5, 7, 11, 13, 17, 19 @};

int i = 1;

int main (void)
@{
   /* フラッシュメモリから読んで17を返す */
   return array[array[i]];
@}
@end smallexample

@noindent
avr-gccでサポートされている名前付きアドレス空間ごとに、同じ名前の大文字の組み込みマクロが定義されている。目的は、それぞれのアドレス空間のサポートが利用可能かどうかをテストすることである：

@smallexample
#ifdef __FLASH
const __flash int var = 1;

int read_var (void)
@{
    return var;
@}
#else
#include <avr/pgmspace.h> /* From AVR-LibC */

const int var PROGMEM = 1;

int read_var (void)
@{
    return (int) pgm_read_word (&var);
@}
#endif /* __FLASH */
@end smallexample

@noindent
属性@ref{AVR Variable Attributes,,@code{progmem}}はデータをフラッシュに配置するが、汎用アドレス空間（RAMなど）から読み込んだデータにアクセスするため、@w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC}}の@code{pgm_read_byte}などの特別なアクセサが属性@code {progmem}とともに必要になる。

@noindent
@b{制限と警告}

@itemize
@item
@code{__flash}または@code{__flash@var{N}}アドレス空間の64KiBセクション境界を読み取ることは、未定義の動作を示す。 64KiBフラッシュセグメントの境界を越えた読取りをサポートする唯一のアドレス空間は@code{__memx}である。

@item
@code{__flash@var{N}}アドレス空間の1つを使用する場合は、必要に応じて@code{.progmem@var{N}.data}セクションを見つけるためにリンカースクリプトを配置する必要がある。

@item
非汎用アドレス空間へのデータまたはポインタは、すべて@code{const}、すなわち読み取り専用データとしてとして修飾する必要がある。これは、ソフトウェアのバージョン番号やキャリブレーションルックアップテーブルのようなアドレス空間のいずれかのデータが、ブートローダなどのロード時間の後に変更されることが意図されている場合にも適用される。 この場合、正しい修飾は@code {const} @code{volatile}であるため、コンパイラは既知の値を最適化したり、命令のオペランドに即値として挿入したりしてはならない。

@item
次のコードは、静的ストレージにある変数@code{pfoo}を24ビットアドレスで初期化する。
@smallexample
extern const __memx char foo;
const __memx void *pfoo = &foo;
@end smallexample

@noindent
このようなコードには少なくともbinutils 2.23が必要である。@w{@uref{https://sourceware.org/PR13503,PR13503}}参照。

@item
ATtiny40のような縮小されたTinyデバイスでは、アドレススペースはサポートされていない。
属性@code{progmem}属性を使ってフラッシュメモリにデータを読み書きすることができる。@ref{AVR Variable Attributes}参照。

@end itemize

@subsection M32C名前付きアドレス空間
@cindex @code{__far} M32C Named Address Spaces

M32Cターゲットでは、R8CおよびM16C CPUのバリエーションでは、最初の64Kバイトを超えるメモリにアクセスするために、32ビットアドレスを使用して@code{__far}で修飾された変数にアクセスする。 @code{__far}をM32CMまたはM32C CPUのバリアントとともに使用すると、効果はない。

@subsection RL78名前付きアドレス空間
@cindex @code{__far} RL78 Named Address Spaces

RL78ターゲットでは、@code{__far}で修飾された変数は、デフォルトの16ビットアドレスではなく32ビットポインタ（20ビットアドレス）でアクセスされる。 非遠隔変数は、アドレス空間の最上位64KiBに現れると仮定する。

@subsection SPU名前付きアドレス空間
@cindex @code{__ea} SPU Named Address Spaces

SPUのターゲット変数は、タイプを@code{__ea}アドレス空間識別子で修飾することによって、別のアドレス空間に属するものとして宣言することができる。

@smallexample
extern int __ea i;
@end smallexample

@noindent 
コンパイラは変数@code{i}にアクセスするための特別なコードを生成する。ランタイムライブラリのサポートを使用したり、そのアドレス空間にアクセスするための特別なマシン命令を生成することができる。

@subsection x86名前付きアドレス空間
@cindex x86 named address spaces

x86ターゲットでは、変数は@code{％fs}または@code{％gs}セグメントとの相対的なものとして宣言できる。

@table @code
@item __seg_fs
@itemx __seg_gs
@cindex @code{__seg_fs} x86 named address space
@cindex @code{__seg_gs} x86 named address space
オブジェクトは、それぞれのセグメントオーバーライド接頭辞でアクセスされる。

それぞれのセグメントベースは、オペレーティングシステム固有のいくつかの方法で設定する必要がある。 セグメントベースを検索するために高価なシステムコールを必要とするのではなく、これらのアドレス空間は汎用（フラット）アドレス空間の部分空間であるとはみなされない。これは、これらのアドレス空間と汎用アドレス空間の間のポインタを変換するために明示的なキャストが必要であることを意味する。実際には、アプリケーションは@code{uintptr_t}にキャストし、以前にインストールしたセグメントベースオフセットを適用する必要がある。

プリプロセッサシンボル@code{__ SEG_FS}と@code{__ SEG_GS}は、これらのアドレス空間がサポートされているときに定義される。
@end table

@node Zero Length
@section 長さゼロの配列
@cindex arrays of length zero
@cindex zero-length arrays
@cindex length-zero arrays
@cindex flexible array members

長さがゼロの配列はGNU Cでは許されている。実際には可変長オブジェクトのヘッダである構造体の最後の要素として非常に便利である。

@smallexample
struct line @{
  int length;
  char contents[0];
@};

struct line *thisline = (struct line *)
  malloc (sizeof (struct line) + this_length);
thisline->length = this_length;
@end smallexample

ISO C90では、@code{contents}の長さを1にする必要がある。つまり、スペースを浪費したり、@code{malloc}の引数を複雑にすることになる。

ISO C99では、@dfn{flexible array member}（可変長配列メンバ）を使用する。これは構文とセマンティクスが少し異なる。

@itemize @bullet
@item
可変長配列メンバは@code{contents []}と、@code {0}なしで書かれている。

@item
可変長配列メンバは型が不完全なため、@code{sizeof}演算子は適用されてはならない。 ゼロ長配列の元々の実装では、@code {sizeof}はゼロに評価される。

@item
可変長配列メンバは@code {struct}の最後のメンバとして表示され、それ以外の場合は非空でなければならない。

@item
可変長配列メンバを含む構造体またはそのような構造体を含む共用体（おそらく再帰的に）は、配列の構造体または要素のメンバであってはならない。 （ただし、これらの用途はGCCによって拡張機能として許可される）。
@end itemize

ゼロ長配列の空でない初期化は、配列よりも多くの初期化要素がある場合と同様に扱われる。「配列の余分な要素」に関する適切な警告が与えられ、余分な要素（この場合すべて ）は無視される。

GCCでは、可変長配列メンバの静的初期化が可能である。これは、元の構造体を含む新しい構造体を定義し、続いてデータを格納するのに十分な大きさの配列を定義することと同じである。たとえば以下のように、@code{f1}は@code{f2}のように宣言されているかのように構築される。

@smallexample
struct f1 @{
  int x; int y[];
@} f1 = @{ 1, @{ 2, 3, 4 @} @};

struct f2 @{
  struct f1 f1; int data[3];
@} f2 = @{ @{ 1 @}, @{ 2, 3, 4 @} @};
@end smallexample

@noindent
この拡張の利便性は、@code{f1}が望ましい型を持っているので、一貫して@code{f2.f1}を参照する必要がなくなる。

これは、未知のサイズの配列も@code{[]}で書かれている点で、通常の静的配列と対称的である。

もちろん、この拡張は、トップレベルのオブジェクトの最後に余分なデータがある場合にのみ意味を持つ。それ以外の場合は、後続のオフセットでデータを上書きする。 過度のネストされた配列の初期化による過度の複雑化と混乱を避けるために、構造体がトップレベルオブジェクトである場合を除いて、空ではない初期化を単に許可しない。 例えば：

@smallexample
struct foo @{ int x; int y[]; @};
struct bar @{ struct foo z; @};

struct foo a = @{ 1, @{ 2, 3, 4 @} @};        // @r{Valid.}
struct bar b = @{ @{ 1, @{ 2, 3, 4 @} @} @};    // @r{Invalid.}
struct bar c = @{ @{ 1, @{ @} @} @};            // @r{Valid.}
struct foo d[1] = @{ @{ 1, @{ 2, 3, 4 @} @} @};  // @r{Invalid.}
@end smallexample

@node Empty Structures
@section メンバなしの構造体
@cindex empty structures
@cindex zero-size structures

GCCでは、C構造体にメンバを持たせないことができる：

@smallexample
struct empty @{
@};
@end smallexample

構造体のサイズはゼロである。 C++では、空の構造が言語の一部である。 G++は、空の構造体が@code{char}型の単一のメンバーを持つかのように扱う。

@node Variable Length
@section 可変長の配列
@cindex variable-length arrays
@cindex arrays of variable length
@cindex VLAs

ISO C99では可変長の自動配列が許可されていて、GCCはC90モードとC++でそれらを受け入れる。 これらの配列は他の自動配列と同様に宣言されるが、長さは定数式ではない。 記憶域は宣言のポイントに割り当てられ、宣言を含むブロックスコープが終了すると割り当てが解除される。 例えば：

@smallexample
FILE *
concat_fopen (char *s1, char *s2, char *mode)
@{
  char str[strlen (s1) + strlen (s2) + 1];
  strcpy (str, s1);
  strcat (str, s2);
  return fopen (str, mode);
@}
@end smallexample

@cindex scope of a variable length array
@cindex variable-length array scope
@cindex deallocating variable length arrays
配列名の範囲を飛び越したり抜けたりすると、記憶域の割り当てが解放される。 スコープにジャンプすることはできない。 そのためのエラーメッセージが表示される。

@cindex variable-length array in a structure
拡張として、GCCは可変長配列を構造体または共用体のメンバーとして受け入れる。 例えば：

@smallexample
void
foo (int n)
@{
  struct S @{ int x[n]; @};
@}
@end smallexample

@cindex @code{alloca} vs variable-length arrays
可変長配列によく似た効果を得るには、関数@code{alloca}を使うことができる。 関数@code{alloca}は他の多くのC実装で利用可能である（ただし、すべてではない）。 一方、可変長配列はよりエレガントである。

これらの2つの方法には他にも違いがある。 @code{alloca}で割り当てられたスペースは、それを含む@emph{_関数_}が返るまで存在する。可変長配列の空間は、このスコープで@code{alloca}も使用しない限り、配列名のスコープが終了するとすぐに割り当てから解放される。

関数の引数として可変長配列を使うこともできる：

@smallexample
struct entry
tester (int len, char data[len][len])
@{
  /* @r{@dots{}} */
@}
@end smallexample

配列の長さは、記憶域が割り当てられたときに1回計算され、@code{sizeof}でアクセスする場合には配列のスコープのために記憶される。

最初に配列を渡し、後に長さを渡す場合は、パラメータリストの前方宣言---別のGNU拡張を使用できる。

@smallexample
struct entry
tester (int len; char data[len][len], int len)
@{
  /* @r{@dots{}} */
@}
@end smallexample

@cindex parameter forward declaration
セミコロンの前の@samp{int len}は@dfn{parameter forward declaration}（パラメータの前方宣言）であり、@code {data}の宣言が解析されるときに、@code{len}という名前を知らせる目的に役立つ。

このようなパラメータの前方宣言は、パラメータリストに任意の数書くことができる。 それらはカンマまたはセミコロンで区切ることができるが、最後のものはセミコロンで終わらなければならない。その後に「実」パラメータ宣言が続く。 各前方宣言は、パラメータ名とデータ型の「実際の」宣言と一致しなければならない。 ISO C99では、パラメータの前方宣言はサポートされていない。

@node Variadic Macros
@section 可変長の引数を持つマクロ
@cindex variable number of arguments
@cindex macro with variable arguments
@cindex rest argument (in macro)
@cindex variadic macros

1999年のISO C標準では、マクロが関数のできる限り多くの引数を受け入れると宣言することができる。 マクロを定義する構文は、関数の構文に似ている。 次に例を示す。

@smallexample
#define debug(format, ...) fprintf (stderr, format, __VA_ARGS__)
@end smallexample

@noindent
@samp{@dots{}}は@dfn{variable argument}（可変引数）である。 このようなマクロの呼び出しでは、カンマを含めて呼び出しを終了する閉じ括弧まで0個以上のトークンを表す。 このトークンのセットは、マクロ本体の識別子@code{__ VA_ARGS__}を置き換える。 詳細については、CPPマニュアルを参照せよ。

GCCは可変長マクロを長い間サポートしていて、他の引数と同じように可変引数に名前を付けることを可能にする別の構文を使用していた。 次に例を示す。

@smallexample
#define debug(format, args...) fprintf (stderr, format, args)
@end smallexample

@noindent
これは、上記のISO Cの例とすべての点で同じだが、おそらく読みやすく記述的である。

GNU CPPにはさらに2つの可変長マクロ拡張があり、上記のマクロ定義のいずれかで使用することができる。

標準Cでは、可変引数を完全に除外することはできない。 空の引数を渡すことは許されている。 たとえば、この呼び出しはISO Cでは無効である。文字列の後にカンマがないためである。

@smallexample
debug ("A message")
@end smallexample

GNU CPPでは、このように可変引数を完全に省略することができる。 上記の例では、マクロの展開にフォーマット文字列の後に余分なカンマが残っているため、コンパイラは不平を言う。

この問題を解決するために、CPPはトークンペースト演算子@samp {##}で使用される可変引数に対して特別に動作する。 代わりにこう書く場合

@smallexample
#define debug(format, ...) fprintf (stderr, format, ## __VA_ARGS__)
@end smallexample

@noindent
そして可変引数が省略または空の場合、@samp{##}演算子はプリプロセッサに前のコンマを削除させる。 マクロ呼び出しでいくつかの可変引数を指定した場合、GNU CPPは貼り付け操作について不平を言わず、可変引数をカンマの後ろに置く。 貼り付けられた他のマクロ引数と同じように、これらの引数はマクロ展開されない。

@node Escaped Newlines
@section エスケープされた改行のためのややゆるい規則
@cindex escaped newlines
@cindex newlines (escaped)

エスケープされた改行のプリプロセッサ処理は、改行がバックスラッシュの直後に続くことを必要とするC90標準で指定されているものよりも緩やかである。GCCの実装では、空白、水平および垂直のタブ、およびバックスラッシュとそれに続く改行の間の書式フィードの形で空白を使用できる。 プリプロセッサは警告を出すが、有効なエスケープされた改行として扱い、2行を結合して1つの論理行を形成する。 これは、コメントとトークン、およびトークン間で機能する。 コメントはこのリラクゼーションの目的のために空白として扱われ@emph{_ない_}。なぜならそれらはまだスペースで置き換えられていないからである。

@node Subscripting
@section 非左辺値配列には添え字が付くことができる
@cindex subscripting
@cindex arrays, non-lvalue

@cindex subscripting and function values
ISO C99では、左辺値ではない配列はポインタに成り下がり、添え字付きになることができるが、変更、次のシーケンスポイントの後での使用、単項@samp{＆}演算子への適用は許されていない。 拡張として、GNU Cはそのような配列をC90モードで添え字にすることができるが、それ以外の場合はC99モード以外のポインタには成り下がらない。 例えば、これはGNU Cでは有効だが、C90では有効ではない：

@smallexample
@group
struct foo @{int a[4];@};

struct foo f();

bar (int index)
@{
  return f().a[index];
@}
@end group
@end smallexample

@node Pointer Arith
@section @code{void}と関数ポインタの算術
@cindex void pointers, arithmetic
@cindex void, size of pointer to
@cindex function pointers, arithmetic
@cindex function, size of pointer to

GNU Cでは、@code{void}へのポインタと関数へのポインタについて、加算と減算の操作がサポートされている。 これは、@code{void}や関数のサイズを1として扱うことによって行われる。

その結果、@code{sizeof}は@code{void}と関数型でも許され、1を返す。

@opindex Wpointer-arith
@option {-Wpointer-arith}オプションは、これらの拡張が使用されている場合に警告を要求する。

@node Pointers to Arrays
@section 修飾子付き配列へのポインタは期待どおりに動作する
@cindex pointers to arrays
@cindex const qualifier

GNU Cでは、修飾子を持つ配列へのポインタは、他の修飾された型へのポインタと同様の働きをする。 たとえば、@code{int(*)[5]}型の変数を使用して、@code{const int(*)[5]}型の変数を初期化することができる。これらの型はISO Cでは互換性がない。@code{const}修飾子は配列自体ではなく配列の要素型に正式に付けられているからである。

@smallexample
extern void
transpose (int N, int M, double out[M][N], const double in[N][M]);
double x[3][2];
double y[2][3];
@r{@dots{}}
transpose(3, 2, y, x);
@end smallexample

@node Initializers
@section 非定数初期化子
@cindex initializers, non-constant
@cindex non-constant initializers

標準C++やISO C99のように、自動変数の集約イニシャライザの要素は、GNU Cでは定数式である必要はない。実行時に変化する要素を持つイニシャライザの例を次に示す。

@smallexample
foo (float f, float g)
@{
  float beat_freqs[2] = @{ f-g, f+g @};
  /* @r{@dots{}} */
@}
@end smallexample

@node Compound Literals
@section 複合リテラル
@cindex constructor expressions
@cindex initializations in expressions
@cindex structures, constructor expression
@cindex expressions, constructor
@cindex compound literals
@c The GNU C name for what C99 calls compound literals was "constructor expressions".

複合リテラルは、中括弧で囲まれた集約初期化子リストのキャストのように見える。 その値は、初期化子で指定された要素を含むキャストで指定された型のオブジェクトである。キャストの結果とは異なり、複合リテラルは左辺値である。 ISO C99以降では複合リテラルをサポートしている。 拡張として、GCCはC90モードとC++でも複合リテラルをサポートしているが、後述するようにC++のセマンティクスは多少異なる。

通常、複合リテラルの指定された型は構造体である。 以下のように@code{struct foo}と@code{structure}が宣言されているとする。

@smallexample
struct foo @{int a; char b[2];@} structure;
@end smallexample

@noindent
複合リテラルで@code{struct foo}を構築する例を次に示す。

@smallexample
structure = ((struct foo) @{x + y, 'a', 0@});
@end smallexample

@noindent
これは、次の記述と同じである。

@smallexample
@{
  struct foo temp = @{x + y, 'a', 0@};
  structure = temp;
@}
@end smallexample

以下で説明するように、C++では危険だが、配列を作成することもできる。 複合リテラルのすべての要素が、静的記憶期間のオブジェクトのイニシャライザでの使用に適した簡単な定数式であれば、複合リテラルはその最初の要素へのポインタに強制され、そのようなイニシャライザで使用される。 ここに示すように：

@smallexample
char **foo = (char *[]) @{ "x", "y", "z" @};
@end smallexample

スカラ型と共用体型の複合リテラルも使用できる。 以下の例では、変数@code{i}は、複合リテラルによって作成された名前のないオブジェクトをインクリメントした結果、値@code{2}に初期化される。

@smallexample
int i = ++(int) @{ 1 @};
@end smallexample

GNUの拡張として、GCCはコンパイルリテラルによる静的な格納期間を持つオブジェクトの初期化を可能にする（初期化子は定数ではないためISO C99では不可能である）。 複合リテラルとオブジェクトの型が一致する場合は、中括弧で囲まれたリストでオブジェクトが初期化されたかのように扱われる。複合リテラルの要素は定数でなければならない。初期化されるオブジェクトの配列型が未知のサイズの場合、サイズは複合リテラルのサイズによって決まる。

@smallexample
static struct foo x = (struct foo) @{1, 'a', 'b'@};
static int y[] = (int []) @{1, 2, 3@};
static int z[] = (int [3]) @{1@};
@end smallexample

@noindent
上記の行は、次の行に相当する。
@smallexample
static struct foo x = @{1, 'a', 'b'@};
static int y[] = @{1, 2, 3@};
static int z[] = @{1, 0, 0@};
@end smallexample

Cでは、複合リテラルは、静的または自動記憶期間を持つ名前のないオブジェクトを指定する。 C++では、複合リテラルは、完全表現の終わりまで存続する一時オブジェクトを指定する。その結果、複合リテラルのサブオブジェクトのアドレスを取得する明確に定義されたCコードは、C++では未定義となるため、G++は一時配列のポインタへの変換を拒否する。たとえば、上記の配列の複合リテラルの例が関数内に現れた場合、C++で@code{foo}を使用すると、配列の寿命が@code{foo}の宣言の後で終わるため、未定義の動作になる。

最適化として、G++は、配列の複合リテラルの寿命を長くすることがある：配列が関数の外に出現するか、@ code{const}修飾型を持つ場合である。 @code{foo}とその初期化子が@code{char *}ではなく@code{char * const}型の要素を持っていた場合、または@code{foo}がグローバル変数であった場合、配列は静的な記憶期間を持つ。 しかし、おそらくC++コードで配列複合リテラルを使用しないようにするのが最も安全である。

@node Designated Inits
@section 指示付きの初期化子
@cindex initializers with labeled elements
@cindex labeled elements in initializers
@cindex case labels in initializers
@cindex designated initializers

標準C90では、イニシャライザの要素は、初期化される配列または構造体の要素の順序と同じ、固定された順序で表示する必要がある。

ISO C99では、配列のインデックスや構造体フィールド名を指定して任意の順序で要素を与えることができ、GNU CではこれをC90モードの拡張としても許可する。 この拡張はGNU C ++では実装されていない。

配列インデックスを指定するには、要素値の前に@samp{[@var{index}]=}を記述する。 例えば、

@smallexample
int a[6] = @{ [4] = 29, [2] = 15 @};
@end smallexample

@noindent
は以下と等価である。

@smallexample
int a[6] = @{ 0, 0, 15, 0, 29, 0 @};
@end smallexample

@noindent
初期化される配列が自動であっても、インデックス値は定数式でなければならない。

GCC 2.5以降では時代遅れとなったが、GCCがまだ受け入れている代替構文は、エレメント値の前に@samp{[@var{index}]}を書くことである。@samp{=}はない。

要素の範囲を同じ値に初期化するには、@samp{[@var{first}...@var{last}]=@var{value}}と記述する。 これはGNU拡張である。 例えば、

@smallexample
int widths[] = @{ [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 @};
@end smallexample

@noindent
その値に副作用がある場合、副作用は、初期化されたフィールドごとにではなく、範囲初期化子によって1回だけ発生する。

@noindent
配列の長さは指定された最大値+1であることに注意せよ。

構造体初期化子で、要素値の前に@samp {.@var{fieldname}=}で初期化するフィールドの名前を指定する。 例えば、以下の構造が与えられると、

@smallexample
struct point @{ int x, y; @};
@end smallexample

@noindent
以下の初期化子は

@smallexample
struct point p = @{ .y = yvalue, .x = xvalue @};
@end smallexample

@noindent
以下と等価である。

@smallexample
struct point p = @{ xvalue, yvalue @};
@end smallexample

同じ意味を持ち、GCC 2.5から廃止された別の構文@samp{@var{fieldname}:}では、ここに示すように：

@smallexample
struct point p = @{ y: yvalue, x: xvalue @};
@end smallexample

省略されたフィールドメンバは、静的格納期間を持つオブジェクトと同じように暗黙的に初期化される。

@cindex designators
@samp{[@var{index}]}や@samp{.@var{fieldname}}は@dfn{designator}（指定子）として知られている。 また、共用体を初期化するときに、指定子（または廃止されたコロン構文）を使用して、共用体のどの要素を使用するかを指定することもできる。 例えば、

@smallexample
union foo @{ int i; double d; @};

union foo f = @{ .d = 4 @};
@end smallexample

@noindent
2番目の要素を使用して4を@code{double}に変換して共用体に格納する。 対照的に、4を型@code{union foo}にキャストすると、それは整数なので整数@code{i}として共用体に格納される。@xref{Cast to Union}.

要素を命名するこの手法を、連続する要素の通常のC初期化と組み合わせることができる。 指定子を持たない各初期化子要素は、配列または構造体の次の連続する要素に適用される。 例えば、

@smallexample
int a[6] = @{ [1] = v1, v2, [4] = v4 @};
@end smallexample

@noindent
は以下と等価である。

@smallexample
int a[6] = @{ 0, v1, v2, 0, v4, 0 @};
@end smallexample

配列の初期化子の要素にラベルを付けることは、インデックスが文字であるか、@code{enum}型に属している場合に特に便利である。例えば：

@smallexample
int whitespace[256]
  = @{ [' '] = 1, ['\t'] = 1, ['\h'] = 1,
      ['\f'] = 1, ['\n'] = 1, ['\r'] = 1 @};
@end smallexample

@cindex designator lists
@samp{=}の前に一連の@samp{.@var{fieldname}}と@samp{[@var{index}]}を書くことで、ネストされたサブオブジェクトを指定して初期化することもできる。 そのリストは、最も近い周囲の中括弧対に対応するサブオブジェクトに関連して取られる。 たとえば、上記の@samp{struct point}宣言を使用すると、次のようになる。

@smallexample
struct point ptarray[10] = @{ [2].y = yv2, [2].x = xv2, [0].x = xv0 @};
@end smallexample

@noindent
同じフィールドが複数回初期化されている場合、最後の初期化の値を持つ。 そのような上書きされた初期化が副作用を持つ場合、副作用が発生するかどうかは不明である。 現在、GCCはそれらを破棄して警告を出す。

@node Case Ranges
@section Case範囲
@cindex case ranges
@cindex ranges in case statements

以下のように、単一の@code {case}ラベルに連続した値の範囲を指定することができる。

@smallexample
case @var{low} ... @var{high}:
@end smallexample

@noindent
これは@var {low}から@var {high}までの整数値ごとに1つずつ、個々の@code {case}ラベルの適切な数と同じ効果を持つ。

この機能は、ASCII文字コードの範囲で特に便利である。

@smallexample
case 'A' ... 'Z':
@end smallexample

@strong{注意:} @code {...}の周囲にスペースを入れること。そうしないと、整数値を使うときに間違って解釈される可能性がある。 たとえば、次のように記述する。

@smallexample
case 1 ... 5:
@end smallexample

@noindent
こうではなく：

@smallexample
case 1...5:
@end smallexample

@node Cast to Union
@section 共用体型へのキャスト
@cindex cast to a union
@cindex union, casting to a

共用体型へのキャストは、指定された型が共用体型であることを除いて、他のキャストと似ている。 型を@code{union}キーワードか、共用体を参照する@code {typedef}名で指定することができる。 共用体へのキャストは実際に複合リテラルを作成し、真のキャストのような右辺値ではなく左辺値を生成する。@xref{Compound Literals}.

共用体型にキャストされる型は、共用体のメンバーの型である。 したがって、以下の結合と変数が与えられているとすると

@smallexample
union foo @{ int i; double d; @};
int x;
double y;
@end smallexample

@noindent
@code{x}と@code{y}の両方を@code{union foo}へキャストすることができる。

共用体型の変数への代入の右辺としてのキャストを使用することは、共用体型のメンバーに格納することと同じである。

@smallexample
union foo u;
/* @r{@dots{}} */
u = (union foo) x  @equiv{}  u.i = x
u = (union foo) y  @equiv{}  u.d = y
@end smallexample

関数の引数としてユニオンキャストを使うこともできる：

@smallexample
void hack (union foo);
/* @r{@dots{}} */
hack ((union foo) x);
@end smallexample

@node Mixed Declarations
@section 宣言とコードの混在
@cindex mixed declarations and code
@cindex declarations, mixed with code
@cindex code, mixed with declarations

ISO C99およびISO C++では、複合宣言内で宣言とコードを自由に混在させることができる。 拡張として、GNU CではC90モードも可能である。 たとえば、次のようにすることができる。

@smallexample
int i;
/* @r{@dots{}} */
i++;
int j = i + 2;
@end smallexample

各識別子は、それが囲まれたブロックの終わりまで宣言されているところから見ることができる。

@node Function Attributes
@section 関数属性の宣言
@cindex function attributes
@cindex declaring attributes of functions
@cindex @code{volatile} applied to function
@cindex @code{const} applied to function

GNU Cでは、関数属性を使用して、プログラムで呼び出される関数について特定のものを宣言することができる。これは、コンパイラが呼び出しを最適化し、コードをより慎重にチェックするのに役立つ。 たとえば、属性を使用して関数が決して返されない（@code{noreturn}）、引数だけに依存する値を返す（@code{pure}）、または@code{printf}スタイルの引数@code{format}）。

また、属性を使用して、注釈を付ける関数内のメモリ配置、コード生成オプション、またはコール/リターン規則を制御することもできる。 これらの属性の多くはターゲット固有である。 たとえば、多くのターゲットでは、割り込みハンドラ関数を定義するための属性がサポートされている。これらの関数は、通常、特殊なレジスタの使用法とリターン規則に従わなければならない。

関数の属性は宣言の@code{__attribute__}キーワードによって導入され、その後に二重括弧で囲まれた属性指定が続く。 宣言で複数の属性を指定するには、ダブルカッコ内でコンマで区切るか、別の属性宣言で属性宣言の直後に記述する。 属性の構文と配置に関する正確な規則については、@xref{Attribute Syntax}を参照せよ。

GCCは変数宣言（@pxref{Variable Attributes}）、ラベル（@pxref{Label Attributes}）、列挙子（@pxref{Enumerator Attributes}）、文（@pxref{Statement Attributes}）、型（@pxref{Type Attributes}）の属性もサポートしている。

属性とプラグマの目的にはいくつかの重複がある（@pxref{Pragmas,,GCCで受け入れられるプラグマ}）。 @code {#pragma}は自然に文法の一部を形成しない他のコンパイラや構文との互換性のために使用されるが、@code{__attribute__}を使用して対応する宣言に属性を自然に付加することが便利であることがわかった。

ここに記述されている属性に加えて、GCCプラグインは独自の属性を提供することがある。

@menu
* Common Function Attributes::
* AArch64 Function Attributes::
* ARC Function Attributes::
* ARM Function Attributes::
* AVR Function Attributes::
* Blackfin Function Attributes::
* CR16 Function Attributes::
* Epiphany Function Attributes::
* H8/300 Function Attributes::
* IA-64 Function Attributes::
* M32C Function Attributes::
* M32R/D Function Attributes::
* m68k Function Attributes::
* MCORE Function Attributes::
* MeP Function Attributes::
* MicroBlaze Function Attributes::
* Microsoft Windows Function Attributes::
* MIPS Function Attributes::
* MSP430 Function Attributes::
* NDS32 Function Attributes::
* Nios II Function Attributes::
* Nvidia PTX Function Attributes::
* PowerPC Function Attributes::
* RL78 Function Attributes::
* RX Function Attributes::
* S/390 Function Attributes::
* SH Function Attributes::
* SPU Function Attributes::
* Symbian OS Function Attributes::
* V850 Function Attributes::
* Visium Function Attributes::
* x86 Function Attributes::
* Xstormy16 Function Attributes::
@end menu

@node Common Function Attributes
@subsection 共通関数属性

次の属性は、ほとんどのターゲットでサポートされている。

@table @code
@c Keep this table alphabetized by attribute name.  Treat _ as space.

@item alias ("@var{target}")
@cindex @code{alias} function attribute
@code{alias}属性は宣言を他のシンボルのエイリアスとして出力し、指定する必要がある。 例えば、

@smallexample
void __f () @{ /* @r{Do something.} */; @}
void f () __attribute__ ((weak, alias ("__f")));
@end smallexample

@noindent
は、@samp{f}が@samp{__f}の弱いエイリアスであると定義している。 C++では、ターゲットの変更された名前を使用する必要がある。 @samp{__f}が同じ翻訳単位で定義されていないと、エラーになる。

この属性には、アセンブラとオブジェクトファイルのサポートが必要である。また、すべてのターゲットで使用できるわけではない。

@item aligned (@var{alignment})
@cindex @code{aligned} function attribute
この属性は、関数の最小アラインメントをバイト単位で指定する。

この属性を使用して関数のアラインメントを減らすことはできない。 しかし、関数の配置を明示的に指定すると、この関数の@option{-falign-functions}（@pxref{Optimize Options}）オプションの効果が上書きされる。

@code{aligned}属性の有効性は、リンカの固有の制限によって制限されることに注意せよ。 多くのシステムでは、リンカは関数が特定の最大アラインメントまで整列するようにのみ調整することができる。 （一部のリンカでは、サポートされている最大のアラインメントは非常に小さいかもしれない）。詳細については、リンカのマニュアルを参照せよ。

@code{aligned}属性は、変数やフィールドにも使用できる（@pxref {Variable Attributes}。）

@item alloc_align
@cindex @code{alloc_align} function attribute
@code{alloc_align}属性は、関数の戻り値がメモリを指していることをコンパイラに知らせるために使用される。返されるポインタの最小アラインメントは、関数のパラメータの1つによって与えられる。 GCCは、この情報を使用してポインタのアラインメント解析を改善する。

割り当てられたアラインメントを示す関数パラメータは、整数の引数で指定される。その数は属性の引数である。引数の番号付けは1から始まる。

例えば、

@smallexample
void* my_memalign(size_t, size_t) __attribute__((alloc_align(1)))
@end smallexample

@noindent
@code {my_memalign}はパラメータ1によって与えられた最小整列でメモリを返すと宣言する。

@item alloc_size
@cindex @code{alloc_size} function attribute
@code{alloc_size}属性は、関数の戻り値がメモリを指していることをコンパイラに知らせるために使用される。サイズは関数のパラメータの1つまたは2つで与えられる。 GCCはこの情報を使って@code{__ builtin_object_size}の正しさを向上させる。

割り当てられたサイズを示す関数パラメータは、属性に供給される1つまたは2つの整数引数によって指定される。 割り当てられたサイズは、指定された単一の関数引数の値か、指定された2つの関数引数の積のいずれかである。 引数の番号付けは1から始まる。

例えば、

@smallexample
void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))
void* my_realloc(void*, size_t) __attribute__((alloc_size(2)))
@end smallexample

@noindent
@code{my_calloc}はパラメータ1と2の積によって与えられたサイズのメモリを返し、@code{my_realloc}はパラメータ2で与えられたサイズのメモリを返すと宣言する。

@item always_inline
@cindex @code{always_inline} function attribute
一般に、最適化が指定されない限り、関数はインライン化されない。インラインで宣言された関数の場合、この属性はインライン展開に適用される制限とは関係なく関数をインライン化する。このような機能をインライン化できない場合は、エラーと診断される。このような関数が間接的に呼び出された場合、コンパイラは最適化レベルに応じてインライン展開することも、インライン展開しないこともあり、間接呼び出しをインライン化できないかどうかは診断されることもない。

@item artificial
@cindex @code{artificial} function attribute
この属性は、可能であればデバッグ中にユニットとして表示されるべき小さなインラインラッパーに役立つ。 デバッグ情報のフォーマットに応じて、関数を人為的なものとしてマークするか、インラインボディ内のすべての命令に対して呼び出し元の位置を使用することを意味する。

@item assume_aligned
@cindex @code{assume_aligned} function attribute
@code{assume_aligned}属性は、関数の戻り値がメモリを指すことをコンパイラに伝えるために使用される。返されるポインタの最小アラインメントは最初の引数によって与えらる。 属性に2つの引数がある場合、2番目の引数は位置ずれオフセットである。

例えば、

@smallexample
void* my_alloc1(size_t) __attribute__((assume_aligned(16)))
void* my_alloc2(size_t) __attribute__((assume_aligned(32, 8)))
@end smallexample

@noindent
は、@code{my_alloc1}が16バイトにアラインメントされたポインタを返し、@code{my_alloc2}は32を法とする値が8に等しいポインタを返すと宣言する。

@item bnd_instrument
@cindex @code{bnd_instrument} function attribute
関数の@code{bnd_instrument}属性は、コンパイラに@option{-fchkp-instrument-marked-only}オプションを指定してコンパイルしたときに、関数を計装する必要があることをコンパイラに通知するために使用される。

@item bnd_legacy
@cindex @code{bnd_legacy} function attribute
@cindex Pointer Bounds Checker attributes
関数の@code{bnd_legacy}属性は、コンパイラに@option{-fcheck-pointer-bounds}オプションを指定してコンパイルしたときに、関数を計装してはならないことをコンパイラに通知するために使用される。

@item cold
@cindex @code{cold} function attribute
関数の@code{cold}属性は、関数が実行される可能性が低いことをコンパイラに通知するために使用される。関数はスピードではなくサイズに最適化される。多くのターゲットでは、テキストセクションの特別なサブセクションに配置されるため、すべてのコールド関数が近くに出力され、プログラムの非コールドパートのコードローカリティが向上する。コード内のコールド関数の呼び出しにつながるパスは、分岐予測メカニズムによってはそうでないとマークされる。したがって、@code{perror}のような、考えられない状況を処理するために使用される関数をcoldとしてマークして、まれにマーク関数を呼び出すホット関数の最適化を改善すると便利である。

@option{-fprofile-use}を介してプロファイルのフィードバックが利用可能になると、コールド関数が自動的に検出され、この属性は無視される。

@item const
@cindex @code{const} function attribute
@cindex functions that have no side effects
多くの関数は引数以外の値を調べず、戻り値以外の効果はない。 関数はグローバルメモリを読み込むことができないので、基本的にこれは下の@code{pure}属性よりもわずかに厳密なクラスである。

@cindex pointer arguments
ポインタ引数を持ち、指されるデータを調べる関数は、@code{const}と宣言されては@emph{_ならない_}ことに注意せよ。 同様に、非@code{const}関数を呼び出す関数は、通常は@code{const}であってはならない。 @code{const}関数が@code{void}を返すのは意味がない。

@item constructor
@itemx destructor
@itemx constructor (@var{priority})
@itemx destructor (@var{priority})
@cindex @code{constructor} function attribute
@cindex @code{destructor} function attribute
@code{constructor}属性は、実行が自動的に@code{main()}に入る前に呼び出される。 同様に、@code{destructor}属性は、@code{main()}が完了した後、または@code {exit()}が呼び出された後に関数が自動的に呼び出されるようにする。 これらの属性を持つ関数は、プログラムの実行中に暗黙的に使用されるデータを初期化するのに便利である。

オプションの整数優先順位を指定して、コンストラクタ関数とデストラクタ関数の実行順序を制御できる。より小さい優先順位番号を持つコンストラクタは、より大きな優先順位番号を持つコンストラクタの前で実行される。 反対の関係はデストラクタにも当てはまる。したがって、リソースを割り当てるコンストラクタと同じリソースを割り当て解除するデストラクタがある場合、通常は両方の関数の優先度が同じになる。コンストラクタとデストラクタ関数の優先順位は、名前空間スコープのC++オブジェクト（@pxref{C++ Attributes}）で指定されたものと同じである。しかし、現時点では、静的な記憶期間と属性@code{constructor}で装飾された関数を持つC++オブジェクトのコンストラクタが呼び出される順序は不定である。混合宣言では、属性@code{init_priority}を使用して特定の順序付けを行うことができる。

@item deprecated
@itemx deprecated (@var{msg})
@cindex @code{deprecated} function attribute
関数がソースファイルのどこでも使用されている場合、@code{deprecated}属性は警告を出す。 これは、将来のバージョンのプログラムで削除される予定の機能を識別する場合に便利である。 この警告には、非推奨機能の宣言の場所も含まれている。これにより、ユーザーは、その機能が廃止された理由、またはその代わりに何をすべきかに関する情報を簡単に見つけることができる。 警告は使用時にのみ発生することに注意せよ。

@smallexample
int old_fn () __attribute__ ((deprecated));
int old_fn ();
int (*fn_ptr)() = old_fn;
@end smallexample

@noindent
3行目では警告が出ますが、2行目では表示されない。文字列でなければならないオプションの@var{msg}引数は、警告があれば出力される。

@code{deprecated}属性は、変数と型（@pxref{Variable Attributes}、@ pxref{Type Attributes}）にも使用できる。

@item error ("@var{message}")
@itemx warning ("@var{message}")
@cindex @code{error} function attribute
@cindex @code{warning} function attribute
@code{error}属性や@code {warning}属性が関数宣言で使用され、そのような関数の呼び出しがデッドコードの削除やその他の最適化によって排除されない場合、@var{message}を含むエラー及び警告が診断される。これはコンパイル時のチェック、特に@code{__builtin_constant_p}およびインライン関数の引数のチェックがトリック@code{extern char [(condition) ? 1 : -1];}では不可能なインライン関数に便利である。

関数を未定義のままにしてリンクエラーを引き起こすことは可能だが（@code {.gnu.warning *}セクションのメッセージで関数を定義する）、これらの属性を使用すると、インライン関数が存在する場合でも、デバッグ情報を出力しない場合でも、問題が早期に診断され、呼び出しの正確な位置で診断される。

@item externally_visible
@cindex @code{externally_visible} function attribute
グローバル変数または関数に付加されたこの属性は、@option{-fwhole-program}コマンドラインオプションの効果を無効にして、オブジェクトは現在のコンパイル単位の外側に表示されたままになる。

@option{-fwhole-program}を@option{-flto}と一緒に使用し、@command{gold}をリンカプラグインとして使用すると、@code{externally_visible}属性が関数に自動的に追加される。 @command{gold}によって生成された解決ファイルに従って、LTOオブジェクトの外部からアクセスされる。解決ファイルを生成できない他のリンカーに対しては、明示的な@code{externally_visible}属性が必要である。

@item flatten
@cindex @code{flatten} function attribute
一般に、関数へのインライン展開は限られている。 この属性でマークされた関数の場合、可能であれば、この関数内のすべての呼び出しがインライン展開される。関数自体がインライン展開の対象かどうかは、そのサイズと現在のインライン化パラメータによって異なる。

@item format (@var{archetype}, @var{string-index}, @var{first-to-check})
@cindex @code{format} function attribute
@cindex functions with @code{printf}, @code{scanf}, @code{strftime} or @code{strfmon} style arguments
@opindex Wformat
@code{format}属性は、関数がフォーマット文字列に対して型チェックされるべき@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}スタイルの引数をとることを指定する。 たとえば、次のような宣言があると、

@smallexample
extern int
my_printf (void *my_object, const char *my_format, ...)
      __attribute__ ((format (printf, 2, 3)));
@end smallexample

@noindent
コンパイラは@code{printf}形式の書式文字列引数@code{my_format}と一貫性を保つために@code{my_printf}への呼び出しで引数をチェックする。

パラメータ@var{archetype}はフォーマット文字列がどのように解釈されるかを決定し、@code{printf}、 @code{scanf}、 @code{strftime}、 @code{gnu_printf}、 @code{gnu_scanf}、 @code{gnu_strftime}、 @code{strfmon}のどれかである。 (@code{__printf__}、 @code{__scanf__}、 @code{__strftime__}、 @code{__strfmon__}を使うこともできる。)  MinGWターゲットでは、@code{ms_printf}、@code{ms_scanf}、@code{ms_strftime}も存在する。@code{printf}のような@var{archetype}の値は、システムのCランタイムライブラリが受け入れる形式を参照し、@samp{gnu_}が付いた値は常にGNU Cライブラリが受け入れた形式を参照する。Microsoft Windowsターゲットでは、@samp{ms_}という接頭辞の付いた値は、@file{msvcrt.dll}ライブラリで受け入れられる形式を参照する。@var{string-index}は、書式文字列の引数（1から始まる）を指定する。@var{first-to-check}は、書式文字列に対してチェックする最初の引数の番号である。引数がチェックできない関数（@code{vprintf}など）の場合は、3番目のパラメータをゼロとして指定する。 この場合、コンパイラは一貫性のために書式文字列のみをチェックする。 @code{strftime}形式の場合、3番目のパラメータはゼロにする必要がある。非静的なC++メソッドは暗黙の@code{this}引数を持つので、@var{string-index}と@var{first-to-check}の値を与えるときには、そのようなメソッドの引数を１ではなく2から数えてカウントする必要がある。

上記の例では、フォーマット文字列（@code{my_format}）は関数@code{my_print}の2番目の引数であり、チェックする引数は3番目の引数で始まるので、format属性の正しいパラメータは2と3である。

@opindex ffreestanding
@opindex fno-builtin
@code{format}属性を使うと、書式文字列を引数とする独自の関数を識別することができ、GCCはこれらの関数の呼び出しをエラーでチェックできる。 （@option{-freestanding}や@option{-fno-builtin}を使用しない限り）コンパイラは常に標準ライブラリ関数@code{printf}、 @code{fprintf}、 @code{sprintf}、 @code{scanf}、 @code{fscanf}、 @code{sscanf}、 @code{strftime}、 @code{vprintf}、 @code{vfprintf}、@code{vsprintf} ）をチェックするので、ヘッダファイル@file{stdio.h}を変更する必要はない。C99モードでは、関数@code{snprintf}、@code{vsnprintf}、@code{vscanf}、@code{vfscanf}、@code{vsscanf}もチェックされる。 厳密に準拠しているC標準モードを除いて、X/Open関数@code{strfmon}、@code{printf_unlocked}、@code{fprintf_unlocked}もチェックされる。@xref{C Dialect Options,,C変種を制御するオプション}。

Objective-C変種の場合、@code{NSString}（または@code{__ NSString__}）は同じコンテキストで認識される。 これらの書式属性を含む宣言は正しい構文で解析されるが、そのような書式文字列のチェック結果はまだ定義されていないため、このバージョンのコンパイラでは実行されない。

ターゲットは、追加のタイプのフォーマットチェックを提供することもできる。@xref{Target Format Checks,,特定のターゲット機種に固有の書式チェック}。

@item format_arg (@var{string-index})
@cindex @code{format_arg} function attribute
@opindex Wformat-nonliteral
@code{format_arg}属性は、関数が@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}スタイル関数の書式文字列を取り、それを変更する（たとえば、 その結果を言語へと翻訳する）ことを指定し、@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}スタイル関数に渡すことができるようになる（書式関数の残りの引数は 変更されていない文字列の場合と同じである）。 たとえば、次のような宣言があると：

@smallexample
extern char *
my_dgettext (char *my_domain, const char *my_format)
      __attribute__ ((format_arg (2)));
@end smallexample

@noindent
コンパイラは、@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}型関数の呼び出しで引数をチェックする。書式文字列の引数は、@code{ my_dgettext}関数を使用して、書式文字列引数@code{my_format}と一貫性を保つ。@code{format_arg}属性が指定されていない場合、 書式関数へのそのような呼び出しに対してコンパイラが伝えることができるすべてのことは、フォーマット文字列の引数が定数ではないことである。@option{-Wformat-nonliteral}が使用されているときに警告が生成されるが、属性なしでは呼び出しをチェックすることはできない。

パラメータ@var{string-index}は、どの引数が書式文字列引数（1から始まる）かを指定する。 非静的なC++のメソッドは暗黙の@code{this}引数を持つので、そのようなメソッドの引数は2つから数える必要がある。

@code{format_arg}属性を使うと、書式文字列を変更する独自の関数を識別することができる。これにより、GCCはオペランドが自分の関数の呼び出しである@code{printf}、 @code{scanf}、@code{strftime}、@code{strfmon}型の関数への呼び出しをチェックできる。コンパイラは、@option{-ansi}および適切な@option{-std}オプションによって厳密なISO Cサポートが要求される場合、または@option{-freestanding}および@option {-fno-builtin}が使用される場合を除いて、この方法で@code{gettext}、@code{dgettext}、@code{dcgettext}を扱う。@xref{C Dialect Options,,C変種を制御するオプション}。

Objective-C変種の場合、@code{format-arg}属性は上記の@code{format}属性との互換性のために@code{NSString}参照を参照することがある。

ターゲットは@code{format-arg}属性で追加の型を許可するかもしれない。@xref{Target Format Checks,,特定のターゲット機種に固有の書式チェック}。

@item gnu_inline
@cindex @code{gnu_inline} function attribute
この属性は、@code{inline}キーワードも宣言されている関数で使用する必要がある。 GCCは、C99またはgnu99モードでコンパイルしていてもgnu90モードで定義されているかのように関数を扱うように指示する。

関数が@code{extern}と宣言されている場合、この関数の定義はインライン化にのみ使用される。関数がスタンドアロン関数としてコンパイルされることはない。たとえそのアドレスを明示的に指定したとしても、関数はコンパイルされない。
  このようなアドレスは、あたかも関数を宣言していて、定義していないかのように、外部参照になる。これはほとんどマクロの効果である。 これを使用する方法は、この属性を持つヘッダファイルに関数定義を置き、関数の別のコピーを@code{extern}なしでライブラリファイルに置くことである。ヘッダーファイルの定義によって、関数へのほとんどの呼び出しがインライン化される。 関数の使用が残っている場合は、ライブラリ内の単一のコピーを参照する。関数の2つの定義は正確に同じである必要はないが、同じ効果を持たなければプログラムが奇妙に動作する可能性がある。

Cでは、関数が@code{extern}でも@code{static}でもない場合、関数はスタンドアロン関数としてコンパイルされ、可能な限りインライン化される。

これは、GCCが伝統的に@code{inline}と宣言された関数をどのように扱うかを示している。 ISO C99では@code{inline}には異なるセマンティクスが指定されているので、この関数属性は遷移の指標として提供され、それ自体の有用な機能として提供される。 この属性はGCC 4.1.3以降で利用可能である。 プリプロセッサマクロ@code{__GNUC_GNU_INLINE__}または@code{__GNUC_STDC_INLINE__}のいずれかが定義されている場合に使用できる。

C++では、この属性は決して@code{extern}に依存しないが、特別な動作を可能にするためにはまだ@code{inline}キーワードが必要である。

@item hot
@cindex @code{hot} function attribute
関数の@code{hot}属性は、関数がコンパイルされたプログラムのホットスポットであることをコンパイラに知らせるために使用される。 この関数はより積極的に最適化され、多くのターゲットではテキストセクションの特別なサブセクションに配置されるので、すべてのホット関数が近くに出力され、地域性が向上する。

@option{-fprofile-use}を介してプロファイルのフィードバックが利用可能になると、ホット機能が自動的に検出され、この属性は無視される。

@item ifunc ("@var{resolver}")
@cindex @code{ifunc} function attribute
@cindex indirect functions
@cindex functions that are dynamically resolved
@code{ifunc}属性は、関数をELF標準へのSTT_GNU_IFUNCシンボル型拡張を使用して間接関数としてマークするために使用される。 これにより、ロード時にシンボル値の分解能を動的に決定することができ、最適化されたバージョンのルーチンを特定のプロセッサまたはそれ以外のシステム特性に対して選択することができる。この属性を使用するには、まず使用可能な実装関数を定義し、選択された実装関数へのポインタを返すリゾルバ関数を定義する。 実装関数の宣言は実装されている関数のAPIと一致していなければならない。リゾルバの宣言はvoid返すvoid関数へのポインタを返す関数になる：

@smallexample
void *my_memcpy (void *dst, const void *src, size_t len)
@{
  @dots{}
@}

static void (*resolve_memcpy (void)) (void)
@{
  return my_memcpy; // we'll just always select this routine
@}
@end smallexample

@noindent
ユーザーが呼び出す関数を宣言したエクスポートされたヘッダーファイルには次のものが含まれる。

@smallexample
extern void *memcpy (void *, const void *, size_t);
@end smallexample

@noindent
これにより、ユーザーは実装を認識しない通常の関数としてこれを呼び出すことができる。 最後に、間接関数をリゾルバ関数と同じ翻訳単位で定義する必要がある。

@smallexample
void *memcpy (void *, const void *, size_t)
     __attribute__ ((ifunc ("resolve_memcpy")));
@end smallexample

間接関数を弱めることはできない。 この機能を使用するには、Binutilsバージョン2.20.1以降およびGNU Cライブラリバージョン2.11.1が必要である。

@item interrupt
@itemx interrupt_handler
多くのGCCバックエンドは、関数が割り込みハンドラであることを示す属性をサポートしている。これは、コンパイラが通常の関数とは異なる関数の入力および終了シーケンスを生成するように指示する。 正確な構文と動作はターゲット固有である。 詳細については、以下のサブセクションを参照せよ。

@item leaf
@cindex @code{leaf} function attribute
この属性を持つ外部関数への呼び出しは、リターンまたは例外処理によってのみ現在のコンパイル単位に戻されなければならない。特に、リーフ関数は、現在のコンパイル単位から渡されたコールバック関数を呼び出すこと、コンパイル単位によってエクスポートされた関数を直接呼び出すこと、またはコンパイル単位へと@code{longjmp}することはできない。 リーフ関数は他のコンパイル単位から関数を呼び出すかもしれないので、関数呼び出しをまったく含まないという意味で必ずしもリーフ関数ではない。

この属性は、ライブラリ関数がデータフロー解析を改善することを目的としている。コンパイラーは、現在のコンパイル単位を脱出しないデータは、リーフ関数で使用または変更できないというヒントを取る。 たとえば、@code{sin}関数はリーフ関数だが、@code{qsort}はリーフ関数ではない。

リーフ関数は、静的変数を使用する現在のコンパイル単位で定義されたシグナルハンドラを間接的に実行する可能性があることに注意せよ。同様に、遅延シンボル解決が有効な場合、リーフ関数は、リゾルバ関数または実装関数が現在のコンパイル単位で定義され、静的変数を使用する間接関数を呼び出すことがある。 このようなシグナルハンドラ、リゾルバ関数、または実装関数を書く標準に準拠した方法はなく、@code{leaf}属性を削除するか、そのような静的変数をすべて@code{volatile}とマークすることができる。最後に、シンボルの挿入をサポートするELFベースのシステムでは、現在のコンパイル単位で定義された関数が、定義された標準モードと定義された機能テストマクロに基づいて他のシンボルを予期せず挿入することに注意しなければならない。 そうしないと偶発的なコールバックが追加される。

この属性は、現在のコンパイル単位内で定義された関数には影響しない。 これは、例えば、リンク時の最適化を使用することによって、複数のコンパイル単位を1つに簡単にマージすることができる。 このため、間接呼び出しに注釈を付ける型では属性を使用できない。

@item malloc
@cindex @code{malloc} function attribute
@cindex functions that behave like malloc
これは、関数が@code {malloc}のようなものであることをコンパイラに伝える。すなわち、関数によって返されたポインタ@var{P}は、関数が返ったときに有効な他のポインタをエイリアスできず、 正当なオブジェクトへのどんなポインタも@var{P}で扱われる任意の記憶域を占めることはない。

この属性を使用すると、最適化が向上する。 @code{malloc}や@code{calloc}のような関数は、初期化されていない、またはゼロアウトしたストレージへのポインタを返すので、このプロパティを持っている。 しかし、@ code{realloc}のような関数は、ポインタを含む記憶域へのポインタを返すことができるので、このプロパティを持たない。

@item no_icf
@cindex @code{no_icf} function attribute
この関数属性は、関数が他の意味的に同等の関数とマージされることを防ぐ。

@item no_instrument_function
@cindex @code{no_instrument_function} function attribute
@opindex finstrument-functions
@option{-finstrument-functions}を指定すると、ユーザがコンパイルしたほとんどの関数の入口と出口でプロファイリング関数呼び出しが生成される。この属性を持つ関数は計装されない。

@item no_profile_instrument_function
@cindex @code{no_profile_instrument_function} function attribute
関数の@code{no_profile_instrument_function}属性は、プロファイルフィードバックに基づく最適化コード計測を処理すべきでないことをコンパイラーに通知するために使用される。

@item no_reorder
@cindex @code{no_reorder} function attribute
@code{no_reorder}とマークされた関数や変数を互いに並べ替えたり、トップレベルのアセンブラ文を実行可能ファイルと並べ替えたりしない。プログラムの実際の順序は、リンカーのコマンドラインによって異なる。 このようにマークされた静的変数も削除されない。これは@option{-fno-toplevel-reorder}オプションと同様の効果を持つが、マークされたシンボルにのみ適用される。

@item no_sanitize_address
@itemx no_address_safety_analysis
@cindex @code{no_sanitize_address} function attribute
関数の@code {no_sanitize_address}属性は、@option{-fsanitize=address}オプションを指定してコンパイルするときに関数内でメモリアクセスを計測しないようにコンパイラに通知するために使用される。@code{no_address_safety_analysis}は非推奨の@code{no_sanitize_address}属性のエイリアスである。新しいコードでは@code{no_sanitize_address}を使用するべきである。

@item no_sanitize_thread
@cindex @code{no_sanitize_thread} function attribute
関数の@code{no_sanitize_thread}属性は、コンパイラに@option{-fsanitize = thread}オプションを指定してコンパイルするときに関数内でメモリアクセスを計測すべきでないことをコンパイラに通知するために使用される。

@item no_sanitize_undefined
@cindex @code{no_sanitize_undefined} function attribute
関数の@code{no_sanitize_undefined}属性は、コンパイラが@option{-fsanitize=undefined}オプションを使用してコンパイルするときに、関数内の未定義の動作をチェックしないことをコンパイラに通知するために使用される。

@item no_split_stack
@cindex @code{no_split_stack} function attribute
@opindex fsplit-stack
@option{-fsplit-stack}を指定した場合、関数はスタックを分割するかどうかを決定する小さなプロローグを持つ。 @code{no_split_stack}属性を持つ関数は、そのプロローグを持たないため、使用可能なスタックスペースがわずかしかなくても実行できる。

@item no_stack_limit
@cindex @code{no_stack_limit} function attribute
この属性は、@option{-fstack-limit-register}および@option{-fstack-limit-symbol}のコマンドラインオプションを局所的に上書きする。 それに適用される関数でスタック制限チェックを無効にするという効果がある。

@item noclone
@cindex @code{noclone} function attribute
この関数属性は、関数の特殊なコピーを生成し、手続き間の定数伝搬によって（現在）実行されている機構である、クローニングのために関数が考慮されないようにする。

@item noinline
@cindex @code{noinline} function attribute
この関数属性は、関数がインライン展開のために考慮されないようにする。
@c Don't enumerate the optimizations by name here; we try to be
@c future-compatible with this mechanism.
関数が副作用を持たない場合は、インライン化以外の最適化があり、関数呼び出しがライブであるにもかかわらず、最適化された関数呼び出しを引き起こす。 そのような呼び出しが最適化されないようにするには、以下を置く。
@smallexample
asm ("");
@end smallexample

@noindent
(@pxref{Extended Asm})は特別な副作用として機能するために、呼び出された関数内で使用される。

@item nonnull (@var{arg-index}, @dots{})
@cindex @code{nonnull} function attribute
@cindex functions with non-null pointer arguments
@code{nonnull}属性は、いくつかの関数のパラメータがnull以外のポインタであることを指定する。 例えば、宣言は：

@smallexample
extern void *
my_memcpy (void *dest, const void *src, size_t len)
        __attribute__((nonnull (1, 2)));
@end smallexample

@noindent
は、コンパイラが@code{my_memcpy}への呼び出しで引数@var{dest}と@var{src}がnullでないことをチェックさせる。 コンパイラーが、ヌルポインターが非ヌルとしてマークされた引数スロットに渡され、@option{-Wnonnull}オプションが有効であると判断すると、警告が発行される。 コンパイラは、特定の関数の引数が決してnullにならないという知識に基づいて最適化を行うこともできる。

引数インデックスリストが@code{nonnull}属性に与えられない場合、すべてのポインタ引数はnull以外としてマークされる。 例として、次の宣言は前の例と同じである。

@smallexample
extern void *
my_memcpy (void *dest, const void *src, size_t len)
        __attribute__((nonnull));
@end smallexample

@item noplt
@cindex @code{noplt} function attribute
@code{noplt}属性は、オプション@option{-fno-plt}に対応している。位置に依存しないコードでこの属性でマークされた関数を呼び出すと、PLTは使用されない。

@smallexample
@group
/* Externally defined function foo.  */
int foo () __attribute__ ((noplt));

int
main (/* @r{@dots{}} */)
@{
  /* @r{@dots{}} */
  foo ();
  /* @r{@dots{}} */
@}
@end group
@end smallexample

関数@code{foo}の@code{noplt}属性は、コンパイラに関数@code{foo}が外部的に定義されていると仮定し、@code{foo}への呼び出しは位置に依存しないコードでPLTを避けなければならないと伝える。

位置依存コードでは、いくつかのターゲットは、GOTを代わりに使用するためにPLTを使用しないようにマークされた関数に呼び出しを変換する。

@item noreturn
@cindex @code{noreturn} function attribute
@cindex functions that never return
@code{abort}や@code {exit}のようないくつかの標準ライブラリ関数は返らない。 GCCはこれを自動的に認識する。 一部のプログラムは、決して戻ってこない独自の関数を定義している。 コンパイラにこの事実を伝えるために@code{noreturn}を宣言することができる。 例えば、

@smallexample
@group
void fatal () __attribute__ ((noreturn));

void
fatal (/* @r{@dots{}} */)
@{
  /* @r{@dots{}} */ /* @r{Print error message.} */ /* @r{@dots{}} */
  exit (1);
@}
@end group
@end smallexample

@code{noreturn}キーワードは、@code{fatal}が返ることができないとコンパイラに指示する。 @code{fatal}が復帰した場合に起こることに関係なく最適化することができる。 これは少し良いコードを作成する。 さらに重要なことは、初期化されていない変数の偽の警告を避けることである。

@code{noreturn}キーワードは、それが適用される例外的なパスには影響しない：@code{noreturn}マークされた関数は、例外を投げたり@code{longjmp}を呼び出すことによっても呼び出し元に戻ることができる。

@code{noreturn}関数を呼び出す前に、呼び出し関数によって保存されたレジスタが復元されたと仮定しないこと。

@code{noreturn}関数が@code {void}以外の戻り値の型を持つことは意味がない。

@item nothrow
@cindex @code{nothrow} function attribute
@code{nothrow}属性は、関数が例外をスローできないことをコンパイラに通知するために使用される。 例えば、標準Cライブラリのほとんどの関数は、関数ポインタの引数を取る@code{qsort}と@code{bsearch}を例外として、例外を投げないことを保証することができる。

@item optimize
@cindex @code{optimize} function attribute
@code{optimize}属性は、関数がコマンドラインで指定されたものとは異なる最適化オプションでコンパイルされることを指定するために使用される。 引数は数値または文字列のいずれかである。 数値は最適化レベルとみなされる。@code{O}で始まる文字列は最適化オプションとみなされ、他のオプションは@code {-f}の接頭辞とともに使用されるものとみなされる。 @samp{#pragma GCC optimize}プラグマを使用して、複数の関数に影響を与える最適化オプションを設定することもできる。@samp{#pragma GCC optimize}プラグマの詳細は@xref{Function Specific Option Pragmas}。

この属性は、デバッグ目的でのみ使用するべきである。 プロダクションコードには適していない。

@item pure
@cindex @code{pure} function attribute
@cindex functions that have no side effects
多くの関数は戻り値以外の効果を持たず、戻り値はパラメータかつ/またはグローバル変数のみに依存する。このような関数は、算術演算子と同じように共通の部分式消去とループ最適化の対象となることができる。 これらの関数は@code{pure}属性で宣言する必要がある。 例えば、

@smallexample
int square (int) __attribute__ ((pure));
@end smallexample

@noindent
仮説的な関数@code {square}は、プログラムが言うよりも少ない回数だけ呼び出すのが安全だと言う。

純粋な関数の一般的な例としては、@code {strlen}や@code {memcmp}がある。興味深い非純粋な関数は、無限ループを持つ関数、または揮発性メモリや他のシステムリソースに依存する関数で、2回の連続した呼び出し（マルチスレッド環境の@code{feof}など）の間で変更される可能性がある。

@item returns_nonnull
@cindex @code{returns_nonnull} function attribute
@code{returns_nonnull}属性は、関数の戻り値がNULLでないポインタでなければならないことを指定する。 例えば、宣言は：

@smallexample
extern void *
mymalloc (size_t len) __attribute__((returns_nonnull));
@end smallexample

@noindent
コンパイラは戻り値が決してnullにならないという知識に基づいて呼び出し元を最適化する。

@item returns_twice
@cindex @code{returns_twice} function attribute
@cindex functions that return more than once
@code{returns_twice}属性は、関数が複数回返す可能性があることをコンパイラに知らせる。 コンパイラは、そのような関数を呼び出す前にすべてのレジスタが停止していることを確認し、関数からの2回目の復帰後に矛盾する可能性のある変数についての警告を発する。 このような関数の例は@code{setjmp}と@code {vfork}である。そのような関数の@code{longjmp}のような対応物は、@code{noreturn}属性でマークする必要があるかもしれない。

@item section ("@var{section-name}")
@cindex @code{section} function attribute
@cindex functions in arbitrary sections
通常、コンパイラは生成するコードを@code{text}セクションに配置する。しかし、場合によっては追加セクションが必要な場合や、特別なセクションに表示する特定の機能が必要な場合もある。 @code{section}属性は、関数が特定のセクションに存在することを指定する。たとえば、次のような宣言があると、

@smallexample
extern void foobar (void) __attribute__ ((section ("bar")));
@end smallexample

@noindent
関数@code{foobar}を@code{bar}セクションに置く。

一部のファイル形式では任意のセクションはサポートされないため、@code{section}属性はすべてのプラットフォームで使用できるわけではない。 モジュールの内容全体を特定のセクションにマップする必要がある場合は、代わりにリンカーの機能を使用することを検討せよ。

@item sentinel
@cindex @code{sentinel} function attribute
この関数属性は、関数呼び出しのパラメータが明示的な@code{NULL}であることを保証する。 属性は可変長関数でのみ有効である。 デフォルトでは、センチネルは、関数呼び出しの最後のパラメータである位置0にある。 オプションの整数位置引数Pが属性に与えられた場合、センチネルは、引数リストの最後から逆方向に数えて位置Pになければならない。

@smallexample
__attribute__ ((sentinel))
は以下と等価である。
__attribute__ ((sentinel(0)))
@end smallexample

属性は組み込み関数@code{execl}と@code{execlp}の位置が0になるように自動的に設定される。 組み込み関数@code{execle}の属性の位置は1である。

この文脈で有効な@code{NULL}は、ポインタ型を持つゼロとして定義されている。 あなたのシステムが@code {NULL}マクロを整数型で定義している場合、明示的なキャストを追加する必要がある。 GCCは@code{stddef.h}を、NULLを適切に再定義するコピーに置き換える。

@option{-Wformat}を指定すると、不正義または間違っている警告の警告が有効になる。

@item simd
@itemx simd("@var{mask}")
@cindex @code{simd} function attribute
この属性を使用すると、1回の呼び出しでSIMD命令を使用して複数の引数を処理できる1つ以上の関数バージョンを作成できる。 この属性を指定すると、コンパイラは、そのようなバージョンがリンク時に利用可能であると想定することができる（同じ翻訳単位または別の翻訳単位で提供される）。 生成されたバージョンはターゲットに依存し、対応するVector ABIドキュメントに記述されている。 x86_64ターゲットの場合、この文書は@w{@uref{https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&do=view&target=VectorABI.txt,here}}で見つけることができる。

オプションの引数@var{mask}は、値@code{notinbranch}または@code{inbranch}を持つことができ、それに対応してマスクされていないクローンまたはマスクされたクローンを生成するようにコンパイラに指示する。 デフォルトでは、すべてのクローンが生成される。

この属性は、同じ関数のCilk Plus @code{vector}属性と一緒に使用するべきではない。

属性が指定され、@code{#pragma omp declare simd}が宣言にあり、@option{-fopenmp}または@option{-fopenmp-simd}スイッチが指定されている場合、属性は無視される。

@item stack_protect
@cindex @code{stack_protect} function attribute
この属性は、フラグ@option{-fstack-protector}、@option{-fstack-protector-strong}または@option{-fstack-protector-explicit}が設定されている場合にスタック保護コードを関数に追加する。

@item target (@var{options})
@cindex @code{target} function attribute
複数のターゲットバックエンドは@code{target}属性を実装して、コマンドラインで指定されたものとは異なるターゲットオプションで関数をコンパイルすることを指定する。これは、例えば、デフォルトとは異なるISA（命令セットアーキテクチャ）でコンパイルされた関数を持つために使用できる。@samp{#pragma GCC target}プラグマを使用して、複数の関数を特定のターゲットオプションでコンパイルするように設定することもできる。@samp{#pragma GCC target}プラグマの詳細については、@xref{Function Specific Option Pragmas}を参照せよ。

たとえば、x86では、@code{target( "sse4.1,arch=core2")}属性を持つ関数と@code{target( "sse4a,arch=amdfam10")}関数を宣言できる。 これは、@option{-msse4.1}と@option{-march = core2}オプションで最初の関数をコンパイルし、@option{-msse4a}と@option{-march = amdfam10}オプションで2番目の関数をコンパイルするのと同じである。 関数がコンパイルされた特定のISAをサポートしているマシンでのみ呼び出されるようにすることは、あなたが任されている（たとえば、x86上で@code {cpuid}を使ってどの機能ビットとアーキテクチャファミリが使用されているかを判断する）。

@smallexample
int core2_func (void) __attribute__ ((__target__ ("arch=core2")));
int sse3_func (void) __attribute__ ((__target__ ("sse3")));
@end smallexample

コンマで区切られた複数の文字列を使用して、複数のオプションを指定するか、単一の文字列内でコンマ（@samp {,}）でオプションを区切ることができる。

サポートされるオプションは、各ターゲットに固有です。詳細は@ref{x86 Function Attributes}、@ref{PowerPC Function Attributes}、 @ref{ARM Function Attributes}、 @ref{Nios II Function Attributes}を参照。

@item target_clones (@var{options})
@cindex @code{target_clones} function attribute
@code{target_clones}属性は、関数がコマンドラインで指定されたものとは異なるターゲットオプションでコンパイルされた複数のバージョンに複製されることを指定するために使用される。 サポートされるオプションと制限は、@ code{target}属性と同じである。

たとえば、x86では、@code{target_clones( "sse4.1,avx")}で関数をコンパイルできる。 GCCは、@option{-msse4.1}と@option{-mavx}でコンパイルされた2つのファンクションクローンを作成する。また、現在のアーキテクチャに適したクローンを動的に選択するリゾルバ関数（上記の@code{ifunc}属性を参照）を作成する。

@item unused
@cindex @code{unused} function attribute
関数に付随するこの属性は、関数が未使用である可能性があることを意味します。 GCCはこの関数に対して警告を出さない。

@item used
@cindex @code{used} function attribute
関数に付随するこの属性は、その関数が参照されていないように見えても、関数に対してコードを発行する必要があることを意味する。 これは、関数がインラインアセンブリでのみ参照される場合などに便利である。

C++クラステンプレートのメンバ関数に適用すると、クラス自体がインスタンス化されている場合、その関数がインスタンス化されることも意味する。

@item visibility ("@var{visibility_type}")
@cindex @code{visibility} function attribute
この属性は、それがアタッチされている宣言のリンケージに影響する。関数だけでなく、変数（@pxref{Common Variable Attributes}）や型（@pxref{Common Type Attributes}）にも適用できる。

サポートされる4つの@var{visibility_type}値があります：default, hidden, protected, internal可視性。

@smallexample
void __attribute__ ((visibility ("protected")))
f () @{ /* @r{Do something.} */; @}
int i __attribute__ ((visibility ("hidden")));
@end smallexample

@var{visibility_type}の値は、ELF gABIの可視性設定に対応している。

@table @code
@c keep this list of visibilities in alphabetical order.

@item default
default(デフォルト)の可視性は、オブジェクトファイル形式の通常の場合である。この値は、visibility属性で使用可能で、エンティティの想定される可視性を変更する可能性のある他のオプションをオーバーライドする。

ELFでは、default可視性は、宣言が他のモジュールに見えることを意味し、共有ライブラリでは、宣言されたエンティティがオーバーライドされる可能性があることを意味する。

Darwinでは、default可視性は、その宣言が他のモジュールから見えることを意味する。

default可視性は、言語の「外部リンケージ」に対応する。

@item hidden
hidden(非表示)の可視性は、宣言されたエンティティが新しい形式のリンケージを持っていることを示している。これを「隠れリンケージ」と呼ぶ。 隠れたリンケージを持つオブジェクトの2つの宣言は、同じ共有オブジェクトにある場合、同じオブジェクトを参照する。

@item internal
internal(内部)可視性はhidden可視性と似ているが、追加のプロセッサ固有の意味がある。 psABIで別途指定されていない限り、GCCはinternal可視性を、関数が@emph{_決して_}他のモジュールから呼び出されることはないと定義する。 これを他のモジュールが直接参照することはできないが、関数ポインタを介して間接的に参照できる隠し関数と比較する。 関数がモジュールの外部から呼び出せないことを示すことによって、GCCは、呼び出し元関数が正しい値をロードしたことが分かっているため、例えばPICレジスタのロードを省略することができる。

@item protected
protected(保護された)可視性は、定義モジュール内の参照がそのモジュールの定義にバインドされていることを示している点を除き、default可視性と似ている。 つまり、宣言されたエンティティを別のモジュールで上書きすることはできない。

@end table
すべての可視性は、ELFターゲットの多くで（しかしすべてではなく）サポートされている（アセンブラが@samp{.visibility}疑似オペレーションをサポートするときにサポートされる）。default可視性はどこでもサポートされている。 hidden可視性はDarwinターゲットでサポートされている。

visibility属性は、それ以外の場合は外部リンクを持つ宣言にのみ適用する必要がある。 属性は一貫して適用する必要がある。そのため、同じエンティティを属性の異なる設定で宣言することはできない。

C++では、visibility属性は型や関数、オブジェクトに適用される。なぜならC++型ではリンケージがあるからである。 クラスは非静的なデータメンバの型や基底よりも大きな可視性を持ってはならず、クラスメンバはそのクラスの可視性をdefaultにする。 また、明示的な可視性のない宣言は、その型の可視性に限定される。

C++では、クラスのメンバ関数と静的メンバ変数をvisibility属性でマークすることができる。 これは、特定のメソッドまたは静的メンバー変数が1つの共有オブジェクトからのみ使用されることがわかっている場合に便利である。 クラスの残りの部分がdefault可視性を持っている一方、それをhiddenにすることができる。 1つの定義ルールを破らないように注意する必要がある。 例えば、クラス全体をhiddenにすることなく、インラインメソッドをhiddenとしてマークすることは、通常、有用ではない。

C++の名前空間宣言にも、visibility属性を含めることができる。

@smallexample
namespace nspace1 __attribute__ ((visibility ("protected")))
@{ /* @r{Do something.} */; @}
@end smallexample

この属性は特定の名前空間本体にのみ適用され、同じ名前空間の他の定義には適用されない。 @samp{#pragma GCC visibility}を名前空間の定義の前後に使用すること（@pxref{Visibility Pragmas}）と同じである。

C++では、テンプレート引数の可視性が制限されている場合、この制限はテンプレートのインスタンス化に暗黙的に伝播される。それ以外の場合は、テンプレートの実体化と特殊化は、デフォルトでテンプレートの可視性になる。

テンプレートクラスと囲みクラスの両方に明示的な可視性がある場合、テンプレートからの可視性が使用される。

@item warn_unused_result
@cindex @code{warn_unused_result} function attribute
この属性を持つ関数の呼び出し側が戻り値を使用しない場合、@code{warn_unused_result}属性は警告を発行する。 これは、@code{realloc}のように、結果をチェックしないとセキュリティ上の問題であるか、常にバグである関数に役立つ。

@smallexample
int fn () __attribute__ ((warn_unused_result));
int foo ()
@{
  if (fn () < 0) return -1;
  fn ();
  return 0;
@}
@end smallexample

@noindent
5行目に警告が表示される。

@item weak
@cindex @code{weak} function attribute
@code{weak}属性は、宣言がグローバルではなく弱いシンボルとして出力されるようにする。 これは主に、ユーザーコードでオーバーライドできるライブラリ関数を定義するのに便利であるが、関数以外の宣言でも使用できる。 弱いシンボルは、ELFターゲット、およびGNUアセンブラとリンカを使用するときのa.outターゲットでサポートされている。

@item weakref
@itemx weakref ("@var{target}")
@cindex @code{weakref} function attribute
@code{weakref}属性は、宣言を弱い参照としてマークする。引数がなければ、それは@code{alias}属性にターゲットシンボルの名前を付ける必要がある。 オプションで、@code{weakref}自体の引数として@var{target}を与えることができる。 どちらの場合でも、@code{weakref}は宣言を暗黙的に@code{weak}とマークする。 @code{weakref}や@code{alias}の引数として与えられた@var{target}がなければ、@code{weakref}は@code {weak}と同等である。

@smallexample
static int x() __attribute__ ((weakref ("y")));
/* is equivalent to... */
static int x() __attribute__ ((weak, weakref, alias ("y")));
/* and to... */
static int x() __attribute__ ((weakref));
static int x() __attribute__ ((alias ("y")));
@end smallexample

弱参照は、それ自身ではターゲットシンボルに対して定義を与える必要がないエイリアスである。 ターゲットシンボルが弱参照によってのみ参照される場合、それは@code{weak}未定義シンボルになる。 ただし、直接参照されている場合は、そのような強力な参照が優先され、シンボルには定義が必要である。必ずしも同じ翻訳単位である必要はない。

この効果は、エイリアスへのすべての参照を別の翻訳単位に移動し、エイリアスをエイリアスシンボルの名前に変更し、弱いと宣言し、2つの別々の翻訳単位をコンパイルし、再読み込み可能なリンクを実行することと同じである。

現在のところ、@code{weakref}が付加されている宣言は@code{static}にしかできない。


@end table

@c This is the end of the target-independent attribute table

@node AArch64 Function Attributes
@subsection AArch64関数属性

AArch64ターゲットでは、次のターゲット固有の関数属性を使用できる。 ほとんどの場合、これらのオプションは、同様のコマンドラインオプション（@pxref{AArch64 Options}）の動作をミラーリングするが、関数ごとに反映される。

@table @code
@item general-regs-only
@cindex @code{general-regs-only} function attribute, AArch64
この関数のコードを生成するときに、浮動小数点またはアドバンストSIMDレジスタを使用しないことを示す。 関数が明示的に浮動小数点コードを使用する場合、コンパイラはエラーを返す。 これは、コマンド行オプション@option{-mgeneral-regs-only}と同じ動作である。

@item fix-cortex-a53-835769
@cindex @code{fix-cortex-a53-835769} function attribute, AArch64
この関数にCortex-A53 erratum 835769の回避策を適用する必要があることを示す。 この関数の回避策を明示的に無効にするには、無効な形式を指定する：@code{no-fix-cortex-a53-835769}。 これは、コマンド行オプション@option{-mfix-cortex-a53-835769}と@option{-mno-fix-cortex-a53-835769}の動作に対応する。

@item cmodel=
@cindex @code{cmodel=} function attribute, AArch64
この関数の特定のコードモデルに対してコードを生成する必要があることを示す。 動作と許容される引数は、コマンドラインオプション@option{-mcmodel=}と同じである。

@item strict-align
@cindex @code{strict-align} function attribute, AArch64
コンパイラーは、境界整列されていないメモリー参照がシステムによって処理されると想定してはならないことを示す。 動作は、コマンドラインオプション@option{-mstrict-align}と同じである。

@item omit-leaf-frame-pointer
@cindex @code{omit-leaf-frame-pointer} function attribute, AArch64
リーフ関数呼び出しのためにフレームポインタを省略するべきであることを示す。フレームポインタを保持するために、逆属性@code{no-omit-leaf-frame-pointer}を指定することができる。 これらの属性は、コマンド行オプション@option{-momit-leaf-frame-pointer}および@option{-mno-omit-leaf-frame-pointer}と同じ動作をする。

@item tls-dialect=
@cindex @code{tls-dialect=} function attribute, AArch64
この関数に使用するTLS方言を指定する。 動作と許容される引数は、コマンドラインオプション@option{-mtls-dialect=}と同じである。

@item arch=
@cindex @code{arch=} function attribute, AArch64
この機能に使用するアーキテクチャーのバージョンとアーキテクチャー拡張を指定する。 動作と許容される引数は、@option{-march=}コマンドラインオプションと同じである。

@item tune=
@cindex @code{tune=} function attribute, AArch64
この機能のパフォーマンスをチューニングするコアを指定する。動作と許容可能な引数は、@option{-mtune=}コマンドラインオプションと同じである。

@item cpu=
@cindex @code{cpu=} function attribute, AArch64
この機能のパフォーマンスをチューニングするコアと、使用するアーキテクチャ上の機能を指定する。 動作と有効な引数は、@option{-mcpu=}コマンドラインオプションと同じである。

@item sign-return-address
@cindex @code{sign-return-address} function attribute, AArch64
戻りアドレスの署名が適用される関数スコープを選択する。 動作と許容される引数は、コマンドラインオプションの@option{-msign-return-address=}と同じである。 デフォルト値は@code{none}である。

@end table

上記のターゲット属性は、次のように指定できる。

@smallexample
__attribute__((target("@var{attr-string}")))
int
f (int a)
@{
  return a + 5;
@}
@end smallexample

ここで@code{@var{attr-string}}は、上記で指定した属性文字列の1つである。

さらに、アーキテクチャ拡張文字列は単独で指定することもできる。 これは、特定のアーキテクチャーのバージョンまたはコアを指定することなく、特定のアーキテクチャー拡張をオンまたはオフにするために使用できる。 例：

@smallexample
__attribute__((target("+crc+nocrypto")))
int
foo (int a)
@{
  return a + 5;
@}
@end smallexample

この例では、@code{target("+crc+nocrypto")}は@code{crc}拡張を有効にし、既存の@option{-march=}または@option{-mcpu}オプションを変更せずに@code{foo}関数の@code{crypto}拡張を無効にする。

カンマで区切って複数のターゲット関数属性を指定することができる。 例えば：
@smallexample
__attribute__((target("arch=armv8-a+crc+crypto,tune=cortex-a53")))
int
foo (int a)
@{
  return a + 5;
@}
@end smallexample

は有効で、ARMv8-Aの関数@code{foo}を@code{crc}と@code{crypto}拡張でコンパイルし、@code{cortex-a53}のために調整する。

@subsubsection インライン規則
異なるターゲットオプションを使用してコンパイルされた翻訳ユニット間で、個々の関数のターゲット属性を指定したり、リンク時の最適化を実行すると、関数のインライン化ルールに影響がでる。

特に、呼び出し元関数は、呼び出し先が利用可能なアーキテクチャ上の機能が呼び出し元が使用できる機能のサブセットである場合にのみ、呼び出し先関数をインライン化できる。例：@option{-march=armv8-a+crc}でコンパイルされた、または同等の@code {arch = armv8-a + crc}属性でタグ付けされた関数@code{foo}は、関数をインラインで@code{@code{bar}}は@option{-march=armv8-a+nocrc}でコンパイルされている。なぜなら、@code {bar}が必要とするすべてのアーキテクチャ機能が@code{foo}を機能させるためである。 逆に関数@code {bar}は関数@code{foo}をインライン化できない。

さらに@option{-mstrict-align}でコンパイルされた関数を@code{-mstrict-align}なしでコンパイルされた関数にインライン展開することはできない。ただし、@option{-mstrict-align}を指定せずにコンパイルされた関数を、@option{-mstrict-align}でコンパイルされた関数にインライン展開することはできる。

@option{-mcpu=}、@option{-mtune=}のようなCPUチューニングオプションと属性は、@option{-mcpu=}オプションまたは@code{cpu=}属性は、上記で指定したアーキテクチャ機能ルールと競合する。

@node ARC Function Attributes
@subsection ARC関数属性

これらの関数属性は、ARCバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, ARC
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

ARCでは、次のように割り込み属性のパラメータで処理される割り込みの種類を指定する必要がある。

@smallexample
void f () __attribute__ ((interrupt ("ilink1")));
@end smallexample

このパラメータの許容値は次のとおりである： @w{@code{ilink1}}と@w{@code{ilink2}}.

@item long_call
@itemx medium_call
@itemx short_call
@cindex @code{long_call} function attribute, ARC
@cindex @code{medium_call} function attribute, ARC
@cindex @code{short_call} function attribute, ARC
@cindex indirect calls, ARC
これらの属性は、特定の関数の呼び出し方法を指定する。これらの属性は、@option{-mlong-calls}と@option{-mmedium-calls}（@pxref{ARC Options}）コマンドラインスイッチと@code{#pragma long_calls}設定よりも優先される。

ARCでは、@code{long_call}属性でマークされた関数は常にレジスタ間接jump-and-link命令を使用して呼び出され、呼び出された関数を32ビットアドレス空間のどこにでも配置できるようにする。 @code{medium_call}属性でマークされた関数は、コールサイトから25ビットのオフセットを持つ無条件の分岐およびリンク命令で呼び出すことができるくらい近くにある。 @code{short_call}属性でマークされた関数は、コールサイトから21ビットのオフセットを持つ条件付き分岐/リンク命令で呼び出すのに十分に近い状態になる。
@end table

@node ARM Function Attributes
@subsection ARM関数属性

これらの関数属性は、ARMターゲットでサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, ARM
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

割り込み属性にオプションのパラメータを追加することで、処理する割り込みの種類を指定することができる。

@smallexample
void f () __attribute__ ((interrupt ("IRQ")));
@end smallexample

@noindent
このパラメータの許容値は次のとおりである。 @code{IRQ}、 @code{FIQ}、@code{SWI}、 @code{ABORT}、@code{UNDEF}.

ARMv7-Mでは、割り込みタイプは無視され、属性はワードアラインされたスタックポインタで呼び出されることを意味する。

@item isr
@cindex @code{isr} function attribute, ARM
割り込みサービスルーチンを書き込むには、ARMでこの属性を使用する。 上記の@code{interrupt}属性の別名である。

@item long_call
@itemx short_call
@cindex @code{long_call} function attribute, ARM
@cindex @code{short_call} function attribute, ARM
@cindex indirect calls, ARM
これらの属性は、特定の関数の呼び出し方法を指定する。これらの属性は、@option{-mlong-calls}（@pxref{ARM Options}）コマンドラインスイッチと@code{#pragma long_calls}設定を上書きする。ARMの場合、@code{long_call}属性は、関数がコールサイトから離れていて、別の（より高価な）呼び出しシーケンスを必要とする可能性があることを示す。 @code{short_call}属性は常に、コールサイトからの関数にオフセットを@samp{BL}命令に直接置く。

@item naked
@cindex @code{naked} function attribute, ARM
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。 基本的な@code{asm}文（@pxref{Basic Asm}）だけが安全にnaked関数に含まれることができる。 拡張@code{asm}または基本的な@code{asm}とCコードの混在を使用すると動作するように見えるかもしれないが、信頼できる動作に依存することはできず、サポートされていない。

@item pcs
@cindex @code{pcs} function attribute, ARM
@code{pcs}属性は、ARM上の関数に使用される呼び出し規約を制御するために使用できる。 この属性は、使用する呼び出し規約を指定する引数をとる。

AAPCS ABI（またはその変形版）を使用してコンパイルする場合、引数の有効な値は@code{"aapcs"}と@code{"aapcs-vfp"}である。@code{"aapcs"}以外のバリアントを使用するには、コンパイラは適切なコプロセッサレジスタを使用する必要がある（つまり、 @code{"aapcs-vfp"}を使用するにはVFPレジスタを使用できる必要がある）。例えば、

@smallexample
/* Argument passed in r0, and result returned in r0+r1.  */
double f2d (float) __attribute__((pcs("aapcs")));
@end smallexample

Variadic関数は常に@code{"aapcs"}呼び出し規約を使用し、コンパイラは代替を指定しようとする試みを拒否する。

@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

ARMでは、次のオプションを使用できる。

@table @samp
@item thumb
@cindex @code{target("thumb")} function attribute, ARM
アーキテクチャレベルに応じて、Thumb（T16/T32）ISAにコードを強制的に生成する。

@item arm
@cindex @code{target("arm")} function attribute, ARM
ARM（A32）ISAのコード生成を強制する。

異なるモードの関数は、呼び出し元のモードでインライン化できます。

@item fpu=
@cindex @code{target("fpu=")} function attribute, ARM
この関数のパフォーマンスを調整するためのfpuを指定する。動作と許容可能な引数は、@option{-mfpu=}コマンドラインオプションと同じである。

@end table

@end table

@node AVR Function Attributes
@subsection AVR関数属性

これらの関数属性は、AVRバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, AVR
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

AVRでは、ハードウェアは割り込みが実行されると割り込みをグローバルに無効化する。 この属性で宣言された割り込みハンドラの最初の命令は、割り込みを再び有効にするための@code{SEI}命令である。 @code{SEI}命令を挿入しない@code{signal}関数属性も参照せよ。 同じ関数に対して@code{signal}と@code{interrupt}の両方が指定されている場合、@code{signal}は暗黙のうちに無視される。

@item naked
@cindex @code{naked} function attribute, AVR
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本的な@code{asm}文（@pxref{Basic Asm}）だけが安全にnaked関数に含まれることができる。 拡張@code{asm}または基本的な@code{asm}とCコードの混在を使用すると動作するように見えるかもしれないが、信頼できる動作に依存することはできず、サポートされていない。

@item OS_main
@itemx OS_task
@cindex @code{OS_main} function attribute, AVR
@cindex @code{OS_task} function attribute, AVR
AVRでは、@code{OS_main}属性または@code{OS_task}属性を持つ関数は、プロローグ/エピローグに呼び出し保存レジスタを保存/復元しない。

関数が入力された時点で割り込みが無効になっていることが@emph{_保証されている_}場合は、@code{OS_main}属性を使用できる。 これにより、ローカル変数のフレームを設定するためにスタックポインタを変更する必要がある場合に、リソースが節約される。

@code{OS_task}属性は、その関数が例えばマルチスレッド・オペレーティング・システムのタスク関数のように入力されたときに割り込みが無効になっているという保証がない場合に使用できる。その場合、スタックポインタレジスタの変更は、グローバル割込み許可フラグのセーブ/クリア/リストアによって保護される。

@code{naked}関数の属性との違いは次のとおりである。
@itemize @bullet
@item @code{naked}関数は戻り命令を持たないが、@code{OS_main}関数と@code{OS_task}関数は@code{RET}または@code{RETI}戻り命令を持っている。
@item @code{naked}関数はローカル変数やフレームポインタのフレームを設定しまないが、@code{OS_main}と@code{OS_task}はこれを必要に応じて行う。
@end itemize

@item signal
@cindex @code{signal} function attribute, AVR
AVRでこの属性を使用して、指定された機能が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@code{interrupt}関数属性も参照せよ。

AVRハードウェアは、割り込みが実行されたときに割り込みをグローバルに無効化する。@code{signal}属性で定義された割り込みハンドラ関数は、割り込みを再び有効にしない。 これは、@code{signal}ハンドラで割り込みを有効にするために保存される。 この「保存」は、コンパイラによって生成されたコードにのみ適用され、アプリケーションの責任であるアプリケーションのIRQレイアウトには適用されない。

同じ関数に対して@code{signal}と@code{interrupt}の両方が指定されている場合、@code{signal}は暗黙のうちに無視される。
@end table

@node Blackfin Function Attributes
@subsection Blackfin関数属性

これらの関数属性は、Blackfinバックエンドによってサポートされている。

@table @code

@item exception_handler
@cindex @code{exception_handler} function attribute
@cindex exception handler functions, Blackfin
Blackfinでこの属性を使用すると、指定された関数が例外ハンドラであることを示す。 コンパイラは、この属性が存在する場合、例外ハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item interrupt_handler
@cindex @code{interrupt_handler} function attribute, Blackfin
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@item kspisusp
@cindex @code{kspisusp} function attribute, Blackfin
@cindex User stack pointer in interrupts on the Blackfin
@code{interrupt_handler}、@code{exception_handler}または@code{nmi_handler}とともに使用すると、関数プロローグのUSPレジスタからスタックポインタをロードするコードが生成される。

@item l1_text
@cindex @code{l1_text} function attribute, Blackfin
この属性は、L1命令SRAMに配置される関数を指定する。関数は@code {.l1.text}という特定のセクションに置かれる。@option{-mfdpic}では、呼び出し先や呼び出し元がインラインPLTを使用するような関数呼び出しを伴う関数呼び出しである。

@item l2
@cindex @code{l2} function attribute, Blackfin
この属性は、L2 SRAMに配置される関数を指定する。 この関数は@code{.l2.text}という名前の特定のセクションに置かれる。 @option{-mfdpic}では、このような関数の呼び出し側はインラインPLTを使用する。

@item longcall
@itemx shortcall
@cindex indirect calls, Blackfin
@cindex @code{longcall} function attribute, Blackfin
@cindex @code{shortcall} function attribute, Blackfin
@code{longcall}属性は、関数がコールサイトから離れていて、別の（より高価な）呼び出しシーケンスを必要とする可能性があることを示す。 @code{shortcall}属性は、短い呼び出しシーケンスを使用するために関数が常に十分に近いことを示す。これらの属性は、@option{-mlongcall}スイッチよりも優先される。

@item nesting
@cindex @code{nesting} function attribute, Blackfin
@cindex Allow nesting in an interrupt handler on the Blackfin processor
この属性を@code{interrupt_handler}、@code{exception_handler}または@code{nmi_handler}とともに使用して、関数エントリコードがネストされた割り込みまたは例外を有効にする必要があることを示す。

@item nmi_handler
@cindex @code{nmi_handler} function attribute, Blackfin
@cindex NMI handler functions on the Blackfin processor
指定された機能がNMIハンドラであることを示すには、この属性をBlackfinで使用する。 コンパイラは、この属性が存在する場合、NMIハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item saveall
@cindex @code{saveall} function attribute, Blackfin
@cindex save all registers on the Blackfin
スタックポインタを使用するかどうかにかかわらず、スタックポインタを除くすべてのレジスタをプロローグに保存する必要があることを示すには、この属性を使用する。
@end table

@node CR16 Function Attributes
@subsection CR16関数属性

これらの関数属性は、CR16のバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, CR16
この属性を使用して、指定された関数が割り込みハンドラであることを示す。コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。
@end table

@node Epiphany Function Attributes
@subsection Epiphany関数属性

これらの関数属性はEpiphanyバックエンドによってサポートされている：

@table @code
@item disinterrupt
@cindex @code{disinterrupt} function attribute, Epiphany
この属性により、コンパイラは指定された関数の実行中に割り込みを無効にする命令を発行する。

@item forwarder_section
@cindex @code{forwarder_section} function attribute, Epiphany
この属性は、割り込みハンドラの動作を変更する。割り込みハンドラは、分岐命令では到達できない外部メモリにある可能性があるため、制御を転送するためにローカルメモリのトランポリンを生成する。 単一のパラメータは、トランポリンが配置されているセクションを識別する。

@item interrupt
@cindex @code{interrupt} function attribute, Epiphany
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。 また、割り込みベクタテーブルを初期化するためのコードを含む特別なセクションを生成することもある。

Epiphanyターゲットでは、次のように1つ以上のオプションパラメータを追加できる。

@smallexample
void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();
@end smallexample

これらのパラメータの可能な値は： @w{@code{reset}}、@w{@code{software_exception}}、 @w{@code{page_miss}}、@w{@code{timer0}}、 @w{@code{timer1}}、 @w{@code{message}}、@w{@code{dma0}}、 @w{@code{dma1}}、 @w{@code{wand}}、@w{@code{swi}}である。複数のパラメータは、割り込みベクタテーブル内の複数のエントリをこの関数に対して初期化する必要があることを示す。各パラメータ@w{@var{name}}に対して、関数へのジャンプはセクション@w{ivt_entry_@var{name}}に生成される。 パラメータは完全に省略されてもよく、この場合、割り込みベクタテーブルエントリは提供されない。

@code{disinterrupt}属性も指定されていない限り、関数内で割り込みが有効になることに注意せよ。

次の例は、Epiphanyターゲットでこれらの属性をすべて有効に使用する例である。
@smallexample
void __attribute__ ((interrupt)) universal_handler ();
void __attribute__ ((interrupt ("dma1"))) dma1_handler ();
void __attribute__ ((interrupt ("dma0, dma1"))) 
  universal_dma_handler ();
void __attribute__ ((interrupt ("timer0"), disinterrupt))
  fast_timer_handler ();
void __attribute__ ((interrupt ("dma0, dma1"), 
                     forwarder_section ("tramp")))
  external_dma_handler ();
@end smallexample

@item long_call
@itemx short_call
@cindex @code{long_call} function attribute, Epiphany
@cindex @code{short_call} function attribute, Epiphany
@cindex indirect calls, Epiphany
これらの属性は、特定の関数の呼び出し方法を指定する。これらの属性は、@option{-mlong-calls}（@pxref{Adapteva Epiphany Options}）コマンドラインスイッチと@code{#pragma long_calls}設定を上書きする。
@end table


@node H8/300 Function Attributes
@subsection H8/300関数属性

これらの関数属性は、H8 / 300ターゲットで使用できる。

@table @code
@item function_vector
@cindex @code{function_vector} function attribute, H8/300
H8 / 300、H8 / 300H、H8Sでは、この属性を使用して、指定した関数を関数ベクタで呼び出す必要があることを示す。関数ベクトルを介して関数を呼び出すと、コードサイズが小さくなる。 関数ベクトルのサイズは制限されていて（H8 / 300では最大128エントリ、H8 / 300HおよびH8Sでは64エントリ）、割り込みベクタと空間を共有する。

@item interrupt_handler
@cindex @code{interrupt_handler} function attribute, H8/300
H8/300、H8/300H、H8Sでこの属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@item saveall
@cindex @code{saveall} function attribute, H8/300
@cindex save all registers on the H8/300, H8/300H, and H8S
H8/300、H8/300H、H8Sではスタックポインタを除くすべてのレジスタを使用するかどうかにかかわらずプロローグに退避する必要があることを示すために使用する。
@end table

@node IA-64 Function Attributes
@subsection IA-64関数属性

これらの関数属性は、IA-64ターゲットでサポートされている。

@table @code
@item syscall_linkage
@cindex @code{syscall_linkage} function attribute, IA-64
この属性は、すべての入力レジスタをすべての関数終了でライブとしてマークすることによって、IA-64呼び出し規約を変更するために使用される。 これにより、入力レジスタを退避/復帰させることなく割り込み後にシステムコールを再開することができる。 これにより、カーネルデータがアプリケーションコードに漏洩することも防止される。

@item version_id
@cindex @code{version_id} function attribute, IA-64
グローバル変数または関数にアタッチされたこのIA-64 HP-UXアトリビュートは、シンボルの名前を変更してバージョン文字列を含むため、ファンクションレベルのバージョニングが可能である。 HP-UXシステムのヘッダーファイルは、一部のシステムコールで機能レベルのバージョニングを使用することがある。

@smallexample
extern int foo () __attribute__((version_id ("20040821")));
@end smallexample

@noindent
@code{foo}の呼び出しは@code{foo@{20040821@}}の呼び出しにマップされる。
@end table

@node M32C Function Attributes
@subsection M32C関数属性

これらの関数属性は、M32Cバックエンドによってサポートされている。

@table @code
@item bank_switch
@cindex @code{bank_switch} function attribute, M32C
M32Cポートで割り込みハンドラに追加すると、プロローグとエピローグでスタックに保存するのではなく、レジスタを保存するためにバンク切り替えを使用する。

@item fast_interrupt
@cindex @code{fast_interrupt} function attribute, M32C
指定された機能が高速割り込みハンドラであることを示すには、M32Cポートでこの属性を使用する。 これは、復帰するため@code{reit}の代わりに@code{freit}を使う点を除いて、@code{interrupt}属性と同じである。

@item function_vector
@cindex @code{function_vector} function attribute, M16C/M32C
M16C/M32Cターゲットでは、@code{function_vector}属性は特別なページサブルーチン呼び出し関数を宣言する。 この属性を使用すると、サブルーチンに生成される呼び出しごとにコードサイズが2バイト減少する。 属性への引数は、サブルーチンのエントリアドレスの下位16ビットを含む特殊ページベクタテーブルからのベクタ番号エントリである。 各ベクタテーブルには、@code{jsrs}命令で使用される特別なページ番号（18〜255）がある。 ルーチンのジャンプアドレスは、ベクタテーブルに設定されている2バイトアドレスに0x0F0000（M16Cターゲットの場合）または0xFF0000（M32Cターゲットの場合）を加算して生成する。 したがって、すべての特殊ページベクタルーチンがアドレス範囲0x0F0000〜0x0FFFFF（M16Cの場合）と0xFF0000〜0xFFFFFF（M32Cの場合）にマッピングされるようにする必要がある。

次の例では、関数@code{foo}の呼び出しごとに2バイトが節約される。

@smallexample
void foo (void) __attribute__((function_vector(0x18)));
void foo (void)
@{
@}

void bar (void)
@{
    foo();
@}
@end smallexample

関数が1つのファイルで定義され、別のファイルで呼び出されている場合は、この宣言を両方のファイルに必ず書き込むこと。

この属性はR8Cターゲットでは無視される。

@item interrupt
@cindex @code{interrupt} function attribute, M32C
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。
@end table

@node M32R/D Function Attributes
@subsection M32R/D関数属性

これらの関数属性は、M32R / Dバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, M32R/D
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@item model (@var{model-name})
@cindex @code{model} function attribute, M32R/D
@cindex function addressability on the M32R/D
M32R/Dでは、この属性を使用してオブジェクトのアドレス可能性を設定し、関数用に生成されたコードを設定する。 識別子@var{model-name}は、各コードモデルを表す@code{small}、@code{medium}、または@code{large}のいずれかである。

smallモデルオブジェクトは、メモリの下位16MBにあり（そのアドレスに@code{ld24}命令でロードできるように）、@code{bl}命令で呼び出し可能である。

mediumモデルオブジェクトは32ビットアドレス空間のどこにでも存在することができる（コンパイラはアドレスをロードするための@code{seth/add3}命令を生成する）。@code{bl}命令で呼び出し可能である。

kargeモデルオブジェクトは、32ビットアドレス空間のどこにでも置くことができ、（コンパイラはアドレスをロードするために@code{seth/add3}命令を生成する）@code {bl}命令では到達できないかもしれない（コンパイラはずっと遅い@code{seth/add3/jl}命令シーケンスを生成する）
@end table

@node m68k Function Attributes
@subsection m68k関数属性

これらの関数属性は、m68kバックエンドによってサポートされている。

@table @code
@item interrupt
@itemx interrupt_handler
@cindex @code{interrupt} function attribute, m68k
@cindex @code{interrupt_handler} function attribute, m68k
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。 いずれかの名前を使用できる。

@item interrupt_thread
@cindex @code{interrupt_thread} function attribute, fido
指定された関数がスレッドとして実行されるように設計された割り込みハンドラであることを示すために、この属性をm68kのサブアーキテクチャであるfidoに使用する。 コンパイラは、プロローグ/エピローグシーケンスの生成を省略し、リターン命令を@code{sleep}命令に置き換える。 この属性はfidoでのみ使用できる。
@end table

@node MCORE Function Attributes
@subsection MCORE関数属性

これらの関数属性は、MCOREバックエンドによってサポートされている。

@table @code
@item naked
@cindex @code{naked} function attribute, MCORE
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。 基本@code{asm}文だけが安全にnaked関数（@pxref {Basic Asm}）に含まれることができる。 拡張@code {asm}または基本@code {asm}とCコードの混在を使用すると動作するように見えるかもしれないが、信頼できる動作に依存することはできず、サポートされていない。
@end table

@node MeP Function Attributes
@subsection MeP関数属性

これらの関数属性は、MePバックエンドによってサポートされている。

@table @code
@item disinterrupt
@cindex @code{disinterrupt} function attribute, MeP
MePターゲットでは、この属性により、コンパイラは指定された関数の実行中に割り込みを無効にする命令を発行する。

@item interrupt
@cindex @code{interrupt} function attribute, MeP
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item near
@cindex @code{near} function attribute, MeP
この属性により、コンパイラは、@option{-mtf}コマンドラインオプションをオーバーライドして、呼び出された関数が通常の呼び出し規約を使用するのに十分近いと想定する。

@item far
@cindex @code{far} function attribute, MeP
MePターゲットでは、コンパイラは呼び出された関数が組み込みアドレッシングモードではあまりにも遠すぎると仮定した呼び出し規約を使用する。

@item vliw
@cindex @code{vliw} function attribute, MeP
@code{vliw}属性は、コアモードではなくVLIWモードで命令を発行するようにコンパイラに指示する。 VLIWコプロセッサがコマンドラインオプションによって構成され、有効にされていない限り、この属性は使用できない。
@end table

@node MicroBlaze Function Attributes
@subsection MicroBlaze関数属性

これらの関数属性は、MicroBlazeターゲットでサポートされている。

@table @code
@item save_volatiles
@cindex @code{save_volatiles} function attribute, MicroBlaze
この属性を使用して、関数が割り込みハンドラであることを示す。 （不揮発性レジスタに加えて）すべての揮発性レジスタは、関数プロローグに保存される。 関数がリーフ関数の場合、関数が使用する揮発性物質のみが保存される。 割り込みからの復帰ではなく、通常の関数戻りが生成される。

@item break_handler
@cindex @code{break_handler} function attribute, MicroBlaze
@cindex break handler functions
この属性を使用して、指定された関数がブレークハンドラであることを示す。 コンパイラーは、この属性が存在する場合にブレーク・ハンドラーでの使用に適した関数入力および出口シーケンスを生成する。 @code{break_handler}からの復帰は@code{rtsd}ではなく@code{rtbd}によって行われる。

@smallexample
void f () __attribute__ ((break_handler));
@end smallexample

@item interrupt_handler
@itemx fast_interrupt 
@cindex @code{interrupt_handler} function attribute, MicroBlaze
@cindex @code{fast_interrupt} function attribute, MicroBlaze
これらの属性は、指定された関数が割り込みハンドラであることを示す。 低レイテンシの割り込みモードで使用されるハンドラを示すには@code{fast_interrupt}属性を使用し、低レイテンシハンドラを使用しない割り込みには@code{interrupt_handler}を使用する。 どちらの場合も、GCCは適切なプロローグコードを生成し、@code {rtsd}の代わりに@code{rtid}を使用してハンドラからのリターンを生成する。
@end table

@node Microsoft Windows Function Attributes
@subsection Microsoft Windows関数属性

次の属性は、Microsoft WindowsおよびSymbian OSターゲットで使用できる。

@table @code
@item dllexport
@cindex @code{dllexport} function attribute
@cindex @code{__declspec(dllexport)}
Microsoft WindowsターゲットとSymbian OSターゲットでは、@code{dllexport}属性を使用すると、コンパイラーはDLLのポインターへのグローバルポインターを提供し、@code{dllimport}属性で参照できるようになる。 Microsoft Windowsターゲットでは、@code{_imp__}と関数名または変数名を組み合わせてポインタ名を作成する。

他のコンパイラとの互換性のため、@code{__declspec(dllexport)}を@code{__attribute__((dllexport))}と同義語として使うことができる。

@code{visibility}属性をサポートするシステムでは、この属性は「default」の可視性も意味する。 他の可視性を明示的に指定するのは誤りである。

GCCのデフォルトの動作は、@code{dllexport}属性を持つすべてのインライン関数を出力することである。 これはオブジェクトファイルサイズの膨張を引き起こす可能性があるので、@option{-fkeep-inline-functions}フラグが代わりに使用されない限り、GCCにインライン関数の属性を無視するように指示する@option{-fno-keep-inline-dllexport}を使用できる。

定義されていないシンボルの場合、属性は無視される。

C++クラスに適用すると、属性は非インラインメンバー関数と静的データメンバーをエクスポートとして定義する。 クラス内で初期化された静的constは、クラス外でも定義されていない限り、マークされない。

Microsoft Windowsターゲットでは、@code{EXPORTS}セクションで@file{.def}ファイルを使用するか、@option{--export-all}リンカーフラグを使用してGNU ldでシンボルをDLLのエクスポートテーブルに組み込む方法がある。

@item dllimport
@cindex @code{dllimport} function attribute
@cindex @code{__declspec(dllimport)}
Microsoft WindowsおよびSymbian OSターゲットでは、@code{dllimport}属性により、コンパイラはシンボルをエクスポートするDLLによって設定されたポインタへのグローバルポインタを介して関数または変数を参照する。 この属性は@code{extern}を意味する。 Microsoft Windowsターゲットでは、@code{_imp__}と関数名または変数名を組み合わせてポインタ名を作成する。

他のコンパイラとの互換性のため、@code{__declspec(dllimport)}を@code {__attribute__((dllimport))}の同義語として使うことができる。

@code{visibility}属性をサポートするシステムでは、この属性は「default」の可視性も意味する。 他の可視性を明示的に指定するのは誤りである。

現在、インライン関数の場合、属性は無視される。属性がシンボル@emph{_定義_}に適用されると、エラーが報告される。以前に@code{dllimport}と宣言されたシンボルが後で定義された場合、その属性は後続の参照では無視され、警告が発行される。この属性は、以降の@code{dllexport}の宣言によっても上書きされる。

C++クラスに適用すると、属性はインラインでないメンバ関数と静的データメンバをインポートとしてマークする。 ただし、サンクを使用してvtableを作成できるようにする仮想メソッドでは、属性は無視される。

SH Symbian OSターゲットでは、@code{dllimport}属性には別の影響もある。クラスのvtableおよび実行時の型情報がエクスポートされる可能性がある。これは、クラスにdllimportされたコンストラクタまたは非インラインで純粋でない仮想関数があり、（これらの2つの条件のいずれかに対して）クラスにインラインコンストラクタまたはデストラクタがあり、現在の翻訳単位で定義されているキー関数を持っている場合に発生する。

Microsoft Windowsターゲットでは、関数に@code{dllimport}属性を使用する必要はないが、DLL内のサンクを除去することでパフォーマンスが少し向上する。@option{-enable-auto-import}スイッチをGNUリンカーに渡すことで、インポートされた変数に@code{dllimport}属性を使用することを避けることができる。 関数と同様に、変数の属性を使用すると、DLL内のサンクがなくなる。

この属性を使用することの1つの欠点は、@code{dllimport}とマークされた@emph{_変数_}へのポインタを定数アドレスとして使用できないことである。 しかし、@code{dllimport}属性を持つ@emph{_関数_}へのポインタは定数初期化子として使用できる。 この場合、インポートlib内のスタブ関数のアドレスが参照される。 Microsoft Windowsターゲットでは、@option{-mnop-fun-dllimport}フラグを設定することで、関数の属性を無効にすることができる。
@end table

@node MIPS Function Attributes
@subsection MIPS関数属性

これらの関数属性は、MIPSバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, MIPS
この属性を使用して、指定された関数が割り込みハンドラであることを示す。コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。割込みモードを記述できるようにするために、オプションの引数が割込み属性に対してサポートされている。 デフォルトでは、GCCは外部割り込みコントローラ（EIC）モードが使用されていることを前提としている。これは、@ code{eic}を使って明示的に設定できる。割込みがマスクされていない場合、要求された割込み優先レベル（IPL）が現在のIPLにコピーされ、優先順位の高い割込みのみを有効にする効果がある。ベクタ割り込みモードを使用するには、引数@code{vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5}を使用する。これはマスクされていない割り込みサポートの動作を変更し、GCCはsw0から指定された割り込みベクタまでのすべての割り込みをマスクするように手配する。

次の属性を使用して、割り込みハンドラの動作を変更できる。
@table @code
@item use_shadow_register_set
@cindex @code{use_shadow_register_set} function attribute, MIPS
ハンドラが主な汎用レジスタの代わりにシャドウレジスタセットを使用すると仮定する。 オプションの引数@code{intstack}は、シャドウレジスタセットに有効なスタックポインタが含まれていることを示すためにサポートされている。

@item keep_interrupts_masked
@cindex @code{keep_interrupts_masked} function attribute, MIPS
関数全体に対して割り込みをマスクしておく。 この属性がなければ、GCCは可能な限り多くの関数に対して割り込みを再び有効にしようとする。

@item use_debug_exception_return
@cindex @code{use_debug_exception_return} function attribute, MIPS
@code{deret}命令を使用して復帰する。 この属性を持たない割り込みハンドラは、代わりに@code{eret}を使用して復帰する。
@end table

以下に示すように、これらの属性の任意の組み合わせを使用できる。
@smallexample
void __attribute__ ((interrupt)) v0 ();
void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();
void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();
void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();
void __attribute__ ((interrupt, use_shadow_register_set,
                     keep_interrupts_masked)) v4 ();
void __attribute__ ((interrupt, use_shadow_register_set,
                     use_debug_exception_return)) v5 ();
void __attribute__ ((interrupt, keep_interrupts_masked,
                     use_debug_exception_return)) v6 ();
void __attribute__ ((interrupt, use_shadow_register_set,
                     keep_interrupts_masked,
                     use_debug_exception_return)) v7 ();
void __attribute__ ((interrupt("eic"))) v8 ();
void __attribute__ ((interrupt("vector=hw3"))) v9 ();
@end smallexample

@item long_call
@itemx near
@itemx far
@cindex indirect calls, MIPS
@cindex @code{long_call} function attribute, MIPS
@cindex @code{near} function attribute, MIPS
@cindex @code{far} function attribute, MIPS
これらの属性は、特定の関数がMIPSでどのように呼び出されるかを指定する。属性は@option{-mlong-calls}（@pxref{MIPS Options}）コマンドラインスイッチよりも優先される。 @code{long_call}属性と@code{far}属性は同義語であり、コンパイラは最初にそのアドレスをレジスタにロードし、次にそのレジスタの内容を使用して関数を呼び出すようにする。@code{near}属性は逆の効果を持つ。 より効率的な@code{jal}命令を使用して非PIC呼び出しを行う必要があることを指定する。

@item mips16
@itemx nomips16
@cindex @code{mips16} function attribute, MIPS
@cindex @code{nomips16} function attribute, MIPS
MIPSターゲットでは、@code{mips16}および@code{nomips16}関数属性を使用して、MIPS16コード生成を局所的に選択または無効にすることができる。@code{mips16}属性を持つ関数はMIPS16コードとして出力される一方、MIPS16コード生成は@code{nomips16}属性を持つ関数では無効になる。 これらの属性は、コマンド行の@option{-mips16}オプションと@option{-mno-mips16}オプションをオーバーライドする(@pxref{MIPS Options})。

MIPS16とMIPS16の混在したコードを含むファイルをコンパイルするとき、プリプロセッサシンボル@code{__ mips16}は個々の関数内の設定ではなく、コマンドラインでの設定を反映する。MIPS16と非MIPS16コードの混合は、@code{__ builtin_apply}のようないくつかのGCC拡張とうまくやりとりできない。(@pxref{Constructing Calls}).

@item micromips, MIPS
@itemx nomicromips, MIPS
@cindex @code{micromips} function attribute
@cindex @code{nomicromips} function attribute
MIPSターゲットでは、@code{micromips}および@code{nomicromips}関数属性を使用して、microMIPSコード生成を局所的に選択またはオフにすることができる。@code{micromips}属性を持つ関数は、microMIPSコードとして出力される一方、microMIPSコード生成は、@code{nomicromips}属性を持つ関数に対しては無効である。これらの属性は、コマンド行の@option{-mmicromips}オプションと@option{-mno-micromips}オプションよりも優先される(@pxref{MIPS Options})。

microMIPSとnon-microMIPSの混在したファイルをコンパイルする場合、プリプロセッサシンボル@code{__mips_micromips}は個々の関数内の設定ではなく、コマンドラインの設定を反映する。 混合microMIPSと非microMIPSコードは、@code{__ builtin_apply}のようないくつかのGCC拡張とうまくやりとりできない。(@pxref{Constructing Calls})。

@item nocompression
@cindex @code{nocompression} function attribute, MIPS
MIPSターゲットでは、@code{nocompression}関数属性を使用して、MIPS16およびmicroMIPSコードの生成を局所的にオフにすることができる。 この属性は、コマンド行の@option{-mips16}オプションと@option{-mmicromips}オプションをオーバーライドする。(@pxref{MIPS Options}).
@end table

@node MSP430 Function Attributes
@subsection MSP430関数属性

これらの関数属性は、MSP430バックエンドによってサポートされている。

@table @code
@item critical
@cindex @code{critical} function attribute, MSP430
critical関数は、入力時に割り込みを無効にし、終了時に以前の割り込み状態を復元する。 critical関数は、@code{naked}属性や@code{reentrant}属性を持つこともできない。 それらは@code{interrupt}属性を持つことができる。

@item interrupt
@cindex @code{interrupt} function attribute, MSP430
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

名前または番号を指定する割り込み属性に引数を指定できる。 引数が数値の場合、このハンドラを割り当てるべき割込みベクタテーブル（0〜31）のスロットを示す。 引数が名前の場合は、ベクトルスロットのシンボリック名として扱われる。 これらの名前は、リンカースクリプトの適切なエントリと一致する必要がある。 デフォルトでは、ベクトル26は@code{watchdog}、ベクトル30は@code{nmi}、ベクトル31は@code{reset}という名前が認識される。

@item naked
@cindex @code{naked} function attribute, MSP430
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。

@item reentrant
@cindex @code{reentrant} function attribute, MSP430
reentrant関数は、入力時に割り込みを無効にし、終了時に割り込みを有効にする。reentrant関数は@code{naked}属性や@code{critical}属性を持つこともできない。 それらは@code{interrupt}属性を持つことができる。

@item wakeup
@cindex @code{wakeup} function attribute, MSP430
この属性は割り込み関数にのみ適用される。 非割り込み関数に適用されると、暗黙のうちに無視される。 ウェイクアップ割り込み関数は、関数が終了したときに低電力の可能性がある状態からプロセッサを起床させる。

@item lower
@itemx upper
@itemx either
@cindex @code{lower} function attribute, MSP430
@cindex @code{upper} function attribute, MSP430
@cindex @code{either} function attribute, MSP430
MSP430ターゲットでは、これらの属性を使用して、関数または変数を低メモリ、高メモリに配置するか、プレースメントをリンカーに任せて決定するかを指定できる。 属性は、MSP430Xアーキテクチャ用にコンパイルする場合にのみ意味を持つ。

この属性は、セクションを@code{.lower}と@code{.upper}というプレフィックスで配置する場所を指定するために拡張されたリンカスクリプトと連携して動作する。たとえば、@code{.data}セクションを配置するだけでなく、@code{.lower.data}セクションと@code {.upper.data}セクションの配置も指定する。その目的は、@code{lower}セクションが小さいがアクセスしやすいメモリ領域に配置され、上部セクションがより大きいがアクセスは遅い領域に配置されることである。
@code{either}属性は特別である。 それは、オブジェクトに対応する@code{lower}セクションにオブジェクトを配置するようリンカに指示する。 十分な空きがない場合、オブジェクトは代わりに対応する@code{upper}セクションに配置される。 配置アルゴリズムはあまり洗練されていないことに注意せよ。 @code{lower}セクションの最適なパッキングを見つけることを試みない。 それは単にオブジェクトをワンパスで作り、可能な限りベストを尽くす。 しかし、@option{-ffunction-sections}と@option{-fdata-sections}のコマンドラインオプションを使うと、パックする領域が小さくて簡単になるので、パッキングに役立つ。
@end table

@node NDS32 Function Attributes
@subsection NDS32関数属性

これらの関数属性は、NDS32バックエンドによってサポートされている。

@table @code
@item exception
@cindex @code{exception} function attribute
@cindex exception handler functions, NDS32
指定された関数が例外ハンドラであることを示すには、NDS32ターゲットでこの属性を使用する。 コンパイラは、対応するセクションを生成して例外ハンドラで使用する。

@item interrupt
@cindex @code{interrupt} function attribute, NDS32
NDS32ターゲットでは、この属性は指定された関数が割り込みハンドラであることを示す。 コンパイラは、対応するセクションを生成して割り込みハンドラで使用する。 次の属性を使用して動作を変更できる。
@table @code
@item nested
@cindex @code{nested} function attribute, NDS32
この割り込みサービスルーチンは割り込み可能である。
@item not_nested
@cindex @code{not_nested} function attribute, NDS32
この割り込みサービスルーチンは中断できない。
@item nested_ready
@cindex @code{nested_ready} function attribute, NDS32
この割り込みサービスルーチンは、@code{PSW.GIE}（グローバル割り込み許可）がセットされた後に割り込み可能である。 これにより、割り込みサービスルーチンは、割り込みを有効にする前に、いくつかの重要な短いコードを終了することができる。
@item save_all
@cindex @code{save_all} function attribute, NDS32
システムは、割り込みハンドラに入る前にすべてのレジスタをスタックに保存するのを助ける。
@item partial_save
@cindex @code{partial_save} function attribute, NDS32
システムは、割り込みハンドラに入る前に呼び出し元レジスタをスタックに保存するのを助ける。
@end table

@item naked
@cindex @code{naked} function attribute, NDS32
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。

@item reset
@cindex @code{reset} function attribute, NDS32
@cindex reset handler functions
指定された関数がリセットハンドラであることを示すには、NDS32ターゲットでこの属性を使用する。 コンパイラは対応するセクションを生成し、リセットハンドラで使用する。 追加の例外処理を提供するには、次の属性を使用できる。
@table @code
@item nmi
@cindex @code{nmi} function attribute, NDS32
NMI例外を処理するユーザー定義関数を提供する。
@item warm
@cindex @code{warm} function attribute, NDS32
ウォームリセット例外を処理するためのユーザー定義関数を提供する。
@end table
@end table

@node Nios II Function Attributes
@subsection Nios II関数属性

これらの関数属性は、Nios IIバックエンドでサポートされている。

@table @code
@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

Nios II用にコンパイルする場合は、次のオプションを使用できる。

@table @samp
@item custom-@var{insn}=@var{N}
@itemx no-custom-@var{insn}
@cindex @code{target("custom-@var{insn}=@var{N}")} function attribute, Nios II
@cindex @code{target("no-custom-@var{insn}")} function attribute, Nios II
各@samp{custom-@var{insn}=@var{N}}属性は、@var{insn}を使用するコードを生成するときに@var{N}をエンコードしてカスタム命令をローカルで使用できるようにする。 同様に、@samp{no-custom-@var{insn}}はカスタム命令@var{insn}の使用をローカルで禁止する。これらのターゲット属性は、@option{-mcustom-@var{insn}=@var{N}}および@option{-mno-custom-@var{insn}}コマンドラインオプションに対応し、 @var{insn}キーワードと同じセットをサポートする。詳細は@xref{Nios II Options}を参照せよ。

@item custom-fpu-cfg=@var{name}
@cindex @code{target("custom-fpu-cfg=@var{name}")} function attribute, Nios II
この属性は@option{-mcustom-fpu-cfg=@var{name}}コマンドラインオプションに対応し、@var{name}というカスタム命令の定義済みセットを選択する。さらなる情報は@xref{Nios II Options}。
@end table
@end table

@node Nvidia PTX Function Attributes
@subsection Nvidia PTX関数属性

これらの関数属性は、Nvidia PTXバックエンドによってサポートされている。

@table @code
@item kernel
@cindex @code{kernel} attribute, Nvidia PTX
この属性は、対応する関数をCUDA RTライブラリ経由でホストから呼び出すことができるカーネル関数としてコンパイルする必要があることを示す。デフォルトでは、関数は他のPTX関数からのみ呼び出すことができる。

カーネル関数は@code {void}戻り型を持たなければならない。
@end table

@node PowerPC Function Attributes
@subsection PowerPC関数属性

これらの関数属性は、PowerPCバックエンドによってサポートされている。

@table @code
@item longcall
@itemx shortcall
@cindex indirect calls, PowerPC
@cindex @code{longcall} function attribute, PowerPC
@cindex @code{shortcall} function attribute, PowerPC
@code{longcall}属性は、関数がコールサイトから離れていて、別の（より高価な）呼び出しシーケンスを必要とする可能性があることを示す。 @code{shortcall}属性は、短い呼び出しシーケンスを使用するために関数が常に十分に近いことを示す。 これらの属性は、@option{-mlongcall}スイッチと@code{#pragma longcall}設定の両方を上書きする。

長いコールが必要かどうかの詳細については、@xref{RS/6000 and PowerPC Options}。

@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

PowerPCでは、次のオプションを使用できる。

@table @samp
@item altivec
@itemx no-altivec
@cindex @code{target("altivec")} function attribute, PowerPC
AltiVec命令を使用するコードを生成する（しない）。 32ビットコードでは、コマンドラインで@option{-mabi=altivec}を使用しない限り、AltiVec命令を有効にすることはできない。

@item cmpb
@itemx no-cmpb
@cindex @code{target("cmpb")} function attribute, PowerPC
POWER6プロセッサーおよびPowerPC V2.05アーキテクチャーをサポートする他のプロセッサーでインプリメントされた比較バイト命令を使用する（使用しない）コードを生成する。

@item dlmzb
@itemx no-dlmzb
@cindex @code{target("dlmzb")} function attribute, PowerPC
IBM 405、440、464、および476プロセッサーで文字列検索@samp{dlmzb}命令を使用する（使用しない）コードを生成する。 この命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item fprnd
@itemx no-fprnd
@cindex @code{target("fprnd")} function attribute, PowerPC
POWER5+プロセッサーおよびPowerPC V2.03アーキテクチャーをサポートする他のプロセッサーに実装された整数値命令を使用する（使用しない）コードを生成する。

@item hard-dfp
@itemx no-hard-dfp
@cindex @code{target("hard-dfp")} function attribute, PowerPC
一部のPOWERプロセッサーで実装されている10進浮動小数点命令を使用する（使用しない）コードを生成する。

@item isel
@itemx no-isel
@cindex @code{target("isel")} function attribute, PowerPC
ISEL命令を使用する（使用しない）コードを生成する。

@item mfcrf
@itemx no-mfcrf
@cindex @code{target("mfcrf")} function attribute, PowerPC
POWER4プロセッサーおよびPowerPC V2.01アーキテクチャーをサポートする他のプロセッサーで実装された条件レコード・フィールド命令を使用する（使用しない）コードを生成する。

@item mfpgpr
@itemx no-mfpgpr
@cindex @code{target("mfpgpr")} function attribute, PowerPC
POWER6Xプロセッサーおよび拡張PowerPC V2.05アーキテクチャーをサポートする他のプロセッサーで実装された汎用レジスタ命令とのFP移動を使用する（使用しない）コードを生成する。

@item mulhw
@itemx no-mulhw
@cindex @code{target("mulhw")} function attribute, PowerPC
IBM 405,440,464、および476プロセッサ上のハーフワード乗算命令および乗算累算命令を使用する（使用しない）コードを生成する。これらの命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item multiple
@itemx no-multiple
@cindex @code{target("multiple")} function attribute, PowerPC
複数ワードのロード命令とストアの複数ワード命令を使用する（使用しない）コードを生成する。

@item update
@itemx no-update
@cindex @code{target("update")} function attribute, PowerPC
ベースレジスタを計算されたメモリ位置のアドレスに更新するロードまたはストア命令を使用する（使用しない）コードを生成する。

@item popcntb
@itemx no-popcntb
@cindex @code{target("popcntb")} function attribute, PowerPC
POWER5プロセッサーおよびPowerPC V2.02アーキテクチャーをサポートする他のプロセッサーで実装されたポップカウントおよび倍精度のFP逆数推定命令を使用する（使用しない）コードを生成する。

@item popcntd
@itemx no-popcntd
@cindex @code{target("popcntd")} function attribute, PowerPC
POWER7プロセッサーおよびPowerPC V2.06アーキテクチャーをサポートする他のプロセッサーに実装されたpopcount命令を使用する（使用しない）コードを生成する。

@item powerpc-gfxopt
@itemx no-powerpc-gfxopt
@cindex @code{target("powerpc-gfxopt")} function attribute, PowerPC
浮動小数点選択を含むグラフィックスグループのオプションのPowerPCアーキテクチャ命令を使用する（使用しない）コードを生成する。

@item powerpc-gpopt
@itemx no-powerpc-gpopt
@cindex @code{target("powerpc-gpopt")} function attribute, PowerPC
浮動小数点平方根を含む汎用目的グループのオプションのPowerPCアーキテクチャ命令を使用する（使用しない）コードを生成する。

@item recip-precision
@itemx no-recip-precision
@cindex @code{target("recip-precision")} function attribute, PowerPC
逆数見積もり命令がPowerPC ABIよりも高い精度の見積もりを提供すると仮定する（仮定しない）。

@item string
@itemx no-string
@cindex @code{target("string")} function attribute, PowerPC
ロード文字列命令とストア文字列ワード命令を使用し、複数のレジスタを保存し、小さなブロック移動を行う（行わない）コードを生成する。

@item vsx
@itemx no-vsx
@cindex @code{target("vsx")} function attribute, PowerPC
ベクトル/スカラー（VSX）命令を使用する（使用しない）コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にする。 32ビットコードでは、コマンドラインで@option{-mabi = altivec}を使用しない限り、VSXまたはAltiVec命令を有効にすることはできない。

@item friz
@itemx no-friz
@cindex @code{target("friz")} function attribute, PowerPC
@option{-funsafe-math-optimizations}オプションを使用して浮動小数点値の64ビット整数への丸めと浮動小数点への最適化を最適化する場合、@code{friz}命令を生成するい（生成しない）。 浮動小数点数が大きすぎて整数に収まらない場合、@code{friz}命令は同じ値を返さない。

@item avoid-indexed-addresses
@itemx no-avoid-indexed-addresses
@cindex @code{target("avoid-indexed-addresses")} function attribute, PowerPC
インデックス付きのロードまたはストア命令の使用を回避する（回避しない）コードを生成する。

@item paired
@itemx no-paired
@cindex @code{target("paired")} function attribute, PowerPC
PAIRED simd命令の生成を使用する（使用しない）コードを生成する。

@item longcall
@itemx no-longcall
@cindex @code{target("longcall")} function attribute, PowerPC
すべての呼び出しが遠く離れていると想定している（想定していない）コードを生成し、より高価な呼び出しシーケンスが必要になるようにする。

@item cpu=@var{CPU}
@cindex @code{target("cpu=@var{CPU}")} function attribute, PowerPC
関数のコンパイル時にコードを生成するアーキテクチャを指定します。 32ビットコードを生成するときに@code {target("cpu=power7")}属性を選択すると、コマンドラインで@option{-mabi=altivec}オプションを使用しない限り、VSXおよびAltiVec命令は生成されない。

@item tune=@var{TUNE}
@cindex @code{target("tune=@var{TUNE}")} function attribute, PowerPC
関数のコンパイル時にチューニングするアーキテクチャを指定する。 @code{target("tune=@var{TUNE}")}属性を指定せず、@code{target("cpu=@var{CPU}")}属性を指定すると、コマンドラインで指定されたデフォルトのチューニングではなく、@var{CPU}アーキテクチャ向けにコンパイルする。
@end table

PowerPCでは、呼び出し側が呼び出し側のターゲットオプションのサブセットを持っていない限り、インライナーは呼び出し側とは異なるターゲットオプションを持つ関数をインラインしない。
@end table

@node RL78 Function Attributes
@subsection RL78関数属性

これらの関数属性は、RL78バックエンドによってサポートされている。

@table @code
@item interrupt
@itemx brk_interrupt
@cindex @code{interrupt} function attribute, RL78
@cindex @code{brk_interrupt} function attribute, RL78
これらの属性は、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@code{BRK}オペコード（つまり、@code{RETI}の代わりに@code{RETB}で終わらなければならないもの）で使用するハンドラには、@code{interrupt}の代わりに@code{brk_interrupt}を使用すること。

@item naked
@cindex @code{naked} function attribute, RL78
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。
@end table

@node RX Function Attributes
@subsection RX関数属性

これらの関数属性は、RXバックエンドによってサポートされている。

@table @code
@item fast_interrupt
@cindex @code{fast_interrupt} function attribute, RX
指定された機能が高速割り込みハンドラであることを示すには、この属性をRXポートで使用する。 これは、@code{reit}の代わりに@code{freit}が返される点を除いて、@code{interrupt}属性と同じである。

@item interrupt
@cindex @code{interrupt} function attribute, RX
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

RXターゲットでは、1つまたは複数のベクタ番号を属性の引数として指定し、代替テーブル名の名前を付けることができる。 パラメータは順次処理されるため、1つのハンドラを複数のテーブルの複数のエントリに割り当てることができる。 また、現在のテーブルの空きスロットに関数を使用させるために、マジック文字列@code{"$ default"}を渡すこともできる。

この例では、デフォルトテーブルの1つのベクトルに関数を単純に代入している（チップ固有のシンボリックベクトル名にはプリプロセッサマクロを使用できることに注意）。
@smallexample
void __attribute__ ((interrupt (5))) txd1_handler ();
@end smallexample

この例では、デフォルトテーブルの2つのスロットに関数を割り当て（プリプロセッサマクロを他の場所で定義して使用）、@code{dct}テーブルのデフォルトにする。
@smallexample
void __attribute__ ((interrupt (RXD1_VECT,RXD2_VECT,"dct","$default")))
	txd1_handler ();
@end smallexample

@item naked
@cindex @code{naked} function attribute, RX
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。

@item vector
@cindex @code{vector} function attribute, RX
このRX属性は、パラメータを含む@code{interrupt}属性に似ていまるが、関数を割り込みハンドラ型関数にしない（つまり、通常のC関数呼び出しABIを保持する）。 その引数の説明については、@code{interrupt}属性を参照せよ。
@end table

@node S/390 Function Attributes
@subsection S/390関数属性

これらの関数属性は、S/390でサポートされている。

@table @code
@item hotpatch (@var{halfwords-before-function-label},@var{halfwords-after-function-label})
@cindex @code{hotpatch} function attribute, S/390

S/390 System zターゲットでは、この関数属性を使用して、GCCに「ホット・パッチ」機能のプロローグを生成させることができる。 @option{-mhotpatch =}コマンドラインオプションを同時に使用すると、@code{hotpatch}属性が優先される。 最初の2つの引数は、関数ラベルの前に追加するハーフワードの数を指定する。 2番目の引数を使用して、関数ラベルの後ろに追加するハーフワードの数を指定できる。 両方の引数について、最大許容値は1000000である。

両方の引数がゼロの場合、ホットパッチは無効になる。

@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

S/390では、以下のオプションがサポートされています。

@table @samp
@item arch=
@item tune=
@item stack-guard=
@item stack-size=
@item branch-cost=
@item warn-framesize=
@item backchain
@itemx no-backchain
@item hard-dfp
@itemx no-hard-dfp
@item hard-float
@itemx soft-float
@item htm
@itemx no-htm
@item vx
@itemx no-vx
@item packed-stack
@itemx no-packed-stack
@item small-exec
@itemx no-small-exec
@item mvcle
@itemx no-mvcle
@item warn-dynamicstack
@itemx no-warn-dynamicstack
@end table

これらのオプションは、S/390固有のコマンドラインオプション（@option {-m}のプレフィックスなし）とまったく同じように機能するが、機能マクロは変更されない。 例えば、

@smallexample
@code{target("no-vx")}
@end smallexample

は@code {__ VEC__}マクロを定義解除しない。
@end table

@node SH Function Attributes
@subsection SH関数属性

これらの関数属性は、SHファミリのプロセッサでサポートされている。

@table @code
@item function_vector
@cindex @code{function_vector} function attribute, SH
@cindex calling functions through the function vector on SH2A
SH2Aターゲットでは、この属性はTBR相対アドレッシングモードを使用して呼び出される関数を宣言する。 この属性の引数は、すべてのTBR相対アドレス可能関数を含むベクトルテーブル内の同じ関数のエントリ番号である。 正しい動作のためには、この属性を持つ関数が呼び出される前に、ベクタテーブルの開始点を指すようにTBRを設定する必要がある。 通常、初期化を行うには、スタートアップルーチンが適している。 TBR相対ベクトルテーブルは最大256の機能エントリを有することができる。 これらの関数へのジャンプは、SH2A固有の遅延なし分岐命令JSR/N @@(disp8, TBR)を使用して生成される。 この属性が正しく機能するには、GNU binutilsバージョン2.7以降のGASおよびGLDを使用する必要がある。

アプリケーションでは、一度呼び出される関数の場合、この属性は少なくとも8バイトのコードを保存する。 同じ関数に対して他の連続した呼び出しが行われている場合は、これらの呼び出しごとに2バイトのコードが保存される。

@item interrupt_handler
@cindex @code{interrupt_handler} function attribute, SH
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item nosave_low_regs
@cindex @code{nosave_low_regs} function attribute, SH
@code{interrupt_handler}関数がレジスタR0..R7を保存して復元してはならないことを示すには、SHターゲットでこの属性を使用する。 これは、リエントラントでない割り込みハンドラに対して2番目のR0..R7レジスタバンクを持つSH3*およびSH4*ターゲットで使用できる。

@item renesas
@cindex @code{renesas} function attribute, SH
SHターゲットでは、この属性はルネサスABIの後に関数または構造体が続くことを指定する。

@item resbank
@cindex @code{resbank} function attribute, SH
SH2Aターゲットでは、@code{interrupt_handler}ルーチン用のレジスタバンクを使用して高速レジスタの保存と復元が可能である。 バンクへのセーブは、CPUがレジスタバンクを使用する割り込みを受け付けた後に自動的に実行される。

汎用レジスタR0〜R14、制御レジスタGBR、およびシステム・レジスタMACH、MACL、PRおよびベクタ・テーブル・アドレス・オフセットを含む19の32ビット・レジスタは、レジスタ・バンクに保存される。 レジスタバンクはファーストイン・ラスト・アウト（FILO）シーケンスでスタックされている。 RESBANK命令を発行することにより、バンクからの復元が実行される。

@item sp_switch
@cindex @code{sp_switch} function attribute, SH
この属性をSHで使用すると、@code{interrupt_handler}関数を代替スタックに切り替える必要がある。 代替スタックのアドレスを保持するグローバル変数に名前を付ける文字列引数が必要である。

@smallexample
void *alt_stack;
void f () __attribute__ ((interrupt_handler,
                          sp_switch ("alt_stack")));
@end smallexample

@item trap_exit
@cindex @code{trap_exit} function attribute, SH
@code{interrupt_handler}が@code {trap}の代わりに@code {rte}を使用して戻るには、SHのこの属性を使用する。 この属性には、使用されるトラップ番号を指定する整数引数が必要である。

@item trapa_handler
@cindex @code{trapa_handler} function attribute, SH
SHターゲットでは、この関数属性は@code{interrupt_handler}と似ているが、すべてのレジスタを保存して復元するわけではない。
@end table

@node SPU Function Attributes
@subsection SPU関数属性

これらの関数属性は、SPUバックエンドによってサポートされている。

@table @code
@item naked
@cindex @code{naked} function attribute, SPU
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。
@end table

@node Symbian OS Function Attributes
@subsection Symbian OS関数属性

@code {dllexport}属性と@code {dllimport}属性の議論には、@xref{Microsoft Windows Function Attributes}。

@node V850 Function Attributes
@subsection V850関数属性

V850バックエンドは、次の関数属性をサポートしている。

@table @code
@item interrupt
@itemx interrupt_handler
@cindex @code{interrupt} function attribute, V850
@cindex @code{interrupt_handler} function attribute, V850
これらの属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、どちらかの属性が存在する場合に割り込みハンドラで使用するのに適した関数の入力および終了シーケンスを生成する。
@end table

@node Visium Function Attributes
@subsection Visium関数属性

これらの関数属性は、Visiumバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, Visium
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。
@end table

@node x86 Function Attributes
@subsection x86関数属性

これらの関数属性は、x86バックエンドによってサポートされている。

@table @code
@item cdecl
@cindex @code{cdecl} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
@opindex mrtd
x86-32ターゲットでは、@code{cdecl}属性により、コンパイラは呼び出し元の関数が引数を渡すために使用されたスタック領域をポップすると想定する。 これは、@option{-mrtd}スイッチの効果を無効にするのに便利である。

@item fastcall
@cindex @code{fastcall} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
x86-32ターゲットでは、@code{fastcall}属性により、コンパイラはレジスタECXの最初の引数（整数型の場合）とレジスタEDXの2番目の引数（整数型の場合）を渡す。 後続およびその他の型付き引数がスタックに渡される。 呼び出された関数は引数をスタックからポップする。 引数の数が可変であれば、すべての引数がスタックにプッシュされる。

@item thiscall
@cindex @code{thiscall} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
x86-32ターゲットでは、@code{thiscall}属性はコンパイラにレジスタECXの最初の引数（整数型の場合）を渡させる。 後続およびその他の型付き引数がスタックに渡される。 呼び出された関数は引数をスタックからポップする。 引数の数が可変であれば、すべての引数がスタックにプッシュされる。@code{thiscall}属性は、C ++非静的メンバ関数を対象としている。GCCの拡張として、この呼び出し規約はC関数や静的メンバーメソッドに使用できる。

@item ms_abi
@itemx sysv_abi
@cindex @code{ms_abi} function attribute, x86
@cindex @code{sysv_abi} function attribute, x86
32ビットおよび64ビットのx86ターゲットでは、ABI属性を使用して、関数に使用する呼び出し規則を指定できる。@code{ms_abi}属性は、Microsoft ABIを使用するようにコンパイラに指示する。@code {sysv_abi}属性は、GNU/Linuxなどのシステムで使用されるABIを使用するようコンパイラに指示する。 デフォルトでは、Windowsを対象とするときにMicrosoft ABIを使用する。 他のすべてのシステムでは、デフォルトはx86/AMD ABIである。

Microsoft Windowsの64ビットターゲットの@code{ms_abi}属性には、現在、@option{-maccumulate-outgoing-args}オプションが必要であることに注意せよ。

@item callee_pop_aggregate_return (@var{number})
@cindex @code{callee_pop_aggregate_return} function attribute, x86
x86-32ターゲットでは、この属性を使用して、集約がメモリー内で返される方法を制御できる。 呼び出し側が非表示のポインタを残りの引数と一緒にポップする必要がある場合は、@var{number}をゼロと指定する。 呼び出し先が非表示のポインタをポップする場合は、@var{number}を1と指定する。

デフォルトのx86-32 ABIでは、呼び出し先が非表示のポインタのスタックをポップすることを前提としている。 ただし、x86-32 Microsoft Windowsターゲットでは、コンパイラは呼び出し元が非表示のポインタのスタックをポップすることを前提としている。

@item ms_hook_prologue
@cindex @code{ms_hook_prologue} function attribute, x86
32ビットおよび64ビットx86ターゲットでは、この関数属性を使用して、Microsoft Windows XP Service Pack 2以降のWin32 API関数で使用される「ホットパッチ」関数プロローグをGCCに生成させることができる。

@item regparm (@var{number})
@cindex @code{regparm} function attribute, x86
@cindex functions that are passed arguments in registers on x86-32
x86-32ターゲットで、@code{regparm}属性により、整数型である場合には、コンパイラは1個から@var{number}個までの引数をスタックの代わりにレジスタEAX、EDX、およびECXで渡す。可変数の引き数を取る関数は引き続きスタック上のすべての引数を渡す。

一部のELFシステムでは、この属性は、遅延バインディング（デフォルト）である共有ライブラリのグローバル関数には適していないことに注意せよ。遅延バインディングは、標準の呼び出し規約に従って、EAX、EDX、ECXが破壊できると仮定しているローダ内の解決コードを介して、最初の呼び出しを送信する。 Solaris 8はこの影響を受ける。 GNU Cライブラリバージョン2.1以上とFreeBSDを搭載したシステムは、そこにあるローダーがEAX、EDX、ECXを保存するので安全だと考えられている。 （問題が発生しないように、必要に応じて遅延バインディングをリンカまたはローダで無効にすることができる）。

@item sseregparm
@cindex @code{sseregparm} function attribute, x86
SSEをサポートしているx86-32ターゲットでは、@code{sseregparm}属性により、コンパイラーはスタック上ではなくSSEレジスターで最大3つの浮動小数点引数を渡す。 可変数の引数をとる関数は、スタック上のすべての浮動小数点引数を引き続き渡す。

@item force_align_arg_pointer
@cindex @code{force_align_arg_pointer} function attribute, x86
x86ターゲットでは、@code{force_align_arg_pointer}属性を個々の関数定義に適用して、必要に応じて実行時スタックを再調整する代替のプロローグとエピローグを生成することができる。 これは、SSEとの互換性のために16バイトのスタックを維持する最新のコードと4バイトの整列されたスタックで実行されるレガシーコードの混在をサポートする。

@item stdcall
@cindex @code{stdcall} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
x86-32ターゲットでは、@code{stdcall}属性は、可変数の引数を取らない限り、引数を渡すために使用されるスタック領域から、呼び出された関数がポップすることをコンパイラが想定するようにする。

@item no_caller_saved_registers
@cindex @code{no_caller_saved_registers} function attribute, x86
指定された関数に呼び出し元保存レジスタがないことを示すには、この属性を使用する。 つまり、すべてのレジスタが呼び出し先保存される。 たとえば、この属性は割り込みハンドラから呼び出された関数に使用できる。 コンパイラは、EFLAGSレジスタを除いて、変更されたレジスタを保存および復元するために、適切な関数入力および終了シーケンスを生成する。 GCCはMPX、SSE、MMX、およびx87状態を保持しないので、@code{no_caller_saved_registers}属性を持つ関数をコンパイルするには、GCCオプションの@option{-mgeneral-regs-only}を使用する必要がある。

@item interrupt
@cindex @code{interrupt} function attribute, x86
この属性を使用して、指定された関数が割り込みハンドラまたは例外ハンドラであることを示す。（さらに説明されているように、関数に渡されるパラメータに応じて）。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。 @code{RET}命令の代わりに@code{IRET}命令が、割り込みハンドラから復帰するために使用される。 @code{IRET}命令で復元されるEFLAGSレジスタを除くすべてのレジスタは、コンパイラによって保持される。 GCCはMPX、SSE、MMX、およびx87の状態を保持しないので、GCCオプションの@option{-mgeneral-regs-only}を使用して割り込みハンドラと例外ハンドラをコンパイルする必要がある。

スタック切り替えなしで割り込み可能なコードは、@option{-mno-red-zone}でコンパイルする必要がある。なぜなら、ハードウェア設計のために割り込みハンドラがレッド・ゾーンに触れることができるからである。

割り込みハンドラは、必須のポインタ引数で宣言する必要がある。

@smallexample
struct interrupt_frame;

__attribute__ ((interrupt))
void
f (struct interrupt_frame *frame)
@{
@}
@end smallexample

@noindent
プロセッサーのマニュアルで説明されているように、@code{struct interrupt_frame}を定義する必要がある。

例外ハンドラは、スタック上にエラーコードをプッシュするため、割り込みハンドラとは異なる。 例外ハンドラの宣言は、割り込みハンドラの宣言と似ているが、必須の関数シグネチャは異なる。 コンパイラは@code{IRET}命令の前にスタックからエラーコードをポップするように手配する。

@smallexample
#ifdef __x86_64__
typedef unsigned long long int uword_t;
#else
typedef unsigned int uword_t;
#endif

struct interrupt_frame;

__attribute__ ((interrupt))
void
f (struct interrupt_frame *frame, uword_t error_code)
@{
  ...
@}
@end smallexample

例外ハンドラは、エラーコードをプッシュする例外に対してのみ使用する必要がある。 それ以外の場合は割り込みハンドラを使用する必要がある。 間違った種類のハンドラが使用されると、システムがクラッシュする。

@item target (@var{options})
@cindex @code{target} function attribute
@ref {Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

x86では、次のオプションを使用できる。
@table @samp
@item abm
@itemx no-abm
@cindex @code{target("abm")} function attribute, x86
拡張ビット命令の生成を有効/無効にする。

@item aes
@itemx no-aes
@cindex @code{target("aes")} function attribute, x86
AES命令の生成を有効/無効にする。

@item default
@cindex @code{target("default")} function attribute, x86
@xref{Function Multiversioning}デフォルトの関数バージョンを指定するために使用される。

@item mmx
@itemx no-mmx
@cindex @code{target("mmx")} function attribute, x86
MMX命令の生成を有効/無効にする。

@item pclmul
@itemx no-pclmul
@cindex @code{target("pclmul")} function attribute, x86
PCLMUL命令の生成を有効/無効にする。

@item popcnt
@itemx no-popcnt
@cindex @code{target("popcnt")} function attribute, x86
POPCNT命令の生成を有効/無効にする。

@item sse
@itemx no-sse
@cindex @code{target("sse")} function attribute, x86
SSE命令の生成を有効/無効にする。

@item sse2
@itemx no-sse2
@cindex @code{target("sse2")} function attribute, x86
SSE2命令の生成を有効/無効にする。

@item sse3
@itemx no-sse3
@cindex @code{target("sse3")} function attribute, x86
SSE3命令の生成を有効/無効にする。

@item sse4
@itemx no-sse4
@cindex @code{target("sse4")} function attribute, x86
SSE4命令の生成を有効/無効にする。（SSE4.1とSSE4.2の両方。）

@item sse4.1
@itemx no-sse4.1
@cindex @code{target("sse4.1")} function attribute, x86
SSE4.1命令の生成を有効/無効にする。

@item sse4.2
@itemx no-sse4.2
@cindex @code{target("sse4.2")} function attribute, x86
SSE4.2命令の生成を有効/無効にする。

@item sse4a
@itemx no-sse4a
@cindex @code{target("sse4a")} function attribute, x86
SSE4A命令の生成を有効/無効にする。

@item fma4
@itemx no-fma4
@cindex @code{target("fma4")} function attribute, x86
FMA4命令の生成を有効/無効にする。

@item xop
@itemx no-xop
@cindex @code{target("xop")} function attribute, x86
XOP命令の生成を有効/無効にする。

@item lwp
@itemx no-lwp
@cindex @code{target("lwp")} function attribute, x86
LWP命令の生成を有効/無効にする。

@item ssse3
@itemx no-ssse3
@cindex @code{target("ssse3")} function attribute, x86
SSSE3命令の生成を有効/無効にする。

@item cld
@itemx no-cld
@cindex @code{target("cld")} function attribute, x86
文字列が移動する前にCLDの生成を有効/無効にする。

@item fancy-math-387
@itemx no-fancy-math-387
@cindex @code{target("fancy-math-387")} function attribute, x86
387浮動小数点ユニットの@code{sin}、@code{cos}、および@code{sqrt}命令の生成を有効/無効にする。

@item ieee-fp
@itemx no-ieee-fp
@cindex @code{target("ieee-fp")} function attribute, x86
IEEE演算に依存する浮動小数点の生成を有効/無効にする。

@item inline-all-stringops
@itemx no-inline-all-stringops
@cindex @code{target("inline-all-stringops")} function attribute, x86
文字列操作のインライン展開を有効または無効にする。

@item inline-stringops-dynamically
@itemx no-inline-stringops-dynamically
@cindex @code{target("inline-stringops-dynamically")} function attribute, x86
小さな文字列操作を実行するためのインラインコードの生成と大きな操作のためにライブラリルーチンを呼び出しを有効または無効にする。

@item align-stringops
@itemx no-align-stringops
@cindex @code{target("align-stringops")} function attribute, x86
インラインストリング操作の宛先を揃える。

@item recip
@itemx no-recip
@cindex @code{target("recip")} function attribute, x86
浮動小数点除算の代わりに追加のNewton-Raphsonステップの実行が後に続くRCPSS、RCPPS、RSQRTSS、およびRSQRTPS命令の生成を有効/無効にする。

@item arch=@var{ARCH}
@cindex @code{target("arch=@var{ARCH}")} function attribute, x86
関数をコンパイルするためのコードを生成するアーキテクチャを指定する。

@item tune=@var{TUNE}
@cindex @code{target("tune=@var{TUNE}")} function attribute, x86
関数のコンパイル時にチューニングするアーキテクチャを指定する。

@item fpmath=@var{FPMATH}
@cindex @code{target("fpmath=@var{FPMATH}")} function attribute, x86
使用する浮動小数点ユニットを指定する。 コンマは異なるオプションを分離するため、@code{target( "fpmath=sse,387")}オプションは@code{target("fpmath=sse+387")}と指定する必要がある。

@item indirect_branch("@var{choice}")
@cindex @code{indirect_branch} function attribute, x86
x86ターゲットでは、@code{indirect_branch}属性で関数に間接呼び出しとジャンプを@var{choice}を使って変換するようにさせる。 @samp{keep}は間接呼び出しとジャンプを保持する。@samp{thunk}は間接呼び出しとジャンプを、サンクの呼び出しと復帰に変換する。@samp{thunk-inline}は間接呼び出しとジャンプをインライン化されたサンクの呼び出しと復帰に変換する。@samp{thunk-extern}は間接呼び出しとジャンプを別のオブジェクトファイルで提供されたサンクへの外部呼び出しと復帰に変換する。

@item function_return("@var{choice}")
@cindex @code{function_return} function attribute, x86
x86ターゲットでは、@code{function_return}属性に@var{choice}で関数復帰を変換するようにさせる。@samp{keep}は、関数復帰は変更されない。 @samp{thunk}は関数復帰をサンクの呼び出しと復帰に変換する。 @samp{thunk-inline}は、関数復帰をインライン化されたサンクの呼び出しと復帰に変換する。 @samp {thunk-extern}は、関数復帰を、別のオブジェクトファイルで提供されるサンクの呼び出しと復帰に変換する。
@end table

x86では、呼び出し側が呼び出し元のターゲットオプションのサブセットを持たない限り、インライナは呼び出し元とは異なるターゲットオプションを持つ関数をインライン化しない。 たとえば、@code{-msse3}は@code{-msse2}を意味するため、@code{target("sse3")}で宣言された関数は@code{target("sse2")}で関数をインライン化できる。
@end table

@node Xstormy16 Function Attributes
@subsection Xstormy16関数属性

これらの関数属性は、Xstormy16バックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, Xstormy16
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。
@end table

@node Variable Attributes
@section 変数の属性の実行指定
@cindex attribute of variables
@cindex variable attributes

キーワード@code {__ attribute__}を使用すると、変数や構造体フィールドの特別な属性を指定できる。このキーワードの後には、二重括弧内の属性指定が続く。いくつかの属性は現在、変数に対して一般的に定義されている。 他の属性は、特定のターゲットシステム上の変数に対して定義されている。他の属性は、関数(@pxref{Function Attributes})、ラベル(@pxref{Label Attributes})、列挙子(@pxref{Enumerator Attributes})、文(@pxref{Statement Attributes})、および型 (@pxref{Type Attributes})に対して定義されている。他のフロントエンドはより多くの属性を定義するかもしれない。
(@pxref{C++ Extensions,,C++言語族に対する拡張}).

属性を使った正確な構文の詳細は@xref{Attribute Syntax}。

@menu
* Common Variable Attributes::
* AVR Variable Attributes::
* Blackfin Variable Attributes::
* H8/300 Variable Attributes::
* IA-64 Variable Attributes::
* M32R/D Variable Attributes::
* MeP Variable Attributes::
* Microsoft Windows Variable Attributes::
* MSP430 Variable Attributes::
* Nvidia PTX Variable Attributes::
* PowerPC Variable Attributes::
* RL78 Variable Attributes::
* SPU Variable Attributes::
* V850 Variable Attributes::
* x86 Variable Attributes::
* Xstormy16 Variable Attributes::
@end menu

@node Common Variable Attributes
@subsection 共通変数属性

次の属性は、ほとんどのターゲットでサポートされている。

@table @code
@cindex @code{aligned} variable attribute
@item aligned (@var{alignment})
この属性は、変数または構造体フィールドの最小整列をバイト単位で指定する。 たとえば、次のような宣言があると、

@smallexample
int x __attribute__ ((aligned (16))) = 0;
@end smallexample

@noindent
コンパイラはグローバル変数@code {x}を16バイトの境界に割り当てる。 68040では、これを@code{asm}式と共に使用して、16バイトのアライメントされたオペランドを必要とする@code{move16}命令にアクセスできる。

構造体フィールドの配置を指定することもできる。 たとえば、ダブルワードアライメントの@code{int}ペアを作成するには、次のように記述する。

@smallexample
struct foo @{ int x[2] __attribute__ ((aligned (8))); @};
@end smallexample

@noindent
これは、@code{double}メンバを使用して共用体を作成して、共用体を強制的にダブルワードアライメントすることに代わるものである。

前述の例のように、コンパイラが指定した変数または構造体フィールドに対して使用する整列（バイト単位）を明示的に指定することができる。あるいは、アラインメント係数を省略して、変数またはフィールドを、コンパイル対象のターゲットアーキテクチャのデフォルトアライメントに合わせるようにコンパイラに依頼することもできる。デフォルトの配置はすべてのスカラー型で十分であるが、ベクトル操作をサポートするターゲット上のすべてのベクトル型では不十分な場合がある。デフォルトの配置は、特定のターゲットABIに対して固定されている。

GCCは、コンパイル対象のマシン上の任意のデータ型に対してこれまで使用されていた最大の配列であるターゲット固有のマクロ@code{__BIGGEST_ALIGNMENT__}も提供する。 たとえば、次のように書くことができる。

@smallexample
short array[3] __attribute__ ((aligned (__BIGGEST_ALIGNMENT__)));
@end smallexample

コンパイラは、宣言された変数またはフィールドの配置を自動的に@code{__BIGGEST_ALIGNMENT__}に設定する。この方法で整列された変数やフィールドとの間でコピーを実行するときに、コンパイラは最大のメモリチャンクをコピーするので、コピー操作をより効率的にすることができる。 @code{__BIGGEST_ALIGNMENT__}の値は、コマンドラインオプションによって変わる可能性があることに注意せよ。

構造体または構造体メンバで使用する場合、@code{aligned}属性はアライメントを増加させるだけである。 これを減らすために@code{packed}属性も指定する必要がある。 typedefの一部として使用する場合、@code{aligned}属性はアラインメントを増減できる。また、@code{packed}属性を指定すると警告が生成される。

@code{aligned}属性の有効性は、リンカの固有の制限によって制限されることに注意せよ。 多くのシステムでは、リンカーは、変数が特定の最大整列まで整列するようにのみ調整することができる。 （リンカの中には、サポートされている最大のアライメントが非常に小さいものもある。）リンカが変数を最大8バイトのアラインメントまでしかアライメントできない場合、@code {aligned__(16)}を@code{__attribute__}に指定しても8バイトのアラインメントしか得られない。 詳細については、リンカーのマニュアルを参照せよ。

@code {aligned}属性は、関数にも使用できる。(@pxref{Common Function Attributes}.)

@item cleanup (@var{cleanup_function})
@cindex @code{cleanup} variable attribute
@code {cleanup}属性は、変数がスコープから外れると関数を実行する。 この属性は、自動関数スコープ変数にのみ適用できる。 静的記憶期間を有するパラメータまたは変数には適用できない。 関数は1つのパラメーター、変数と互換性のある型へのポインターを取る必要がある。 関数の戻り値（存在する場合）は無視される。

@option{-fexceptions}を有効にすると、例外の処理中に発生するスタックの巻き戻し中に@var{cleanup_function}が実行される。 @code{cleanup}属性は、例外を捕捉することを許可せず、アクションの実行のみを許可することに注意せよ。@var{cleanup_function}が正常に返されなかった場合の動作は未定義である。

@item common
@itemx nocommon
@cindex @code{common} variable attribute
@cindex @code{nocommon} variable attribute
@opindex fcommon
@opindex fno-common
@code{common}属性は、GCCに変数を「共通」ストレージに配置するよう要求する。 @code{nocommon}属性は、反対である。直接に空間を割り当てることを要求する。

これらの属性は、それぞれ@option{-fno-common}フラグと@option{-fcommon}フラグによって選択されたデフォルトを上書きする。

@item deprecated
@itemx deprecated (@var{msg})
@cindex @code{deprecated} variable attribute
変数がソースファイルのどこでも使用されている場合、@code{deprecated}属性は警告を出す。 これは、将来のバージョンのプログラムで削除されると予想される変数を識別する場合に便利である。 この警告には、廃止予定の変数の宣言の場所も含まれている。なぜなら、ユーザーは、変数が廃止された理由、またはその代わりに何をすべきかに関する詳細情報を簡単に見つけることができるようにするためである。 この警告は、使用時にのみ発生することに注意せよ。

@smallexample
extern int old_var __attribute__ ((deprecated));
extern int old_var;
int new_fn () @{ return old_var; @}
@end smallexample

@noindent
は行3では警告が表示されるが、行2では表示されない。文字列でなければならないオプションの@var{msg}引数は、警告があれば出力される。

@code{deprecated}属性は、関数および型にも使用できる。 (@pxref{Common Function Attributes}, @pxref{Common Type Attributes}).

@item mode (@var{mode})
@cindex @code{mode} variable attribute
この属性は、宣言のデータ型を指定する。どちらの型もモード@var{mode}に対応しする。 実際には、幅に応じて整数型または浮動小数点型を要求できる。

@xref{Machine Modes,,, gccint, GNU Compiler Collection (GCC) Internals}は、@var {mode}の可能なキーワードのリストを参照する。また、1バイトの整数に対応するモードを示すために、@code{byte}または@code{__byte__}のモードを、1ワード整数のモードの場合は@code {word}または@code{__word__}、ポインタの表現に使用されるモードの場合は@code {pointer}または@code {__ pointer__}を指定することもできる。

@item packed
@cindex @code{packed} variable attribute
@code{aligned}属性でより大きい値を指定しない限り、@code{packed}属性は、変数または構造体フィールドの配置が最小になるように指定する。変数には1バイト、フィールドには1ビットを指定する 。

ここで構造体のフィールド@code{x}がパックされているので、すぐに@code {a}に続く：

@smallexample
struct foo
@{
  char a;
  int x[2] __attribute__ ((packed));
@};
@end smallexample

@emph{_注意_:} GCCの4.1、4.2および4.3シリーズは、@code{char}型のビットフィールドの@code{packed}属性を無視する。 これはGCC 4.4で修正されているが、変更によって構造のレイアウトが異なる場合がある。 詳細については、@option{-Wpacked-bitfield-compat}のドキュメントを参照せよ。

@item section ("@var{section-name}")
@cindex @code{section} variable attribute
通常、コンパイラは生成するオブジェクトを@code{data}や@code{bss}のようなセクションに配置する。 ただし、特別なハードウェアにマップするなど、特別なセクションに表示するには、セクションを追加する必要がある。 @code{section}属性は、変数（または関数）が特定のセクションに存在することを指定する。 たとえば、この小さなプログラムでは、いくつかの特定のセクション名を使用する。

@smallexample
struct duart a __attribute__ ((section ("DUART_A"))) = @{ 0 @};
struct duart b __attribute__ ((section ("DUART_B"))) = @{ 0 @};
char stack[10000] __attribute__ ((section ("STACK"))) = @{ 0 @};
int init_data __attribute__ ((section ("INITDATA")));

main()
@{
  /* @r{Initialize stack pointer} */
  init_sp (stack + sizeof (stack));

  /* @r{Initialize initialized data} */
  memcpy (&init_data, &data, &edata - &data);

  /* @r{Turn on the serial ports} */
  init_duart (&a);
  init_duart (&b);
@}
@end smallexample

@noindent
この例に示すように、@emph{_ローカル_}変数ではなく、@emph{_グローバル_}変数で@code{section}属性を使用すること。

初期化されている、または初期化されていないグローバル変数で@code{section}属性を使うことができるが、リンカは各オブジェクトを一度定義する必要がある。例外は、初期化されていない変数は@code{common}（または@code{bss}）セクションに一時的に置かれ、複数回「定義」されることができることである。@code{section}属性を使用すると、変数に入るセクションが変更され、初期化されていない変数に複数の定義がある場合、リンカにエラーが発生する可能性がある。変数を@option{-fno-common}フラグまたは@code {nocommon}属性で強制的に初期化することができる。

一部のファイル形式では任意のセクションはサポートされないため、@code{section}属性はすべてのプラットフォームで使用できるわけではない。モジュールの内容全体を特定のセクションにマップする必要がある場合は、代わりにリンカの機能を使用することを検討せよ。

@item tls_model ("@var{tls_model}")
@cindex @code{tls_model} variable attribute
@code{tls_model}属性は、特定の@code{__ thread}変数のスレッドローカルストレージモデル（@pxref{Thread-Local}）を設定し@option{-ftls-model =}コマンドラインスイッチを、 変動単位で上書きする。@var{tls_model}引数は@code{global-dynamic}、@code{local-dynamic}、@code{initial-exec}または@code {local-exec}のいずれかでなければならない。

すべてのターゲットがこの属性をサポートするわけではない。

@item unused
@cindex @code{unused} variable attribute
変数に付けられたこの属性は、その変数が使用されていない可能性があることを意味する。 GCCはこの変数に対して警告を生成しない。

@item used
@cindex @code{used} variable attribute
この属性は、静的記憶域を持つ変数に添付されると、変数が参照されていないように見えても変数を発行する必要があることを意味する。

C++クラス・テンプレートの静的データ・メンバーに適用される場合、その属性は、クラス自体がインスタンス化された場合にメンバーがインスタンス化されることも意味する。

@item vector_size (@var{bytes})
@cindex @code{vector_size} variable attribute
この属性は、変数のベクトルサイズをバイト単位で指定する。 たとえば、次のような宣言があると：

@smallexample
int foo __attribute__ ((vector_size (16)));
@end smallexample

@noindent
コンパイラは@code{foo}のモードを16バイトに設定し、@code{int}サイズ単位に分割する。 32ビット整数（4バイトの4単位のベクトル）を仮定すると、対応する@code{foo}のモードはV4SIである。

この属性は、整数、浮動小数点スカラーにのみ適用されるが、配列、ポインタ、および関数の戻り値は、この構造とともに使用できる。

この属性を持つ集合知は、対応するスカラーと同じサイズであっても無効である。 たとえば、次のような宣言は、

@smallexample
struct S @{ int a; @};
struct S  __attribute__ ((vector_size (16))) foo;
@end smallexample

@noindent
構造体のサイズが@code {int}のサイズと同じであっても無効である。

@item visibility ("@var{visibility_type}")
@cindex @code{visibility} variable attribute
この属性は、それがアタッチされている宣言のリンケージに影響します。
@code {visibility}属性については、@ref{Common Function Attributes}.

@item weak
@cindex @code{weak} variable attribute
@code {weak}属性については、@ref{Common Function Attributes}.

@end table

@node AVR Variable Attributes
@subsection AVR変数属性

@table @code
@item progmem
@cindex @code{progmem} variable attribute, AVR
@code{progmem}属性は、AVRで読み取り専用データを不揮発性プログラムメモリ（フラッシュ）に配置するために使用される。 @code{progmem}属性は、それぞれの変数を@code{.progmem}で始まるセクションに入れることでこれを実現する。

この属性は@code {section}属性と同様の働きをするが、追加のチェックを追加する。

@table @asis
@item @bullet{}@tie{} 32個の汎用レジスタを持つ通常のAVRコア：
@code{progmem}はデータの場所に影響するが、このデータへのアクセス方法には影響しない。 @code{progmem}属性のデータを読み込むために（インライン）アセンブラを使用する必要がある。
@smallexample
/* Use custom macros from @w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC}} */
#include <avr/pgmspace.h> 

/* Locate var in flash memory */
const int var[2] PROGMEM = @{ 1, 2 @};

int read_var (int i)
@{
    /* Access var[] by accessor macro from avr/pgmspace.h */
    return (int) pgm_read_word (& var[i]);
@}
@end smallexample

AVRはハーバードアーキテクチャのプロセッサであり、データおよびリードオンリーデータは通常、データメモリ（RAM）に常駐する。

フラッシュメモリ内のデータを検索してアクセスする別の方法については、@ref{AVR Named Address Spaces}セクションを参照せよ。

@item @bullet{}@tie{}AVRの削減ATtiny40のような小型コア：
コンパイラは、@code{0x4000}を@code {progmem}のオブジェクトと宣言のアドレスに追加し、オブジェクトをフラッシュメモリ、つまりセクション@code{.progmem.data}に配置する。フラッシュメモリがアドレス@code{0x4000}から始まるRAMアドレス空間に表示されるので、オフセットが必要である。

@code{progmem}のデータは、通常のCコードでアクセスすることができる。特殊な関数やマクロは必要ない。

@smallexample
/* var is located in flash memory */
extern const int var[2] __attribute__((progmem));

int read_var (int i)
@{
    return var[i];
@}
@end smallexample

これらのデバイスでは、@code{progmem}はまったく必要ないことに注意すること。 下記のような適切なリンカー記述ファイルを使用する。

@smallexample
  .text :
  @{ ...
  @} > text
  /* Leave .rodata in flash and add an offset of 0x4000 to all
     addresses so that respective objects can be accessed by
     LD instructions and open coded C/C++.  This means there
     is no need for progmem in the source and no overhead by
     read-only data in RAM.  */
  .rodata ADDR(.text) + SIZEOF (.text) + 0x4000 :
  @{
    *(.rodata)
    *(.rodata*)
    *(.gnu.linkonce.r*)
  @} AT> text
  /* No more need to put .rodata into .data:
     Removed all .rodata entries from .data.  */
  .data :
  @{ ...
@end smallexample

@end table

@item io
@itemx io (@var{addr})
@cindex @code{io} variable attribute, AVR
@code{io}属性を持つ変数は、ioアドレス範囲内のメモリマップされたペリフェラルに対処するために使用される。アドレスが指定されている場合、変数にはそのアドレスが割り当てられ、その値はデータアドレス空間のアドレスとして解釈される。例：

@smallexample
volatile int porta __attribute__((io (0x22)));
@end smallexample

データアドレス範囲のアドレスに指定されたアドレス。

それ以外の場合、変数にはアドレスは割り当てられないが、コンパイラは適用可能な場合にイン/アウト命令を使用し、他の一部のモジュールがアドレス範囲内のアドレスを割り当てると仮定する。 例：

@smallexample
extern volatile int porta __attribute__((io));
@end smallexample

@item io_low
@itemx io_low (@var{addr})
@cindex @code{io_low} variable attribute, AVR
これは@code{io}属性と似ているが、オブジェクトがI/O領域の下半分にあることをコンパイラに通知し、@code {cbi}、@code{sbi}、@code{sbic}命令と@code {sbis}命令の使用を可能とする。

@item address
@itemx address (@var{addr})
@cindex @code{address} variable attribute, AVR
@code {address}属性を持つ変数は、ioアドレス範囲外にある可能性があるメモリマップされた周辺機器に対処するために使用される。

@smallexample
volatile int porta __attribute__((address (0x600)));
@end smallexample

@item absdata
@cindex @code{absdata} variable attribute, AVR
静的記憶域の変数と@code{absdata}属性の変数は、絶対アドレスを取る@code{LDS}命令と@code{STS}命令でアクセスできる。

@itemize @bullet
@item
この属性は、ATtiny40のような縮小AVR Tinyコアでのみサポートされている。

@item
それぞれのデータが、@code {0x40} @dots{} @code{0xbf}の@code{LDS}と@code{STS}のアドレス範囲にあることを確認する必要がある。これを実現する1つの方法は、適切なリンカー記述ファイルである。

@item
場所が@code {LDS}と@code {STS}のアドレス範囲に合っていない場合、現在のところ（Binutils 2.26）以下のような不特定の警告がある。
@quotation
@code{module.c:(.text+0x1c): warning: internal error: out of range error}
@end quotation

@end itemize

@option{-mabsdata} @ref{AVR Options,command-line option}も参照。

@end table

@node Blackfin Variable Attributes
@subsection Blackfin変数属性

現在、Blackfinには3つの属性が定義されている。

@table @code
@item l1_data
@itemx l1_data_A
@itemx l1_data_B
@cindex @code{l1_data} variable attribute, Blackfin
@cindex @code{l1_data_A} variable attribute, Blackfin
@cindex @code{l1_data_B} variable attribute, Blackfin
これらの属性をBlackfinで使用して、変数をL1データSRAMに配置する。@code{l1_data}属性の変数は、@code{.l1.data}という特定のセクションに配置される。@code{l1_data_A}属性を持つものは、@code{.l1.data.A}という特定のセクションに置かれる。@code{l1_data_B}属性を持つものは、@code{.l1.data.B}という特定のセクションに置かれる。

@item l2
@cindex @code{l2} variable attribute, Blackfin
この属性をBlackfinで使用して、変数をL2 SRAMに配置する。@code{l2}属性の変数は、@code{.l2.data}という特定のセクションに配置される。
@end table

@node H8/300 Variable Attributes
@subsection H8/300変数属性

これらの変数属性は、H8 / 300ターゲットで使用できる。

@table @code
@item eightbit_data
@cindex @code{eightbit_data} variable attribute, H8/300
@cindex eight-bit data on the H8/300, H8/300H, and H8S
H8/300、H8/300H、およびH8Sでこの属性を使用して、指定された変数を8ビットデータセクションに配置する必要があることを示す。コンパイラは、8ビットデータ領域内のデータに対する特定の操作に対してより効率的なコードを生成する。 8ビットのデータ領域は256バイトのデータに制限されていることに注意せよ。

この属性が正しく機能するには、GNU binutilsバージョン2.7以降のGASおよびGLDを使用する必要がある。

@item tiny_data
@cindex @code{tiny_data} variable attribute, H8/300
@cindex tiny data section on the H8/300H and H8S
H8/300HおよびH8Sでは、この属性を使用して、指定された変数を小さなデータセクションに配置する必要があることを示す。コンパイラは、小さなデータセクションのデータの読み込みと格納のために、より効率的なコードを生成する。 小さなデータ領域はわずか32KB未満のデータに限定されている。

@end table

@node IA-64 Variable Attributes
@subsection IA-64変数属性

IA-64バックエンドは、次の変数属性をサポートしている。

@table @code
@item model (@var{model-name})
@cindex @code{model} variable attribute, IA-64
IA-64では、この属性を使用してオブジェクトのアドレス可能性を設定する。現在のところ、@var{model-name}のサポートされている識別子は@code{small}であり、「小さい」（22ビット）アドレスによるアドレス指定可能性を示している（アドレスに@code{add }命令）。 注意：そのようなアドレッシングは定義上の位置独立性ではないため、この属性は共有ライブラリによって定義されたオブジェクトに使用されてはならない。

@end table

@node M32R/D Variable Attributes
@subsection M32R/D変数属性

1つの属性が現在M32R / Dに対して定義されている。

@table @code
@item model (@var{model-name})
@cindex @code{model-name} variable attribute, M32R/D
@cindex variable addressability on the M32R/D
M32R/Dでオブジェクトのアドレス可能性を設定するには、この属性を使用する。識別子@var{model-name}は、各コードモデルを表す@code{small}、@ code{medium}、または@code{large}のいずれかである。

小さなモデルオブジェクトは、メモリの下位16MBに存在する（そのため、アドレスは@code{ld24}命令でロードできる）。

中規模および大規模モデルオブジェクトは、32ビットアドレス空間のどこにでも置くことができる（コンパイラは、アドレスをロードするための@code{seth/add3}命令を生成する）。
@end table

@node MeP Variable Attributes
@subsection MeP変数属性

MePターゲットにはいくつかのアドレッシングモードとバスがある。@code{near}空間は、標準メモリ空間の最初の16メガバイト（24ビット）に及んでいる。 @code{far}空間は32ビットメモリ空間全体に広がる。@code{based}空間は、メモリ空間の128バイトの領域で、@code{$tp}レジスタに相対してアドレス指定される。@code{tiny}空間は、@code{$gp}レジスタを基準にして65536バイトの領域である。これらのメモリ領域に加えて、MePターゲットには@code{cb}属性で指定された別個の16ビット制御バスがある。

@table @code

@item based
@cindex @code{based} variable attribute, MeP
@code{based}属性を持つ変数は@code{.based}セクションに割り当てられ、@code{$tp}レジスタ相対でアクセスされる。

@item tiny
@cindex @code{tiny} variable attribute, MeP
同様に、@code{tiny}属性は@code{.tiny}セクションに変数を割り当て、@code{$gp}レジスタ相対である。

@item near
@cindex @code{near} variable attribute, MeP
@code{near}属性を持つ変数は、24ビットアドレッシングモードに適合するアドレスを持つとみなされる。 これは大きな変数（@code{-mtiny=4}がデフォルト）のデフォルトだが、この属性は小さな変数の場合は@code{-mtiny=}を上書きするか、さもなくば@code{-ml}を上書きすることができる。

@item far
@cindex @code{far} variable attribute, MeP
@code{far}属性を持つ変数は、完全な32ビットアドレスを使用してアドレス指定される。 これはメモリ空間全体をカバーするので、モジュールは変数がどこに格納されるかについて何の仮定もしない。

@item io
@cindex @code{io} variable attribute, MeP
@itemx io (@var{addr})
@code{io}属性の変数は、メモリマップされた周辺機器のアドレス指定に使用される。 アドレスが指定されていれば、変数はそのアドレスに割り当てられる。そうでなければ、アドレスに割り当てられない（他のモジュールがアドレスを割り当てると仮定する）。 例：

@smallexample
int timer_count __attribute__((io(0x123)));
@end smallexample

@item cb
@itemx cb (@var{addr})
@cindex @code{cb} variable attribute, MeP
@code{cb}属性の変数は、特別な指示を使用してコントロールバスにアクセスするために使用される。 @code{addr}はコントロールバスのアドレスを示す。 例：

@smallexample
int cpu_clock __attribute__((cb(0x123)));
@end smallexample

@end table

@node Microsoft Windows Variable Attributes
@subsection Microsoft Windows変数属性

これらの属性をMicrosoft Windowsターゲットで使用できる。 @ref{x86 Variable Attributes}は、すべてのx86ターゲットで使用可能な追加のWindows互換性属性である。

@table @code
@item dllimport
@itemx dllexport
@cindex @code{dllimport} variable attribute
@cindex @code{dllexport} variable attribute
@code {dllimport}属性と@code {dllexport}属性については、@ref{Microsoft Windows Function Attributes}。

@item selectany
@cindex @code{selectany} variable attribute
@code{selectany}属性は、初期化されたグローバル変数にリンク時セマンティクスを持たせる。 変数の複数の定義にリンカーが遭遇すると、最初のものが選択され、残りは破棄される。 Microsoftコンパイラによる使用に続いて、リンカは複数の定義のサイズや内容の違いについて警告@emph{_しない_}と伝える。

この属性の主な用途はPOD型のためだが、属性はコンストラクタによって初期化されるグローバルC++オブジェクトにも適用できる。 この場合、オブジェクトの静的初期化コードおよび破棄コードがオブジェクトを定義する各変換で発行されるが、コンストラクタおよびデストラクタへの呼び出しはリンク時ガード変数によって保護される。

@code{selectany}属性は、Microsoft Windowsターゲットでのみ使用できる。 他のコンパイラとの互換性のため、@code{__declspec(selectany)}を@code {__attribute__((selectany))}の同義語として使うことができる。

@item shared
@cindex @code{shared} variable attribute
Microsoft Windowsでは、名前付きセクションに変数定義を追加するだけでなく、実行可能ファイルまたはDLLのすべての実行中のコピーでセクションを共有することもできる。 たとえば、この小さなプログラムは、共有データを名前付きセクション@code{shared}に入れ、共有可能セクションにマークを付けることで定義する。

@smallexample
int foo __attribute__((section ("shared"), shared)) = 0;

int
main()
@{
  /* @r{Read and write foo.  All running
     copies see the same value.}  */
  return 0;
@}
@end smallexample

@noindent
@code{section}属性とともに@code{shared}属性と、完全に初期化されたグローバル定義のみを使うことができるのは、リンカの仕組みに由来する。 詳細については、@code{section}属性を参照せよ。

@code{shared}属性はMicrosoft Windowsでのみ利用可能である。

@end table

@node MSP430 Variable Attributes
@subsection MSP430変数属性

@table @code
@item noinit
@cindex @code{noinit} variable attribute, MSP430 
@code{noinit}属性を持つデータは、Cランタイムスタートアップコードまたはプログラムローダーによって初期化されない。 このようにデータを初期化しないと、プログラムの起動時間を短縮できる。

@item persistent
@cindex @code{persistent} variable attribute, MSP430 
@code{persistent}属性を持つ変数は、Cランタイムスタートアップコードによって初期化されない。 代わりに、その値は、アプリケーションがロードされると一度設定され、プロセッサがリセットされたりプログラムが再起動しても、再び初期化されることはない。 永続的なデータはFLASH RAMに配置されることを意図しており、その値はリセット時に保持される。 アプリケーションを作成するために使用されるリンカースクリプトは、永続データが正しく配置されるようにする必要がある。

@item lower
@itemx upper
@itemx either
@cindex @code{lower} variable attribute, MSP430 
@cindex @code{upper} variable attribute, MSP430 
@cindex @code{either} variable attribute, MSP430 
これらの属性は、同じ名前のMSP430関数属性と同じである（@pxref{MSP430 Function Attributes}）。これらの属性は、関数と変数の両方に適用できる。
@end table

@node Nvidia PTX Variable Attributes
@subsection Nvidia PTX変数属性

これらの変数属性は、Nvidia PTXバックエンドによってサポートされている。

@table @code
@item shared
@cindex @code{shared} attribute, Nvidia PTX
この属性を使用して変数を@code{.shared}メモリ空間に配置する。このメモリ空間は、協調スレッド配列ごとにプライベートである。 1つのスレッドブロック内のスレッドのみが変数の同じインスタンスを参照する。ランタイムは、このメモリ空間内の変数を初期化しない。
@end table

@node PowerPC Variable Attributes
@subsection PowerPC変数属性

PowerPC設定では、@code{altivec}、@code{ms_struct}、@code{gcc_struct}という3つの属性が定義されている。

@cindex @code{ms_struct} variable attribute, PowerPC
@cindex @code{gcc_struct} variable attribute, PowerPC
構造体の属性の詳細は@ref{x86 Variable Attributes}のドキュメントを参照せよ。

@cindex @code{altivec} variable attribute, PowerPC
@code {altivec}属性のドキュメントについては、@ref{PowerPC Type Attributes}のドキュメントを参照せよ。

@node RL78 Variable Attributes
@subsection RL78変数属性

@cindex @code{saddr} variable attribute, RL78
RL78バックエンドは@code{saddr}変数属性をサポートしている。 これは、対応する変数のSADDR領域への配置を指定する。これで、デフォルトのメモリ領域より効率的にアクセスできる。

@node SPU Variable Attributes
@subsection SPU変数属性

@cindex @code{spu_vector} variable attribute, SPU
SPUは変数の@code {spu_vector}属性をサポートしている。 この属性のドキュメントについては、@ref{SPU Type Attributes}.

@node V850 Variable Attributes
@subsection V850変数属性

これらの可変属性は、V850バックエンドによってサポートされている。

@table @code

@item sda
@cindex @code{sda} variable attribute, V850
この属性を使用して、64 KBまで保持できる小さなデータ領域に明示的に変数を配置する。

@item tda
@cindex @code{tda} variable attribute, V850
この属性を使用して、変数を明示的に非常に小さなデータ領域に配置する。これは合計で最大256バイトまで保持できる。

@item zda
@cindex @code{zda} variable attribute, V850
この属性を使用して、最初の32キロバイトのメモリに変数を明示的に配置する。
@end table

@node x86 Variable Attributes
@subsection x86変数属性

現在のところ、x86構成では、@code{ms_struct}と@code{gcc_struct}という2つの属性が定義されている。

@table @code
@item ms_struct
@itemx gcc_struct
@cindex @code{ms_struct} variable attribute, x86
@cindex @code{gcc_struct} variable attribute, x86

構造体で@code{packed}が使用されている場合、またはビットフィールドが使用されている場合は、Microsoft ABIがGCCの通常の方法とは異なる構造をレイアウトしている可能性がある。 特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラ（関数呼び出しまたはファイル内のデータ）の間でパックされたデータを移動する場合は、どちらの形式にもアクセスする必要がある。

@code{ms_struct}属性と@code{gcc_struct}属性は、それぞれコマンドラインオプション@option{-mms-bitfields}と@option{-mno-ms-bitfields}に対応する。 構造体レイアウトの影響の詳細については、@ref{x86 Options}を参照せよ。型の対応する属性については、@xref{x86 Type Attributes}を参照せよ。

@end table

@node Xstormy16 Variable Attributes
@subsection Xstormy16変数属性

現在、xstormy16構成に対して1つの属性が定義されている。@code{below100}.

@table @code
@item below100
@cindex @code{below100} variable attribute, Xstormy16
変数に@code {below100}属性（@code{BELOW100}も許可されている）がある場合、GCCは変数を最初の0x100バイトのメモリに置き、特殊なオペコードを使用してアクセスする。 このような変数は、@code{.bss_below100}セクションまたは@code{.data_below100}セクションに置かれる。

@end table

@node Type Attributes
@section 型の属性を指定する
@cindex attribute of types
@cindex type attributes

キーワード@code {__attribute__}を使用すると、型の特殊属性を指定できる。 ある型の属性は@code{struct}型と@code{union}型にのみ適用されるが、その他の型は@code{typedef}宣言で定義された型に適用できる。 他の属性は関数（@pxref{Function Attributes}）、ラベル（@pxref{Label Attributes}）、列挙子（@pxref{Enumerator Attributes}）、文（@pxref{Statement Attributes}）、変数@pxref{Variable Attributes}）に定義されている。

@code{__ attribute__}キーワードの後ろには二重括弧で囲まれた属性指定が続く。

@code{struct}、@code{union}、@code{enum}キーワードの直後に置くことで、型属性をenum、struct、または共用体の型宣言または定義に指定することができる。 あまり推奨されない構文は、それらを定義の最後の中括弧の直前に置くことである。

型属性を@code{typedef}宣言に含めることもできる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。

@menu
* Common Type Attributes::
* ARM Type Attributes::
* MeP Type Attributes::
* PowerPC Type Attributes::
* SPU Type Attributes::
* x86 Type Attributes::
@end menu

@node Common Type Attributes
@subsection 共通型属性

ほとんどのターゲットでは、次のタイプ属性がサポートされている。

@table @code
@cindex @code{aligned} type attribute
@item aligned (@var{alignment})
この属性は、指定された型の変数の最小整列（バイト単位）を指定する。 たとえば、次の宣言があると。

@smallexample
struct S @{ short f[3]; @} __attribute__ ((aligned (8)));
typedef int more_aligned_int __attribute__ ((aligned (8)));
@end smallexample

@noindent
@code{struct S}または@code {more_aligned_int}の各変数が@emph{_少なくとも_}8バイト境界に割り当てられていることをコンパイラーに（可能な限り）保証させる。SPARCでは、@code{struct S}型の変数をすべて8バイトの境界に揃えておくと、 @code {struct S}型の変数を別のものにコピーするときに、コンパイラは@code {ldd}と@code{std}（ダブルワードのロードとストア）命令を使用して、実行時の効率が向上する。

@code {struct}型や@code {union}型のアライメントは、ISO C標準では、少なくとも問題の@code{struct}または@code{union}のすべてのメンバーのアライメントの最低公倍数の完全な倍数であることが要求されることに注意せよ。つまり、@code{aligned}属性をそのような型のメンバのいずれかに付加することによって、@code {struct}型または@code{union}型の整列を効果的に調整することができるが、 上の例では、コンパイラに@code{struct}型または@code{union}型全体のアライメントを調整するように要求する、より明白で直感的で読みやすい方法を示している。

前の例と同様に、コンパイラが指定された@code{struct}型または@code{union}型に対して使用する整列（バイト単位）を明示的に指定することができる。 あるいは、アラインメント係数を省略して、コンパイルするターゲットマシンの最大の有効なアライメントにタイプを合わせるようにコンパイラーに依頼することもできる。 たとえば、次のように書くことができる。

@smallexample
struct S @{ short f[3]; @} __attribute__ ((aligned));
@end smallexample

アラインメント係数を@code{aligned}属性指定で除外すると、コンパイラは自動的にそのタイプのアライメントを、コンパイルするターゲットマシンの任意のデータ型に使用された最大のアライメントに設定する。コンパイラは、このように整列した型を持つ変数との間でコピーを実行するときに、最大のメモリチャンクをコピーする命令を使用できるため、コピー操作をより効率的にすることができる。

上記の例では、各@code{short}のサイズが2バイトの場合、@code{struct S}タイプ全体のサイズは6バイトである。 2以上の最小の累乗は8以上であるため、コンパイラは@code{struct S}型全体のアラインメントを8バイトに設定する。

特定の型に対して時間効率の良いアライメントを選択し、その型の個々のスタンドアロンオブジェクトのみを宣言するようにコンパイラに依頼することはできるが、コンパイラの時間効率的な配置を選択する機能は、関連する（効率的に配置された）タイプの変数の配列を作成する予定がある場合にのみ、主に有効である。効率的に整列された型の変数の配列を宣言または使用すると、プログラムは関連する型へのポインタに対してポインタ算術（または同じものになる添え字付け）も行うが、コンパイラがこれらのポインタ算術演算用に生成するコードは、他の型より効率的に配置された型の方が効率がよいことがよくある。

@code{aligned}属性の有効性は、リンカの固有の制限によって制限されることに注意せよ。 多くのシステムでは、リンカは、変数が特定の最大整列まで整列するようにのみ調整することができる。 （一部のリンカでは、サポートされている最大のアラインメントは非常に小さいかもしれない）。リンカが変数を最大8バイトのアラインメントまでしかアライメントできない場合、@code{aligned(16)}を@code {__attribute__}に指定しても8バイトのアラインメントしか得られない。 詳細については、リンカのマニュアルを参照せよ。

@code {aligned}属性はアラインメントを増加させるだけである。 @code {packed}属性を指定することで、アラインメントを減らすことができる。 下記参照。

@item bnd_variable_size
@cindex @code{bnd_variable_size} type attribute
@cindex Pointer Bounds Checker attributes
構造体フィールドに適用されるとき、この属性はポインタの境界チェッカーに、このフィールドのサイズを静的型情報を使用して計算すべきではないことを伝える。 これは、構造体の終わりに配置された可変サイズの静的配列フィールドをマークするために使用される。

@smallexample
struct S
@{
  int size;
  char data[1];
@}
S *p = (S *)malloc (sizeof(S) + 100);
p->data[10] = 0; //Bounds violation
@end smallexample

@noindent
フィールドの属性を使用することにより、望ましくない拘束違反チェックを避けることができる：

@smallexample
struct S
@{
  int size;
  char data[1] __attribute__((bnd_variable_size));
@}
S *p = (S *)malloc (sizeof(S) + 100);
p->data[10] = 0; //OK
@end smallexample

@item deprecated
@itemx deprecated (@var{msg})
@cindex @code{deprecated} type attribute
@code{deprecated}属性は、型がソースファイルのどこでも使用されている場合、警告を出す。 これは、将来のバージョンのプログラムで削除されることが予想される型を識別する場合に便利である。可能であれば、警告には非推奨型の宣言の場所も含まれているため、ユーザーはその型が推奨されない理由やその代わりに何をすべきかに関する情報を簡単に見つけることができる。警告は使用時にのみ発生し、その型自体が非推奨として宣言されていない識別子に適用されている場合に限り発生することに注意せよ。

@smallexample
typedef int T1 __attribute__ ((deprecated));
T1 x;
typedef T1 T2;
T2 y;
typedef T1 T3 __attribute__ ((deprecated));
T3 z __attribute__ ((deprecated));
@end smallexample

@noindent
2行目と3行目には警告が表示されるが、4行目、5行目、または6行目には警告は表示されない。T2は明示的に推奨されていないため、4行目には警告は発行されない。 T3は明示的に推奨されていないため、5行目に警告はない。６行目も同様である。 文字列でなければならないオプションの@var{msg}引数は、警告が表示されている場合に出力される。

@code {deprecated}属性は、関数や変数にも使用できる。 (@pxref{Function Attributes}, @pxref{Variable Attributes})

@item designated_init
@cindex @code{designated_init} type attribute
この属性は構造体型にのみ適用できる。 このタイプのオブジェクトの初期化では、位置初期化子ではなく、指示子付き初期化子を使用する必要があることを示している。 この属性の目的は、構造体のレイアウトが変更される可能性があることを、したがって位置の初期化に依存すると将来の破損が生じる可能性があることをプログラマが示すことができるようにすることである。

GCCはデフォルトでこの属性に基づいて警告を出す。 @option{-Wno-designated-init}を使用してそれらを抑制できる。

@item may_alias
@cindex @code{may_alias} type attribute
この属性を持つ型へのポインタによるアクセスは、型に基づくエイリアス解析の対象ではないが、代わりに他の型のオブジェクトのエイリアスが可能であると想定される。 C99標準の第6.5節第7項の文脈では、そのようなポインタを逆参照する左辺式は、文字型のように扱われる。 エイリアスの問題の詳細については、@option{-fstrict-aliasing}を参照せよ。 この拡張は、あるベクトル型へのポインタが別のベクトル型へのポインタの別名付けを許可されているいくつかのベクトルAPIをサポートするために存在する。

この属性を持つ型のオブジェクトは特別なセマンティクスを持たないことに注意せよ。

使用の例：

@smallexample
typedef short __attribute__((__may_alias__)) short_a;

int
main (void)
@{
  int a = 0x12345678;
  short_a *b = (short_a *) &a;

  b[1] = 0;

  if (a == 0x12345678)
    abort();

  exit(0);
@}
@end smallexample

@noindent
変数宣言で@code{short_a}を@code{short}に置き換えた場合、@option{-O2}以上でデフォルトでオンになる@option{-fstrict-aliasing}でコンパイルすると、上記のプログラムは強制終了するだろう。

@item packed
@cindex @code{packed} type attribute
@code{struct}型または@code {union}型定義に添付されているこの属性は、構造体または共用体の各メンバ（ゼロ幅のビットフィールド以外）が必要なメモリを最小限に抑えるように配置されることを指定する。 @code{enum}定義に付けると、最小の整数型を使用する必要があることを示す。

@opindex fshort-enums
@code{struct}型と@code{union}型に@code{packed}属性を指定することは、構造体または共用体の各メンバで@code{packed}属性を指定するのと同じである。 コマンドラインで@option{-fshort-enums}フラグを指定することは、すべての@code{enum}定義で@code{packed}属性を指定するのと同じである。

次の例では、@code {struct my_packed_struct}のメンバーは密接にまとめられているが、@code{s}メンバーの内部レイアウトはパックされていない。そうするためには、@code{struct my_unpacked_struct}もパックする必要がある。

@smallexample
struct my_unpacked_struct
 @{
    char c;
    int i;
 @};

struct __attribute__ ((__packed__)) my_packed_struct
  @{
     char c;
     int  i;
     struct my_unpacked_struct s;
  @};
@end smallexample

列挙型、構造体、共用体を定義していない@code {typedef}ではなく@code{enum}、@code {struct}または@code{union}の定義にのみ@code{packed}属性属性を指定することができる。

@item scalar_storage_order ("@var{endianness}")
@cindex @code{scalar_storage_order} type attribute
@code{union}または@code {struct}にアタッチされている場合、この属性は型のスカラフィールド、およびコンポーネントがスカラーである配列フィールドの格納順序、つまりエンディアンを設定する。 サポートされるエンディアンは@code{big-endian}と@code{little-endian}である。この属性は、それ自身が@code{union}、@code{struct}、またはその構成要素が@code{union}または@code{struct}の配列であるフィールドには影響せず、これらのフィールドは囲むタイプとは異なるスカラー格納順序を持つことができる。

この属性は、揃ったデフォルトのスカラーストレージオーダーを使用するターゲット（幸運なことに、ほとんど）、つまりスカラーをすべてビッグエンディアンまたはリトルエンディアンに格納するターゲットでのみサポートされる。

ターゲットのスカラー格納順序とは逆のスカラ格納順序を持つ型に対しては、追加の制限が適用される。

@itemize
@item 逆スカラー格納順序の@code{union}または@code {struct}のスカラーフィールドのアドレスを取ることは許されず、エラーが発生する。
@item @option{-Wno-scalar-storage-name}が指定されていない限り、構成要素がスカラーである、配列フィールドのアドレスを逆スカラー格納順序の@code{union}または@code {struct}の配列フィールドのアドレスを取ることは許可されるが、警告が生成される。
@item 逆スカラー格納順序の@code {union}または@code {struct}のアドレスを取ることは許可されている。
@end itemize

これらの制約は、スカラーのアドレスまたはスカラーコンポーネントを持つ配列のアドレスが取られたときに記憶順序属性が失われるために存在する。したがって、このアドレスを介して間接的に格納するのは一般的に機能しない。それにもかかわらず、第2の場合は、配列との間でブロックコピーを実行することができる。

さらに、格納順序を切り替えるための型キャストやエイリアシングの使用はサポートされていない。 つまり、指定されたスカラーオブジェクトは、別の記憶順序を割り当てる別の型を通してアクセスすることはできない。

@item transparent_union
@cindex @code{transparent_union} type attribute

@code{union}型定義に添付されているこの属性は、その共用体型を持つ関数パラメータがその関数への呼び出しを特別な方法で扱うことを示す。

まず、透明な共用体型に対応する引数は、共用体内のどの型でもよい。 キャストは必要ない。 また、共用体にポインタ型が含まれている場合、対応する引数にはNULLポインタ定数またはvoidポインタ式を指定できる。 共用体にvoidポインタ型が含まれている場合、対応する引数は任意のポインタ式になる。 共用体メンバ型がポインタの場合、通常のポインタ変換と同様に、参照される型の@code{const}のような修飾子を尊重する必要がある。

第2に、引数は、共用体自体の呼び出し規約ではなく、透明な共用体の最初のメンバーの呼び出し規約を使用して関数に渡される。 共用体のすべてのメンバーは、同じマシン表現を持たなければならない。 この引数が正しく動作するためには、これが必要である。

透明な共用体は、互換性の理由で複数のインタフェースを持つライブラリ関数用に設計されている。 たとえば、@code{wait}関数がPOSIXに準拠するために@code{int *}型の値を受け入れるか、4.1BSDインタフェースに準拠するために@code{union wait *}型の値を受け入れる必要があるとする。 @code{wait}のパラメータが@code{void *}の場合、@code{wait}は両方の種類の引数を受け入れるが、他のポインタ型も受け入れる。 代わりに、@code{<sys/wait.h>}は次のようにインタフェースを定義してもよい：

@smallexample
typedef union __attribute__ ((__transparent_union__))
  @{
    int *__ip;
    union wait *__up;
  @} wait_status_ptr_t;

pid_t wait (wait_status_ptr_t);
@end smallexample

@noindent
このインタフェースでは、@code{int *}呼び出し規約を使用して、@code{int *}または@code{union wait *}引数を渡すことができる。 プログラムはどちらの型の引数でも@code{wait}を呼び出すことができる：

@smallexample
int w1 () @{ int w; return wait (&w); @}
int w2 () @{ union wait w; return wait (&w); @}
@end smallexample

@noindent
このインタフェースでは、@code{wait}の実装は次のようになる。

@smallexample
pid_t wait (wait_status_ptr_t p)
@{
  return waitpid (-1, p.__ip, 0);
@}
@end smallexample

@item unused
@cindex @code{unused} type attribute
型（@code{union}や@code{struct}を含む）に接続すると、この型の変数は使用されない可能性があることを意味する。 変数が何もしないように見えても、GCCはその型の変数について警告を出さない。 これは通常、定義されて参照されないが、自明ではない簿記機能を持つコンストラクタとデストラクタを含むロッククラスまたはスレッドクラスのケースである。

@item visibility
@cindex @code{visibility} type attribute
C++では、属性の可視性（@pxref {Function Attributes}）はクラス、構造体、共用体、列挙型にも適用できる。 他の型の属性とは異なり、属性は初期キーワードと型の名前の間になければならない。 タイプのボディの後には出現できない。

タイプの可視性は、クラス（vtable、typeinfoノードなど）に関連付けられた曖昧なリンケージエンティティに適用されることに注意せよ。 特に、あるクラスがある共有オブジェクト内で例外としてスローされ、別の共有オブジェクトで捕捉された場合、そのクラスはデフォルトの可視性を持たなければならない。 それ以外の場合は、2つの共有オブジェクトが同じtypeinfoノードを使用できず、例外処理が中断される。

@end table

複数の属性を指定するには、ダブルカッコ内でコンマで区切る。例えば、 @samp{__attribute__ ((aligned (16), packed))}.

@node ARM Type Attributes
@subsection ARM型属性

@cindex @code{notshared} type attribute, ARM
@code{dllimport}（Symbian OSなど）をサポートするARMターゲットでは、@code{notshared}属性を使用して、クラスの仮想テーブルやその他の同様のデータをDLLからエクスポートしないことを指定できる。 例えば：

@smallexample
class __declspec(notshared) C @{
public:
  __declspec(dllimport) C();
  virtual void f();
@}

__declspec(dllexport)
C::C() @{@}
@end smallexample

@noindent
このコードでは、@code{C::C}は現在のDLLからエクスポートされるが、@code{C}の仮想テーブルはエクスポートされない。 必要に応じて@code{__ declspec}の代わりに@code{__attribute__}を使うことができるが、ほとんどのSymbian OSコードは@code{__declspec}を使用している）。

@node MeP Type Attributes
@subsection MeP型属性

@cindex @code{based} type attribute, MeP
@cindex @code{tiny} type attribute, MeP
@cindex @code{near} type attribute, MeP
@cindex @code{far} type attribute, MeP
MeP変数属性の多くは、型にも適用できる。具体的には、@code{based}、@code{tiny}、@code{near}、@code{far}のいずれかの属性を適用することができる。 @code{io}属性と@code{cb}属性は型には適用されない。

@node PowerPC Type Attributes
@subsection PowerPC型属性

PowerPCの設定では、@code{altivec}、@code{ms_struct}、@code{gcc_struct}という3つの属性が定義されている。

@cindex @code{ms_struct} type attribute, PowerPC
@cindex @code{gcc_struct} type attribute, PowerPC
@code{ms_struct}属性と@code{gcc_struct}属性の詳細については、@ref{x86 Type Attributes}のドキュメントを参照せよ。

@cindex @code{altivec} type attribute, PowerPC
@code{altivec}属性は、AltiVec Programming Interface ManualでサポートされているAltiVecベクタデータ型を宣言することができる。 属性には、@code{vector__}、@code{pixel__}（常にunsigned short）、@code{bool__}（常に符号なし）の3種類のベクトル型のいずれかを指定する引数が必要である。

@smallexample
__attribute__((altivec(vector__)))
__attribute__((altivec(pixel__))) unsigned short
__attribute__((altivec(bool__))) unsigned
@end smallexample

これらの属性は主に、@code{__vector}、@code{__pixel}、@code{__bool}のAltiVecキーワードをサポートすることを意図している。

@node SPU Type Attributes
@subsection SPU型属性

@cindex @code{spu_vector} type attribute, SPU
SPUは型の@code{spu_vector}属性をサポートしている。 この属性を使用すると、ソニー/東芝/IBM SPU言語拡張仕様でサポートされているベクトルデータ型を宣言できる。 @code{__ vector}キーワードをサポートすることを意図している。

@node x86 Type Attributes
@subsection x86型属性

現在のところ、x86構成では、@code{ms_struct}と@code{gcc_struct}という2つの属性が定義されている。

@table @code

@item ms_struct
@itemx gcc_struct
@cindex @code{ms_struct} type attribute, x86
@cindex @code{gcc_struct} type attribute, x86

構造体で@code{packed}が使用されている場合、またはビットフィールドが使用されている場合は、Microsoft ABIが通常GCCパックとは異なる方法でパックしている可能性がある。 特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラ（関数呼び出しまたはファイル内のデータ）の間でパックされたデータを移動する場合は、どちらの形式にもアクセスする必要がある。

@code{ms_struct}属性と@code{gcc_struct}属性は、それぞれコマンドラインオプション@option{-mms-bitfields}と@option{-mno-ms-bitfields}に対応する。 構造体レイアウトの影響の詳細については、@ref{x86 Options}を参照せよ。 変数の対応する属性については、@xref{x86 Variable Attributes}を参照せよ。

@end table

@node Label Attributes
@section ラベル属性
@cindex Label Attributes

GCCでは、属性をCラベルに設定できる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。他の属性は、関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、列挙(@pxref{Enumerator Attributes})、文(@pxref{Statement Attributes})、型(@pxref{Type Attributes})である。

この例では、@code{Error}タグのラベル属性を使用して、@code{ErrorHandling}ブランチが実行されにくく、@code{ErrorHandling}ラベルが使用されていないことを示している。

@smallexample

   asm goto ("some asm" : : : : NoError);

/* This branch (the fall-through from the asm) is less commonly used */
ErrorHandling: 
   __attribute__((cold, unused)); /* Semi-colon is required here */
   printf("error\n");
   return 0;

NoError:
   printf("no error\n");
   return 1;
@end smallexample

@table @code
@item unused
@cindex @code{unused} label attribute
この機能は、未使用のラベルを含む可能性があるが、@option {-Wall}でコンパイルされたプログラム生成コードを対象としている。 人間が作成したコードを使用するのは通常は適切ではないが、ラベルにジャンプするコードが@code{#ifdef}条件に含まれる場合に役立つ。

@item hot
@cindex @code{hot} label attribute
ラベルの@code{hot}属性は、ラベルに続くパスが注釈されていないパスよりも可能性が高いことをコンパイラに通知するために使用される。 この属性は、@code{__ builtin_expect}が使用できない場合、たとえば計算gotoまたは@code{asm goto}で使用される。

@item cold
@cindex @code{cold} label attribute
ラベルの@code{cold}属性は、ラベルに続くパスが実行される可能性が低いことをコンパイラに通知するために使用される。 この属性は、@code{__ builtin_expect}が使用できない場合、たとえば計算gotoまたは@code{asm goto}で使用される。

@end table

@node Enumerator Attributes
@section 列挙属性
@cindex Enumerator Attributes

GCCでは、属性を列挙に設定できる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。他の属性は、関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、ラベル(@pxref{Label Attributes})、文(@pxref{Statement Attributes})、型(@pxref{Type Attributes})である。

この例では、@code{deprecated}列挙子属性を使用して、@code{oldval}列挙子が廃止予定であることを示している。

@smallexample
enum E @{
  oldval __attribute__((deprecated)),
  newval
@};

int
fn (void)
@{
  return oldval;
@}
@end smallexample

@table @code
@item deprecated
@cindex @code{deprecated} enumerator attribute
列挙子がソースファイルのどこで使用されている場合でも、@code{deprecated}属性は警告を出す。 これは、将来のバージョンのプログラムで削除されると予想される列挙子を識別する場合に便利である。 この警告には、廃止された列挙子の宣言の場所も含まれているため、列挙子が廃止された理由やその代わりに何をすべきかに関する情報をユーザーが簡単に見つけることができる。 警告は、使用時にのみ発生することに注意せよ。

@end table

@node Statement Attributes
@section 文属性
@cindex Statement Attributes

GCCでは、属性を空文に設定できる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。他の属性は、関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、ラベル(@pxref{Label Attributes})、列挙(@pxref{Enumerator Attributes})、型(@pxref{Type Attributes})である。

この例では、@code{fallthrough}文属性を使用して、@option{-Wimplicit-fallthrough}警告を出力しないことを示している。

@smallexample
switch (cond)
  @{
  case 1:
    bar (1);
    __attribute__((fallthrough));
  case 2:
    @dots{}
  @}
@end smallexample

@table @code
@item fallthrough
@cindex @code{fallthrough} statement attribute
空文を持つ@code{fallthrough}属性はフォールスルー文として機能する。 switchステートメント内の別のcaseラベルまたはユーザー定義ラベルに渡すステートメントは意図的なものであるため、@option{-Wimplicit-fallthrough}警告はトリガーしてはならないことをコンパイラーに示唆している。 フォールスルー属性は、各属性リストに最大で1回しか表示されず、他の属性と混在することはできない。 switchステートメントでのみ使用できる（コンパイラーは別の方法でエラーを出します）。これは、直前の文の後で、論理的に後続するcaseラベルまたはユーザー定義ラベルの前である。

@end table

@node Attribute Syntax
@section 属性構文
@cindex attribute syntax

この節では、C言語の@code{__attribute__}が使用される構文と、属性指定子が結合される構文について説明する。 いくつかの詳細は、C++とObjective-Cで異なる場合がある。 属性の文法の情報が不十分であるため、ここに記載されている一部の書式はすべての場合に正常に解析されないことがある。

C ++の属性のセマンティクスにはいくつかの問題がある。 たとえば、コードの生成に影響する可能性があるが、属性のマングリングはない。したがって、属性付きの型をテンプレートやオーバーロードとともに使用すると問題が発生する可能性がある。 同様に、@code{typeid}は属性の異なる型を区別しない。 C++での属性のサポートは、将来は宣言のみの属性に制限されるが、ネストされた宣言子では制限されない。

関数に適用する属性の意味の詳細は@xref{Function Attributes}。変数に適用される属性の意味の詳細は@xref{Variable Attributes}。構造体、共用体、列挙型に適用される属性の意味の詳細は@xref{Type Attributes}。ラベルに適用される属性の意味の詳細は@xref{Label Attributes}。列挙子に適用される属性の意味の詳細は@xref{Enumerator Attributes}。文に適用される属性の意味の詳細は@xref{Statement Attributes}

@dfn{attribute specifier}（属性指定子）は形式@code{__attribute__ ((@var{attribute-list}))}を持つ。@dfn{attribute list}（属性リスト）は@dfn{attributes}のコンマで区切られた空を許容する列であり、それぞれは以下の一つである。

@itemize @bullet
@item
空。空属性は無視される。

@item
属性名。（@code{unused}のような識別子か、@code{const}のような予約後かもしれない）

@item
属性名の後に、属性のパラメータのカッコで囲まれたリストが続く。 これらのパラメータは、次のいずれかの形式をとる。

@itemize @bullet
@item
識別子。例えば、@code{mode}属性はこの形式を持つ。

@item
識別子のあとに、式のコンマで区切られた空でないリストが続く。例えば、@code{format}属性はこの形式を使う。

@item
式の空を許容するコンマ区切りのリスト。例えば、@code{format_arg}属性はこの形式を使用し、リストは単一の整数定数式であり、@code {alias}属性はこのフォームを使用し、リストは単一の文字列定数になる。
@end itemize
@end itemize

@dfn{attribute specifier list}（属性指定子リスト）は、他のトークンで区切られていない、1つ以上の属性指定子の列である。

属性名の前に@samp{__}を付けて属性名を指定することもできる。 これにより、同じ名前の可能性のあるマクロを気にせずにヘッダファイルでそれらを使用することができる。 たとえば、@code {noreturn}ではなく@code{__ noreturn__}という属性名を使用できる。

@subsubheading ラベル属性

GNU Cでは、@code{case}や@code{default}ラベル以外のラベルの後にコロンの後に属性指定子リストが現れる。 GNU C++では、属性指定子の直後にセミコロンが続く場合（つまり、空文にラベルが適用される）、ラベルの属性のみが許可される。 セミコロンがない場合、C++のラベル属性はあいまいである。属性リストで始まる宣言がC++でラベル付けされる可能性があるためである。 宣言はC90またはC99ではラベル付けできないため、あいまいさはそこでは発生しない。

@subsubheading 列挙属性

GNU Cでは、属性指定子リストが列挙子の一部として現れるてもよい。属性は列挙定数の後、（存在する場合）@code{=}の前に置かれる。 列挙子のオプションの属性は、列挙定数に属す。 存在する場合、定数式の後に属性を配置することはできない。

@subsubheading 文属性
GNU Cでは、属性指定子リストが空文の一部として現れることができる。 属性はセミコロンの前に置かれる。

@subsubheading 型属性
属性指定子リストは@code{struct}、@code{union}または@code{enum}指定子の一部として現れることができる。 @code{struct}、@code{union}、@code{enum}キーワードの直後、または閉じ括弧の後に置くことができる。 前者の構文が好ましい。属性指定子が閉じ括弧の後に続く場合、それらは構造体、共用体、または列挙型に関連しているとみなされ、型指定子が含まれる囲み宣言には関係せず、定義された型は属性指定子の後まで完全ではない。
@c Otherwise, there would be the following problems: a shift/reduce
@c conflict between attributes binding the struct/union/enum and
@c binding to the list of specifiers/qualifiers; and "aligned"
@c attributes could use sizeof for the structure, but the size could be
@c changed later by "packed" attributes.


@subsubheading 他のすべての属性

それ以外の場合、属性指定子は宣言の一部として現れ、それは名前無しのパラメータと型名、そしてその宣言、及び宣言内の特定の宣言に関連するもの（例えば、パラメータ宣言の場合の用に、他の宣言内で入れ子になっているかもしれない）が含まれる。属性指定子が関数または配列として宣言されたパラメータに適用される場合、そのパラメータは暗黙的に変換されるポインタではなく関数または配列に適用されるが、これはまだ正しく実装されていない。

宣言の先頭にある指定子と修飾子のリストには、そのようなリストに格納クラス指定子が含まれているかどうかにかかわらず、属性指定子を含めることができる。 （ただし、一部の属性は本質的にストレージクラス指定子の性質を持ち、ストレージクラス指定子が使用される場所、たとえば、@code{section}などにのみ意味がある。）この構文には、必要な制限が1つある。関数定義の最初の旧式のパラメータ宣言は、属性指定子で始めることはできない。これは、後述の構文ではなく関数に適用されるためである。 （ただし、このケースはまだ実装されていない。）他の場合では、属性指定子はこの文法では許可されているが、コンパイラではまだサポートされていない。この場所のすべての属性指定子は、宣言全体に関連している。@code{int}の型が型指定子がないことによって暗示される時代遅れの使用法では、そのような指定子と修飾子のリストは、他の指定子や修飾子を持たない属性指定子リストである。

現在、関数プロトタイプの最初のパラメータには、属性指定子ではない型指定子が必要である。 これは@code{void f(int
(__attribute__((foo)) x))}の解釈のあいまいさを解決するが、変更される可能性がある。 現時点では、関数宣言子の括弧に属性のみが含まれている場合、エラーや警告を出すのではなく、int型の単一のパラメータを指定するのでもなく、これらの属性は無視されるが、変更される可能性がある。

属性指定子リストは、指定子と修飾子の単一のリストを使用する複数の識別子の宣言で、宣言子のコンマ区切りリスト内の宣言子（最初のものを除く）の直前に現れる。 そのような属性指定子は、その宣言子が出現する前の識別子にのみ適用される。 たとえば、

@smallexample
__attribute__((noreturn)) void d0 (void),
    __attribute__((format(printf, 1, 2))) d1 (const char *, ...),
     d2 (void);
@end smallexample

@noindent
@code{noreturn}属性は宣言されたすべての関数に適用される。 @code{format}属性は@code{d1}にのみ適用される。

属性指定子リストはカンマの直前に現れる。@code{=}またはセミコロンは、関数定義以外の識別子の宣言を終了する。 このような属性指定子は、宣言されたオブジェクトまたは関数に適用される。 オブジェクトまたは関数のアセンブラ名が指定されている場合（@pxref {Asm Labels}）、属性は@code {asm}の指定に従わなければならない。

属性指定子リストは、将来、（古いスタイルのパラメータ宣言または関数本体の前の）関数定義の宣言子の後に現れるようにすることができるかもしれない。

属性指定子は、配列が暗黙的に変換されるポインタにそのような修飾子が適用されるC99構造のパラメータ配列宣言子の@code{[]}の中に現れる型修飾子と混在することができる。 そのような属性指定子は、配列ではなくポインタに適用されるが、現在実装されておらず、無視されている。

属性指定子リストは、ネストされた宣言子の先頭に現れることがある。 現在のところ、この使用法にはいくつかの制限がある。属性は宣言子に正しく適用されますが、ほとんどの個々の属性では、これが意味するセマンティクスは実装されていない。 属性指定子がポインタ宣言子の@code{*}の後にある場合、それらは任意のタイプの修飾子と混在することがある。 以下では、この構文の正式なセマンティクスについて説明する。 ISO C標準の宣言子の正式な仕様に精通している場合は、最も理にかなっている。

（C99の節6.7.5の4節のように）@code {T D1}という宣言があると仮定し、ここで@code{T}には、型@var{Type}（@code {int}など）を指定する宣言指定子が含まれていて、@code {D1}は識別子@var{ident}を含む宣言子である。 属性指定子を含まない派生宣言子の@var{ident}に指定された型は、ISO C標準の場合と同じである。

もし@code{D1}が形式@code{( @var{attribute-specifier-list} D )}を持ち、宣言@code{T D}が@var{idnet}の型「@var{derived-declarator-type-list} @var{Type}」を指定するならば、@code{T D1}は@var{ident}の型「@var{derived-declarator-type-list} @var{attribute-specifier-list} @var{Type}」を指定する。

もし@code{D1}が形式@code{* @var{type-qualifier-and-attribute-specifier-list} D}を持ち、宣言@code{T D}が@var{idnet}の型「@var{derived-declarator-type-list} @var{Type}」を指定するならば、@code{T D1} は@var{ident}の型「@var{Type}への@var{derived-declarator-type-list} @var{type-qualifier-and-attribute-specifier-list}ポインタ」型を指定する。

例えば、

@smallexample
void (__attribute__((noreturn)) ****f) (void);
@end smallexample

@noindent
は「@code{void}を返す返らない関数へのインタへのポインタへのポインタへのポインタ」の型を指定する。別の例として、

@smallexample
char *__attribute__((aligned(8))) *f;
@end smallexample

@noindent
は＠cpde{char}への8バイト境界のポインタへのポインタを指定する。これはほとんどの属性では機能しないことに再び注意すること。 たとえば、上記の@samp{aligned}属性と@samp{noreturn}属性の使用はまだサポートされていない。

ネストされた宣言子の属性を実装していないコンパイラのバージョン用に書かれた既存のコードとの互換性のために、属性の配置にある程度の寛容さが許されている。型にのみ適用される属性が宣言に適用される場合、その宣言の型に適用されるものとして扱われる。宣言にのみ適用される属性が宣言の型に適用される場合、その宣言に適用するものとして扱われる。そして識別子が宣言される直前に属性を配置するコードとの互換性のために、関数の戻り型に適用されるこのような属性は、関数型に適用されるものとして扱われ、配列要素型に適用されるそのような属性は、配列型に適用されるものとして扱われる。関数型にのみ適用される属性が関数型へのポインタ型に適用される場合、それはポインタのターゲット型に適用されるものとして扱われる。そのような属性が関数へのポインタ型ではない関数戻り型に適用された場合、それは関数型に適用するものとして扱われる。

@node Function Prototypes
@section プロトタイプと旧式の関数宣言
@cindex function prototype declarations
@cindex old-style function definitions
@cindex promotion of formal parameters

GNU Cは、ISO Cを拡張して、関数プロトタイプが後の古いスタイルの非プロトタイプ定義を上書きできるようにする。 次の例を考える。

@smallexample
/* @r{Use prototypes unless the compiler is old-fashioned.}  */
#ifdef __STDC__
#define P(x) x
#else
#define P(x) ()
#endif

/* @r{Prototype function declaration.}  */
int isroot P((uid_t));

/* @r{Old-style function definition.}  */
int
isroot (x)   /* @r{??? lossage here ???} */
     uid_t x;
@{
  return x == 0;
@}
@end smallexample

@code {uid_t}型が@code {short}であるとする。 ISO Cでは、旧式の非プロトタイプ定義のサブワード引数が昇格されるため、この例は許可されない。 したがって、この例では、関数定義の引数は実際には@code{int}で、プロトタイプ引数の型@code{short}と一致しない。

このISO Cの制限により、プログラマーは@code{uid_t}型が@code{short}、@code{int}、または@code{long}であるかどうかわからないため、従来のCコンパイラに移植可能なコードを書くのが難しくなる。 したがって、これらのような場合、これらのGNU Cではプロトタイプが古いスタイルの定義を上書きすることができる。 より正確には、GNU Cでは、関数プロトタイプの引数型は、前の型が宣言前の後者の型と同じ場合は、後の旧式の型定義で指定された引数の型を上書きする。 したがって、GNU Cでは、上記の例は次のようになる。

@smallexample
int isroot (uid_t);

int
isroot (uid_t x)
@{
  return x == 0;
@}
@end smallexample

@noindent
GNU C ++は古いスタイルの関数定義をサポートしていないので、この拡張は無関係である。

@node C++ Comments
@section C++形式のコメント
@cindex @code{//}
@cindex C++ comments
@cindex comments, C++ style

GNU Cでは、C++スタイルのコメントを使うことができる。コメントは@samp {//}で始まり、行末まで続く。 他の多くのC実装では、このようなコメントが許可されており、1999 C標準に含まれている。 しかし、C99の前にISO Cのバージョンを指定する@option {-std}オプション、または@option{-ansi}（@option{-std = c90}と同等）を指定すると、C++スタイルのコメントは認識されない。

@node Dollar Signs
@section 識別子名でのドル記号
@cindex $
@cindex dollar signs in identifier names
@cindex identifier names, dollar signs in

GNU Cでは、通常、識別子名にドル記号を使用することができる。これは、多くの伝統的なC実装がそのような識別子を許可するためである。ただし、いくつかのターゲット・マシンでは、識別子のドル記号をターゲット・アセンブラーがそれらを許可しないため、サポートされない。

@node Character Escapes
@section 定数での@key{ESC}文字

文字列または文字定数で@samp{\e}というシーケンスを使用すると、ASCII文字@key{ESC}を表すことができる。

@node Alignment
@section 型及び変数のアラインメントの検査
@cindex alignment
@cindex type alignment
@cindex variable alignment

キーワード@code{__alignof__}を使うと、オブジェクトがどのように整列されているか、及び型によって通常必要とされる最小整列について問い合わせることができる。 その構文は@code{sizeof}と同じである。

たとえば、ターゲットマシンが@code {double}値を8バイト境界に揃える必要がある場合、@code {__alignof__(double)}は8である。これは多くのRISCマシンで当てはまる。 より伝統的なマシン設計では、@code{__alignof__(double)}は4または2である。

一部のマシンでは実際にはアラインメントが必要ない。それらは、奇数アドレスであっても任意のデータ型への参照を可能にする。これらのマシンでは、@code{__alignof__}は、GCCがデータ型を与える最小のアライメントを報告する。通常、ターゲットABIが指定する。

@code{__alignof__}のオペランドが型ではなく左辺値の場合、その値は、GCCの@code{__ attribute__}拡張子（@pxref{Variable Attributes}）で指定された最小整列を考慮して、その型の必要な整列である 。 たとえば、次の宣言の後に：

@smallexample
struct foo @{ int x; char y; @} foo1;
@end smallexample

@noindent
@code{__alignof__(foo1.y)}の値は、実際の配置がおそらく2または4であっても、@code{__alignof__(int)}と同じ1である。

不完全な型のアライメントを求めるのは誤りである。


@node Inline
@section マクロと同等に速いインライン関数
@cindex inline functions
@cindex integrating function code
@cindex open coding
@cindex macros, inline alternative

関数をインラインで宣言することで、GCCにその関数の呼び出しをより高速にするように指示できる。 GCCがこれを達成できる1つの方法は、その関数のコードを呼び出し元のコードに統合することである。 これにより、関数呼び出しのオーバーヘッドを排除して実行を高速化する。 さらに、実際の引数の値のいずれかが定数である場合、それらの既知の値によって、コンパイル時の簡略化が可能になり、インライン関数のコードのすべてを含める必要はなくなる。 コードサイズへの影響はあまり予測できない。 特定の場合に応じて、関数インライン化によってオブジェクトコードが大きくても小さくなるかもしれない。 また、GCCに対して、@option{-finline-functions}オプションを使用して、すべての「単純な」関数を呼び出し元に統合しようとすることもできる。

GCCは、関数をインラインで宣言するという3つの異なるセマンティクスを実装している。 1つは、@option{-std=gnu89}または@option{-fgnu89-inline}、または@code{gnu_inline}属性がすべてのインライン宣言に存在する場合、もう1つは@option{-fgnu89-inline}を指定せずに@option{-std=c99}、@option{-std=c11}、@option{-std=gnu99}または@option{-std=gnu11}を指定するとき、三番目はC++をコンパイルするときに使用される。

関数をインラインで宣言するには、宣言に次のように@code{inline}キーワードを使用する。

@smallexample
static inline int
inc (int *a)
@{
  return (*a)++;
@}
@end smallexample

ISO C90プログラムにインクルードするヘッダーファイルを作成する場合は、@code{inline}ではなく@code{__inline__}を記述する。@xref{Alternate Keywords}.

3つのタイプのインライン展開は、2つの重要なケースで同様に動作する。上記の例のように@code{static}関数で@code{inline}キーワードを使用するとき、そして以下のように、関数が@code{inline}キーワードを使わずに宣言され、その後@code{inline}で定義されるとき。

@smallexample
extern int inc (int *a);
inline int
inc (int *a)
@{
  return (*a)++;
@}
@end smallexample

これらの一般的な場合の両方で、プログラムは速度以外は@code{inline}キーワードを使用しなかった場合と同じように動作する。

@cindex inline functions, omission of
@opindex fkeep-inline-functions
関数がインラインと@code{static}の両方の場合、関数へのすべての呼び出しが呼び出し側に統合され、関数のアドレスが決して使用されないと、関数自身のアセンブラコードは決して参照されない。この場合、オプション@option{-fkeep-inline-functions}を指定しない限り、GCCは関数のアセンブラコードを実際に出力しない。統合されていない呼び出しがある場合、関数はいつものようにアセンブラコードにコンパイルされる。 インライン化できないため、プログラムがそのアドレスを参照している場合は、通常どおりコンパイルする必要がある。

@opindex Winline
関数定義の特定の用途は、インライン置換には適していないことに注意せよ。 これらの使用法の中には、可変長引数関数、@code{alloca}の使用、計算gotoの使用（@pxref{Labels as Values}）、非局所的なgotoの使用、入れ子関数の使用、@code{setjmp}の使用、 @code{__ builtin_longjmp}と@code{__ builtin_return}または@code{__ builtin_apply_args}の使用。 @option{-Winline}を使用すると、@code{inline}とマークされた関数を代入できなかったときに警告が表示され、失敗の理由が示される。

@cindex automatic @code{inline} for C++ member fns
@cindex @code{inline} automatic for C++ member fns
@cindex member fns, automatically @code{inline}
@cindex C++ member fns, automatically @code{inline}
@opindex fno-default-inline
GCCは、ISO C++の必要条件として、クラスの本体内で定義されたメンバ関数が、@code{inline}キーワードで明示的に宣言されていなくてもインラインでマークされると見なる。 これを@option{-fno-default-inline}で上書きすることができる。 @pxref{C++ Dialect Options,,C++変種を制御するオプション}

GCCは、関数に@samp{always_inline}属性を指定しない限り、最適化していないときに関数をインライン化しない。

@smallexample
/* @r{Prototype.}  */
inline void foo (const char) __attribute__((always_inline));
@end smallexample

このセクションの残りの部分は、GNU C90のインライン展開に特有のものである。

@cindex non-static inline function
インライン関数が@code{static}でない場合、コンパイラは他のソースファイルからの呼び出しがあると想定する必要がある。 グローバルシンボルはどのプログラムでも一度しか定義できないので、関数を他のソースファイルで定義してはいけないので、その中の呼び出しを統合することはできない。 したがって、非@code{static}インライン関数は常に通常の方法でそれ自身でコンパイルされる。

関数定義で@code{inline}と@code{extern}の両方を指定すると、定義はインライン化にのみ使用される。 たとえあなたがそのアドレスを明示的に参照したとしても、関数はそれ自身でコンパイルされることはない。 このようなアドレスは、あたかも関数を宣言していて、定義していないかのように、外部参照になる。

この@code{inline}と@code{extern}の組み合わせは、ほとんどマクロの効果を持つ。 これを使う方法は、これらのキーワードを使ってヘッダファイルに関数定義を置き、ライブラリファイルに定義の別のコピー（@code{inline}と@code{extern}がない）を置くことである。 ヘッダーファイルの定義によって、関数へのほとんどの呼び出しがインライン化される。 関数の使用が残っている場合は、ライブラリ内の単一のコピーを参照する。

@node Volatiles
@section いつvolatileオブジェクトにアクセスするか
@cindex accessing volatiles
@cindex volatile read
@cindex volatile write
@cindex volatile access

Cにはvolatileオブジェクトの概念がある。 これらは通常ポインターによってアクセスされ、ハードウェアまたはスレッド間通信にアクセスするために使用される。 この標準では、コンパイラがvolatileオブジェクトへのアクセスに関する最適化を控えるように勧めているが、何が揮発性のアクセスを構成するかについて実装定義のままとしている。 シーケンスポイントでは、volatileオブジェクトへの以前のすべてのアクセスが安定し、その後のアクセスは発生していないことが最低限必要である。 したがって、実装では、シーケンスポイント間で発生するvolatileアクセスを並べ替えて組み合わせることは自由であるが、シーケンスポイント間のアクセスでは実行できない。 volatileを使用すると、2つのシーケンスポイント間でオブジェクトを複数回更新する際の制限に違反することはできない。

不揮発性オブジェクトへのアクセスは、volatileアクセスに関しては順序付けられていない。 非volatileメモリへの一連の書き込みを順序付けるために、volatileオブジェクトをメモリバリアとして使用することはできない。 例えば：

@smallexample
int *ptr = @var{something};
volatile int vobj;
*ptr = @var{something};
vobj = 1;
@end smallexample

@noindent
@var{*ptr}と@var{vobj}にエイリアスを付けることができない限り、@var{*ptr}への書き込みは、@var{vobj}の更新が発生するまでに発生することは保証されない。 この保証が必要な場合は、次のような強力なメモリバリアを使用する必要がある。

@smallexample
int *ptr = @var{something};
volatile int vobj;
*ptr = @var{something};
asm volatile ("" : : : "memory");
vobj = 1;
@end smallexample

スカラー揮発性オブジェクトは、voidコンテキストでアクセスされると読み込まれる。

@smallexample
volatile int *src = @var{somevalue};
*src;
@end smallexample

このような式は右辺値であり、GCCはこれがvolatileオブジェクトの読み込みとして指し示すものとして実装する。

代入は式でもあり、右辺値を持つ。 ただし、スカラー揮発性に割り当てるときは、代入式の右辺値が使用されているかどうかにかかわらず、volatileオブジェクトは再読み込みされない。 代入の右辺値が使用されている場合、その値はvolatileオブジェクトに割り当てられた値になる。 たとえば、次のすべての場合に@var{vobj}の読み込みはない。

@smallexample
int obj;
volatile int vobj;
vobj = @var{something};
obj = vobj = @var{something};
obj ? vobj = @var{onething} : vobj = @var{anotherthing};
obj = (@var{something}, vobj = @var{anotherthing});
@end smallexample

代入が発生した後にvolatileオブジェクトを読み取る必要がある場合は、介在するシーケンスポイントを持つ別の式を使用する必要がある。

ビットフィールドが個別にアドレス可能ではないので、volatileビットフィールドは、書き込まれるとき、または隣接するビットフィールドがアクセスされるときに暗黙的に読み取られ得る。 ビットフィールド動作は、隣接するビットフィールドが記憶装置の境界をまたぐ場合、部分的にのみアクセスされるように最適化することができる。 これらの理由から、volatileビットフィールドを使用してハードウェアにアクセスすることは賢明ではない。

@node Using Assembly Language with C
@section Cコードでインラインアセンブリ言語を使う方法
@cindex @code{asm} keyword
@cindex assembly language in C
@cindex inline assembly language
@cindex mixing assembly language and C

@code{asm}キーワードを使用すると、Cコード内にアセンブラ命令を埋め込むことができる。 GCCは2つの形式のインライン@code{asm}文を提供する。@dfn{basic @code{asm}}(基本 asm)文はオペランドを持たず (@pxref{Basic Asm})、一方@dfn{extended @code{asm}}(拡張asm)は一つ以上のオペランドを含む。拡張形式は、関数内でC言語とアセンブリ言語を混合する場合に好まれるが、アセンブリ言語を最上位レベルに組み込むには、基本@code{asm}を使用する必要がある。

@code{asm}キーワードを使用して、Cシンボルのアセンブラ名を上書きしたり、C変数を特定のレジスタに配置したりすることもできる。

@menu
* Basic Asm::          オペランドなしのインラインアセンブラ
* Extended Asm::       オペランドのあるインラインアセンブラ
* Constraints::        @code{asm}オペランドの制約
* Asm Labels::         Cシンボル用に使うためのアセンブラの名前を指定する
* Explicit Register Variables::  指定されたレジスタに存在する変数の定義。
* Size of an asm::     GCCが@code{asm}ブロックのサイズを計算する方法。
@end menu

@node Basic Asm
@subsection 基本Asm --- オペランドなしのアセンブラ命令
@cindex basic @code{asm}
@cindex assembly language in C, basic

基本@code{asm}文は以下の構文を持つ。

@example
asm @r{[} volatile @r{]} ( @var{AssemblerInstructions} )
@end example

@code{asm}キーワードはGNU拡張である。@option{-ansi}とさまざまな@option{-std}オプションでコンパイルできるコードを書くときは、@code{asm}の代わりに@code{__ asm__}（@pxref {Alternate Keywords}）を使用すること。
(@pxref{Alternate Keywords}).

@subsubheading 限定子
@table @code
@item volatile
オプションの@code{volatile}修飾子は効果がない。すべての基本的な@code{asm}ブロックは暗黙的に揮発性である。
@end table

@subsubheading パラメータ
@table @var

@item AssemblerInstructions（アセンブラ命令）
これは、アセンブラコードを指定するリテラル文字列である。 この文字列には、ディレクティブを含め、アセンブラで認識されるすべての命令を含めることができる。GCCはアセンブラ命令自体を解析せず、それらが何を意味するのか、またそれらが有効なアセンブラ入力であるかを知らない。

1つの@code {asm}文字列に、システムのアセンブリコードで通常使用される文字で区切られた、複数のアセンブラ命令を一緒に配置することができる。 ほとんどの場所で動作する組み合わせは、改行とタブ文字（@samp {\n\t}と書かれる）である。一部のアセンブラではセミコロンを行区切り記号として使用できる。 ただし、アセンブラの方言の中には、セミコロンを使用してコメントを開始するものがある。
@end table

@subsubheading 注意
拡張@code{asm}（@pxref{Extended Asm}）を使うと、通常、より小さく、より安全で、より効率的なコードが生成され、ほとんどの場合、基本@code{asm}より優れた解決策である。 しかし、基本@code{asm}だけが使用できる2つの状況がある：

@itemize @bullet
@item
拡張@code{asm}文はC関数内になければならない。したがって、C関数の外部でファイルスコープ（ 「トップレベル 」）にインラインアセンブリ言語を書くには、基本@code{asm}を使用する必要がある。この手法を使用して、アセンブラディレクティブを発行したり、ファイル内の別の場所で呼び出せるアセンブリ言語マクロを定義したり、アセンブリ言語で関数全体を記述したりすることができる。

@item
@code {naked}属性で宣言された関数も、基本的な@code {asm}を必要とする。(@pxref{Function Attributes}).
@end itemize

基本@code{asm}から安全にCデータにアクセスし、関数を呼び出すことは、見かけよりも複雑である。 Cデータにアクセスするには、拡張@code{asm}を使用する方が良い。

コンパイル後に@code{asm}文のシーケンスが完全に連続しているとは思ってはならない。 特定の命令を連続して出力に残す必要がある場合は、それらを単一のマルチ命令@code{asm}文に入れる。 GCCのオプティマイザは、ジャンプを含めた他のコードと比較して@code{asm}文を移動できることに注意せよ。

@code{asm}文は他の@code {asm}文にジャンプしてはならない。GCCはこれらのジャンプについて知らないため、最適化の方法を決める際には考慮することができない。 @code{asm}からCラベルへのジャンプは、拡張@code{asm}でのみサポートされる。

特定の状況下では、GCCは最適化するときにアセンブリコードを複製（または重複を取り除く）することがある。 アセンブラコードでシンボルまたはラベルが定義されていると、コンパイル時に予期しない重複シンボルエラーが発生する可能性がある。

@strong{警告:} Cの標準は@code{asm}のセマンティクスを指定していないので、コンパイラ間の非互換性の原因となる。 これらの非互換性によって、コンパイラの警告/エラーが発生することはない。

GCCは基本@code{asm}の@var{AssemblerInstructions}を解析しない。つまり、内部で何が起こっているのかをコンパイラに伝える方法がない。 GCCは@code{asm}内のシンボルの可視性を持たず、参照されていないものとして破棄することがある。 また、メモリやレジスタの変更など、アセンブラコードの副作用についても認識しない。 いくつかのコンパイラとは異なり、GCCは汎用レジスタへの変更は起こらないと仮定している。 この仮定は、将来のリリースで変更される可能性がある。

将来のセマンティクスの変更やコンパイラ間の互換性の問題を避けるため、基本@code{asm}を拡張@code{asm}に置き換えることを検討せよ。 この変換の実行方法については、@uref{https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended、基本asmから拡張asmへの変換方法}を参照すること。

コンパイラは、拡張@code{asm}で使用可能な変種や@samp{％}演算子を処理せずに、基本的な@code{asm}のアセンブラ命令をアセンブリ言語出力ファイルにそのままコピーする。 これにより、基本@code{asm}文字列と拡張された@code{asm}テンプレートの間には小さな違いが生じる。 たとえば、レジスタを参照するには、基本@code{asm}では@samp {％eax}を、拡張@code{asm}では@samp{%%eax}を使用する。

複数のアセンブラ変種をサポートするx86などのターゲットでは、すべての基本@code{asm}ブロックが@option{-masm}コマンドラインオプション（@pxref {x86オプション}）で指定されたアセンブラ変種を使用する。基本@code{asm}は、異なる変種に対して異なるアセンブラ文字列を提供する仕組みを提供しない。

GCCは、アセンブラブロックが汎用レジスタを変更しないと仮定するが、グローバルにアクセス可能な変数を読み書きすることができる。

i386の基本的な@code {asm}の例を次に示す。

@example
/* Note that this code will not compile with -masm=intel */
#define DebugBreak() asm("int $3")
@end example

@node Extended Asm
@subsection 拡張Asm - C式オペランドのあるアセンブラ命令
@cindex extended @code{asm}
@cindex assembly language in C, extended

拡張@code{asm}を使用すると、アセンブラからC変数を読み書きし、アセンブラコードからCラベルにジャンプすることができる。拡張@code{asm}構文は、アセンブラテンプレートの後にオペランドパラメータを区切るためにコロン（@samp{:}）を使用する：

@example
asm @r{[}volatile@r{]} ( @var{AssemblerTemplate} 
                 : @var{OutputOperands} 
                 @r{[} : @var{InputOperands}
                 @r{[} : @var{Clobbers} @r{]} @r{]})

asm @r{[}volatile@r{]} goto ( @var{AssemblerTemplate} 
                      : 
                      : @var{InputOperands}
                      : @var{Clobbers}
                      : @var{GotoLabels})
@end example

@code{asm}キーワードはGNU拡張である。@option{-ansi}と様々な@option {-std}オプションでコンパイルできるコードを書くときは、@code{asm}の代わりに@code{__ asm__}を使う。 (@pxref{Alternate Keywords}).

@subsubheading 限定子
@table @code

@item volatile
拡張@code{asm}文の典型的な使い方は、入力値を操作して出力値を生成することである。 しかし、@code{asm}文は、副作用も生じる。 その場合は、特定の最適化を無効にするために@code{volatile}修飾子を使用する必要がある。@xref{Volatile}.

@item goto
この修飾子は、@code{asm}文が@var{GotoLabels}にリストされているラベルの1つにジャンプする可能性があることをコンパイラに通知する。@xref{GotoLabels}.
@end table

@subsubheading パラメータ
@table @var
@item AssemblerTemplate
これは、アセンブラコードのテンプレートであるリテラル文字列である。 入力テキスト、出力テキスト、およびgotoパラメータを参照する固定テキストとトークンの組み合わせである。@xref{AssemblerTemplate}.

@item OutputOperands（出力オペランド）
@var{AssemblerTemplate}の命令で変更されたC変数のカンマ区切りのリスト。 空のリストが許可される。@xref{OutputOperands}.

@item InputOperands（入力オペランド）
@var{AssemblerTemplate}の命令で読み取られるC式のカンマ区切りリスト。 空のリストが許可される。@xref{InputOperands}.

@item Clobbers（破壊子）
出力としてリストされたものを覗いた、@var{AssemblerTemplate}によって変更されたレジスタまたはその他の値のコンマ区切りのリスト。空のリストが許可される。@xref{Clobbers}.

@item GotoLabels（Gotoラベル）
@code{asm}の@code{goto}形式を使用している場合、このセクションには、@var{AssemblerTemplate}のコードがジャンプする可能性のあるすべてのCラベルのリストが含まれている。
@xref{GotoLabels}.

@code{asm}文は、リストされた@var{GotoLabels}に対してのみジャンプすることができ、他の@code{asm}文にジャンプすることはできない。GCCのオプティマイザは他のジャンプについて知らない。したがって、どのように最適化するかを決めるときに、それらを考慮に入れることはできない。
@end table

入力+出力+ gotoオペランドの合計数は30に制限されている。

@subsubheading 注意
@code{asm}ステートメントを使用すると、Cコード内にアセンブリ命令を直接組み込むことができる。 これは、時間に敏感なコードのパフォーマンスを最大化したり、Cプログラムがすぐに利用できないアセンブリ命令にアクセスするのに役立つ。

拡張@code {asm}文は関数内になければならないことに注意。基本@code{asm}だけが関数の外にあることができる（@pxref {Basic Asm}）。@code{naked}属性で宣言された関数も、基本@code{asm}を必要とする。 (@pxref{Function Attributes}).

@code{asm}の使用方法は多種多様だが、入力パラメータを出力パラメータに変換する一連の低レベル命令として@code{asm}文を考えると役に立つ。なので、@code{asm}を使ったi386のシンプルな（特に有用ではないにしても）例は次のようになる：

@example
int src = 1;
int dst;   

asm ("mov %1, %0\n\t"
    "add $1, %0"
    : "=r" (dst) 
    : "r" (src));

printf("%d\n", dst);
@end example

このコードは@code{src}を@code{dst}にコピーし、1を@code{dst}に追加する。

@anchor{Volatile}
@subsubsection Volatile
@cindex volatile @code{asm}
@cindex @code{asm} volatile
GCCのオプティマイザは、出力変数の必要がないと判断した場合、@code {asm}文を破棄することがある。 また、オプティマイザは、コードが常に同じ結果を返すと考えられる場合（つまり、入力値のいずれも呼び出し間で変化しない場合）、コードをループから移動させる可能性がある。 @code{volatile}修飾子を使用すると、これらの最適化が無効になる。 @code{asm goto}文を含む出力オペランドを持たない@code{asm}文は暗黙的にvolatileである。

このi386コードは、@code{volatile}修飾子を使用しない（または必要とする）ケースを示している。 アサーションチェックを実行している場合、このコードは@code{asm}を使用して検証を実行する。それ以外の場合、@code{dwRes}はどのコードでも参照されない。 結果として、オプティマイザは@code{asm}文を破棄することができ、@code{DoCheck}ルーチン全体が不要になる。@code{volatile}修飾子を省略すると、オプティマイザは可能な限り効率的なコードを生成できる。

@example
void DoCheck(uint32_t dwSomeValue)
@{
   uint32_t dwRes;

   // Assumes dwSomeValue is not zero.
   asm ("bsfl %1,%0"
     : "=r" (dwRes)
     : "r" (dwSomeValue)
     : "cc");

   assert(dwRes > 3);
@}
@end example

次の例は、オプティマイザが関数の実行中に入力（@ code{dwSomeValue}）が決して変化しないことを認識できるので、より効率的なコードを生成するためにループの外側に@code{asm}を移動できる。ここでも、@code{volatile}を使用すると、このタイプの最適化が無効になる。

@example
void do_print(uint32_t dwSomeValue)
@{
   uint32_t dwRes;

   for (uint32_t x=0; x < 5; x++)
   @{
      // Assumes dwSomeValue is not zero.
      asm ("bsfl %1,%0"
        : "=r" (dwRes)
        : "r" (dwSomeValue)
        : "cc");

      printf("%u: %u %u\n", x, dwSomeValue, dwRes);
   @}
@}
@end example

次の例は、@code{volatile}修飾子を使用する必要がある場合を示している。x86の@code{rdtsc}命令を使用して、コンピュータのタイムスタンプカウンタを読み取る。 オプティマイザは、@code{volatile}修飾子を指定しないと、@code{asm}ブロックが常に同じ値を返すと仮定して、2番目の呼び出しを最適化する。

@example
uint64_t msr;

asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
        "shl $32, %%rdx\n\t"  // Shift the upper bits left.
        "or %%rdx, %0"        // 'Or' in the lower bits.
        : "=a" (msr)
        : 
        : "rdx");

printf("msr: %llx\n", msr);

// Do other work...

// Reprint the timestamp
asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
        "shl $32, %%rdx\n\t"  // Shift the upper bits left.
        "or %%rdx, %0"        // 'Or' in the lower bits.
        : "=a" (msr)
        : 
        : "rdx");

printf("msr: %llx\n", msr);
@end example

GCCのオプティマイザは、以前の例ではこのコードを不揮発性コードのように扱っていない。 以前の呼び出しの結果が依然として有効であるという前提で、ループから移動したり、ループを省略することはない。

コンパイラはジャンプ命令全体を含む、他のコードと相対で揮発性の@code {asm}命令も移動させることができる。 たとえば、多くのターゲットでは、浮動小数点演算の丸めモードを制御するシステム・レジスタがある。 揮発性の@code{asm}で設定すると、次のPowerPCの例のように確実に動作しない。

@example
asm volatile("mtfsf 255, %0" : : "f" (fpenv));
sum = x + y;
@end example

コンパイラは、volatile @code{asm}の前に加算を動かすかもしれない。期待通りに動作させるには、後続のコードで変数を参照することで、@code{asm}に人為的な依存関係を追加する。例えば、

@example
asm volatile ("mtfsf 255,%1" : "=X" (sum) : "f" (fpenv));
sum = x + y;
@end example

特定の状況下では、GCCは最適化するときにアセンブリコードを複製（または重複を除去）することがある。 これにより、asmコードでシンボルまたはラベルが定義されていると、コンパイル時に予期しない重複シンボルエラーが発生する可能性がある。@samp{％=}（@pxref {AssemblerTemplate}）を使用すると、この問題を解決できる。

@anchor{AssemblerTemplate}
@subsubsection アセンブラテンプレート
@cindex @code{asm} assembler template

アセンブラテンプレートは、アセンブラ命令を含むリテラル文字列である。コンパイラは、入力、出力、およびgotoラベルを参照するテンプレート内のトークンを置き換え、結果の文字列をアセンブラに出力する。この文字列には、ディレクティブを含め、アセンブラで認識されるすべての命令を含めることができる。GCCはアセンブラ命令自体を解析せず、それらが何を意味するのか、またそれらが有効なアセンブラ入力であるかを知らないが、文は数える。(@pxref{Size of an asm}).

1つの@code{asm}文字列に、システムのアセンブリコードで通常使用される文字で区切られた、複数のアセンブラ命令を一緒に配置することができる。ほとんどの場所で動作する組み合わせは、行を改行する改行と、タブフィールド（@samp{\n \t}と書かれる）に移動するためのタブ文字である。一部のアセンブラではセミコロンを行区切り記号として使用できる。 ただし、アセンブラの方言の中には、セミコロンを使用してコメントを開始するものがある。

@code{volatile}修飾子を使用していても、コンパイル後に一連の@code{asm}文が完全に連続しているとは期待しないこと。特定の命令を連続して出力に残す必要がある場合は、それらを単一のマルチ命令asm文に入れる。

入力/出力オペランドを使用せずに（たとえば、アセンブラテンプレートからグローバルシンボルを使用して）Cプログラムからデータにアクセスすると、期待どおりに動作しないことがある。同様に、アセンブラテンプレートから関数を直接呼び出すには、ターゲットアセンブラとABIの詳細な理解が必要である。

GCCはアセンブラテンプレートを解析しないので、参照するシンボルの可視性はない。 これにより、GCCは、入力、出力、またはgotoオペランドとしてもリストされていない限り、これらのシンボルを参照されないものとして破棄することがある。

@subsubheading 特別なフォーマット文字列

input、output、およびgotoオペランドで記述されたトークンに加えて、これらのトークンはアセンブラテンプレートに特別な意味を持つ。

@table @samp
@item %% 
単一の@samp {％}をアセンブラコードに出力する。

@item %= 
コンパイル全体で@code{asm}文の各インスタンスに固有の番号を出力する。 このオプションは、ローカルラベルを作成し、複数のアセンブラ命令を生成する1つのテンプレートでそれらを複数回参照する場合に便利である。

@item %@{
@itemx %|
@itemx %@}
@samp{@{}、@samp{|}、@samp{@}}文字をそれぞれアセンブラコードに出力する。 エスケープされていない場合、これらの文字は、以下に説明するように、複数のアセンブラ方言を示すために特別な意味を持つ。
@end table

@subsubheading @code{asm}テンプレートでの複数のアセンブラ変種

x86などのターゲットでは、GCCは複数のアセンブラ変種をサポートしている。@option{-masm}オプションは、GCCがインラインアセンブラのデフォルトとして使用するダイアレクトを制御する。 @option{-masm}オプションのターゲット固有のドキュメントには、サポートされている変種のリストと、オプションが指定されていない場合のデフォルトの変種が含まれている。ある方言を使ってコンパイルしたときに正しく動作するアセンブラコードは、別の方言を使ってコンパイルすると失敗する可能性があるため、この情報は理解するのに重要である。@xref{x86 Options}.

コードが複数のアセンブラ変種をサポートする必要がある場合（例えば、さまざまなコンパイルオプションをサポートする必要があるパブリックヘッダを書く場合）、このフォームの構文を使用する：

@example
@{ dialect0 | dialect1 | dialect2... @}
@end example

この構文は、変種＃0を使用してコードをコンパイルするときに@code{dialect0}、変種＃1に@code {dialect1}などを出力する。中括弧内の代替語句がコンパイラがサポートする変種の数より少ない場合、構文は何も出力しない。

たとえば、x86コンパイラが2つの変種（@samp{att}、@samp{intel}）をサポートしている場合、次のようなアセンブラテンプレートは：

@example
"bt@{l %[Offset],%[Base] | %[Base],%[Offset]@}; jc %l2"
@end example

@noindent
以下の一つと等価である

@example
"btl %[Offset],%[Base] ; jc %l2"   @r{/* att dialect */}
"bt %[Base],%[Offset]; jc %l2"     @r{/* intel dialect */}
@end example

同じコンパイラを使用して、このコードは：

@example
"xchg@{l@}\t@{%%@}ebx, %1"
@end example

@noindent
いずれかに対応する

@example
"xchgl\t%%ebx, %1"                 @r{/* att dialect */}
"xchg\tebx, %1"                    @r{/* intel dialect */}
@end example

代替のネストをサポートしていない。

@anchor{OutputOperands}
@subsubsection 出力オペランド
@cindex @code{asm} output operands

@code{asm}文には、アセンブラコードによって変更されたC変数の名前を示す0個以上の出力オペランドがある。

このi386の例では、@code{old}（テンプレート文字列の@code{％0}として参照される）と@code{*Base}（@code{％1}）は出力であり、@code{Offset}（@code {％2}）は入力である：

@example
bool old;

__asm__ ("btsl %2,%1\n\t" // Turn on zero-based bit #Offset in Base.
         "sbb %0,%0"      // Use the CF to calculate old.
   : "=r" (old), "+rm" (*Base)
   : "Ir" (Offset)
   : "cc");

return old;
@end example

オペランドはコンマで区切られます。 各オペランドは次の形式である。

@example
@r{[} [@var{asmSymbolicName}] @r{]} @var{constraint} (@var{cvariablename})
@end example

@table @var
@item asmSymbolicName
オペランドのシンボリック名を指定する。アセンブラテンプレートの名前は、角括弧（@samp{％[Value]}）で囲んで参照する。名前のスコープは、定義を含む@code{asm}ステートメントである。 周囲のコードにすでに定義されている名前を含め、任意の有効なC変数名を使用できる。同じ@code{asm}ステートメント内に2つのオペランドが同じシンボリック名を使用することはできない。

@var{asmSymbolicName}を使用しないときは、アセンブラ・テンプレートのオペランドのリスト内のオペランドの（ゼロからの）位置を使用する。 たとえば、3つの出力オペランドがある場合は、最初のものをテンプレートの@samp{％0}で、2番目の@samp{％1}と3番目のものの@samp{％2}を使用して参照する。

@item constraint
オペランドの配置に関する制約を指定する文字列定数。詳細は@xref{Constraints}を参照せよ。

出力制約は、@samp{=}（既存の値を上書きする変数）または@samp{+}（読み書き時）で始まる必要がある。 @samp{=}を使用する場合、オペランドが入力に接続されている場合を除いて、その場所に@code{asm}への入力時に既存の値が含まれていると仮定しないこと。@pxref{InputOperands,,Input Operands}.

接頭辞の後には、値がどこにあるかを記述する1つ以上の追加の制約（@pxref{Constraints}）が必要である。一般的な制約には、レジスタの@samp{r}とメモリの@samp{m}がある。 可能な場所を複数指定すると（たとえば@code{"rm"}）、コンパイラは現在のコンテキストに基づいて最も効率的な場所を選択する。@code{asm}文で許される数だけアルファベットを指定すると、オプティマイザは可能な限り最良のコードを生成できる。特定のレジスタを使用する必要があるが、機種制約が必要な特定のレジスタを選択するのに十分な制御を提供していない場合、ローカルレジスタ変数が解決策を提供する（@pxref {Local Register Variables}）。

@item cvariablename
出力を保持するC言語の式（通常は変数名）を指定します。囲み括弧は構文の必須部分である。

@end table
コンパイラが出力オペランドを表すために使用するレジスタを選択すると、clobberedレジスタは使用されない。(@pxref{Clobbers})。

出力オペランド式は左辺値でなければならない。 コンパイラは、オペランドが実行されている命令に合ったデータ型を持っているかどうかをチェックすることはできない。直接アドレス可能ではない出力式（たとえばビットフィールド）の場合、制約でレジスタを許可する必要がある。 その場合、GCCはレジスタを@code{asm}の出力として使用し、そのレジスタを出力に格納する。

@samp{+}制約修飾子を使用するオペランドは、@code{asm}ステートメントごとに最大30個のオペランドまでの2つのオペランド（つまり、入力と出力の両方）としてカウントされる。

@samp{&}制約修飾子（@pxref {Modifiers}）は、入力と重複してはならないすべての出力オペランドに対して使用する。 さもなければ、GCCは出力を生成する前にアセンブラコードがその入力を消費すると仮定して、無関係の入力オペランドと同じレジスタに出力オペランドを割り当てることができる。 アセンブラコードが実際に複数の命令で構成されている場合、この仮定は誤っている可能性がある。

1つの出力パラメータ（@var{a}）がレジスタ制約を許可し、別の出力パラメータ（@var{b}）がメモリ制約を許容する場合、同じ問題が発生する可能性がある。@var{b}のメモリアドレスにアクセスするためにGCCによって生成されたコードは、@var{a}によって共有される@emph{_可能性のある_}レジスタを含むかもしれず、GCCはこれらのレジスタをasmへの入力と見なす。上記のように、GCCは、出力が書き込まれる前にそのような入力レジスタが消費されると仮定する。この仮定は、asmが@var{b}を使用する前に@var{a}に書き込むと正しく動作しなくなる可能性がある。@samp{&}修飾子を@var{a}のレジスタ制約と組み合わせると、@var{a}の変更が@var{b}が参照するアドレスに影響しないようになる。そうでなければ、@var{a}が変更されてから@var{b}が使用されると、@var{b}の位置は未定義である。

@code{asm}はオペランドのオペランド修飾子をサポートしている（例えば@samp{％2}の代わりに@samp{％k2}）。 通常、これらの修飾子はハードウェアに依存する。 x86でサポートされている修飾子のリストは、次の場所にあります。
@ref{x86Operandmodifiers,x86 Operand modifiers}.

@code{asm}に続くCコードが出力オペランドを何も使用しない場合は、オプティマイザが未使用として@code{asm}文を破棄しないように@code {asm}文に@code{volatile}を使用する。(@ref{Volatile}参照。)

このコードはオプションの@var{asmSymbolicName}を使用しない。 そのため、最初の出力オペランドを@code{％0}（2番目に@code {％1}など）として参照する。 最初の入力オペランドの数は、最後の出力オペランドの数より1多い。 このi386の例では、@code{Mask}は@code{％1}として参照される：

@example
uint32_t Mask = 1234;
uint32_t Index;

  asm ("bsfl %1, %0"
     : "=r" (Index)
     : "r" (Mask)
     : "cc");
@end example

そのコードは変数@code{Index}（@samp{=}）を上書きし、その値をレジスタ（@ samp{r}）に入れる。特定のレジスタの制約の代わりに汎用の@samp{r}制約を使用すると、コンパイラは使用するレジスタを選択できるため、より効率的なコードが生成される。 アセンブラ命令で特定のレジスタが必要な場合、これは不可能である。

次のi386の例では、@var{asmSymbolicName}構文を使用している。上記のコードと同じ結果が得られるが、オペランドを追加または削除するときには、インデックス番号を並べ替える必要がないため、より読みやすく保守性が高いと考えるユーザーもいる。 @code{aIndex}と@code{aMask}という名前は、この例では、どの名前がどこで使用されるのか強調するためにのみ使用されている。@code{Index}と@code{Mask}という名前を再利用してもよい。

@example
uint32_t Mask = 1234;
uint32_t Index;

  asm ("bsfl %[aMask], %[aIndex]"
     : [aIndex] "=r" (Index)
     : [aMask] "r" (Mask)
     : "cc");
@end example

出力オペランドのいくつかの例を次に示す。

@example
uint32_t c = 1;
uint32_t d;
uint32_t *e = &c;

asm ("mov %[e], %[d]"
   : [d] "=rm" (d)
   : [e] "rm" (*e));
@end example

ここで、@code{d}はレジスタまたはメモリのどちらかにある。 コンパイラはすでにレジスタ内の@code{e}が指している@code{uint32_t}位置の現在の値をすでに持っている可能性があるので、両方の制約を指定することで@code{d}の最適な場所を選択できる。

@anchor{FlagOutputOperands}
@subsubsection フラグ出力オペランド
@cindex @code{asm} flag output operands

一部のターゲットには、操作または比較の結果の「フラグ」を保持する特別なレジスタがある。 通常、そのレジスタの内容はasmによって変更されないか、asmが内容を破壊するとみなされる。

いくつかのターゲットでは、flagsレジスタの条件をasmの出力とすることができる特別な形式の出力オペランドが存在する。 サポートされる条件のセットはターゲット固有だが、一般的なルールは出力変数がスカラー整数で、値はブール値でなければならない。サポートされている場合、ターゲットはプリプロセッサシンボル@code{__ GCC_ASM_FLAG_OUTPUTS__}を定義する。

フラグ出力オペランドの特別な性質のため、制約には代替が含まれてはならない。

ほとんどの場合、ターゲットにはフラグレジスタが1つしかないため、多くの命令の暗黙のオペランドになる。 この場合、アセンブリ言語に対応するテキストがないので、オペランドは@code{％0}などを介してアセンブラテンプレート内で参照されるべきではない。

@table @asis
@item x86ファミリ
x86ファミリのフラグ出力の制約は、@code {j@var{cond}}のISAマニュアルで定義されている標準条件の1つで、@var{cond}は@samp {=@@cc@var{cond}}または@code{set@var{cc}}を使用する。

@table @code
@item a
「上(above)」、すなわち符号なしのより大きい
@item ae
「上(above)及び等しい(equal)」、すなわち、符号なしの以上
@item b
「下(below)」すなわち符号なしの未満
@item be
「下(below)及び等しい(equal)」、すなわち、符号なしの以下
@item c
キャリーフラグセット
@item e
@itemx z
「等しい(equal)」、すなわちゼロフラグセット
@item g
符号ありのより大きい
@item ge
符号ありの以上
@item l
符号ありの未満
@item le
符号ありの以下
@item o
オーバーフローセット
@item p
パリティフラグセット
@item s
符号フラグセット
@item na
@itemx nae
@itemx nb
@itemx nbe
@itemx nc
@itemx ne
@itemx ng
@itemx nge
@itemx nl
@itemx nle
@itemx no
@itemx np
@itemx ns
@itemx nz
@var{flag}「でない(not)」、すなわち、上の逆バージョン
@end table

@end table

@anchor{InputOperands}
@subsubsection 入力オペランド
@cindex @code{asm} input operands
@cindex @code{asm} expressions

入力オペランドは、C変数および式から値をアセンブリコードで使用できるようにする。

オペランドはコンマで区切られる。 各オペランドは次の形式である。

@example
@r{[} [@var{asmSymbolicName}] @r{]} @var{constraint} (@var{cexpression})
@end example

@table @var
@item asmSymbolicName
オペランドのシンボリック名を指定する。アセンブラテンプレートの名前は、角括弧（@samp{％[Value]}）で囲んで参照する。名前のスコープは、定義を含む@code{asm}ステートメントである。 周囲のコードにすでに定義されている名前を含め、任意の有効なC変数名を使用できる。同じ@code{asm}ステートメント内に2つのオペランドが同じシンボリック名を使用することはできない。

@var{asmSymbolicName}を使用しないときは、アセンブラ・テンプレートのオペランドのリスト内のオペランドの（ゼロからの）位置を使用する。たとえば、2つの出力オペランドと3つの入力がある場合は、テンプレートの@samp{％2}を使用して最初の入力オペランドを参照し、@samp{％3}で2番目、@samp{％4}で3番目となる。

@item constraint
オペランドの配置に関する制約を指定する文字列定数。詳細は@xref{Constraints}を参照せよ。

入力制約文字列は、@samp{=}か@samp{+}で始まることはできない。可能な場所を複数指定すると（@samp{"irm"}など）、コンパイラは現在のコンテキストに基づいて最も効率的な場所を選択する。特定のレジスタを使用する必要があるにもかかわらず、Machine Constraintsが必要な特定のレジスタを選択するための十分な制御を提供しない場合、ローカルレジスタ変数が解決策を提供する。(@pxref{Local Register Variables}).

入力制約は、数字（たとえば、@code{"0"}）にもできる。これは、指定された入力が、出力制約リストの（ゼロベースの）インデックスの出力制約と同じ場所になければならないことを示す。出力オペランドに@var{asmSymbolicName}構文を使用する場合、数字の代わりにこれらの名前（大括弧@samp{[]}に囲まれた）を使用できる。

@item cexpression
これは、入力として@code{asm}ステートメントに渡されるC変数または式である。 囲み括弧は構文の必須部分である。

@end table

コンパイラが入力オペランドを表すために使用するレジスタを選択すると、clobberedレジスタ（@pxref{Clobbers}）は使用されない。

出力オペランドがないが入力オペランドがある場合は、出力オペランドが続くところに2つの連続するコロンを配置する。

@example
__asm__ ("some instructions"
   : /* No outputs. */
   : "r" (Offset / 8));
@end example

@strong{警告:} 入力専用オペランドの内容を変更しては@emph{_ならない_}（出力に接続された入力を除く）。コンパイラは、@code{asm}文を終了すると、これらのオペランドには文を実行する前と同じ値が含まれているとみなす。これらの入力値が変化していることをコンパイラーに知らせるためにクローバーを使用することはでき@emph{_ない_}。 1つの一般的な回避策は、変化する入力変数を決して使用されない出力変数に結びつけることである。 ただし、@code{asm}文に続くコードが出力オペランドを使用しない場合、GCCオプティマイザは@code{asm}ステートメントを不要として破棄することがある。(@ref{Volatile}を見よ。)

@code{asm}はオペランドのオペランド修飾子をサポートしている（例えば@samp{％2}の代わりに@samp{％k2}）。 通常、これらの修飾子はハードウェアに依存する。 x86でサポートされている修飾子のリストは、@ref{x86Operandmodifiers,x86 Operand modifiers}にある。

この例では、架空の@code{combine}命令を使用して、入力オペランド1の制約@code {"0"}は、出力オペランド0と同じ位置を占める必要があると示している。入力オペランドだけが制約内の数値を使用し、 それぞれが出力オペランドを参照する必要がある。 制約内の数字（またはシンボリックアセンブラ名）のみが、あるオペランドが別のオペランドと同じ場所にあることを保証できる。 @code{foo}が両方のオペランドの値であるという単なる事実は、それらが生成されたアセンブラコード内の同じ場所にあることを保証するには不十分である。

@example
asm ("combine %2, %0" 
   : "=r" (foo) 
   : "0" (foo), "g" (bar));
@end example

シンボリック名を使用した例を次に示す。

@example
asm ("cmoveq %1, %2, %[result]" 
   : [result] "=r"(result) 
   : "r" (test), "r" (new), "[result]" (old));
@end example

@anchor{Clobbers}
@subsubsection Clobber
@cindex @code{asm} clobbers

コンパイラは出力オペランドにリストされているエントリの変更を認識しているが、インラインの@code{asm}コードは出力以外を変更することがある。 たとえば、計算に追加のレジスタが必要な場合や、プロセッサが特定のアセンブラ命令の副作用としてレジスタを上書きする場合がある。コンパイラにこれらの変更を通知するには、それらをclobberリストに並べる。 clobberリスト項目は、レジスタ名または特殊Clobber（以下にリストされています）である。 各clobberリスト項目は、二重引用符で囲みコンマで区切られた文字列定数である。

clobber記述は、入力オペランドまたは出力オペランドと重複してはならない。 たとえば、clobberリストにそのレジスタをリストするときに、1つのメンバを持つレジスタクラスを記述するオペランドを持つことはできない。 特定のレジスタに存在すると宣言された変数（@pxref{Explicit Register Variables}）、@code{asm}の入力オペランドまたは出力オペランドとして使用する変数は、clobberの記述には何も記述することはできない。 特に、入力オペランドが出力オペランドとしても指定されていない状態では変更されるように指定する方法はない。

コンパイラは、入力および出力オペランドを表すために使用するレジスタを選択するとき、clobberedレジスタを使用しない。 その結果、アセンブラコード内での使用には、clobberedレジスタが使用できる。

VAXがclobberedレジスタの使用を示す現実的な例を次に示す。

@example
asm volatile ("movc3 %0, %1, %2"
                   : /* No outputs. */
                   : "g" (from), "g" (to), "g" (count)
                   : "r0", "r1", "r2", "r3", "r4", "r5");
@end example

また、特別なclobber引数が2つある。

@table @code
@item "cc"
@code{"cc"} clobberは、アセンブラコードがフラグレジスタを変更することを示す。 一部のマシンでは、GCCは条件コードを特定のハードウェアレジスタとして表す。 @code{"cc"}はこのレジスタの名前を指定する。他のマシンでは、条件コードの処理が異なり、@code{"cc"}を指定しても効果はない。 しかし、それはどんなターゲットであっても有効である。

@item "memory"
@code{"memory"} clobberは、アセンブラコードが入出力オペランドにリストされているもの以外のメモリ（例えば、入力パラメータの1つが指すメモリにアクセスする）への読み書きを実行することをコンパイラに伝える。メモリに正しい値が含まれていることを確認するために、GCCは@code{asm}を実行する前に特定のレジスタ値をメモリにフラッシュする必要がある。 さらに、コンパイラは、@code{asm}の前にメモリから読み込まれた値がその@code{asm}の後も変わらないと仮定しない。 必要に応じて再ロードする。@code{"memory"} clobberを使用すると、コンパイラの読み書き可能メモリバリアが効果的に形成される。

このclobberは、@emph{_プロセッサ_}が@code{asm}ステートメントより先に投機的な読み込みを行うことを妨げないことに注意せよ。 これを防ぐには、プロセッサ固有のフェンス命令が必要である。

メモリへのレジスタのフラッシュはパフォーマンスに影響を与え、時間に敏感なコードの問題となる可能性がある。 これを避けるためにトリックを使うことができる。 たとえば、文字列の10バイトにアクセスする場合は、次のようなメモリ入力を使用する。

@code{@{"m"( (@{ struct @{ char x[10]; @} *p = (void *)ptr ; *p; @}) )@}}.

@end table

@anchor{GotoLabels}
@subsubsection Gotoラベル
@cindex @code{asm} goto labels
@code{asm goto}はアセンブリコードを1つまたは複数のCラベルにジャンプさせることを可能にする。@code{asm goto}文の@var{GotoLabels}セクションには、アセンブラコードがジャンプするすべてのCラベルのコンマ区切りリストが含まれている。GCCは@code{asm}の実行が次の文に進むと仮定する（そうでない場合は、@code{__ builtin_unreachable}組み込み関数の使用を検討せよ）。@code{asm goto}の最適化は、@code{hot}と@code{cold}のラベル属性を使うことで改善されるかもしれない。(@pxref{Label Attributes}。)

@code{asm goto}文には出力がない。これは、コンパイラの内部制限によるものである。制御転送命令には出力がない。アセンブラコードが何かを変更する場合は、@code{"memory"} clobberを使用して、オプティマイザにすべてのレジスタ値をメモリにフラッシュさせ、必要に応じて@code{asm}文の後に再ロードする。

また、@code{asm goto}文は常に暗黙的にvolatileとみなされる。

アセンブラテンプレートのラベルを参照するには、@var{GotoLabels}に入力オペランドの数を加えた@samp{％l}（小文字@samp{L}）とその後ろに（ゼロベースの）位置を付ける。たとえば、@code{asm}に3つの入力があり、2つのラベルを参照する場合は、最初のラベルを@samp{％l3}、2番目のラベルを@samp{％l4}とする。

あるいは、カッコで囲まれた実際のCラベル名を使用してラベルを参照することもできる。 たとえば、@code{carry}という名前のラベルを参照するには、@samp{％l [carry]}を使用できる。 この方法を使用する場合でも、ラベルはまだ@var{GotoLabels}セクションにリストされていなければならない。

i386の@code {asm goto}の例を次に示す。

@example
asm goto (
    "btl %1, %0\n\t"
    "jc %l2"
    : /* No outputs. */
    : "r" (p1), "r" (p2) 
    : "cc" 
    : carry);

return 0;

carry:
return 1;
@end example

次の例は、メモリclobberを使用する@code {asm goto}を示している。

@example
int frob(int x)
@{
  int y;
  asm goto ("frob %%r5, %1; jc %l[error]; mov (%2), %%r5"
            : /* No outputs. */
            : "r"(x), "r"(&y)
            : "r5", "memory" 
            : error);
  return y;
error:
  return -1;
@}
@end example

@anchor{x86Operandmodifiers}
@subsubsection x86オペランド修正子

拡張された@code{asm}ステートメントのアセンブラテンプレートのinput、output、およびgotoオペランドへの参照は、修飾子を使用して、オペランドがコード出力の中でアセンブラにフォーマットされる方法に影響を与えることができる。 たとえば、次のコードでは、x86の@samp{h}および@samp{b}修飾子を使用している。

@example
uint16_t  num;
asm volatile ("xchg %h0, %b0" : "+a" (num) );
@end example

@noindent
これらの修飾子は、このアセンブラコードを生成する。

@example
xchg %ah, %al
@end example

この説明の残りの部分では、説明の目的で次のコードを使用する。

@example
int main()
@{
   int iInt = 1;

top:

   asm volatile goto ("some assembler instructions here"
   : /* No outputs. */
   : "q" (iInt), "X" (sizeof(unsigned char) + 1)
   : /* No clobbers. */
   : top);
@}
@end example

修飾子がない場合、アセンブラの@samp{att}と@samp{intel}の変種のオペランドからの出力は次のようになる。

@multitable {Operand} {$.L2} {OFFSET FLAT:.L2}
@headitem Operand @tab @samp{att} @tab @samp{intel}
@item @code{%0}
@tab @code{%eax}
@tab @code{eax}
@item @code{%1}
@tab @code{$2}
@tab @code{2}
@item @code{%2}
@tab @code{$.L2}
@tab @code{OFFSET FLAT:.L2}
@end multitable

下の表は、サポートされている修飾子のリストとその効果を示している。

@multitable {Modifier} {Print the opcode suffix for the size of th} {Operand} {@samp{att}} {@samp{intel}}
@headitem 修正子 @tab 説明 @tab Operand @tab @samp{att} @tab @samp{intel}
@item @code{z}
@tab 現在の整数オペランドのサイズのオペコード接尾辞を出力する (@code{b}/@code{w}/@code{l}/@code{q}のどれか)。
@tab @code{%z0}
@tab @code{l}
@tab 
@item @code{b}
@tab レジスタのQIモード名を出力する。
@tab @code{%b0}
@tab @code{%al}
@tab @code{al}
@item @code{h}
@tab 「上位」レジスタ用のQIモード名を出力する。.
@tab @code{%h0}
@tab @code{%ah}
@tab @code{ah}
@item @code{w}
@tab レジスタのHIモード名を出力する
@tab @code{%w0}
@tab @code{%ax}
@tab @code{ax}
@item @code{k}
@tab レジスタのSIモード名を出力する。
@tab @code{%k0}
@tab @code{%eax}
@tab @code{eax}
@item @code{q}
@tab レジスタのDIモード名を出力する
@tab @code{%q0}
@tab @code{%rax}
@tab @code{rax}
@item @code{l}
@tab 句読点なしでラベル名を出力する。
@tab @code{%l2}
@tab @code{.L2}
@tab @code{.L2}
@item @code{c}
@tab 定数オペランドを必要とし、定数式を句読点なしで出力する。
@tab @code{%c1}
@tab @code{2}
@tab @code{2}
@end multitable

@code{V}は、完全な整数レジスタの名前を@code{％}なしで出力する特別な修飾子である。

@anchor{x86floatingpointasmoperands}
@subsubsection x86浮動小数点@code{asm}オペランド

x86ターゲットでは、@code{asm}のオペランドにスタック型レジスタの使用法に関するいくつかの規則がある。 これらの規則は、スタック状のレジスタであるオペランドにのみ適用される。

@enumerate
@item
@code{asm}で死に至る入力レジスタのセットが与えられると、どれが暗黙的に@code{asm}によってポップされ、どれがGCCによって明示的にポップされなければならないことを知る必要がある。

@code{asm}によって暗黙的にポップされる入力レジスタは、出力オペランドと一致するように制約されない限り、明示的に破壊されなければならない。

@item
暗黙的に@code{asm}でポップされる入力レジスタの場合、ポップを補うためにスタックを調整する方法を知る必要がある。ポップされていない入力が暗黙的にポップされたレジスタよりもreg-stackの先頭に近い場合、スタックの外観を知ることはできない。スタックの残りの部分がどのように「滑り落ちる」かは不明瞭である。

すべての暗黙的にポップされた入力レジスタは、暗黙的にポップされていない入力よりもregスタックの先頭に近い必要がある。

入力が@code{asm}で終了した場合、コンパイラは出力リロードに入力レジスタを使用する可能性がある。 この例を考える。

@smallexample
asm ("foo" : "=t" (a) : "f" (b));
@end smallexample

@noindent
このコードは、入力@code{b}が@code{asm}によってポップされず、@code{asm}が結果をreg-stackにプッシュすると言う。つまり、スタックは@code{asm}以前のものよりも1段深くなっている。 しかし、リロードは入力と出力の両方に同じレジスタを使用できると考えることも可能である。

これを防ぐために、入力オペランドが@samp{f}制約を使用する場合、すべての出力レジスタ制約で@samp{&} early-clobber修飾子を使用する必要がある。

上記の例は以下のように正しく記述される：

@smallexample
asm ("foo" : "=&t" (a) : "f" (b));
@end smallexample

@item
いくつかのオペランドはスタック上の特定の場所にある必要がある。すべての出力オペランドはこのカテゴリに属す。GCCは、制約内でこれを指定しない限り、出力がどのレジスタに現れるかを知る他の方法はない。

出力オペランドは、出力が@code{asm}の後に現れるレジスタを具体的に示さなければならない。 @samp{= f}は許されない：オペランドの制約は、単一のレジスタを持つクラスを選択しなければならない。

@item
出力オペランドは、既存のスタックレジスタ間に「挿入」されないことがある。387オペコードは読取り/書込みオペランドを使用しないので、すべての出力オペランドは@code{asm}より前に死に、@code{asm}によってプッシュされる。regスタックの最上部以外の場所にプッシュするのは意味がない。

出力オペランドはreg-stackの先頭で始まらなければならない。出力オペランドはレジスタを「スキップ」しない。

@item
@code{asm}文の中には、内部計算のために余分なスタック領域が必要なものがある。 これは、入力と出力に無関係なスタックレジスタを壊すことによって保証される。

@end enumerate

この@code{asm}は内部的にポップされた1つの入力を受け取り、2つの出力を生成する。

@smallexample
asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));
@end smallexample

@noindent
この@code{asm}は2つの入力を受け取り、@code{fyl2xp1}オペコードでポップされ、1つの出力に置き換えらる。 コンパイラが@code{fyl2xp1}が両方の入力をポップすることを知るためには、@code{st(1)}clobberが必要である。


@smallexample
asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");
@end smallexample

@lowersections
@include md.texi
@raisesections

@node Asm Labels
@subsection アセンブラコードで使われる名前を制御する
@cindex assembler names for identifiers
@cindex names used in assembler code
@cindex identifiers, names in assembler code

宣言子の後ろに@code{asm}（または@code{__ asm__}）キーワードを書くことによって、C関数または変数のアセンブラコードで使用される名前を指定できる。選択したアセンブラ名が他のアセンブラシンボルまたは参照レジスタと競合しないようにすることは、あなたの責任である。

@subsubheading データ用のアセンブラ名

このサンプルは、データのアセンブラ名を指定する方法を示している。

@smallexample
int foo asm ("myfoo") = 2;
@end smallexample

@noindent
これは、アセンブラコードの変数@code {foo}に使用される名前が通常の@samp{_foo}ではなく@samp{myfoo}であることを指定する。

通常、アンダースコアがC変数の名前の前に付加されているシステムでは、この機能を使用して、アンダースコアで始まらないリンカーの名前を定義できる。GCCでは静的でないローカル変数は、アセンブラ名を持たないためにこの機能を使用することはサポートしていない。 変数を特定のレジスタに入れる場合は、@ref{Explicit Register Variables}を参照せよ。

@subsubheading 関数のアセンブラ名

関数のアセンブラ名を指定するには、その定義の前に関数の宣言を記述し、そこに@code{asm}を入れる。

@smallexample
int func (int x, int y) asm ("MYFUNC");
     
int func (int x, int y)
@{
   /* @r{@dots{}} */
@end smallexample

@noindent
これは、アセンブラコードの関数@code {func}に使用される名前が@code{MYFUNC}であることを指定する。

@node Explicit Register Variables
@subsection 指定されたレジスタでの変数
@anchor{Explicit Reg Vars}
@cindex explicit register variables
@cindex variables in specified registers
@cindex specified registers

GNU Cでは、特定のハードウェアレジスタをC変数に関連付けることができる。 ほとんどの場合、コンパイラにレジスタの割り当てを許可すると、最良のコードが生成される。 しかし、特殊な状況下では、可変記憶域をより正確に制御する必要がある。

グローバル変数とローカル変数の両方をレジスタに関連付けることができる。 この関連付けを実行することの結果は、以下のセクションで説明するように、2つの場合で大きく異なる。

@menu
* Global Register Variables::   グローバルスコープで宣言された変数。
* Local Register Variables::    関数内で宣言された変数。
@end menu

@node Global Register Variables
@subsubsection グローバルレジスタ変数の定義
@anchor{Global Reg Vars}
@cindex global register variables
@cindex registers, global variables in
@cindex registers, global allocation

このように、グローバルレジスタ変数を定義して指定されたレジスタと関連づけることができる。

@smallexample
register int *foo asm ("r12");
@end smallexample

@noindent
ここで@code{r12}は使用すべきレジスタの名前である。 これはローカルレジスタ変数を定義するのと同じ構文であることに注意せよ。しかし、グローバル変数の場合、宣言は関数の外に現れる。 @code{register}キーワードは必須で、@code{static}と組み合わせることはできない。 レジスタ名は、ターゲットプラットフォームの有効なレジスタ名でなければならない。

ほとんどのシステムではレジスタは貴重なリソースであり、コンパイラがその使用法を管理できるようにすることで、通常は最良のコードが得られる。 しかし、特別な状況の下では、グローバルにいくつかを確保することが理にかなっている。 例えば、これは非常に頻繁にアクセスされる2つのグローバル変数を持つプログラミング言語インタープリタのようなプログラムで有用かもしれない。

現在のコンパイル単位のグローバルレジスタ変数を定義した後は、次のようになる。

@itemize @bullet
@item この使用のためにレジスタは完全に予約されており、他の目的では割り当てられない。
@item このレジスタは、どの関数機能によっても保存・復元されない。
@item このレジスタへのストアは、たとえ死んでいるように見えても決して削除されないが、参照は削除、移動、または簡略化されるかもしれない。
@end itemize

これらの点は、定義でコンパイルされたコードに@emph{_のみ_}適用される。 単にリンクされているコード（例えば、ライブラリのコード）の動作は影響を受けない。

グローバルレジスタ変数を実際に使用していないソースファイルを再コンパイルして、他の目的に使用しないようにするには、ソースコードにグローバルレジスタ宣言を実際に追加する必要はない。 レジスタを予約するには、コンパイラオプション@option{-ffixed-@var{reg}}（@pxref{Code Gen Options}）を指定するだけで十分である。

@subsubheading 変数の宣言

実行可能ファイルにはレジスタの初期内容を提供する手段がないため、グローバルレジスタ変数は初期値を持つことはできない。

レジスタを選択するときは、通常は保存され、マシン上の関数呼び出しによって復元されたものを選択する。 これにより、この予約を知らないコード（ライブラリルーチンなど）は、復帰前に復元される。

レジスタウィンドウを持つマシンでは、関数呼び出しメカニズムによって魔法の影響を受けないグローバルレジスタを選択すること。

@subsubheading Using the variable

@cindex @code{qsort}, and global register variables
予約を認識していないルーチンを呼び出すときは、それらのルーチンがそれらを使用するコードにコールバックするかどうかに注意せよ。 例えば、@code{qsort}のシステムライブラリバージョンを呼び出すと、実行中にレジスタが壊れる可能性があるが、適切なレジスタを選択した場合は、復帰前に復元される。 しかし、@code{qsort}の比較関数を呼び出す前にそれらを復元し@emph{_ない_}。 その結果、@code{qsort}関数自体が再構築されない限り、グローバル関数の値は比較関数で確実に利用できなくなる。

同様に、シグナルハンドラや複数の制御スレッドからグローバルレジスタ変数にアクセスすることは安全ではない。 手元のタスクのためにそれらを特別に再コンパイルしない限り、システムライブラリルーチンは他のもののために一時的にレジスタを使用するかもしれない。

@cindex register variable after @code{longjmp}
@cindex global register after @code{longjmp}
@cindex value after @code{longjmp}
@findex longjmp
@findex setjmp
ほとんどのマシンでは、@code{longjmp}は@code{setjmp}の時に持っていた値を各グローバルレジスタ変数に復元する。 しかし、一部のマシンでは、@code{longjmp}はグローバルレジスタ変数の値を変更しない。 移植性を持たせるために、@code{setjmp}を呼び出した関数は、グローバルレジスタ変数の値を保存し、それらを@code{longjmp}に復元するための他の準備をしなければならない。 このようにして、@code{longjmp}とは関係なく同じことが起こります。

最終的にコンパイラに自動的にレジスタを選択させる方法があるかもしれないが、最初に選択方法と選択方法を導き出す方法を理解する必要がある。 解決策は明らかではない。

@node Local Register Variables
@subsubsection ローカル変数用のレジスタを指定する
@anchor{Local Reg Vars}
@cindex local variables, specifying registers
@cindex specifying registers for local variables
@cindex registers for local variables

ローカルレジスタ変数を定義し、次のように指定されたレジスタに関連付けることができる：

@smallexample
register int *foo asm ("r12");
@end smallexample

@noindent
ここで@code{r12}は使用すべきレジスタの名前である。これはグローバルレジスタ変数の定義と同じ構文だが、ローカル変数の場合は宣言が関数内に表示される。 @code{register}キーワードは必須で、@code{static}と組み合わせることはできない。 レジスタ名は、ターゲットプラットフォームの有効なレジスタ名でなければならない。

グローバルレジスタ変数の場合と同様に、通常は保存され、マシン上の関数呼び出しによってリストアされるレジスタを選択することを推奨する。これにより、ライブラリルーチンへの呼び出しがそれを壊さないようにする。

この機能で唯一サポートされているのは、Extended @code{asm}（@pxref {Extended Asm}）を呼び出すときに入力オペランドと出力オペランドのためのレジスタを指定することである。 これは、特定の機械に対する制約が所望のレジスタを選択するのに十分な制御を提供しない場合に必要となることがある。 オペランドを強制的にレジスタに入れるには、ローカル変数を作成し、その変数の宣言の後にレジスタ名を指定する。 次に、@code{asm}オペランドにローカル変数を使用し、レジスタと一致する制約文字を指定する。

@smallexample
register int *p1 asm ("r0") = @dots{};
register int *p2 asm ("r1") = @dots{};
register int *result asm ("r0");
asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));
@end smallexample

@emph{_警告_:} 上記の例では、関数呼び出しと他の変数の算術演算子のライブラリ呼び出し（例えば、@code{p2}の初期化などを含む、後続のコードによってレジスタ（たとえば@code{r0}）を呼び出すことができることに注意せよ）。 この場合、レジスタ割り当て間の式には一時変数を使用する。

@smallexample
int t1 = @dots{};
register int *p1 asm ("r0") = @dots{};
register int *p2 asm ("r1") = t1;
register int *result asm ("r0");
asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));
@end smallexample

レジスタ変数を定義しても、レジスタは予約されない。 拡張@code{asm}を呼び出すとき以外は、指定されたレジスタの内容は保証されない。 このため、以下の用途は明示的にに対応してい@emph{_ない_}。 動作しているように見える場合は偶然であり、周辺コードの（一見）関連のない変更、またはgccの将来のバージョンの最適化におけるマイナーな変更のために意図したとおりに動作を停止する可能性がある。

@itemize @bullet
@item 基本@code{asm}とのパラメータのやり取り
@item 入力・出力オペランドを使わずに拡張@code{asm}とのパラメータのやり取り
@item 非標準の呼び出し規約を使ったアセンブラ（及び他の言語）で書かれたルーチンとのパラメータのやり取り
@end itemize

いくつかの開発者は、gccのレジスタの割り当てを改善するために、特に大きな関数でローカルレジスタ変数を使用する。 この場合、レジスタ名は基本的にレジスタアロケータのヒントになる。場合によってはより良いコードを生成することができるが、改善はアロケータ/オプティマイザの気まぐれに左右される。あなたの改善が失われないという保証はないので、このローカルレジスタ変数の使用は推奨しない。

MIPSプラットフォームでは、特性が少し異なるローカルレジスタ変数（@pxref {MIPS CoprocessorsDefining coprocessor specifics for MIPS targets, gccint, 
GNU Compiler Collection (GCC) Internals}）に関連する用途がある。

@node Size of an asm
@subsection @code{asm}のサイズ

ターゲットによっては、GCCが正しいコードを生成するために使用される各命令のサイズを追跡する必要がある。 @code{asm}ステートメントで生成されるコードの最終的な長さはアセンブラでしか認識されないため、GCCはどれくらいの大きさになるかについての見積もりを行う必要がある。 これは、@code{asm}のパターンで命令の数を数え、そのプロセッサでサポートされている最長命令の長さで乗算することで行う。 （命令数を試してみると、改行やアセンブラでサポートされている文の区切り文字（通常@samp {;} ---）があれば、命令の終わりを示しているとみなされる。

通常、正しいコードが生成されるようにGCCの見積もりは適切だが、複数の実命令に展開する擬似命令またはアセンブラマクロを使用する場合、単一の命令で必要とされるよりも多くのオブジェクトファイル内の領域に展開するアセンブラディレクティブを使用する場合、コンパイラを混乱させる可能性がある。この場合、アセンブラはラベルに到達できないという診断を生成することがある。

@node Alternate Keywords
@section 代替キーワード
@cindex alternate keywords
@cindex keywords, alternate

@option {-ansi}とさまざまな@option {-std}オプションは、特定のキーワードを無効にする。 これは、GNU C拡張、またはISO Cプログラムを含むすべてのプログラムで使用可能な汎用ヘッダファイルを使用するときに問題を引き起こす。 @option{-ansi}または@option{-std}でコンパイルされたプログラムでは、キーワード@code{asm}、@code{typeof}と@code{inline}は使用できない（ただし、@code{inline}は @option{-std=c99}または@option{-std=c11}でコンパイルされたプログラムでは使用できる）。 ISO C99キーワード@code{restrict}は、@option{-std=gnu99}（結局はデフォルトである）または@option{-std=c99}（または同等の@option{-std=iso9899:1999}）以降の標準のオプションバージョンが使用されるときだけ利用可能である。

これらの問題を解決する方法は、各問題のキーワードの先頭と最後に@samp {__}を入れることである。 たとえば、@code{asm}ではなく@code{__ asm__}を使用し、@code{inline}ではなく@code{__ inline__}を使用する。

他のCコンパイラはこれらの代替キーワードを受け入れない。 別のコンパイラでコンパイルする場合は、代替キーワードをマクロとして定義して、通常のキーワードと置き換えることができる。 これは次のようになる。

@smallexample
#ifndef __GNUC__
#define __asm__ asm
#endif
@end smallexample

@findex __extension__
@opindex pedantic
@option{-pedantic}と他のオプションは、多くのGNU C拡張の警告を引き起こす。式の前に@code{__extension__}を書くことで、そのような警告を防ぐことができる。 @code{__extension__}はこれとは別に何の効果もない。

@node Incomplete Enums
@section 不完全@code{enum}型

可能な値を指定せずに@code {enum}タグを定義することができる。これは要素を記述せずに@code{struct foo}を書くと非常に似ている、不完全な型になる。 可能な値を指定する後の宣言は型を完成させる。

変数が不完全な場合は、型を使用して変数または記憶域を割り当てることはできない。 ただし、その型へのポインタで作業することはできる。

この拡張はそれほど有用ではないかもしれないが、@code{struct}と@code{union}の扱い方と@code{enum}の扱いがより一貫している。

この拡張はGNU C ++ではサポートされていない。

@node Function Names
@section 文字列としての関数名
@cindex @code{__func__} identifier
@cindex @code{__FUNCTION__} identifier
@cindex @code{__PRETTY_FUNCTION__} identifier

GCCは現在の関数の名前を文字列として保持する3つのマジック定数を提供する。 C++11以降のモードでは、3つすべてが定数式として扱われ、@code{constexpr}文脈で使用できる。これらの定数の最初のものはC99標準の一部である@code{__ func__}である：

識別子@code{__ func__}は、各関数定義の開始中括弧の直後に宣言

@smallexample
static const char __func__[] = "function-name";
@end smallexample

@noindent
が出現した場合と同様に、トランスレータによって暗黙的に宣言される。function-nameは字句を囲む関数の名前である。 この名前は、機能の未装飾の名前である。 拡張として、ファイル（または、C++では名前空間の）スコープで、@code{__func__}は空の文字列を評価する。

@code{__FUNCTION__}は、GCCの旧バージョンとの下位互換性のために提供されている@code {__func__}の別の名前である。

Cでは、@code{__PRETTY_FUNCTION__}は、ファイル（またはC ++では名前空間の）スコープで@code {"top level"}という文字列になる点を除いて、@code{__func__}のもう一つの名前である。さらに、C++では、@code{__PRETTY_FUNCTION__}には関数の署名とその裸の名前が含まれている。 たとえば、次のプログラム：

@smallexample
extern "C" int printf (const char *, ...);

class a @{
 public:
  void sub (int i)
    @{
      printf ("__FUNCTION__ = %s\n", __FUNCTION__);
      printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
    @}
@};

int
main (void)
@{
  a ax;
  ax.sub (0);
  return 0;
@}
@end smallexample

@noindent
は以下を出力する。

@smallexample
__FUNCTION__ = sub
__PRETTY_FUNCTION__ = void a::sub(int)
@end smallexample

これらの識別子はプリプロセッサマクロではなく変数であり、@code{char}配列の初期化や文字列リテラルとの連結には使用できない。

@node Return Address
@section Getting the Return or Frame Address of a Function

These functions may be used to get information about the callers of a
function.

@deftypefn {Built-in Function} {void *} __builtin_return_address (unsigned int @var{level})
This function returns the return address of the current function, or of
one of its callers.  The @var{level} argument is number of frames to
scan up the call stack.  A value of @code{0} yields the return address
of the current function, a value of @code{1} yields the return address
of the caller of the current function, and so forth.  When inlining
the expected behavior is that the function returns the address of
the function that is returned to.  To work around this behavior use
the @code{noinline} function attribute.

The @var{level} argument must be a constant integer.

On some machines it may be impossible to determine the return address of
any function other than the current one; in such cases, or when the top
of the stack has been reached, this function returns @code{0} or a
random value.  In addition, @code{__builtin_frame_address} may be used
to determine if the top of the stack has been reached.

Additional post-processing of the returned value may be needed, see
@code{__builtin_extract_return_addr}.

Calling this function with a nonzero argument can have unpredictable
effects, including crashing the calling program.  As a result, calls
that are considered unsafe are diagnosed when the @option{-Wframe-address}
option is in effect.  Such calls should only be made in debugging
situations.
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_extract_return_addr (void *@var{addr})
The address as returned by @code{__builtin_return_address} may have to be fed
through this function to get the actual encoded address.  For example, on the
31-bit S/390 platform the highest bit has to be masked out, or on SPARC
platforms an offset has to be added for the true next instruction to be
executed.

If no fixup is needed, this function simply passes through @var{addr}.
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_frob_return_address (void *@var{addr})
This function does the reverse of @code{__builtin_extract_return_addr}.
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_frame_address (unsigned int @var{level})
This function is similar to @code{__builtin_return_address}, but it
returns the address of the function frame rather than the return address
of the function.  Calling @code{__builtin_frame_address} with a value of
@code{0} yields the frame address of the current function, a value of
@code{1} yields the frame address of the caller of the current function,
and so forth.

The frame is the area on the stack that holds local variables and saved
registers.  The frame address is normally the address of the first word
pushed on to the stack by the function.  However, the exact definition
depends upon the processor and the calling convention.  If the processor
has a dedicated frame pointer register, and the function has a frame,
then @code{__builtin_frame_address} returns the value of the frame
pointer register.

On some machines it may be impossible to determine the frame address of
any function other than the current one; in such cases, or when the top
of the stack has been reached, this function returns @code{0} if
the first frame pointer is properly initialized by the startup code.

Calling this function with a nonzero argument can have unpredictable
effects, including crashing the calling program.  As a result, calls
that are considered unsafe are diagnosed when the @option{-Wframe-address}
option is in effect.  Such calls should only be made in debugging
situations.
@end deftypefn

@node Vector Extensions
@section Using Vector Instructions through Built-in Functions

On some targets, the instruction set contains SIMD vector instructions which
operate on multiple values contained in one large register at the same time.
For example, on the x86 the MMX, 3DNow!@: and SSE extensions can be used
this way.

The first step in using these extensions is to provide the necessary data
types.  This should be done using an appropriate @code{typedef}:

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));
@end smallexample

@noindent
The @code{int} type specifies the base type, while the attribute specifies
the vector size for the variable, measured in bytes.  For example, the
declaration above causes the compiler to set the mode for the @code{v4si}
type to be 16 bytes wide and divided into @code{int} sized units.  For
a 32-bit @code{int} this means a vector of 4 units of 4 bytes, and the
corresponding mode of @code{foo} is @acronym{V4SI}.

The @code{vector_size} attribute is only applicable to integral and
float scalars, although arrays, pointers, and function return values
are allowed in conjunction with this construct. Only sizes that are
a power of two are currently allowed.

All the basic integer types can be used as base types, both as signed
and as unsigned: @code{char}, @code{short}, @code{int}, @code{long},
@code{long long}.  In addition, @code{float} and @code{double} can be
used to build floating-point vector types.

Specifying a combination that is not valid for the current architecture
causes GCC to synthesize the instructions using a narrower mode.
For example, if you specify a variable of type @code{V4SI} and your
architecture does not allow for this specific SIMD type, GCC
produces code that uses 4 @code{SIs}.

The types defined in this manner can be used with a subset of normal C
operations.  Currently, GCC allows using the following operators
on these types: @code{+, -, *, /, unary minus, ^, |, &, ~, %}@.

The operations behave like C++ @code{valarrays}.  Addition is defined as
the addition of the corresponding elements of the operands.  For
example, in the code below, each of the 4 elements in @var{a} is
added to the corresponding 4 elements in @var{b} and the resulting
vector is stored in @var{c}.

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a, b, c;

c = a + b;
@end smallexample

Subtraction, multiplication, division, and the logical operations
operate in a similar manner.  Likewise, the result of using the unary
minus or complement operators on a vector type is a vector whose
elements are the negative or complemented values of the corresponding
elements in the operand.

It is possible to use shifting operators @code{<<}, @code{>>} on
integer-type vectors. The operation is defined as following: @code{@{a0,
a1, @dots{}, an@} >> @{b0, b1, @dots{}, bn@} == @{a0 >> b0, a1 >> b1,
@dots{}, an >> bn@}}@. Vector operands must have the same number of
elements. 

For convenience, it is allowed to use a binary vector operation
where one operand is a scalar. In that case the compiler transforms
the scalar operand into a vector where each element is the scalar from
the operation. The transformation happens only if the scalar could be
safely converted to the vector-element type.
Consider the following code.

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a, b, c;
long l;

a = b + 1;    /* a = b + @{1,1,1,1@}; */
a = 2 * b;    /* a = @{2,2,2,2@} * b; */

a = l + a;    /* Error, cannot convert long to int. */
@end smallexample

Vectors can be subscripted as if the vector were an array with
the same number of elements and base type.  Out of bound accesses
invoke undefined behavior at run time.  Warnings for out of bound
accesses for vector subscription can be enabled with
@option{-Warray-bounds}.

Vector comparison is supported with standard comparison
operators: @code{==, !=, <, <=, >, >=}. Comparison operands can be
vector expressions of integer-type or real-type. Comparison between
integer-type vectors and real-type vectors are not supported.  The
result of the comparison is a vector of the same width and number of
elements as the comparison operands with a signed integral element
type.

Vectors are compared element-wise producing 0 when comparison is false
and -1 (constant of the appropriate type where all bits are set)
otherwise. Consider the following example.

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a = @{1,2,3,4@};
v4si b = @{3,2,1,4@};
v4si c;

c = a >  b;     /* The result would be @{0, 0,-1, 0@}  */
c = a == b;     /* The result would be @{0,-1, 0,-1@}  */
@end smallexample

In C++, the ternary operator @code{?:} is available. @code{a?b:c}, where
@code{b} and @code{c} are vectors of the same type and @code{a} is an
integer vector with the same number of elements of the same size as @code{b}
and @code{c}, computes all three arguments and creates a vector
@code{@{a[0]?b[0]:c[0], a[1]?b[1]:c[1], @dots{}@}}.  Note that unlike in
OpenCL, @code{a} is thus interpreted as @code{a != 0} and not @code{a < 0}.
As in the case of binary operations, this syntax is also accepted when
one of @code{b} or @code{c} is a scalar that is then transformed into a
vector. If both @code{b} and @code{c} are scalars and the type of
@code{true?b:c} has the same size as the element type of @code{a}, then
@code{b} and @code{c} are converted to a vector type whose elements have
this type and with the same number of elements as @code{a}.

In C++, the logic operators @code{!, &&, ||} are available for vectors.
@code{!v} is equivalent to @code{v == 0}, @code{a && b} is equivalent to
@code{a!=0 & b!=0} and @code{a || b} is equivalent to @code{a!=0 | b!=0}.
For mixed operations between a scalar @code{s} and a vector @code{v},
@code{s && v} is equivalent to @code{s?v!=0:0} (the evaluation is
short-circuit) and @code{v && s} is equivalent to @code{v!=0 & (s?-1:0)}.

@findex __builtin_shuffle
Vector shuffling is available using functions
@code{__builtin_shuffle (vec, mask)} and
@code{__builtin_shuffle (vec0, vec1, mask)}.
Both functions construct a permutation of elements from one or two
vectors and return a vector of the same type as the input vector(s).
The @var{mask} is an integral vector with the same width (@var{W})
and element count (@var{N}) as the output vector.

The elements of the input vectors are numbered in memory ordering of
@var{vec0} beginning at 0 and @var{vec1} beginning at @var{N}.  The
elements of @var{mask} are considered modulo @var{N} in the single-operand
case and modulo @math{2*@var{N}} in the two-operand case.

Consider the following example,

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a = @{1,2,3,4@};
v4si b = @{5,6,7,8@};
v4si mask1 = @{0,1,1,3@};
v4si mask2 = @{0,4,2,5@};
v4si res;

res = __builtin_shuffle (a, mask1);       /* res is @{1,2,2,4@}  */
res = __builtin_shuffle (a, b, mask2);    /* res is @{1,5,3,6@}  */
@end smallexample

Note that @code{__builtin_shuffle} is intentionally semantically
compatible with the OpenCL @code{shuffle} and @code{shuffle2} functions.

You can declare variables and use them in function calls and returns, as
well as in assignments and some casts.  You can specify a vector type as
a return type for a function.  Vector types can also be used as function
arguments.  It is possible to cast from one vector type to another,
provided they are of the same size (in fact, you can also cast vectors
to and from other datatypes of the same size).

You cannot operate between vectors of different lengths or different
signedness without a cast.

@node Offsetof
@section Support for @code{offsetof}
@findex __builtin_offsetof

GCC implements for both C and C++ a syntactic extension to implement
the @code{offsetof} macro.

@smallexample
primary:
        "__builtin_offsetof" "(" @code{typename} "," offsetof_member_designator ")"

offsetof_member_designator:
          @code{identifier}
        | offsetof_member_designator "." @code{identifier}
        | offsetof_member_designator "[" @code{expr} "]"
@end smallexample

This extension is sufficient such that

@smallexample
#define offsetof(@var{type}, @var{member})  __builtin_offsetof (@var{type}, @var{member})
@end smallexample

@noindent
is a suitable definition of the @code{offsetof} macro.  In C++, @var{type}
may be dependent.  In either case, @var{member} may consist of a single
identifier, or a sequence of member accesses and array references.

@node __sync Builtins
@section Legacy @code{__sync} Built-in Functions for Atomic Memory Access

The following built-in functions
are intended to be compatible with those described
in the @cite{Intel Itanium Processor-specific Application Binary Interface},
section 7.4.  As such, they depart from normal GCC practice by not using
the @samp{__builtin_} prefix and also by being overloaded so that they
work on multiple types.

The definition given in the Intel documentation allows only for the use of
the types @code{int}, @code{long}, @code{long long} or their unsigned
counterparts.  GCC allows any scalar type that is 1, 2, 4 or 8 bytes in
size other than the C type @code{_Bool} or the C++ type @code{bool}.
Operations on pointer arguments are performed as if the operands were
of the @code{uintptr_t} type.  That is, they are not scaled by the size
of the type to which the pointer points.

These functions are implemented in terms of the @samp{__atomic}
builtins (@pxref{__atomic Builtins}).  They should not be used for new
code which should use the @samp{__atomic} builtins instead.

Not all operations are supported by all target processors.  If a particular
operation cannot be implemented on the target processor, a warning is
generated and a call to an external function is generated.  The external
function carries the same name as the built-in version,
with an additional suffix
@samp{_@var{n}} where @var{n} is the size of the data type.

@c ??? Should we have a mechanism to suppress this warning?  This is almost
@c useful for implementing the operation under the control of an external
@c mutex.

In most cases, these built-in functions are considered a @dfn{full barrier}.
That is,
no memory operand is moved across the operation, either forward or
backward.  Further, instructions are issued as necessary to prevent the
processor from speculating loads across the operation and from queuing stores
after the operation.

All of the routines are described in the Intel documentation to take
``an optional list of variables protected by the memory barrier''.  It's
not clear what is meant by that; it could mean that @emph{only} the
listed variables are protected, or it could mean a list of additional
variables to be protected.  The list is ignored by GCC which treats it as
empty.  GCC interprets an empty list as meaning that all globally
accessible variables should be protected.

@table @code
@item @var{type} __sync_fetch_and_add (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_sub (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_or (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_and (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_xor (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_nand (@var{type} *ptr, @var{type} value, ...)
@findex __sync_fetch_and_add
@findex __sync_fetch_and_sub
@findex __sync_fetch_and_or
@findex __sync_fetch_and_and
@findex __sync_fetch_and_xor
@findex __sync_fetch_and_nand
These built-in functions perform the operation suggested by the name, and
returns the value that had previously been in memory.  That is, operations
on integer operands have the following semantics.  Operations on pointer
arguments are performed as if the operands were of the @code{uintptr_t}
type.  That is, they are not scaled by the size of the type to which
the pointer points.

@smallexample
@{ tmp = *ptr; *ptr @var{op}= value; return tmp; @}
@{ tmp = *ptr; *ptr = ~(tmp & value); return tmp; @}   // nand
@end smallexample

The object pointed to by the first argument must be of integer or pointer
type.  It must not be a boolean type.

@emph{Note:} GCC 4.4 and later implement @code{__sync_fetch_and_nand}
as @code{*ptr = ~(tmp & value)} instead of @code{*ptr = ~tmp & value}.

@item @var{type} __sync_add_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_sub_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_or_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_and_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_xor_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_nand_and_fetch (@var{type} *ptr, @var{type} value, ...)
@findex __sync_add_and_fetch
@findex __sync_sub_and_fetch
@findex __sync_or_and_fetch
@findex __sync_and_and_fetch
@findex __sync_xor_and_fetch
@findex __sync_nand_and_fetch
These built-in functions perform the operation suggested by the name, and
return the new value.  That is, operations on integer operands have
the following semantics.  Operations on pointer operands are performed as
if the operand's type were @code{uintptr_t}.

@smallexample
@{ *ptr @var{op}= value; return *ptr; @}
@{ *ptr = ~(*ptr & value); return *ptr; @}   // nand
@end smallexample

The same constraints on arguments apply as for the corresponding
@code{__sync_op_and_fetch} built-in functions.

@emph{Note:} GCC 4.4 and later implement @code{__sync_nand_and_fetch}
as @code{*ptr = ~(*ptr & value)} instead of
@code{*ptr = ~*ptr & value}.

@item bool __sync_bool_compare_and_swap (@var{type} *ptr, @var{type} oldval, @var{type} newval, ...)
@itemx @var{type} __sync_val_compare_and_swap (@var{type} *ptr, @var{type} oldval, @var{type} newval, ...)
@findex __sync_bool_compare_and_swap
@findex __sync_val_compare_and_swap
These built-in functions perform an atomic compare and swap.
That is, if the current
value of @code{*@var{ptr}} is @var{oldval}, then write @var{newval} into
@code{*@var{ptr}}.

The ``bool'' version returns true if the comparison is successful and
@var{newval} is written.  The ``val'' version returns the contents
of @code{*@var{ptr}} before the operation.

@item __sync_synchronize (...)
@findex __sync_synchronize
This built-in function issues a full memory barrier.

@item @var{type} __sync_lock_test_and_set (@var{type} *ptr, @var{type} value, ...)
@findex __sync_lock_test_and_set
This built-in function, as described by Intel, is not a traditional test-and-set
operation, but rather an atomic exchange operation.  It writes @var{value}
into @code{*@var{ptr}}, and returns the previous contents of
@code{*@var{ptr}}.

Many targets have only minimal support for such locks, and do not support
a full exchange operation.  In this case, a target may support reduced
functionality here by which the @emph{only} valid value to store is the
immediate constant 1.  The exact value actually stored in @code{*@var{ptr}}
is implementation defined.

This built-in function is not a full barrier,
but rather an @dfn{acquire barrier}.
This means that references after the operation cannot move to (or be
speculated to) before the operation, but previous memory stores may not
be globally visible yet, and previous memory loads may not yet be
satisfied.

@item void __sync_lock_release (@var{type} *ptr, ...)
@findex __sync_lock_release
This built-in function releases the lock acquired by
@code{__sync_lock_test_and_set}.
Normally this means writing the constant 0 to @code{*@var{ptr}}.

This built-in function is not a full barrier,
but rather a @dfn{release barrier}.
This means that all previous memory stores are globally visible, and all
previous memory loads have been satisfied, but following memory reads
are not prevented from being speculated to before the barrier.
@end table

@node __atomic Builtins
@section Built-in Functions for Memory Model Aware Atomic Operations

The following built-in functions approximately match the requirements
for the C++11 memory model.  They are all
identified by being prefixed with @samp{__atomic} and most are
overloaded so that they work with multiple types.

These functions are intended to replace the legacy @samp{__sync}
builtins.  The main difference is that the memory order that is requested
is a parameter to the functions.  New code should always use the
@samp{__atomic} builtins rather than the @samp{__sync} builtins.

Note that the @samp{__atomic} builtins assume that programs will
conform to the C++11 memory model.  In particular, they assume
that programs are free of data races.  See the C++11 standard for
detailed requirements.

The @samp{__atomic} builtins can be used with any integral scalar or
pointer type that is 1, 2, 4, or 8 bytes in length.  16-byte integral
types are also allowed if @samp{__int128} (@pxref{__int128}) is
supported by the architecture.

The four non-arithmetic functions (load, store, exchange, and 
compare_exchange) all have a generic version as well.  This generic
version works on any data type.  It uses the lock-free built-in function
if the specific data type size makes that possible; otherwise, an
external call is left to be resolved at run time.  This external call is
the same format with the addition of a @samp{size_t} parameter inserted
as the first parameter indicating the size of the object being pointed to.
All objects must be the same size.

There are 6 different memory orders that can be specified.  These map
to the C++11 memory orders with the same names, see the C++11 standard
or the @uref{http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync,GCC wiki
on atomic synchronization} for detailed definitions.  Individual
targets may also support additional memory orders for use on specific
architectures.  Refer to the target documentation for details of
these.

An atomic operation can both constrain code motion and
be mapped to hardware instructions for synchronization between threads
(e.g., a fence).  To which extent this happens is controlled by the
memory orders, which are listed here in approximately ascending order of
strength.  The description of each memory order is only meant to roughly
illustrate the effects and is not a specification; see the C++11
memory model for precise semantics.

@table  @code
@item __ATOMIC_RELAXED
Implies no inter-thread ordering constraints.
@item __ATOMIC_CONSUME
This is currently implemented using the stronger @code{__ATOMIC_ACQUIRE}
memory order because of a deficiency in C++11's semantics for
@code{memory_order_consume}.
@item __ATOMIC_ACQUIRE
Creates an inter-thread happens-before constraint from the release (or
stronger) semantic store to this acquire load.  Can prevent hoisting
of code to before the operation.
@item __ATOMIC_RELEASE
Creates an inter-thread happens-before constraint to acquire (or stronger)
semantic loads that read from this release store.  Can prevent sinking
of code to after the operation.
@item __ATOMIC_ACQ_REL
Combines the effects of both @code{__ATOMIC_ACQUIRE} and
@code{__ATOMIC_RELEASE}.
@item __ATOMIC_SEQ_CST
Enforces total ordering with all other @code{__ATOMIC_SEQ_CST} operations.
@end table

Note that in the C++11 memory model, @emph{fences} (e.g.,
@samp{__atomic_thread_fence}) take effect in combination with other
atomic operations on specific memory locations (e.g., atomic loads);
operations on specific memory locations do not necessarily affect other
operations in the same way.

Target architectures are encouraged to provide their own patterns for
each of the atomic built-in functions.  If no target is provided, the original
non-memory model set of @samp{__sync} atomic built-in functions are
used, along with any required synchronization fences surrounding it in
order to achieve the proper behavior.  Execution in this case is subject
to the same restrictions as those built-in functions.

If there is no pattern or mechanism to provide a lock-free instruction
sequence, a call is made to an external routine with the same parameters
to be resolved at run time.

When implementing patterns for these built-in functions, the memory order
parameter can be ignored as long as the pattern implements the most
restrictive @code{__ATOMIC_SEQ_CST} memory order.  Any of the other memory
orders execute correctly with this memory order but they may not execute as
efficiently as they could with a more appropriate implementation of the
relaxed requirements.

Note that the C++11 standard allows for the memory order parameter to be
determined at run time rather than at compile time.  These built-in
functions map any run-time value to @code{__ATOMIC_SEQ_CST} rather
than invoke a runtime library call or inline a switch statement.  This is
standard compliant, safe, and the simplest approach for now.

The memory order parameter is a signed int, but only the lower 16 bits are
reserved for the memory order.  The remainder of the signed int is reserved
for target use and should be 0.  Use of the predefined atomic values
ensures proper usage.

@deftypefn {Built-in Function} @var{type} __atomic_load_n (@var{type} *ptr, int memorder)
This built-in function implements an atomic load operation.  It returns the
contents of @code{*@var{ptr}}.

The valid memory order variants are
@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, @code{__ATOMIC_ACQUIRE},
and @code{__ATOMIC_CONSUME}.

@end deftypefn

@deftypefn {Built-in Function} void __atomic_load (@var{type} *ptr, @var{type} *ret, int memorder)
This is the generic version of an atomic load.  It returns the
contents of @code{*@var{ptr}} in @code{*@var{ret}}.

@end deftypefn

@deftypefn {Built-in Function} void __atomic_store_n (@var{type} *ptr, @var{type} val, int memorder)
This built-in function implements an atomic store operation.  It writes 
@code{@var{val}} into @code{*@var{ptr}}.  

The valid memory order variants are
@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, and @code{__ATOMIC_RELEASE}.

@end deftypefn

@deftypefn {Built-in Function} void __atomic_store (@var{type} *ptr, @var{type} *val, int memorder)
This is the generic version of an atomic store.  It stores the value
of @code{*@var{val}} into @code{*@var{ptr}}.

@end deftypefn

@deftypefn {Built-in Function} @var{type} __atomic_exchange_n (@var{type} *ptr, @var{type} val, int memorder)
This built-in function implements an atomic exchange operation.  It writes
@var{val} into @code{*@var{ptr}}, and returns the previous contents of
@code{*@var{ptr}}.

The valid memory order variants are
@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, @code{__ATOMIC_ACQUIRE},
@code{__ATOMIC_RELEASE}, and @code{__ATOMIC_ACQ_REL}.

@end deftypefn

@deftypefn {Built-in Function} void __atomic_exchange (@var{type} *ptr, @var{type} *val, @var{type} *ret, int memorder)
This is the generic version of an atomic exchange.  It stores the
contents of @code{*@var{val}} into @code{*@var{ptr}}. The original value
of @code{*@var{ptr}} is copied into @code{*@var{ret}}.

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_compare_exchange_n (@var{type} *ptr, @var{type} *expected, @var{type} desired, bool weak, int success_memorder, int failure_memorder)
This built-in function implements an atomic compare and exchange operation.
This compares the contents of @code{*@var{ptr}} with the contents of
@code{*@var{expected}}. If equal, the operation is a @emph{read-modify-write}
operation that writes @var{desired} into @code{*@var{ptr}}.  If they are not
equal, the operation is a @emph{read} and the current contents of
@code{*@var{ptr}} are written into @code{*@var{expected}}.  @var{weak} is true
for weak compare_exchange, which may fail spuriously, and false for
the strong variation, which never fails spuriously.  Many targets
only offer the strong variation and ignore the parameter.  When in doubt, use
the strong variation.

If @var{desired} is written into @code{*@var{ptr}} then true is returned
and memory is affected according to the
memory order specified by @var{success_memorder}.  There are no
restrictions on what memory order can be used here.

Otherwise, false is returned and memory is affected according
to @var{failure_memorder}. This memory order cannot be
@code{__ATOMIC_RELEASE} nor @code{__ATOMIC_ACQ_REL}.  It also cannot be a
stronger order than that specified by @var{success_memorder}.

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_compare_exchange (@var{type} *ptr, @var{type} *expected, @var{type} *desired, bool weak, int success_memorder, int failure_memorder)
This built-in function implements the generic version of
@code{__atomic_compare_exchange}.  The function is virtually identical to
@code{__atomic_compare_exchange_n}, except the desired value is also a
pointer.

@end deftypefn

@deftypefn {Built-in Function} @var{type} __atomic_add_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_sub_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_and_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_xor_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_or_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_nand_fetch (@var{type} *ptr, @var{type} val, int memorder)
These built-in functions perform the operation suggested by the name, and
return the result of the operation.  Operations on pointer arguments are
performed as if the operands were of the @code{uintptr_t} type.  That is,
they are not scaled by the size of the type to which the pointer points.

@smallexample
@{ *ptr @var{op}= val; return *ptr; @}
@end smallexample

The object pointed to by the first argument must be of integer or pointer
type.  It must not be a boolean type.  All memory orders are valid.

@end deftypefn

@deftypefn {Built-in Function} @var{type} __atomic_fetch_add (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_sub (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_and (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_xor (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_or (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_nand (@var{type} *ptr, @var{type} val, int memorder)
These built-in functions perform the operation suggested by the name, and
return the value that had previously been in @code{*@var{ptr}}.  Operations
on pointer arguments are performed as if the operands were of
the @code{uintptr_t} type.  That is, they are not scaled by the size of
the type to which the pointer points.

@smallexample
@{ tmp = *ptr; *ptr @var{op}= val; return tmp; @}
@end smallexample

The same constraints on arguments apply as for the corresponding
@code{__atomic_op_fetch} built-in functions.  All memory orders are valid.

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_test_and_set (void *ptr, int memorder)

This built-in function performs an atomic test-and-set operation on
the byte at @code{*@var{ptr}}.  The byte is set to some implementation
defined nonzero ``set'' value and the return value is @code{true} if and only
if the previous contents were ``set''.
It should be only used for operands of type @code{bool} or @code{char}. For 
other types only part of the value may be set.

All memory orders are valid.

@end deftypefn

@deftypefn {Built-in Function} void __atomic_clear (bool *ptr, int memorder)

This built-in function performs an atomic clear operation on
@code{*@var{ptr}}.  After the operation, @code{*@var{ptr}} contains 0.
It should be only used for operands of type @code{bool} or @code{char} and 
in conjunction with @code{__atomic_test_and_set}.
For other types it may only clear partially. If the type is not @code{bool}
prefer using @code{__atomic_store}.

The valid memory order variants are
@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, and
@code{__ATOMIC_RELEASE}.

@end deftypefn

@deftypefn {Built-in Function} void __atomic_thread_fence (int memorder)

This built-in function acts as a synchronization fence between threads
based on the specified memory order.

All memory orders are valid.

@end deftypefn

@deftypefn {Built-in Function} void __atomic_signal_fence (int memorder)

This built-in function acts as a synchronization fence between a thread
and signal handlers based in the same thread.

All memory orders are valid.

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_always_lock_free (size_t size,  void *ptr)

This built-in function returns true if objects of @var{size} bytes always
generate lock-free atomic instructions for the target architecture.
@var{size} must resolve to a compile-time constant and the result also
resolves to a compile-time constant.

@var{ptr} is an optional pointer to the object that may be used to determine
alignment.  A value of 0 indicates typical alignment should be used.  The 
compiler may also ignore this parameter.

@smallexample
if (__atomic_always_lock_free (sizeof (long long), 0))
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_is_lock_free (size_t size, void *ptr)

This built-in function returns true if objects of @var{size} bytes always
generate lock-free atomic instructions for the target architecture.  If
the built-in function is not known to be lock-free, a call is made to a
runtime routine named @code{__atomic_is_lock_free}.

@var{ptr} is an optional pointer to the object that may be used to determine
alignment.  A value of 0 indicates typical alignment should be used.  The 
compiler may also ignore this parameter.
@end deftypefn

@node Integer Overflow Builtins
@section Built-in Functions to Perform Arithmetic with Overflow Checking

The following built-in functions allow performing simple arithmetic operations
together with checking whether the operations overflowed.

@deftypefn {Built-in Function} bool __builtin_add_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)
@deftypefnx {Built-in Function} bool __builtin_sadd_overflow (int a, int b, int *res)
@deftypefnx {Built-in Function} bool __builtin_saddl_overflow (long int a, long int b, long int *res)
@deftypefnx {Built-in Function} bool __builtin_saddll_overflow (long long int a, long long int b, long long int *res)
@deftypefnx {Built-in Function} bool __builtin_uadd_overflow (unsigned int a, unsigned int b, unsigned int *res)
@deftypefnx {Built-in Function} bool __builtin_uaddl_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)
@deftypefnx {Built-in Function} bool __builtin_uaddll_overflow (unsigned long long int a, unsigned long long int b, unsigned long long int *res)

These built-in functions promote the first two operands into infinite precision signed
type and perform addition on those promoted operands.  The result is then
cast to the type the third pointer argument points to and stored there.
If the stored result is equal to the infinite precision result, the built-in
functions return false, otherwise they return true.  As the addition is
performed in infinite signed precision, these built-in functions have fully defined
behavior for all argument values.

The first built-in function allows arbitrary integral types for operands and
the result type must be pointer to some integral type other than enumerated or
boolean type, the rest of the built-in functions have explicit integer types.

The compiler will attempt to use hardware instructions to implement
these built-in functions where possible, like conditional jump on overflow
after addition, conditional jump on carry etc.

@end deftypefn

@deftypefn {Built-in Function} bool __builtin_sub_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)
@deftypefnx {Built-in Function} bool __builtin_ssub_overflow (int a, int b, int *res)
@deftypefnx {Built-in Function} bool __builtin_ssubl_overflow (long int a, long int b, long int *res)
@deftypefnx {Built-in Function} bool __builtin_ssubll_overflow (long long int a, long long int b, long long int *res)
@deftypefnx {Built-in Function} bool __builtin_usub_overflow (unsigned int a, unsigned int b, unsigned int *res)
@deftypefnx {Built-in Function} bool __builtin_usubl_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)
@deftypefnx {Built-in Function} bool __builtin_usubll_overflow (unsigned long long int a, unsigned long long int b, unsigned long long int *res)

These built-in functions are similar to the add overflow checking built-in
functions above, except they perform subtraction, subtract the second argument
from the first one, instead of addition.

@end deftypefn

@deftypefn {Built-in Function} bool __builtin_mul_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)
@deftypefnx {Built-in Function} bool __builtin_smul_overflow (int a, int b, int *res)
@deftypefnx {Built-in Function} bool __builtin_smull_overflow (long int a, long int b, long int *res)
@deftypefnx {Built-in Function} bool __builtin_smulll_overflow (long long int a, long long int b, long long int *res)
@deftypefnx {Built-in Function} bool __builtin_umul_overflow (unsigned int a, unsigned int b, unsigned int *res)
@deftypefnx {Built-in Function} bool __builtin_umull_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)
@deftypefnx {Built-in Function} bool __builtin_umulll_overflow (unsigned long long int a, unsigned long long int b, unsigned long long int *res)

These built-in functions are similar to the add overflow checking built-in
functions above, except they perform multiplication, instead of addition.

@end deftypefn

The following built-in functions allow checking if simple arithmetic operation
would overflow.

@deftypefn {Built-in Function} bool __builtin_add_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)
@deftypefnx {Built-in Function} bool __builtin_sub_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)
@deftypefnx {Built-in Function} bool __builtin_mul_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)

These built-in functions are similar to @code{__builtin_add_overflow},
@code{__builtin_sub_overflow}, or @code{__builtin_mul_overflow}, except that
they don't store the result of the arithmetic operation anywhere and the
last argument is not a pointer, but some expression with integral type other
than enumerated or boolean type.

The built-in functions promote the first two operands into infinite precision signed type
and perform addition on those promoted operands. The result is then
cast to the type of the third argument.  If the cast result is equal to the infinite
precision result, the built-in functions return false, otherwise they return true.
The value of the third argument is ignored, just the side-effects in the third argument
are evaluated, and no integral argument promotions are performed on the last argument.
If the third argument is a bit-field, the type used for the result cast has the
precision and signedness of the given bit-field, rather than precision and signedness
of the underlying type.

For example, the following macro can be used to portably check, at
compile-time, whether or not adding two constant integers will overflow,
and perform the addition only when it is known to be safe and not to trigger
a @option{-Woverflow} warning.

@smallexample
#define INT_ADD_OVERFLOW_P(a, b) \
   __builtin_add_overflow_p (a, b, (__typeof__ ((a) + (b))) 0)

enum @{
    A = INT_MAX, B = 3,
    C = INT_ADD_OVERFLOW_P (A, B) ? 0 : A + B,
    D = __builtin_add_overflow_p (1, SCHAR_MAX, (signed char) 0)
@};
@end smallexample

The compiler will attempt to use hardware instructions to implement
these built-in functions where possible, like conditional jump on overflow
after addition, conditional jump on carry etc.
 
@end deftypefn

@node x86 specific memory model extensions for transactional memory
@section x86-Specific Memory Model Extensions for Transactional Memory

The x86 architecture supports additional memory ordering flags
to mark critical sections for hardware lock elision. 
These must be specified in addition to an existing memory order to
atomic intrinsics.

@table @code
@item __ATOMIC_HLE_ACQUIRE
Start lock elision on a lock variable.
Memory order must be @code{__ATOMIC_ACQUIRE} or stronger.
@item __ATOMIC_HLE_RELEASE
End lock elision on a lock variable.
Memory order must be @code{__ATOMIC_RELEASE} or stronger.
@end table

When a lock acquire fails, it is required for good performance to abort
the transaction quickly. This can be done with a @code{_mm_pause}.

@smallexample
#include <immintrin.h> // For _mm_pause

int lockvar;

/* Acquire lock with lock elision */
while (__atomic_exchange_n(&lockvar, 1, __ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))
    _mm_pause(); /* Abort failed transaction */
...
/* Free lock with lock elision */
__atomic_store_n(&lockvar, 0, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);
@end smallexample

@node Object Size Checking
@section Object Size Checking Built-in Functions
@findex __builtin_object_size
@findex __builtin___memcpy_chk
@findex __builtin___mempcpy_chk
@findex __builtin___memmove_chk
@findex __builtin___memset_chk
@findex __builtin___strcpy_chk
@findex __builtin___stpcpy_chk
@findex __builtin___strncpy_chk
@findex __builtin___strcat_chk
@findex __builtin___strncat_chk
@findex __builtin___sprintf_chk
@findex __builtin___snprintf_chk
@findex __builtin___vsprintf_chk
@findex __builtin___vsnprintf_chk
@findex __builtin___printf_chk
@findex __builtin___vprintf_chk
@findex __builtin___fprintf_chk
@findex __builtin___vfprintf_chk

GCC implements a limited buffer overflow protection mechanism that can
prevent some buffer overflow attacks by determining the sizes of objects
into which data is about to be written and preventing the writes when
the size isn't sufficient.  The built-in functions described below yield
the best results when used together and when optimization is enabled.
For example, to detect object sizes across function boundaries or to
follow pointer assignments through non-trivial control flow they rely
on various optimization passes enabled with @option{-O2}.  However, to
a limited extent, they can be used without optimization as well.

@deftypefn {Built-in Function} {size_t} __builtin_object_size (const void * @var{ptr}, int @var{type})
is a built-in construct that returns a constant number of bytes from
@var{ptr} to the end of the object @var{ptr} pointer points to
(if known at compile time).  @code{__builtin_object_size} never evaluates
its arguments for side-effects.  If there are any side-effects in them, it
returns @code{(size_t) -1} for @var{type} 0 or 1 and @code{(size_t) 0}
for @var{type} 2 or 3.  If there are multiple objects @var{ptr} can
point to and all of them are known at compile time, the returned number
is the maximum of remaining byte counts in those objects if @var{type} & 2 is
0 and minimum if nonzero.  If it is not possible to determine which objects
@var{ptr} points to at compile time, @code{__builtin_object_size} should
return @code{(size_t) -1} for @var{type} 0 or 1 and @code{(size_t) 0}
for @var{type} 2 or 3.

@var{type} is an integer constant from 0 to 3.  If the least significant
bit is clear, objects are whole variables, if it is set, a closest
surrounding subobject is considered the object a pointer points to.
The second bit determines if maximum or minimum of remaining bytes
is computed.

@smallexample
struct V @{ char buf1[10]; int b; char buf2[10]; @} var;
char *p = &var.buf1[1], *q = &var.b;

/* Here the object p points to is var.  */
assert (__builtin_object_size (p, 0) == sizeof (var) - 1);
/* The subobject p points to is var.buf1.  */
assert (__builtin_object_size (p, 1) == sizeof (var.buf1) - 1);
/* The object q points to is var.  */
assert (__builtin_object_size (q, 0)
        == (char *) (&var + 1) - (char *) &var.b);
/* The subobject q points to is var.b.  */
assert (__builtin_object_size (q, 1) == sizeof (var.b));
@end smallexample
@end deftypefn

There are built-in functions added for many common string operation
functions, e.g., for @code{memcpy} @code{__builtin___memcpy_chk}
built-in is provided.  This built-in has an additional last argument,
which is the number of bytes remaining in object the @var{dest}
argument points to or @code{(size_t) -1} if the size is not known.

The built-in functions are optimized into the normal string functions
like @code{memcpy} if the last argument is @code{(size_t) -1} or if
it is known at compile time that the destination object will not
be overflown.  If the compiler can determine at compile time the
object will be always overflown, it issues a warning.

The intended use can be e.g.@:

@smallexample
#undef memcpy
#define bos0(dest) __builtin_object_size (dest, 0)
#define memcpy(dest, src, n) \
  __builtin___memcpy_chk (dest, src, n, bos0 (dest))

char *volatile p;
char buf[10];
/* It is unknown what object p points to, so this is optimized
   into plain memcpy - no checking is possible.  */
memcpy (p, "abcde", n);
/* Destination is known and length too.  It is known at compile
   time there will be no overflow.  */
memcpy (&buf[5], "abcde", 5);
/* Destination is known, but the length is not known at compile time.
   This will result in __memcpy_chk call that can check for overflow
   at run time.  */
memcpy (&buf[5], "abcde", n);
/* Destination is known and it is known at compile time there will
   be overflow.  There will be a warning and __memcpy_chk call that
   will abort the program at run time.  */
memcpy (&buf[6], "abcde", 5);
@end smallexample

Such built-in functions are provided for @code{memcpy}, @code{mempcpy},
@code{memmove}, @code{memset}, @code{strcpy}, @code{stpcpy}, @code{strncpy},
@code{strcat} and @code{strncat}.

There are also checking built-in functions for formatted output functions.
@smallexample
int __builtin___sprintf_chk (char *s, int flag, size_t os, const char *fmt, ...);
int __builtin___snprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                              const char *fmt, ...);
int __builtin___vsprintf_chk (char *s, int flag, size_t os, const char *fmt,
                              va_list ap);
int __builtin___vsnprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                               const char *fmt, va_list ap);
@end smallexample

The added @var{flag} argument is passed unchanged to @code{__sprintf_chk}
etc.@: functions and can contain implementation specific flags on what
additional security measures the checking function might take, such as
handling @code{%n} differently.

The @var{os} argument is the object size @var{s} points to, like in the
other built-in functions.  There is a small difference in the behavior
though, if @var{os} is @code{(size_t) -1}, the built-in functions are
optimized into the non-checking functions only if @var{flag} is 0, otherwise
the checking function is called with @var{os} argument set to
@code{(size_t) -1}.

In addition to this, there are checking built-in functions
@code{__builtin___printf_chk}, @code{__builtin___vprintf_chk},
@code{__builtin___fprintf_chk} and @code{__builtin___vfprintf_chk}.
These have just one additional argument, @var{flag}, right before
format string @var{fmt}.  If the compiler is able to optimize them to
@code{fputc} etc.@: functions, it does, otherwise the checking function
is called and the @var{flag} argument passed to it.

@node Pointer Bounds Checker builtins
@section Pointer Bounds Checker Built-in Functions
@cindex Pointer Bounds Checker builtins
@findex __builtin___bnd_set_ptr_bounds
@findex __builtin___bnd_narrow_ptr_bounds
@findex __builtin___bnd_copy_ptr_bounds
@findex __builtin___bnd_init_ptr_bounds
@findex __builtin___bnd_null_ptr_bounds
@findex __builtin___bnd_store_ptr_bounds
@findex __builtin___bnd_chk_ptr_lbounds
@findex __builtin___bnd_chk_ptr_ubounds
@findex __builtin___bnd_chk_ptr_bounds
@findex __builtin___bnd_get_ptr_lbound
@findex __builtin___bnd_get_ptr_ubound

GCC provides a set of built-in functions to control Pointer Bounds Checker
instrumentation.  Note that all Pointer Bounds Checker builtins can be used
even if you compile with Pointer Bounds Checker off
(@option{-fno-check-pointer-bounds}).
The behavior may differ in such case as documented below.

@deftypefn {Built-in Function} {void *} __builtin___bnd_set_ptr_bounds (const void *@var{q}, size_t @var{size})

This built-in function returns a new pointer with the value of @var{q}, and
associate it with the bounds [@var{q}, @var{q}+@var{size}-1].  With Pointer
Bounds Checker off, the built-in function just returns the first argument.

@smallexample
extern void *__wrap_malloc (size_t n)
@{
  void *p = (void *)__real_malloc (n);
  if (!p) return __builtin___bnd_null_ptr_bounds (p);
  return __builtin___bnd_set_ptr_bounds (p, n);
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_narrow_ptr_bounds (const void *@var{p}, const void *@var{q}, size_t  @var{size})

This built-in function returns a new pointer with the value of @var{p}
and associates it with the narrowed bounds formed by the intersection
of bounds associated with @var{q} and the bounds
[@var{p}, @var{p} + @var{size} - 1].
With Pointer Bounds Checker off, the built-in function just returns the first
argument.

@smallexample
void init_objects (object *objs, size_t size)
@{
  size_t i;
  /* Initialize objects one-by-one passing pointers with bounds of 
     an object, not the full array of objects.  */
  for (i = 0; i < size; i++)
    init_object (__builtin___bnd_narrow_ptr_bounds (objs + i, objs,
                                                    sizeof(object)));
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_copy_ptr_bounds (const void *@var{q}, const void *@var{r})

This built-in function returns a new pointer with the value of @var{q},
and associates it with the bounds already associated with pointer @var{r}.
With Pointer Bounds Checker off, the built-in function just returns the first
argument.

@smallexample
/* Here is a way to get pointer to object's field but
   still with the full object's bounds.  */
int *field_ptr = __builtin___bnd_copy_ptr_bounds (&objptr->int_field, 
                                                  objptr);
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_init_ptr_bounds (const void *@var{q})

This built-in function returns a new pointer with the value of @var{q}, and
associates it with INIT (allowing full memory access) bounds. With Pointer
Bounds Checker off, the built-in function just returns the first argument.

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_null_ptr_bounds (const void *@var{q})

This built-in function returns a new pointer with the value of @var{q}, and
associates it with NULL (allowing no memory access) bounds. With Pointer
Bounds Checker off, the built-in function just returns the first argument.

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_store_ptr_bounds (const void **@var{ptr_addr}, const void *@var{ptr_val})

This built-in function stores the bounds associated with pointer @var{ptr_val}
and location @var{ptr_addr} into Bounds Table.  This can be useful to propagate
bounds from legacy code without touching the associated pointer's memory when
pointers are copied as integers.  With Pointer Bounds Checker off, the built-in
function call is ignored.

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_lbounds (const void *@var{q})

This built-in function checks if the pointer @var{q} is within the lower
bound of its associated bounds.  With Pointer Bounds Checker off, the built-in
function call is ignored.

@smallexample
extern void *__wrap_memset (void *dst, int c, size_t len)
@{
  if (len > 0)
    @{
      __builtin___bnd_chk_ptr_lbounds (dst);
      __builtin___bnd_chk_ptr_ubounds ((char *)dst + len - 1);
      __real_memset (dst, c, len);
    @}
  return dst;
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_ubounds (const void *@var{q})

This built-in function checks if the pointer @var{q} is within the upper
bound of its associated bounds.  With Pointer Bounds Checker off, the built-in
function call is ignored.

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_bounds (const void *@var{q}, size_t @var{size})

This built-in function checks if [@var{q}, @var{q} + @var{size} - 1] is within
the lower and upper bounds associated with @var{q}.  With Pointer Bounds Checker
off, the built-in function call is ignored.

@smallexample
extern void *__wrap_memcpy (void *dst, const void *src, size_t n)
@{
  if (n > 0)
    @{
      __bnd_chk_ptr_bounds (dst, n);
      __bnd_chk_ptr_bounds (src, n);
      __real_memcpy (dst, src, n);
    @}
  return dst;
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {const void *} __builtin___bnd_get_ptr_lbound (const void *@var{q})

This built-in function returns the lower bound associated
with the pointer @var{q}, as a pointer value.  
This is useful for debugging using @code{printf}.
With Pointer Bounds Checker off, the built-in function returns 0.

@smallexample
void *lb = __builtin___bnd_get_ptr_lbound (q);
void *ub = __builtin___bnd_get_ptr_ubound (q);
printf ("q = %p  lb(q) = %p  ub(q) = %p", q, lb, ub);
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {const void *} __builtin___bnd_get_ptr_ubound (const void *@var{q})

This built-in function returns the upper bound (which is a pointer) associated
with the pointer @var{q}.  With Pointer Bounds Checker off,
the built-in function returns -1.

@end deftypefn

@node Cilk Plus Builtins
@section Cilk Plus C/C++ Language Extension Built-in Functions

GCC provides support for the following built-in reduction functions if Cilk Plus
is enabled. Cilk Plus can be enabled using the @option{-fcilkplus} flag.

@itemize @bullet
@item @code{__sec_implicit_index}
@item @code{__sec_reduce}
@item @code{__sec_reduce_add}
@item @code{__sec_reduce_all_nonzero}
@item @code{__sec_reduce_all_zero}
@item @code{__sec_reduce_any_nonzero}
@item @code{__sec_reduce_any_zero}
@item @code{__sec_reduce_max}
@item @code{__sec_reduce_min}
@item @code{__sec_reduce_max_ind}
@item @code{__sec_reduce_min_ind}
@item @code{__sec_reduce_mul}
@item @code{__sec_reduce_mutating}
@end itemize

Further details and examples about these built-in functions are described 
in the Cilk Plus language manual which can be found at 
@uref{https://www.cilkplus.org}.

@node Other Builtins
@section Other Built-in Functions Provided by GCC
@cindex built-in functions
@findex __builtin_alloca
@findex __builtin_alloca_with_align
@findex __builtin_call_with_static_chain
@findex __builtin_fpclassify
@findex __builtin_isfinite
@findex __builtin_isnormal
@findex __builtin_isgreater
@findex __builtin_isgreaterequal
@findex __builtin_isinf_sign
@findex __builtin_isless
@findex __builtin_islessequal
@findex __builtin_islessgreater
@findex __builtin_isunordered
@findex __builtin_powi
@findex __builtin_powif
@findex __builtin_powil
@findex _Exit
@findex _exit
@findex abort
@findex abs
@findex acos
@findex acosf
@findex acosh
@findex acoshf
@findex acoshl
@findex acosl
@findex alloca
@findex asin
@findex asinf
@findex asinh
@findex asinhf
@findex asinhl
@findex asinl
@findex atan
@findex atan2
@findex atan2f
@findex atan2l
@findex atanf
@findex atanh
@findex atanhf
@findex atanhl
@findex atanl
@findex bcmp
@findex bzero
@findex cabs
@findex cabsf
@findex cabsl
@findex cacos
@findex cacosf
@findex cacosh
@findex cacoshf
@findex cacoshl
@findex cacosl
@findex calloc
@findex carg
@findex cargf
@findex cargl
@findex casin
@findex casinf
@findex casinh
@findex casinhf
@findex casinhl
@findex casinl
@findex catan
@findex catanf
@findex catanh
@findex catanhf
@findex catanhl
@findex catanl
@findex cbrt
@findex cbrtf
@findex cbrtl
@findex ccos
@findex ccosf
@findex ccosh
@findex ccoshf
@findex ccoshl
@findex ccosl
@findex ceil
@findex ceilf
@findex ceill
@findex cexp
@findex cexpf
@findex cexpl
@findex cimag
@findex cimagf
@findex cimagl
@findex clog
@findex clogf
@findex clogl
@findex clog10
@findex clog10f
@findex clog10l
@findex conj
@findex conjf
@findex conjl
@findex copysign
@findex copysignf
@findex copysignl
@findex cos
@findex cosf
@findex cosh
@findex coshf
@findex coshl
@findex cosl
@findex cpow
@findex cpowf
@findex cpowl
@findex cproj
@findex cprojf
@findex cprojl
@findex creal
@findex crealf
@findex creall
@findex csin
@findex csinf
@findex csinh
@findex csinhf
@findex csinhl
@findex csinl
@findex csqrt
@findex csqrtf
@findex csqrtl
@findex ctan
@findex ctanf
@findex ctanh
@findex ctanhf
@findex ctanhl
@findex ctanl
@findex dcgettext
@findex dgettext
@findex drem
@findex dremf
@findex dreml
@findex erf
@findex erfc
@findex erfcf
@findex erfcl
@findex erff
@findex erfl
@findex exit
@findex exp
@findex exp10
@findex exp10f
@findex exp10l
@findex exp2
@findex exp2f
@findex exp2l
@findex expf
@findex expl
@findex expm1
@findex expm1f
@findex expm1l
@findex fabs
@findex fabsf
@findex fabsl
@findex fdim
@findex fdimf
@findex fdiml
@findex ffs
@findex floor
@findex floorf
@findex floorl
@findex fma
@findex fmaf
@findex fmal
@findex fmax
@findex fmaxf
@findex fmaxl
@findex fmin
@findex fminf
@findex fminl
@findex fmod
@findex fmodf
@findex fmodl
@findex fprintf
@findex fprintf_unlocked
@findex fputs
@findex fputs_unlocked
@findex frexp
@findex frexpf
@findex frexpl
@findex fscanf
@findex gamma
@findex gammaf
@findex gammal
@findex gamma_r
@findex gammaf_r
@findex gammal_r
@findex gettext
@findex hypot
@findex hypotf
@findex hypotl
@findex ilogb
@findex ilogbf
@findex ilogbl
@findex imaxabs
@findex index
@findex isalnum
@findex isalpha
@findex isascii
@findex isblank
@findex iscntrl
@findex isdigit
@findex isgraph
@findex islower
@findex isprint
@findex ispunct
@findex isspace
@findex isupper
@findex iswalnum
@findex iswalpha
@findex iswblank
@findex iswcntrl
@findex iswdigit
@findex iswgraph
@findex iswlower
@findex iswprint
@findex iswpunct
@findex iswspace
@findex iswupper
@findex iswxdigit
@findex isxdigit
@findex j0
@findex j0f
@findex j0l
@findex j1
@findex j1f
@findex j1l
@findex jn
@findex jnf
@findex jnl
@findex labs
@findex ldexp
@findex ldexpf
@findex ldexpl
@findex lgamma
@findex lgammaf
@findex lgammal
@findex lgamma_r
@findex lgammaf_r
@findex lgammal_r
@findex llabs
@findex llrint
@findex llrintf
@findex llrintl
@findex llround
@findex llroundf
@findex llroundl
@findex log
@findex log10
@findex log10f
@findex log10l
@findex log1p
@findex log1pf
@findex log1pl
@findex log2
@findex log2f
@findex log2l
@findex logb
@findex logbf
@findex logbl
@findex logf
@findex logl
@findex lrint
@findex lrintf
@findex lrintl
@findex lround
@findex lroundf
@findex lroundl
@findex malloc
@findex memchr
@findex memcmp
@findex memcpy
@findex mempcpy
@findex memset
@findex modf
@findex modff
@findex modfl
@findex nearbyint
@findex nearbyintf
@findex nearbyintl
@findex nextafter
@findex nextafterf
@findex nextafterl
@findex nexttoward
@findex nexttowardf
@findex nexttowardl
@findex pow
@findex pow10
@findex pow10f
@findex pow10l
@findex powf
@findex powl
@findex printf
@findex printf_unlocked
@findex putchar
@findex puts
@findex remainder
@findex remainderf
@findex remainderl
@findex remquo
@findex remquof
@findex remquol
@findex rindex
@findex rint
@findex rintf
@findex rintl
@findex round
@findex roundf
@findex roundl
@findex scalb
@findex scalbf
@findex scalbl
@findex scalbln
@findex scalblnf
@findex scalblnf
@findex scalbn
@findex scalbnf
@findex scanfnl
@findex signbit
@findex signbitf
@findex signbitl
@findex signbitd32
@findex signbitd64
@findex signbitd128
@findex significand
@findex significandf
@findex significandl
@findex sin
@findex sincos
@findex sincosf
@findex sincosl
@findex sinf
@findex sinh
@findex sinhf
@findex sinhl
@findex sinl
@findex snprintf
@findex sprintf
@findex sqrt
@findex sqrtf
@findex sqrtl
@findex sscanf
@findex stpcpy
@findex stpncpy
@findex strcasecmp
@findex strcat
@findex strchr
@findex strcmp
@findex strcpy
@findex strcspn
@findex strdup
@findex strfmon
@findex strftime
@findex strlen
@findex strncasecmp
@findex strncat
@findex strncmp
@findex strncpy
@findex strndup
@findex strpbrk
@findex strrchr
@findex strspn
@findex strstr
@findex tan
@findex tanf
@findex tanh
@findex tanhf
@findex tanhl
@findex tanl
@findex tgamma
@findex tgammaf
@findex tgammal
@findex toascii
@findex tolower
@findex toupper
@findex towlower
@findex towupper
@findex trunc
@findex truncf
@findex truncl
@findex vfprintf
@findex vfscanf
@findex vprintf
@findex vscanf
@findex vsnprintf
@findex vsprintf
@findex vsscanf
@findex y0
@findex y0f
@findex y0l
@findex y1
@findex y1f
@findex y1l
@findex yn
@findex ynf
@findex ynl

GCC provides a large number of built-in functions other than the ones
mentioned above.  Some of these are for internal use in the processing
of exceptions or variable-length argument lists and are not
documented here because they may change from time to time; we do not
recommend general use of these functions.

The remaining functions are provided for optimization purposes.

With the exception of built-ins that have library equivalents such as
the standard C library functions discussed below, or that expand to
library calls, GCC built-in functions are always expanded inline and
thus do not have corresponding entry points and their address cannot
be obtained.  Attempting to use them in an expression other than
a function call results in a compile-time error.

@opindex fno-builtin
GCC includes built-in versions of many of the functions in the standard
C library.  These functions come in two forms: one whose names start with
the @code{__builtin_} prefix, and the other without.  Both forms have the
same type (including prototype), the same address (when their address is
taken), and the same meaning as the C library functions even if you specify
the @option{-fno-builtin} option @pxref{C Dialect Options}).  Many of these
functions are only optimized in certain cases; if they are not optimized in
a particular case, a call to the library function is emitted.

@opindex ansi
@opindex std
Outside strict ISO C mode (@option{-ansi}, @option{-std=c90},
@option{-std=c99} or @option{-std=c11}), the functions
@code{_exit}, @code{alloca}, @code{bcmp}, @code{bzero},
@code{dcgettext}, @code{dgettext}, @code{dremf}, @code{dreml},
@code{drem}, @code{exp10f}, @code{exp10l}, @code{exp10}, @code{ffsll},
@code{ffsl}, @code{ffs}, @code{fprintf_unlocked},
@code{fputs_unlocked}, @code{gammaf}, @code{gammal}, @code{gamma},
@code{gammaf_r}, @code{gammal_r}, @code{gamma_r}, @code{gettext},
@code{index}, @code{isascii}, @code{j0f}, @code{j0l}, @code{j0},
@code{j1f}, @code{j1l}, @code{j1}, @code{jnf}, @code{jnl}, @code{jn},
@code{lgammaf_r}, @code{lgammal_r}, @code{lgamma_r}, @code{mempcpy},
@code{pow10f}, @code{pow10l}, @code{pow10}, @code{printf_unlocked},
@code{rindex}, @code{scalbf}, @code{scalbl}, @code{scalb},
@code{signbit}, @code{signbitf}, @code{signbitl}, @code{signbitd32},
@code{signbitd64}, @code{signbitd128}, @code{significandf},
@code{significandl}, @code{significand}, @code{sincosf},
@code{sincosl}, @code{sincos}, @code{stpcpy}, @code{stpncpy},
@code{strcasecmp}, @code{strdup}, @code{strfmon}, @code{strncasecmp},
@code{strndup}, @code{toascii}, @code{y0f}, @code{y0l}, @code{y0},
@code{y1f}, @code{y1l}, @code{y1}, @code{ynf}, @code{ynl} and
@code{yn}
may be handled as built-in functions.
All these functions have corresponding versions
prefixed with @code{__builtin_}, which may be used even in strict C90
mode.

The ISO C99 functions
@code{_Exit}, @code{acoshf}, @code{acoshl}, @code{acosh}, @code{asinhf},
@code{asinhl}, @code{asinh}, @code{atanhf}, @code{atanhl}, @code{atanh},
@code{cabsf}, @code{cabsl}, @code{cabs}, @code{cacosf}, @code{cacoshf},
@code{cacoshl}, @code{cacosh}, @code{cacosl}, @code{cacos},
@code{cargf}, @code{cargl}, @code{carg}, @code{casinf}, @code{casinhf},
@code{casinhl}, @code{casinh}, @code{casinl}, @code{casin},
@code{catanf}, @code{catanhf}, @code{catanhl}, @code{catanh},
@code{catanl}, @code{catan}, @code{cbrtf}, @code{cbrtl}, @code{cbrt},
@code{ccosf}, @code{ccoshf}, @code{ccoshl}, @code{ccosh}, @code{ccosl},
@code{ccos}, @code{cexpf}, @code{cexpl}, @code{cexp}, @code{cimagf},
@code{cimagl}, @code{cimag}, @code{clogf}, @code{clogl}, @code{clog},
@code{conjf}, @code{conjl}, @code{conj}, @code{copysignf}, @code{copysignl},
@code{copysign}, @code{cpowf}, @code{cpowl}, @code{cpow}, @code{cprojf},
@code{cprojl}, @code{cproj}, @code{crealf}, @code{creall}, @code{creal},
@code{csinf}, @code{csinhf}, @code{csinhl}, @code{csinh}, @code{csinl},
@code{csin}, @code{csqrtf}, @code{csqrtl}, @code{csqrt}, @code{ctanf},
@code{ctanhf}, @code{ctanhl}, @code{ctanh}, @code{ctanl}, @code{ctan},
@code{erfcf}, @code{erfcl}, @code{erfc}, @code{erff}, @code{erfl},
@code{erf}, @code{exp2f}, @code{exp2l}, @code{exp2}, @code{expm1f},
@code{expm1l}, @code{expm1}, @code{fdimf}, @code{fdiml}, @code{fdim},
@code{fmaf}, @code{fmal}, @code{fmaxf}, @code{fmaxl}, @code{fmax},
@code{fma}, @code{fminf}, @code{fminl}, @code{fmin}, @code{hypotf},
@code{hypotl}, @code{hypot}, @code{ilogbf}, @code{ilogbl}, @code{ilogb},
@code{imaxabs}, @code{isblank}, @code{iswblank}, @code{lgammaf},
@code{lgammal}, @code{lgamma}, @code{llabs}, @code{llrintf}, @code{llrintl},
@code{llrint}, @code{llroundf}, @code{llroundl}, @code{llround},
@code{log1pf}, @code{log1pl}, @code{log1p}, @code{log2f}, @code{log2l},
@code{log2}, @code{logbf}, @code{logbl}, @code{logb}, @code{lrintf},
@code{lrintl}, @code{lrint}, @code{lroundf}, @code{lroundl},
@code{lround}, @code{nearbyintf}, @code{nearbyintl}, @code{nearbyint},
@code{nextafterf}, @code{nextafterl}, @code{nextafter},
@code{nexttowardf}, @code{nexttowardl}, @code{nexttoward},
@code{remainderf}, @code{remainderl}, @code{remainder}, @code{remquof},
@code{remquol}, @code{remquo}, @code{rintf}, @code{rintl}, @code{rint},
@code{roundf}, @code{roundl}, @code{round}, @code{scalblnf},
@code{scalblnl}, @code{scalbln}, @code{scalbnf}, @code{scalbnl},
@code{scalbn}, @code{snprintf}, @code{tgammaf}, @code{tgammal},
@code{tgamma}, @code{truncf}, @code{truncl}, @code{trunc},
@code{vfscanf}, @code{vscanf}, @code{vsnprintf} and @code{vsscanf}
are handled as built-in functions
except in strict ISO C90 mode (@option{-ansi} or @option{-std=c90}).

There are also built-in versions of the ISO C99 functions
@code{acosf}, @code{acosl}, @code{asinf}, @code{asinl}, @code{atan2f},
@code{atan2l}, @code{atanf}, @code{atanl}, @code{ceilf}, @code{ceill},
@code{cosf}, @code{coshf}, @code{coshl}, @code{cosl}, @code{expf},
@code{expl}, @code{fabsf}, @code{fabsl}, @code{floorf}, @code{floorl},
@code{fmodf}, @code{fmodl}, @code{frexpf}, @code{frexpl}, @code{ldexpf},
@code{ldexpl}, @code{log10f}, @code{log10l}, @code{logf}, @code{logl},
@code{modfl}, @code{modf}, @code{powf}, @code{powl}, @code{sinf},
@code{sinhf}, @code{sinhl}, @code{sinl}, @code{sqrtf}, @code{sqrtl},
@code{tanf}, @code{tanhf}, @code{tanhl} and @code{tanl}
that are recognized in any mode since ISO C90 reserves these names for
the purpose to which ISO C99 puts them.  All these functions have
corresponding versions prefixed with @code{__builtin_}.

There are also built-in functions @code{__builtin_fabsf@var{n}},
@code{__builtin_fabsf@var{n}x}, @code{__builtin_copysignf@var{n}} and
@code{__builtin_copysignf@var{n}x}, corresponding to the TS 18661-3
functions @code{fabsf@var{n}}, @code{fabsf@var{n}x},
@code{copysignf@var{n}} and @code{copysignf@var{n}x}, for supported
types @code{_Float@var{n}} and @code{_Float@var{n}x}.

There are also GNU extension functions @code{clog10}, @code{clog10f} and
@code{clog10l} which names are reserved by ISO C99 for future use.
All these functions have versions prefixed with @code{__builtin_}.

The ISO C94 functions
@code{iswalnum}, @code{iswalpha}, @code{iswcntrl}, @code{iswdigit},
@code{iswgraph}, @code{iswlower}, @code{iswprint}, @code{iswpunct},
@code{iswspace}, @code{iswupper}, @code{iswxdigit}, @code{towlower} and
@code{towupper}
are handled as built-in functions
except in strict ISO C90 mode (@option{-ansi} or @option{-std=c90}).

The ISO C90 functions
@code{abort}, @code{abs}, @code{acos}, @code{asin}, @code{atan2},
@code{atan}, @code{calloc}, @code{ceil}, @code{cosh}, @code{cos},
@code{exit}, @code{exp}, @code{fabs}, @code{floor}, @code{fmod},
@code{fprintf}, @code{fputs}, @code{frexp}, @code{fscanf},
@code{isalnum}, @code{isalpha}, @code{iscntrl}, @code{isdigit},
@code{isgraph}, @code{islower}, @code{isprint}, @code{ispunct},
@code{isspace}, @code{isupper}, @code{isxdigit}, @code{tolower},
@code{toupper}, @code{labs}, @code{ldexp}, @code{log10}, @code{log},
@code{malloc}, @code{memchr}, @code{memcmp}, @code{memcpy},
@code{memset}, @code{modf}, @code{pow}, @code{printf}, @code{putchar},
@code{puts}, @code{scanf}, @code{sinh}, @code{sin}, @code{snprintf},
@code{sprintf}, @code{sqrt}, @code{sscanf}, @code{strcat},
@code{strchr}, @code{strcmp}, @code{strcpy}, @code{strcspn},
@code{strlen}, @code{strncat}, @code{strncmp}, @code{strncpy},
@code{strpbrk}, @code{strrchr}, @code{strspn}, @code{strstr},
@code{tanh}, @code{tan}, @code{vfprintf}, @code{vprintf} and @code{vsprintf}
are all recognized as built-in functions unless
@option{-fno-builtin} is specified (or @option{-fno-builtin-@var{function}}
is specified for an individual function).  All of these functions have
corresponding versions prefixed with @code{__builtin_}.

GCC provides built-in versions of the ISO C99 floating-point comparison
macros that avoid raising exceptions for unordered operands.  They have
the same names as the standard macros ( @code{isgreater},
@code{isgreaterequal}, @code{isless}, @code{islessequal},
@code{islessgreater}, and @code{isunordered}) , with @code{__builtin_}
prefixed.  We intend for a library implementor to be able to simply
@code{#define} each standard macro to its built-in equivalent.
In the same fashion, GCC provides @code{fpclassify}, @code{isfinite},
@code{isinf_sign}, @code{isnormal} and @code{signbit} built-ins used with
@code{__builtin_} prefixed.  The @code{isinf} and @code{isnan}
built-in functions appear both with and without the @code{__builtin_} prefix.

@deftypefn {Built-in Function} void *__builtin_alloca (size_t size)
The @code{__builtin_alloca} function must be called at block scope.
The function allocates an object @var{size} bytes large on the stack
of the calling function.  The object is aligned on the default stack
alignment boundary for the target determined by the
@code{__BIGGEST_ALIGNMENT__} macro.  The @code{__builtin_alloca}
function returns a pointer to the first byte of the allocated object.
The lifetime of the allocated object ends just before the calling
function returns to its caller.   This is so even when
@code{__builtin_alloca} is called within a nested block.

For example, the following function allocates eight objects of @code{n}
bytes each on the stack, storing a pointer to each in consecutive elements
of the array @code{a}.  It then passes the array to function @code{g}
which can safely use the storage pointed to by each of the array elements.

@smallexample
void f (unsigned n)
@{
  void *a [8];
  for (int i = 0; i != 8; ++i)
    a [i] = __builtin_alloca (n);

  g (a, n);   // @r{safe}
@}
@end smallexample

Since the @code{__builtin_alloca} function doesn't validate its argument
it is the responsibility of its caller to make sure the argument doesn't
cause it to exceed the stack size limit.
The @code{__builtin_alloca} function is provided to make it possible to
allocate on the stack arrays of bytes with an upper bound that may be
computed at run time.  Since C99 Variable Length Arrays offer
similar functionality under a portable, more convenient, and safer
interface they are recommended instead, in both C99 and C++ programs
where GCC provides them as an extension.
@xref{Variable Length}, for details.

@end deftypefn

@deftypefn {Built-in Function} void *__builtin_alloca_with_align (size_t size, size_t alignment)
The @code{__builtin_alloca_with_align} function must be called at block
scope.  The function allocates an object @var{size} bytes large on
the stack of the calling function.  The allocated object is aligned on
the boundary specified by the argument @var{alignment} whose unit is given
in bits (not bytes).  The @var{size} argument must be positive and not
exceed the stack size limit.  The @var{alignment} argument must be a constant
integer expression that evaluates to a power of 2 greater than or equal to
@code{CHAR_BIT} and less than some unspecified maximum.  Invocations
with other values are rejected with an error indicating the valid bounds.
The function returns a pointer to the first byte of the allocated object.
The lifetime of the allocated object ends at the end of the block in which
the function was called.  The allocated storage is released no later than
just before the calling function returns to its caller, but may be released
at the end of the block in which the function was called.

For example, in the following function the call to @code{g} is unsafe
because when @code{overalign} is non-zero, the space allocated by
@code{__builtin_alloca_with_align} may have been released at the end
of the @code{if} statement in which it was called.

@smallexample
void f (unsigned n, bool overalign)
@{
  void *p;
  if (overalign)
    p = __builtin_alloca_with_align (n, 64 /* bits */);
  else
    p = __builtin_alloc (n);

  g (p, n);   // @r{unsafe}
@}
@end smallexample

Since the @code{__builtin_alloca_with_align} function doesn't validate its
@var{size} argument it is the responsibility of its caller to make sure
the argument doesn't cause it to exceed the stack size limit.
The @code{__builtin_alloca_with_align} function is provided to make
it possible to allocate on the stack overaligned arrays of bytes with
an upper bound that may be computed at run time.  Since C99
Variable Length Arrays offer the same functionality under
a portable, more convenient, and safer interface they are recommended
instead, in both C99 and C++ programs where GCC provides them as
an extension.  @xref{Variable Length}, for details.

@end deftypefn

@deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})

You can use the built-in function @code{__builtin_types_compatible_p} to
determine whether two types are the same.

This built-in function returns 1 if the unqualified versions of the
types @var{type1} and @var{type2} (which are types, not expressions) are
compatible, 0 otherwise.  The result of this built-in function can be
used in integer constant expressions.

This built-in function ignores top level qualifiers (e.g., @code{const},
@code{volatile}).  For example, @code{int} is equivalent to @code{const
int}.

The type @code{int[]} and @code{int[5]} are compatible.  On the other
hand, @code{int} and @code{char *} are not compatible, even if the size
of their types, on the particular architecture are the same.  Also, the
amount of pointer indirection is taken into account when determining
similarity.  Consequently, @code{short *} is not similar to
@code{short **}.  Furthermore, two types that are typedefed are
considered compatible if their underlying types are compatible.

An @code{enum} type is not considered to be compatible with another
@code{enum} type even if both are compatible with the same integer
type; this is what the C standard specifies.
For example, @code{enum @{foo, bar@}} is not similar to
@code{enum @{hot, dog@}}.

You typically use this function in code whose execution varies
depending on the arguments' types.  For example:

@smallexample
#define foo(x)                                                  \
  (@{                                                           \
    typeof (x) tmp = (x);                                       \
    if (__builtin_types_compatible_p (typeof (x), long double)) \
      tmp = foo_long_double (tmp);                              \
    else if (__builtin_types_compatible_p (typeof (x), double)) \
      tmp = foo_double (tmp);                                   \
    else if (__builtin_types_compatible_p (typeof (x), float))  \
      tmp = foo_float (tmp);                                    \
    else                                                        \
      abort ();                                                 \
    tmp;                                                        \
  @})
@end smallexample

@emph{Note:} This construct is only available for C@.

@end deftypefn

@deftypefn {Built-in Function} @var{type} __builtin_call_with_static_chain (@var{call_exp}, @var{pointer_exp})

The @var{call_exp} expression must be a function call, and the
@var{pointer_exp} expression must be a pointer.  The @var{pointer_exp}
is passed to the function call in the target's static chain location.
The result of builtin is the result of the function call.

@emph{Note:} This builtin is only available for C@.
This builtin can be used to call Go closures from C.

@end deftypefn

@deftypefn {Built-in Function} @var{type} __builtin_choose_expr (@var{const_exp}, @var{exp1}, @var{exp2})

You can use the built-in function @code{__builtin_choose_expr} to
evaluate code depending on the value of a constant expression.  This
built-in function returns @var{exp1} if @var{const_exp}, which is an
integer constant expression, is nonzero.  Otherwise it returns @var{exp2}.

This built-in function is analogous to the @samp{? :} operator in C,
except that the expression returned has its type unaltered by promotion
rules.  Also, the built-in function does not evaluate the expression
that is not chosen.  For example, if @var{const_exp} evaluates to true,
@var{exp2} is not evaluated even if it has side-effects.

This built-in function can return an lvalue if the chosen argument is an
lvalue.

If @var{exp1} is returned, the return type is the same as @var{exp1}'s
type.  Similarly, if @var{exp2} is returned, its return type is the same
as @var{exp2}.

Example:

@smallexample
#define foo(x)                                                    \
  __builtin_choose_expr (                                         \
    __builtin_types_compatible_p (typeof (x), double),            \
    foo_double (x),                                               \
    __builtin_choose_expr (                                       \
      __builtin_types_compatible_p (typeof (x), float),           \
      foo_float (x),                                              \
      /* @r{The void expression results in a compile-time error}  \
         @r{when assigning the result to something.}  */          \
      (void)0))
@end smallexample

@emph{Note:} This construct is only available for C@.  Furthermore, the
unused expression (@var{exp1} or @var{exp2} depending on the value of
@var{const_exp}) may still generate syntax errors.  This may change in
future revisions.

@end deftypefn

@deftypefn {Built-in Function} @var{type} __builtin_complex (@var{real}, @var{imag})

The built-in function @code{__builtin_complex} is provided for use in
implementing the ISO C11 macros @code{CMPLXF}, @code{CMPLX} and
@code{CMPLXL}.  @var{real} and @var{imag} must have the same type, a
real binary floating-point type, and the result has the corresponding
complex type with real and imaginary parts @var{real} and @var{imag}.
Unlike @samp{@var{real} + I * @var{imag}}, this works even when
infinities, NaNs and negative zeros are involved.

@end deftypefn

@deftypefn {Built-in Function} int __builtin_constant_p (@var{exp})
You can use the built-in function @code{__builtin_constant_p} to
determine if a value is known to be constant at compile time and hence
that GCC can perform constant-folding on expressions involving that
value.  The argument of the function is the value to test.  The function
returns the integer 1 if the argument is known to be a compile-time
constant and 0 if it is not known to be a compile-time constant.  A
return of 0 does not indicate that the value is @emph{not} a constant,
but merely that GCC cannot prove it is a constant with the specified
value of the @option{-O} option.

You typically use this function in an embedded application where
memory is a critical resource.  If you have some complex calculation,
you may want it to be folded if it involves constants, but need to call
a function if it does not.  For example:

@smallexample
#define Scale_Value(X)      \
  (__builtin_constant_p (X) \
  ? ((X) * SCALE + OFFSET) : Scale (X))
@end smallexample

You may use this built-in function in either a macro or an inline
function.  However, if you use it in an inlined function and pass an
argument of the function as the argument to the built-in, GCC 
never returns 1 when you call the inline function with a string constant
or compound literal (@pxref{Compound Literals}) and does not return 1
when you pass a constant numeric value to the inline function unless you
specify the @option{-O} option.

You may also use @code{__builtin_constant_p} in initializers for static
data.  For instance, you can write

@smallexample
static const int table[] = @{
   __builtin_constant_p (EXPRESSION) ? (EXPRESSION) : -1,
   /* @r{@dots{}} */
@};
@end smallexample

@noindent
This is an acceptable initializer even if @var{EXPRESSION} is not a
constant expression, including the case where
@code{__builtin_constant_p} returns 1 because @var{EXPRESSION} can be
folded to a constant but @var{EXPRESSION} contains operands that are
not otherwise permitted in a static initializer (for example,
@code{0 && foo ()}).  GCC must be more conservative about evaluating the
built-in in this case, because it has no opportunity to perform
optimization.
@end deftypefn

@deftypefn {Built-in Function} long __builtin_expect (long @var{exp}, long @var{c})
@opindex fprofile-arcs
You may use @code{__builtin_expect} to provide the compiler with
branch prediction information.  In general, you should prefer to
use actual profile feedback for this (@option{-fprofile-arcs}), as
programmers are notoriously bad at predicting how their programs
actually perform.  However, there are applications in which this
data is hard to collect.

The return value is the value of @var{exp}, which should be an integral
expression.  The semantics of the built-in are that it is expected that
@var{exp} == @var{c}.  For example:

@smallexample
if (__builtin_expect (x, 0))
  foo ();
@end smallexample

@noindent
indicates that we do not expect to call @code{foo}, since
we expect @code{x} to be zero.  Since you are limited to integral
expressions for @var{exp}, you should use constructions such as

@smallexample
if (__builtin_expect (ptr != NULL, 1))
  foo (*ptr);
@end smallexample

@noindent
when testing pointer or floating-point values.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_trap (void)
This function causes the program to exit abnormally.  GCC implements
this function by using a target-dependent mechanism (such as
intentionally executing an illegal instruction) or by calling
@code{abort}.  The mechanism used may vary from release to release so
you should not rely on any particular implementation.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_unreachable (void)
If control flow reaches the point of the @code{__builtin_unreachable},
the program is undefined.  It is useful in situations where the
compiler cannot deduce the unreachability of the code.

One such case is immediately following an @code{asm} statement that
either never terminates, or one that transfers control elsewhere
and never returns.  In this example, without the
@code{__builtin_unreachable}, GCC issues a warning that control
reaches the end of a non-void function.  It also generates code
to return after the @code{asm}.

@smallexample
int f (int c, int v)
@{
  if (c)
    @{
      return v;
    @}
  else
    @{
      asm("jmp error_handler");
      __builtin_unreachable ();
    @}
@}
@end smallexample

@noindent
Because the @code{asm} statement unconditionally transfers control out
of the function, control never reaches the end of the function
body.  The @code{__builtin_unreachable} is in fact unreachable and
communicates this fact to the compiler.

Another use for @code{__builtin_unreachable} is following a call a
function that never returns but that is not declared
@code{__attribute__((noreturn))}, as in this example:

@smallexample
void function_that_never_returns (void);

int g (int c)
@{
  if (c)
    @{
      return 1;
    @}
  else
    @{
      function_that_never_returns ();
      __builtin_unreachable ();
    @}
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_assume_aligned (const void *@var{exp}, size_t @var{align}, ...)
This function returns its first argument, and allows the compiler
to assume that the returned pointer is at least @var{align} bytes
aligned.  This built-in can have either two or three arguments,
if it has three, the third argument should have integer type, and
if it is nonzero means misalignment offset.  For example:

@smallexample
void *x = __builtin_assume_aligned (arg, 16);
@end smallexample

@noindent
means that the compiler can assume @code{x}, set to @code{arg}, is at least
16-byte aligned, while:

@smallexample
void *x = __builtin_assume_aligned (arg, 32, 8);
@end smallexample

@noindent
means that the compiler can assume for @code{x}, set to @code{arg}, that
@code{(char *) x - 8} is 32-byte aligned.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_LINE ()
This function is the equivalent of the preprocessor @code{__LINE__}
macro and returns a constant integer expression that evaluates to
the line number of the invocation of the built-in.  When used as a C++
default argument for a function @var{F}, it returns the line number
of the call to @var{F}.
@end deftypefn

@deftypefn {Built-in Function} {const char *} __builtin_FUNCTION ()
This function is the equivalent of the @code{__FUNCTION__} symbol
and returns an address constant pointing to the name of the function
from which the built-in was invoked, or the empty string if
the invocation is not at function scope.  When used as a C++ default
argument for a function @var{F}, it returns the name of @var{F}'s
caller or the empty string if the call was not made at function
scope.
@end deftypefn

@deftypefn {Built-in Function} {const char *} __builtin_FILE ()
This function is the equivalent of the preprocessor @code{__FILE__}
macro and returns an address constant pointing to the file name
containing the invocation of the built-in, or the empty string if
the invocation is not at function scope.  When used as a C++ default
argument for a function @var{F}, it returns the file name of the call
to @var{F} or the empty string if the call was not made at function
scope.

For example, in the following, each call to function @code{foo} will
print a line similar to @code{"file.c:123: foo: message"} with the name
of the file and the line number of the @code{printf} call, the name of
the function @code{foo}, followed by the word @code{message}.

@smallexample
const char*
function (const char *func = __builtin_FUNCTION ())
@{
  return func;
@}

void foo (void)
@{
  printf ("%s:%i: %s: message\n", file (), line (), function ());
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} void __builtin___clear_cache (char *@var{begin}, char *@var{end})
This function is used to flush the processor's instruction cache for
the region of memory between @var{begin} inclusive and @var{end}
exclusive.  Some targets require that the instruction cache be
flushed, after modifying memory containing code, in order to obtain
deterministic behavior.

If the target does not require instruction cache flushes,
@code{__builtin___clear_cache} has no effect.  Otherwise either
instructions are emitted in-line to clear the instruction cache or a
call to the @code{__clear_cache} function in libgcc is made.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_prefetch (const void *@var{addr}, ...)
This function is used to minimize cache-miss latency by moving data into
a cache before it is accessed.
You can insert calls to @code{__builtin_prefetch} into code for which
you know addresses of data in memory that is likely to be accessed soon.
If the target supports them, data prefetch instructions are generated.
If the prefetch is done early enough before the access then the data will
be in the cache by the time it is accessed.

The value of @var{addr} is the address of the memory to prefetch.
There are two optional arguments, @var{rw} and @var{locality}.
The value of @var{rw} is a compile-time constant one or zero; one
means that the prefetch is preparing for a write to the memory address
and zero, the default, means that the prefetch is preparing for a read.
The value @var{locality} must be a compile-time constant integer between
zero and three.  A value of zero means that the data has no temporal
locality, so it need not be left in the cache after the access.  A value
of three means that the data has a high degree of temporal locality and
should be left in all levels of cache possible.  Values of one and two
mean, respectively, a low or moderate degree of temporal locality.  The
default is three.

@smallexample
for (i = 0; i < n; i++)
  @{
    a[i] = a[i] + b[i];
    __builtin_prefetch (&a[i+j], 1, 1);
    __builtin_prefetch (&b[i+j], 0, 1);
    /* @r{@dots{}} */
  @}
@end smallexample

Data prefetch does not generate faults if @var{addr} is invalid, but
the address expression itself must be valid.  For example, a prefetch
of @code{p->next} does not fault if @code{p->next} is not a valid
address, but evaluation faults if @code{p} is not a valid address.

If the target does not support data prefetch, the address expression
is evaluated if it includes side effects but no other code is generated
and GCC does not issue a warning.
@end deftypefn

@deftypefn {Built-in Function} double __builtin_huge_val (void)
Returns a positive infinity, if supported by the floating-point format,
else @code{DBL_MAX}.  This function is suitable for implementing the
ISO C macro @code{HUGE_VAL}.
@end deftypefn

@deftypefn {Built-in Function} float __builtin_huge_valf (void)
Similar to @code{__builtin_huge_val}, except the return type is @code{float}.
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_huge_vall (void)
Similar to @code{__builtin_huge_val}, except the return
type is @code{long double}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_huge_valf@var{n} (void)
Similar to @code{__builtin_huge_val}, except the return type is
@code{_Float@var{n}}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n}x __builtin_huge_valf@var{n}x (void)
Similar to @code{__builtin_huge_val}, except the return type is
@code{_Float@var{n}x}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_fpclassify (int, int, int, int, int, ...)
This built-in implements the C99 fpclassify functionality.  The first
five int arguments should be the target library's notion of the
possible FP classes and are used for return values.  They must be
constant values and they must appear in this order: @code{FP_NAN},
@code{FP_INFINITE}, @code{FP_NORMAL}, @code{FP_SUBNORMAL} and
@code{FP_ZERO}.  The ellipsis is for exactly one floating-point value
to classify.  GCC treats the last argument as type-generic, which
means it does not do default promotion from float to double.
@end deftypefn

@deftypefn {Built-in Function} double __builtin_inf (void)
Similar to @code{__builtin_huge_val}, except a warning is generated
if the target floating-point format does not support infinities.
@end deftypefn

@deftypefn {Built-in Function} _Decimal32 __builtin_infd32 (void)
Similar to @code{__builtin_inf}, except the return type is @code{_Decimal32}.
@end deftypefn

@deftypefn {Built-in Function} _Decimal64 __builtin_infd64 (void)
Similar to @code{__builtin_inf}, except the return type is @code{_Decimal64}.
@end deftypefn

@deftypefn {Built-in Function} _Decimal128 __builtin_infd128 (void)
Similar to @code{__builtin_inf}, except the return type is @code{_Decimal128}.
@end deftypefn

@deftypefn {Built-in Function} float __builtin_inff (void)
Similar to @code{__builtin_inf}, except the return type is @code{float}.
This function is suitable for implementing the ISO C99 macro @code{INFINITY}.
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_infl (void)
Similar to @code{__builtin_inf}, except the return
type is @code{long double}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_inff@var{n} (void)
Similar to @code{__builtin_inf}, except the return
type is @code{_Float@var{n}}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_inff@var{n}x (void)
Similar to @code{__builtin_inf}, except the return
type is @code{_Float@var{n}x}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_isinf_sign (...)
Similar to @code{isinf}, except the return value is -1 for
an argument of @code{-Inf} and 1 for an argument of @code{+Inf}.
Note while the parameter list is an
ellipsis, this function only accepts exactly one floating-point
argument.  GCC treats this parameter as type-generic, which means it
does not do default promotion from float to double.
@end deftypefn

@deftypefn {Built-in Function} double __builtin_nan (const char *str)
This is an implementation of the ISO C99 function @code{nan}.

Since ISO C99 defines this function in terms of @code{strtod}, which we
do not implement, a description of the parsing is in order.  The string
is parsed as by @code{strtol}; that is, the base is recognized by
leading @samp{0} or @samp{0x} prefixes.  The number parsed is placed
in the significand such that the least significant bit of the number
is at the least significant bit of the significand.  The number is
truncated to fit the significand field provided.  The significand is
forced to be a quiet NaN@.

This function, if given a string literal all of which would have been
consumed by @code{strtol}, is evaluated early enough that it is considered a
compile-time constant.
@end deftypefn

@deftypefn {Built-in Function} _Decimal32 __builtin_nand32 (const char *str)
Similar to @code{__builtin_nan}, except the return type is @code{_Decimal32}.
@end deftypefn

@deftypefn {Built-in Function} _Decimal64 __builtin_nand64 (const char *str)
Similar to @code{__builtin_nan}, except the return type is @code{_Decimal64}.
@end deftypefn

@deftypefn {Built-in Function} _Decimal128 __builtin_nand128 (const char *str)
Similar to @code{__builtin_nan}, except the return type is @code{_Decimal128}.
@end deftypefn

@deftypefn {Built-in Function} float __builtin_nanf (const char *str)
Similar to @code{__builtin_nan}, except the return type is @code{float}.
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_nanl (const char *str)
Similar to @code{__builtin_nan}, except the return type is @code{long double}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_nanf@var{n} (const char *str)
Similar to @code{__builtin_nan}, except the return type is
@code{_Float@var{n}}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n}x __builtin_nanf@var{n}x (const char *str)
Similar to @code{__builtin_nan}, except the return type is
@code{_Float@var{n}x}.
@end deftypefn

@deftypefn {Built-in Function} double __builtin_nans (const char *str)
Similar to @code{__builtin_nan}, except the significand is forced
to be a signaling NaN@.  The @code{nans} function is proposed by
@uref{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm,,WG14 N965}.
@end deftypefn

@deftypefn {Built-in Function} float __builtin_nansf (const char *str)
Similar to @code{__builtin_nans}, except the return type is @code{float}.
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_nansl (const char *str)
Similar to @code{__builtin_nans}, except the return type is @code{long double}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_nansf@var{n} (const char *str)
Similar to @code{__builtin_nans}, except the return type is
@code{_Float@var{n}}.
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n}x __builtin_nansf@var{n}x (const char *str)
Similar to @code{__builtin_nans}, except the return type is
@code{_Float@var{n}x}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ffs (int x)
Returns one plus the index of the least significant 1-bit of @var{x}, or
if @var{x} is zero, returns zero.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clz (unsigned int x)
Returns the number of leading 0-bits in @var{x}, starting at the most
significant bit position.  If @var{x} is 0, the result is undefined.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ctz (unsigned int x)
Returns the number of trailing 0-bits in @var{x}, starting at the least
significant bit position.  If @var{x} is 0, the result is undefined.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clrsb (int x)
Returns the number of leading redundant sign bits in @var{x}, i.e.@: the
number of bits following the most significant bit that are identical
to it.  There are no special cases for 0 or other values. 
@end deftypefn

@deftypefn {Built-in Function} int __builtin_popcount (unsigned int x)
Returns the number of 1-bits in @var{x}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_parity (unsigned int x)
Returns the parity of @var{x}, i.e.@: the number of 1-bits in @var{x}
modulo 2.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ffsl (long)
Similar to @code{__builtin_ffs}, except the argument type is
@code{long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clzl (unsigned long)
Similar to @code{__builtin_clz}, except the argument type is
@code{unsigned long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ctzl (unsigned long)
Similar to @code{__builtin_ctz}, except the argument type is
@code{unsigned long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clrsbl (long)
Similar to @code{__builtin_clrsb}, except the argument type is
@code{long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_popcountl (unsigned long)
Similar to @code{__builtin_popcount}, except the argument type is
@code{unsigned long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_parityl (unsigned long)
Similar to @code{__builtin_parity}, except the argument type is
@code{unsigned long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ffsll (long long)
Similar to @code{__builtin_ffs}, except the argument type is
@code{long long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clzll (unsigned long long)
Similar to @code{__builtin_clz}, except the argument type is
@code{unsigned long long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ctzll (unsigned long long)
Similar to @code{__builtin_ctz}, except the argument type is
@code{unsigned long long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clrsbll (long long)
Similar to @code{__builtin_clrsb}, except the argument type is
@code{long long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_popcountll (unsigned long long)
Similar to @code{__builtin_popcount}, except the argument type is
@code{unsigned long long}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_parityll (unsigned long long)
Similar to @code{__builtin_parity}, except the argument type is
@code{unsigned long long}.
@end deftypefn

@deftypefn {Built-in Function} double __builtin_powi (double, int)
Returns the first argument raised to the power of the second.  Unlike the
@code{pow} function no guarantees about precision and rounding are made.
@end deftypefn

@deftypefn {Built-in Function} float __builtin_powif (float, int)
Similar to @code{__builtin_powi}, except the argument and return types
are @code{float}.
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_powil (long double, int)
Similar to @code{__builtin_powi}, except the argument and return types
are @code{long double}.
@end deftypefn

@deftypefn {Built-in Function} uint16_t __builtin_bswap16 (uint16_t x)
Returns @var{x} with the order of the bytes reversed; for example,
@code{0xaabb} becomes @code{0xbbaa}.  Byte here always means
exactly 8 bits.
@end deftypefn

@deftypefn {Built-in Function} uint32_t __builtin_bswap32 (uint32_t x)
Similar to @code{__builtin_bswap16}, except the argument and return types
are 32 bit.
@end deftypefn

@deftypefn {Built-in Function} uint64_t __builtin_bswap64 (uint64_t x)
Similar to @code{__builtin_bswap32}, except the argument and return types
are 64 bit.
@end deftypefn

@node Target Builtins
@section Built-in Functions Specific to Particular Target Machines

On some target machines, GCC supports many built-in functions specific
to those machines.  Generally these generate calls to specific machine
instructions, but allow the compiler to schedule those calls.

@menu
* AArch64 Built-in Functions::
* Alpha Built-in Functions::
* Altera Nios II Built-in Functions::
* ARC Built-in Functions::
* ARC SIMD Built-in Functions::
* ARM iWMMXt Built-in Functions::
* ARM C Language Extensions (ACLE)::
* ARM Floating Point Status and Control Intrinsics::
* ARM ARMv8-M Security Extensions::
* AVR Built-in Functions::
* Blackfin Built-in Functions::
* FR-V Built-in Functions::
* MIPS DSP Built-in Functions::
* MIPS Paired-Single Support::
* MIPS Loongson Built-in Functions::
* MIPS SIMD Architecture (MSA) Support::
* Other MIPS Built-in Functions::
* MSP430 Built-in Functions::
* NDS32 Built-in Functions::
* picoChip Built-in Functions::
* PowerPC Built-in Functions::
* PowerPC AltiVec/VSX Built-in Functions::
* PowerPC Hardware Transactional Memory Built-in Functions::
* RX Built-in Functions::
* S/390 System z Built-in Functions::
* SH Built-in Functions::
* SPARC VIS Built-in Functions::
* SPU Built-in Functions::
* TI C6X Built-in Functions::
* TILE-Gx Built-in Functions::
* TILEPro Built-in Functions::
* x86 Built-in Functions::
* x86 transactional memory intrinsics::
@end menu

@node AArch64 Built-in Functions
@subsection AArch64 Built-in Functions

These built-in functions are available for the AArch64 family of
processors.
@smallexample
unsigned int __builtin_aarch64_get_fpcr ()
void __builtin_aarch64_set_fpcr (unsigned int)
unsigned int __builtin_aarch64_get_fpsr ()
void __builtin_aarch64_set_fpsr (unsigned int)
@end smallexample

@node Alpha Built-in Functions
@subsection Alpha Built-in Functions

These built-in functions are available for the Alpha family of
processors, depending on the command-line switches used.

The following built-in functions are always available.  They
all generate the machine instruction that is part of the name.

@smallexample
long __builtin_alpha_implver (void)
long __builtin_alpha_rpcc (void)
long __builtin_alpha_amask (long)
long __builtin_alpha_cmpbge (long, long)
long __builtin_alpha_extbl (long, long)
long __builtin_alpha_extwl (long, long)
long __builtin_alpha_extll (long, long)
long __builtin_alpha_extql (long, long)
long __builtin_alpha_extwh (long, long)
long __builtin_alpha_extlh (long, long)
long __builtin_alpha_extqh (long, long)
long __builtin_alpha_insbl (long, long)
long __builtin_alpha_inswl (long, long)
long __builtin_alpha_insll (long, long)
long __builtin_alpha_insql (long, long)
long __builtin_alpha_inswh (long, long)
long __builtin_alpha_inslh (long, long)
long __builtin_alpha_insqh (long, long)
long __builtin_alpha_mskbl (long, long)
long __builtin_alpha_mskwl (long, long)
long __builtin_alpha_mskll (long, long)
long __builtin_alpha_mskql (long, long)
long __builtin_alpha_mskwh (long, long)
long __builtin_alpha_msklh (long, long)
long __builtin_alpha_mskqh (long, long)
long __builtin_alpha_umulh (long, long)
long __builtin_alpha_zap (long, long)
long __builtin_alpha_zapnot (long, long)
@end smallexample

The following built-in functions are always with @option{-mmax}
or @option{-mcpu=@var{cpu}} where @var{cpu} is @code{pca56} or
later.  They all generate the machine instruction that is part
of the name.

@smallexample
long __builtin_alpha_pklb (long)
long __builtin_alpha_pkwb (long)
long __builtin_alpha_unpkbl (long)
long __builtin_alpha_unpkbw (long)
long __builtin_alpha_minub8 (long, long)
long __builtin_alpha_minsb8 (long, long)
long __builtin_alpha_minuw4 (long, long)
long __builtin_alpha_minsw4 (long, long)
long __builtin_alpha_maxub8 (long, long)
long __builtin_alpha_maxsb8 (long, long)
long __builtin_alpha_maxuw4 (long, long)
long __builtin_alpha_maxsw4 (long, long)
long __builtin_alpha_perr (long, long)
@end smallexample

The following built-in functions are always with @option{-mcix}
or @option{-mcpu=@var{cpu}} where @var{cpu} is @code{ev67} or
later.  They all generate the machine instruction that is part
of the name.

@smallexample
long __builtin_alpha_cttz (long)
long __builtin_alpha_ctlz (long)
long __builtin_alpha_ctpop (long)
@end smallexample

The following built-in functions are available on systems that use the OSF/1
PALcode.  Normally they invoke the @code{rduniq} and @code{wruniq}
PAL calls, but when invoked with @option{-mtls-kernel}, they invoke
@code{rdval} and @code{wrval}.

@smallexample
void *__builtin_thread_pointer (void)
void __builtin_set_thread_pointer (void *)
@end smallexample

@node Altera Nios II Built-in Functions
@subsection Altera Nios II Built-in Functions

These built-in functions are available for the Altera Nios II
family of processors.

The following built-in functions are always available.  They
all generate the machine instruction that is part of the name.

@example
int __builtin_ldbio (volatile const void *)
int __builtin_ldbuio (volatile const void *)
int __builtin_ldhio (volatile const void *)
int __builtin_ldhuio (volatile const void *)
int __builtin_ldwio (volatile const void *)
void __builtin_stbio (volatile void *, int)
void __builtin_sthio (volatile void *, int)
void __builtin_stwio (volatile void *, int)
void __builtin_sync (void)
int __builtin_rdctl (int) 
int __builtin_rdprs (int, int)
void __builtin_wrctl (int, int)
void __builtin_flushd (volatile void *)
void __builtin_flushda (volatile void *)
int __builtin_wrpie (int);
void __builtin_eni (int);
int __builtin_ldex (volatile const void *)
int __builtin_stex (volatile void *, int)
int __builtin_ldsex (volatile const void *)
int __builtin_stsex (volatile void *, int)
@end example

The following built-in functions are always available.  They
all generate a Nios II Custom Instruction. The name of the
function represents the types that the function takes and
returns. The letter before the @code{n} is the return type
or void if absent. The @code{n} represents the first parameter
to all the custom instructions, the custom instruction number.
The two letters after the @code{n} represent the up to two
parameters to the function.

The letters represent the following data types:
@table @code
@item <no letter>
@code{void} for return type and no parameter for parameter types.

@item i
@code{int} for return type and parameter type

@item f
@code{float} for return type and parameter type

@item p
@code{void *} for return type and parameter type

@end table

And the function names are:
@example
void __builtin_custom_n (void)
void __builtin_custom_ni (int)
void __builtin_custom_nf (float)
void __builtin_custom_np (void *)
void __builtin_custom_nii (int, int)
void __builtin_custom_nif (int, float)
void __builtin_custom_nip (int, void *)
void __builtin_custom_nfi (float, int)
void __builtin_custom_nff (float, float)
void __builtin_custom_nfp (float, void *)
void __builtin_custom_npi (void *, int)
void __builtin_custom_npf (void *, float)
void __builtin_custom_npp (void *, void *)
int __builtin_custom_in (void)
int __builtin_custom_ini (int)
int __builtin_custom_inf (float)
int __builtin_custom_inp (void *)
int __builtin_custom_inii (int, int)
int __builtin_custom_inif (int, float)
int __builtin_custom_inip (int, void *)
int __builtin_custom_infi (float, int)
int __builtin_custom_inff (float, float)
int __builtin_custom_infp (float, void *)
int __builtin_custom_inpi (void *, int)
int __builtin_custom_inpf (void *, float)
int __builtin_custom_inpp (void *, void *)
float __builtin_custom_fn (void)
float __builtin_custom_fni (int)
float __builtin_custom_fnf (float)
float __builtin_custom_fnp (void *)
float __builtin_custom_fnii (int, int)
float __builtin_custom_fnif (int, float)
float __builtin_custom_fnip (int, void *)
float __builtin_custom_fnfi (float, int)
float __builtin_custom_fnff (float, float)
float __builtin_custom_fnfp (float, void *)
float __builtin_custom_fnpi (void *, int)
float __builtin_custom_fnpf (void *, float)
float __builtin_custom_fnpp (void *, void *)
void * __builtin_custom_pn (void)
void * __builtin_custom_pni (int)
void * __builtin_custom_pnf (float)
void * __builtin_custom_pnp (void *)
void * __builtin_custom_pnii (int, int)
void * __builtin_custom_pnif (int, float)
void * __builtin_custom_pnip (int, void *)
void * __builtin_custom_pnfi (float, int)
void * __builtin_custom_pnff (float, float)
void * __builtin_custom_pnfp (float, void *)
void * __builtin_custom_pnpi (void *, int)
void * __builtin_custom_pnpf (void *, float)
void * __builtin_custom_pnpp (void *, void *)
@end example

@node ARC Built-in Functions
@subsection ARC Built-in Functions

The following built-in functions are provided for ARC targets.  The
built-ins generate the corresponding assembly instructions.  In the
examples given below, the generated code often requires an operand or
result to be in a register.  Where necessary further code will be
generated to ensure this is true, but for brevity this is not
described in each case.

@emph{Note:} Using a built-in to generate an instruction not supported
by a target may cause problems. At present the compiler is not
guaranteed to detect such misuse, and as a result an internal compiler
error may be generated.

@deftypefn {Built-in Function} int __builtin_arc_aligned (void *@var{val}, int @var{alignval})
Return 1 if @var{val} is known to have the byte alignment given
by @var{alignval}, otherwise return 0.
Note that this is different from
@smallexample
__alignof__(*(char *)@var{val}) >= alignval
@end smallexample
because __alignof__ sees only the type of the dereference, whereas
__builtin_arc_align uses alignment information from the pointer
as well as from the pointed-to type.
The information available will depend on optimization level.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_brk (void)
Generates
@example
brk
@end example
@end deftypefn

@deftypefn {Built-in Function} {unsigned int} __builtin_arc_core_read (unsigned int @var{regno})
The operand is the number of a register to be read.  Generates:
@example
mov  @var{dest}, r@var{regno}
@end example
where the value in @var{dest} will be the result returned from the
built-in.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_core_write (unsigned int @var{regno}, unsigned int @var{val})
The first operand is the number of a register to be written, the
second operand is a compile time constant to write into that
register.  Generates:
@example
mov  r@var{regno}, @var{val}
@end example
@end deftypefn

@deftypefn {Built-in Function} int __builtin_arc_divaw (int @var{a}, int @var{b})
Only available if either @option{-mcpu=ARC700} or @option{-meA} is set.
Generates:
@example
divaw  @var{dest}, @var{a}, @var{b}
@end example
where the value in @var{dest} will be the result returned from the
built-in.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_flag (unsigned int @var{a})
Generates
@example
flag  @var{a}
@end example
@end deftypefn

@deftypefn {Built-in Function} {unsigned int} __builtin_arc_lr (unsigned int @var{auxr})
The operand, @var{auxv}, is the address of an auxiliary register and
must be a compile time constant.  Generates:
@example
lr  @var{dest}, [@var{auxr}]
@end example
Where the value in @var{dest} will be the result returned from the
built-in.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_mul64 (int @var{a}, int @var{b})
Only available with @option{-mmul64}.  Generates:
@example
mul64  @var{a}, @var{b}
@end example
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_mulu64 (unsigned int @var{a}, unsigned int @var{b})
Only available with @option{-mmul64}.  Generates:
@example
mulu64  @var{a}, @var{b}
@end example
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_nop (void)
Generates:
@example
nop
@end example
@end deftypefn

@deftypefn {Built-in Function} int __builtin_arc_norm (int @var{src})
Only valid if the @samp{norm} instruction is available through the
@option{-mnorm} option or by default with @option{-mcpu=ARC700}.
Generates:
@example
norm  @var{dest}, @var{src}
@end example
Where the value in @var{dest} will be the result returned from the
built-in.
@end deftypefn

@deftypefn {Built-in Function}  {short int} __builtin_arc_normw (short int @var{src})
Only valid if the @samp{normw} instruction is available through the
@option{-mnorm} option or by default with @option{-mcpu=ARC700}.
Generates:
@example
normw  @var{dest}, @var{src}
@end example
Where the value in @var{dest} will be the result returned from the
built-in.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_rtie (void)
Generates:
@example
rtie
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_sleep (int @var{a}
Generates:
@example
sleep  @var{a}
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_sr (unsigned int @var{auxr}, unsigned int @var{val})
The first argument, @var{auxv}, is the address of an auxiliary
register, the second argument, @var{val}, is a compile time constant
to be written to the register.  Generates:
@example
sr  @var{auxr}, [@var{val}]
@end example
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_arc_swap (int @var{src})
Only valid with @option{-mswap}.  Generates:
@example
swap  @var{dest}, @var{src}
@end example
Where the value in @var{dest} will be the result returned from the
built-in.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_swi (void)
Generates:
@example
swi
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_sync (void)
Only available with @option{-mcpu=ARC700}.  Generates:
@example
sync
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_trap_s (unsigned int @var{c})
Only available with @option{-mcpu=ARC700}.  Generates:
@example
trap_s  @var{c}
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_unimp_s (void)
Only available with @option{-mcpu=ARC700}.  Generates:
@example
unimp_s
@end example
@end deftypefn

The instructions generated by the following builtins are not
considered as candidates for scheduling.  They are not moved around by
the compiler during scheduling, and thus can be expected to appear
where they are put in the C code:
@example
__builtin_arc_brk()
__builtin_arc_core_read()
__builtin_arc_core_write()
__builtin_arc_flag()
__builtin_arc_lr()
__builtin_arc_sleep()
__builtin_arc_sr()
__builtin_arc_swi()
@end example

@node ARC SIMD Built-in Functions
@subsection ARC SIMD Built-in Functions

SIMD builtins provided by the compiler can be used to generate the
vector instructions.  This section describes the available builtins
and their usage in programs.  With the @option{-msimd} option, the
compiler provides 128-bit vector types, which can be specified using
the @code{vector_size} attribute.  The header file @file{arc-simd.h}
can be included to use the following predefined types:
@example
typedef int __v4si   __attribute__((vector_size(16)));
typedef short __v8hi __attribute__((vector_size(16)));
@end example

These types can be used to define 128-bit variables.  The built-in
functions listed in the following section can be used on these
variables to generate the vector operations.

For all builtins, @code{__builtin_arc_@var{someinsn}}, the header file
@file{arc-simd.h} also provides equivalent macros called
@code{_@var{someinsn}} that can be used for programming ease and
improved readability.  The following macros for DMA control are also
provided:
@example
#define _setup_dma_in_channel_reg _vdiwr
#define _setup_dma_out_channel_reg _vdowr
@end example

The following is a complete list of all the SIMD built-ins provided
for ARC, grouped by calling signature.

The following take two @code{__v8hi} arguments and return a
@code{__v8hi} result:
@example
__v8hi __builtin_arc_vaddaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vaddw (__v8hi, __v8hi)
__v8hi __builtin_arc_vand (__v8hi, __v8hi)
__v8hi __builtin_arc_vandaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vavb (__v8hi, __v8hi)
__v8hi __builtin_arc_vavrb (__v8hi, __v8hi)
__v8hi __builtin_arc_vbic (__v8hi, __v8hi)
__v8hi __builtin_arc_vbicaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vdifaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vdifw (__v8hi, __v8hi)
__v8hi __builtin_arc_veqw (__v8hi, __v8hi)
__v8hi __builtin_arc_vh264f (__v8hi, __v8hi)
__v8hi __builtin_arc_vh264ft (__v8hi, __v8hi)
__v8hi __builtin_arc_vh264fw (__v8hi, __v8hi)
__v8hi __builtin_arc_vlew (__v8hi, __v8hi)
__v8hi __builtin_arc_vltw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmaxaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmaxw (__v8hi, __v8hi)
__v8hi __builtin_arc_vminaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vminw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr1aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr1w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr2aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr2w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr3aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr3w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr4aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr4w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr5aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr5w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr6aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr6w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr7aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr7w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmrb (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulfaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulfw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulw (__v8hi, __v8hi)
__v8hi __builtin_arc_vnew (__v8hi, __v8hi)
__v8hi __builtin_arc_vor (__v8hi, __v8hi)
__v8hi __builtin_arc_vsubaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vsubw (__v8hi, __v8hi)
__v8hi __builtin_arc_vsummw (__v8hi, __v8hi)
__v8hi __builtin_arc_vvc1f (__v8hi, __v8hi)
__v8hi __builtin_arc_vvc1ft (__v8hi, __v8hi)
__v8hi __builtin_arc_vxor (__v8hi, __v8hi)
__v8hi __builtin_arc_vxoraw (__v8hi, __v8hi)
@end example

The following take one @code{__v8hi} and one @code{int} argument and return a
@code{__v8hi} result:

@example
__v8hi __builtin_arc_vbaddw (__v8hi, int)
__v8hi __builtin_arc_vbmaxw (__v8hi, int)
__v8hi __builtin_arc_vbminw (__v8hi, int)
__v8hi __builtin_arc_vbmulaw (__v8hi, int)
__v8hi __builtin_arc_vbmulfw (__v8hi, int)
__v8hi __builtin_arc_vbmulw (__v8hi, int)
__v8hi __builtin_arc_vbrsubw (__v8hi, int)
__v8hi __builtin_arc_vbsubw (__v8hi, int)
@end example

The following take one @code{__v8hi} argument and one @code{int} argument which
must be a 3-bit compile time constant indicating a register number
I0-I7.  They return a @code{__v8hi} result.
@example
__v8hi __builtin_arc_vasrw (__v8hi, const int)
__v8hi __builtin_arc_vsr8 (__v8hi, const int)
__v8hi __builtin_arc_vsr8aw (__v8hi, const int)
@end example

The following take one @code{__v8hi} argument and one @code{int}
argument which must be a 6-bit compile time constant.  They return a
@code{__v8hi} result.
@example
__v8hi __builtin_arc_vasrpwbi (__v8hi, const int)
__v8hi __builtin_arc_vasrrpwbi (__v8hi, const int)
__v8hi __builtin_arc_vasrrwi (__v8hi, const int)
__v8hi __builtin_arc_vasrsrwi (__v8hi, const int)
__v8hi __builtin_arc_vasrwi (__v8hi, const int)
__v8hi __builtin_arc_vsr8awi (__v8hi, const int)
__v8hi __builtin_arc_vsr8i (__v8hi, const int)
@end example

The following take one @code{__v8hi} argument and one @code{int} argument which
must be a 8-bit compile time constant.  They return a @code{__v8hi}
result.
@example
__v8hi __builtin_arc_vd6tapf (__v8hi, const int)
__v8hi __builtin_arc_vmvaw (__v8hi, const int)
__v8hi __builtin_arc_vmvw (__v8hi, const int)
__v8hi __builtin_arc_vmvzw (__v8hi, const int)
@end example

The following take two @code{int} arguments, the second of which which
must be a 8-bit compile time constant.  They return a @code{__v8hi}
result:
@example
__v8hi __builtin_arc_vmovaw (int, const int)
__v8hi __builtin_arc_vmovw (int, const int)
__v8hi __builtin_arc_vmovzw (int, const int)
@end example

The following take a single @code{__v8hi} argument and return a
@code{__v8hi} result:
@example
__v8hi __builtin_arc_vabsaw (__v8hi)
__v8hi __builtin_arc_vabsw (__v8hi)
__v8hi __builtin_arc_vaddsuw (__v8hi)
__v8hi __builtin_arc_vexch1 (__v8hi)
__v8hi __builtin_arc_vexch2 (__v8hi)
__v8hi __builtin_arc_vexch4 (__v8hi)
__v8hi __builtin_arc_vsignw (__v8hi)
__v8hi __builtin_arc_vupbaw (__v8hi)
__v8hi __builtin_arc_vupbw (__v8hi)
__v8hi __builtin_arc_vupsbaw (__v8hi)
__v8hi __builtin_arc_vupsbw (__v8hi)
@end example

The following take two @code{int} arguments and return no result:
@example
void __builtin_arc_vdirun (int, int)
void __builtin_arc_vdorun (int, int)
@end example

The following take two @code{int} arguments and return no result.  The
first argument must a 3-bit compile time constant indicating one of
the DR0-DR7 DMA setup channels:
@example
void __builtin_arc_vdiwr (const int, int)
void __builtin_arc_vdowr (const int, int)
@end example

The following take an @code{int} argument and return no result:
@example
void __builtin_arc_vendrec (int)
void __builtin_arc_vrec (int)
void __builtin_arc_vrecrun (int)
void __builtin_arc_vrun (int)
@end example

The following take a @code{__v8hi} argument and two @code{int}
arguments and return a @code{__v8hi} result.  The second argument must
be a 3-bit compile time constants, indicating one the registers I0-I7,
and the third argument must be an 8-bit compile time constant.

@emph{Note:} Although the equivalent hardware instructions do not take
an SIMD register as an operand, these builtins overwrite the relevant
bits of the @code{__v8hi} register provided as the first argument with
the value loaded from the @code{[Ib, u8]} location in the SDM.

@example
__v8hi __builtin_arc_vld32 (__v8hi, const int, const int)
__v8hi __builtin_arc_vld32wh (__v8hi, const int, const int)
__v8hi __builtin_arc_vld32wl (__v8hi, const int, const int)
__v8hi __builtin_arc_vld64 (__v8hi, const int, const int)
@end example

The following take two @code{int} arguments and return a @code{__v8hi}
result.  The first argument must be a 3-bit compile time constants,
indicating one the registers I0-I7, and the second argument must be an
8-bit compile time constant.

@example
__v8hi __builtin_arc_vld128 (const int, const int)
__v8hi __builtin_arc_vld64w (const int, const int)
@end example

The following take a @code{__v8hi} argument and two @code{int}
arguments and return no result.  The second argument must be a 3-bit
compile time constants, indicating one the registers I0-I7, and the
third argument must be an 8-bit compile time constant.

@example
void __builtin_arc_vst128 (__v8hi, const int, const int)
void __builtin_arc_vst64 (__v8hi, const int, const int)
@end example

The following take a @code{__v8hi} argument and three @code{int}
arguments and return no result.  The second argument must be a 3-bit
compile-time constant, identifying the 16-bit sub-register to be
stored, the third argument must be a 3-bit compile time constants,
indicating one the registers I0-I7, and the fourth argument must be an
8-bit compile time constant.

@example
void __builtin_arc_vst16_n (__v8hi, const int, const int, const int)
void __builtin_arc_vst32_n (__v8hi, const int, const int, const int)
@end example

@node ARM iWMMXt Built-in Functions
@subsection ARM iWMMXt Built-in Functions

These built-in functions are available for the ARM family of
processors when the @option{-mcpu=iwmmxt} switch is used:

@smallexample
typedef int v2si __attribute__ ((vector_size (8)));
typedef short v4hi __attribute__ ((vector_size (8)));
typedef char v8qi __attribute__ ((vector_size (8)));

int __builtin_arm_getwcgr0 (void)
void __builtin_arm_setwcgr0 (int)
int __builtin_arm_getwcgr1 (void)
void __builtin_arm_setwcgr1 (int)
int __builtin_arm_getwcgr2 (void)
void __builtin_arm_setwcgr2 (int)
int __builtin_arm_getwcgr3 (void)
void __builtin_arm_setwcgr3 (int)
int __builtin_arm_textrmsb (v8qi, int)
int __builtin_arm_textrmsh (v4hi, int)
int __builtin_arm_textrmsw (v2si, int)
int __builtin_arm_textrmub (v8qi, int)
int __builtin_arm_textrmuh (v4hi, int)
int __builtin_arm_textrmuw (v2si, int)
v8qi __builtin_arm_tinsrb (v8qi, int, int)
v4hi __builtin_arm_tinsrh (v4hi, int, int)
v2si __builtin_arm_tinsrw (v2si, int, int)
long long __builtin_arm_tmia (long long, int, int)
long long __builtin_arm_tmiabb (long long, int, int)
long long __builtin_arm_tmiabt (long long, int, int)
long long __builtin_arm_tmiaph (long long, int, int)
long long __builtin_arm_tmiatb (long long, int, int)
long long __builtin_arm_tmiatt (long long, int, int)
int __builtin_arm_tmovmskb (v8qi)
int __builtin_arm_tmovmskh (v4hi)
int __builtin_arm_tmovmskw (v2si)
long long __builtin_arm_waccb (v8qi)
long long __builtin_arm_wacch (v4hi)
long long __builtin_arm_waccw (v2si)
v8qi __builtin_arm_waddb (v8qi, v8qi)
v8qi __builtin_arm_waddbss (v8qi, v8qi)
v8qi __builtin_arm_waddbus (v8qi, v8qi)
v4hi __builtin_arm_waddh (v4hi, v4hi)
v4hi __builtin_arm_waddhss (v4hi, v4hi)
v4hi __builtin_arm_waddhus (v4hi, v4hi)
v2si __builtin_arm_waddw (v2si, v2si)
v2si __builtin_arm_waddwss (v2si, v2si)
v2si __builtin_arm_waddwus (v2si, v2si)
v8qi __builtin_arm_walign (v8qi, v8qi, int)
long long __builtin_arm_wand(long long, long long)
long long __builtin_arm_wandn (long long, long long)
v8qi __builtin_arm_wavg2b (v8qi, v8qi)
v8qi __builtin_arm_wavg2br (v8qi, v8qi)
v4hi __builtin_arm_wavg2h (v4hi, v4hi)
v4hi __builtin_arm_wavg2hr (v4hi, v4hi)
v8qi __builtin_arm_wcmpeqb (v8qi, v8qi)
v4hi __builtin_arm_wcmpeqh (v4hi, v4hi)
v2si __builtin_arm_wcmpeqw (v2si, v2si)
v8qi __builtin_arm_wcmpgtsb (v8qi, v8qi)
v4hi __builtin_arm_wcmpgtsh (v4hi, v4hi)
v2si __builtin_arm_wcmpgtsw (v2si, v2si)
v8qi __builtin_arm_wcmpgtub (v8qi, v8qi)
v4hi __builtin_arm_wcmpgtuh (v4hi, v4hi)
v2si __builtin_arm_wcmpgtuw (v2si, v2si)
long long __builtin_arm_wmacs (long long, v4hi, v4hi)
long long __builtin_arm_wmacsz (v4hi, v4hi)
long long __builtin_arm_wmacu (long long, v4hi, v4hi)
long long __builtin_arm_wmacuz (v4hi, v4hi)
v4hi __builtin_arm_wmadds (v4hi, v4hi)
v4hi __builtin_arm_wmaddu (v4hi, v4hi)
v8qi __builtin_arm_wmaxsb (v8qi, v8qi)
v4hi __builtin_arm_wmaxsh (v4hi, v4hi)
v2si __builtin_arm_wmaxsw (v2si, v2si)
v8qi __builtin_arm_wmaxub (v8qi, v8qi)
v4hi __builtin_arm_wmaxuh (v4hi, v4hi)
v2si __builtin_arm_wmaxuw (v2si, v2si)
v8qi __builtin_arm_wminsb (v8qi, v8qi)
v4hi __builtin_arm_wminsh (v4hi, v4hi)
v2si __builtin_arm_wminsw (v2si, v2si)
v8qi __builtin_arm_wminub (v8qi, v8qi)
v4hi __builtin_arm_wminuh (v4hi, v4hi)
v2si __builtin_arm_wminuw (v2si, v2si)
v4hi __builtin_arm_wmulsm (v4hi, v4hi)
v4hi __builtin_arm_wmulul (v4hi, v4hi)
v4hi __builtin_arm_wmulum (v4hi, v4hi)
long long __builtin_arm_wor (long long, long long)
v2si __builtin_arm_wpackdss (long long, long long)
v2si __builtin_arm_wpackdus (long long, long long)
v8qi __builtin_arm_wpackhss (v4hi, v4hi)
v8qi __builtin_arm_wpackhus (v4hi, v4hi)
v4hi __builtin_arm_wpackwss (v2si, v2si)
v4hi __builtin_arm_wpackwus (v2si, v2si)
long long __builtin_arm_wrord (long long, long long)
long long __builtin_arm_wrordi (long long, int)
v4hi __builtin_arm_wrorh (v4hi, long long)
v4hi __builtin_arm_wrorhi (v4hi, int)
v2si __builtin_arm_wrorw (v2si, long long)
v2si __builtin_arm_wrorwi (v2si, int)
v2si __builtin_arm_wsadb (v2si, v8qi, v8qi)
v2si __builtin_arm_wsadbz (v8qi, v8qi)
v2si __builtin_arm_wsadh (v2si, v4hi, v4hi)
v2si __builtin_arm_wsadhz (v4hi, v4hi)
v4hi __builtin_arm_wshufh (v4hi, int)
long long __builtin_arm_wslld (long long, long long)
long long __builtin_arm_wslldi (long long, int)
v4hi __builtin_arm_wsllh (v4hi, long long)
v4hi __builtin_arm_wsllhi (v4hi, int)
v2si __builtin_arm_wsllw (v2si, long long)
v2si __builtin_arm_wsllwi (v2si, int)
long long __builtin_arm_wsrad (long long, long long)
long long __builtin_arm_wsradi (long long, int)
v4hi __builtin_arm_wsrah (v4hi, long long)
v4hi __builtin_arm_wsrahi (v4hi, int)
v2si __builtin_arm_wsraw (v2si, long long)
v2si __builtin_arm_wsrawi (v2si, int)
long long __builtin_arm_wsrld (long long, long long)
long long __builtin_arm_wsrldi (long long, int)
v4hi __builtin_arm_wsrlh (v4hi, long long)
v4hi __builtin_arm_wsrlhi (v4hi, int)
v2si __builtin_arm_wsrlw (v2si, long long)
v2si __builtin_arm_wsrlwi (v2si, int)
v8qi __builtin_arm_wsubb (v8qi, v8qi)
v8qi __builtin_arm_wsubbss (v8qi, v8qi)
v8qi __builtin_arm_wsubbus (v8qi, v8qi)
v4hi __builtin_arm_wsubh (v4hi, v4hi)
v4hi __builtin_arm_wsubhss (v4hi, v4hi)
v4hi __builtin_arm_wsubhus (v4hi, v4hi)
v2si __builtin_arm_wsubw (v2si, v2si)
v2si __builtin_arm_wsubwss (v2si, v2si)
v2si __builtin_arm_wsubwus (v2si, v2si)
v4hi __builtin_arm_wunpckehsb (v8qi)
v2si __builtin_arm_wunpckehsh (v4hi)
long long __builtin_arm_wunpckehsw (v2si)
v4hi __builtin_arm_wunpckehub (v8qi)
v2si __builtin_arm_wunpckehuh (v4hi)
long long __builtin_arm_wunpckehuw (v2si)
v4hi __builtin_arm_wunpckelsb (v8qi)
v2si __builtin_arm_wunpckelsh (v4hi)
long long __builtin_arm_wunpckelsw (v2si)
v4hi __builtin_arm_wunpckelub (v8qi)
v2si __builtin_arm_wunpckeluh (v4hi)
long long __builtin_arm_wunpckeluw (v2si)
v8qi __builtin_arm_wunpckihb (v8qi, v8qi)
v4hi __builtin_arm_wunpckihh (v4hi, v4hi)
v2si __builtin_arm_wunpckihw (v2si, v2si)
v8qi __builtin_arm_wunpckilb (v8qi, v8qi)
v4hi __builtin_arm_wunpckilh (v4hi, v4hi)
v2si __builtin_arm_wunpckilw (v2si, v2si)
long long __builtin_arm_wxor (long long, long long)
long long __builtin_arm_wzero ()
@end smallexample


@node ARM C Language Extensions (ACLE)
@subsection ARM C Language Extensions (ACLE)

GCC implements extensions for C as described in the ARM C Language
Extensions (ACLE) specification, which can be found at
@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf}.

As a part of ACLE, GCC implements extensions for Advanced SIMD as described in
the ARM C Language Extensions Specification.  The complete list of Advanced SIMD
intrinsics can be found at
@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf}.
The built-in intrinsics for the Advanced SIMD extension are available when
NEON is enabled.

Currently, ARM and AArch64 back ends do not support ACLE 2.0 fully.  Both
back ends support CRC32 intrinsics and the ARM back end supports the
Coprocessor intrinsics, all from @file{arm_acle.h}.  The ARM back end's 16-bit
floating-point Advanced SIMD intrinsics currently comply to ACLE v1.1.
AArch64's back end does not have support for 16-bit floating point Advanced SIMD
intrinsics yet.

See @ref{ARM Options} and @ref{AArch64 Options} for more information on the
availability of extensions.

@node ARM Floating Point Status and Control Intrinsics
@subsection ARM Floating Point Status and Control Intrinsics

These built-in functions are available for the ARM family of
processors with floating-point unit.

@smallexample
unsigned int __builtin_arm_get_fpscr ()
void __builtin_arm_set_fpscr (unsigned int)
@end smallexample

@node ARM ARMv8-M Security Extensions
@subsection ARM ARMv8-M Security Extensions

GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M
Security Extensions: Requirements on Development Tools Engineering
Specification, which can be found at
@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf}.

As part of the Security Extensions GCC implements two new function attributes:
@code{cmse_nonsecure_entry} and @code{cmse_nonsecure_call}.

As part of the Security Extensions GCC implements the intrinsics below.  FPTR
is used here to mean any function pointer type.

@smallexample
cmse_address_info_t cmse_TT (void *)
cmse_address_info_t cmse_TT_fptr (FPTR)
cmse_address_info_t cmse_TTT (void *)
cmse_address_info_t cmse_TTT_fptr (FPTR)
cmse_address_info_t cmse_TTA (void *)
cmse_address_info_t cmse_TTA_fptr (FPTR)
cmse_address_info_t cmse_TTAT (void *)
cmse_address_info_t cmse_TTAT_fptr (FPTR)
void * cmse_check_address_range (void *, size_t, int)
typeof(p) cmse_nsfptr_create (FPTR p)
intptr_t cmse_is_nsfptr (FPTR)
int cmse_nonsecure_caller (void)
@end smallexample

@node AVR Built-in Functions
@subsection AVR Built-in Functions

For each built-in function for AVR, there is an equally named,
uppercase built-in macro defined. That way users can easily query if
or if not a specific built-in is implemented or not. For example, if
@code{__builtin_avr_nop} is available the macro
@code{__BUILTIN_AVR_NOP} is defined to @code{1} and undefined otherwise.

The following built-in functions map to the respective machine
instruction, i.e.@: @code{nop}, @code{sei}, @code{cli}, @code{sleep},
@code{wdr}, @code{swap}, @code{fmul}, @code{fmuls}
resp. @code{fmulsu}. The three @code{fmul*} built-ins are implemented
as library call if no hardware multiplier is available.

@smallexample
void __builtin_avr_nop (void)
void __builtin_avr_sei (void)
void __builtin_avr_cli (void)
void __builtin_avr_sleep (void)
void __builtin_avr_wdr (void)
unsigned char __builtin_avr_swap (unsigned char)
unsigned int __builtin_avr_fmul (unsigned char, unsigned char)
int __builtin_avr_fmuls (char, char)
int __builtin_avr_fmulsu (char, unsigned char)
@end smallexample

In order to delay execution for a specific number of cycles, GCC
implements
@smallexample
void __builtin_avr_delay_cycles (unsigned long ticks)
@end smallexample

@noindent
@code{ticks} is the number of ticks to delay execution. Note that this
built-in does not take into account the effect of interrupts that
might increase delay time. @code{ticks} must be a compile-time
integer constant; delays with a variable number of cycles are not supported.

@smallexample
char __builtin_avr_flash_segment (const __memx void*)
@end smallexample

@noindent
This built-in takes a byte address to the 24-bit
@ref{AVR Named Address Spaces,address space} @code{__memx} and returns
the number of the flash segment (the 64 KiB chunk) where the address
points to.  Counting starts at @code{0}.
If the address does not point to flash memory, return @code{-1}.

@smallexample
unsigned char __builtin_avr_insert_bits (unsigned long map,
                                         unsigned char bits,
                                         unsigned char val)
@end smallexample

@noindent
Insert bits from @var{bits} into @var{val} and return the resulting
value. The nibbles of @var{map} determine how the insertion is
performed: Let @var{X} be the @var{n}-th nibble of @var{map}
@enumerate
@item If @var{X} is @code{0xf},
then the @var{n}-th bit of @var{val} is returned unaltered.

@item If X is in the range 0@dots{}7,
then the @var{n}-th result bit is set to the @var{X}-th bit of @var{bits}

@item If X is in the range 8@dots{}@code{0xe},
then the @var{n}-th result bit is undefined.
@end enumerate

@noindent
One typical use case for this built-in is adjusting input and
output values to non-contiguous port layouts. Some examples:

@smallexample
// same as val, bits is unused
__builtin_avr_insert_bits (0xffffffff, bits, val)
@end smallexample

@smallexample
// same as bits, val is unused
__builtin_avr_insert_bits (0x76543210, bits, val)
@end smallexample

@smallexample
// same as rotating bits by 4
__builtin_avr_insert_bits (0x32107654, bits, 0)
@end smallexample

@smallexample
// high nibble of result is the high nibble of val
// low nibble of result is the low nibble of bits
__builtin_avr_insert_bits (0xffff3210, bits, val)
@end smallexample

@smallexample
// reverse the bit order of bits
__builtin_avr_insert_bits (0x01234567, bits, 0)
@end smallexample

@smallexample
void __builtin_avr_nops (unsigned count)
@end smallexample

@noindent
Insert @code{count} @code{NOP} instructions.
The number of instructions must be a compile-time integer constant.

@node Blackfin Built-in Functions
@subsection Blackfin Built-in Functions

Currently, there are two Blackfin-specific built-in functions.  These are
used for generating @code{CSYNC} and @code{SSYNC} machine insns without
using inline assembly; by using these built-in functions the compiler can
automatically add workarounds for hardware errata involving these
instructions.  These functions are named as follows:

@smallexample
void __builtin_bfin_csync (void)
void __builtin_bfin_ssync (void)
@end smallexample

@node FR-V Built-in Functions
@subsection FR-V Built-in Functions

GCC provides many FR-V-specific built-in functions.  In general,
these functions are intended to be compatible with those described
by @cite{FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu
Semiconductor}.  The two exceptions are @code{__MDUNPACKH} and
@code{__MBTOHE}, the GCC forms of which pass 128-bit values by
pointer rather than by value.

Most of the functions are named after specific FR-V instructions.
Such functions are said to be ``directly mapped'' and are summarized
here in tabular form.

@menu
* Argument Types::
* Directly-mapped Integer Functions::
* Directly-mapped Media Functions::
* Raw read/write Functions::
* Other Built-in Functions::
@end menu

@node Argument Types
@subsubsection Argument Types

The arguments to the built-in functions can be divided into three groups:
register numbers, compile-time constants and run-time values.  In order
to make this classification clear at a glance, the arguments and return
values are given the following pseudo types:

@multitable @columnfractions .20 .30 .15 .35
@item Pseudo type @tab Real C type @tab Constant? @tab Description
@item @code{uh} @tab @code{unsigned short} @tab No @tab an unsigned halfword
@item @code{uw1} @tab @code{unsigned int} @tab No @tab an unsigned word
@item @code{sw1} @tab @code{int} @tab No @tab a signed word
@item @code{uw2} @tab @code{unsigned long long} @tab No
@tab an unsigned doubleword
@item @code{sw2} @tab @code{long long} @tab No @tab a signed doubleword
@item @code{const} @tab @code{int} @tab Yes @tab an integer constant
@item @code{acc} @tab @code{int} @tab Yes @tab an ACC register number
@item @code{iacc} @tab @code{int} @tab Yes @tab an IACC register number
@end multitable

These pseudo types are not defined by GCC, they are simply a notational
convenience used in this manual.

Arguments of type @code{uh}, @code{uw1}, @code{sw1}, @code{uw2}
and @code{sw2} are evaluated at run time.  They correspond to
register operands in the underlying FR-V instructions.

@code{const} arguments represent immediate operands in the underlying
FR-V instructions.  They must be compile-time constants.

@code{acc} arguments are evaluated at compile time and specify the number
of an accumulator register.  For example, an @code{acc} argument of 2
selects the ACC2 register.

@code{iacc} arguments are similar to @code{acc} arguments but specify the
number of an IACC register.  See @pxref{Other Built-in Functions}
for more details.

@node Directly-mapped Integer Functions
@subsubsection Directly-Mapped Integer Functions

The functions listed below map directly to FR-V I-type instructions.

@multitable @columnfractions .45 .32 .23
@item Function prototype @tab Example usage @tab Assembly output
@item @code{sw1 __ADDSS (sw1, sw1)}
@tab @code{@var{c} = __ADDSS (@var{a}, @var{b})}
@tab @code{ADDSS @var{a},@var{b},@var{c}}
@item @code{sw1 __SCAN (sw1, sw1)}
@tab @code{@var{c} = __SCAN (@var{a}, @var{b})}
@tab @code{SCAN @var{a},@var{b},@var{c}}
@item @code{sw1 __SCUTSS (sw1)}
@tab @code{@var{b} = __SCUTSS (@var{a})}
@tab @code{SCUTSS @var{a},@var{b}}
@item @code{sw1 __SLASS (sw1, sw1)}
@tab @code{@var{c} = __SLASS (@var{a}, @var{b})}
@tab @code{SLASS @var{a},@var{b},@var{c}}
@item @code{void __SMASS (sw1, sw1)}
@tab @code{__SMASS (@var{a}, @var{b})}
@tab @code{SMASS @var{a},@var{b}}
@item @code{void __SMSSS (sw1, sw1)}
@tab @code{__SMSSS (@var{a}, @var{b})}
@tab @code{SMSSS @var{a},@var{b}}
@item @code{void __SMU (sw1, sw1)}
@tab @code{__SMU (@var{a}, @var{b})}
@tab @code{SMU @var{a},@var{b}}
@item @code{sw2 __SMUL (sw1, sw1)}
@tab @code{@var{c} = __SMUL (@var{a}, @var{b})}
@tab @code{SMUL @var{a},@var{b},@var{c}}
@item @code{sw1 __SUBSS (sw1, sw1)}
@tab @code{@var{c} = __SUBSS (@var{a}, @var{b})}
@tab @code{SUBSS @var{a},@var{b},@var{c}}
@item @code{uw2 __UMUL (uw1, uw1)}
@tab @code{@var{c} = __UMUL (@var{a}, @var{b})}
@tab @code{UMUL @var{a},@var{b},@var{c}}
@end multitable

@node Directly-mapped Media Functions
@subsubsection Directly-Mapped Media Functions

The functions listed below map directly to FR-V M-type instructions.

@multitable @columnfractions .45 .32 .23
@item Function prototype @tab Example usage @tab Assembly output
@item @code{uw1 __MABSHS (sw1)}
@tab @code{@var{b} = __MABSHS (@var{a})}
@tab @code{MABSHS @var{a},@var{b}}
@item @code{void __MADDACCS (acc, acc)}
@tab @code{__MADDACCS (@var{b}, @var{a})}
@tab @code{MADDACCS @var{a},@var{b}}
@item @code{sw1 __MADDHSS (sw1, sw1)}
@tab @code{@var{c} = __MADDHSS (@var{a}, @var{b})}
@tab @code{MADDHSS @var{a},@var{b},@var{c}}
@item @code{uw1 __MADDHUS (uw1, uw1)}
@tab @code{@var{c} = __MADDHUS (@var{a}, @var{b})}
@tab @code{MADDHUS @var{a},@var{b},@var{c}}
@item @code{uw1 __MAND (uw1, uw1)}
@tab @code{@var{c} = __MAND (@var{a}, @var{b})}
@tab @code{MAND @var{a},@var{b},@var{c}}
@item @code{void __MASACCS (acc, acc)}
@tab @code{__MASACCS (@var{b}, @var{a})}
@tab @code{MASACCS @var{a},@var{b}}
@item @code{uw1 __MAVEH (uw1, uw1)}
@tab @code{@var{c} = __MAVEH (@var{a}, @var{b})}
@tab @code{MAVEH @var{a},@var{b},@var{c}}
@item @code{uw2 __MBTOH (uw1)}
@tab @code{@var{b} = __MBTOH (@var{a})}
@tab @code{MBTOH @var{a},@var{b}}
@item @code{void __MBTOHE (uw1 *, uw1)}
@tab @code{__MBTOHE (&@var{b}, @var{a})}
@tab @code{MBTOHE @var{a},@var{b}}
@item @code{void __MCLRACC (acc)}
@tab @code{__MCLRACC (@var{a})}
@tab @code{MCLRACC @var{a}}
@item @code{void __MCLRACCA (void)}
@tab @code{__MCLRACCA ()}
@tab @code{MCLRACCA}
@item @code{uw1 __Mcop1 (uw1, uw1)}
@tab @code{@var{c} = __Mcop1 (@var{a}, @var{b})}
@tab @code{Mcop1 @var{a},@var{b},@var{c}}
@item @code{uw1 __Mcop2 (uw1, uw1)}
@tab @code{@var{c} = __Mcop2 (@var{a}, @var{b})}
@tab @code{Mcop2 @var{a},@var{b},@var{c}}
@item @code{uw1 __MCPLHI (uw2, const)}
@tab @code{@var{c} = __MCPLHI (@var{a}, @var{b})}
@tab @code{MCPLHI @var{a},#@var{b},@var{c}}
@item @code{uw1 __MCPLI (uw2, const)}
@tab @code{@var{c} = __MCPLI (@var{a}, @var{b})}
@tab @code{MCPLI @var{a},#@var{b},@var{c}}
@item @code{void __MCPXIS (acc, sw1, sw1)}
@tab @code{__MCPXIS (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXIS @var{a},@var{b},@var{c}}
@item @code{void __MCPXIU (acc, uw1, uw1)}
@tab @code{__MCPXIU (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXIU @var{a},@var{b},@var{c}}
@item @code{void __MCPXRS (acc, sw1, sw1)}
@tab @code{__MCPXRS (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXRS @var{a},@var{b},@var{c}}
@item @code{void __MCPXRU (acc, uw1, uw1)}
@tab @code{__MCPXRU (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXRU @var{a},@var{b},@var{c}}
@item @code{uw1 __MCUT (acc, uw1)}
@tab @code{@var{c} = __MCUT (@var{a}, @var{b})}
@tab @code{MCUT @var{a},@var{b},@var{c}}
@item @code{uw1 __MCUTSS (acc, sw1)}
@tab @code{@var{c} = __MCUTSS (@var{a}, @var{b})}
@tab @code{MCUTSS @var{a},@var{b},@var{c}}
@item @code{void __MDADDACCS (acc, acc)}
@tab @code{__MDADDACCS (@var{b}, @var{a})}
@tab @code{MDADDACCS @var{a},@var{b}}
@item @code{void __MDASACCS (acc, acc)}
@tab @code{__MDASACCS (@var{b}, @var{a})}
@tab @code{MDASACCS @var{a},@var{b}}
@item @code{uw2 __MDCUTSSI (acc, const)}
@tab @code{@var{c} = __MDCUTSSI (@var{a}, @var{b})}
@tab @code{MDCUTSSI @var{a},#@var{b},@var{c}}
@item @code{uw2 __MDPACKH (uw2, uw2)}
@tab @code{@var{c} = __MDPACKH (@var{a}, @var{b})}
@tab @code{MDPACKH @var{a},@var{b},@var{c}}
@item @code{uw2 __MDROTLI (uw2, const)}
@tab @code{@var{c} = __MDROTLI (@var{a}, @var{b})}
@tab @code{MDROTLI @var{a},#@var{b},@var{c}}
@item @code{void __MDSUBACCS (acc, acc)}
@tab @code{__MDSUBACCS (@var{b}, @var{a})}
@tab @code{MDSUBACCS @var{a},@var{b}}
@item @code{void __MDUNPACKH (uw1 *, uw2)}
@tab @code{__MDUNPACKH (&@var{b}, @var{a})}
@tab @code{MDUNPACKH @var{a},@var{b}}
@item @code{uw2 __MEXPDHD (uw1, const)}
@tab @code{@var{c} = __MEXPDHD (@var{a}, @var{b})}
@tab @code{MEXPDHD @var{a},#@var{b},@var{c}}
@item @code{uw1 __MEXPDHW (uw1, const)}
@tab @code{@var{c} = __MEXPDHW (@var{a}, @var{b})}
@tab @code{MEXPDHW @var{a},#@var{b},@var{c}}
@item @code{uw1 __MHDSETH (uw1, const)}
@tab @code{@var{c} = __MHDSETH (@var{a}, @var{b})}
@tab @code{MHDSETH @var{a},#@var{b},@var{c}}
@item @code{sw1 __MHDSETS (const)}
@tab @code{@var{b} = __MHDSETS (@var{a})}
@tab @code{MHDSETS #@var{a},@var{b}}
@item @code{uw1 __MHSETHIH (uw1, const)}
@tab @code{@var{b} = __MHSETHIH (@var{b}, @var{a})}
@tab @code{MHSETHIH #@var{a},@var{b}}
@item @code{sw1 __MHSETHIS (sw1, const)}
@tab @code{@var{b} = __MHSETHIS (@var{b}, @var{a})}
@tab @code{MHSETHIS #@var{a},@var{b}}
@item @code{uw1 __MHSETLOH (uw1, const)}
@tab @code{@var{b} = __MHSETLOH (@var{b}, @var{a})}
@tab @code{MHSETLOH #@var{a},@var{b}}
@item @code{sw1 __MHSETLOS (sw1, const)}
@tab @code{@var{b} = __MHSETLOS (@var{b}, @var{a})}
@tab @code{MHSETLOS #@var{a},@var{b}}
@item @code{uw1 __MHTOB (uw2)}
@tab @code{@var{b} = __MHTOB (@var{a})}
@tab @code{MHTOB @var{a},@var{b}}
@item @code{void __MMACHS (acc, sw1, sw1)}
@tab @code{__MMACHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMACHS @var{a},@var{b},@var{c}}
@item @code{void __MMACHU (acc, uw1, uw1)}
@tab @code{__MMACHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMACHU @var{a},@var{b},@var{c}}
@item @code{void __MMRDHS (acc, sw1, sw1)}
@tab @code{__MMRDHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMRDHS @var{a},@var{b},@var{c}}
@item @code{void __MMRDHU (acc, uw1, uw1)}
@tab @code{__MMRDHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMRDHU @var{a},@var{b},@var{c}}
@item @code{void __MMULHS (acc, sw1, sw1)}
@tab @code{__MMULHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMULHS @var{a},@var{b},@var{c}}
@item @code{void __MMULHU (acc, uw1, uw1)}
@tab @code{__MMULHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMULHU @var{a},@var{b},@var{c}}
@item @code{void __MMULXHS (acc, sw1, sw1)}
@tab @code{__MMULXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMULXHS @var{a},@var{b},@var{c}}
@item @code{void __MMULXHU (acc, uw1, uw1)}
@tab @code{__MMULXHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMULXHU @var{a},@var{b},@var{c}}
@item @code{uw1 __MNOT (uw1)}
@tab @code{@var{b} = __MNOT (@var{a})}
@tab @code{MNOT @var{a},@var{b}}
@item @code{uw1 __MOR (uw1, uw1)}
@tab @code{@var{c} = __MOR (@var{a}, @var{b})}
@tab @code{MOR @var{a},@var{b},@var{c}}
@item @code{uw1 __MPACKH (uh, uh)}
@tab @code{@var{c} = __MPACKH (@var{a}, @var{b})}
@tab @code{MPACKH @var{a},@var{b},@var{c}}
@item @code{sw2 __MQADDHSS (sw2, sw2)}
@tab @code{@var{c} = __MQADDHSS (@var{a}, @var{b})}
@tab @code{MQADDHSS @var{a},@var{b},@var{c}}
@item @code{uw2 __MQADDHUS (uw2, uw2)}
@tab @code{@var{c} = __MQADDHUS (@var{a}, @var{b})}
@tab @code{MQADDHUS @var{a},@var{b},@var{c}}
@item @code{void __MQCPXIS (acc, sw2, sw2)}
@tab @code{__MQCPXIS (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXIS @var{a},@var{b},@var{c}}
@item @code{void __MQCPXIU (acc, uw2, uw2)}
@tab @code{__MQCPXIU (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXIU @var{a},@var{b},@var{c}}
@item @code{void __MQCPXRS (acc, sw2, sw2)}
@tab @code{__MQCPXRS (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXRS @var{a},@var{b},@var{c}}
@item @code{void __MQCPXRU (acc, uw2, uw2)}
@tab @code{__MQCPXRU (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXRU @var{a},@var{b},@var{c}}
@item @code{sw2 __MQLCLRHS (sw2, sw2)}
@tab @code{@var{c} = __MQLCLRHS (@var{a}, @var{b})}
@tab @code{MQLCLRHS @var{a},@var{b},@var{c}}
@item @code{sw2 __MQLMTHS (sw2, sw2)}
@tab @code{@var{c} = __MQLMTHS (@var{a}, @var{b})}
@tab @code{MQLMTHS @var{a},@var{b},@var{c}}
@item @code{void __MQMACHS (acc, sw2, sw2)}
@tab @code{__MQMACHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMACHS @var{a},@var{b},@var{c}}
@item @code{void __MQMACHU (acc, uw2, uw2)}
@tab @code{__MQMACHU (@var{c}, @var{a}, @var{b})}
@tab @code{MQMACHU @var{a},@var{b},@var{c}}
@item @code{void __MQMACXHS (acc, sw2, sw2)}
@tab @code{__MQMACXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMACXHS @var{a},@var{b},@var{c}}
@item @code{void __MQMULHS (acc, sw2, sw2)}
@tab @code{__MQMULHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULHS @var{a},@var{b},@var{c}}
@item @code{void __MQMULHU (acc, uw2, uw2)}
@tab @code{__MQMULHU (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULHU @var{a},@var{b},@var{c}}
@item @code{void __MQMULXHS (acc, sw2, sw2)}
@tab @code{__MQMULXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULXHS @var{a},@var{b},@var{c}}
@item @code{void __MQMULXHU (acc, uw2, uw2)}
@tab @code{__MQMULXHU (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULXHU @var{a},@var{b},@var{c}}
@item @code{sw2 __MQSATHS (sw2, sw2)}
@tab @code{@var{c} = __MQSATHS (@var{a}, @var{b})}
@tab @code{MQSATHS @var{a},@var{b},@var{c}}
@item @code{uw2 __MQSLLHI (uw2, int)}
@tab @code{@var{c} = __MQSLLHI (@var{a}, @var{b})}
@tab @code{MQSLLHI @var{a},@var{b},@var{c}}
@item @code{sw2 __MQSRAHI (sw2, int)}
@tab @code{@var{c} = __MQSRAHI (@var{a}, @var{b})}
@tab @code{MQSRAHI @var{a},@var{b},@var{c}}
@item @code{sw2 __MQSUBHSS (sw2, sw2)}
@tab @code{@var{c} = __MQSUBHSS (@var{a}, @var{b})}
@tab @code{MQSUBHSS @var{a},@var{b},@var{c}}
@item @code{uw2 __MQSUBHUS (uw2, uw2)}
@tab @code{@var{c} = __MQSUBHUS (@var{a}, @var{b})}
@tab @code{MQSUBHUS @var{a},@var{b},@var{c}}
@item @code{void __MQXMACHS (acc, sw2, sw2)}
@tab @code{__MQXMACHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQXMACHS @var{a},@var{b},@var{c}}
@item @code{void __MQXMACXHS (acc, sw2, sw2)}
@tab @code{__MQXMACXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQXMACXHS @var{a},@var{b},@var{c}}
@item @code{uw1 __MRDACC (acc)}
@tab @code{@var{b} = __MRDACC (@var{a})}
@tab @code{MRDACC @var{a},@var{b}}
@item @code{uw1 __MRDACCG (acc)}
@tab @code{@var{b} = __MRDACCG (@var{a})}
@tab @code{MRDACCG @var{a},@var{b}}
@item @code{uw1 __MROTLI (uw1, const)}
@tab @code{@var{c} = __MROTLI (@var{a}, @var{b})}
@tab @code{MROTLI @var{a},#@var{b},@var{c}}
@item @code{uw1 __MROTRI (uw1, const)}
@tab @code{@var{c} = __MROTRI (@var{a}, @var{b})}
@tab @code{MROTRI @var{a},#@var{b},@var{c}}
@item @code{sw1 __MSATHS (sw1, sw1)}
@tab @code{@var{c} = __MSATHS (@var{a}, @var{b})}
@tab @code{MSATHS @var{a},@var{b},@var{c}}
@item @code{uw1 __MSATHU (uw1, uw1)}
@tab @code{@var{c} = __MSATHU (@var{a}, @var{b})}
@tab @code{MSATHU @var{a},@var{b},@var{c}}
@item @code{uw1 __MSLLHI (uw1, const)}
@tab @code{@var{c} = __MSLLHI (@var{a}, @var{b})}
@tab @code{MSLLHI @var{a},#@var{b},@var{c}}
@item @code{sw1 __MSRAHI (sw1, const)}
@tab @code{@var{c} = __MSRAHI (@var{a}, @var{b})}
@tab @code{MSRAHI @var{a},#@var{b},@var{c}}
@item @code{uw1 __MSRLHI (uw1, const)}
@tab @code{@var{c} = __MSRLHI (@var{a}, @var{b})}
@tab @code{MSRLHI @var{a},#@var{b},@var{c}}
@item @code{void __MSUBACCS (acc, acc)}
@tab @code{__MSUBACCS (@var{b}, @var{a})}
@tab @code{MSUBACCS @var{a},@var{b}}
@item @code{sw1 __MSUBHSS (sw1, sw1)}
@tab @code{@var{c} = __MSUBHSS (@var{a}, @var{b})}
@tab @code{MSUBHSS @var{a},@var{b},@var{c}}
@item @code{uw1 __MSUBHUS (uw1, uw1)}
@tab @code{@var{c} = __MSUBHUS (@var{a}, @var{b})}
@tab @code{MSUBHUS @var{a},@var{b},@var{c}}
@item @code{void __MTRAP (void)}
@tab @code{__MTRAP ()}
@tab @code{MTRAP}
@item @code{uw2 __MUNPACKH (uw1)}
@tab @code{@var{b} = __MUNPACKH (@var{a})}
@tab @code{MUNPACKH @var{a},@var{b}}
@item @code{uw1 __MWCUT (uw2, uw1)}
@tab @code{@var{c} = __MWCUT (@var{a}, @var{b})}
@tab @code{MWCUT @var{a},@var{b},@var{c}}
@item @code{void __MWTACC (acc, uw1)}
@tab @code{__MWTACC (@var{b}, @var{a})}
@tab @code{MWTACC @var{a},@var{b}}
@item @code{void __MWTACCG (acc, uw1)}
@tab @code{__MWTACCG (@var{b}, @var{a})}
@tab @code{MWTACCG @var{a},@var{b}}
@item @code{uw1 __MXOR (uw1, uw1)}
@tab @code{@var{c} = __MXOR (@var{a}, @var{b})}
@tab @code{MXOR @var{a},@var{b},@var{c}}
@end multitable

@node Raw read/write Functions
@subsubsection Raw Read/Write Functions

This sections describes built-in functions related to read and write
instructions to access memory.  These functions generate
@code{membar} instructions to flush the I/O load and stores where
appropriate, as described in Fujitsu's manual described above.

@table @code

@item unsigned char __builtin_read8 (void *@var{data})
@item unsigned short __builtin_read16 (void *@var{data})
@item unsigned long __builtin_read32 (void *@var{data})
@item unsigned long long __builtin_read64 (void *@var{data})

@item void __builtin_write8 (void *@var{data}, unsigned char @var{datum})
@item void __builtin_write16 (void *@var{data}, unsigned short @var{datum})
@item void __builtin_write32 (void *@var{data}, unsigned long @var{datum})
@item void __builtin_write64 (void *@var{data}, unsigned long long @var{datum})
@end table

@node Other Built-in Functions
@subsubsection Other Built-in Functions

This section describes built-in functions that are not named after
a specific FR-V instruction.

@table @code
@item sw2 __IACCreadll (iacc @var{reg})
Return the full 64-bit value of IACC0@.  The @var{reg} argument is reserved
for future expansion and must be 0.

@item sw1 __IACCreadl (iacc @var{reg})
Return the value of IACC0H if @var{reg} is 0 and IACC0L if @var{reg} is 1.
Other values of @var{reg} are rejected as invalid.

@item void __IACCsetll (iacc @var{reg}, sw2 @var{x})
Set the full 64-bit value of IACC0 to @var{x}.  The @var{reg} argument
is reserved for future expansion and must be 0.

@item void __IACCsetl (iacc @var{reg}, sw1 @var{x})
Set IACC0H to @var{x} if @var{reg} is 0 and IACC0L to @var{x} if @var{reg}
is 1.  Other values of @var{reg} are rejected as invalid.

@item void __data_prefetch0 (const void *@var{x})
Use the @code{dcpl} instruction to load the contents of address @var{x}
into the data cache.

@item void __data_prefetch (const void *@var{x})
Use the @code{nldub} instruction to load the contents of address @var{x}
into the data cache.  The instruction is issued in slot I1@.
@end table

@node MIPS DSP Built-in Functions
@subsection MIPS DSP Built-in Functions

The MIPS DSP Application-Specific Extension (ASE) includes new
instructions that are designed to improve the performance of DSP and
media applications.  It provides instructions that operate on packed
8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.

GCC supports MIPS DSP operations using both the generic
vector extensions (@pxref{Vector Extensions}) and a collection of
MIPS-specific built-in functions.  Both kinds of support are
enabled by the @option{-mdsp} command-line option.

Revision 2 of the ASE was introduced in the second half of 2006.
This revision adds extra instructions to the original ASE, but is
otherwise backwards-compatible with it.  You can select revision 2
using the command-line option @option{-mdspr2}; this option implies
@option{-mdsp}.

The SCOUNT and POS bits of the DSP control register are global.  The
WRDSP, EXTPDP, EXTPDPV and MTHLIP instructions modify the SCOUNT and
POS bits.  During optimization, the compiler does not delete these
instructions and it does not delete calls to functions containing
these instructions.

At present, GCC only provides support for operations on 32-bit
vectors.  The vector type associated with 8-bit integer data is
usually called @code{v4i8}, the vector type associated with Q7
is usually called @code{v4q7}, the vector type associated with 16-bit
integer data is usually called @code{v2i16}, and the vector type
associated with Q15 is usually called @code{v2q15}.  They can be
defined in C as follows:

@smallexample
typedef signed char v4i8 __attribute__ ((vector_size(4)));
typedef signed char v4q7 __attribute__ ((vector_size(4)));
typedef short v2i16 __attribute__ ((vector_size(4)));
typedef short v2q15 __attribute__ ((vector_size(4)));
@end smallexample

@code{v4i8}, @code{v4q7}, @code{v2i16} and @code{v2q15} values are
initialized in the same way as aggregates.  For example:

@smallexample
v4i8 a = @{1, 2, 3, 4@};
v4i8 b;
b = (v4i8) @{5, 6, 7, 8@};

v2q15 c = @{0x0fcb, 0x3a75@};
v2q15 d;
d = (v2q15) @{0.1234 * 0x1.0p15, 0.4567 * 0x1.0p15@};
@end smallexample

@emph{Note:} The CPU's endianness determines the order in which values
are packed.  On little-endian targets, the first value is the least
significant and the last value is the most significant.  The opposite
order applies to big-endian targets.  For example, the code above
sets the lowest byte of @code{a} to @code{1} on little-endian targets
and @code{4} on big-endian targets.

@emph{Note:} Q7, Q15 and Q31 values must be initialized with their integer
representation.  As shown in this example, the integer representation
of a Q7 value can be obtained by multiplying the fractional value by
@code{0x1.0p7}.  The equivalent for Q15 values is to multiply by
@code{0x1.0p15}.  The equivalent for Q31 values is to multiply by
@code{0x1.0p31}.

The table below lists the @code{v4i8} and @code{v2q15} operations for which
hardware support exists.  @code{a} and @code{b} are @code{v4i8} values,
and @code{c} and @code{d} are @code{v2q15} values.

@multitable @columnfractions .50 .50
@item C code @tab MIPS instruction
@item @code{a + b} @tab @code{addu.qb}
@item @code{c + d} @tab @code{addq.ph}
@item @code{a - b} @tab @code{subu.qb}
@item @code{c - d} @tab @code{subq.ph}
@end multitable

The table below lists the @code{v2i16} operation for which
hardware support exists for the DSP ASE REV 2.  @code{e} and @code{f} are
@code{v2i16} values.

@multitable @columnfractions .50 .50
@item C code @tab MIPS instruction
@item @code{e * f} @tab @code{mul.ph}
@end multitable

It is easier to describe the DSP built-in functions if we first define
the following types:

@smallexample
typedef int q31;
typedef int i32;
typedef unsigned int ui32;
typedef long long a64;
@end smallexample

@code{q31} and @code{i32} are actually the same as @code{int}, but we
use @code{q31} to indicate a Q31 fractional value and @code{i32} to
indicate a 32-bit integer value.  Similarly, @code{a64} is the same as
@code{long long}, but we use @code{a64} to indicate values that are
placed in one of the four DSP accumulators (@code{$ac0},
@code{$ac1}, @code{$ac2} or @code{$ac3}).

Also, some built-in functions prefer or require immediate numbers as
parameters, because the corresponding DSP instructions accept both immediate
numbers and register operands, or accept immediate numbers only.  The
immediate parameters are listed as follows.

@smallexample
imm0_3: 0 to 3.
imm0_7: 0 to 7.
imm0_15: 0 to 15.
imm0_31: 0 to 31.
imm0_63: 0 to 63.
imm0_255: 0 to 255.
imm_n32_31: -32 to 31.
imm_n512_511: -512 to 511.
@end smallexample

The following built-in functions map directly to a particular MIPS DSP
instruction.  Please refer to the architecture specification
for details on what each instruction does.

@smallexample
v2q15 __builtin_mips_addq_ph (v2q15, v2q15)
v2q15 __builtin_mips_addq_s_ph (v2q15, v2q15)
q31 __builtin_mips_addq_s_w (q31, q31)
v4i8 __builtin_mips_addu_qb (v4i8, v4i8)
v4i8 __builtin_mips_addu_s_qb (v4i8, v4i8)
v2q15 __builtin_mips_subq_ph (v2q15, v2q15)
v2q15 __builtin_mips_subq_s_ph (v2q15, v2q15)
q31 __builtin_mips_subq_s_w (q31, q31)
v4i8 __builtin_mips_subu_qb (v4i8, v4i8)
v4i8 __builtin_mips_subu_s_qb (v4i8, v4i8)
i32 __builtin_mips_addsc (i32, i32)
i32 __builtin_mips_addwc (i32, i32)
i32 __builtin_mips_modsub (i32, i32)
i32 __builtin_mips_raddu_w_qb (v4i8)
v2q15 __builtin_mips_absq_s_ph (v2q15)
q31 __builtin_mips_absq_s_w (q31)
v4i8 __builtin_mips_precrq_qb_ph (v2q15, v2q15)
v2q15 __builtin_mips_precrq_ph_w (q31, q31)
v2q15 __builtin_mips_precrq_rs_ph_w (q31, q31)
v4i8 __builtin_mips_precrqu_s_qb_ph (v2q15, v2q15)
q31 __builtin_mips_preceq_w_phl (v2q15)
q31 __builtin_mips_preceq_w_phr (v2q15)
v2q15 __builtin_mips_precequ_ph_qbl (v4i8)
v2q15 __builtin_mips_precequ_ph_qbr (v4i8)
v2q15 __builtin_mips_precequ_ph_qbla (v4i8)
v2q15 __builtin_mips_precequ_ph_qbra (v4i8)
v2q15 __builtin_mips_preceu_ph_qbl (v4i8)
v2q15 __builtin_mips_preceu_ph_qbr (v4i8)
v2q15 __builtin_mips_preceu_ph_qbla (v4i8)
v2q15 __builtin_mips_preceu_ph_qbra (v4i8)
v4i8 __builtin_mips_shll_qb (v4i8, imm0_7)
v4i8 __builtin_mips_shll_qb (v4i8, i32)
v2q15 __builtin_mips_shll_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shll_ph (v2q15, i32)
v2q15 __builtin_mips_shll_s_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shll_s_ph (v2q15, i32)
q31 __builtin_mips_shll_s_w (q31, imm0_31)
q31 __builtin_mips_shll_s_w (q31, i32)
v4i8 __builtin_mips_shrl_qb (v4i8, imm0_7)
v4i8 __builtin_mips_shrl_qb (v4i8, i32)
v2q15 __builtin_mips_shra_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shra_ph (v2q15, i32)
v2q15 __builtin_mips_shra_r_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shra_r_ph (v2q15, i32)
q31 __builtin_mips_shra_r_w (q31, imm0_31)
q31 __builtin_mips_shra_r_w (q31, i32)
v2q15 __builtin_mips_muleu_s_ph_qbl (v4i8, v2q15)
v2q15 __builtin_mips_muleu_s_ph_qbr (v4i8, v2q15)
v2q15 __builtin_mips_mulq_rs_ph (v2q15, v2q15)
q31 __builtin_mips_muleq_s_w_phl (v2q15, v2q15)
q31 __builtin_mips_muleq_s_w_phr (v2q15, v2q15)
a64 __builtin_mips_dpau_h_qbl (a64, v4i8, v4i8)
a64 __builtin_mips_dpau_h_qbr (a64, v4i8, v4i8)
a64 __builtin_mips_dpsu_h_qbl (a64, v4i8, v4i8)
a64 __builtin_mips_dpsu_h_qbr (a64, v4i8, v4i8)
a64 __builtin_mips_dpaq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_dpaq_sa_l_w (a64, q31, q31)
a64 __builtin_mips_dpsq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_dpsq_sa_l_w (a64, q31, q31)
a64 __builtin_mips_mulsaq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_maq_s_w_phl (a64, v2q15, v2q15)
a64 __builtin_mips_maq_s_w_phr (a64, v2q15, v2q15)
a64 __builtin_mips_maq_sa_w_phl (a64, v2q15, v2q15)
a64 __builtin_mips_maq_sa_w_phr (a64, v2q15, v2q15)
i32 __builtin_mips_bitrev (i32)
i32 __builtin_mips_insv (i32, i32)
v4i8 __builtin_mips_repl_qb (imm0_255)
v4i8 __builtin_mips_repl_qb (i32)
v2q15 __builtin_mips_repl_ph (imm_n512_511)
v2q15 __builtin_mips_repl_ph (i32)
void __builtin_mips_cmpu_eq_qb (v4i8, v4i8)
void __builtin_mips_cmpu_lt_qb (v4i8, v4i8)
void __builtin_mips_cmpu_le_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_eq_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_lt_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_le_qb (v4i8, v4i8)
void __builtin_mips_cmp_eq_ph (v2q15, v2q15)
void __builtin_mips_cmp_lt_ph (v2q15, v2q15)
void __builtin_mips_cmp_le_ph (v2q15, v2q15)
v4i8 __builtin_mips_pick_qb (v4i8, v4i8)
v2q15 __builtin_mips_pick_ph (v2q15, v2q15)
v2q15 __builtin_mips_packrl_ph (v2q15, v2q15)
i32 __builtin_mips_extr_w (a64, imm0_31)
i32 __builtin_mips_extr_w (a64, i32)
i32 __builtin_mips_extr_r_w (a64, imm0_31)
i32 __builtin_mips_extr_s_h (a64, i32)
i32 __builtin_mips_extr_rs_w (a64, imm0_31)
i32 __builtin_mips_extr_rs_w (a64, i32)
i32 __builtin_mips_extr_s_h (a64, imm0_31)
i32 __builtin_mips_extr_r_w (a64, i32)
i32 __builtin_mips_extp (a64, imm0_31)
i32 __builtin_mips_extp (a64, i32)
i32 __builtin_mips_extpdp (a64, imm0_31)
i32 __builtin_mips_extpdp (a64, i32)
a64 __builtin_mips_shilo (a64, imm_n32_31)
a64 __builtin_mips_shilo (a64, i32)
a64 __builtin_mips_mthlip (a64, i32)
void __builtin_mips_wrdsp (i32, imm0_63)
i32 __builtin_mips_rddsp (imm0_63)
i32 __builtin_mips_lbux (void *, i32)
i32 __builtin_mips_lhx (void *, i32)
i32 __builtin_mips_lwx (void *, i32)
a64 __builtin_mips_ldx (void *, i32) [MIPS64 only]
i32 __builtin_mips_bposge32 (void)
a64 __builtin_mips_madd (a64, i32, i32);
a64 __builtin_mips_maddu (a64, ui32, ui32);
a64 __builtin_mips_msub (a64, i32, i32);
a64 __builtin_mips_msubu (a64, ui32, ui32);
a64 __builtin_mips_mult (i32, i32);
a64 __builtin_mips_multu (ui32, ui32);
@end smallexample

The following built-in functions map directly to a particular MIPS DSP REV 2
instruction.  Please refer to the architecture specification
for details on what each instruction does.

@smallexample
v4q7 __builtin_mips_absq_s_qb (v4q7);
v2i16 __builtin_mips_addu_ph (v2i16, v2i16);
v2i16 __builtin_mips_addu_s_ph (v2i16, v2i16);
v4i8 __builtin_mips_adduh_qb (v4i8, v4i8);
v4i8 __builtin_mips_adduh_r_qb (v4i8, v4i8);
i32 __builtin_mips_append (i32, i32, imm0_31);
i32 __builtin_mips_balign (i32, i32, imm0_3);
i32 __builtin_mips_cmpgdu_eq_qb (v4i8, v4i8);
i32 __builtin_mips_cmpgdu_lt_qb (v4i8, v4i8);
i32 __builtin_mips_cmpgdu_le_qb (v4i8, v4i8);
a64 __builtin_mips_dpa_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dps_w_ph (a64, v2i16, v2i16);
v2i16 __builtin_mips_mul_ph (v2i16, v2i16);
v2i16 __builtin_mips_mul_s_ph (v2i16, v2i16);
q31 __builtin_mips_mulq_rs_w (q31, q31);
v2q15 __builtin_mips_mulq_s_ph (v2q15, v2q15);
q31 __builtin_mips_mulq_s_w (q31, q31);
a64 __builtin_mips_mulsa_w_ph (a64, v2i16, v2i16);
v4i8 __builtin_mips_precr_qb_ph (v2i16, v2i16);
v2i16 __builtin_mips_precr_sra_ph_w (i32, i32, imm0_31);
v2i16 __builtin_mips_precr_sra_r_ph_w (i32, i32, imm0_31);
i32 __builtin_mips_prepend (i32, i32, imm0_31);
v4i8 __builtin_mips_shra_qb (v4i8, imm0_7);
v4i8 __builtin_mips_shra_r_qb (v4i8, imm0_7);
v4i8 __builtin_mips_shra_qb (v4i8, i32);
v4i8 __builtin_mips_shra_r_qb (v4i8, i32);
v2i16 __builtin_mips_shrl_ph (v2i16, imm0_15);
v2i16 __builtin_mips_shrl_ph (v2i16, i32);
v2i16 __builtin_mips_subu_ph (v2i16, v2i16);
v2i16 __builtin_mips_subu_s_ph (v2i16, v2i16);
v4i8 __builtin_mips_subuh_qb (v4i8, v4i8);
v4i8 __builtin_mips_subuh_r_qb (v4i8, v4i8);
v2q15 __builtin_mips_addqh_ph (v2q15, v2q15);
v2q15 __builtin_mips_addqh_r_ph (v2q15, v2q15);
q31 __builtin_mips_addqh_w (q31, q31);
q31 __builtin_mips_addqh_r_w (q31, q31);
v2q15 __builtin_mips_subqh_ph (v2q15, v2q15);
v2q15 __builtin_mips_subqh_r_ph (v2q15, v2q15);
q31 __builtin_mips_subqh_w (q31, q31);
q31 __builtin_mips_subqh_r_w (q31, q31);
a64 __builtin_mips_dpax_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dpsx_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dpaqx_s_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpaqx_sa_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpsqx_s_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpsqx_sa_w_ph (a64, v2q15, v2q15);
@end smallexample


@node MIPS Paired-Single Support
@subsection MIPS Paired-Single Support

The MIPS64 architecture includes a number of instructions that
operate on pairs of single-precision floating-point values.
Each pair is packed into a 64-bit floating-point register,
with one element being designated the ``upper half'' and
the other being designated the ``lower half''.

GCC supports paired-single operations using both the generic
vector extensions (@pxref{Vector Extensions}) and a collection of
MIPS-specific built-in functions.  Both kinds of support are
enabled by the @option{-mpaired-single} command-line option.

The vector type associated with paired-single values is usually
called @code{v2sf}.  It can be defined in C as follows:

@smallexample
typedef float v2sf __attribute__ ((vector_size (8)));
@end smallexample

@code{v2sf} values are initialized in the same way as aggregates.
For example:

@smallexample
v2sf a = @{1.5, 9.1@};
v2sf b;
float e, f;
b = (v2sf) @{e, f@};
@end smallexample

@emph{Note:} The CPU's endianness determines which value is stored in
the upper half of a register and which value is stored in the lower half.
On little-endian targets, the first value is the lower one and the second
value is the upper one.  The opposite order applies to big-endian targets.
For example, the code above sets the lower half of @code{a} to
@code{1.5} on little-endian targets and @code{9.1} on big-endian targets.

@node MIPS Loongson Built-in Functions
@subsection MIPS Loongson Built-in Functions

GCC provides intrinsics to access the SIMD instructions provided by the
ST Microelectronics Loongson-2E and -2F processors.  These intrinsics,
available after inclusion of the @code{loongson.h} header file,
operate on the following 64-bit vector types:

@itemize
@item @code{uint8x8_t}, a vector of eight unsigned 8-bit integers;
@item @code{uint16x4_t}, a vector of four unsigned 16-bit integers;
@item @code{uint32x2_t}, a vector of two unsigned 32-bit integers;
@item @code{int8x8_t}, a vector of eight signed 8-bit integers;
@item @code{int16x4_t}, a vector of four signed 16-bit integers;
@item @code{int32x2_t}, a vector of two signed 32-bit integers.
@end itemize

The intrinsics provided are listed below; each is named after the
machine instruction to which it corresponds, with suffixes added as
appropriate to distinguish intrinsics that expand to the same machine
instruction yet have different argument types.  Refer to the architecture
documentation for a description of the functionality of each
instruction.

@smallexample
int16x4_t packsswh (int32x2_t s, int32x2_t t);
int8x8_t packsshb (int16x4_t s, int16x4_t t);
uint8x8_t packushb (uint16x4_t s, uint16x4_t t);
uint32x2_t paddw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t paddh_u (uint16x4_t s, uint16x4_t t);
uint8x8_t paddb_u (uint8x8_t s, uint8x8_t t);
int32x2_t paddw_s (int32x2_t s, int32x2_t t);
int16x4_t paddh_s (int16x4_t s, int16x4_t t);
int8x8_t paddb_s (int8x8_t s, int8x8_t t);
uint64_t paddd_u (uint64_t s, uint64_t t);
int64_t paddd_s (int64_t s, int64_t t);
int16x4_t paddsh (int16x4_t s, int16x4_t t);
int8x8_t paddsb (int8x8_t s, int8x8_t t);
uint16x4_t paddush (uint16x4_t s, uint16x4_t t);
uint8x8_t paddusb (uint8x8_t s, uint8x8_t t);
uint64_t pandn_ud (uint64_t s, uint64_t t);
uint32x2_t pandn_uw (uint32x2_t s, uint32x2_t t);
uint16x4_t pandn_uh (uint16x4_t s, uint16x4_t t);
uint8x8_t pandn_ub (uint8x8_t s, uint8x8_t t);
int64_t pandn_sd (int64_t s, int64_t t);
int32x2_t pandn_sw (int32x2_t s, int32x2_t t);
int16x4_t pandn_sh (int16x4_t s, int16x4_t t);
int8x8_t pandn_sb (int8x8_t s, int8x8_t t);
uint16x4_t pavgh (uint16x4_t s, uint16x4_t t);
uint8x8_t pavgb (uint8x8_t s, uint8x8_t t);
uint32x2_t pcmpeqw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t pcmpeqh_u (uint16x4_t s, uint16x4_t t);
uint8x8_t pcmpeqb_u (uint8x8_t s, uint8x8_t t);
int32x2_t pcmpeqw_s (int32x2_t s, int32x2_t t);
int16x4_t pcmpeqh_s (int16x4_t s, int16x4_t t);
int8x8_t pcmpeqb_s (int8x8_t s, int8x8_t t);
uint32x2_t pcmpgtw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t pcmpgth_u (uint16x4_t s, uint16x4_t t);
uint8x8_t pcmpgtb_u (uint8x8_t s, uint8x8_t t);
int32x2_t pcmpgtw_s (int32x2_t s, int32x2_t t);
int16x4_t pcmpgth_s (int16x4_t s, int16x4_t t);
int8x8_t pcmpgtb_s (int8x8_t s, int8x8_t t);
uint16x4_t pextrh_u (uint16x4_t s, int field);
int16x4_t pextrh_s (int16x4_t s, int field);
uint16x4_t pinsrh_0_u (uint16x4_t s, uint16x4_t t);
uint16x4_t pinsrh_1_u (uint16x4_t s, uint16x4_t t);
uint16x4_t pinsrh_2_u (uint16x4_t s, uint16x4_t t);
uint16x4_t pinsrh_3_u (uint16x4_t s, uint16x4_t t);
int16x4_t pinsrh_0_s (int16x4_t s, int16x4_t t);
int16x4_t pinsrh_1_s (int16x4_t s, int16x4_t t);
int16x4_t pinsrh_2_s (int16x4_t s, int16x4_t t);
int16x4_t pinsrh_3_s (int16x4_t s, int16x4_t t);
int32x2_t pmaddhw (int16x4_t s, int16x4_t t);
int16x4_t pmaxsh (int16x4_t s, int16x4_t t);
uint8x8_t pmaxub (uint8x8_t s, uint8x8_t t);
int16x4_t pminsh (int16x4_t s, int16x4_t t);
uint8x8_t pminub (uint8x8_t s, uint8x8_t t);
uint8x8_t pmovmskb_u (uint8x8_t s);
int8x8_t pmovmskb_s (int8x8_t s);
uint16x4_t pmulhuh (uint16x4_t s, uint16x4_t t);
int16x4_t pmulhh (int16x4_t s, int16x4_t t);
int16x4_t pmullh (int16x4_t s, int16x4_t t);
int64_t pmuluw (uint32x2_t s, uint32x2_t t);
uint8x8_t pasubub (uint8x8_t s, uint8x8_t t);
uint16x4_t biadd (uint8x8_t s);
uint16x4_t psadbh (uint8x8_t s, uint8x8_t t);
uint16x4_t pshufh_u (uint16x4_t dest, uint16x4_t s, uint8_t order);
int16x4_t pshufh_s (int16x4_t dest, int16x4_t s, uint8_t order);
uint16x4_t psllh_u (uint16x4_t s, uint8_t amount);
int16x4_t psllh_s (int16x4_t s, uint8_t amount);
uint32x2_t psllw_u (uint32x2_t s, uint8_t amount);
int32x2_t psllw_s (int32x2_t s, uint8_t amount);
uint16x4_t psrlh_u (uint16x4_t s, uint8_t amount);
int16x4_t psrlh_s (int16x4_t s, uint8_t amount);
uint32x2_t psrlw_u (uint32x2_t s, uint8_t amount);
int32x2_t psrlw_s (int32x2_t s, uint8_t amount);
uint16x4_t psrah_u (uint16x4_t s, uint8_t amount);
int16x4_t psrah_s (int16x4_t s, uint8_t amount);
uint32x2_t psraw_u (uint32x2_t s, uint8_t amount);
int32x2_t psraw_s (int32x2_t s, uint8_t amount);
uint32x2_t psubw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t psubh_u (uint16x4_t s, uint16x4_t t);
uint8x8_t psubb_u (uint8x8_t s, uint8x8_t t);
int32x2_t psubw_s (int32x2_t s, int32x2_t t);
int16x4_t psubh_s (int16x4_t s, int16x4_t t);
int8x8_t psubb_s (int8x8_t s, int8x8_t t);
uint64_t psubd_u (uint64_t s, uint64_t t);
int64_t psubd_s (int64_t s, int64_t t);
int16x4_t psubsh (int16x4_t s, int16x4_t t);
int8x8_t psubsb (int8x8_t s, int8x8_t t);
uint16x4_t psubush (uint16x4_t s, uint16x4_t t);
uint8x8_t psubusb (uint8x8_t s, uint8x8_t t);
uint32x2_t punpckhwd_u (uint32x2_t s, uint32x2_t t);
uint16x4_t punpckhhw_u (uint16x4_t s, uint16x4_t t);
uint8x8_t punpckhbh_u (uint8x8_t s, uint8x8_t t);
int32x2_t punpckhwd_s (int32x2_t s, int32x2_t t);
int16x4_t punpckhhw_s (int16x4_t s, int16x4_t t);
int8x8_t punpckhbh_s (int8x8_t s, int8x8_t t);
uint32x2_t punpcklwd_u (uint32x2_t s, uint32x2_t t);
uint16x4_t punpcklhw_u (uint16x4_t s, uint16x4_t t);
uint8x8_t punpcklbh_u (uint8x8_t s, uint8x8_t t);
int32x2_t punpcklwd_s (int32x2_t s, int32x2_t t);
int16x4_t punpcklhw_s (int16x4_t s, int16x4_t t);
int8x8_t punpcklbh_s (int8x8_t s, int8x8_t t);
@end smallexample

@menu
* Paired-Single Arithmetic::
* Paired-Single Built-in Functions::
* MIPS-3D Built-in Functions::
@end menu

@node Paired-Single Arithmetic
@subsubsection Paired-Single Arithmetic

The table below lists the @code{v2sf} operations for which hardware
support exists.  @code{a}, @code{b} and @code{c} are @code{v2sf}
values and @code{x} is an integral value.

@multitable @columnfractions .50 .50
@item C code @tab MIPS instruction
@item @code{a + b} @tab @code{add.ps}
@item @code{a - b} @tab @code{sub.ps}
@item @code{-a} @tab @code{neg.ps}
@item @code{a * b} @tab @code{mul.ps}
@item @code{a * b + c} @tab @code{madd.ps}
@item @code{a * b - c} @tab @code{msub.ps}
@item @code{-(a * b + c)} @tab @code{nmadd.ps}
@item @code{-(a * b - c)} @tab @code{nmsub.ps}
@item @code{x ? a : b} @tab @code{movn.ps}/@code{movz.ps}
@end multitable

Note that the multiply-accumulate instructions can be disabled
using the command-line option @code{-mno-fused-madd}.

@node Paired-Single Built-in Functions
@subsubsection Paired-Single Built-in Functions

The following paired-single functions map directly to a particular
MIPS instruction.  Please refer to the architecture specification
for details on what each instruction does.

@table @code
@item v2sf __builtin_mips_pll_ps (v2sf, v2sf)
Pair lower lower (@code{pll.ps}).

@item v2sf __builtin_mips_pul_ps (v2sf, v2sf)
Pair upper lower (@code{pul.ps}).

@item v2sf __builtin_mips_plu_ps (v2sf, v2sf)
Pair lower upper (@code{plu.ps}).

@item v2sf __builtin_mips_puu_ps (v2sf, v2sf)
Pair upper upper (@code{puu.ps}).

@item v2sf __builtin_mips_cvt_ps_s (float, float)
Convert pair to paired single (@code{cvt.ps.s}).

@item float __builtin_mips_cvt_s_pl (v2sf)
Convert pair lower to single (@code{cvt.s.pl}).

@item float __builtin_mips_cvt_s_pu (v2sf)
Convert pair upper to single (@code{cvt.s.pu}).

@item v2sf __builtin_mips_abs_ps (v2sf)
Absolute value (@code{abs.ps}).

@item v2sf __builtin_mips_alnv_ps (v2sf, v2sf, int)
Align variable (@code{alnv.ps}).

@emph{Note:} The value of the third parameter must be 0 or 4
modulo 8, otherwise the result is unpredictable.  Please read the
instruction description for details.
@end table

The following multi-instruction functions are also available.
In each case, @var{cond} can be any of the 16 floating-point conditions:
@code{f}, @code{un}, @code{eq}, @code{ueq}, @code{olt}, @code{ult},
@code{ole}, @code{ule}, @code{sf}, @code{ngle}, @code{seq}, @code{ngl},
@code{lt}, @code{nge}, @code{le} or @code{ngt}.

@table @code
@item v2sf __builtin_mips_movt_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx v2sf __builtin_mips_movf_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
Conditional move based on floating-point comparison (@code{c.@var{cond}.ps},
@code{movt.ps}/@code{movf.ps}).

The @code{movt} functions return the value @var{x} computed by:

@smallexample
c.@var{cond}.ps @var{cc},@var{a},@var{b}
mov.ps @var{x},@var{c}
movt.ps @var{x},@var{d},@var{cc}
@end smallexample

The @code{movf} functions are similar but use @code{movf.ps} instead
of @code{movt.ps}.

@item int __builtin_mips_upper_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_lower_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
Comparison of two paired-single values (@code{c.@var{cond}.ps},
@code{bc1t}/@code{bc1f}).

These functions compare @var{a} and @var{b} using @code{c.@var{cond}.ps}
and return either the upper or lower half of the result.  For example:

@smallexample
v2sf a, b;
if (__builtin_mips_upper_c_eq_ps (a, b))
  upper_halves_are_equal ();
else
  upper_halves_are_unequal ();

if (__builtin_mips_lower_c_eq_ps (a, b))
  lower_halves_are_equal ();
else
  lower_halves_are_unequal ();
@end smallexample
@end table

@node MIPS-3D Built-in Functions
@subsubsection MIPS-3D Built-in Functions

The MIPS-3D Application-Specific Extension (ASE) includes additional
paired-single instructions that are designed to improve the performance
of 3D graphics operations.  Support for these instructions is controlled
by the @option{-mips3d} command-line option.

The functions listed below map directly to a particular MIPS-3D
instruction.  Please refer to the architecture specification for
more details on what each instruction does.

@table @code
@item v2sf __builtin_mips_addr_ps (v2sf, v2sf)
Reduction add (@code{addr.ps}).

@item v2sf __builtin_mips_mulr_ps (v2sf, v2sf)
Reduction multiply (@code{mulr.ps}).

@item v2sf __builtin_mips_cvt_pw_ps (v2sf)
Convert paired single to paired word (@code{cvt.pw.ps}).

@item v2sf __builtin_mips_cvt_ps_pw (v2sf)
Convert paired word to paired single (@code{cvt.ps.pw}).

@item float __builtin_mips_recip1_s (float)
@itemx double __builtin_mips_recip1_d (double)
@itemx v2sf __builtin_mips_recip1_ps (v2sf)
Reduced-precision reciprocal (sequence step 1) (@code{recip1.@var{fmt}}).

@item float __builtin_mips_recip2_s (float, float)
@itemx double __builtin_mips_recip2_d (double, double)
@itemx v2sf __builtin_mips_recip2_ps (v2sf, v2sf)
Reduced-precision reciprocal (sequence step 2) (@code{recip2.@var{fmt}}).

@item float __builtin_mips_rsqrt1_s (float)
@itemx double __builtin_mips_rsqrt1_d (double)
@itemx v2sf __builtin_mips_rsqrt1_ps (v2sf)
Reduced-precision reciprocal square root (sequence step 1)
(@code{rsqrt1.@var{fmt}}).

@item float __builtin_mips_rsqrt2_s (float, float)
@itemx double __builtin_mips_rsqrt2_d (double, double)
@itemx v2sf __builtin_mips_rsqrt2_ps (v2sf, v2sf)
Reduced-precision reciprocal square root (sequence step 2)
(@code{rsqrt2.@var{fmt}}).
@end table

The following multi-instruction functions are also available.
In each case, @var{cond} can be any of the 16 floating-point conditions:
@code{f}, @code{un}, @code{eq}, @code{ueq}, @code{olt}, @code{ult},
@code{ole}, @code{ule}, @code{sf}, @code{ngle}, @code{seq},
@code{ngl}, @code{lt}, @code{nge}, @code{le} or @code{ngt}.

@table @code
@item int __builtin_mips_cabs_@var{cond}_s (float @var{a}, float @var{b})
@itemx int __builtin_mips_cabs_@var{cond}_d (double @var{a}, double @var{b})
Absolute comparison of two scalar values (@code{cabs.@var{cond}.@var{fmt}},
@code{bc1t}/@code{bc1f}).

These functions compare @var{a} and @var{b} using @code{cabs.@var{cond}.s}
or @code{cabs.@var{cond}.d} and return the result as a boolean value.
For example:

@smallexample
float a, b;
if (__builtin_mips_cabs_eq_s (a, b))
  true ();
else
  false ();
@end smallexample

@item int __builtin_mips_upper_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_lower_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
Absolute comparison of two paired-single values (@code{cabs.@var{cond}.ps},
@code{bc1t}/@code{bc1f}).

These functions compare @var{a} and @var{b} using @code{cabs.@var{cond}.ps}
and return either the upper or lower half of the result.  For example:

@smallexample
v2sf a, b;
if (__builtin_mips_upper_cabs_eq_ps (a, b))
  upper_halves_are_equal ();
else
  upper_halves_are_unequal ();

if (__builtin_mips_lower_cabs_eq_ps (a, b))
  lower_halves_are_equal ();
else
  lower_halves_are_unequal ();
@end smallexample

@item v2sf __builtin_mips_movt_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx v2sf __builtin_mips_movf_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
Conditional move based on absolute comparison (@code{cabs.@var{cond}.ps},
@code{movt.ps}/@code{movf.ps}).

The @code{movt} functions return the value @var{x} computed by:

@smallexample
cabs.@var{cond}.ps @var{cc},@var{a},@var{b}
mov.ps @var{x},@var{c}
movt.ps @var{x},@var{d},@var{cc}
@end smallexample

The @code{movf} functions are similar but use @code{movf.ps} instead
of @code{movt.ps}.

@item int __builtin_mips_any_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_all_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_any_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_all_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
Comparison of two paired-single values
(@code{c.@var{cond}.ps}/@code{cabs.@var{cond}.ps},
@code{bc1any2t}/@code{bc1any2f}).

These functions compare @var{a} and @var{b} using @code{c.@var{cond}.ps}
or @code{cabs.@var{cond}.ps}.  The @code{any} forms return true if either
result is true and the @code{all} forms return true if both results are true.
For example:

@smallexample
v2sf a, b;
if (__builtin_mips_any_c_eq_ps (a, b))
  one_is_true ();
else
  both_are_false ();

if (__builtin_mips_all_c_eq_ps (a, b))
  both_are_true ();
else
  one_is_false ();
@end smallexample

@item int __builtin_mips_any_c_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx int __builtin_mips_all_c_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx int __builtin_mips_any_cabs_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx int __builtin_mips_all_cabs_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
Comparison of four paired-single values
(@code{c.@var{cond}.ps}/@code{cabs.@var{cond}.ps},
@code{bc1any4t}/@code{bc1any4f}).

These functions use @code{c.@var{cond}.ps} or @code{cabs.@var{cond}.ps}
to compare @var{a} with @var{b} and to compare @var{c} with @var{d}.
The @code{any} forms return true if any of the four results are true
and the @code{all} forms return true if all four results are true.
For example:

@smallexample
v2sf a, b, c, d;
if (__builtin_mips_any_c_eq_4s (a, b, c, d))
  some_are_true ();
else
  all_are_false ();

if (__builtin_mips_all_c_eq_4s (a, b, c, d))
  all_are_true ();
else
  some_are_false ();
@end smallexample
@end table

@node MIPS SIMD Architecture (MSA) Support
@subsection MIPS SIMD Architecture (MSA) Support

@menu
* MIPS SIMD Architecture Built-in Functions::
@end menu

GCC provides intrinsics to access the SIMD instructions provided by the
MSA MIPS SIMD Architecture.  The interface is made available by including
@code{<msa.h>} and using @option{-mmsa -mhard-float -mfp64 -mnan=2008}.
For each @code{__builtin_msa_*}, there is a shortened name of the intrinsic,
@code{__msa_*}.

MSA implements 128-bit wide vector registers, operating on 8-, 16-, 32- and
64-bit integer, 16- and 32-bit fixed-point, or 32- and 64-bit floating point
data elements.  The following vectors typedefs are included in @code{msa.h}:
@itemize
@item @code{v16i8}, a vector of sixteen signed 8-bit integers;
@item @code{v16u8}, a vector of sixteen unsigned 8-bit integers;
@item @code{v8i16}, a vector of eight signed 16-bit integers;
@item @code{v8u16}, a vector of eight unsigned 16-bit integers;
@item @code{v4i32}, a vector of four signed 32-bit integers;
@item @code{v4u32}, a vector of four unsigned 32-bit integers;
@item @code{v2i64}, a vector of two signed 64-bit integers;
@item @code{v2u64}, a vector of two unsigned 64-bit integers;
@item @code{v4f32}, a vector of four 32-bit floats;
@item @code{v2f64}, a vector of two 64-bit doubles.
@end itemize

Instructions and corresponding built-ins may have additional restrictions and/or
input/output values manipulated:
@itemize
@item @code{imm0_1}, an integer literal in range 0 to 1;
@item @code{imm0_3}, an integer literal in range 0 to 3;
@item @code{imm0_7}, an integer literal in range 0 to 7;
@item @code{imm0_15}, an integer literal in range 0 to 15;
@item @code{imm0_31}, an integer literal in range 0 to 31;
@item @code{imm0_63}, an integer literal in range 0 to 63;
@item @code{imm0_255}, an integer literal in range 0 to 255;
@item @code{imm_n16_15}, an integer literal in range -16 to 15;
@item @code{imm_n512_511}, an integer literal in range -512 to 511;
@item @code{imm_n1024_1022}, an integer literal in range -512 to 511 left
shifted by 1 bit, i.e., -1024, -1022, @dots{}, 1020, 1022;
@item @code{imm_n2048_2044}, an integer literal in range -512 to 511 left
shifted by 2 bits, i.e., -2048, -2044, @dots{}, 2040, 2044;
@item @code{imm_n4096_4088}, an integer literal in range -512 to 511 left
shifted by 3 bits, i.e., -4096, -4088, @dots{}, 4080, 4088;
@item @code{imm1_4}, an integer literal in range 1 to 4;
@item @code{i32, i64, u32, u64, f32, f64}, defined as follows:
@end itemize

@smallexample
@{
typedef int i32;
#if __LONG_MAX__ == __LONG_LONG_MAX__
typedef long i64;
#else
typedef long long i64;
#endif

typedef unsigned int u32;
#if __LONG_MAX__ == __LONG_LONG_MAX__
typedef unsigned long u64;
#else
typedef unsigned long long u64;
#endif

typedef double f64;
typedef float f32;
@}
@end smallexample

@node MIPS SIMD Architecture Built-in Functions
@subsubsection MIPS SIMD Architecture Built-in Functions

The intrinsics provided are listed below; each is named after the
machine instruction.

@smallexample
v16i8 __builtin_msa_add_a_b (v16i8, v16i8);
v8i16 __builtin_msa_add_a_h (v8i16, v8i16);
v4i32 __builtin_msa_add_a_w (v4i32, v4i32);
v2i64 __builtin_msa_add_a_d (v2i64, v2i64);

v16i8 __builtin_msa_adds_a_b (v16i8, v16i8);
v8i16 __builtin_msa_adds_a_h (v8i16, v8i16);
v4i32 __builtin_msa_adds_a_w (v4i32, v4i32);
v2i64 __builtin_msa_adds_a_d (v2i64, v2i64);

v16i8 __builtin_msa_adds_s_b (v16i8, v16i8);
v8i16 __builtin_msa_adds_s_h (v8i16, v8i16);
v4i32 __builtin_msa_adds_s_w (v4i32, v4i32);
v2i64 __builtin_msa_adds_s_d (v2i64, v2i64);

v16u8 __builtin_msa_adds_u_b (v16u8, v16u8);
v8u16 __builtin_msa_adds_u_h (v8u16, v8u16);
v4u32 __builtin_msa_adds_u_w (v4u32, v4u32);
v2u64 __builtin_msa_adds_u_d (v2u64, v2u64);

v16i8 __builtin_msa_addv_b (v16i8, v16i8);
v8i16 __builtin_msa_addv_h (v8i16, v8i16);
v4i32 __builtin_msa_addv_w (v4i32, v4i32);
v2i64 __builtin_msa_addv_d (v2i64, v2i64);

v16i8 __builtin_msa_addvi_b (v16i8, imm0_31);
v8i16 __builtin_msa_addvi_h (v8i16, imm0_31);
v4i32 __builtin_msa_addvi_w (v4i32, imm0_31);
v2i64 __builtin_msa_addvi_d (v2i64, imm0_31);

v16u8 __builtin_msa_and_v (v16u8, v16u8);

v16u8 __builtin_msa_andi_b (v16u8, imm0_255);

v16i8 __builtin_msa_asub_s_b (v16i8, v16i8);
v8i16 __builtin_msa_asub_s_h (v8i16, v8i16);
v4i32 __builtin_msa_asub_s_w (v4i32, v4i32);
v2i64 __builtin_msa_asub_s_d (v2i64, v2i64);

v16u8 __builtin_msa_asub_u_b (v16u8, v16u8);
v8u16 __builtin_msa_asub_u_h (v8u16, v8u16);
v4u32 __builtin_msa_asub_u_w (v4u32, v4u32);
v2u64 __builtin_msa_asub_u_d (v2u64, v2u64);

v16i8 __builtin_msa_ave_s_b (v16i8, v16i8);
v8i16 __builtin_msa_ave_s_h (v8i16, v8i16);
v4i32 __builtin_msa_ave_s_w (v4i32, v4i32);
v2i64 __builtin_msa_ave_s_d (v2i64, v2i64);

v16u8 __builtin_msa_ave_u_b (v16u8, v16u8);
v8u16 __builtin_msa_ave_u_h (v8u16, v8u16);
v4u32 __builtin_msa_ave_u_w (v4u32, v4u32);
v2u64 __builtin_msa_ave_u_d (v2u64, v2u64);

v16i8 __builtin_msa_aver_s_b (v16i8, v16i8);
v8i16 __builtin_msa_aver_s_h (v8i16, v8i16);
v4i32 __builtin_msa_aver_s_w (v4i32, v4i32);
v2i64 __builtin_msa_aver_s_d (v2i64, v2i64);

v16u8 __builtin_msa_aver_u_b (v16u8, v16u8);
v8u16 __builtin_msa_aver_u_h (v8u16, v8u16);
v4u32 __builtin_msa_aver_u_w (v4u32, v4u32);
v2u64 __builtin_msa_aver_u_d (v2u64, v2u64);

v16u8 __builtin_msa_bclr_b (v16u8, v16u8);
v8u16 __builtin_msa_bclr_h (v8u16, v8u16);
v4u32 __builtin_msa_bclr_w (v4u32, v4u32);
v2u64 __builtin_msa_bclr_d (v2u64, v2u64);

v16u8 __builtin_msa_bclri_b (v16u8, imm0_7);
v8u16 __builtin_msa_bclri_h (v8u16, imm0_15);
v4u32 __builtin_msa_bclri_w (v4u32, imm0_31);
v2u64 __builtin_msa_bclri_d (v2u64, imm0_63);

v16u8 __builtin_msa_binsl_b (v16u8, v16u8, v16u8);
v8u16 __builtin_msa_binsl_h (v8u16, v8u16, v8u16);
v4u32 __builtin_msa_binsl_w (v4u32, v4u32, v4u32);
v2u64 __builtin_msa_binsl_d (v2u64, v2u64, v2u64);

v16u8 __builtin_msa_binsli_b (v16u8, v16u8, imm0_7);
v8u16 __builtin_msa_binsli_h (v8u16, v8u16, imm0_15);
v4u32 __builtin_msa_binsli_w (v4u32, v4u32, imm0_31);
v2u64 __builtin_msa_binsli_d (v2u64, v2u64, imm0_63);

v16u8 __builtin_msa_binsr_b (v16u8, v16u8, v16u8);
v8u16 __builtin_msa_binsr_h (v8u16, v8u16, v8u16);
v4u32 __builtin_msa_binsr_w (v4u32, v4u32, v4u32);
v2u64 __builtin_msa_binsr_d (v2u64, v2u64, v2u64);

v16u8 __builtin_msa_binsri_b (v16u8, v16u8, imm0_7);
v8u16 __builtin_msa_binsri_h (v8u16, v8u16, imm0_15);
v4u32 __builtin_msa_binsri_w (v4u32, v4u32, imm0_31);
v2u64 __builtin_msa_binsri_d (v2u64, v2u64, imm0_63);

v16u8 __builtin_msa_bmnz_v (v16u8, v16u8, v16u8);

v16u8 __builtin_msa_bmnzi_b (v16u8, v16u8, imm0_255);

v16u8 __builtin_msa_bmz_v (v16u8, v16u8, v16u8);

v16u8 __builtin_msa_bmzi_b (v16u8, v16u8, imm0_255);

v16u8 __builtin_msa_bneg_b (v16u8, v16u8);
v8u16 __builtin_msa_bneg_h (v8u16, v8u16);
v4u32 __builtin_msa_bneg_w (v4u32, v4u32);
v2u64 __builtin_msa_bneg_d (v2u64, v2u64);

v16u8 __builtin_msa_bnegi_b (v16u8, imm0_7);
v8u16 __builtin_msa_bnegi_h (v8u16, imm0_15);
v4u32 __builtin_msa_bnegi_w (v4u32, imm0_31);
v2u64 __builtin_msa_bnegi_d (v2u64, imm0_63);

i32 __builtin_msa_bnz_b (v16u8);
i32 __builtin_msa_bnz_h (v8u16);
i32 __builtin_msa_bnz_w (v4u32);
i32 __builtin_msa_bnz_d (v2u64);

i32 __builtin_msa_bnz_v (v16u8);

v16u8 __builtin_msa_bsel_v (v16u8, v16u8, v16u8);

v16u8 __builtin_msa_bseli_b (v16u8, v16u8, imm0_255);

v16u8 __builtin_msa_bset_b (v16u8, v16u8);
v8u16 __builtin_msa_bset_h (v8u16, v8u16);
v4u32 __builtin_msa_bset_w (v4u32, v4u32);
v2u64 __builtin_msa_bset_d (v2u64, v2u64);

v16u8 __builtin_msa_bseti_b (v16u8, imm0_7);
v8u16 __builtin_msa_bseti_h (v8u16, imm0_15);
v4u32 __builtin_msa_bseti_w (v4u32, imm0_31);
v2u64 __builtin_msa_bseti_d (v2u64, imm0_63);

i32 __builtin_msa_bz_b (v16u8);
i32 __builtin_msa_bz_h (v8u16);
i32 __builtin_msa_bz_w (v4u32);
i32 __builtin_msa_bz_d (v2u64);

i32 __builtin_msa_bz_v (v16u8);

v16i8 __builtin_msa_ceq_b (v16i8, v16i8);
v8i16 __builtin_msa_ceq_h (v8i16, v8i16);
v4i32 __builtin_msa_ceq_w (v4i32, v4i32);
v2i64 __builtin_msa_ceq_d (v2i64, v2i64);

v16i8 __builtin_msa_ceqi_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_ceqi_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_ceqi_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_ceqi_d (v2i64, imm_n16_15);

i32 __builtin_msa_cfcmsa (imm0_31);

v16i8 __builtin_msa_cle_s_b (v16i8, v16i8);
v8i16 __builtin_msa_cle_s_h (v8i16, v8i16);
v4i32 __builtin_msa_cle_s_w (v4i32, v4i32);
v2i64 __builtin_msa_cle_s_d (v2i64, v2i64);

v16i8 __builtin_msa_cle_u_b (v16u8, v16u8);
v8i16 __builtin_msa_cle_u_h (v8u16, v8u16);
v4i32 __builtin_msa_cle_u_w (v4u32, v4u32);
v2i64 __builtin_msa_cle_u_d (v2u64, v2u64);

v16i8 __builtin_msa_clei_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_clei_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_clei_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_clei_s_d (v2i64, imm_n16_15);

v16i8 __builtin_msa_clei_u_b (v16u8, imm0_31);
v8i16 __builtin_msa_clei_u_h (v8u16, imm0_31);
v4i32 __builtin_msa_clei_u_w (v4u32, imm0_31);
v2i64 __builtin_msa_clei_u_d (v2u64, imm0_31);

v16i8 __builtin_msa_clt_s_b (v16i8, v16i8);
v8i16 __builtin_msa_clt_s_h (v8i16, v8i16);
v4i32 __builtin_msa_clt_s_w (v4i32, v4i32);
v2i64 __builtin_msa_clt_s_d (v2i64, v2i64);

v16i8 __builtin_msa_clt_u_b (v16u8, v16u8);
v8i16 __builtin_msa_clt_u_h (v8u16, v8u16);
v4i32 __builtin_msa_clt_u_w (v4u32, v4u32);
v2i64 __builtin_msa_clt_u_d (v2u64, v2u64);

v16i8 __builtin_msa_clti_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_clti_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_clti_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_clti_s_d (v2i64, imm_n16_15);

v16i8 __builtin_msa_clti_u_b (v16u8, imm0_31);
v8i16 __builtin_msa_clti_u_h (v8u16, imm0_31);
v4i32 __builtin_msa_clti_u_w (v4u32, imm0_31);
v2i64 __builtin_msa_clti_u_d (v2u64, imm0_31);

i32 __builtin_msa_copy_s_b (v16i8, imm0_15);
i32 __builtin_msa_copy_s_h (v8i16, imm0_7);
i32 __builtin_msa_copy_s_w (v4i32, imm0_3);
i64 __builtin_msa_copy_s_d (v2i64, imm0_1);

u32 __builtin_msa_copy_u_b (v16i8, imm0_15);
u32 __builtin_msa_copy_u_h (v8i16, imm0_7);
u32 __builtin_msa_copy_u_w (v4i32, imm0_3);
u64 __builtin_msa_copy_u_d (v2i64, imm0_1);

void __builtin_msa_ctcmsa (imm0_31, i32);

v16i8 __builtin_msa_div_s_b (v16i8, v16i8);
v8i16 __builtin_msa_div_s_h (v8i16, v8i16);
v4i32 __builtin_msa_div_s_w (v4i32, v4i32);
v2i64 __builtin_msa_div_s_d (v2i64, v2i64);

v16u8 __builtin_msa_div_u_b (v16u8, v16u8);
v8u16 __builtin_msa_div_u_h (v8u16, v8u16);
v4u32 __builtin_msa_div_u_w (v4u32, v4u32);
v2u64 __builtin_msa_div_u_d (v2u64, v2u64);

v8i16 __builtin_msa_dotp_s_h (v16i8, v16i8);
v4i32 __builtin_msa_dotp_s_w (v8i16, v8i16);
v2i64 __builtin_msa_dotp_s_d (v4i32, v4i32);

v8u16 __builtin_msa_dotp_u_h (v16u8, v16u8);
v4u32 __builtin_msa_dotp_u_w (v8u16, v8u16);
v2u64 __builtin_msa_dotp_u_d (v4u32, v4u32);

v8i16 __builtin_msa_dpadd_s_h (v8i16, v16i8, v16i8);
v4i32 __builtin_msa_dpadd_s_w (v4i32, v8i16, v8i16);
v2i64 __builtin_msa_dpadd_s_d (v2i64, v4i32, v4i32);

v8u16 __builtin_msa_dpadd_u_h (v8u16, v16u8, v16u8);
v4u32 __builtin_msa_dpadd_u_w (v4u32, v8u16, v8u16);
v2u64 __builtin_msa_dpadd_u_d (v2u64, v4u32, v4u32);

v8i16 __builtin_msa_dpsub_s_h (v8i16, v16i8, v16i8);
v4i32 __builtin_msa_dpsub_s_w (v4i32, v8i16, v8i16);
v2i64 __builtin_msa_dpsub_s_d (v2i64, v4i32, v4i32);

v8i16 __builtin_msa_dpsub_u_h (v8i16, v16u8, v16u8);
v4i32 __builtin_msa_dpsub_u_w (v4i32, v8u16, v8u16);
v2i64 __builtin_msa_dpsub_u_d (v2i64, v4u32, v4u32);

v4f32 __builtin_msa_fadd_w (v4f32, v4f32);
v2f64 __builtin_msa_fadd_d (v2f64, v2f64);

v4i32 __builtin_msa_fcaf_w (v4f32, v4f32);
v2i64 __builtin_msa_fcaf_d (v2f64, v2f64);

v4i32 __builtin_msa_fceq_w (v4f32, v4f32);
v2i64 __builtin_msa_fceq_d (v2f64, v2f64);

v4i32 __builtin_msa_fclass_w (v4f32);
v2i64 __builtin_msa_fclass_d (v2f64);

v4i32 __builtin_msa_fcle_w (v4f32, v4f32);
v2i64 __builtin_msa_fcle_d (v2f64, v2f64);

v4i32 __builtin_msa_fclt_w (v4f32, v4f32);
v2i64 __builtin_msa_fclt_d (v2f64, v2f64);

v4i32 __builtin_msa_fcne_w (v4f32, v4f32);
v2i64 __builtin_msa_fcne_d (v2f64, v2f64);

v4i32 __builtin_msa_fcor_w (v4f32, v4f32);
v2i64 __builtin_msa_fcor_d (v2f64, v2f64);

v4i32 __builtin_msa_fcueq_w (v4f32, v4f32);
v2i64 __builtin_msa_fcueq_d (v2f64, v2f64);

v4i32 __builtin_msa_fcule_w (v4f32, v4f32);
v2i64 __builtin_msa_fcule_d (v2f64, v2f64);

v4i32 __builtin_msa_fcult_w (v4f32, v4f32);
v2i64 __builtin_msa_fcult_d (v2f64, v2f64);

v4i32 __builtin_msa_fcun_w (v4f32, v4f32);
v2i64 __builtin_msa_fcun_d (v2f64, v2f64);

v4i32 __builtin_msa_fcune_w (v4f32, v4f32);
v2i64 __builtin_msa_fcune_d (v2f64, v2f64);

v4f32 __builtin_msa_fdiv_w (v4f32, v4f32);
v2f64 __builtin_msa_fdiv_d (v2f64, v2f64);

v8i16 __builtin_msa_fexdo_h (v4f32, v4f32);
v4f32 __builtin_msa_fexdo_w (v2f64, v2f64);

v4f32 __builtin_msa_fexp2_w (v4f32, v4i32);
v2f64 __builtin_msa_fexp2_d (v2f64, v2i64);

v4f32 __builtin_msa_fexupl_w (v8i16);
v2f64 __builtin_msa_fexupl_d (v4f32);

v4f32 __builtin_msa_fexupr_w (v8i16);
v2f64 __builtin_msa_fexupr_d (v4f32);

v4f32 __builtin_msa_ffint_s_w (v4i32);
v2f64 __builtin_msa_ffint_s_d (v2i64);

v4f32 __builtin_msa_ffint_u_w (v4u32);
v2f64 __builtin_msa_ffint_u_d (v2u64);

v4f32 __builtin_msa_ffql_w (v8i16);
v2f64 __builtin_msa_ffql_d (v4i32);

v4f32 __builtin_msa_ffqr_w (v8i16);
v2f64 __builtin_msa_ffqr_d (v4i32);

v16i8 __builtin_msa_fill_b (i32);
v8i16 __builtin_msa_fill_h (i32);
v4i32 __builtin_msa_fill_w (i32);
v2i64 __builtin_msa_fill_d (i64);

v4f32 __builtin_msa_flog2_w (v4f32);
v2f64 __builtin_msa_flog2_d (v2f64);

v4f32 __builtin_msa_fmadd_w (v4f32, v4f32, v4f32);
v2f64 __builtin_msa_fmadd_d (v2f64, v2f64, v2f64);

v4f32 __builtin_msa_fmax_w (v4f32, v4f32);
v2f64 __builtin_msa_fmax_d (v2f64, v2f64);

v4f32 __builtin_msa_fmax_a_w (v4f32, v4f32);
v2f64 __builtin_msa_fmax_a_d (v2f64, v2f64);

v4f32 __builtin_msa_fmin_w (v4f32, v4f32);
v2f64 __builtin_msa_fmin_d (v2f64, v2f64);

v4f32 __builtin_msa_fmin_a_w (v4f32, v4f32);
v2f64 __builtin_msa_fmin_a_d (v2f64, v2f64);

v4f32 __builtin_msa_fmsub_w (v4f32, v4f32, v4f32);
v2f64 __builtin_msa_fmsub_d (v2f64, v2f64, v2f64);

v4f32 __builtin_msa_fmul_w (v4f32, v4f32);
v2f64 __builtin_msa_fmul_d (v2f64, v2f64);

v4f32 __builtin_msa_frint_w (v4f32);
v2f64 __builtin_msa_frint_d (v2f64);

v4f32 __builtin_msa_frcp_w (v4f32);
v2f64 __builtin_msa_frcp_d (v2f64);

v4f32 __builtin_msa_frsqrt_w (v4f32);
v2f64 __builtin_msa_frsqrt_d (v2f64);

v4i32 __builtin_msa_fsaf_w (v4f32, v4f32);
v2i64 __builtin_msa_fsaf_d (v2f64, v2f64);

v4i32 __builtin_msa_fseq_w (v4f32, v4f32);
v2i64 __builtin_msa_fseq_d (v2f64, v2f64);

v4i32 __builtin_msa_fsle_w (v4f32, v4f32);
v2i64 __builtin_msa_fsle_d (v2f64, v2f64);

v4i32 __builtin_msa_fslt_w (v4f32, v4f32);
v2i64 __builtin_msa_fslt_d (v2f64, v2f64);

v4i32 __builtin_msa_fsne_w (v4f32, v4f32);
v2i64 __builtin_msa_fsne_d (v2f64, v2f64);

v4i32 __builtin_msa_fsor_w (v4f32, v4f32);
v2i64 __builtin_msa_fsor_d (v2f64, v2f64);

v4f32 __builtin_msa_fsqrt_w (v4f32);
v2f64 __builtin_msa_fsqrt_d (v2f64);

v4f32 __builtin_msa_fsub_w (v4f32, v4f32);
v2f64 __builtin_msa_fsub_d (v2f64, v2f64);

v4i32 __builtin_msa_fsueq_w (v4f32, v4f32);
v2i64 __builtin_msa_fsueq_d (v2f64, v2f64);

v4i32 __builtin_msa_fsule_w (v4f32, v4f32);
v2i64 __builtin_msa_fsule_d (v2f64, v2f64);

v4i32 __builtin_msa_fsult_w (v4f32, v4f32);
v2i64 __builtin_msa_fsult_d (v2f64, v2f64);

v4i32 __builtin_msa_fsun_w (v4f32, v4f32);
v2i64 __builtin_msa_fsun_d (v2f64, v2f64);

v4i32 __builtin_msa_fsune_w (v4f32, v4f32);
v2i64 __builtin_msa_fsune_d (v2f64, v2f64);

v4i32 __builtin_msa_ftint_s_w (v4f32);
v2i64 __builtin_msa_ftint_s_d (v2f64);

v4u32 __builtin_msa_ftint_u_w (v4f32);
v2u64 __builtin_msa_ftint_u_d (v2f64);

v8i16 __builtin_msa_ftq_h (v4f32, v4f32);
v4i32 __builtin_msa_ftq_w (v2f64, v2f64);

v4i32 __builtin_msa_ftrunc_s_w (v4f32);
v2i64 __builtin_msa_ftrunc_s_d (v2f64);

v4u32 __builtin_msa_ftrunc_u_w (v4f32);
v2u64 __builtin_msa_ftrunc_u_d (v2f64);

v8i16 __builtin_msa_hadd_s_h (v16i8, v16i8);
v4i32 __builtin_msa_hadd_s_w (v8i16, v8i16);
v2i64 __builtin_msa_hadd_s_d (v4i32, v4i32);

v8u16 __builtin_msa_hadd_u_h (v16u8, v16u8);
v4u32 __builtin_msa_hadd_u_w (v8u16, v8u16);
v2u64 __builtin_msa_hadd_u_d (v4u32, v4u32);

v8i16 __builtin_msa_hsub_s_h (v16i8, v16i8);
v4i32 __builtin_msa_hsub_s_w (v8i16, v8i16);
v2i64 __builtin_msa_hsub_s_d (v4i32, v4i32);

v8i16 __builtin_msa_hsub_u_h (v16u8, v16u8);
v4i32 __builtin_msa_hsub_u_w (v8u16, v8u16);
v2i64 __builtin_msa_hsub_u_d (v4u32, v4u32);

v16i8 __builtin_msa_ilvev_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvev_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvev_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvev_d (v2i64, v2i64);

v16i8 __builtin_msa_ilvl_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvl_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvl_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvl_d (v2i64, v2i64);

v16i8 __builtin_msa_ilvod_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvod_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvod_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvod_d (v2i64, v2i64);

v16i8 __builtin_msa_ilvr_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvr_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvr_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvr_d (v2i64, v2i64);

v16i8 __builtin_msa_insert_b (v16i8, imm0_15, i32);
v8i16 __builtin_msa_insert_h (v8i16, imm0_7, i32);
v4i32 __builtin_msa_insert_w (v4i32, imm0_3, i32);
v2i64 __builtin_msa_insert_d (v2i64, imm0_1, i64);

v16i8 __builtin_msa_insve_b (v16i8, imm0_15, v16i8);
v8i16 __builtin_msa_insve_h (v8i16, imm0_7, v8i16);
v4i32 __builtin_msa_insve_w (v4i32, imm0_3, v4i32);
v2i64 __builtin_msa_insve_d (v2i64, imm0_1, v2i64);

v16i8 __builtin_msa_ld_b (void *, imm_n512_511);
v8i16 __builtin_msa_ld_h (void *, imm_n1024_1022);
v4i32 __builtin_msa_ld_w (void *, imm_n2048_2044);
v2i64 __builtin_msa_ld_d (void *, imm_n4096_4088);

v16i8 __builtin_msa_ldi_b (imm_n512_511);
v8i16 __builtin_msa_ldi_h (imm_n512_511);
v4i32 __builtin_msa_ldi_w (imm_n512_511);
v2i64 __builtin_msa_ldi_d (imm_n512_511);

v8i16 __builtin_msa_madd_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_madd_q_w (v4i32, v4i32, v4i32);

v8i16 __builtin_msa_maddr_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_maddr_q_w (v4i32, v4i32, v4i32);

v16i8 __builtin_msa_maddv_b (v16i8, v16i8, v16i8);
v8i16 __builtin_msa_maddv_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_maddv_w (v4i32, v4i32, v4i32);
v2i64 __builtin_msa_maddv_d (v2i64, v2i64, v2i64);

v16i8 __builtin_msa_max_a_b (v16i8, v16i8);
v8i16 __builtin_msa_max_a_h (v8i16, v8i16);
v4i32 __builtin_msa_max_a_w (v4i32, v4i32);
v2i64 __builtin_msa_max_a_d (v2i64, v2i64);

v16i8 __builtin_msa_max_s_b (v16i8, v16i8);
v8i16 __builtin_msa_max_s_h (v8i16, v8i16);
v4i32 __builtin_msa_max_s_w (v4i32, v4i32);
v2i64 __builtin_msa_max_s_d (v2i64, v2i64);

v16u8 __builtin_msa_max_u_b (v16u8, v16u8);
v8u16 __builtin_msa_max_u_h (v8u16, v8u16);
v4u32 __builtin_msa_max_u_w (v4u32, v4u32);
v2u64 __builtin_msa_max_u_d (v2u64, v2u64);

v16i8 __builtin_msa_maxi_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_maxi_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_maxi_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_maxi_s_d (v2i64, imm_n16_15);

v16u8 __builtin_msa_maxi_u_b (v16u8, imm0_31);
v8u16 __builtin_msa_maxi_u_h (v8u16, imm0_31);
v4u32 __builtin_msa_maxi_u_w (v4u32, imm0_31);
v2u64 __builtin_msa_maxi_u_d (v2u64, imm0_31);

v16i8 __builtin_msa_min_a_b (v16i8, v16i8);
v8i16 __builtin_msa_min_a_h (v8i16, v8i16);
v4i32 __builtin_msa_min_a_w (v4i32, v4i32);
v2i64 __builtin_msa_min_a_d (v2i64, v2i64);

v16i8 __builtin_msa_min_s_b (v16i8, v16i8);
v8i16 __builtin_msa_min_s_h (v8i16, v8i16);
v4i32 __builtin_msa_min_s_w (v4i32, v4i32);
v2i64 __builtin_msa_min_s_d (v2i64, v2i64);

v16u8 __builtin_msa_min_u_b (v16u8, v16u8);
v8u16 __builtin_msa_min_u_h (v8u16, v8u16);
v4u32 __builtin_msa_min_u_w (v4u32, v4u32);
v2u64 __builtin_msa_min_u_d (v2u64, v2u64);

v16i8 __builtin_msa_mini_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_mini_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_mini_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_mini_s_d (v2i64, imm_n16_15);

v16u8 __builtin_msa_mini_u_b (v16u8, imm0_31);
v8u16 __builtin_msa_mini_u_h (v8u16, imm0_31);
v4u32 __builtin_msa_mini_u_w (v4u32, imm0_31);
v2u64 __builtin_msa_mini_u_d (v2u64, imm0_31);

v16i8 __builtin_msa_mod_s_b (v16i8, v16i8);
v8i16 __builtin_msa_mod_s_h (v8i16, v8i16);
v4i32 __builtin_msa_mod_s_w (v4i32, v4i32);
v2i64 __builtin_msa_mod_s_d (v2i64, v2i64);

v16u8 __builtin_msa_mod_u_b (v16u8, v16u8);
v8u16 __builtin_msa_mod_u_h (v8u16, v8u16);
v4u32 __builtin_msa_mod_u_w (v4u32, v4u32);
v2u64 __builtin_msa_mod_u_d (v2u64, v2u64);

v16i8 __builtin_msa_move_v (v16i8);

v8i16 __builtin_msa_msub_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_msub_q_w (v4i32, v4i32, v4i32);

v8i16 __builtin_msa_msubr_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_msubr_q_w (v4i32, v4i32, v4i32);

v16i8 __builtin_msa_msubv_b (v16i8, v16i8, v16i8);
v8i16 __builtin_msa_msubv_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_msubv_w (v4i32, v4i32, v4i32);
v2i64 __builtin_msa_msubv_d (v2i64, v2i64, v2i64);

v8i16 __builtin_msa_mul_q_h (v8i16, v8i16);
v4i32 __builtin_msa_mul_q_w (v4i32, v4i32);

v8i16 __builtin_msa_mulr_q_h (v8i16, v8i16);
v4i32 __builtin_msa_mulr_q_w (v4i32, v4i32);

v16i8 __builtin_msa_mulv_b (v16i8, v16i8);
v8i16 __builtin_msa_mulv_h (v8i16, v8i16);
v4i32 __builtin_msa_mulv_w (v4i32, v4i32);
v2i64 __builtin_msa_mulv_d (v2i64, v2i64);

v16i8 __builtin_msa_nloc_b (v16i8);
v8i16 __builtin_msa_nloc_h (v8i16);
v4i32 __builtin_msa_nloc_w (v4i32);
v2i64 __builtin_msa_nloc_d (v2i64);

v16i8 __builtin_msa_nlzc_b (v16i8);
v8i16 __builtin_msa_nlzc_h (v8i16);
v4i32 __builtin_msa_nlzc_w (v4i32);
v2i64 __builtin_msa_nlzc_d (v2i64);

v16u8 __builtin_msa_nor_v (v16u8, v16u8);

v16u8 __builtin_msa_nori_b (v16u8, imm0_255);

v16u8 __builtin_msa_or_v (v16u8, v16u8);

v16u8 __builtin_msa_ori_b (v16u8, imm0_255);

v16i8 __builtin_msa_pckev_b (v16i8, v16i8);
v8i16 __builtin_msa_pckev_h (v8i16, v8i16);
v4i32 __builtin_msa_pckev_w (v4i32, v4i32);
v2i64 __builtin_msa_pckev_d (v2i64, v2i64);

v16i8 __builtin_msa_pckod_b (v16i8, v16i8);
v8i16 __builtin_msa_pckod_h (v8i16, v8i16);
v4i32 __builtin_msa_pckod_w (v4i32, v4i32);
v2i64 __builtin_msa_pckod_d (v2i64, v2i64);

v16i8 __builtin_msa_pcnt_b (v16i8);
v8i16 __builtin_msa_pcnt_h (v8i16);
v4i32 __builtin_msa_pcnt_w (v4i32);
v2i64 __builtin_msa_pcnt_d (v2i64);

v16i8 __builtin_msa_sat_s_b (v16i8, imm0_7);
v8i16 __builtin_msa_sat_s_h (v8i16, imm0_15);
v4i32 __builtin_msa_sat_s_w (v4i32, imm0_31);
v2i64 __builtin_msa_sat_s_d (v2i64, imm0_63);

v16u8 __builtin_msa_sat_u_b (v16u8, imm0_7);
v8u16 __builtin_msa_sat_u_h (v8u16, imm0_15);
v4u32 __builtin_msa_sat_u_w (v4u32, imm0_31);
v2u64 __builtin_msa_sat_u_d (v2u64, imm0_63);

v16i8 __builtin_msa_shf_b (v16i8, imm0_255);
v8i16 __builtin_msa_shf_h (v8i16, imm0_255);
v4i32 __builtin_msa_shf_w (v4i32, imm0_255);

v16i8 __builtin_msa_sld_b (v16i8, v16i8, i32);
v8i16 __builtin_msa_sld_h (v8i16, v8i16, i32);
v4i32 __builtin_msa_sld_w (v4i32, v4i32, i32);
v2i64 __builtin_msa_sld_d (v2i64, v2i64, i32);

v16i8 __builtin_msa_sldi_b (v16i8, v16i8, imm0_15);
v8i16 __builtin_msa_sldi_h (v8i16, v8i16, imm0_7);
v4i32 __builtin_msa_sldi_w (v4i32, v4i32, imm0_3);
v2i64 __builtin_msa_sldi_d (v2i64, v2i64, imm0_1);

v16i8 __builtin_msa_sll_b (v16i8, v16i8);
v8i16 __builtin_msa_sll_h (v8i16, v8i16);
v4i32 __builtin_msa_sll_w (v4i32, v4i32);
v2i64 __builtin_msa_sll_d (v2i64, v2i64);

v16i8 __builtin_msa_slli_b (v16i8, imm0_7);
v8i16 __builtin_msa_slli_h (v8i16, imm0_15);
v4i32 __builtin_msa_slli_w (v4i32, imm0_31);
v2i64 __builtin_msa_slli_d (v2i64, imm0_63);

v16i8 __builtin_msa_splat_b (v16i8, i32);
v8i16 __builtin_msa_splat_h (v8i16, i32);
v4i32 __builtin_msa_splat_w (v4i32, i32);
v2i64 __builtin_msa_splat_d (v2i64, i32);

v16i8 __builtin_msa_splati_b (v16i8, imm0_15);
v8i16 __builtin_msa_splati_h (v8i16, imm0_7);
v4i32 __builtin_msa_splati_w (v4i32, imm0_3);
v2i64 __builtin_msa_splati_d (v2i64, imm0_1);

v16i8 __builtin_msa_sra_b (v16i8, v16i8);
v8i16 __builtin_msa_sra_h (v8i16, v8i16);
v4i32 __builtin_msa_sra_w (v4i32, v4i32);
v2i64 __builtin_msa_sra_d (v2i64, v2i64);

v16i8 __builtin_msa_srai_b (v16i8, imm0_7);
v8i16 __builtin_msa_srai_h (v8i16, imm0_15);
v4i32 __builtin_msa_srai_w (v4i32, imm0_31);
v2i64 __builtin_msa_srai_d (v2i64, imm0_63);

v16i8 __builtin_msa_srar_b (v16i8, v16i8);
v8i16 __builtin_msa_srar_h (v8i16, v8i16);
v4i32 __builtin_msa_srar_w (v4i32, v4i32);
v2i64 __builtin_msa_srar_d (v2i64, v2i64);

v16i8 __builtin_msa_srari_b (v16i8, imm0_7);
v8i16 __builtin_msa_srari_h (v8i16, imm0_15);
v4i32 __builtin_msa_srari_w (v4i32, imm0_31);
v2i64 __builtin_msa_srari_d (v2i64, imm0_63);

v16i8 __builtin_msa_srl_b (v16i8, v16i8);
v8i16 __builtin_msa_srl_h (v8i16, v8i16);
v4i32 __builtin_msa_srl_w (v4i32, v4i32);
v2i64 __builtin_msa_srl_d (v2i64, v2i64);

v16i8 __builtin_msa_srli_b (v16i8, imm0_7);
v8i16 __builtin_msa_srli_h (v8i16, imm0_15);
v4i32 __builtin_msa_srli_w (v4i32, imm0_31);
v2i64 __builtin_msa_srli_d (v2i64, imm0_63);

v16i8 __builtin_msa_srlr_b (v16i8, v16i8);
v8i16 __builtin_msa_srlr_h (v8i16, v8i16);
v4i32 __builtin_msa_srlr_w (v4i32, v4i32);
v2i64 __builtin_msa_srlr_d (v2i64, v2i64);

v16i8 __builtin_msa_srlri_b (v16i8, imm0_7);
v8i16 __builtin_msa_srlri_h (v8i16, imm0_15);
v4i32 __builtin_msa_srlri_w (v4i32, imm0_31);
v2i64 __builtin_msa_srlri_d (v2i64, imm0_63);

void __builtin_msa_st_b (v16i8, void *, imm_n512_511);
void __builtin_msa_st_h (v8i16, void *, imm_n1024_1022);
void __builtin_msa_st_w (v4i32, void *, imm_n2048_2044);
void __builtin_msa_st_d (v2i64, void *, imm_n4096_4088);

v16i8 __builtin_msa_subs_s_b (v16i8, v16i8);
v8i16 __builtin_msa_subs_s_h (v8i16, v8i16);
v4i32 __builtin_msa_subs_s_w (v4i32, v4i32);
v2i64 __builtin_msa_subs_s_d (v2i64, v2i64);

v16u8 __builtin_msa_subs_u_b (v16u8, v16u8);
v8u16 __builtin_msa_subs_u_h (v8u16, v8u16);
v4u32 __builtin_msa_subs_u_w (v4u32, v4u32);
v2u64 __builtin_msa_subs_u_d (v2u64, v2u64);

v16u8 __builtin_msa_subsus_u_b (v16u8, v16i8);
v8u16 __builtin_msa_subsus_u_h (v8u16, v8i16);
v4u32 __builtin_msa_subsus_u_w (v4u32, v4i32);
v2u64 __builtin_msa_subsus_u_d (v2u64, v2i64);

v16i8 __builtin_msa_subsuu_s_b (v16u8, v16u8);
v8i16 __builtin_msa_subsuu_s_h (v8u16, v8u16);
v4i32 __builtin_msa_subsuu_s_w (v4u32, v4u32);
v2i64 __builtin_msa_subsuu_s_d (v2u64, v2u64);

v16i8 __builtin_msa_subv_b (v16i8, v16i8);
v8i16 __builtin_msa_subv_h (v8i16, v8i16);
v4i32 __builtin_msa_subv_w (v4i32, v4i32);
v2i64 __builtin_msa_subv_d (v2i64, v2i64);

v16i8 __builtin_msa_subvi_b (v16i8, imm0_31);
v8i16 __builtin_msa_subvi_h (v8i16, imm0_31);
v4i32 __builtin_msa_subvi_w (v4i32, imm0_31);
v2i64 __builtin_msa_subvi_d (v2i64, imm0_31);

v16i8 __builtin_msa_vshf_b (v16i8, v16i8, v16i8);
v8i16 __builtin_msa_vshf_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_vshf_w (v4i32, v4i32, v4i32);
v2i64 __builtin_msa_vshf_d (v2i64, v2i64, v2i64);

v16u8 __builtin_msa_xor_v (v16u8, v16u8);

v16u8 __builtin_msa_xori_b (v16u8, imm0_255);
@end smallexample

@node Other MIPS Built-in Functions
@subsection Other MIPS Built-in Functions

GCC provides other MIPS-specific built-in functions:

@table @code
@item void __builtin_mips_cache (int @var{op}, const volatile void *@var{addr})
Insert a @samp{cache} instruction with operands @var{op} and @var{addr}.
GCC defines the preprocessor macro @code{___GCC_HAVE_BUILTIN_MIPS_CACHE}
when this function is available.

@item unsigned int __builtin_mips_get_fcsr (void)
@itemx void __builtin_mips_set_fcsr (unsigned int @var{value})
Get and set the contents of the floating-point control and status register
(FPU control register 31).  These functions are only available in hard-float
code but can be called in both MIPS16 and non-MIPS16 contexts.

@code{__builtin_mips_set_fcsr} can be used to change any bit of the
register except the condition codes, which GCC assumes are preserved.
@end table

@node MSP430 Built-in Functions
@subsection MSP430 Built-in Functions

GCC provides a couple of special builtin functions to aid in the
writing of interrupt handlers in C.

@table @code
@item __bic_SR_register_on_exit (int @var{mask})
This clears the indicated bits in the saved copy of the status register
currently residing on the stack.  This only works inside interrupt
handlers and the changes to the status register will only take affect
once the handler returns.

@item __bis_SR_register_on_exit (int @var{mask})
This sets the indicated bits in the saved copy of the status register
currently residing on the stack.  This only works inside interrupt
handlers and the changes to the status register will only take affect
once the handler returns.

@item __delay_cycles (long long @var{cycles})
This inserts an instruction sequence that takes exactly @var{cycles}
cycles (between 0 and about 17E9) to complete.  The inserted sequence
may use jumps, loops, or no-ops, and does not interfere with any other
instructions.  Note that @var{cycles} must be a compile-time constant
integer - that is, you must pass a number, not a variable that may be
optimized to a constant later.  The number of cycles delayed by this
builtin is exact.
@end table

@node NDS32 Built-in Functions
@subsection NDS32 Built-in Functions

These built-in functions are available for the NDS32 target:

@deftypefn {Built-in Function} void __builtin_nds32_isync (int *@var{addr})
Insert an ISYNC instruction into the instruction stream where
@var{addr} is an instruction address for serialization.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_isb (void)
Insert an ISB instruction into the instruction stream.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_nds32_mfsr (int @var{sr})
Return the content of a system register which is mapped by @var{sr}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_nds32_mfusr (int @var{usr})
Return the content of a user space register which is mapped by @var{usr}.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_mtsr (int @var{value}, int @var{sr})
Move the @var{value} to a system register which is mapped by @var{sr}.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_mtusr (int @var{value}, int @var{usr})
Move the @var{value} to a user space register which is mapped by @var{usr}.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_setgie_en (void)
Enable global interrupt.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_setgie_dis (void)
Disable global interrupt.
@end deftypefn

@node picoChip Built-in Functions
@subsection picoChip Built-in Functions

GCC provides an interface to selected machine instructions from the
picoChip instruction set.

@table @code
@item int __builtin_sbc (int @var{value})
Sign bit count.  Return the number of consecutive bits in @var{value}
that have the same value as the sign bit.  The result is the number of
leading sign bits minus one, giving the number of redundant sign bits in
@var{value}.

@item int __builtin_byteswap (int @var{value})
Byte swap.  Return the result of swapping the upper and lower bytes of
@var{value}.

@item int __builtin_brev (int @var{value})
Bit reversal.  Return the result of reversing the bits in
@var{value}.  Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1,
and so on.

@item int __builtin_adds (int @var{x}, int @var{y})
Saturating addition.  Return the result of adding @var{x} and @var{y},
storing the value 32767 if the result overflows.

@item int __builtin_subs (int @var{x}, int @var{y})
Saturating subtraction.  Return the result of subtracting @var{y} from
@var{x}, storing the value @minus{}32768 if the result overflows.

@item void __builtin_halt (void)
Halt.  The processor stops execution.  This built-in is useful for
implementing assertions.

@end table

@node PowerPC Built-in Functions
@subsection PowerPC Built-in Functions

The following built-in functions are always available and can be used to
check the PowerPC target platform type:

@deftypefn {Built-in Function} void __builtin_cpu_init (void)
This function is a @code{nop} on the PowerPC platform and is included solely
to maintain API compatibility with the x86 builtins.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_cpu_init (void)
This function is a @code{nop} on the PowerPC platform and is included solely
to maintain API compatibility with the x86 builtins.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_is (const char *@var{cpuname})
This function returns a value of @code{1} if the run-time CPU is of type
@var{cpuname} and returns @code{0} otherwise

The @code{__builtin_cpu_is} function requires GLIBC 2.23 or newer
which exports the hardware capability bits.  GCC defines the macro
@code{__BUILTIN_CPU_SUPPORTS__} if the @code{__builtin_cpu_supports}
built-in function is fully supported.

If GCC was configured to use a GLIBC before 2.23, the built-in
function @code{__builtin_cpu_is} always returns a 0 and the compiler
issues a warning.

The following CPU names can be detected:

@table @samp
@item power9
IBM POWER9 Server CPU.
@item power8
IBM POWER8 Server CPU.
@item power7
IBM POWER7 Server CPU.
@item power6x
IBM POWER6 Server CPU (RAW mode).
@item power6
IBM POWER6 Server CPU (Architected mode).
@item power5+
IBM POWER5+ Server CPU.
@item power5
IBM POWER5 Server CPU.
@item ppc970
IBM 970 Server CPU (ie, Apple G5).
@item power4
IBM POWER4 Server CPU.
@item ppca2
IBM A2 64-bit Embedded CPU
@item ppc476
IBM PowerPC 476FP 32-bit Embedded CPU.
@item ppc464
IBM PowerPC 464 32-bit Embedded CPU.
@item ppc440
PowerPC 440 32-bit Embedded CPU.
@item ppc405
PowerPC 405 32-bit Embedded CPU.
@item ppc-cell-be
IBM PowerPC Cell Broadband Engine Architecture CPU.
@end table

Here is an example:
@smallexample
#ifdef __BUILTIN_CPU_SUPPORTS__
  if (__builtin_cpu_is ("power8"))
    @{
       do_power8 (); // POWER8 specific implementation.
    @}
  else
#endif
    @{
       do_generic (); // Generic implementation.
    @}
@end smallexample
@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_supports (const char *@var{feature})
This function returns a value of @code{1} if the run-time CPU supports the HWCAP
feature @var{feature} and returns @code{0} otherwise.

The @code{__builtin_cpu_supports} function requires GLIBC 2.23 or
newer which exports the hardware capability bits.  GCC defines the
macro @code{__BUILTIN_CPU_SUPPORTS__} if the
@code{__builtin_cpu_supports} built-in function is fully supported.

If GCC was configured to use a GLIBC before 2.23, the built-in
function @code{__builtin_cpu_suports} always returns a 0 and the
compiler issues a warning.

The following features can be
detected:

@table @samp
@item 4xxmac
4xx CPU has a Multiply Accumulator.
@item altivec
CPU has a SIMD/Vector Unit.
@item arch_2_05
CPU supports ISA 2.05 (eg, POWER6)
@item arch_2_06
CPU supports ISA 2.06 (eg, POWER7)
@item arch_2_07
CPU supports ISA 2.07 (eg, POWER8)
@item arch_3_00
CPU supports ISA 3.0 (eg, POWER9)
@item archpmu
CPU supports the set of compatible performance monitoring events.
@item booke
CPU supports the Embedded ISA category.
@item cellbe
CPU has a CELL broadband engine.
@item dfp
CPU has a decimal floating point unit.
@item dscr
CPU supports the data stream control register.
@item ebb
CPU supports event base branching.
@item efpdouble
CPU has a SPE double precision floating point unit.
@item efpsingle
CPU has a SPE single precision floating point unit.
@item fpu
CPU has a floating point unit.
@item htm
CPU has hardware transaction memory instructions.
@item htm-nosc
Kernel aborts hardware transactions when a syscall is made.
@item ic_snoop
CPU supports icache snooping capabilities.
@item ieee128
CPU supports 128-bit IEEE binary floating point instructions.
@item isel
CPU supports the integer select instruction.
@item mmu
CPU has a memory management unit.
@item notb
CPU does not have a timebase (eg, 601 and 403gx).
@item pa6t
CPU supports the PA Semi 6T CORE ISA.
@item power4
CPU supports ISA 2.00 (eg, POWER4)
@item power5
CPU supports ISA 2.02 (eg, POWER5)
@item power5+
CPU supports ISA 2.03 (eg, POWER5+)
@item power6x
CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.
@item ppc32
CPU supports 32-bit mode execution.
@item ppc601
CPU supports the old POWER ISA (eg, 601)
@item ppc64
CPU supports 64-bit mode execution.
@item ppcle
CPU supports a little-endian mode that uses address swizzling.
@item smt
CPU support simultaneous multi-threading.
@item spe
CPU has a signal processing extension unit.
@item tar
CPU supports the target address register.
@item true_le
CPU supports true little-endian mode.
@item ucache
CPU has unified I/D cache.
@item vcrypto
CPU supports the vector cryptography instructions.
@item vsx
CPU supports the vector-scalar extension.
@end table

Here is an example:
@smallexample
#ifdef __BUILTIN_CPU_SUPPORTS__
  if (__builtin_cpu_supports ("fpu"))
    @{
       asm("fadd %0,%1,%2" : "=d"(dst) : "d"(src1), "d"(src2));
    @}
  else
#endif
    @{
       dst = __fadd (src1, src2); // Software FP addition function.
    @}
@end smallexample
@end deftypefn

These built-in functions are available for the PowerPC family of
processors:
@smallexample
float __builtin_recipdivf (float, float);
float __builtin_rsqrtf (float);
double __builtin_recipdiv (double, double);
double __builtin_rsqrt (double);
uint64_t __builtin_ppc_get_timebase ();
unsigned long __builtin_ppc_mftb ();
double __builtin_unpack_longdouble (long double, int);
long double __builtin_pack_longdouble (double, double);
@end smallexample

The @code{vec_rsqrt}, @code{__builtin_rsqrt}, and
@code{__builtin_rsqrtf} functions generate multiple instructions to
implement the reciprocal sqrt functionality using reciprocal sqrt
estimate instructions.

The @code{__builtin_recipdiv}, and @code{__builtin_recipdivf}
functions generate multiple instructions to implement division using
the reciprocal estimate instructions.

The @code{__builtin_ppc_get_timebase} and @code{__builtin_ppc_mftb}
functions generate instructions to read the Time Base Register.  The
@code{__builtin_ppc_get_timebase} function may generate multiple
instructions and always returns the 64 bits of the Time Base Register.
The @code{__builtin_ppc_mftb} function always generates one instruction and
returns the Time Base Register value as an unsigned long, throwing away
the most significant word on 32-bit environments.

Additional built-in functions are available for the 64-bit PowerPC
family of processors, for efficient use of 128-bit floating point
(@code{__float128}) values.

The following floating-point built-in functions are available with
@code{-mfloat128} and Altivec support.  All of them implement the
function that is part of the name.

@smallexample
__float128 __builtin_fabsq (__float128)
__float128 __builtin_copysignq (__float128, __float128)
@end smallexample

The following built-in functions are available with @code{-mfloat128}
and Altivec support.

@table @code
@item __float128 __builtin_infq (void)
Similar to @code{__builtin_inf}, except the return type is @code{__float128}.
@findex __builtin_infq

@item __float128 __builtin_huge_valq (void)
Similar to @code{__builtin_huge_val}, except the return type is @code{__float128}.
@findex __builtin_huge_valq

@item __float128 __builtin_nanq (void)
Similar to @code{__builtin_nan}, except the return type is @code{__float128}.
@findex __builtin_nanq

@item __float128 __builtin_nansq (void)
Similar to @code{__builtin_nans}, except the return type is @code{__float128}.
@findex __builtin_nansq
@end table

The following built-in functions are available for the PowerPC family
of processors, starting with ISA 2.06 or later (@option{-mcpu=power7}
or @option{-mpopcntd}):
@smallexample
long __builtin_bpermd (long, long);
int __builtin_divwe (int, int);
int __builtin_divweo (int, int);
unsigned int __builtin_divweu (unsigned int, unsigned int);
unsigned int __builtin_divweuo (unsigned int, unsigned int);
long __builtin_divde (long, long);
long __builtin_divdeo (long, long);
unsigned long __builtin_divdeu (unsigned long, unsigned long);
unsigned long __builtin_divdeuo (unsigned long, unsigned long);
unsigned int cdtbcd (unsigned int);
unsigned int cbcdtd (unsigned int);
unsigned int addg6s (unsigned int, unsigned int);
@end smallexample

The @code{__builtin_divde}, @code{__builtin_divdeo},
@code{__builtin_divdeu}, @code{__builtin_divdeou} functions require a
64-bit environment support ISA 2.06 or later.

The following built-in functions are available for the PowerPC family
of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@smallexample
long long __builtin_darn (void);
long long __builtin_darn_raw (void);
int __builtin_darn_32 (void);

unsigned int scalar_extract_exp (double source);
unsigned long long int scalar_extract_sig (double source);

double
scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);
double
scalar_insert_exp (double significand, unsigned long long int exponent);

int scalar_cmp_exp_gt (double arg1, double arg2);
int scalar_cmp_exp_lt (double arg1, double arg2);
int scalar_cmp_exp_eq (double arg1, double arg2);
int scalar_cmp_exp_unordered (double arg1, double arg2);

bool scalar_test_data_class (float source, const int condition);
bool scalar_test_data_class (double source, const int condition);

bool scalar_test_neg (float source);
bool scalar_test_neg (double source);

int __builtin_byte_in_set (unsigned char u, unsigned long long set);
int __builtin_byte_in_range (unsigned char u, unsigned int range);
int __builtin_byte_in_either_range (unsigned char u, unsigned int ranges);

int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_lt_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_lt_td (unsigned int comparison, _Decimal128 value);

int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_gt_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_gt_td (unsigned int comparison, _Decimal128 value);

int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_eq_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_eq_td (unsigned int comparison, _Decimal128 value);

int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);
@end smallexample

The @code{__builtin_darn} and @code{__builtin_darn_raw}
functions require a
64-bit environment supporting ISA 3.0 or later.
The @code{__builtin_darn} function provides a 64-bit conditioned
random number.  The @code{__builtin_darn_raw} function provides a
64-bit raw random number.  The @code{__builtin_darn_32} function
provides a 32-bit random number.

The @code{scalar_extract_exp} and @code{scalar_extract_sig}
functions require a 64-bit environment supporting ISA 3.0 or later.
The @code{scalar_extract_exp} and @code{scalar_extract_sig} built-in
functions return the significand and the biased exponent value
respectively of their @code{source} arguments.
Within the result returned by @code{scalar_extract_sig},
the @code{0x10000000000000} bit is set if the
function's @code{source} argument is in normalized form.
Otherwise, this bit is set to 0.
Note that the sign of the significand is not represented in the result
returned from the @code{scalar_extract_sig} function.  Use the
@code{scalar_test_neg} function to test the sign of its @code{double}
argument.

The @code{scalar_insert_exp} 
function requires a 64-bit environment supporting ISA 3.0 or later.
The @code{scalar_insert_exp} built-in function returns a double-precision
floating point value that is constructed by assembling the values of its
@code{significand} and @code{exponent} arguments.  The sign of the
result is copied from the most significant bit of the
@code{significand} argument.  The significand and exponent components
of the result are composed of the least significant 11 bits of the
@code{exponent} argument and the least significant 52 bits of the
@code{significand} argument.

The @code{scalar_cmp_exp_gt}, @code{scalar_cmp_exp_lt},
@code{scalar_cmp_exp_eq}, and @code{scalar_cmp_exp_unordered} built-in
functions return a non-zero value if @code{arg1} is greater than, less
than, equal to, or not comparable to @code{arg2} respectively.  The
arguments are not comparable if one or the other equals NaN (not a
number). 

The @code{scalar_test_data_class} built-in function returns 1
if any of the condition tests enabled by the value of the
@code{condition} variable are true, and 0 otherwise.  The
@code{condition} argument must be a compile-time constant integer with
value not exceeding 127.  The
@code{condition} argument is encoded as a bitmask with each bit
enabling the testing of a different condition, as characterized by the
following:
@smallexample
0x40    Test for NaN
0x20    Test for +Infinity
0x10    Test for -Infinity
0x08    Test for +Zero
0x04    Test for -Zero
0x02    Test for +Denormal
0x01    Test for -Denormal
@end smallexample

The @code{scalar_test_neg} built-in function returns 1 if its
@code{source} argument holds a negative value, 0 otherwise.

The @code{__builtin_byte_in_set} function requires a
64-bit environment supporting ISA 3.0 or later.  This function returns
a non-zero value if and only if its @code{u} argument exactly equals one of
the eight bytes contained within its 64-bit @code{set} argument.

The @code{__builtin_byte_in_range} and
@code{__builtin_byte_in_either_range} require an environment
supporting ISA 3.0 or later.  For these two functions, the
@code{range} argument is encoded as 4 bytes, organized as
@code{hi_1:lo_1:hi_2:lo_2}.
The @code{__builtin_byte_in_range} function returns a
non-zero value if and only if its @code{u} argument is within the
range bounded between @code{lo_2} and @code{hi_2} inclusive.
The @code{__builtin_byte_in_either_range} function returns non-zero if
and only if its @code{u} argument is within either the range bounded
between @code{lo_1} and @code{hi_1} inclusive or the range bounded
between @code{lo_2} and @code{hi_2} inclusive.

The @code{__builtin_dfp_dtstsfi_lt} function returns a non-zero value
if and only if the number of signficant digits of its @code{value} argument
is less than its @code{comparison} argument.  The
@code{__builtin_dfp_dtstsfi_lt_dd} and
@code{__builtin_dfp_dtstsfi_lt_td} functions behave similarly, but
require that the type of the @code{value} argument be
@code{__Decimal64} and @code{__Decimal128} respectively.

The @code{__builtin_dfp_dtstsfi_gt} function returns a non-zero value
if and only if the number of signficant digits of its @code{value} argument
is greater than its @code{comparison} argument.  The
@code{__builtin_dfp_dtstsfi_gt_dd} and
@code{__builtin_dfp_dtstsfi_gt_td} functions behave similarly, but
require that the type of the @code{value} argument be
@code{__Decimal64} and @code{__Decimal128} respectively.

The @code{__builtin_dfp_dtstsfi_eq} function returns a non-zero value
if and only if the number of signficant digits of its @code{value} argument
equals its @code{comparison} argument.  The
@code{__builtin_dfp_dtstsfi_eq_dd} and
@code{__builtin_dfp_dtstsfi_eq_td} functions behave similarly, but
require that the type of the @code{value} argument be
@code{__Decimal64} and @code{__Decimal128} respectively.

The @code{__builtin_dfp_dtstsfi_ov} function returns a non-zero value
if and only if its @code{value} argument has an undefined number of
significant digits, such as when @code{value} is an encoding of @code{NaN}.
The @code{__builtin_dfp_dtstsfi_ov_dd} and
@code{__builtin_dfp_dtstsfi_ov_td} functions behave similarly, but
require that the type of the @code{value} argument be
@code{__Decimal64} and @code{__Decimal128} respectively.

The following built-in functions are also available for the PowerPC family
of processors, starting with ISA 3.0 or later
(@option{-mcpu=power9}).  These string functions are described
separately in order to group the descriptions closer to the function
prototypes:
@smallexample
int vec_all_nez (vector signed char, vector signed char);
int vec_all_nez (vector unsigned char, vector unsigned char);
int vec_all_nez (vector signed short, vector signed short);
int vec_all_nez (vector unsigned short, vector unsigned short);
int vec_all_nez (vector signed int, vector signed int);
int vec_all_nez (vector unsigned int, vector unsigned int);

int vec_any_eqz (vector signed char, vector signed char);
int vec_any_eqz (vector unsigned char, vector unsigned char);
int vec_any_eqz (vector signed short, vector signed short);
int vec_any_eqz (vector unsigned short, vector unsigned short);
int vec_any_eqz (vector signed int, vector signed int);
int vec_any_eqz (vector unsigned int, vector unsigned int);

vector bool char vec_cmpnez (vector signed char arg1, vector signed char arg2);
vector bool char vec_cmpnez (vector unsigned char arg1, vector unsigned char arg2);
vector bool short vec_cmpnez (vector signed short arg1, vector signed short arg2);
vector bool short vec_cmpnez (vector unsigned short arg1, vector unsigned short arg2);
vector bool int vec_cmpnez (vector signed int arg1, vector signed int arg2);
vector bool int vec_cmpnez (vector unsigned int, vector unsigned int);

signed int vec_cntlz_lsbb (vector signed char);
signed int vec_cntlz_lsbb (vector unsigned char);

signed int vec_cnttz_lsbb (vector signed char);
signed int vec_cnttz_lsbb (vector unsigned char);

vector signed char vec_xl_len (signed char *addr, size_t len);
vector unsigned char vec_xl_len (unsigned char *addr, size_t len);
vector signed int vec_xl_len (signed int *addr, size_t len);
vector unsigned int vec_xl_len (unsigned int *addr, size_t len);
vector signed __int128 vec_xl_len (signed __int128 *addr, size_t len);
vector unsigned __int128 vec_xl_len (unsigned __int128 *addr, size_t len);
vector signed long long vec_xl_len (signed long long *addr, size_t len);
vector unsigned long long vec_xl_len (unsigned long long *addr, size_t len);
vector signed short vec_xl_len (signed short *addr, size_t len);
vector unsigned short vec_xl_len (unsigned short *addr, size_t len);
vector double vec_xl_len (double *addr, size_t len);
vector float vec_xl_len (float *addr, size_t len);

void vec_xst_len (vector signed char data, signed char *addr, size_t len);
void vec_xst_len (vector unsigned char data, unsigned char *addr, size_t len);
void vec_xst_len (vector signed int data, signed int *addr, size_t len);
void vec_xst_len (vector unsigned int data, unsigned int *addr, size_t len);
void vec_xst_len (vector unsigned __int128 data, unsigned __int128 *addr, size_t len);
void vec_xst_len (vector signed long long data, signed long long *addr, size_t len);
void vec_xst_len (vector unsigned long long data, unsigned long long *addr, size_t len);
void vec_xst_len (vector signed short data, signed short *addr, size_t len);
void vec_xst_len (vector unsigned short data, unsigned short *addr, size_t len);
void vec_xst_len (vector signed __int128 data, signed __int128 *addr, size_t len);
void vec_xst_len (vector double data, double *addr, size_t len);
void vec_xst_len (vector float data, float *addr, size_t len);

signed char vec_xlx (unsigned int index, vector signed char data);
unsigned char vec_xlx (unsigned int index, vector unsigned char data);
signed short vec_xlx (unsigned int index, vector signed short data);
unsigned short vec_xlx (unsigned int index, vector unsigned short data);
signed int vec_xlx (unsigned int index, vector signed int data);
unsigned int vec_xlx (unsigned int index, vector unsigned int data);
float vec_xlx (unsigned int index, vector float data);

signed char vec_xrx (unsigned int index, vector signed char data);
unsigned char vec_xrx (unsigned int index, vector unsigned char data);
signed short vec_xrx (unsigned int index, vector signed short data);
unsigned short vec_xrx (unsigned int index, vector unsigned short data);
signed int vec_xrx (unsigned int index, vector signed int data);
unsigned int vec_xrx (unsigned int index, vector unsigned int data);
float vec_xrx (unsigned int index, vector float data);
@end smallexample

The @code{vec_all_nez}, @code{vec_any_eqz}, and @code{vec_cmpnez}
perform pairwise comparisons between the elements at the same
positions within their two vector arguments.
The @code{vec_all_nez} function returns a
non-zero value if and only if all pairwise comparisons are not
equal and no element of either vector argument contains a zero.
The @code{vec_any_eqz} function returns a
non-zero value if and only if at least one pairwise comparison is equal
or if at least one element of either vector argument contains a zero.
The @code{vec_cmpnez} function returns a vector of the same type as
its two arguments, within which each element consists of all ones to
denote that either the corresponding elements of the incoming arguments are
not equal or that at least one of the corresponding elements contains
zero.  Otherwise, the element of the returned vector contains all zeros.

The @code{vec_cntlz_lsbb} function returns the count of the number of
consecutive leading byte elements (starting from position 0 within the
supplied vector argument) for which the least-significant bit
equals zero.  The @code{vec_cnttz_lsbb} function returns the count of
the number of consecutive trailing byte elements (starting from
position 15 and counting backwards within the supplied vector
argument) for which the least-significant bit equals zero.

The @code{vec_xl_len} and @code{vec_xst_len} functions require a
64-bit environment supporting ISA 3.0 or later.  The @code{vec_xl_len}
function loads a variable length vector from memory.  The
@code{vec_xst_len} function stores a variable length vector to memory.
With both the @code{vec_xl_len} and @code{vec_xst_len} functions, the
@code{addr} argument represents the memory address to or from which
data will be transferred, and the
@code{len} argument represents the number of bytes to be
transferred, as computed by the C expression @code{min((len & 0xff), 16)}.
If this expression's value is not a multiple of the vector element's
size, the behavior of this function is undefined.
In the case that the underlying computer is configured to run in
big-endian mode, the data transfer moves bytes 0 to @code{(len - 1)} of
the corresponding vector.  In little-endian mode, the data transfer
moves bytes @code{(16 - len)} to @code{15} of the corresponding
vector.  For the load function, any bytes of the result vector that
are not loaded from memory are set to zero.
The value of the @code{addr} argument need not be aligned on a
multiple of the vector's element size.

The @code{vec_xlx} and @code{vec_xrx} functions extract the single
element selected by the @code{index} argument from the vector
represented by the @code{data} argument.  The @code{index} argument
always specifies a byte offset, regardless of the size of the vector
element.  With @code{vec_xlx}, @code{index} is the offset of the first
byte of the element to be extracted.  With @code{vec_xrx}, @code{index}
represents the last byte of the element to be extracted, measured
from the right end of the vector.  In other words, the last byte of
the element to be extracted is found at position @code{(15 - index)}.
There is no requirement that @code{index} be a multiple of the vector
element size.  However, if the size of the vector element added to
@code{index} is greater than 15, the content of the returned value is
undefined.

The following built-in functions are available for the PowerPC family
of processors when hardware decimal floating point
(@option{-mhard-dfp}) is available:
@smallexample
long long __builtin_dxex (_Decimal64);
long long __builtin_dxexq (_Decimal128);
_Decimal64 __builtin_ddedpd (int, _Decimal64);
_Decimal128 __builtin_ddedpdq (int, _Decimal128);
_Decimal64 __builtin_denbcd (int, _Decimal64);
_Decimal128 __builtin_denbcdq (int, _Decimal128);
_Decimal64 __builtin_diex (long long, _Decimal64);
_Decimal128 _builtin_diexq (long long, _Decimal128);
_Decimal64 __builtin_dscli (_Decimal64, int);
_Decimal128 __builtin_dscliq (_Decimal128, int);
_Decimal64 __builtin_dscri (_Decimal64, int);
_Decimal128 __builtin_dscriq (_Decimal128, int);
unsigned long long __builtin_unpack_dec128 (_Decimal128, int);
_Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);
@end smallexample

The following built-in functions are available for the PowerPC family
of processors when the Vector Scalar (vsx) instruction set is
available:
@smallexample
unsigned long long __builtin_unpack_vector_int128 (vector __int128_t, int);
vector __int128_t __builtin_pack_vector_int128 (unsigned long long,
                                                unsigned long long);
@end smallexample

@node PowerPC AltiVec/VSX Built-in Functions
@subsection PowerPC AltiVec Built-in Functions

GCC provides an interface for the PowerPC family of processors to access
the AltiVec operations described in Motorola's AltiVec Programming
Interface Manual.  The interface is made available by including
@code{<altivec.h>} and using @option{-maltivec} and
@option{-mabi=altivec}.  The interface supports the following vector
types.

@smallexample
vector unsigned char
vector signed char
vector bool char

vector unsigned short
vector signed short
vector bool short
vector pixel

vector unsigned int
vector signed int
vector bool int
vector float
@end smallexample

If @option{-mvsx} is used the following additional vector types are
implemented.

@smallexample
vector unsigned long
vector signed long
vector double
@end smallexample

The long types are only implemented for 64-bit code generation, and
the long type is only used in the floating point/integer conversion
instructions.

GCC's implementation of the high-level language interface available from
C and C++ code differs from Motorola's documentation in several ways.

@itemize @bullet

@item
A vector constant is a list of constant expressions within curly braces.

@item
A vector initializer requires no cast if the vector constant is of the
same type as the variable it is initializing.

@item
If @code{signed} or @code{unsigned} is omitted, the signedness of the
vector type is the default signedness of the base type.  The default
varies depending on the operating system, so a portable program should
always specify the signedness.

@item
Compiling with @option{-maltivec} adds keywords @code{__vector},
@code{vector}, @code{__pixel}, @code{pixel}, @code{__bool} and
@code{bool}.  When compiling ISO C, the context-sensitive substitution
of the keywords @code{vector}, @code{pixel} and @code{bool} is
disabled.  To use them, you must include @code{<altivec.h>} instead.

@item
GCC allows using a @code{typedef} name as the type specifier for a
vector type.

@item
For C, overloaded functions are implemented with macros so the following
does not work:

@smallexample
  vec_add ((vector signed int)@{1, 2, 3, 4@}, foo);
@end smallexample

@noindent
Since @code{vec_add} is a macro, the vector constant in the example
is treated as four separate arguments.  Wrap the entire argument in
parentheses for this to work.
@end itemize

@emph{Note:} Only the @code{<altivec.h>} interface is supported.
Internally, GCC uses built-in functions to achieve the functionality in
the aforementioned header file, but they are not supported and are
subject to change without notice.

GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification,
which may be found at
@uref{http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html}.
Appendix A of this document lists the vector API interfaces that must be
provided by compliant compilers.  Programmers should preferentially use
the interfaces described therein.  However, historically GCC has provided
additional interfaces for access to vector instructions.  These are
briefly described below.

The following interfaces are supported for the generic and specific
AltiVec operations and the AltiVec predicates.  In cases where there
is a direct mapping between generic and specific operations, only the
generic names are shown here, although the specific operations can also
be used.

Arguments that are documented as @code{const int} require literal
integral values within the range required for that operation.

@smallexample
vector signed char vec_abs (vector signed char);
vector signed short vec_abs (vector signed short);
vector signed int vec_abs (vector signed int);
vector float vec_abs (vector float);

vector signed char vec_abss (vector signed char);
vector signed short vec_abss (vector signed short);
vector signed int vec_abss (vector signed int);

vector signed char vec_add (vector bool char, vector signed char);
vector signed char vec_add (vector signed char, vector bool char);
vector signed char vec_add (vector signed char, vector signed char);
vector unsigned char vec_add (vector bool char, vector unsigned char);
vector unsigned char vec_add (vector unsigned char, vector bool char);
vector unsigned char vec_add (vector unsigned char,
                              vector unsigned char);
vector signed short vec_add (vector bool short, vector signed short);
vector signed short vec_add (vector signed short, vector bool short);
vector signed short vec_add (vector signed short, vector signed short);
vector unsigned short vec_add (vector bool short,
                               vector unsigned short);
vector unsigned short vec_add (vector unsigned short,
                               vector bool short);
vector unsigned short vec_add (vector unsigned short,
                               vector unsigned short);
vector signed int vec_add (vector bool int, vector signed int);
vector signed int vec_add (vector signed int, vector bool int);
vector signed int vec_add (vector signed int, vector signed int);
vector unsigned int vec_add (vector bool int, vector unsigned int);
vector unsigned int vec_add (vector unsigned int, vector bool int);
vector unsigned int vec_add (vector unsigned int, vector unsigned int);
vector float vec_add (vector float, vector float);

vector float vec_vaddfp (vector float, vector float);

vector signed int vec_vadduwm (vector bool int, vector signed int);
vector signed int vec_vadduwm (vector signed int, vector bool int);
vector signed int vec_vadduwm (vector signed int, vector signed int);
vector unsigned int vec_vadduwm (vector bool int, vector unsigned int);
vector unsigned int vec_vadduwm (vector unsigned int, vector bool int);
vector unsigned int vec_vadduwm (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vadduhm (vector bool short,
                                 vector signed short);
vector signed short vec_vadduhm (vector signed short,
                                 vector bool short);
vector signed short vec_vadduhm (vector signed short,
                                 vector signed short);
vector unsigned short vec_vadduhm (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vadduhm (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vadduhm (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vaddubm (vector bool char, vector signed char);
vector signed char vec_vaddubm (vector signed char, vector bool char);
vector signed char vec_vaddubm (vector signed char, vector signed char);
vector unsigned char vec_vaddubm (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vaddubm (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vaddubm (vector unsigned char,
                                  vector unsigned char);

vector unsigned int vec_addc (vector unsigned int, vector unsigned int);

vector unsigned char vec_adds (vector bool char, vector unsigned char);
vector unsigned char vec_adds (vector unsigned char, vector bool char);
vector unsigned char vec_adds (vector unsigned char,
                               vector unsigned char);
vector signed char vec_adds (vector bool char, vector signed char);
vector signed char vec_adds (vector signed char, vector bool char);
vector signed char vec_adds (vector signed char, vector signed char);
vector unsigned short vec_adds (vector bool short,
                                vector unsigned short);
vector unsigned short vec_adds (vector unsigned short,
                                vector bool short);
vector unsigned short vec_adds (vector unsigned short,
                                vector unsigned short);
vector signed short vec_adds (vector bool short, vector signed short);
vector signed short vec_adds (vector signed short, vector bool short);
vector signed short vec_adds (vector signed short, vector signed short);
vector unsigned int vec_adds (vector bool int, vector unsigned int);
vector unsigned int vec_adds (vector unsigned int, vector bool int);
vector unsigned int vec_adds (vector unsigned int, vector unsigned int);
vector signed int vec_adds (vector bool int, vector signed int);
vector signed int vec_adds (vector signed int, vector bool int);
vector signed int vec_adds (vector signed int, vector signed int);

vector signed int vec_vaddsws (vector bool int, vector signed int);
vector signed int vec_vaddsws (vector signed int, vector bool int);
vector signed int vec_vaddsws (vector signed int, vector signed int);

vector unsigned int vec_vadduws (vector bool int, vector unsigned int);
vector unsigned int vec_vadduws (vector unsigned int, vector bool int);
vector unsigned int vec_vadduws (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vaddshs (vector bool short,
                                 vector signed short);
vector signed short vec_vaddshs (vector signed short,
                                 vector bool short);
vector signed short vec_vaddshs (vector signed short,
                                 vector signed short);

vector unsigned short vec_vadduhs (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vadduhs (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vadduhs (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vaddsbs (vector bool char, vector signed char);
vector signed char vec_vaddsbs (vector signed char, vector bool char);
vector signed char vec_vaddsbs (vector signed char, vector signed char);

vector unsigned char vec_vaddubs (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vaddubs (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vaddubs (vector unsigned char,
                                  vector unsigned char);

vector float vec_and (vector float, vector float);
vector float vec_and (vector float, vector bool int);
vector float vec_and (vector bool int, vector float);
vector bool int vec_and (vector bool int, vector bool int);
vector signed int vec_and (vector bool int, vector signed int);
vector signed int vec_and (vector signed int, vector bool int);
vector signed int vec_and (vector signed int, vector signed int);
vector unsigned int vec_and (vector bool int, vector unsigned int);
vector unsigned int vec_and (vector unsigned int, vector bool int);
vector unsigned int vec_and (vector unsigned int, vector unsigned int);
vector bool short vec_and (vector bool short, vector bool short);
vector signed short vec_and (vector bool short, vector signed short);
vector signed short vec_and (vector signed short, vector bool short);
vector signed short vec_and (vector signed short, vector signed short);
vector unsigned short vec_and (vector bool short,
                               vector unsigned short);
vector unsigned short vec_and (vector unsigned short,
                               vector bool short);
vector unsigned short vec_and (vector unsigned short,
                               vector unsigned short);
vector signed char vec_and (vector bool char, vector signed char);
vector bool char vec_and (vector bool char, vector bool char);
vector signed char vec_and (vector signed char, vector bool char);
vector signed char vec_and (vector signed char, vector signed char);
vector unsigned char vec_and (vector bool char, vector unsigned char);
vector unsigned char vec_and (vector unsigned char, vector bool char);
vector unsigned char vec_and (vector unsigned char,
                              vector unsigned char);

vector float vec_andc (vector float, vector float);
vector float vec_andc (vector float, vector bool int);
vector float vec_andc (vector bool int, vector float);
vector bool int vec_andc (vector bool int, vector bool int);
vector signed int vec_andc (vector bool int, vector signed int);
vector signed int vec_andc (vector signed int, vector bool int);
vector signed int vec_andc (vector signed int, vector signed int);
vector unsigned int vec_andc (vector bool int, vector unsigned int);
vector unsigned int vec_andc (vector unsigned int, vector bool int);
vector unsigned int vec_andc (vector unsigned int, vector unsigned int);
vector bool short vec_andc (vector bool short, vector bool short);
vector signed short vec_andc (vector bool short, vector signed short);
vector signed short vec_andc (vector signed short, vector bool short);
vector signed short vec_andc (vector signed short, vector signed short);
vector unsigned short vec_andc (vector bool short,
                                vector unsigned short);
vector unsigned short vec_andc (vector unsigned short,
                                vector bool short);
vector unsigned short vec_andc (vector unsigned short,
                                vector unsigned short);
vector signed char vec_andc (vector bool char, vector signed char);
vector bool char vec_andc (vector bool char, vector bool char);
vector signed char vec_andc (vector signed char, vector bool char);
vector signed char vec_andc (vector signed char, vector signed char);
vector unsigned char vec_andc (vector bool char, vector unsigned char);
vector unsigned char vec_andc (vector unsigned char, vector bool char);
vector unsigned char vec_andc (vector unsigned char,
                               vector unsigned char);

vector unsigned char vec_avg (vector unsigned char,
                              vector unsigned char);
vector signed char vec_avg (vector signed char, vector signed char);
vector unsigned short vec_avg (vector unsigned short,
                               vector unsigned short);
vector signed short vec_avg (vector signed short, vector signed short);
vector unsigned int vec_avg (vector unsigned int, vector unsigned int);
vector signed int vec_avg (vector signed int, vector signed int);

vector signed int vec_vavgsw (vector signed int, vector signed int);

vector unsigned int vec_vavguw (vector unsigned int,
                                vector unsigned int);

vector signed short vec_vavgsh (vector signed short,
                                vector signed short);

vector unsigned short vec_vavguh (vector unsigned short,
                                  vector unsigned short);

vector signed char vec_vavgsb (vector signed char, vector signed char);

vector unsigned char vec_vavgub (vector unsigned char,
                                 vector unsigned char);

vector float vec_copysign (vector float);

vector float vec_ceil (vector float);

vector signed int vec_cmpb (vector float, vector float);

vector bool char vec_cmpeq (vector bool char, vector bool char);
vector bool short vec_cmpeq (vector bool short, vector bool short);
vector bool int vec_cmpeq (vector bool int, vector bool int);
vector bool char vec_cmpeq (vector signed char, vector signed char);
vector bool char vec_cmpeq (vector unsigned char, vector unsigned char);
vector bool short vec_cmpeq (vector signed short, vector signed short);
vector bool short vec_cmpeq (vector unsigned short,
                             vector unsigned short);
vector bool int vec_cmpeq (vector signed int, vector signed int);
vector bool int vec_cmpeq (vector unsigned int, vector unsigned int);
vector bool int vec_cmpeq (vector float, vector float);

vector bool int vec_vcmpeqfp (vector float, vector float);

vector bool int vec_vcmpequw (vector signed int, vector signed int);
vector bool int vec_vcmpequw (vector unsigned int, vector unsigned int);

vector bool short vec_vcmpequh (vector signed short,
                                vector signed short);
vector bool short vec_vcmpequh (vector unsigned short,
                                vector unsigned short);

vector bool char vec_vcmpequb (vector signed char, vector signed char);
vector bool char vec_vcmpequb (vector unsigned char,
                               vector unsigned char);

vector bool int vec_cmpge (vector float, vector float);

vector bool char vec_cmpgt (vector unsigned char, vector unsigned char);
vector bool char vec_cmpgt (vector signed char, vector signed char);
vector bool short vec_cmpgt (vector unsigned short,
                             vector unsigned short);
vector bool short vec_cmpgt (vector signed short, vector signed short);
vector bool int vec_cmpgt (vector unsigned int, vector unsigned int);
vector bool int vec_cmpgt (vector signed int, vector signed int);
vector bool int vec_cmpgt (vector float, vector float);

vector bool int vec_vcmpgtfp (vector float, vector float);

vector bool int vec_vcmpgtsw (vector signed int, vector signed int);

vector bool int vec_vcmpgtuw (vector unsigned int, vector unsigned int);

vector bool short vec_vcmpgtsh (vector signed short,
                                vector signed short);

vector bool short vec_vcmpgtuh (vector unsigned short,
                                vector unsigned short);

vector bool char vec_vcmpgtsb (vector signed char, vector signed char);

vector bool char vec_vcmpgtub (vector unsigned char,
                               vector unsigned char);

vector bool int vec_cmple (vector float, vector float);

vector bool char vec_cmplt (vector unsigned char, vector unsigned char);
vector bool char vec_cmplt (vector signed char, vector signed char);
vector bool short vec_cmplt (vector unsigned short,
                             vector unsigned short);
vector bool short vec_cmplt (vector signed short, vector signed short);
vector bool int vec_cmplt (vector unsigned int, vector unsigned int);
vector bool int vec_cmplt (vector signed int, vector signed int);
vector bool int vec_cmplt (vector float, vector float);

vector float vec_cpsgn (vector float, vector float);

vector float vec_ctf (vector unsigned int, const int);
vector float vec_ctf (vector signed int, const int);
vector double vec_ctf (vector unsigned long, const int);
vector double vec_ctf (vector signed long, const int);

vector float vec_vcfsx (vector signed int, const int);

vector float vec_vcfux (vector unsigned int, const int);

vector signed int vec_cts (vector float, const int);
vector signed long vec_cts (vector double, const int);

vector unsigned int vec_ctu (vector float, const int);
vector unsigned long vec_ctu (vector double, const int);

void vec_dss (const int);

void vec_dssall (void);

void vec_dst (const vector unsigned char *, int, const int);
void vec_dst (const vector signed char *, int, const int);
void vec_dst (const vector bool char *, int, const int);
void vec_dst (const vector unsigned short *, int, const int);
void vec_dst (const vector signed short *, int, const int);
void vec_dst (const vector bool short *, int, const int);
void vec_dst (const vector pixel *, int, const int);
void vec_dst (const vector unsigned int *, int, const int);
void vec_dst (const vector signed int *, int, const int);
void vec_dst (const vector bool int *, int, const int);
void vec_dst (const vector float *, int, const int);
void vec_dst (const unsigned char *, int, const int);
void vec_dst (const signed char *, int, const int);
void vec_dst (const unsigned short *, int, const int);
void vec_dst (const short *, int, const int);
void vec_dst (const unsigned int *, int, const int);
void vec_dst (const int *, int, const int);
void vec_dst (const unsigned long *, int, const int);
void vec_dst (const long *, int, const int);
void vec_dst (const float *, int, const int);

void vec_dstst (const vector unsigned char *, int, const int);
void vec_dstst (const vector signed char *, int, const int);
void vec_dstst (const vector bool char *, int, const int);
void vec_dstst (const vector unsigned short *, int, const int);
void vec_dstst (const vector signed short *, int, const int);
void vec_dstst (const vector bool short *, int, const int);
void vec_dstst (const vector pixel *, int, const int);
void vec_dstst (const vector unsigned int *, int, const int);
void vec_dstst (const vector signed int *, int, const int);
void vec_dstst (const vector bool int *, int, const int);
void vec_dstst (const vector float *, int, const int);
void vec_dstst (const unsigned char *, int, const int);
void vec_dstst (const signed char *, int, const int);
void vec_dstst (const unsigned short *, int, const int);
void vec_dstst (const short *, int, const int);
void vec_dstst (const unsigned int *, int, const int);
void vec_dstst (const int *, int, const int);
void vec_dstst (const unsigned long *, int, const int);
void vec_dstst (const long *, int, const int);
void vec_dstst (const float *, int, const int);

void vec_dststt (const vector unsigned char *, int, const int);
void vec_dststt (const vector signed char *, int, const int);
void vec_dststt (const vector bool char *, int, const int);
void vec_dststt (const vector unsigned short *, int, const int);
void vec_dststt (const vector signed short *, int, const int);
void vec_dststt (const vector bool short *, int, const int);
void vec_dststt (const vector pixel *, int, const int);
void vec_dststt (const vector unsigned int *, int, const int);
void vec_dststt (const vector signed int *, int, const int);
void vec_dststt (const vector bool int *, int, const int);
void vec_dststt (const vector float *, int, const int);
void vec_dststt (const unsigned char *, int, const int);
void vec_dststt (const signed char *, int, const int);
void vec_dststt (const unsigned short *, int, const int);
void vec_dststt (const short *, int, const int);
void vec_dststt (const unsigned int *, int, const int);
void vec_dststt (const int *, int, const int);
void vec_dststt (const unsigned long *, int, const int);
void vec_dststt (const long *, int, const int);
void vec_dststt (const float *, int, const int);

void vec_dstt (const vector unsigned char *, int, const int);
void vec_dstt (const vector signed char *, int, const int);
void vec_dstt (const vector bool char *, int, const int);
void vec_dstt (const vector unsigned short *, int, const int);
void vec_dstt (const vector signed short *, int, const int);
void vec_dstt (const vector bool short *, int, const int);
void vec_dstt (const vector pixel *, int, const int);
void vec_dstt (const vector unsigned int *, int, const int);
void vec_dstt (const vector signed int *, int, const int);
void vec_dstt (const vector bool int *, int, const int);
void vec_dstt (const vector float *, int, const int);
void vec_dstt (const unsigned char *, int, const int);
void vec_dstt (const signed char *, int, const int);
void vec_dstt (const unsigned short *, int, const int);
void vec_dstt (const short *, int, const int);
void vec_dstt (const unsigned int *, int, const int);
void vec_dstt (const int *, int, const int);
void vec_dstt (const unsigned long *, int, const int);
void vec_dstt (const long *, int, const int);
void vec_dstt (const float *, int, const int);

vector float vec_expte (vector float);

vector float vec_floor (vector float);

vector float vec_ld (int, const vector float *);
vector float vec_ld (int, const float *);
vector bool int vec_ld (int, const vector bool int *);
vector signed int vec_ld (int, const vector signed int *);
vector signed int vec_ld (int, const int *);
vector signed int vec_ld (int, const long *);
vector unsigned int vec_ld (int, const vector unsigned int *);
vector unsigned int vec_ld (int, const unsigned int *);
vector unsigned int vec_ld (int, const unsigned long *);
vector bool short vec_ld (int, const vector bool short *);
vector pixel vec_ld (int, const vector pixel *);
vector signed short vec_ld (int, const vector signed short *);
vector signed short vec_ld (int, const short *);
vector unsigned short vec_ld (int, const vector unsigned short *);
vector unsigned short vec_ld (int, const unsigned short *);
vector bool char vec_ld (int, const vector bool char *);
vector signed char vec_ld (int, const vector signed char *);
vector signed char vec_ld (int, const signed char *);
vector unsigned char vec_ld (int, const vector unsigned char *);
vector unsigned char vec_ld (int, const unsigned char *);

vector signed char vec_lde (int, const signed char *);
vector unsigned char vec_lde (int, const unsigned char *);
vector signed short vec_lde (int, const short *);
vector unsigned short vec_lde (int, const unsigned short *);
vector float vec_lde (int, const float *);
vector signed int vec_lde (int, const int *);
vector unsigned int vec_lde (int, const unsigned int *);
vector signed int vec_lde (int, const long *);
vector unsigned int vec_lde (int, const unsigned long *);

vector float vec_lvewx (int, float *);
vector signed int vec_lvewx (int, int *);
vector unsigned int vec_lvewx (int, unsigned int *);
vector signed int vec_lvewx (int, long *);
vector unsigned int vec_lvewx (int, unsigned long *);

vector signed short vec_lvehx (int, short *);
vector unsigned short vec_lvehx (int, unsigned short *);

vector signed char vec_lvebx (int, char *);
vector unsigned char vec_lvebx (int, unsigned char *);

vector float vec_ldl (int, const vector float *);
vector float vec_ldl (int, const float *);
vector bool int vec_ldl (int, const vector bool int *);
vector signed int vec_ldl (int, const vector signed int *);
vector signed int vec_ldl (int, const int *);
vector signed int vec_ldl (int, const long *);
vector unsigned int vec_ldl (int, const vector unsigned int *);
vector unsigned int vec_ldl (int, const unsigned int *);
vector unsigned int vec_ldl (int, const unsigned long *);
vector bool short vec_ldl (int, const vector bool short *);
vector pixel vec_ldl (int, const vector pixel *);
vector signed short vec_ldl (int, const vector signed short *);
vector signed short vec_ldl (int, const short *);
vector unsigned short vec_ldl (int, const vector unsigned short *);
vector unsigned short vec_ldl (int, const unsigned short *);
vector bool char vec_ldl (int, const vector bool char *);
vector signed char vec_ldl (int, const vector signed char *);
vector signed char vec_ldl (int, const signed char *);
vector unsigned char vec_ldl (int, const vector unsigned char *);
vector unsigned char vec_ldl (int, const unsigned char *);

vector float vec_loge (vector float);

vector unsigned char vec_lvsl (int, const volatile unsigned char *);
vector unsigned char vec_lvsl (int, const volatile signed char *);
vector unsigned char vec_lvsl (int, const volatile unsigned short *);
vector unsigned char vec_lvsl (int, const volatile short *);
vector unsigned char vec_lvsl (int, const volatile unsigned int *);
vector unsigned char vec_lvsl (int, const volatile int *);
vector unsigned char vec_lvsl (int, const volatile unsigned long *);
vector unsigned char vec_lvsl (int, const volatile long *);
vector unsigned char vec_lvsl (int, const volatile float *);

vector unsigned char vec_lvsr (int, const volatile unsigned char *);
vector unsigned char vec_lvsr (int, const volatile signed char *);
vector unsigned char vec_lvsr (int, const volatile unsigned short *);
vector unsigned char vec_lvsr (int, const volatile short *);
vector unsigned char vec_lvsr (int, const volatile unsigned int *);
vector unsigned char vec_lvsr (int, const volatile int *);
vector unsigned char vec_lvsr (int, const volatile unsigned long *);
vector unsigned char vec_lvsr (int, const volatile long *);
vector unsigned char vec_lvsr (int, const volatile float *);

vector float vec_madd (vector float, vector float, vector float);

vector signed short vec_madds (vector signed short,
                               vector signed short,
                               vector signed short);

vector unsigned char vec_max (vector bool char, vector unsigned char);
vector unsigned char vec_max (vector unsigned char, vector bool char);
vector unsigned char vec_max (vector unsigned char,
                              vector unsigned char);
vector signed char vec_max (vector bool char, vector signed char);
vector signed char vec_max (vector signed char, vector bool char);
vector signed char vec_max (vector signed char, vector signed char);
vector unsigned short vec_max (vector bool short,
                               vector unsigned short);
vector unsigned short vec_max (vector unsigned short,
                               vector bool short);
vector unsigned short vec_max (vector unsigned short,
                               vector unsigned short);
vector signed short vec_max (vector bool short, vector signed short);
vector signed short vec_max (vector signed short, vector bool short);
vector signed short vec_max (vector signed short, vector signed short);
vector unsigned int vec_max (vector bool int, vector unsigned int);
vector unsigned int vec_max (vector unsigned int, vector bool int);
vector unsigned int vec_max (vector unsigned int, vector unsigned int);
vector signed int vec_max (vector bool int, vector signed int);
vector signed int vec_max (vector signed int, vector bool int);
vector signed int vec_max (vector signed int, vector signed int);
vector float vec_max (vector float, vector float);

vector float vec_vmaxfp (vector float, vector float);

vector signed int vec_vmaxsw (vector bool int, vector signed int);
vector signed int vec_vmaxsw (vector signed int, vector bool int);
vector signed int vec_vmaxsw (vector signed int, vector signed int);

vector unsigned int vec_vmaxuw (vector bool int, vector unsigned int);
vector unsigned int vec_vmaxuw (vector unsigned int, vector bool int);
vector unsigned int vec_vmaxuw (vector unsigned int,
                                vector unsigned int);

vector signed short vec_vmaxsh (vector bool short, vector signed short);
vector signed short vec_vmaxsh (vector signed short, vector bool short);
vector signed short vec_vmaxsh (vector signed short,
                                vector signed short);

vector unsigned short vec_vmaxuh (vector bool short,
                                  vector unsigned short);
vector unsigned short vec_vmaxuh (vector unsigned short,
                                  vector bool short);
vector unsigned short vec_vmaxuh (vector unsigned short,
                                  vector unsigned short);

vector signed char vec_vmaxsb (vector bool char, vector signed char);
vector signed char vec_vmaxsb (vector signed char, vector bool char);
vector signed char vec_vmaxsb (vector signed char, vector signed char);

vector unsigned char vec_vmaxub (vector bool char,
                                 vector unsigned char);
vector unsigned char vec_vmaxub (vector unsigned char,
                                 vector bool char);
vector unsigned char vec_vmaxub (vector unsigned char,
                                 vector unsigned char);

vector bool char vec_mergeh (vector bool char, vector bool char);
vector signed char vec_mergeh (vector signed char, vector signed char);
vector unsigned char vec_mergeh (vector unsigned char,
                                 vector unsigned char);
vector bool short vec_mergeh (vector bool short, vector bool short);
vector pixel vec_mergeh (vector pixel, vector pixel);
vector signed short vec_mergeh (vector signed short,
                                vector signed short);
vector unsigned short vec_mergeh (vector unsigned short,
                                  vector unsigned short);
vector float vec_mergeh (vector float, vector float);
vector bool int vec_mergeh (vector bool int, vector bool int);
vector signed int vec_mergeh (vector signed int, vector signed int);
vector unsigned int vec_mergeh (vector unsigned int,
                                vector unsigned int);

vector float vec_vmrghw (vector float, vector float);
vector bool int vec_vmrghw (vector bool int, vector bool int);
vector signed int vec_vmrghw (vector signed int, vector signed int);
vector unsigned int vec_vmrghw (vector unsigned int,
                                vector unsigned int);

vector bool short vec_vmrghh (vector bool short, vector bool short);
vector signed short vec_vmrghh (vector signed short,
                                vector signed short);
vector unsigned short vec_vmrghh (vector unsigned short,
                                  vector unsigned short);
vector pixel vec_vmrghh (vector pixel, vector pixel);

vector bool char vec_vmrghb (vector bool char, vector bool char);
vector signed char vec_vmrghb (vector signed char, vector signed char);
vector unsigned char vec_vmrghb (vector unsigned char,
                                 vector unsigned char);

vector bool char vec_mergel (vector bool char, vector bool char);
vector signed char vec_mergel (vector signed char, vector signed char);
vector unsigned char vec_mergel (vector unsigned char,
                                 vector unsigned char);
vector bool short vec_mergel (vector bool short, vector bool short);
vector pixel vec_mergel (vector pixel, vector pixel);
vector signed short vec_mergel (vector signed short,
                                vector signed short);
vector unsigned short vec_mergel (vector unsigned short,
                                  vector unsigned short);
vector float vec_mergel (vector float, vector float);
vector bool int vec_mergel (vector bool int, vector bool int);
vector signed int vec_mergel (vector signed int, vector signed int);
vector unsigned int vec_mergel (vector unsigned int,
                                vector unsigned int);

vector float vec_vmrglw (vector float, vector float);
vector signed int vec_vmrglw (vector signed int, vector signed int);
vector unsigned int vec_vmrglw (vector unsigned int,
                                vector unsigned int);
vector bool int vec_vmrglw (vector bool int, vector bool int);

vector bool short vec_vmrglh (vector bool short, vector bool short);
vector signed short vec_vmrglh (vector signed short,
                                vector signed short);
vector unsigned short vec_vmrglh (vector unsigned short,
                                  vector unsigned short);
vector pixel vec_vmrglh (vector pixel, vector pixel);

vector bool char vec_vmrglb (vector bool char, vector bool char);
vector signed char vec_vmrglb (vector signed char, vector signed char);
vector unsigned char vec_vmrglb (vector unsigned char,
                                 vector unsigned char);

vector unsigned short vec_mfvscr (void);

vector unsigned char vec_min (vector bool char, vector unsigned char);
vector unsigned char vec_min (vector unsigned char, vector bool char);
vector unsigned char vec_min (vector unsigned char,
                              vector unsigned char);
vector signed char vec_min (vector bool char, vector signed char);
vector signed char vec_min (vector signed char, vector bool char);
vector signed char vec_min (vector signed char, vector signed char);
vector unsigned short vec_min (vector bool short,
                               vector unsigned short);
vector unsigned short vec_min (vector unsigned short,
                               vector bool short);
vector unsigned short vec_min (vector unsigned short,
                               vector unsigned short);
vector signed short vec_min (vector bool short, vector signed short);
vector signed short vec_min (vector signed short, vector bool short);
vector signed short vec_min (vector signed short, vector signed short);
vector unsigned int vec_min (vector bool int, vector unsigned int);
vector unsigned int vec_min (vector unsigned int, vector bool int);
vector unsigned int vec_min (vector unsigned int, vector unsigned int);
vector signed int vec_min (vector bool int, vector signed int);
vector signed int vec_min (vector signed int, vector bool int);
vector signed int vec_min (vector signed int, vector signed int);
vector float vec_min (vector float, vector float);

vector float vec_vminfp (vector float, vector float);

vector signed int vec_vminsw (vector bool int, vector signed int);
vector signed int vec_vminsw (vector signed int, vector bool int);
vector signed int vec_vminsw (vector signed int, vector signed int);

vector unsigned int vec_vminuw (vector bool int, vector unsigned int);
vector unsigned int vec_vminuw (vector unsigned int, vector bool int);
vector unsigned int vec_vminuw (vector unsigned int,
                                vector unsigned int);

vector signed short vec_vminsh (vector bool short, vector signed short);
vector signed short vec_vminsh (vector signed short, vector bool short);
vector signed short vec_vminsh (vector signed short,
                                vector signed short);

vector unsigned short vec_vminuh (vector bool short,
                                  vector unsigned short);
vector unsigned short vec_vminuh (vector unsigned short,
                                  vector bool short);
vector unsigned short vec_vminuh (vector unsigned short,
                                  vector unsigned short);

vector signed char vec_vminsb (vector bool char, vector signed char);
vector signed char vec_vminsb (vector signed char, vector bool char);
vector signed char vec_vminsb (vector signed char, vector signed char);

vector unsigned char vec_vminub (vector bool char,
                                 vector unsigned char);
vector unsigned char vec_vminub (vector unsigned char,
                                 vector bool char);
vector unsigned char vec_vminub (vector unsigned char,
                                 vector unsigned char);

vector signed short vec_mladd (vector signed short,
                               vector signed short,
                               vector signed short);
vector signed short vec_mladd (vector signed short,
                               vector unsigned short,
                               vector unsigned short);
vector signed short vec_mladd (vector unsigned short,
                               vector signed short,
                               vector signed short);
vector unsigned short vec_mladd (vector unsigned short,
                                 vector unsigned short,
                                 vector unsigned short);

vector signed short vec_mradds (vector signed short,
                                vector signed short,
                                vector signed short);

vector unsigned int vec_msum (vector unsigned char,
                              vector unsigned char,
                              vector unsigned int);
vector signed int vec_msum (vector signed char,
                            vector unsigned char,
                            vector signed int);
vector unsigned int vec_msum (vector unsigned short,
                              vector unsigned short,
                              vector unsigned int);
vector signed int vec_msum (vector signed short,
                            vector signed short,
                            vector signed int);

vector signed int vec_vmsumshm (vector signed short,
                                vector signed short,
                                vector signed int);

vector unsigned int vec_vmsumuhm (vector unsigned short,
                                  vector unsigned short,
                                  vector unsigned int);

vector signed int vec_vmsummbm (vector signed char,
                                vector unsigned char,
                                vector signed int);

vector unsigned int vec_vmsumubm (vector unsigned char,
                                  vector unsigned char,
                                  vector unsigned int);

vector unsigned int vec_msums (vector unsigned short,
                               vector unsigned short,
                               vector unsigned int);
vector signed int vec_msums (vector signed short,
                             vector signed short,
                             vector signed int);

vector signed int vec_vmsumshs (vector signed short,
                                vector signed short,
                                vector signed int);

vector unsigned int vec_vmsumuhs (vector unsigned short,
                                  vector unsigned short,
                                  vector unsigned int);

void vec_mtvscr (vector signed int);
void vec_mtvscr (vector unsigned int);
void vec_mtvscr (vector bool int);
void vec_mtvscr (vector signed short);
void vec_mtvscr (vector unsigned short);
void vec_mtvscr (vector bool short);
void vec_mtvscr (vector pixel);
void vec_mtvscr (vector signed char);
void vec_mtvscr (vector unsigned char);
void vec_mtvscr (vector bool char);

vector unsigned short vec_mule (vector unsigned char,
                                vector unsigned char);
vector signed short vec_mule (vector signed char,
                              vector signed char);
vector unsigned int vec_mule (vector unsigned short,
                              vector unsigned short);
vector signed int vec_mule (vector signed short, vector signed short);

vector signed int vec_vmulesh (vector signed short,
                               vector signed short);

vector unsigned int vec_vmuleuh (vector unsigned short,
                                 vector unsigned short);

vector signed short vec_vmulesb (vector signed char,
                                 vector signed char);

vector unsigned short vec_vmuleub (vector unsigned char,
                                  vector unsigned char);

vector unsigned short vec_mulo (vector unsigned char,
                                vector unsigned char);
vector signed short vec_mulo (vector signed char, vector signed char);
vector unsigned int vec_mulo (vector unsigned short,
                              vector unsigned short);
vector signed int vec_mulo (vector signed short, vector signed short);

vector signed int vec_vmulosh (vector signed short,
                               vector signed short);

vector unsigned int vec_vmulouh (vector unsigned short,
                                 vector unsigned short);

vector signed short vec_vmulosb (vector signed char,
                                 vector signed char);

vector unsigned short vec_vmuloub (vector unsigned char,
                                   vector unsigned char);

vector float vec_nmsub (vector float, vector float, vector float);

vector signed char vec_nabs (vector signed char);
vector signed short vec_nabs (vector signed short);
vector signed int vec_nabs (vector signed int);
vector float vec_nabs (vector float);
vector double vec_nabs (vector double);

vector float vec_nor (vector float, vector float);
vector signed int vec_nor (vector signed int, vector signed int);
vector unsigned int vec_nor (vector unsigned int, vector unsigned int);
vector bool int vec_nor (vector bool int, vector bool int);
vector signed short vec_nor (vector signed short, vector signed short);
vector unsigned short vec_nor (vector unsigned short,
                               vector unsigned short);
vector bool short vec_nor (vector bool short, vector bool short);
vector signed char vec_nor (vector signed char, vector signed char);
vector unsigned char vec_nor (vector unsigned char,
                              vector unsigned char);
vector bool char vec_nor (vector bool char, vector bool char);

vector float vec_or (vector float, vector float);
vector float vec_or (vector float, vector bool int);
vector float vec_or (vector bool int, vector float);
vector bool int vec_or (vector bool int, vector bool int);
vector signed int vec_or (vector bool int, vector signed int);
vector signed int vec_or (vector signed int, vector bool int);
vector signed int vec_or (vector signed int, vector signed int);
vector unsigned int vec_or (vector bool int, vector unsigned int);
vector unsigned int vec_or (vector unsigned int, vector bool int);
vector unsigned int vec_or (vector unsigned int, vector unsigned int);
vector bool short vec_or (vector bool short, vector bool short);
vector signed short vec_or (vector bool short, vector signed short);
vector signed short vec_or (vector signed short, vector bool short);
vector signed short vec_or (vector signed short, vector signed short);
vector unsigned short vec_or (vector bool short, vector unsigned short);
vector unsigned short vec_or (vector unsigned short, vector bool short);
vector unsigned short vec_or (vector unsigned short,
                              vector unsigned short);
vector signed char vec_or (vector bool char, vector signed char);
vector bool char vec_or (vector bool char, vector bool char);
vector signed char vec_or (vector signed char, vector bool char);
vector signed char vec_or (vector signed char, vector signed char);
vector unsigned char vec_or (vector bool char, vector unsigned char);
vector unsigned char vec_or (vector unsigned char, vector bool char);
vector unsigned char vec_or (vector unsigned char,
                             vector unsigned char);

vector signed char vec_pack (vector signed short, vector signed short);
vector unsigned char vec_pack (vector unsigned short,
                               vector unsigned short);
vector bool char vec_pack (vector bool short, vector bool short);
vector signed short vec_pack (vector signed int, vector signed int);
vector unsigned short vec_pack (vector unsigned int,
                                vector unsigned int);
vector bool short vec_pack (vector bool int, vector bool int);

vector bool short vec_vpkuwum (vector bool int, vector bool int);
vector signed short vec_vpkuwum (vector signed int, vector signed int);
vector unsigned short vec_vpkuwum (vector unsigned int,
                                   vector unsigned int);

vector bool char vec_vpkuhum (vector bool short, vector bool short);
vector signed char vec_vpkuhum (vector signed short,
                                vector signed short);
vector unsigned char vec_vpkuhum (vector unsigned short,
                                  vector unsigned short);

vector pixel vec_packpx (vector unsigned int, vector unsigned int);

vector unsigned char vec_packs (vector unsigned short,
                                vector unsigned short);
vector signed char vec_packs (vector signed short, vector signed short);
vector unsigned short vec_packs (vector unsigned int,
                                 vector unsigned int);
vector signed short vec_packs (vector signed int, vector signed int);

vector signed short vec_vpkswss (vector signed int, vector signed int);

vector unsigned short vec_vpkuwus (vector unsigned int,
                                   vector unsigned int);

vector signed char vec_vpkshss (vector signed short,
                                vector signed short);

vector unsigned char vec_vpkuhus (vector unsigned short,
                                  vector unsigned short);

vector unsigned char vec_packsu (vector unsigned short,
                                 vector unsigned short);
vector unsigned char vec_packsu (vector signed short,
                                 vector signed short);
vector unsigned short vec_packsu (vector unsigned int,
                                  vector unsigned int);
vector unsigned short vec_packsu (vector signed int, vector signed int);

vector unsigned short vec_vpkswus (vector signed int,
                                   vector signed int);

vector unsigned char vec_vpkshus (vector signed short,
                                  vector signed short);

vector float vec_perm (vector float,
                       vector float,
                       vector unsigned char);
vector signed int vec_perm (vector signed int,
                            vector signed int,
                            vector unsigned char);
vector unsigned int vec_perm (vector unsigned int,
                              vector unsigned int,
                              vector unsigned char);
vector bool int vec_perm (vector bool int,
                          vector bool int,
                          vector unsigned char);
vector signed short vec_perm (vector signed short,
                              vector signed short,
                              vector unsigned char);
vector unsigned short vec_perm (vector unsigned short,
                                vector unsigned short,
                                vector unsigned char);
vector bool short vec_perm (vector bool short,
                            vector bool short,
                            vector unsigned char);
vector pixel vec_perm (vector pixel,
                       vector pixel,
                       vector unsigned char);
vector signed char vec_perm (vector signed char,
                             vector signed char,
                             vector unsigned char);
vector unsigned char vec_perm (vector unsigned char,
                               vector unsigned char,
                               vector unsigned char);
vector bool char vec_perm (vector bool char,
                           vector bool char,
                           vector unsigned char);

vector float vec_re (vector float);

vector signed char vec_rl (vector signed char,
                           vector unsigned char);
vector unsigned char vec_rl (vector unsigned char,
                             vector unsigned char);
vector signed short vec_rl (vector signed short, vector unsigned short);
vector unsigned short vec_rl (vector unsigned short,
                              vector unsigned short);
vector signed int vec_rl (vector signed int, vector unsigned int);
vector unsigned int vec_rl (vector unsigned int, vector unsigned int);

vector signed int vec_vrlw (vector signed int, vector unsigned int);
vector unsigned int vec_vrlw (vector unsigned int, vector unsigned int);

vector signed short vec_vrlh (vector signed short,
                              vector unsigned short);
vector unsigned short vec_vrlh (vector unsigned short,
                                vector unsigned short);

vector signed char vec_vrlb (vector signed char, vector unsigned char);
vector unsigned char vec_vrlb (vector unsigned char,
                               vector unsigned char);

vector float vec_round (vector float);

vector float vec_recip (vector float, vector float);

vector float vec_rsqrt (vector float);

vector float vec_rsqrte (vector float);

vector float vec_sel (vector float, vector float, vector bool int);
vector float vec_sel (vector float, vector float, vector unsigned int);
vector signed int vec_sel (vector signed int,
                           vector signed int,
                           vector bool int);
vector signed int vec_sel (vector signed int,
                           vector signed int,
                           vector unsigned int);
vector unsigned int vec_sel (vector unsigned int,
                             vector unsigned int,
                             vector bool int);
vector unsigned int vec_sel (vector unsigned int,
                             vector unsigned int,
                             vector unsigned int);
vector bool int vec_sel (vector bool int,
                         vector bool int,
                         vector bool int);
vector bool int vec_sel (vector bool int,
                         vector bool int,
                         vector unsigned int);
vector signed short vec_sel (vector signed short,
                             vector signed short,
                             vector bool short);
vector signed short vec_sel (vector signed short,
                             vector signed short,
                             vector unsigned short);
vector unsigned short vec_sel (vector unsigned short,
                               vector unsigned short,
                               vector bool short);
vector unsigned short vec_sel (vector unsigned short,
                               vector unsigned short,
                               vector unsigned short);
vector bool short vec_sel (vector bool short,
                           vector bool short,
                           vector bool short);
vector bool short vec_sel (vector bool short,
                           vector bool short,
                           vector unsigned short);
vector signed char vec_sel (vector signed char,
                            vector signed char,
                            vector bool char);
vector signed char vec_sel (vector signed char,
                            vector signed char,
                            vector unsigned char);
vector unsigned char vec_sel (vector unsigned char,
                              vector unsigned char,
                              vector bool char);
vector unsigned char vec_sel (vector unsigned char,
                              vector unsigned char,
                              vector unsigned char);
vector bool char vec_sel (vector bool char,
                          vector bool char,
                          vector bool char);
vector bool char vec_sel (vector bool char,
                          vector bool char,
                          vector unsigned char);

vector signed char vec_sl (vector signed char,
                           vector unsigned char);
vector unsigned char vec_sl (vector unsigned char,
                             vector unsigned char);
vector signed short vec_sl (vector signed short, vector unsigned short);
vector unsigned short vec_sl (vector unsigned short,
                              vector unsigned short);
vector signed int vec_sl (vector signed int, vector unsigned int);
vector unsigned int vec_sl (vector unsigned int, vector unsigned int);

vector signed int vec_vslw (vector signed int, vector unsigned int);
vector unsigned int vec_vslw (vector unsigned int, vector unsigned int);

vector signed short vec_vslh (vector signed short,
                              vector unsigned short);
vector unsigned short vec_vslh (vector unsigned short,
                                vector unsigned short);

vector signed char vec_vslb (vector signed char, vector unsigned char);
vector unsigned char vec_vslb (vector unsigned char,
                               vector unsigned char);

vector float vec_sld (vector float, vector float, const int);
vector double vec_sld (vector double, vector double, const int);

vector signed int vec_sld (vector signed int,
                           vector signed int,
                           const int);
vector unsigned int vec_sld (vector unsigned int,
                             vector unsigned int,
                             const int);
vector bool int vec_sld (vector bool int,
                         vector bool int,
                         const int);
vector signed short vec_sld (vector signed short,
                             vector signed short,
                             const int);
vector unsigned short vec_sld (vector unsigned short,
                               vector unsigned short,
                               const int);
vector bool short vec_sld (vector bool short,
                           vector bool short,
                           const int);
vector pixel vec_sld (vector pixel,
                      vector pixel,
                      const int);
vector signed char vec_sld (vector signed char,
                            vector signed char,
                            const int);
vector unsigned char vec_sld (vector unsigned char,
                              vector unsigned char,
                              const int);
vector bool char vec_sld (vector bool char,
                          vector bool char,
                          const int);

vector signed int vec_sll (vector signed int,
                           vector unsigned int);
vector signed int vec_sll (vector signed int,
                           vector unsigned short);
vector signed int vec_sll (vector signed int,
                           vector unsigned char);
vector unsigned int vec_sll (vector unsigned int,
                             vector unsigned int);
vector unsigned int vec_sll (vector unsigned int,
                             vector unsigned short);
vector unsigned int vec_sll (vector unsigned int,
                             vector unsigned char);
vector bool int vec_sll (vector bool int,
                         vector unsigned int);
vector bool int vec_sll (vector bool int,
                         vector unsigned short);
vector bool int vec_sll (vector bool int,
                         vector unsigned char);
vector signed short vec_sll (vector signed short,
                             vector unsigned int);
vector signed short vec_sll (vector signed short,
                             vector unsigned short);
vector signed short vec_sll (vector signed short,
                             vector unsigned char);
vector unsigned short vec_sll (vector unsigned short,
                               vector unsigned int);
vector unsigned short vec_sll (vector unsigned short,
                               vector unsigned short);
vector unsigned short vec_sll (vector unsigned short,
                               vector unsigned char);
vector bool short vec_sll (vector bool short, vector unsigned int);
vector bool short vec_sll (vector bool short, vector unsigned short);
vector bool short vec_sll (vector bool short, vector unsigned char);
vector pixel vec_sll (vector pixel, vector unsigned int);
vector pixel vec_sll (vector pixel, vector unsigned short);
vector pixel vec_sll (vector pixel, vector unsigned char);
vector signed char vec_sll (vector signed char, vector unsigned int);
vector signed char vec_sll (vector signed char, vector unsigned short);
vector signed char vec_sll (vector signed char, vector unsigned char);
vector unsigned char vec_sll (vector unsigned char,
                              vector unsigned int);
vector unsigned char vec_sll (vector unsigned char,
                              vector unsigned short);
vector unsigned char vec_sll (vector unsigned char,
                              vector unsigned char);
vector bool char vec_sll (vector bool char, vector unsigned int);
vector bool char vec_sll (vector bool char, vector unsigned short);
vector bool char vec_sll (vector bool char, vector unsigned char);

vector float vec_slo (vector float, vector signed char);
vector float vec_slo (vector float, vector unsigned char);
vector signed int vec_slo (vector signed int, vector signed char);
vector signed int vec_slo (vector signed int, vector unsigned char);
vector unsigned int vec_slo (vector unsigned int, vector signed char);
vector unsigned int vec_slo (vector unsigned int, vector unsigned char);
vector signed short vec_slo (vector signed short, vector signed char);
vector signed short vec_slo (vector signed short, vector unsigned char);
vector unsigned short vec_slo (vector unsigned short,
                               vector signed char);
vector unsigned short vec_slo (vector unsigned short,
                               vector unsigned char);
vector pixel vec_slo (vector pixel, vector signed char);
vector pixel vec_slo (vector pixel, vector unsigned char);
vector signed char vec_slo (vector signed char, vector signed char);
vector signed char vec_slo (vector signed char, vector unsigned char);
vector unsigned char vec_slo (vector unsigned char, vector signed char);
vector unsigned char vec_slo (vector unsigned char,
                              vector unsigned char);

vector signed char vec_splat (vector signed char, const int);
vector unsigned char vec_splat (vector unsigned char, const int);
vector bool char vec_splat (vector bool char, const int);
vector signed short vec_splat (vector signed short, const int);
vector unsigned short vec_splat (vector unsigned short, const int);
vector bool short vec_splat (vector bool short, const int);
vector pixel vec_splat (vector pixel, const int);
vector float vec_splat (vector float, const int);
vector signed int vec_splat (vector signed int, const int);
vector unsigned int vec_splat (vector unsigned int, const int);
vector bool int vec_splat (vector bool int, const int);
vector signed long vec_splat (vector signed long, const int);
vector unsigned long vec_splat (vector unsigned long, const int);

vector signed char vec_splats (signed char);
vector unsigned char vec_splats (unsigned char);
vector signed short vec_splats (signed short);
vector unsigned short vec_splats (unsigned short);
vector signed int vec_splats (signed int);
vector unsigned int vec_splats (unsigned int);
vector float vec_splats (float);

vector float vec_vspltw (vector float, const int);
vector signed int vec_vspltw (vector signed int, const int);
vector unsigned int vec_vspltw (vector unsigned int, const int);
vector bool int vec_vspltw (vector bool int, const int);

vector bool short vec_vsplth (vector bool short, const int);
vector signed short vec_vsplth (vector signed short, const int);
vector unsigned short vec_vsplth (vector unsigned short, const int);
vector pixel vec_vsplth (vector pixel, const int);

vector signed char vec_vspltb (vector signed char, const int);
vector unsigned char vec_vspltb (vector unsigned char, const int);
vector bool char vec_vspltb (vector bool char, const int);

vector signed char vec_splat_s8 (const int);

vector signed short vec_splat_s16 (const int);

vector signed int vec_splat_s32 (const int);

vector unsigned char vec_splat_u8 (const int);

vector unsigned short vec_splat_u16 (const int);

vector unsigned int vec_splat_u32 (const int);

vector signed char vec_sr (vector signed char, vector unsigned char);
vector unsigned char vec_sr (vector unsigned char,
                             vector unsigned char);
vector signed short vec_sr (vector signed short,
                            vector unsigned short);
vector unsigned short vec_sr (vector unsigned short,
                              vector unsigned short);
vector signed int vec_sr (vector signed int, vector unsigned int);
vector unsigned int vec_sr (vector unsigned int, vector unsigned int);

vector signed int vec_vsrw (vector signed int, vector unsigned int);
vector unsigned int vec_vsrw (vector unsigned int, vector unsigned int);

vector signed short vec_vsrh (vector signed short,
                              vector unsigned short);
vector unsigned short vec_vsrh (vector unsigned short,
                                vector unsigned short);

vector signed char vec_vsrb (vector signed char, vector unsigned char);
vector unsigned char vec_vsrb (vector unsigned char,
                               vector unsigned char);

vector signed char vec_sra (vector signed char, vector unsigned char);
vector unsigned char vec_sra (vector unsigned char,
                              vector unsigned char);
vector signed short vec_sra (vector signed short,
                             vector unsigned short);
vector unsigned short vec_sra (vector unsigned short,
                               vector unsigned short);
vector signed int vec_sra (vector signed int, vector unsigned int);
vector unsigned int vec_sra (vector unsigned int, vector unsigned int);

vector signed int vec_vsraw (vector signed int, vector unsigned int);
vector unsigned int vec_vsraw (vector unsigned int,
                               vector unsigned int);

vector signed short vec_vsrah (vector signed short,
                               vector unsigned short);
vector unsigned short vec_vsrah (vector unsigned short,
                                 vector unsigned short);

vector signed char vec_vsrab (vector signed char, vector unsigned char);
vector unsigned char vec_vsrab (vector unsigned char,
                                vector unsigned char);

vector signed int vec_srl (vector signed int, vector unsigned int);
vector signed int vec_srl (vector signed int, vector unsigned short);
vector signed int vec_srl (vector signed int, vector unsigned char);
vector unsigned int vec_srl (vector unsigned int, vector unsigned int);
vector unsigned int vec_srl (vector unsigned int,
                             vector unsigned short);
vector unsigned int vec_srl (vector unsigned int, vector unsigned char);
vector bool int vec_srl (vector bool int, vector unsigned int);
vector bool int vec_srl (vector bool int, vector unsigned short);
vector bool int vec_srl (vector bool int, vector unsigned char);
vector signed short vec_srl (vector signed short, vector unsigned int);
vector signed short vec_srl (vector signed short,
                             vector unsigned short);
vector signed short vec_srl (vector signed short, vector unsigned char);
vector unsigned short vec_srl (vector unsigned short,
                               vector unsigned int);
vector unsigned short vec_srl (vector unsigned short,
                               vector unsigned short);
vector unsigned short vec_srl (vector unsigned short,
                               vector unsigned char);
vector bool short vec_srl (vector bool short, vector unsigned int);
vector bool short vec_srl (vector bool short, vector unsigned short);
vector bool short vec_srl (vector bool short, vector unsigned char);
vector pixel vec_srl (vector pixel, vector unsigned int);
vector pixel vec_srl (vector pixel, vector unsigned short);
vector pixel vec_srl (vector pixel, vector unsigned char);
vector signed char vec_srl (vector signed char, vector unsigned int);
vector signed char vec_srl (vector signed char, vector unsigned short);
vector signed char vec_srl (vector signed char, vector unsigned char);
vector unsigned char vec_srl (vector unsigned char,
                              vector unsigned int);
vector unsigned char vec_srl (vector unsigned char,
                              vector unsigned short);
vector unsigned char vec_srl (vector unsigned char,
                              vector unsigned char);
vector bool char vec_srl (vector bool char, vector unsigned int);
vector bool char vec_srl (vector bool char, vector unsigned short);
vector bool char vec_srl (vector bool char, vector unsigned char);

vector float vec_sro (vector float, vector signed char);
vector float vec_sro (vector float, vector unsigned char);
vector signed int vec_sro (vector signed int, vector signed char);
vector signed int vec_sro (vector signed int, vector unsigned char);
vector unsigned int vec_sro (vector unsigned int, vector signed char);
vector unsigned int vec_sro (vector unsigned int, vector unsigned char);
vector signed short vec_sro (vector signed short, vector signed char);
vector signed short vec_sro (vector signed short, vector unsigned char);
vector unsigned short vec_sro (vector unsigned short,
                               vector signed char);
vector unsigned short vec_sro (vector unsigned short,
                               vector unsigned char);
vector pixel vec_sro (vector pixel, vector signed char);
vector pixel vec_sro (vector pixel, vector unsigned char);
vector signed char vec_sro (vector signed char, vector signed char);
vector signed char vec_sro (vector signed char, vector unsigned char);
vector unsigned char vec_sro (vector unsigned char, vector signed char);
vector unsigned char vec_sro (vector unsigned char,
                              vector unsigned char);

void vec_st (vector float, int, vector float *);
void vec_st (vector float, int, float *);
void vec_st (vector signed int, int, vector signed int *);
void vec_st (vector signed int, int, int *);
void vec_st (vector unsigned int, int, vector unsigned int *);
void vec_st (vector unsigned int, int, unsigned int *);
void vec_st (vector bool int, int, vector bool int *);
void vec_st (vector bool int, int, unsigned int *);
void vec_st (vector bool int, int, int *);
void vec_st (vector signed short, int, vector signed short *);
void vec_st (vector signed short, int, short *);
void vec_st (vector unsigned short, int, vector unsigned short *);
void vec_st (vector unsigned short, int, unsigned short *);
void vec_st (vector bool short, int, vector bool short *);
void vec_st (vector bool short, int, unsigned short *);
void vec_st (vector pixel, int, vector pixel *);
void vec_st (vector pixel, int, unsigned short *);
void vec_st (vector pixel, int, short *);
void vec_st (vector bool short, int, short *);
void vec_st (vector signed char, int, vector signed char *);
void vec_st (vector signed char, int, signed char *);
void vec_st (vector unsigned char, int, vector unsigned char *);
void vec_st (vector unsigned char, int, unsigned char *);
void vec_st (vector bool char, int, vector bool char *);
void vec_st (vector bool char, int, unsigned char *);
void vec_st (vector bool char, int, signed char *);

void vec_ste (vector signed char, int, signed char *);
void vec_ste (vector unsigned char, int, unsigned char *);
void vec_ste (vector bool char, int, signed char *);
void vec_ste (vector bool char, int, unsigned char *);
void vec_ste (vector signed short, int, short *);
void vec_ste (vector unsigned short, int, unsigned short *);
void vec_ste (vector bool short, int, short *);
void vec_ste (vector bool short, int, unsigned short *);
void vec_ste (vector pixel, int, short *);
void vec_ste (vector pixel, int, unsigned short *);
void vec_ste (vector float, int, float *);
void vec_ste (vector signed int, int, int *);
void vec_ste (vector unsigned int, int, unsigned int *);
void vec_ste (vector bool int, int, int *);
void vec_ste (vector bool int, int, unsigned int *);

void vec_stvewx (vector float, int, float *);
void vec_stvewx (vector signed int, int, int *);
void vec_stvewx (vector unsigned int, int, unsigned int *);
void vec_stvewx (vector bool int, int, int *);
void vec_stvewx (vector bool int, int, unsigned int *);

void vec_stvehx (vector signed short, int, short *);
void vec_stvehx (vector unsigned short, int, unsigned short *);
void vec_stvehx (vector bool short, int, short *);
void vec_stvehx (vector bool short, int, unsigned short *);
void vec_stvehx (vector pixel, int, short *);
void vec_stvehx (vector pixel, int, unsigned short *);

void vec_stvebx (vector signed char, int, signed char *);
void vec_stvebx (vector unsigned char, int, unsigned char *);
void vec_stvebx (vector bool char, int, signed char *);
void vec_stvebx (vector bool char, int, unsigned char *);

void vec_stl (vector float, int, vector float *);
void vec_stl (vector float, int, float *);
void vec_stl (vector signed int, int, vector signed int *);
void vec_stl (vector signed int, int, int *);
void vec_stl (vector unsigned int, int, vector unsigned int *);
void vec_stl (vector unsigned int, int, unsigned int *);
void vec_stl (vector bool int, int, vector bool int *);
void vec_stl (vector bool int, int, unsigned int *);
void vec_stl (vector bool int, int, int *);
void vec_stl (vector signed short, int, vector signed short *);
void vec_stl (vector signed short, int, short *);
void vec_stl (vector unsigned short, int, vector unsigned short *);
void vec_stl (vector unsigned short, int, unsigned short *);
void vec_stl (vector bool short, int, vector bool short *);
void vec_stl (vector bool short, int, unsigned short *);
void vec_stl (vector bool short, int, short *);
void vec_stl (vector pixel, int, vector pixel *);
void vec_stl (vector pixel, int, unsigned short *);
void vec_stl (vector pixel, int, short *);
void vec_stl (vector signed char, int, vector signed char *);
void vec_stl (vector signed char, int, signed char *);
void vec_stl (vector unsigned char, int, vector unsigned char *);
void vec_stl (vector unsigned char, int, unsigned char *);
void vec_stl (vector bool char, int, vector bool char *);
void vec_stl (vector bool char, int, unsigned char *);
void vec_stl (vector bool char, int, signed char *);

vector signed char vec_sub (vector bool char, vector signed char);
vector signed char vec_sub (vector signed char, vector bool char);
vector signed char vec_sub (vector signed char, vector signed char);
vector unsigned char vec_sub (vector bool char, vector unsigned char);
vector unsigned char vec_sub (vector unsigned char, vector bool char);
vector unsigned char vec_sub (vector unsigned char,
                              vector unsigned char);
vector signed short vec_sub (vector bool short, vector signed short);
vector signed short vec_sub (vector signed short, vector bool short);
vector signed short vec_sub (vector signed short, vector signed short);
vector unsigned short vec_sub (vector bool short,
                               vector unsigned short);
vector unsigned short vec_sub (vector unsigned short,
                               vector bool short);
vector unsigned short vec_sub (vector unsigned short,
                               vector unsigned short);
vector signed int vec_sub (vector bool int, vector signed int);
vector signed int vec_sub (vector signed int, vector bool int);
vector signed int vec_sub (vector signed int, vector signed int);
vector unsigned int vec_sub (vector bool int, vector unsigned int);
vector unsigned int vec_sub (vector unsigned int, vector bool int);
vector unsigned int vec_sub (vector unsigned int, vector unsigned int);
vector float vec_sub (vector float, vector float);

vector float vec_vsubfp (vector float, vector float);

vector signed int vec_vsubuwm (vector bool int, vector signed int);
vector signed int vec_vsubuwm (vector signed int, vector bool int);
vector signed int vec_vsubuwm (vector signed int, vector signed int);
vector unsigned int vec_vsubuwm (vector bool int, vector unsigned int);
vector unsigned int vec_vsubuwm (vector unsigned int, vector bool int);
vector unsigned int vec_vsubuwm (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vsubuhm (vector bool short,
                                 vector signed short);
vector signed short vec_vsubuhm (vector signed short,
                                 vector bool short);
vector signed short vec_vsubuhm (vector signed short,
                                 vector signed short);
vector unsigned short vec_vsubuhm (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vsubuhm (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vsubuhm (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vsububm (vector bool char, vector signed char);
vector signed char vec_vsububm (vector signed char, vector bool char);
vector signed char vec_vsububm (vector signed char, vector signed char);
vector unsigned char vec_vsububm (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vsububm (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vsububm (vector unsigned char,
                                  vector unsigned char);

vector unsigned int vec_subc (vector unsigned int, vector unsigned int);

vector unsigned char vec_subs (vector bool char, vector unsigned char);
vector unsigned char vec_subs (vector unsigned char, vector bool char);
vector unsigned char vec_subs (vector unsigned char,
                               vector unsigned char);
vector signed char vec_subs (vector bool char, vector signed char);
vector signed char vec_subs (vector signed char, vector bool char);
vector signed char vec_subs (vector signed char, vector signed char);
vector unsigned short vec_subs (vector bool short,
                                vector unsigned short);
vector unsigned short vec_subs (vector unsigned short,
                                vector bool short);
vector unsigned short vec_subs (vector unsigned short,
                                vector unsigned short);
vector signed short vec_subs (vector bool short, vector signed short);
vector signed short vec_subs (vector signed short, vector bool short);
vector signed short vec_subs (vector signed short, vector signed short);
vector unsigned int vec_subs (vector bool int, vector unsigned int);
vector unsigned int vec_subs (vector unsigned int, vector bool int);
vector unsigned int vec_subs (vector unsigned int, vector unsigned int);
vector signed int vec_subs (vector bool int, vector signed int);
vector signed int vec_subs (vector signed int, vector bool int);
vector signed int vec_subs (vector signed int, vector signed int);

vector signed int vec_vsubsws (vector bool int, vector signed int);
vector signed int vec_vsubsws (vector signed int, vector bool int);
vector signed int vec_vsubsws (vector signed int, vector signed int);

vector unsigned int vec_vsubuws (vector bool int, vector unsigned int);
vector unsigned int vec_vsubuws (vector unsigned int, vector bool int);
vector unsigned int vec_vsubuws (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vsubshs (vector bool short,
                                 vector signed short);
vector signed short vec_vsubshs (vector signed short,
                                 vector bool short);
vector signed short vec_vsubshs (vector signed short,
                                 vector signed short);

vector unsigned short vec_vsubuhs (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vsubuhs (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vsubuhs (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vsubsbs (vector bool char, vector signed char);
vector signed char vec_vsubsbs (vector signed char, vector bool char);
vector signed char vec_vsubsbs (vector signed char, vector signed char);

vector unsigned char vec_vsububs (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vsububs (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vsububs (vector unsigned char,
                                  vector unsigned char);

vector unsigned int vec_sum4s (vector unsigned char,
                               vector unsigned int);
vector signed int vec_sum4s (vector signed char, vector signed int);
vector signed int vec_sum4s (vector signed short, vector signed int);

vector signed int vec_vsum4shs (vector signed short, vector signed int);

vector signed int vec_vsum4sbs (vector signed char, vector signed int);

vector unsigned int vec_vsum4ubs (vector unsigned char,
                                  vector unsigned int);

vector signed int vec_sum2s (vector signed int, vector signed int);

vector signed int vec_sums (vector signed int, vector signed int);

vector float vec_trunc (vector float);

vector signed short vec_unpackh (vector signed char);
vector bool short vec_unpackh (vector bool char);
vector signed int vec_unpackh (vector signed short);
vector bool int vec_unpackh (vector bool short);
vector unsigned int vec_unpackh (vector pixel);

vector bool int vec_vupkhsh (vector bool short);
vector signed int vec_vupkhsh (vector signed short);

vector unsigned int vec_vupkhpx (vector pixel);

vector bool short vec_vupkhsb (vector bool char);
vector signed short vec_vupkhsb (vector signed char);

vector signed short vec_unpackl (vector signed char);
vector bool short vec_unpackl (vector bool char);
vector unsigned int vec_unpackl (vector pixel);
vector signed int vec_unpackl (vector signed short);
vector bool int vec_unpackl (vector bool short);

vector unsigned int vec_vupklpx (vector pixel);

vector bool int vec_vupklsh (vector bool short);
vector signed int vec_vupklsh (vector signed short);

vector bool short vec_vupklsb (vector bool char);
vector signed short vec_vupklsb (vector signed char);

vector float vec_xor (vector float, vector float);
vector float vec_xor (vector float, vector bool int);
vector float vec_xor (vector bool int, vector float);
vector bool int vec_xor (vector bool int, vector bool int);
vector signed int vec_xor (vector bool int, vector signed int);
vector signed int vec_xor (vector signed int, vector bool int);
vector signed int vec_xor (vector signed int, vector signed int);
vector unsigned int vec_xor (vector bool int, vector unsigned int);
vector unsigned int vec_xor (vector unsigned int, vector bool int);
vector unsigned int vec_xor (vector unsigned int, vector unsigned int);
vector bool short vec_xor (vector bool short, vector bool short);
vector signed short vec_xor (vector bool short, vector signed short);
vector signed short vec_xor (vector signed short, vector bool short);
vector signed short vec_xor (vector signed short, vector signed short);
vector unsigned short vec_xor (vector bool short,
                               vector unsigned short);
vector unsigned short vec_xor (vector unsigned short,
                               vector bool short);
vector unsigned short vec_xor (vector unsigned short,
                               vector unsigned short);
vector signed char vec_xor (vector bool char, vector signed char);
vector bool char vec_xor (vector bool char, vector bool char);
vector signed char vec_xor (vector signed char, vector bool char);
vector signed char vec_xor (vector signed char, vector signed char);
vector unsigned char vec_xor (vector bool char, vector unsigned char);
vector unsigned char vec_xor (vector unsigned char, vector bool char);
vector unsigned char vec_xor (vector unsigned char,
                              vector unsigned char);

int vec_all_eq (vector signed char, vector bool char);
int vec_all_eq (vector signed char, vector signed char);
int vec_all_eq (vector unsigned char, vector bool char);
int vec_all_eq (vector unsigned char, vector unsigned char);
int vec_all_eq (vector bool char, vector bool char);
int vec_all_eq (vector bool char, vector unsigned char);
int vec_all_eq (vector bool char, vector signed char);
int vec_all_eq (vector signed short, vector bool short);
int vec_all_eq (vector signed short, vector signed short);
int vec_all_eq (vector unsigned short, vector bool short);
int vec_all_eq (vector unsigned short, vector unsigned short);
int vec_all_eq (vector bool short, vector bool short);
int vec_all_eq (vector bool short, vector unsigned short);
int vec_all_eq (vector bool short, vector signed short);
int vec_all_eq (vector pixel, vector pixel);
int vec_all_eq (vector signed int, vector bool int);
int vec_all_eq (vector signed int, vector signed int);
int vec_all_eq (vector unsigned int, vector bool int);
int vec_all_eq (vector unsigned int, vector unsigned int);
int vec_all_eq (vector bool int, vector bool int);
int vec_all_eq (vector bool int, vector unsigned int);
int vec_all_eq (vector bool int, vector signed int);
int vec_all_eq (vector float, vector float);

int vec_all_ge (vector bool char, vector unsigned char);
int vec_all_ge (vector unsigned char, vector bool char);
int vec_all_ge (vector unsigned char, vector unsigned char);
int vec_all_ge (vector bool char, vector signed char);
int vec_all_ge (vector signed char, vector bool char);
int vec_all_ge (vector signed char, vector signed char);
int vec_all_ge (vector bool short, vector unsigned short);
int vec_all_ge (vector unsigned short, vector bool short);
int vec_all_ge (vector unsigned short, vector unsigned short);
int vec_all_ge (vector signed short, vector signed short);
int vec_all_ge (vector bool short, vector signed short);
int vec_all_ge (vector signed short, vector bool short);
int vec_all_ge (vector bool int, vector unsigned int);
int vec_all_ge (vector unsigned int, vector bool int);
int vec_all_ge (vector unsigned int, vector unsigned int);
int vec_all_ge (vector bool int, vector signed int);
int vec_all_ge (vector signed int, vector bool int);
int vec_all_ge (vector signed int, vector signed int);
int vec_all_ge (vector float, vector float);

int vec_all_gt (vector bool char, vector unsigned char);
int vec_all_gt (vector unsigned char, vector bool char);
int vec_all_gt (vector unsigned char, vector unsigned char);
int vec_all_gt (vector bool char, vector signed char);
int vec_all_gt (vector signed char, vector bool char);
int vec_all_gt (vector signed char, vector signed char);
int vec_all_gt (vector bool short, vector unsigned short);
int vec_all_gt (vector unsigned short, vector bool short);
int vec_all_gt (vector unsigned short, vector unsigned short);
int vec_all_gt (vector bool short, vector signed short);
int vec_all_gt (vector signed short, vector bool short);
int vec_all_gt (vector signed short, vector signed short);
int vec_all_gt (vector bool int, vector unsigned int);
int vec_all_gt (vector unsigned int, vector bool int);
int vec_all_gt (vector unsigned int, vector unsigned int);
int vec_all_gt (vector bool int, vector signed int);
int vec_all_gt (vector signed int, vector bool int);
int vec_all_gt (vector signed int, vector signed int);
int vec_all_gt (vector float, vector float);

int vec_all_in (vector float, vector float);

int vec_all_le (vector bool char, vector unsigned char);
int vec_all_le (vector unsigned char, vector bool char);
int vec_all_le (vector unsigned char, vector unsigned char);
int vec_all_le (vector bool char, vector signed char);
int vec_all_le (vector signed char, vector bool char);
int vec_all_le (vector signed char, vector signed char);
int vec_all_le (vector bool short, vector unsigned short);
int vec_all_le (vector unsigned short, vector bool short);
int vec_all_le (vector unsigned short, vector unsigned short);
int vec_all_le (vector bool short, vector signed short);
int vec_all_le (vector signed short, vector bool short);
int vec_all_le (vector signed short, vector signed short);
int vec_all_le (vector bool int, vector unsigned int);
int vec_all_le (vector unsigned int, vector bool int);
int vec_all_le (vector unsigned int, vector unsigned int);
int vec_all_le (vector bool int, vector signed int);
int vec_all_le (vector signed int, vector bool int);
int vec_all_le (vector signed int, vector signed int);
int vec_all_le (vector float, vector float);

int vec_all_lt (vector bool char, vector unsigned char);
int vec_all_lt (vector unsigned char, vector bool char);
int vec_all_lt (vector unsigned char, vector unsigned char);
int vec_all_lt (vector bool char, vector signed char);
int vec_all_lt (vector signed char, vector bool char);
int vec_all_lt (vector signed char, vector signed char);
int vec_all_lt (vector bool short, vector unsigned short);
int vec_all_lt (vector unsigned short, vector bool short);
int vec_all_lt (vector unsigned short, vector unsigned short);
int vec_all_lt (vector bool short, vector signed short);
int vec_all_lt (vector signed short, vector bool short);
int vec_all_lt (vector signed short, vector signed short);
int vec_all_lt (vector bool int, vector unsigned int);
int vec_all_lt (vector unsigned int, vector bool int);
int vec_all_lt (vector unsigned int, vector unsigned int);
int vec_all_lt (vector bool int, vector signed int);
int vec_all_lt (vector signed int, vector bool int);
int vec_all_lt (vector signed int, vector signed int);
int vec_all_lt (vector float, vector float);

int vec_all_nan (vector float);

int vec_all_ne (vector signed char, vector bool char);
int vec_all_ne (vector signed char, vector signed char);
int vec_all_ne (vector unsigned char, vector bool char);
int vec_all_ne (vector unsigned char, vector unsigned char);
int vec_all_ne (vector bool char, vector bool char);
int vec_all_ne (vector bool char, vector unsigned char);
int vec_all_ne (vector bool char, vector signed char);
int vec_all_ne (vector signed short, vector bool short);
int vec_all_ne (vector signed short, vector signed short);
int vec_all_ne (vector unsigned short, vector bool short);
int vec_all_ne (vector unsigned short, vector unsigned short);
int vec_all_ne (vector bool short, vector bool short);
int vec_all_ne (vector bool short, vector unsigned short);
int vec_all_ne (vector bool short, vector signed short);
int vec_all_ne (vector pixel, vector pixel);
int vec_all_ne (vector signed int, vector bool int);
int vec_all_ne (vector signed int, vector signed int);
int vec_all_ne (vector unsigned int, vector bool int);
int vec_all_ne (vector unsigned int, vector unsigned int);
int vec_all_ne (vector bool int, vector bool int);
int vec_all_ne (vector bool int, vector unsigned int);
int vec_all_ne (vector bool int, vector signed int);
int vec_all_ne (vector float, vector float);

int vec_all_nge (vector float, vector float);

int vec_all_ngt (vector float, vector float);

int vec_all_nle (vector float, vector float);

int vec_all_nlt (vector float, vector float);

int vec_all_numeric (vector float);

int vec_any_eq (vector signed char, vector bool char);
int vec_any_eq (vector signed char, vector signed char);
int vec_any_eq (vector unsigned char, vector bool char);
int vec_any_eq (vector unsigned char, vector unsigned char);
int vec_any_eq (vector bool char, vector bool char);
int vec_any_eq (vector bool char, vector unsigned char);
int vec_any_eq (vector bool char, vector signed char);
int vec_any_eq (vector signed short, vector bool short);
int vec_any_eq (vector signed short, vector signed short);
int vec_any_eq (vector unsigned short, vector bool short);
int vec_any_eq (vector unsigned short, vector unsigned short);
int vec_any_eq (vector bool short, vector bool short);
int vec_any_eq (vector bool short, vector unsigned short);
int vec_any_eq (vector bool short, vector signed short);
int vec_any_eq (vector pixel, vector pixel);
int vec_any_eq (vector signed int, vector bool int);
int vec_any_eq (vector signed int, vector signed int);
int vec_any_eq (vector unsigned int, vector bool int);
int vec_any_eq (vector unsigned int, vector unsigned int);
int vec_any_eq (vector bool int, vector bool int);
int vec_any_eq (vector bool int, vector unsigned int);
int vec_any_eq (vector bool int, vector signed int);
int vec_any_eq (vector float, vector float);

int vec_any_ge (vector signed char, vector bool char);
int vec_any_ge (vector unsigned char, vector bool char);
int vec_any_ge (vector unsigned char, vector unsigned char);
int vec_any_ge (vector signed char, vector signed char);
int vec_any_ge (vector bool char, vector unsigned char);
int vec_any_ge (vector bool char, vector signed char);
int vec_any_ge (vector unsigned short, vector bool short);
int vec_any_ge (vector unsigned short, vector unsigned short);
int vec_any_ge (vector signed short, vector signed short);
int vec_any_ge (vector signed short, vector bool short);
int vec_any_ge (vector bool short, vector unsigned short);
int vec_any_ge (vector bool short, vector signed short);
int vec_any_ge (vector signed int, vector bool int);
int vec_any_ge (vector unsigned int, vector bool int);
int vec_any_ge (vector unsigned int, vector unsigned int);
int vec_any_ge (vector signed int, vector signed int);
int vec_any_ge (vector bool int, vector unsigned int);
int vec_any_ge (vector bool int, vector signed int);
int vec_any_ge (vector float, vector float);

int vec_any_gt (vector bool char, vector unsigned char);
int vec_any_gt (vector unsigned char, vector bool char);
int vec_any_gt (vector unsigned char, vector unsigned char);
int vec_any_gt (vector bool char, vector signed char);
int vec_any_gt (vector signed char, vector bool char);
int vec_any_gt (vector signed char, vector signed char);
int vec_any_gt (vector bool short, vector unsigned short);
int vec_any_gt (vector unsigned short, vector bool short);
int vec_any_gt (vector unsigned short, vector unsigned short);
int vec_any_gt (vector bool short, vector signed short);
int vec_any_gt (vector signed short, vector bool short);
int vec_any_gt (vector signed short, vector signed short);
int vec_any_gt (vector bool int, vector unsigned int);
int vec_any_gt (vector unsigned int, vector bool int);
int vec_any_gt (vector unsigned int, vector unsigned int);
int vec_any_gt (vector bool int, vector signed int);
int vec_any_gt (vector signed int, vector bool int);
int vec_any_gt (vector signed int, vector signed int);
int vec_any_gt (vector float, vector float);

int vec_any_le (vector bool char, vector unsigned char);
int vec_any_le (vector unsigned char, vector bool char);
int vec_any_le (vector unsigned char, vector unsigned char);
int vec_any_le (vector bool char, vector signed char);
int vec_any_le (vector signed char, vector bool char);
int vec_any_le (vector signed char, vector signed char);
int vec_any_le (vector bool short, vector unsigned short);
int vec_any_le (vector unsigned short, vector bool short);
int vec_any_le (vector unsigned short, vector unsigned short);
int vec_any_le (vector bool short, vector signed short);
int vec_any_le (vector signed short, vector bool short);
int vec_any_le (vector signed short, vector signed short);
int vec_any_le (vector bool int, vector unsigned int);
int vec_any_le (vector unsigned int, vector bool int);
int vec_any_le (vector unsigned int, vector unsigned int);
int vec_any_le (vector bool int, vector signed int);
int vec_any_le (vector signed int, vector bool int);
int vec_any_le (vector signed int, vector signed int);
int vec_any_le (vector float, vector float);

int vec_any_lt (vector bool char, vector unsigned char);
int vec_any_lt (vector unsigned char, vector bool char);
int vec_any_lt (vector unsigned char, vector unsigned char);
int vec_any_lt (vector bool char, vector signed char);
int vec_any_lt (vector signed char, vector bool char);
int vec_any_lt (vector signed char, vector signed char);
int vec_any_lt (vector bool short, vector unsigned short);
int vec_any_lt (vector unsigned short, vector bool short);
int vec_any_lt (vector unsigned short, vector unsigned short);
int vec_any_lt (vector bool short, vector signed short);
int vec_any_lt (vector signed short, vector bool short);
int vec_any_lt (vector signed short, vector signed short);
int vec_any_lt (vector bool int, vector unsigned int);
int vec_any_lt (vector unsigned int, vector bool int);
int vec_any_lt (vector unsigned int, vector unsigned int);
int vec_any_lt (vector bool int, vector signed int);
int vec_any_lt (vector signed int, vector bool int);
int vec_any_lt (vector signed int, vector signed int);
int vec_any_lt (vector float, vector float);

int vec_any_nan (vector float);

int vec_any_ne (vector signed char, vector bool char);
int vec_any_ne (vector signed char, vector signed char);
int vec_any_ne (vector unsigned char, vector bool char);
int vec_any_ne (vector unsigned char, vector unsigned char);
int vec_any_ne (vector bool char, vector bool char);
int vec_any_ne (vector bool char, vector unsigned char);
int vec_any_ne (vector bool char, vector signed char);
int vec_any_ne (vector signed short, vector bool short);
int vec_any_ne (vector signed short, vector signed short);
int vec_any_ne (vector unsigned short, vector bool short);
int vec_any_ne (vector unsigned short, vector unsigned short);
int vec_any_ne (vector bool short, vector bool short);
int vec_any_ne (vector bool short, vector unsigned short);
int vec_any_ne (vector bool short, vector signed short);
int vec_any_ne (vector pixel, vector pixel);
int vec_any_ne (vector signed int, vector bool int);
int vec_any_ne (vector signed int, vector signed int);
int vec_any_ne (vector unsigned int, vector bool int);
int vec_any_ne (vector unsigned int, vector unsigned int);
int vec_any_ne (vector bool int, vector bool int);
int vec_any_ne (vector bool int, vector unsigned int);
int vec_any_ne (vector bool int, vector signed int);
int vec_any_ne (vector float, vector float);

int vec_any_nge (vector float, vector float);

int vec_any_ngt (vector float, vector float);

int vec_any_nle (vector float, vector float);

int vec_any_nlt (vector float, vector float);

int vec_any_numeric (vector float);

int vec_any_out (vector float, vector float);
@end smallexample

If the vector/scalar (VSX) instruction set is available, the following
additional functions are available:

@smallexample
vector double vec_abs (vector double);
vector double vec_add (vector double, vector double);
vector double vec_and (vector double, vector double);
vector double vec_and (vector double, vector bool long);
vector double vec_and (vector bool long, vector double);
vector long vec_and (vector long, vector long);
vector long vec_and (vector long, vector bool long);
vector long vec_and (vector bool long, vector long);
vector unsigned long vec_and (vector unsigned long, vector unsigned long);
vector unsigned long vec_and (vector unsigned long, vector bool long);
vector unsigned long vec_and (vector bool long, vector unsigned long);
vector double vec_andc (vector double, vector double);
vector double vec_andc (vector double, vector bool long);
vector double vec_andc (vector bool long, vector double);
vector long vec_andc (vector long, vector long);
vector long vec_andc (vector long, vector bool long);
vector long vec_andc (vector bool long, vector long);
vector unsigned long vec_andc (vector unsigned long, vector unsigned long);
vector unsigned long vec_andc (vector unsigned long, vector bool long);
vector unsigned long vec_andc (vector bool long, vector unsigned long);
vector double vec_ceil (vector double);
vector bool long vec_cmpeq (vector double, vector double);
vector bool long vec_cmpge (vector double, vector double);
vector bool long vec_cmpgt (vector double, vector double);
vector bool long vec_cmple (vector double, vector double);
vector bool long vec_cmplt (vector double, vector double);
vector double vec_cpsgn (vector double, vector double);
vector float vec_div (vector float, vector float);
vector double vec_div (vector double, vector double);
vector long vec_div (vector long, vector long);
vector unsigned long vec_div (vector unsigned long, vector unsigned long);
vector double vec_floor (vector double);
vector double vec_ld (int, const vector double *);
vector double vec_ld (int, const double *);
vector double vec_ldl (int, const vector double *);
vector double vec_ldl (int, const double *);
vector unsigned char vec_lvsl (int, const volatile double *);
vector unsigned char vec_lvsr (int, const volatile double *);
vector double vec_madd (vector double, vector double, vector double);
vector double vec_max (vector double, vector double);
vector signed long vec_mergeh (vector signed long, vector signed long);
vector signed long vec_mergeh (vector signed long, vector bool long);
vector signed long vec_mergeh (vector bool long, vector signed long);
vector unsigned long vec_mergeh (vector unsigned long, vector unsigned long);
vector unsigned long vec_mergeh (vector unsigned long, vector bool long);
vector unsigned long vec_mergeh (vector bool long, vector unsigned long);
vector signed long vec_mergel (vector signed long, vector signed long);
vector signed long vec_mergel (vector signed long, vector bool long);
vector signed long vec_mergel (vector bool long, vector signed long);
vector unsigned long vec_mergel (vector unsigned long, vector unsigned long);
vector unsigned long vec_mergel (vector unsigned long, vector bool long);
vector unsigned long vec_mergel (vector bool long, vector unsigned long);
vector double vec_min (vector double, vector double);
vector float vec_msub (vector float, vector float, vector float);
vector double vec_msub (vector double, vector double, vector double);
vector float vec_mul (vector float, vector float);
vector double vec_mul (vector double, vector double);
vector long vec_mul (vector long, vector long);
vector unsigned long vec_mul (vector unsigned long, vector unsigned long);
vector float vec_nearbyint (vector float);
vector double vec_nearbyint (vector double);
vector float vec_nmadd (vector float, vector float, vector float);
vector double vec_nmadd (vector double, vector double, vector double);
vector double vec_nmsub (vector double, vector double, vector double);
vector double vec_nor (vector double, vector double);
vector long vec_nor (vector long, vector long);
vector long vec_nor (vector long, vector bool long);
vector long vec_nor (vector bool long, vector long);
vector unsigned long vec_nor (vector unsigned long, vector unsigned long);
vector unsigned long vec_nor (vector unsigned long, vector bool long);
vector unsigned long vec_nor (vector bool long, vector unsigned long);
vector double vec_or (vector double, vector double);
vector double vec_or (vector double, vector bool long);
vector double vec_or (vector bool long, vector double);
vector long vec_or (vector long, vector long);
vector long vec_or (vector long, vector bool long);
vector long vec_or (vector bool long, vector long);
vector unsigned long vec_or (vector unsigned long, vector unsigned long);
vector unsigned long vec_or (vector unsigned long, vector bool long);
vector unsigned long vec_or (vector bool long, vector unsigned long);
vector double vec_perm (vector double, vector double, vector unsigned char);
vector long vec_perm (vector long, vector long, vector unsigned char);
vector unsigned long vec_perm (vector unsigned long, vector unsigned long,
                               vector unsigned char);
vector double vec_rint (vector double);
vector double vec_recip (vector double, vector double);
vector double vec_rsqrt (vector double);
vector double vec_rsqrte (vector double);
vector double vec_sel (vector double, vector double, vector bool long);
vector double vec_sel (vector double, vector double, vector unsigned long);
vector long vec_sel (vector long, vector long, vector long);
vector long vec_sel (vector long, vector long, vector unsigned long);
vector long vec_sel (vector long, vector long, vector bool long);
vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                              vector long);
vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                              vector unsigned long);
vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                              vector bool long);
vector double vec_splats (double);
vector signed long vec_splats (signed long);
vector unsigned long vec_splats (unsigned long);
vector float vec_sqrt (vector float);
vector double vec_sqrt (vector double);
void vec_st (vector double, int, vector double *);
void vec_st (vector double, int, double *);
vector double vec_sub (vector double, vector double);
vector double vec_trunc (vector double);
vector double vec_xl (int, vector double *);
vector double vec_xl (int, double *);
vector long long vec_xl (int, vector long long *);
vector long long vec_xl (int, long long *);
vector unsigned long long vec_xl (int, vector unsigned long long *);
vector unsigned long long vec_xl (int, unsigned long long *);
vector float vec_xl (int, vector float *);
vector float vec_xl (int, float *);
vector int vec_xl (int, vector int *);
vector int vec_xl (int, int *);
vector unsigned int vec_xl (int, vector unsigned int *);
vector unsigned int vec_xl (int, unsigned int *);
vector double vec_xor (vector double, vector double);
vector double vec_xor (vector double, vector bool long);
vector double vec_xor (vector bool long, vector double);
vector long vec_xor (vector long, vector long);
vector long vec_xor (vector long, vector bool long);
vector long vec_xor (vector bool long, vector long);
vector unsigned long vec_xor (vector unsigned long, vector unsigned long);
vector unsigned long vec_xor (vector unsigned long, vector bool long);
vector unsigned long vec_xor (vector bool long, vector unsigned long);
void vec_xst (vector double, int, vector double *);
void vec_xst (vector double, int, double *);
void vec_xst (vector long long, int, vector long long *);
void vec_xst (vector long long, int, long long *);
void vec_xst (vector unsigned long long, int, vector unsigned long long *);
void vec_xst (vector unsigned long long, int, unsigned long long *);
void vec_xst (vector float, int, vector float *);
void vec_xst (vector float, int, float *);
void vec_xst (vector int, int, vector int *);
void vec_xst (vector int, int, int *);
void vec_xst (vector unsigned int, int, vector unsigned int *);
void vec_xst (vector unsigned int, int, unsigned int *);
int vec_all_eq (vector double, vector double);
int vec_all_ge (vector double, vector double);
int vec_all_gt (vector double, vector double);
int vec_all_le (vector double, vector double);
int vec_all_lt (vector double, vector double);
int vec_all_nan (vector double);
int vec_all_ne (vector double, vector double);
int vec_all_nge (vector double, vector double);
int vec_all_ngt (vector double, vector double);
int vec_all_nle (vector double, vector double);
int vec_all_nlt (vector double, vector double);
int vec_all_numeric (vector double);
int vec_any_eq (vector double, vector double);
int vec_any_ge (vector double, vector double);
int vec_any_gt (vector double, vector double);
int vec_any_le (vector double, vector double);
int vec_any_lt (vector double, vector double);
int vec_any_nan (vector double);
int vec_any_ne (vector double, vector double);
int vec_any_nge (vector double, vector double);
int vec_any_ngt (vector double, vector double);
int vec_any_nle (vector double, vector double);
int vec_any_nlt (vector double, vector double);
int vec_any_numeric (vector double);

vector double vec_vsx_ld (int, const vector double *);
vector double vec_vsx_ld (int, const double *);
vector float vec_vsx_ld (int, const vector float *);
vector float vec_vsx_ld (int, const float *);
vector bool int vec_vsx_ld (int, const vector bool int *);
vector signed int vec_vsx_ld (int, const vector signed int *);
vector signed int vec_vsx_ld (int, const int *);
vector signed int vec_vsx_ld (int, const long *);
vector unsigned int vec_vsx_ld (int, const vector unsigned int *);
vector unsigned int vec_vsx_ld (int, const unsigned int *);
vector unsigned int vec_vsx_ld (int, const unsigned long *);
vector bool short vec_vsx_ld (int, const vector bool short *);
vector pixel vec_vsx_ld (int, const vector pixel *);
vector signed short vec_vsx_ld (int, const vector signed short *);
vector signed short vec_vsx_ld (int, const short *);
vector unsigned short vec_vsx_ld (int, const vector unsigned short *);
vector unsigned short vec_vsx_ld (int, const unsigned short *);
vector bool char vec_vsx_ld (int, const vector bool char *);
vector signed char vec_vsx_ld (int, const vector signed char *);
vector signed char vec_vsx_ld (int, const signed char *);
vector unsigned char vec_vsx_ld (int, const vector unsigned char *);
vector unsigned char vec_vsx_ld (int, const unsigned char *);

void vec_vsx_st (vector double, int, vector double *);
void vec_vsx_st (vector double, int, double *);
void vec_vsx_st (vector float, int, vector float *);
void vec_vsx_st (vector float, int, float *);
void vec_vsx_st (vector signed int, int, vector signed int *);
void vec_vsx_st (vector signed int, int, int *);
void vec_vsx_st (vector unsigned int, int, vector unsigned int *);
void vec_vsx_st (vector unsigned int, int, unsigned int *);
void vec_vsx_st (vector bool int, int, vector bool int *);
void vec_vsx_st (vector bool int, int, unsigned int *);
void vec_vsx_st (vector bool int, int, int *);
void vec_vsx_st (vector signed short, int, vector signed short *);
void vec_vsx_st (vector signed short, int, short *);
void vec_vsx_st (vector unsigned short, int, vector unsigned short *);
void vec_vsx_st (vector unsigned short, int, unsigned short *);
void vec_vsx_st (vector bool short, int, vector bool short *);
void vec_vsx_st (vector bool short, int, unsigned short *);
void vec_vsx_st (vector pixel, int, vector pixel *);
void vec_vsx_st (vector pixel, int, unsigned short *);
void vec_vsx_st (vector pixel, int, short *);
void vec_vsx_st (vector bool short, int, short *);
void vec_vsx_st (vector signed char, int, vector signed char *);
void vec_vsx_st (vector signed char, int, signed char *);
void vec_vsx_st (vector unsigned char, int, vector unsigned char *);
void vec_vsx_st (vector unsigned char, int, unsigned char *);
void vec_vsx_st (vector bool char, int, vector bool char *);
void vec_vsx_st (vector bool char, int, unsigned char *);
void vec_vsx_st (vector bool char, int, signed char *);

vector double vec_xxpermdi (vector double, vector double, const int);
vector float vec_xxpermdi (vector float, vector float, const int);
vector long long vec_xxpermdi (vector long long, vector long long, const int);
vector unsigned long long vec_xxpermdi (vector unsigned long long,
                                        vector unsigned long long, const int);
vector int vec_xxpermdi (vector int, vector int, const int);
vector unsigned int vec_xxpermdi (vector unsigned int,
                                  vector unsigned int, const int);
vector short vec_xxpermdi (vector short, vector short, const int);
vector unsigned short vec_xxpermdi (vector unsigned short,
                                    vector unsigned short, const int);
vector signed char vec_xxpermdi (vector signed char, vector signed char,
                                 const int);
vector unsigned char vec_xxpermdi (vector unsigned char,
                                   vector unsigned char, const int);

vector double vec_xxsldi (vector double, vector double, int);
vector float vec_xxsldi (vector float, vector float, int);
vector long long vec_xxsldi (vector long long, vector long long, int);
vector unsigned long long vec_xxsldi (vector unsigned long long,
                                      vector unsigned long long, int);
vector int vec_xxsldi (vector int, vector int, int);
vector unsigned int vec_xxsldi (vector unsigned int, vector unsigned int, int);
vector short vec_xxsldi (vector short, vector short, int);
vector unsigned short vec_xxsldi (vector unsigned short,
                                  vector unsigned short, int);
vector signed char vec_xxsldi (vector signed char, vector signed char, int);
vector unsigned char vec_xxsldi (vector unsigned char,
                                 vector unsigned char, int);
@end smallexample

Note that the @samp{vec_ld} and @samp{vec_st} built-in functions always
generate the AltiVec @samp{LVX} and @samp{STVX} instructions even
if the VSX instruction set is available.  The @samp{vec_vsx_ld} and
@samp{vec_vsx_st} built-in functions always generate the VSX @samp{LXVD2X},
@samp{LXVW4X}, @samp{STXVD2X}, and @samp{STXVW4X} instructions.

If the ISA 2.07 additions to the vector/scalar (power8-vector)
instruction set are available, the following additional functions are
available for both 32-bit and 64-bit targets.  For 64-bit targets, you
can use @var{vector long} instead of @var{vector long long},
@var{vector bool long} instead of @var{vector bool long long}, and
@var{vector unsigned long} instead of @var{vector unsigned long long}.

@smallexample
vector long long vec_abs (vector long long);

vector long long vec_add (vector long long, vector long long);
vector unsigned long long vec_add (vector unsigned long long,
                                   vector unsigned long long);

int vec_all_eq (vector long long, vector long long);
int vec_all_eq (vector unsigned long long, vector unsigned long long);
int vec_all_ge (vector long long, vector long long);
int vec_all_ge (vector unsigned long long, vector unsigned long long);
int vec_all_gt (vector long long, vector long long);
int vec_all_gt (vector unsigned long long, vector unsigned long long);
int vec_all_le (vector long long, vector long long);
int vec_all_le (vector unsigned long long, vector unsigned long long);
int vec_all_lt (vector long long, vector long long);
int vec_all_lt (vector unsigned long long, vector unsigned long long);
int vec_all_ne (vector long long, vector long long);
int vec_all_ne (vector unsigned long long, vector unsigned long long);

int vec_any_eq (vector long long, vector long long);
int vec_any_eq (vector unsigned long long, vector unsigned long long);
int vec_any_ge (vector long long, vector long long);
int vec_any_ge (vector unsigned long long, vector unsigned long long);
int vec_any_gt (vector long long, vector long long);
int vec_any_gt (vector unsigned long long, vector unsigned long long);
int vec_any_le (vector long long, vector long long);
int vec_any_le (vector unsigned long long, vector unsigned long long);
int vec_any_lt (vector long long, vector long long);
int vec_any_lt (vector unsigned long long, vector unsigned long long);
int vec_any_ne (vector long long, vector long long);
int vec_any_ne (vector unsigned long long, vector unsigned long long);

vector bool long long vec_cmpeq (vector bool long long, vector bool long long);

vector long long vec_eqv (vector long long, vector long long);
vector long long vec_eqv (vector bool long long, vector long long);
vector long long vec_eqv (vector long long, vector bool long long);
vector unsigned long long vec_eqv (vector unsigned long long,
                                   vector unsigned long long);
vector unsigned long long vec_eqv (vector bool long long,
                                   vector unsigned long long);
vector unsigned long long vec_eqv (vector unsigned long long,
                                   vector bool long long);
vector int vec_eqv (vector int, vector int);
vector int vec_eqv (vector bool int, vector int);
vector int vec_eqv (vector int, vector bool int);
vector unsigned int vec_eqv (vector unsigned int, vector unsigned int);
vector unsigned int vec_eqv (vector bool unsigned int,
                             vector unsigned int);
vector unsigned int vec_eqv (vector unsigned int,
                             vector bool unsigned int);
vector short vec_eqv (vector short, vector short);
vector short vec_eqv (vector bool short, vector short);
vector short vec_eqv (vector short, vector bool short);
vector unsigned short vec_eqv (vector unsigned short, vector unsigned short);
vector unsigned short vec_eqv (vector bool unsigned short,
                               vector unsigned short);
vector unsigned short vec_eqv (vector unsigned short,
                               vector bool unsigned short);
vector signed char vec_eqv (vector signed char, vector signed char);
vector signed char vec_eqv (vector bool signed char, vector signed char);
vector signed char vec_eqv (vector signed char, vector bool signed char);
vector unsigned char vec_eqv (vector unsigned char, vector unsigned char);
vector unsigned char vec_eqv (vector bool unsigned char, vector unsigned char);
vector unsigned char vec_eqv (vector unsigned char, vector bool unsigned char);

vector long long vec_max (vector long long, vector long long);
vector unsigned long long vec_max (vector unsigned long long,
                                   vector unsigned long long);

vector signed int vec_mergee (vector signed int, vector signed int);
vector unsigned int vec_mergee (vector unsigned int, vector unsigned int);
vector bool int vec_mergee (vector bool int, vector bool int);

vector signed int vec_mergeo (vector signed int, vector signed int);
vector unsigned int vec_mergeo (vector unsigned int, vector unsigned int);
vector bool int vec_mergeo (vector bool int, vector bool int);

vector long long vec_min (vector long long, vector long long);
vector unsigned long long vec_min (vector unsigned long long,
                                   vector unsigned long long);

vector signed long long vec_nabs (vector signed long long);

vector long long vec_nand (vector long long, vector long long);
vector long long vec_nand (vector bool long long, vector long long);
vector long long vec_nand (vector long long, vector bool long long);
vector unsigned long long vec_nand (vector unsigned long long,
                                    vector unsigned long long);
vector unsigned long long vec_nand (vector bool long long,
                                   vector unsigned long long);
vector unsigned long long vec_nand (vector unsigned long long,
                                    vector bool long long);
vector int vec_nand (vector int, vector int);
vector int vec_nand (vector bool int, vector int);
vector int vec_nand (vector int, vector bool int);
vector unsigned int vec_nand (vector unsigned int, vector unsigned int);
vector unsigned int vec_nand (vector bool unsigned int,
                              vector unsigned int);
vector unsigned int vec_nand (vector unsigned int,
                              vector bool unsigned int);
vector short vec_nand (vector short, vector short);
vector short vec_nand (vector bool short, vector short);
vector short vec_nand (vector short, vector bool short);
vector unsigned short vec_nand (vector unsigned short, vector unsigned short);
vector unsigned short vec_nand (vector bool unsigned short,
                                vector unsigned short);
vector unsigned short vec_nand (vector unsigned short,
                                vector bool unsigned short);
vector signed char vec_nand (vector signed char, vector signed char);
vector signed char vec_nand (vector bool signed char, vector signed char);
vector signed char vec_nand (vector signed char, vector bool signed char);
vector unsigned char vec_nand (vector unsigned char, vector unsigned char);
vector unsigned char vec_nand (vector bool unsigned char, vector unsigned char);
vector unsigned char vec_nand (vector unsigned char, vector bool unsigned char);

vector long long vec_orc (vector long long, vector long long);
vector long long vec_orc (vector bool long long, vector long long);
vector long long vec_orc (vector long long, vector bool long long);
vector unsigned long long vec_orc (vector unsigned long long,
                                   vector unsigned long long);
vector unsigned long long vec_orc (vector bool long long,
                                   vector unsigned long long);
vector unsigned long long vec_orc (vector unsigned long long,
                                   vector bool long long);
vector int vec_orc (vector int, vector int);
vector int vec_orc (vector bool int, vector int);
vector int vec_orc (vector int, vector bool int);
vector unsigned int vec_orc (vector unsigned int, vector unsigned int);
vector unsigned int vec_orc (vector bool unsigned int,
                             vector unsigned int);
vector unsigned int vec_orc (vector unsigned int,
                             vector bool unsigned int);
vector short vec_orc (vector short, vector short);
vector short vec_orc (vector bool short, vector short);
vector short vec_orc (vector short, vector bool short);
vector unsigned short vec_orc (vector unsigned short, vector unsigned short);
vector unsigned short vec_orc (vector bool unsigned short,
                               vector unsigned short);
vector unsigned short vec_orc (vector unsigned short,
                               vector bool unsigned short);
vector signed char vec_orc (vector signed char, vector signed char);
vector signed char vec_orc (vector bool signed char, vector signed char);
vector signed char vec_orc (vector signed char, vector bool signed char);
vector unsigned char vec_orc (vector unsigned char, vector unsigned char);
vector unsigned char vec_orc (vector bool unsigned char, vector unsigned char);
vector unsigned char vec_orc (vector unsigned char, vector bool unsigned char);

vector int vec_pack (vector long long, vector long long);
vector unsigned int vec_pack (vector unsigned long long,
                              vector unsigned long long);
vector bool int vec_pack (vector bool long long, vector bool long long);
vector float vec_pack (vector double, vector double);

vector int vec_packs (vector long long, vector long long);
vector unsigned int vec_packs (vector unsigned long long,
                               vector unsigned long long);

vector unsigned int vec_packsu (vector long long, vector long long);
vector unsigned int vec_packsu (vector unsigned long long,
                                vector unsigned long long);

vector long long vec_rl (vector long long,
                         vector unsigned long long);
vector long long vec_rl (vector unsigned long long,
                         vector unsigned long long);

vector long long vec_sl (vector long long, vector unsigned long long);
vector long long vec_sl (vector unsigned long long,
                         vector unsigned long long);

vector long long vec_sr (vector long long, vector unsigned long long);
vector unsigned long long char vec_sr (vector unsigned long long,
                                       vector unsigned long long);

vector long long vec_sra (vector long long, vector unsigned long long);
vector unsigned long long vec_sra (vector unsigned long long,
                                   vector unsigned long long);

vector long long vec_sub (vector long long, vector long long);
vector unsigned long long vec_sub (vector unsigned long long,
                                   vector unsigned long long);

vector long long vec_unpackh (vector int);
vector unsigned long long vec_unpackh (vector unsigned int);

vector long long vec_unpackl (vector int);
vector unsigned long long vec_unpackl (vector unsigned int);

vector long long vec_vaddudm (vector long long, vector long long);
vector long long vec_vaddudm (vector bool long long, vector long long);
vector long long vec_vaddudm (vector long long, vector bool long long);
vector unsigned long long vec_vaddudm (vector unsigned long long,
                                       vector unsigned long long);
vector unsigned long long vec_vaddudm (vector bool unsigned long long,
                                       vector unsigned long long);
vector unsigned long long vec_vaddudm (vector unsigned long long,
                                       vector bool unsigned long long);

vector long long vec_vbpermq (vector signed char, vector signed char);
vector long long vec_vbpermq (vector unsigned char, vector unsigned char);

vector unsigned char vec_bperm (vector unsigned char, vector unsigned char);
vector unsigned long long vec_bperm (vector unsigned __int128,
                                     vector unsigned char);

vector long long vec_cntlz (vector long long);
vector unsigned long long vec_cntlz (vector unsigned long long);
vector int vec_cntlz (vector int);
vector unsigned int vec_cntlz (vector int);
vector short vec_cntlz (vector short);
vector unsigned short vec_cntlz (vector unsigned short);
vector signed char vec_cntlz (vector signed char);
vector unsigned char vec_cntlz (vector unsigned char);

vector long long vec_vclz (vector long long);
vector unsigned long long vec_vclz (vector unsigned long long);
vector int vec_vclz (vector int);
vector unsigned int vec_vclz (vector int);
vector short vec_vclz (vector short);
vector unsigned short vec_vclz (vector unsigned short);
vector signed char vec_vclz (vector signed char);
vector unsigned char vec_vclz (vector unsigned char);

vector signed char vec_vclzb (vector signed char);
vector unsigned char vec_vclzb (vector unsigned char);

vector long long vec_vclzd (vector long long);
vector unsigned long long vec_vclzd (vector unsigned long long);

vector short vec_vclzh (vector short);
vector unsigned short vec_vclzh (vector unsigned short);

vector int vec_vclzw (vector int);
vector unsigned int vec_vclzw (vector int);

vector signed char vec_vgbbd (vector signed char);
vector unsigned char vec_vgbbd (vector unsigned char);

vector long long vec_vmaxsd (vector long long, vector long long);

vector unsigned long long vec_vmaxud (vector unsigned long long,
                                      unsigned vector long long);

vector long long vec_vminsd (vector long long, vector long long);

vector unsigned long long vec_vminud (vector long long,
                                      vector long long);

vector int vec_vpksdss (vector long long, vector long long);
vector unsigned int vec_vpksdss (vector long long, vector long long);

vector unsigned int vec_vpkudus (vector unsigned long long,
                                 vector unsigned long long);

vector int vec_vpkudum (vector long long, vector long long);
vector unsigned int vec_vpkudum (vector unsigned long long,
                                 vector unsigned long long);
vector bool int vec_vpkudum (vector bool long long, vector bool long long);

vector long long vec_vpopcnt (vector long long);
vector unsigned long long vec_vpopcnt (vector unsigned long long);
vector int vec_vpopcnt (vector int);
vector unsigned int vec_vpopcnt (vector int);
vector short vec_vpopcnt (vector short);
vector unsigned short vec_vpopcnt (vector unsigned short);
vector signed char vec_vpopcnt (vector signed char);
vector unsigned char vec_vpopcnt (vector unsigned char);

vector signed char vec_vpopcntb (vector signed char);
vector unsigned char vec_vpopcntb (vector unsigned char);

vector long long vec_vpopcntd (vector long long);
vector unsigned long long vec_vpopcntd (vector unsigned long long);

vector short vec_vpopcnth (vector short);
vector unsigned short vec_vpopcnth (vector unsigned short);

vector int vec_vpopcntw (vector int);
vector unsigned int vec_vpopcntw (vector int);

vector long long vec_vrld (vector long long, vector unsigned long long);
vector unsigned long long vec_vrld (vector unsigned long long,
                                    vector unsigned long long);

vector long long vec_vsld (vector long long, vector unsigned long long);
vector long long vec_vsld (vector unsigned long long,
                           vector unsigned long long);

vector long long vec_vsrad (vector long long, vector unsigned long long);
vector unsigned long long vec_vsrad (vector unsigned long long,
                                     vector unsigned long long);

vector long long vec_vsrd (vector long long, vector unsigned long long);
vector unsigned long long char vec_vsrd (vector unsigned long long,
                                         vector unsigned long long);

vector long long vec_vsubudm (vector long long, vector long long);
vector long long vec_vsubudm (vector bool long long, vector long long);
vector long long vec_vsubudm (vector long long, vector bool long long);
vector unsigned long long vec_vsubudm (vector unsigned long long,
                                       vector unsigned long long);
vector unsigned long long vec_vsubudm (vector bool long long,
                                       vector unsigned long long);
vector unsigned long long vec_vsubudm (vector unsigned long long,
                                       vector bool long long);

vector long long vec_vupkhsw (vector int);
vector unsigned long long vec_vupkhsw (vector unsigned int);

vector long long vec_vupklsw (vector int);
vector unsigned long long vec_vupklsw (vector int);
@end smallexample

If the ISA 2.07 additions to the vector/scalar (power8-vector)
instruction set are available, the following additional functions are
available for 64-bit targets.  New vector types
(@var{vector __int128_t} and @var{vector __uint128_t}) are available
to hold the @var{__int128_t} and @var{__uint128_t} types to use these
builtins.

The normal vector extract, and set operations work on
@var{vector __int128_t} and @var{vector __uint128_t} types,
but the index value must be 0.

@smallexample
vector __int128_t vec_vaddcuq (vector __int128_t, vector __int128_t);
vector __uint128_t vec_vaddcuq (vector __uint128_t, vector __uint128_t);

vector __int128_t vec_vadduqm (vector __int128_t, vector __int128_t);
vector __uint128_t vec_vadduqm (vector __uint128_t, vector __uint128_t);

vector __int128_t vec_vaddecuq (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vaddecuq (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vaddeuqm (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vaddeuqm (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vsubecuq (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vsubecuq (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vsubeuqm (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vsubeuqm (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vsubcuq (vector __int128_t, vector __int128_t);
vector __uint128_t vec_vsubcuq (vector __uint128_t, vector __uint128_t);

__int128_t vec_vsubuqm (__int128_t, __int128_t);
__uint128_t vec_vsubuqm (__uint128_t, __uint128_t);

vector __int128_t __builtin_bcdadd (vector __int128_t, vector__int128_t);
int __builtin_bcdadd_lt (vector __int128_t, vector__int128_t);
int __builtin_bcdadd_eq (vector __int128_t, vector__int128_t);
int __builtin_bcdadd_gt (vector __int128_t, vector__int128_t);
int __builtin_bcdadd_ov (vector __int128_t, vector__int128_t);
vector __int128_t bcdsub (vector __int128_t, vector__int128_t);
int __builtin_bcdsub_lt (vector __int128_t, vector__int128_t);
int __builtin_bcdsub_eq (vector __int128_t, vector__int128_t);
int __builtin_bcdsub_gt (vector __int128_t, vector__int128_t);
int __builtin_bcdsub_ov (vector __int128_t, vector__int128_t);
@end smallexample

If the ISA 3.0 instruction set additions (@option{-mcpu=power9})
are available:

@smallexample
vector unsigned long long vec_bperm (vector unsigned long long,
                                     vector unsigned char);

vector bool char vec_cmpne (vector bool char, vector bool char);
vector bool short vec_cmpne (vector bool short, vector bool short);
vector bool int vec_cmpne (vector bool int, vector bool int);
vector bool long long vec_cmpne (vector bool long long, vector bool long long);

vector long long vec_vctz (vector long long);
vector unsigned long long vec_vctz (vector unsigned long long);
vector int vec_vctz (vector int);
vector unsigned int vec_vctz (vector int);
vector short vec_vctz (vector short);
vector unsigned short vec_vctz (vector unsigned short);
vector signed char vec_vctz (vector signed char);
vector unsigned char vec_vctz (vector unsigned char);

vector signed char vec_vctzb (vector signed char);
vector unsigned char vec_vctzb (vector unsigned char);

vector long long vec_vctzd (vector long long);
vector unsigned long long vec_vctzd (vector unsigned long long);

vector short vec_vctzh (vector short);
vector unsigned short vec_vctzh (vector unsigned short);

vector int vec_vctzw (vector int);
vector unsigned int vec_vctzw (vector int);

long long vec_vextract4b (const vector signed char, const int);
long long vec_vextract4b (const vector unsigned char, const int);

vector signed char vec_insert4b (vector int, vector signed char, const int);
vector unsigned char vec_insert4b (vector unsigned int, vector unsigned char,
                                   const int);
vector signed char vec_insert4b (long long, vector signed char, const int);
vector unsigned char vec_insert4b (long long, vector unsigned char, const int);

vector int vec_vprtyb (vector int);
vector unsigned int vec_vprtyb (vector unsigned int);
vector long long vec_vprtyb (vector long long);
vector unsigned long long vec_vprtyb (vector unsigned long long);

vector int vec_vprtybw (vector int);
vector unsigned int vec_vprtybw (vector unsigned int);

vector long long vec_vprtybd (vector long long);
vector unsigned long long vec_vprtybd (vector unsigned long long);
@end smallexample

On 64-bit targets, if the ISA 3.0 additions (@option{-mcpu=power9})
are available:

@smallexample
vector long vec_vprtyb (vector long);
vector unsigned long vec_vprtyb (vector unsigned long);
vector __int128_t vec_vprtyb (vector __int128_t);
vector __uint128_t vec_vprtyb (vector __uint128_t);

vector long vec_vprtybd (vector long);
vector unsigned long vec_vprtybd (vector unsigned long);

vector __int128_t vec_vprtybq (vector __int128_t);
vector __uint128_t vec_vprtybd (vector __uint128_t);
@end smallexample

The following built-in vector functions are available for the PowerPC family
of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@smallexample
__vector unsigned char
vec_slv (__vector unsigned char src, __vector unsigned char shift_distance);
__vector unsigned char
vec_srv (__vector unsigned char src, __vector unsigned char shift_distance);
@end smallexample

The @code{vec_slv} and @code{vec_srv} functions operate on
all of the bytes of their @code{src} and @code{shift_distance}
arguments in parallel.  The behavior of the @code{vec_slv} is as if
there existed a temporary array of 17 unsigned characters
@code{slv_array} within which elements 0 through 15 are the same as
the entries in the @code{src} array and element 16 equals 0.  The
result returned from the @code{vec_slv} function is a
@code{__vector} of 16 unsigned characters within which element
@code{i} is computed using the C expression
@code{0xff & (*((unsigned short *)(slv_array + i)) << (0x07 &
shift_distance[i]))},
with this resulting value coerced to the @code{unsigned char} type.
The behavior of the @code{vec_srv} is as if
there existed a temporary array of 17 unsigned characters
@code{srv_array} within which element 0 equals zero and
elements 1 through 16 equal the elements 0 through 15 of
the @code{src} array.  The
result returned from the @code{vec_srv} function is a
@code{__vector} of 16 unsigned characters within which element
@code{i} is computed using the C expression
@code{0xff & (*((unsigned short *)(srv_array + i)) >>
(0x07 & shift_distance[i]))},
with this resulting value coerced to the @code{unsigned char} type.

The following built-in functions are available for the PowerPC family
of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@smallexample
__vector unsigned char
vec_absd (__vector unsigned char arg1, __vector unsigned char arg2);
__vector unsigned short
vec_absd (__vector unsigned short arg1, __vector unsigned short arg2);
__vector unsigned int
vec_absd (__vector unsigned int arg1, __vector unsigned int arg2);

__vector unsigned char
vec_absdb (__vector unsigned char arg1, __vector unsigned char arg2);
__vector unsigned short
vec_absdh (__vector unsigned short arg1, __vector unsigned short arg2);
__vector unsigned int
vec_absdw (__vector unsigned int arg1, __vector unsigned int arg2);
@end smallexample

The @code{vec_absd}, @code{vec_absdb}, @code{vec_absdh}, and
@code{vec_absdw} built-in functions each computes the absolute
differences of the pairs of vector elements supplied in its two vector
arguments, placing the absolute differences into the corresponding
elements of the vector result.

The following built-in functions are available for the PowerPC family
of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@smallexample
__vector unsigned int
vec_extract_exp (__vector float source);
__vector unsigned long long int
vec_extract_exp (__vector double source);

__vector unsigned int
vec_extract_sig (__vector float source);
__vector unsigned long long int
vec_extract_sig (__vector double source);

__vector float
vec_insert_exp (__vector unsigned int significands,
                __vector unsigned int exponents);
__vector float
vec_insert_exp (__vector unsigned float significands,
                __vector unsigned int exponents);
__vector double
vec_insert_exp (__vector unsigned long long int significands,
                __vector unsigned long long int exponents);
__vector double
vec_insert_exp (__vector unsigned double significands,
                __vector unsigned long long int exponents);

__vector bool int vec_test_data_class (__vector float source,
                                       const int condition);
__vector bool long long int vec_test_data_class (__vector double source,
                                                 const int condition);
@end smallexample

The @code{vec_extract_sig} and @code{vec_extract_exp} built-in
functions return vectors representing the significands and biased
exponent values of their @code{source} arguments respectively.
Within the result vector returned by @code{vec_extract_sig}, the
@code{0x800000} bit of each vector element returned when the
function's @code{source} argument is of type @code{float} is set to 1
if the corresponding floating point value is in normalized form.
Otherwise, this bit is set to 0.  When the @code{source} argument is
of type @code{double}, the @code{0x10000000000000} bit within each of
the result vector's elements is set according to the same rules.
Note that the sign of the significand is not represented in the result
returned from the @code{vec_extract_sig} function.  To extract the
sign bits, use the
@code{vec_cpsgn} function, which returns a new vector within which all
of the sign bits of its second argument vector are overwritten with the
sign bits copied from the coresponding elements of its first argument
vector, and all other (non-sign) bits of the second argument vector
are copied unchanged into the result vector.

The @code{vec_insert_exp} built-in functions return a vector of
single- or double-precision floating
point values constructed by assembling the values of their
@code{significands} and @code{exponents} arguments into the
corresponding elements of the returned vector.
The sign of each
element of the result is copied from the most significant bit of the
corresponding entry within the @code{significands} argument.
Note that the relevant
bits of the @code{significands} argument are the same, for both integer
and floating point types.
The
significand and exponent components of each element of the result are
composed of the least significant bits of the corresponding
@code{significands} element and the least significant bits of the
corresponding @code{exponents} element.

The @code{vec_test_data_class} built-in function returns a vector
representing the results of testing the @code{source} vector for the
condition selected by the @code{condition} argument.  The
@code{condition} argument must be a compile-time constant integer with
value not exceeding 127.  The
@code{condition} argument is encoded as a bitmask with each bit
enabling the testing of a different condition, as characterized by the
following:
@smallexample
0x40    Test for NaN
0x20    Test for +Infinity
0x10    Test for -Infinity
0x08    Test for +Zero
0x04    Test for -Zero
0x02    Test for +Denormal
0x01    Test for -Denormal
@end smallexample

If any of the enabled test conditions is true, the corresponding entry
in the result vector is -1.  Otherwise (all of the enabled test
conditions are false), the corresponding entry of the result vector is 0.

The following built-in functions are available for the PowerPC family
of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@smallexample
vector unsigned int vec_rlmi (vector unsigned int, vector unsigned int,
                              vector unsigned int);
vector unsigned long long vec_rlmi (vector unsigned long long,
                                    vector unsigned long long,
                                    vector unsigned long long);
vector unsigned int vec_rlnm (vector unsigned int, vector unsigned int,
                              vector unsigned int);
vector unsigned long long vec_rlnm (vector unsigned long long,
                                    vector unsigned long long,
                                    vector unsigned long long);
vector unsigned int vec_vrlnm (vector unsigned int, vector unsigned int);
vector unsigned long long vec_vrlnm (vector unsigned long long,
                                     vector unsigned long long);
@end smallexample

The result of @code{vec_rlmi} is obtained by rotating each element of
the first argument vector left and inserting it under mask into the
second argument vector.  The third argument vector contains the mask
beginning in bits 11:15, the mask end in bits 19:23, and the shift
count in bits 27:31, of each element.

The result of @code{vec_rlnm} is obtained by rotating each element of
the first argument vector left and ANDing it with a mask specified by
the second and third argument vectors.  The second argument vector
contains the shift count for each element in the low-order byte.  The
third argument vector contains the mask end for each element in the
low-order byte, with the mask begin in the next higher byte.

The result of @code{vec_vrlnm} is obtained by rotating each element
of the first argument vector left and ANDing it with a mask.  The
second argument vector contains the mask  beginning in bits 11:15,
the mask end in bits 19:23, and the shift count in bits 27:31,
of each element.

If the ISA 3.0 instruction set additions (@option{-mcpu=power9})
are available:
@smallexample
vector signed char vec_revb (vector signed char);
vector unsigned char vec_revb (vector unsigned char);
vector short vec_revb (vector short);
vector unsigned short vec_revb (vector unsigned short);
vector int vec_revb (vector int);
vector unsigned int vec_revb (vector unsigned int);
vector float vec_revb (vector float);
vector long long vec_revb (vector long long);
vector unsigned long long vec_revb (vector unsigned long long);
vector double vec_revb (vector double);
@end smallexample

On 64-bit targets, if the ISA 3.0 additions (@option{-mcpu=power9})
are available:
@smallexample
vector long vec_revb (vector long);
vector unsigned long vec_revb (vector unsigned long);
vector __int128_t vec_revb (vector __int128_t);
vector __uint128_t vec_revb (vector __uint128_t);
@end smallexample

The @code{vec_revb} built-in function reverses the bytes on an element
by element basis.  A vector of @code{vector unsigned char} or
@code{vector signed char} reverses the bytes in the whole word.

If the cryptographic instructions are enabled (@option{-mcrypto} or
@option{-mcpu=power8}), the following builtins are enabled.

@smallexample
vector unsigned long long __builtin_crypto_vsbox (vector unsigned long long);

vector unsigned long long __builtin_crypto_vcipher (vector unsigned long long,
                                                    vector unsigned long long);

vector unsigned long long __builtin_crypto_vcipherlast
                                     (vector unsigned long long,
                                      vector unsigned long long);

vector unsigned long long __builtin_crypto_vncipher (vector unsigned long long,
                                                     vector unsigned long long);

vector unsigned long long __builtin_crypto_vncipherlast
                                     (vector unsigned long long,
                                      vector unsigned long long);

vector unsigned char __builtin_crypto_vpermxor (vector unsigned char,
                                                vector unsigned char,
                                                vector unsigned char);

vector unsigned short __builtin_crypto_vpermxor (vector unsigned short,
                                                 vector unsigned short,
                                                 vector unsigned short);

vector unsigned int __builtin_crypto_vpermxor (vector unsigned int,
                                               vector unsigned int,
                                               vector unsigned int);

vector unsigned long long __builtin_crypto_vpermxor (vector unsigned long long,
                                                     vector unsigned long long,
                                                     vector unsigned long long);

vector unsigned char __builtin_crypto_vpmsumb (vector unsigned char,
                                               vector unsigned char);

vector unsigned short __builtin_crypto_vpmsumb (vector unsigned short,
                                                vector unsigned short);

vector unsigned int __builtin_crypto_vpmsumb (vector unsigned int,
                                              vector unsigned int);

vector unsigned long long __builtin_crypto_vpmsumb (vector unsigned long long,
                                                    vector unsigned long long);

vector unsigned long long __builtin_crypto_vshasigmad
                               (vector unsigned long long, int, int);

vector unsigned int __builtin_crypto_vshasigmaw (vector unsigned int,
                                                 int, int);
@end smallexample

The second argument to @var{__builtin_crypto_vshasigmad} and
@var{__builtin_crypto_vshasigmaw} must be a constant
integer that is 0 or 1.  The third argument to these built-in functions
must be a constant integer in the range of 0 to 15.

If the ISA 3.0 instruction set additions 
are enabled (@option{-mcpu=power9}), the following additional
functions are available for both 32-bit and 64-bit targets.

vector short vec_xl (int, vector short *);
vector short vec_xl (int, short *);
vector unsigned short vec_xl (int, vector unsigned short *);
vector unsigned short vec_xl (int, unsigned short *);
vector char vec_xl (int, vector char *);
vector char vec_xl (int, char *);
vector unsigned char vec_xl (int, vector unsigned char *);
vector unsigned char vec_xl (int, unsigned char *);

void vec_xst (vector short, int, vector short *);
void vec_xst (vector short, int, short *);
void vec_xst (vector unsigned short, int, vector unsigned short *);
void vec_xst (vector unsigned short, int, unsigned short *);
void vec_xst (vector char, int, vector char *);
void vec_xst (vector char, int, char *);
void vec_xst (vector unsigned char, int, vector unsigned char *);
void vec_xst (vector unsigned char, int, unsigned char *);

@node PowerPC Hardware Transactional Memory Built-in Functions
@subsection PowerPC Hardware Transactional Memory Built-in Functions
GCC provides two interfaces for accessing the Hardware Transactional
Memory (HTM) instructions available on some of the PowerPC family
of processors (eg, POWER8).  The two interfaces come in a low level
interface, consisting of built-in functions specific to PowerPC and a
higher level interface consisting of inline functions that are common
between PowerPC and S/390.

@subsubsection PowerPC HTM Low Level Built-in Functions

The following low level built-in functions are available with
@option{-mhtm} or @option{-mcpu=CPU} where CPU is `power8' or later.
They all generate the machine instruction that is part of the name.

The HTM builtins (with the exception of @code{__builtin_tbegin}) return
the full 4-bit condition register value set by their associated hardware
instruction.  The header file @code{htmintrin.h} defines some macros that can
be used to decipher the return value.  The @code{__builtin_tbegin} builtin
returns a simple true or false value depending on whether a transaction was
successfully started or not.  The arguments of the builtins match exactly the
type and order of the associated hardware instruction's operands, except for
the @code{__builtin_tcheck} builtin, which does not take any input arguments.
Refer to the ISA manual for a description of each instruction's operands.

@smallexample
unsigned int __builtin_tbegin (unsigned int)
unsigned int __builtin_tend (unsigned int)

unsigned int __builtin_tabort (unsigned int)
unsigned int __builtin_tabortdc (unsigned int, unsigned int, unsigned int)
unsigned int __builtin_tabortdci (unsigned int, unsigned int, int)
unsigned int __builtin_tabortwc (unsigned int, unsigned int, unsigned int)
unsigned int __builtin_tabortwci (unsigned int, unsigned int, int)

unsigned int __builtin_tcheck (void)
unsigned int __builtin_treclaim (unsigned int)
unsigned int __builtin_trechkpt (void)
unsigned int __builtin_tsr (unsigned int)
@end smallexample

In addition to the above HTM built-ins, we have added built-ins for
some common extended mnemonics of the HTM instructions:

@smallexample
unsigned int __builtin_tendall (void)
unsigned int __builtin_tresume (void)
unsigned int __builtin_tsuspend (void)
@end smallexample

Note that the semantics of the above HTM builtins are required to mimic
the locking semantics used for critical sections.  Builtins that are used
to create a new transaction or restart a suspended transaction must have
lock acquisition like semantics while those builtins that end or suspend a
transaction must have lock release like semantics.  Specifically, this must
mimic lock semantics as specified by C++11, for example: Lock acquisition is
as-if an execution of __atomic_exchange_n(&globallock,1,__ATOMIC_ACQUIRE)
that returns 0, and lock release is as-if an execution of
__atomic_store(&globallock,0,__ATOMIC_RELEASE), with globallock being an
implicit implementation-defined lock used for all transactions.  The HTM
instructions associated with with the builtins inherently provide the
correct acquisition and release hardware barriers required.  However,
the compiler must also be prohibited from moving loads and stores across
the builtins in a way that would violate their semantics.  This has been
accomplished by adding memory barriers to the associated HTM instructions
(which is a conservative approach to provide acquire and release semantics).
Earlier versions of the compiler did not treat the HTM instructions as
memory barriers.  A @code{__TM_FENCE__} macro has been added, which can
be used to determine whether the current compiler treats HTM instructions
as memory barriers or not.  This allows the user to explicitly add memory
barriers to their code when using an older version of the compiler.

The following set of built-in functions are available to gain access
to the HTM specific special purpose registers.

@smallexample
unsigned long __builtin_get_texasr (void)
unsigned long __builtin_get_texasru (void)
unsigned long __builtin_get_tfhar (void)
unsigned long __builtin_get_tfiar (void)

void __builtin_set_texasr (unsigned long);
void __builtin_set_texasru (unsigned long);
void __builtin_set_tfhar (unsigned long);
void __builtin_set_tfiar (unsigned long);
@end smallexample

Example usage of these low level built-in functions may look like:

@smallexample
#include <htmintrin.h>

int num_retries = 10;

while (1)
  @{
    if (__builtin_tbegin (0))
      @{
        /* Transaction State Initiated.  */
        if (is_locked (lock))
          __builtin_tabort (0);
        ... transaction code...
        __builtin_tend (0);
        break;
      @}
    else
      @{
        /* Transaction State Failed.  Use locks if the transaction
           failure is "persistent" or we've tried too many times.  */
        if (num_retries-- <= 0
            || _TEXASRU_FAILURE_PERSISTENT (__builtin_get_texasru ()))
          @{
            acquire_lock (lock);
            ... non transactional fallback path...
            release_lock (lock);
            break;
          @}
      @}
  @}
@end smallexample

One final built-in function has been added that returns the value of
the 2-bit Transaction State field of the Machine Status Register (MSR)
as stored in @code{CR0}.

@smallexample
unsigned long __builtin_ttest (void)
@end smallexample

This built-in can be used to determine the current transaction state
using the following code example:

@smallexample
#include <htmintrin.h>

unsigned char tx_state = _HTM_STATE (__builtin_ttest ());

if (tx_state == _HTM_TRANSACTIONAL)
  @{
    /* Code to use in transactional state.  */
  @}
else if (tx_state == _HTM_NONTRANSACTIONAL)
  @{
    /* Code to use in non-transactional state.  */
  @}
else if (tx_state == _HTM_SUSPENDED)
  @{
    /* Code to use in transaction suspended state.  */
  @}
@end smallexample

@subsubsection PowerPC HTM High Level Inline Functions

The following high level HTM interface is made available by including
@code{<htmxlintrin.h>} and using @option{-mhtm} or @option{-mcpu=CPU}
where CPU is `power8' or later.  This interface is common between PowerPC
and S/390, allowing users to write one HTM source implementation that
can be compiled and executed on either system.

@smallexample
long __TM_simple_begin (void)
long __TM_begin (void* const TM_buff)
long __TM_end (void)
void __TM_abort (void)
void __TM_named_abort (unsigned char const code)
void __TM_resume (void)
void __TM_suspend (void)

long __TM_is_user_abort (void* const TM_buff)
long __TM_is_named_user_abort (void* const TM_buff, unsigned char *code)
long __TM_is_illegal (void* const TM_buff)
long __TM_is_footprint_exceeded (void* const TM_buff)
long __TM_nesting_depth (void* const TM_buff)
long __TM_is_nested_too_deep(void* const TM_buff)
long __TM_is_conflict(void* const TM_buff)
long __TM_is_failure_persistent(void* const TM_buff)
long __TM_failure_address(void* const TM_buff)
long long __TM_failure_code(void* const TM_buff)
@end smallexample

Using these common set of HTM inline functions, we can create
a more portable version of the HTM example in the previous
section that will work on either PowerPC or S/390:

@smallexample
#include <htmxlintrin.h>

int num_retries = 10;
TM_buff_type TM_buff;

while (1)
  @{
    if (__TM_begin (TM_buff) == _HTM_TBEGIN_STARTED)
      @{
        /* Transaction State Initiated.  */
        if (is_locked (lock))
          __TM_abort ();
        ... transaction code...
        __TM_end ();
        break;
      @}
    else
      @{
        /* Transaction State Failed.  Use locks if the transaction
           failure is "persistent" or we've tried too many times.  */
        if (num_retries-- <= 0
            || __TM_is_failure_persistent (TM_buff))
          @{
            acquire_lock (lock);
            ... non transactional fallback path...
            release_lock (lock);
            break;
          @}
      @}
  @}
@end smallexample

@node RX Built-in Functions
@subsection RX Built-in Functions
GCC supports some of the RX instructions which cannot be expressed in
the C programming language via the use of built-in functions.  The
following functions are supported:

@deftypefn {Built-in Function}  void __builtin_rx_brk (void)
Generates the @code{brk} machine instruction.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_clrpsw (int)
Generates the @code{clrpsw} machine instruction to clear the specified
bit in the processor status word.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_int (int)
Generates the @code{int} machine instruction to generate an interrupt
with the specified value.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_machi (int, int)
Generates the @code{machi} machine instruction to add the result of
multiplying the top 16 bits of the two arguments into the
accumulator.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_maclo (int, int)
Generates the @code{maclo} machine instruction to add the result of
multiplying the bottom 16 bits of the two arguments into the
accumulator.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mulhi (int, int)
Generates the @code{mulhi} machine instruction to place the result of
multiplying the top 16 bits of the two arguments into the
accumulator.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mullo (int, int)
Generates the @code{mullo} machine instruction to place the result of
multiplying the bottom 16 bits of the two arguments into the
accumulator.
@end deftypefn

@deftypefn {Built-in Function}  int  __builtin_rx_mvfachi (void)
Generates the @code{mvfachi} machine instruction to read the top
32 bits of the accumulator.
@end deftypefn

@deftypefn {Built-in Function}  int  __builtin_rx_mvfacmi (void)
Generates the @code{mvfacmi} machine instruction to read the middle
32 bits of the accumulator.
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_rx_mvfc (int)
Generates the @code{mvfc} machine instruction which reads the control
register specified in its argument and returns its value.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtachi (int)
Generates the @code{mvtachi} machine instruction to set the top
32 bits of the accumulator.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtaclo (int)
Generates the @code{mvtaclo} machine instruction to set the bottom
32 bits of the accumulator.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtc (int reg, int val)
Generates the @code{mvtc} machine instruction which sets control
register number @code{reg} to @code{val}.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtipl (int)
Generates the @code{mvtipl} machine instruction set the interrupt
priority level.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_racw (int)
Generates the @code{racw} machine instruction to round the accumulator
according to the specified mode.
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_rx_revw (int)
Generates the @code{revw} machine instruction which swaps the bytes in
the argument so that bits 0--7 now occupy bits 8--15 and vice versa,
and also bits 16--23 occupy bits 24--31 and vice versa.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_rmpa (void)
Generates the @code{rmpa} machine instruction which initiates a
repeated multiply and accumulate sequence.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_round (float)
Generates the @code{round} machine instruction which returns the
floating-point argument rounded according to the current rounding mode
set in the floating-point status word register.
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_rx_sat (int)
Generates the @code{sat} machine instruction which returns the
saturated value of the argument.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_setpsw (int)
Generates the @code{setpsw} machine instruction to set the specified
bit in the processor status word.
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_wait (void)
Generates the @code{wait} machine instruction.
@end deftypefn

@node S/390 System z Built-in Functions
@subsection S/390 System z Built-in Functions
@deftypefn {Built-in Function} int __builtin_tbegin (void*)
Generates the @code{tbegin} machine instruction starting a
non-constrained hardware transaction.  If the parameter is non-NULL the
memory area is used to store the transaction diagnostic buffer and
will be passed as first operand to @code{tbegin}.  This buffer can be
defined using the @code{struct __htm_tdb} C struct defined in
@code{htmintrin.h} and must reside on a double-word boundary.  The
second tbegin operand is set to @code{0xff0c}. This enables
save/restore of all GPRs and disables aborts for FPR and AR
manipulations inside the transaction body.  The condition code set by
the tbegin instruction is returned as integer value.  The tbegin
instruction by definition overwrites the content of all FPRs.  The
compiler will generate code which saves and restores the FPRs.  For
soft-float code it is recommended to used the @code{*_nofloat}
variant.  In order to prevent a TDB from being written it is required
to pass a constant zero value as parameter.  Passing a zero value
through a variable is not sufficient.  Although modifications of
access registers inside the transaction will not trigger an
transaction abort it is not supported to actually modify them.  Access
registers do not get saved when entering a transaction. They will have
undefined state when reaching the abort code.
@end deftypefn

Macros for the possible return codes of tbegin are defined in the
@code{htmintrin.h} header file:

@table @code
@item _HTM_TBEGIN_STARTED
@code{tbegin} has been executed as part of normal processing.  The
transaction body is supposed to be executed.
@item _HTM_TBEGIN_INDETERMINATE
The transaction was aborted due to an indeterminate condition which
might be persistent.
@item _HTM_TBEGIN_TRANSIENT
The transaction aborted due to a transient failure.  The transaction
should be re-executed in that case.
@item _HTM_TBEGIN_PERSISTENT
The transaction aborted due to a persistent failure.  Re-execution
under same circumstances will not be productive.
@end table

@defmac _HTM_FIRST_USER_ABORT_CODE
The @code{_HTM_FIRST_USER_ABORT_CODE} defined in @code{htmintrin.h}
specifies the first abort code which can be used for
@code{__builtin_tabort}.  Values below this threshold are reserved for
machine use.
@end defmac

@deftp {Data type} {struct __htm_tdb}
The @code{struct __htm_tdb} defined in @code{htmintrin.h} describes
the structure of the transaction diagnostic block as specified in the
Principles of Operation manual chapter 5-91.
@end deftp

@deftypefn {Built-in Function} int __builtin_tbegin_nofloat (void*)
Same as @code{__builtin_tbegin} but without FPR saves and restores.
Using this variant in code making use of FPRs will leave the FPRs in
undefined state when entering the transaction abort handler code.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tbegin_retry (void*, int)
In addition to @code{__builtin_tbegin} a loop for transient failures
is generated.  If tbegin returns a condition code of 2 the transaction
will be retried as often as specified in the second argument.  The
perform processor assist instruction is used to tell the CPU about the
number of fails so far.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tbegin_retry_nofloat (void*, int)
Same as @code{__builtin_tbegin_retry} but without FPR saves and
restores.  Using this variant in code making use of FPRs will leave
the FPRs in undefined state when entering the transaction abort
handler code.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_tbeginc (void)
Generates the @code{tbeginc} machine instruction starting a constrained
hardware transaction.  The second operand is set to @code{0xff08}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tend (void)
Generates the @code{tend} machine instruction finishing a transaction
and making the changes visible to other threads.  The condition code
generated by tend is returned as integer value.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_tabort (int)
Generates the @code{tabort} machine instruction with the specified
abort code.  Abort codes from 0 through 255 are reserved and will
result in an error message.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_tx_assist (int)
Generates the @code{ppa rX,rY,1} machine instruction.  Where the
integer parameter is loaded into rX and a value of zero is loaded into
rY.  The integer parameter specifies the number of times the
transaction repeatedly aborted.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tx_nesting_depth (void)
Generates the @code{etnd} machine instruction.  The current nesting
depth is returned as integer value.  For a nesting depth of 0 the code
is not executed as part of an transaction.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_non_tx_store (uint64_t *, uint64_t)

Generates the @code{ntstg} machine instruction.  The second argument
is written to the first arguments location.  The store operation will
not be rolled-back in case of an transaction abort.
@end deftypefn

@node SH Built-in Functions
@subsection SH Built-in Functions
The following built-in functions are supported on the SH1, SH2, SH3 and SH4
families of processors:

@deftypefn {Built-in Function} {void} __builtin_set_thread_pointer (void *@var{ptr})
Sets the @samp{GBR} register to the specified value @var{ptr}.  This is usually
used by system code that manages threads and execution contexts.  The compiler
normally does not generate code that modifies the contents of @samp{GBR} and
thus the value is preserved across function calls.  Changing the @samp{GBR}
value in user code must be done with caution, since the compiler might use
@samp{GBR} in order to access thread local variables.

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_thread_pointer (void)
Returns the value that is currently set in the @samp{GBR} register.
Memory loads and stores that use the thread pointer as a base address are
turned into @samp{GBR} based displacement loads and stores, if possible.
For example:
@smallexample
struct my_tcb
@{
   int a, b, c, d, e;
@};

int get_tcb_value (void)
@{
  // Generate @samp{mov.l @@(8,gbr),r0} instruction
  return ((my_tcb*)__builtin_thread_pointer ())->c;
@}

@end smallexample
@end deftypefn

@deftypefn {Built-in Function} {unsigned int} __builtin_sh_get_fpscr (void)
Returns the value that is currently set in the @samp{FPSCR} register.
@end deftypefn

@deftypefn {Built-in Function} {void} __builtin_sh_set_fpscr (unsigned int @var{val})
Sets the @samp{FPSCR} register to the specified value @var{val}, while
preserving the current values of the FR, SZ and PR bits.
@end deftypefn

@node SPARC VIS Built-in Functions
@subsection SPARC VIS Built-in Functions

GCC supports SIMD operations on the SPARC using both the generic vector
extensions (@pxref{Vector Extensions}) as well as built-in functions for
the SPARC Visual Instruction Set (VIS).  When you use the @option{-mvis}
switch, the VIS extension is exposed as the following built-in functions:

@smallexample
typedef int v1si __attribute__ ((vector_size (4)));
typedef int v2si __attribute__ ((vector_size (8)));
typedef short v4hi __attribute__ ((vector_size (8)));
typedef short v2hi __attribute__ ((vector_size (4)));
typedef unsigned char v8qi __attribute__ ((vector_size (8)));
typedef unsigned char v4qi __attribute__ ((vector_size (4)));

void __builtin_vis_write_gsr (int64_t);
int64_t __builtin_vis_read_gsr (void);

void * __builtin_vis_alignaddr (void *, long);
void * __builtin_vis_alignaddrl (void *, long);
int64_t __builtin_vis_faligndatadi (int64_t, int64_t);
v2si __builtin_vis_faligndatav2si (v2si, v2si);
v4hi __builtin_vis_faligndatav4hi (v4si, v4si);
v8qi __builtin_vis_faligndatav8qi (v8qi, v8qi);

v4hi __builtin_vis_fexpand (v4qi);

v4hi __builtin_vis_fmul8x16 (v4qi, v4hi);
v4hi __builtin_vis_fmul8x16au (v4qi, v2hi);
v4hi __builtin_vis_fmul8x16al (v4qi, v2hi);
v4hi __builtin_vis_fmul8sux16 (v8qi, v4hi);
v4hi __builtin_vis_fmul8ulx16 (v8qi, v4hi);
v2si __builtin_vis_fmuld8sux16 (v4qi, v2hi);
v2si __builtin_vis_fmuld8ulx16 (v4qi, v2hi);

v4qi __builtin_vis_fpack16 (v4hi);
v8qi __builtin_vis_fpack32 (v2si, v8qi);
v2hi __builtin_vis_fpackfix (v2si);
v8qi __builtin_vis_fpmerge (v4qi, v4qi);

int64_t __builtin_vis_pdist (v8qi, v8qi, int64_t);

long __builtin_vis_edge8 (void *, void *);
long __builtin_vis_edge8l (void *, void *);
long __builtin_vis_edge16 (void *, void *);
long __builtin_vis_edge16l (void *, void *);
long __builtin_vis_edge32 (void *, void *);
long __builtin_vis_edge32l (void *, void *);

long __builtin_vis_fcmple16 (v4hi, v4hi);
long __builtin_vis_fcmple32 (v2si, v2si);
long __builtin_vis_fcmpne16 (v4hi, v4hi);
long __builtin_vis_fcmpne32 (v2si, v2si);
long __builtin_vis_fcmpgt16 (v4hi, v4hi);
long __builtin_vis_fcmpgt32 (v2si, v2si);
long __builtin_vis_fcmpeq16 (v4hi, v4hi);
long __builtin_vis_fcmpeq32 (v2si, v2si);

v4hi __builtin_vis_fpadd16 (v4hi, v4hi);
v2hi __builtin_vis_fpadd16s (v2hi, v2hi);
v2si __builtin_vis_fpadd32 (v2si, v2si);
v1si __builtin_vis_fpadd32s (v1si, v1si);
v4hi __builtin_vis_fpsub16 (v4hi, v4hi);
v2hi __builtin_vis_fpsub16s (v2hi, v2hi);
v2si __builtin_vis_fpsub32 (v2si, v2si);
v1si __builtin_vis_fpsub32s (v1si, v1si);

long __builtin_vis_array8 (long, long);
long __builtin_vis_array16 (long, long);
long __builtin_vis_array32 (long, long);
@end smallexample

When you use the @option{-mvis2} switch, the VIS version 2.0 built-in
functions also become available:

@smallexample
long __builtin_vis_bmask (long, long);
int64_t __builtin_vis_bshuffledi (int64_t, int64_t);
v2si __builtin_vis_bshufflev2si (v2si, v2si);
v4hi __builtin_vis_bshufflev2si (v4hi, v4hi);
v8qi __builtin_vis_bshufflev2si (v8qi, v8qi);

long __builtin_vis_edge8n (void *, void *);
long __builtin_vis_edge8ln (void *, void *);
long __builtin_vis_edge16n (void *, void *);
long __builtin_vis_edge16ln (void *, void *);
long __builtin_vis_edge32n (void *, void *);
long __builtin_vis_edge32ln (void *, void *);
@end smallexample

When you use the @option{-mvis3} switch, the VIS version 3.0 built-in
functions also become available:

@smallexample
void __builtin_vis_cmask8 (long);
void __builtin_vis_cmask16 (long);
void __builtin_vis_cmask32 (long);

v4hi __builtin_vis_fchksm16 (v4hi, v4hi);

v4hi __builtin_vis_fsll16 (v4hi, v4hi);
v4hi __builtin_vis_fslas16 (v4hi, v4hi);
v4hi __builtin_vis_fsrl16 (v4hi, v4hi);
v4hi __builtin_vis_fsra16 (v4hi, v4hi);
v2si __builtin_vis_fsll16 (v2si, v2si);
v2si __builtin_vis_fslas16 (v2si, v2si);
v2si __builtin_vis_fsrl16 (v2si, v2si);
v2si __builtin_vis_fsra16 (v2si, v2si);

long __builtin_vis_pdistn (v8qi, v8qi);

v4hi __builtin_vis_fmean16 (v4hi, v4hi);

int64_t __builtin_vis_fpadd64 (int64_t, int64_t);
int64_t __builtin_vis_fpsub64 (int64_t, int64_t);

v4hi __builtin_vis_fpadds16 (v4hi, v4hi);
v2hi __builtin_vis_fpadds16s (v2hi, v2hi);
v4hi __builtin_vis_fpsubs16 (v4hi, v4hi);
v2hi __builtin_vis_fpsubs16s (v2hi, v2hi);
v2si __builtin_vis_fpadds32 (v2si, v2si);
v1si __builtin_vis_fpadds32s (v1si, v1si);
v2si __builtin_vis_fpsubs32 (v2si, v2si);
v1si __builtin_vis_fpsubs32s (v1si, v1si);

long __builtin_vis_fucmple8 (v8qi, v8qi);
long __builtin_vis_fucmpne8 (v8qi, v8qi);
long __builtin_vis_fucmpgt8 (v8qi, v8qi);
long __builtin_vis_fucmpeq8 (v8qi, v8qi);

float __builtin_vis_fhadds (float, float);
double __builtin_vis_fhaddd (double, double);
float __builtin_vis_fhsubs (float, float);
double __builtin_vis_fhsubd (double, double);
float __builtin_vis_fnhadds (float, float);
double __builtin_vis_fnhaddd (double, double);

int64_t __builtin_vis_umulxhi (int64_t, int64_t);
int64_t __builtin_vis_xmulx (int64_t, int64_t);
int64_t __builtin_vis_xmulxhi (int64_t, int64_t);
@end smallexample

When you use the @option{-mvis4} switch, the VIS version 4.0 built-in
functions also become available:

@smallexample
v8qi __builtin_vis_fpadd8 (v8qi, v8qi);
v8qi __builtin_vis_fpadds8 (v8qi, v8qi);
v8qi __builtin_vis_fpaddus8 (v8qi, v8qi);
v4hi __builtin_vis_fpaddus16 (v4hi, v4hi);

v8qi __builtin_vis_fpsub8 (v8qi, v8qi);
v8qi __builtin_vis_fpsubs8 (v8qi, v8qi);
v8qi __builtin_vis_fpsubus8 (v8qi, v8qi);
v4hi __builtin_vis_fpsubus16 (v4hi, v4hi);

long __builtin_vis_fpcmple8 (v8qi, v8qi);
long __builtin_vis_fpcmpgt8 (v8qi, v8qi);
long __builtin_vis_fpcmpule16 (v4hi, v4hi);
long __builtin_vis_fpcmpugt16 (v4hi, v4hi);
long __builtin_vis_fpcmpule32 (v2si, v2si);
long __builtin_vis_fpcmpugt32 (v2si, v2si);

v8qi __builtin_vis_fpmax8 (v8qi, v8qi);
v4hi __builtin_vis_fpmax16 (v4hi, v4hi);
v2si __builtin_vis_fpmax32 (v2si, v2si);

v8qi __builtin_vis_fpmaxu8 (v8qi, v8qi);
v4hi __builtin_vis_fpmaxu16 (v4hi, v4hi);
v2si __builtin_vis_fpmaxu32 (v2si, v2si);


v8qi __builtin_vis_fpmin8 (v8qi, v8qi);
v4hi __builtin_vis_fpmin16 (v4hi, v4hi);
v2si __builtin_vis_fpmin32 (v2si, v2si);

v8qi __builtin_vis_fpminu8 (v8qi, v8qi);
v4hi __builtin_vis_fpminu16 (v4hi, v4hi);
v2si __builtin_vis_fpminu32 (v2si, v2si);
@end smallexample

When you use the @option{-mvis4b} switch, the VIS version 4.0B
built-in functions also become available:

@smallexample
v8qi __builtin_vis_dictunpack8 (double, int);
v4hi __builtin_vis_dictunpack16 (double, int);
v2si __builtin_vis_dictunpack32 (double, int);

long __builtin_vis_fpcmple8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpgt8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpeq8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpne8shl (v8qi, v8qi, int);

long __builtin_vis_fpcmple16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpgt16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpeq16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpne16shl (v4hi, v4hi, int);

long __builtin_vis_fpcmple32shl (v2si, v2si, int);
long __builtin_vis_fpcmpgt32shl (v2si, v2si, int);
long __builtin_vis_fpcmpeq32shl (v2si, v2si, int);
long __builtin_vis_fpcmpne32shl (v2si, v2si, int);

long __builtin_vis_fpcmpule8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpugt8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpule16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpugt16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpule32shl (v2si, v2si, int);
long __builtin_vis_fpcmpugt32shl (v2si, v2si, int);

long __builtin_vis_fpcmpde8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpde16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpde32shl (v2si, v2si, int);

long __builtin_vis_fpcmpur8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpur16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpur32shl (v2si, v2si, int);
@end smallexample

@node SPU Built-in Functions
@subsection SPU Built-in Functions

GCC provides extensions for the SPU processor as described in the
Sony/Toshiba/IBM SPU Language Extensions Specification.  GCC's
implementation differs in several ways.

@itemize @bullet

@item
The optional extension of specifying vector constants in parentheses is
not supported.

@item
A vector initializer requires no cast if the vector constant is of the
same type as the variable it is initializing.

@item
If @code{signed} or @code{unsigned} is omitted, the signedness of the
vector type is the default signedness of the base type.  The default
varies depending on the operating system, so a portable program should
always specify the signedness.

@item
By default, the keyword @code{__vector} is added. The macro
@code{vector} is defined in @code{<spu_intrinsics.h>} and can be
undefined.

@item
GCC allows using a @code{typedef} name as the type specifier for a
vector type.

@item
For C, overloaded functions are implemented with macros so the following
does not work:

@smallexample
  spu_add ((vector signed int)@{1, 2, 3, 4@}, foo);
@end smallexample

@noindent
Since @code{spu_add} is a macro, the vector constant in the example
is treated as four separate arguments.  Wrap the entire argument in
parentheses for this to work.

@item
The extended version of @code{__builtin_expect} is not supported.

@end itemize

@emph{Note:} Only the interface described in the aforementioned
specification is supported. Internally, GCC uses built-in functions to
implement the required functionality, but these are not supported and
are subject to change without notice.

@node TI C6X Built-in Functions
@subsection TI C6X Built-in Functions

GCC provides intrinsics to access certain instructions of the TI C6X
processors.  These intrinsics, listed below, are available after
inclusion of the @code{c6x_intrinsics.h} header file.  They map directly
to C6X instructions.

@smallexample

int _sadd (int, int)
int _ssub (int, int)
int _sadd2 (int, int)
int _ssub2 (int, int)
long long _mpy2 (int, int)
long long _smpy2 (int, int)
int _add4 (int, int)
int _sub4 (int, int)
int _saddu4 (int, int)

int _smpy (int, int)
int _smpyh (int, int)
int _smpyhl (int, int)
int _smpylh (int, int)

int _sshl (int, int)
int _subc (int, int)

int _avg2 (int, int)
int _avgu4 (int, int)

int _clrr (int, int)
int _extr (int, int)
int _extru (int, int)
int _abs (int)
int _abs2 (int)

@end smallexample

@node TILE-Gx Built-in Functions
@subsection TILE-Gx Built-in Functions

GCC provides intrinsics to access every instruction of the TILE-Gx
processor.  The intrinsics are of the form:

@smallexample

unsigned long long __insn_@var{op} (...)

@end smallexample

Where @var{op} is the name of the instruction.  Refer to the ISA manual
for the complete list of instructions.

GCC also provides intrinsics to directly access the network registers.
The intrinsics are:

@smallexample

unsigned long long __tile_idn0_receive (void)
unsigned long long __tile_idn1_receive (void)
unsigned long long __tile_udn0_receive (void)
unsigned long long __tile_udn1_receive (void)
unsigned long long __tile_udn2_receive (void)
unsigned long long __tile_udn3_receive (void)
void __tile_idn_send (unsigned long long)
void __tile_udn_send (unsigned long long)

@end smallexample

The intrinsic @code{void __tile_network_barrier (void)} is used to
guarantee that no network operations before it are reordered with
those after it.

@node TILEPro Built-in Functions
@subsection TILEPro Built-in Functions

GCC provides intrinsics to access every instruction of the TILEPro
processor.  The intrinsics are of the form:

@smallexample

unsigned __insn_@var{op} (...)

@end smallexample

@noindent
where @var{op} is the name of the instruction.  Refer to the ISA manual
for the complete list of instructions.

GCC also provides intrinsics to directly access the network registers.
The intrinsics are:

@smallexample

unsigned __tile_idn0_receive (void)
unsigned __tile_idn1_receive (void)
unsigned __tile_sn_receive (void)
unsigned __tile_udn0_receive (void)
unsigned __tile_udn1_receive (void)
unsigned __tile_udn2_receive (void)
unsigned __tile_udn3_receive (void)
void __tile_idn_send (unsigned)
void __tile_sn_send (unsigned)
void __tile_udn_send (unsigned)

@end smallexample

The intrinsic @code{void __tile_network_barrier (void)} is used to
guarantee that no network operations before it are reordered with
those after it.

@node x86 Built-in Functions
@subsection x86 Built-in Functions

These built-in functions are available for the x86-32 and x86-64 family
of computers, depending on the command-line switches used.

If you specify command-line switches such as @option{-msse},
the compiler could use the extended instruction sets even if the built-ins
are not used explicitly in the program.  For this reason, applications
that perform run-time CPU detection must compile separate files for each
supported architecture, using the appropriate flags.  In particular,
the file containing the CPU detection code should be compiled without
these options.

The following machine modes are available for use with MMX built-in functions
(@pxref{Vector Extensions}): @code{V2SI} for a vector of two 32-bit integers,
@code{V4HI} for a vector of four 16-bit integers, and @code{V8QI} for a
vector of eight 8-bit integers.  Some of the built-in functions operate on
MMX registers as a whole 64-bit entity, these use @code{V1DI} as their mode.

If 3DNow!@: extensions are enabled, @code{V2SF} is used as a mode for a vector
of two 32-bit floating-point values.

If SSE extensions are enabled, @code{V4SF} is used for a vector of four 32-bit
floating-point values.  Some instructions use a vector of four 32-bit
integers, these use @code{V4SI}.  Finally, some instructions operate on an
entire vector register, interpreting it as a 128-bit integer, these use mode
@code{TI}.

The x86-32 and x86-64 family of processors use additional built-in
functions for efficient use of @code{TF} (@code{__float128}) 128-bit
floating point and @code{TC} 128-bit complex floating-point values.

The following floating-point built-in functions are always available.  All
of them implement the function that is part of the name.

@smallexample
__float128 __builtin_fabsq (__float128)
__float128 __builtin_copysignq (__float128, __float128)
@end smallexample

The following built-in functions are always available.

@table @code
@item __float128 __builtin_infq (void)
Similar to @code{__builtin_inf}, except the return type is @code{__float128}.
@findex __builtin_infq

@item __float128 __builtin_huge_valq (void)
Similar to @code{__builtin_huge_val}, except the return type is @code{__float128}.
@findex __builtin_huge_valq

@item __float128 __builtin_nanq (void)
Similar to @code{__builtin_nan}, except the return type is @code{__float128}.
@findex __builtin_nanq

@item __float128 __builtin_nansq (void)
Similar to @code{__builtin_nans}, except the return type is @code{__float128}.
@findex __builtin_nansq
@end table

The following built-in function is always available.

@table @code
@item void __builtin_ia32_pause (void)
Generates the @code{pause} machine instruction with a compiler memory
barrier.
@end table

The following built-in functions are always available and can be used to
check the target platform type.

@deftypefn {Built-in Function} void __builtin_cpu_init (void)
This function runs the CPU detection code to check the type of CPU and the
features supported.  This built-in function needs to be invoked along with the built-in functions
to check CPU type and features, @code{__builtin_cpu_is} and
@code{__builtin_cpu_supports}, only when used in a function that is
executed before any constructors are called.  The CPU detection code is
automatically executed in a very high priority constructor.

For example, this function has to be used in @code{ifunc} resolvers that
check for CPU type using the built-in functions @code{__builtin_cpu_is}
and @code{__builtin_cpu_supports}, or in constructors on targets that
don't support constructor priority.
@smallexample

static void (*resolve_memcpy (void)) (void)
@{
  // ifunc resolvers fire before constructors, explicitly call the init
  // function.
  __builtin_cpu_init ();
  if (__builtin_cpu_supports ("ssse3"))
    return ssse3_memcpy; // super fast memcpy with ssse3 instructions.
  else
    return default_memcpy;
@}

void *memcpy (void *, const void *, size_t)
     __attribute__ ((ifunc ("resolve_memcpy")));
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_is (const char *@var{cpuname})
This function returns a positive integer if the run-time CPU
is of type @var{cpuname}
and returns @code{0} otherwise. The following CPU names can be detected:

@table @samp
@item intel
Intel CPU.

@item atom
Intel Atom CPU.

@item core2
Intel Core 2 CPU.

@item corei7
Intel Core i7 CPU.

@item nehalem
Intel Core i7 Nehalem CPU.

@item westmere
Intel Core i7 Westmere CPU.

@item sandybridge
Intel Core i7 Sandy Bridge CPU.

@item amd
AMD CPU.

@item amdfam10h
AMD Family 10h CPU.

@item barcelona
AMD Family 10h Barcelona CPU.

@item shanghai
AMD Family 10h Shanghai CPU.

@item istanbul
AMD Family 10h Istanbul CPU.

@item btver1
AMD Family 14h CPU.

@item amdfam15h
AMD Family 15h CPU.

@item bdver1
AMD Family 15h Bulldozer version 1.

@item bdver2
AMD Family 15h Bulldozer version 2.

@item bdver3
AMD Family 15h Bulldozer version 3.

@item bdver4
AMD Family 15h Bulldozer version 4.

@item btver2
AMD Family 16h CPU.

@item amdfam17h
AMD Family 17h CPU.

@item znver1
AMD Family 17h Zen version 1.
@end table

Here is an example:
@smallexample
if (__builtin_cpu_is ("corei7"))
  @{
     do_corei7 (); // Core i7 specific implementation.
  @}
else
  @{
     do_generic (); // Generic implementation.
  @}
@end smallexample
@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_supports (const char *@var{feature})
This function returns a positive integer if the run-time CPU
supports @var{feature}
and returns @code{0} otherwise. The following features can be detected:

@table @samp
@item cmov
CMOV instruction.
@item mmx
MMX instructions.
@item popcnt
POPCNT instruction.
@item sse
SSE instructions.
@item sse2
SSE2 instructions.
@item sse3
SSE3 instructions.
@item ssse3
SSSE3 instructions.
@item sse4.1
SSE4.1 instructions.
@item sse4.2
SSE4.2 instructions.
@item avx
AVX instructions.
@item avx2
AVX2 instructions.
@item avx512f
AVX512F instructions.
@end table

Here is an example:
@smallexample
if (__builtin_cpu_supports ("popcnt"))
  @{
     asm("popcnt %1,%0" : "=r"(count) : "rm"(n) : "cc");
  @}
else
  @{
     count = generic_countbits (n); //generic implementation.
  @}
@end smallexample
@end deftypefn


The following built-in functions are made available by @option{-mmmx}.
All of them generate the machine instruction that is part of the name.

@smallexample
v8qi __builtin_ia32_paddb (v8qi, v8qi)
v4hi __builtin_ia32_paddw (v4hi, v4hi)
v2si __builtin_ia32_paddd (v2si, v2si)
v8qi __builtin_ia32_psubb (v8qi, v8qi)
v4hi __builtin_ia32_psubw (v4hi, v4hi)
v2si __builtin_ia32_psubd (v2si, v2si)
v8qi __builtin_ia32_paddsb (v8qi, v8qi)
v4hi __builtin_ia32_paddsw (v4hi, v4hi)
v8qi __builtin_ia32_psubsb (v8qi, v8qi)
v4hi __builtin_ia32_psubsw (v4hi, v4hi)
v8qi __builtin_ia32_paddusb (v8qi, v8qi)
v4hi __builtin_ia32_paddusw (v4hi, v4hi)
v8qi __builtin_ia32_psubusb (v8qi, v8qi)
v4hi __builtin_ia32_psubusw (v4hi, v4hi)
v4hi __builtin_ia32_pmullw (v4hi, v4hi)
v4hi __builtin_ia32_pmulhw (v4hi, v4hi)
di __builtin_ia32_pand (di, di)
di __builtin_ia32_pandn (di,di)
di __builtin_ia32_por (di, di)
di __builtin_ia32_pxor (di, di)
v8qi __builtin_ia32_pcmpeqb (v8qi, v8qi)
v4hi __builtin_ia32_pcmpeqw (v4hi, v4hi)
v2si __builtin_ia32_pcmpeqd (v2si, v2si)
v8qi __builtin_ia32_pcmpgtb (v8qi, v8qi)
v4hi __builtin_ia32_pcmpgtw (v4hi, v4hi)
v2si __builtin_ia32_pcmpgtd (v2si, v2si)
v8qi __builtin_ia32_punpckhbw (v8qi, v8qi)
v4hi __builtin_ia32_punpckhwd (v4hi, v4hi)
v2si __builtin_ia32_punpckhdq (v2si, v2si)
v8qi __builtin_ia32_punpcklbw (v8qi, v8qi)
v4hi __builtin_ia32_punpcklwd (v4hi, v4hi)
v2si __builtin_ia32_punpckldq (v2si, v2si)
v8qi __builtin_ia32_packsswb (v4hi, v4hi)
v4hi __builtin_ia32_packssdw (v2si, v2si)
v8qi __builtin_ia32_packuswb (v4hi, v4hi)

v4hi __builtin_ia32_psllw (v4hi, v4hi)
v2si __builtin_ia32_pslld (v2si, v2si)
v1di __builtin_ia32_psllq (v1di, v1di)
v4hi __builtin_ia32_psrlw (v4hi, v4hi)
v2si __builtin_ia32_psrld (v2si, v2si)
v1di __builtin_ia32_psrlq (v1di, v1di)
v4hi __builtin_ia32_psraw (v4hi, v4hi)
v2si __builtin_ia32_psrad (v2si, v2si)
v4hi __builtin_ia32_psllwi (v4hi, int)
v2si __builtin_ia32_pslldi (v2si, int)
v1di __builtin_ia32_psllqi (v1di, int)
v4hi __builtin_ia32_psrlwi (v4hi, int)
v2si __builtin_ia32_psrldi (v2si, int)
v1di __builtin_ia32_psrlqi (v1di, int)
v4hi __builtin_ia32_psrawi (v4hi, int)
v2si __builtin_ia32_psradi (v2si, int)

@end smallexample

The following built-in functions are made available either with
@option{-msse}, or with @option{-m3dnowa}.  All of them generate
the machine instruction that is part of the name.

@smallexample
v4hi __builtin_ia32_pmulhuw (v4hi, v4hi)
v8qi __builtin_ia32_pavgb (v8qi, v8qi)
v4hi __builtin_ia32_pavgw (v4hi, v4hi)
v1di __builtin_ia32_psadbw (v8qi, v8qi)
v8qi __builtin_ia32_pmaxub (v8qi, v8qi)
v4hi __builtin_ia32_pmaxsw (v4hi, v4hi)
v8qi __builtin_ia32_pminub (v8qi, v8qi)
v4hi __builtin_ia32_pminsw (v4hi, v4hi)
int __builtin_ia32_pmovmskb (v8qi)
void __builtin_ia32_maskmovq (v8qi, v8qi, char *)
void __builtin_ia32_movntq (di *, di)
void __builtin_ia32_sfence (void)
@end smallexample

The following built-in functions are available when @option{-msse} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
int __builtin_ia32_comieq (v4sf, v4sf)
int __builtin_ia32_comineq (v4sf, v4sf)
int __builtin_ia32_comilt (v4sf, v4sf)
int __builtin_ia32_comile (v4sf, v4sf)
int __builtin_ia32_comigt (v4sf, v4sf)
int __builtin_ia32_comige (v4sf, v4sf)
int __builtin_ia32_ucomieq (v4sf, v4sf)
int __builtin_ia32_ucomineq (v4sf, v4sf)
int __builtin_ia32_ucomilt (v4sf, v4sf)
int __builtin_ia32_ucomile (v4sf, v4sf)
int __builtin_ia32_ucomigt (v4sf, v4sf)
int __builtin_ia32_ucomige (v4sf, v4sf)
v4sf __builtin_ia32_addps (v4sf, v4sf)
v4sf __builtin_ia32_subps (v4sf, v4sf)
v4sf __builtin_ia32_mulps (v4sf, v4sf)
v4sf __builtin_ia32_divps (v4sf, v4sf)
v4sf __builtin_ia32_addss (v4sf, v4sf)
v4sf __builtin_ia32_subss (v4sf, v4sf)
v4sf __builtin_ia32_mulss (v4sf, v4sf)
v4sf __builtin_ia32_divss (v4sf, v4sf)
v4sf __builtin_ia32_cmpeqps (v4sf, v4sf)
v4sf __builtin_ia32_cmpltps (v4sf, v4sf)
v4sf __builtin_ia32_cmpleps (v4sf, v4sf)
v4sf __builtin_ia32_cmpgtps (v4sf, v4sf)
v4sf __builtin_ia32_cmpgeps (v4sf, v4sf)
v4sf __builtin_ia32_cmpunordps (v4sf, v4sf)
v4sf __builtin_ia32_cmpneqps (v4sf, v4sf)
v4sf __builtin_ia32_cmpnltps (v4sf, v4sf)
v4sf __builtin_ia32_cmpnleps (v4sf, v4sf)
v4sf __builtin_ia32_cmpngtps (v4sf, v4sf)
v4sf __builtin_ia32_cmpngeps (v4sf, v4sf)
v4sf __builtin_ia32_cmpordps (v4sf, v4sf)
v4sf __builtin_ia32_cmpeqss (v4sf, v4sf)
v4sf __builtin_ia32_cmpltss (v4sf, v4sf)
v4sf __builtin_ia32_cmpless (v4sf, v4sf)
v4sf __builtin_ia32_cmpunordss (v4sf, v4sf)
v4sf __builtin_ia32_cmpneqss (v4sf, v4sf)
v4sf __builtin_ia32_cmpnltss (v4sf, v4sf)
v4sf __builtin_ia32_cmpnless (v4sf, v4sf)
v4sf __builtin_ia32_cmpordss (v4sf, v4sf)
v4sf __builtin_ia32_maxps (v4sf, v4sf)
v4sf __builtin_ia32_maxss (v4sf, v4sf)
v4sf __builtin_ia32_minps (v4sf, v4sf)
v4sf __builtin_ia32_minss (v4sf, v4sf)
v4sf __builtin_ia32_andps (v4sf, v4sf)
v4sf __builtin_ia32_andnps (v4sf, v4sf)
v4sf __builtin_ia32_orps (v4sf, v4sf)
v4sf __builtin_ia32_xorps (v4sf, v4sf)
v4sf __builtin_ia32_movss (v4sf, v4sf)
v4sf __builtin_ia32_movhlps (v4sf, v4sf)
v4sf __builtin_ia32_movlhps (v4sf, v4sf)
v4sf __builtin_ia32_unpckhps (v4sf, v4sf)
v4sf __builtin_ia32_unpcklps (v4sf, v4sf)
v4sf __builtin_ia32_cvtpi2ps (v4sf, v2si)
v4sf __builtin_ia32_cvtsi2ss (v4sf, int)
v2si __builtin_ia32_cvtps2pi (v4sf)
int __builtin_ia32_cvtss2si (v4sf)
v2si __builtin_ia32_cvttps2pi (v4sf)
int __builtin_ia32_cvttss2si (v4sf)
v4sf __builtin_ia32_rcpps (v4sf)
v4sf __builtin_ia32_rsqrtps (v4sf)
v4sf __builtin_ia32_sqrtps (v4sf)
v4sf __builtin_ia32_rcpss (v4sf)
v4sf __builtin_ia32_rsqrtss (v4sf)
v4sf __builtin_ia32_sqrtss (v4sf)
v4sf __builtin_ia32_shufps (v4sf, v4sf, int)
void __builtin_ia32_movntps (float *, v4sf)
int __builtin_ia32_movmskps (v4sf)
@end smallexample

The following built-in functions are available when @option{-msse} is used.

@table @code
@item v4sf __builtin_ia32_loadups (float *)
Generates the @code{movups} machine instruction as a load from memory.
@item void __builtin_ia32_storeups (float *, v4sf)
Generates the @code{movups} machine instruction as a store to memory.
@item v4sf __builtin_ia32_loadss (float *)
Generates the @code{movss} machine instruction as a load from memory.
@item v4sf __builtin_ia32_loadhps (v4sf, const v2sf *)
Generates the @code{movhps} machine instruction as a load from memory.
@item v4sf __builtin_ia32_loadlps (v4sf, const v2sf *)
Generates the @code{movlps} machine instruction as a load from memory
@item void __builtin_ia32_storehps (v2sf *, v4sf)
Generates the @code{movhps} machine instruction as a store to memory.
@item void __builtin_ia32_storelps (v2sf *, v4sf)
Generates the @code{movlps} machine instruction as a store to memory.
@end table

The following built-in functions are available when @option{-msse2} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
int __builtin_ia32_comisdeq (v2df, v2df)
int __builtin_ia32_comisdlt (v2df, v2df)
int __builtin_ia32_comisdle (v2df, v2df)
int __builtin_ia32_comisdgt (v2df, v2df)
int __builtin_ia32_comisdge (v2df, v2df)
int __builtin_ia32_comisdneq (v2df, v2df)
int __builtin_ia32_ucomisdeq (v2df, v2df)
int __builtin_ia32_ucomisdlt (v2df, v2df)
int __builtin_ia32_ucomisdle (v2df, v2df)
int __builtin_ia32_ucomisdgt (v2df, v2df)
int __builtin_ia32_ucomisdge (v2df, v2df)
int __builtin_ia32_ucomisdneq (v2df, v2df)
v2df __builtin_ia32_cmpeqpd (v2df, v2df)
v2df __builtin_ia32_cmpltpd (v2df, v2df)
v2df __builtin_ia32_cmplepd (v2df, v2df)
v2df __builtin_ia32_cmpgtpd (v2df, v2df)
v2df __builtin_ia32_cmpgepd (v2df, v2df)
v2df __builtin_ia32_cmpunordpd (v2df, v2df)
v2df __builtin_ia32_cmpneqpd (v2df, v2df)
v2df __builtin_ia32_cmpnltpd (v2df, v2df)
v2df __builtin_ia32_cmpnlepd (v2df, v2df)
v2df __builtin_ia32_cmpngtpd (v2df, v2df)
v2df __builtin_ia32_cmpngepd (v2df, v2df)
v2df __builtin_ia32_cmpordpd (v2df, v2df)
v2df __builtin_ia32_cmpeqsd (v2df, v2df)
v2df __builtin_ia32_cmpltsd (v2df, v2df)
v2df __builtin_ia32_cmplesd (v2df, v2df)
v2df __builtin_ia32_cmpunordsd (v2df, v2df)
v2df __builtin_ia32_cmpneqsd (v2df, v2df)
v2df __builtin_ia32_cmpnltsd (v2df, v2df)
v2df __builtin_ia32_cmpnlesd (v2df, v2df)
v2df __builtin_ia32_cmpordsd (v2df, v2df)
v2di __builtin_ia32_paddq (v2di, v2di)
v2di __builtin_ia32_psubq (v2di, v2di)
v2df __builtin_ia32_addpd (v2df, v2df)
v2df __builtin_ia32_subpd (v2df, v2df)
v2df __builtin_ia32_mulpd (v2df, v2df)
v2df __builtin_ia32_divpd (v2df, v2df)
v2df __builtin_ia32_addsd (v2df, v2df)
v2df __builtin_ia32_subsd (v2df, v2df)
v2df __builtin_ia32_mulsd (v2df, v2df)
v2df __builtin_ia32_divsd (v2df, v2df)
v2df __builtin_ia32_minpd (v2df, v2df)
v2df __builtin_ia32_maxpd (v2df, v2df)
v2df __builtin_ia32_minsd (v2df, v2df)
v2df __builtin_ia32_maxsd (v2df, v2df)
v2df __builtin_ia32_andpd (v2df, v2df)
v2df __builtin_ia32_andnpd (v2df, v2df)
v2df __builtin_ia32_orpd (v2df, v2df)
v2df __builtin_ia32_xorpd (v2df, v2df)
v2df __builtin_ia32_movsd (v2df, v2df)
v2df __builtin_ia32_unpckhpd (v2df, v2df)
v2df __builtin_ia32_unpcklpd (v2df, v2df)
v16qi __builtin_ia32_paddb128 (v16qi, v16qi)
v8hi __builtin_ia32_paddw128 (v8hi, v8hi)
v4si __builtin_ia32_paddd128 (v4si, v4si)
v2di __builtin_ia32_paddq128 (v2di, v2di)
v16qi __builtin_ia32_psubb128 (v16qi, v16qi)
v8hi __builtin_ia32_psubw128 (v8hi, v8hi)
v4si __builtin_ia32_psubd128 (v4si, v4si)
v2di __builtin_ia32_psubq128 (v2di, v2di)
v8hi __builtin_ia32_pmullw128 (v8hi, v8hi)
v8hi __builtin_ia32_pmulhw128 (v8hi, v8hi)
v2di __builtin_ia32_pand128 (v2di, v2di)
v2di __builtin_ia32_pandn128 (v2di, v2di)
v2di __builtin_ia32_por128 (v2di, v2di)
v2di __builtin_ia32_pxor128 (v2di, v2di)
v16qi __builtin_ia32_pavgb128 (v16qi, v16qi)
v8hi __builtin_ia32_pavgw128 (v8hi, v8hi)
v16qi __builtin_ia32_pcmpeqb128 (v16qi, v16qi)
v8hi __builtin_ia32_pcmpeqw128 (v8hi, v8hi)
v4si __builtin_ia32_pcmpeqd128 (v4si, v4si)
v16qi __builtin_ia32_pcmpgtb128 (v16qi, v16qi)
v8hi __builtin_ia32_pcmpgtw128 (v8hi, v8hi)
v4si __builtin_ia32_pcmpgtd128 (v4si, v4si)
v16qi __builtin_ia32_pmaxub128 (v16qi, v16qi)
v8hi __builtin_ia32_pmaxsw128 (v8hi, v8hi)
v16qi __builtin_ia32_pminub128 (v16qi, v16qi)
v8hi __builtin_ia32_pminsw128 (v8hi, v8hi)
v16qi __builtin_ia32_punpckhbw128 (v16qi, v16qi)
v8hi __builtin_ia32_punpckhwd128 (v8hi, v8hi)
v4si __builtin_ia32_punpckhdq128 (v4si, v4si)
v2di __builtin_ia32_punpckhqdq128 (v2di, v2di)
v16qi __builtin_ia32_punpcklbw128 (v16qi, v16qi)
v8hi __builtin_ia32_punpcklwd128 (v8hi, v8hi)
v4si __builtin_ia32_punpckldq128 (v4si, v4si)
v2di __builtin_ia32_punpcklqdq128 (v2di, v2di)
v16qi __builtin_ia32_packsswb128 (v8hi, v8hi)
v8hi __builtin_ia32_packssdw128 (v4si, v4si)
v16qi __builtin_ia32_packuswb128 (v8hi, v8hi)
v8hi __builtin_ia32_pmulhuw128 (v8hi, v8hi)
void __builtin_ia32_maskmovdqu (v16qi, v16qi)
v2df __builtin_ia32_loadupd (double *)
void __builtin_ia32_storeupd (double *, v2df)
v2df __builtin_ia32_loadhpd (v2df, double const *)
v2df __builtin_ia32_loadlpd (v2df, double const *)
int __builtin_ia32_movmskpd (v2df)
int __builtin_ia32_pmovmskb128 (v16qi)
void __builtin_ia32_movnti (int *, int)
void __builtin_ia32_movnti64 (long long int *, long long int)
void __builtin_ia32_movntpd (double *, v2df)
void __builtin_ia32_movntdq (v2df *, v2df)
v4si __builtin_ia32_pshufd (v4si, int)
v8hi __builtin_ia32_pshuflw (v8hi, int)
v8hi __builtin_ia32_pshufhw (v8hi, int)
v2di __builtin_ia32_psadbw128 (v16qi, v16qi)
v2df __builtin_ia32_sqrtpd (v2df)
v2df __builtin_ia32_sqrtsd (v2df)
v2df __builtin_ia32_shufpd (v2df, v2df, int)
v2df __builtin_ia32_cvtdq2pd (v4si)
v4sf __builtin_ia32_cvtdq2ps (v4si)
v4si __builtin_ia32_cvtpd2dq (v2df)
v2si __builtin_ia32_cvtpd2pi (v2df)
v4sf __builtin_ia32_cvtpd2ps (v2df)
v4si __builtin_ia32_cvttpd2dq (v2df)
v2si __builtin_ia32_cvttpd2pi (v2df)
v2df __builtin_ia32_cvtpi2pd (v2si)
int __builtin_ia32_cvtsd2si (v2df)
int __builtin_ia32_cvttsd2si (v2df)
long long __builtin_ia32_cvtsd2si64 (v2df)
long long __builtin_ia32_cvttsd2si64 (v2df)
v4si __builtin_ia32_cvtps2dq (v4sf)
v2df __builtin_ia32_cvtps2pd (v4sf)
v4si __builtin_ia32_cvttps2dq (v4sf)
v2df __builtin_ia32_cvtsi2sd (v2df, int)
v2df __builtin_ia32_cvtsi642sd (v2df, long long)
v4sf __builtin_ia32_cvtsd2ss (v4sf, v2df)
v2df __builtin_ia32_cvtss2sd (v2df, v4sf)
void __builtin_ia32_clflush (const void *)
void __builtin_ia32_lfence (void)
void __builtin_ia32_mfence (void)
v16qi __builtin_ia32_loaddqu (const char *)
void __builtin_ia32_storedqu (char *, v16qi)
v1di __builtin_ia32_pmuludq (v2si, v2si)
v2di __builtin_ia32_pmuludq128 (v4si, v4si)
v8hi __builtin_ia32_psllw128 (v8hi, v8hi)
v4si __builtin_ia32_pslld128 (v4si, v4si)
v2di __builtin_ia32_psllq128 (v2di, v2di)
v8hi __builtin_ia32_psrlw128 (v8hi, v8hi)
v4si __builtin_ia32_psrld128 (v4si, v4si)
v2di __builtin_ia32_psrlq128 (v2di, v2di)
v8hi __builtin_ia32_psraw128 (v8hi, v8hi)
v4si __builtin_ia32_psrad128 (v4si, v4si)
v2di __builtin_ia32_pslldqi128 (v2di, int)
v8hi __builtin_ia32_psllwi128 (v8hi, int)
v4si __builtin_ia32_pslldi128 (v4si, int)
v2di __builtin_ia32_psllqi128 (v2di, int)
v2di __builtin_ia32_psrldqi128 (v2di, int)
v8hi __builtin_ia32_psrlwi128 (v8hi, int)
v4si __builtin_ia32_psrldi128 (v4si, int)
v2di __builtin_ia32_psrlqi128 (v2di, int)
v8hi __builtin_ia32_psrawi128 (v8hi, int)
v4si __builtin_ia32_psradi128 (v4si, int)
v4si __builtin_ia32_pmaddwd128 (v8hi, v8hi)
v2di __builtin_ia32_movq128 (v2di)
@end smallexample

The following built-in functions are available when @option{-msse3} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2df __builtin_ia32_addsubpd (v2df, v2df)
v4sf __builtin_ia32_addsubps (v4sf, v4sf)
v2df __builtin_ia32_haddpd (v2df, v2df)
v4sf __builtin_ia32_haddps (v4sf, v4sf)
v2df __builtin_ia32_hsubpd (v2df, v2df)
v4sf __builtin_ia32_hsubps (v4sf, v4sf)
v16qi __builtin_ia32_lddqu (char const *)
void __builtin_ia32_monitor (void *, unsigned int, unsigned int)
v4sf __builtin_ia32_movshdup (v4sf)
v4sf __builtin_ia32_movsldup (v4sf)
void __builtin_ia32_mwait (unsigned int, unsigned int)
@end smallexample

The following built-in functions are available when @option{-mssse3} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2si __builtin_ia32_phaddd (v2si, v2si)
v4hi __builtin_ia32_phaddw (v4hi, v4hi)
v4hi __builtin_ia32_phaddsw (v4hi, v4hi)
v2si __builtin_ia32_phsubd (v2si, v2si)
v4hi __builtin_ia32_phsubw (v4hi, v4hi)
v4hi __builtin_ia32_phsubsw (v4hi, v4hi)
v4hi __builtin_ia32_pmaddubsw (v8qi, v8qi)
v4hi __builtin_ia32_pmulhrsw (v4hi, v4hi)
v8qi __builtin_ia32_pshufb (v8qi, v8qi)
v8qi __builtin_ia32_psignb (v8qi, v8qi)
v2si __builtin_ia32_psignd (v2si, v2si)
v4hi __builtin_ia32_psignw (v4hi, v4hi)
v1di __builtin_ia32_palignr (v1di, v1di, int)
v8qi __builtin_ia32_pabsb (v8qi)
v2si __builtin_ia32_pabsd (v2si)
v4hi __builtin_ia32_pabsw (v4hi)
@end smallexample

The following built-in functions are available when @option{-mssse3} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v4si __builtin_ia32_phaddd128 (v4si, v4si)
v8hi __builtin_ia32_phaddw128 (v8hi, v8hi)
v8hi __builtin_ia32_phaddsw128 (v8hi, v8hi)
v4si __builtin_ia32_phsubd128 (v4si, v4si)
v8hi __builtin_ia32_phsubw128 (v8hi, v8hi)
v8hi __builtin_ia32_phsubsw128 (v8hi, v8hi)
v8hi __builtin_ia32_pmaddubsw128 (v16qi, v16qi)
v8hi __builtin_ia32_pmulhrsw128 (v8hi, v8hi)
v16qi __builtin_ia32_pshufb128 (v16qi, v16qi)
v16qi __builtin_ia32_psignb128 (v16qi, v16qi)
v4si __builtin_ia32_psignd128 (v4si, v4si)
v8hi __builtin_ia32_psignw128 (v8hi, v8hi)
v2di __builtin_ia32_palignr128 (v2di, v2di, int)
v16qi __builtin_ia32_pabsb128 (v16qi)
v4si __builtin_ia32_pabsd128 (v4si)
v8hi __builtin_ia32_pabsw128 (v8hi)
@end smallexample

The following built-in functions are available when @option{-msse4.1} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
v2df __builtin_ia32_blendpd (v2df, v2df, const int)
v4sf __builtin_ia32_blendps (v4sf, v4sf, const int)
v2df __builtin_ia32_blendvpd (v2df, v2df, v2df)
v4sf __builtin_ia32_blendvps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_dppd (v2df, v2df, const int)
v4sf __builtin_ia32_dpps (v4sf, v4sf, const int)
v4sf __builtin_ia32_insertps128 (v4sf, v4sf, const int)
v2di __builtin_ia32_movntdqa (v2di *);
v16qi __builtin_ia32_mpsadbw128 (v16qi, v16qi, const int)
v8hi __builtin_ia32_packusdw128 (v4si, v4si)
v16qi __builtin_ia32_pblendvb128 (v16qi, v16qi, v16qi)
v8hi __builtin_ia32_pblendw128 (v8hi, v8hi, const int)
v2di __builtin_ia32_pcmpeqq (v2di, v2di)
v8hi __builtin_ia32_phminposuw128 (v8hi)
v16qi __builtin_ia32_pmaxsb128 (v16qi, v16qi)
v4si __builtin_ia32_pmaxsd128 (v4si, v4si)
v4si __builtin_ia32_pmaxud128 (v4si, v4si)
v8hi __builtin_ia32_pmaxuw128 (v8hi, v8hi)
v16qi __builtin_ia32_pminsb128 (v16qi, v16qi)
v4si __builtin_ia32_pminsd128 (v4si, v4si)
v4si __builtin_ia32_pminud128 (v4si, v4si)
v8hi __builtin_ia32_pminuw128 (v8hi, v8hi)
v4si __builtin_ia32_pmovsxbd128 (v16qi)
v2di __builtin_ia32_pmovsxbq128 (v16qi)
v8hi __builtin_ia32_pmovsxbw128 (v16qi)
v2di __builtin_ia32_pmovsxdq128 (v4si)
v4si __builtin_ia32_pmovsxwd128 (v8hi)
v2di __builtin_ia32_pmovsxwq128 (v8hi)
v4si __builtin_ia32_pmovzxbd128 (v16qi)
v2di __builtin_ia32_pmovzxbq128 (v16qi)
v8hi __builtin_ia32_pmovzxbw128 (v16qi)
v2di __builtin_ia32_pmovzxdq128 (v4si)
v4si __builtin_ia32_pmovzxwd128 (v8hi)
v2di __builtin_ia32_pmovzxwq128 (v8hi)
v2di __builtin_ia32_pmuldq128 (v4si, v4si)
v4si __builtin_ia32_pmulld128 (v4si, v4si)
int __builtin_ia32_ptestc128 (v2di, v2di)
int __builtin_ia32_ptestnzc128 (v2di, v2di)
int __builtin_ia32_ptestz128 (v2di, v2di)
v2df __builtin_ia32_roundpd (v2df, const int)
v4sf __builtin_ia32_roundps (v4sf, const int)
v2df __builtin_ia32_roundsd (v2df, v2df, const int)
v4sf __builtin_ia32_roundss (v4sf, v4sf, const int)
@end smallexample

The following built-in functions are available when @option{-msse4.1} is
used.

@table @code
@item v4sf __builtin_ia32_vec_set_v4sf (v4sf, float, const int)
Generates the @code{insertps} machine instruction.
@item int __builtin_ia32_vec_ext_v16qi (v16qi, const int)
Generates the @code{pextrb} machine instruction.
@item v16qi __builtin_ia32_vec_set_v16qi (v16qi, int, const int)
Generates the @code{pinsrb} machine instruction.
@item v4si __builtin_ia32_vec_set_v4si (v4si, int, const int)
Generates the @code{pinsrd} machine instruction.
@item v2di __builtin_ia32_vec_set_v2di (v2di, long long, const int)
Generates the @code{pinsrq} machine instruction in 64bit mode.
@end table

The following built-in functions are changed to generate new SSE4.1
instructions when @option{-msse4.1} is used.

@table @code
@item float __builtin_ia32_vec_ext_v4sf (v4sf, const int)
Generates the @code{extractps} machine instruction.
@item int __builtin_ia32_vec_ext_v4si (v4si, const int)
Generates the @code{pextrd} machine instruction.
@item long long __builtin_ia32_vec_ext_v2di (v2di, const int)
Generates the @code{pextrq} machine instruction in 64bit mode.
@end table

The following built-in functions are available when @option{-msse4.2} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
v16qi __builtin_ia32_pcmpestrm128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestri128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestria128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestric128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestrio128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestris128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestriz128 (v16qi, int, v16qi, int, const int)
v16qi __builtin_ia32_pcmpistrm128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistri128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistria128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistric128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistrio128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistris128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistriz128 (v16qi, v16qi, const int)
v2di __builtin_ia32_pcmpgtq (v2di, v2di)
@end smallexample

The following built-in functions are available when @option{-msse4.2} is
used.

@table @code
@item unsigned int __builtin_ia32_crc32qi (unsigned int, unsigned char)
Generates the @code{crc32b} machine instruction.
@item unsigned int __builtin_ia32_crc32hi (unsigned int, unsigned short)
Generates the @code{crc32w} machine instruction.
@item unsigned int __builtin_ia32_crc32si (unsigned int, unsigned int)
Generates the @code{crc32l} machine instruction.
@item unsigned long long __builtin_ia32_crc32di (unsigned long long, unsigned long long)
Generates the @code{crc32q} machine instruction.
@end table

The following built-in functions are changed to generate new SSE4.2
instructions when @option{-msse4.2} is used.

@table @code
@item int __builtin_popcount (unsigned int)
Generates the @code{popcntl} machine instruction.
@item int __builtin_popcountl (unsigned long)
Generates the @code{popcntl} or @code{popcntq} machine instruction,
depending on the size of @code{unsigned long}.
@item int __builtin_popcountll (unsigned long long)
Generates the @code{popcntq} machine instruction.
@end table

The following built-in functions are available when @option{-mavx} is
used. All of them generate the machine instruction that is part of the
name.

@smallexample
v4df __builtin_ia32_addpd256 (v4df,v4df)
v8sf __builtin_ia32_addps256 (v8sf,v8sf)
v4df __builtin_ia32_addsubpd256 (v4df,v4df)
v8sf __builtin_ia32_addsubps256 (v8sf,v8sf)
v4df __builtin_ia32_andnpd256 (v4df,v4df)
v8sf __builtin_ia32_andnps256 (v8sf,v8sf)
v4df __builtin_ia32_andpd256 (v4df,v4df)
v8sf __builtin_ia32_andps256 (v8sf,v8sf)
v4df __builtin_ia32_blendpd256 (v4df,v4df,int)
v8sf __builtin_ia32_blendps256 (v8sf,v8sf,int)
v4df __builtin_ia32_blendvpd256 (v4df,v4df,v4df)
v8sf __builtin_ia32_blendvps256 (v8sf,v8sf,v8sf)
v2df __builtin_ia32_cmppd (v2df,v2df,int)
v4df __builtin_ia32_cmppd256 (v4df,v4df,int)
v4sf __builtin_ia32_cmpps (v4sf,v4sf,int)
v8sf __builtin_ia32_cmpps256 (v8sf,v8sf,int)
v2df __builtin_ia32_cmpsd (v2df,v2df,int)
v4sf __builtin_ia32_cmpss (v4sf,v4sf,int)
v4df __builtin_ia32_cvtdq2pd256 (v4si)
v8sf __builtin_ia32_cvtdq2ps256 (v8si)
v4si __builtin_ia32_cvtpd2dq256 (v4df)
v4sf __builtin_ia32_cvtpd2ps256 (v4df)
v8si __builtin_ia32_cvtps2dq256 (v8sf)
v4df __builtin_ia32_cvtps2pd256 (v4sf)
v4si __builtin_ia32_cvttpd2dq256 (v4df)
v8si __builtin_ia32_cvttps2dq256 (v8sf)
v4df __builtin_ia32_divpd256 (v4df,v4df)
v8sf __builtin_ia32_divps256 (v8sf,v8sf)
v8sf __builtin_ia32_dpps256 (v8sf,v8sf,int)
v4df __builtin_ia32_haddpd256 (v4df,v4df)
v8sf __builtin_ia32_haddps256 (v8sf,v8sf)
v4df __builtin_ia32_hsubpd256 (v4df,v4df)
v8sf __builtin_ia32_hsubps256 (v8sf,v8sf)
v32qi __builtin_ia32_lddqu256 (pcchar)
v32qi __builtin_ia32_loaddqu256 (pcchar)
v4df __builtin_ia32_loadupd256 (pcdouble)
v8sf __builtin_ia32_loadups256 (pcfloat)
v2df __builtin_ia32_maskloadpd (pcv2df,v2df)
v4df __builtin_ia32_maskloadpd256 (pcv4df,v4df)
v4sf __builtin_ia32_maskloadps (pcv4sf,v4sf)
v8sf __builtin_ia32_maskloadps256 (pcv8sf,v8sf)
void __builtin_ia32_maskstorepd (pv2df,v2df,v2df)
void __builtin_ia32_maskstorepd256 (pv4df,v4df,v4df)
void __builtin_ia32_maskstoreps (pv4sf,v4sf,v4sf)
void __builtin_ia32_maskstoreps256 (pv8sf,v8sf,v8sf)
v4df __builtin_ia32_maxpd256 (v4df,v4df)
v8sf __builtin_ia32_maxps256 (v8sf,v8sf)
v4df __builtin_ia32_minpd256 (v4df,v4df)
v8sf __builtin_ia32_minps256 (v8sf,v8sf)
v4df __builtin_ia32_movddup256 (v4df)
int __builtin_ia32_movmskpd256 (v4df)
int __builtin_ia32_movmskps256 (v8sf)
v8sf __builtin_ia32_movshdup256 (v8sf)
v8sf __builtin_ia32_movsldup256 (v8sf)
v4df __builtin_ia32_mulpd256 (v4df,v4df)
v8sf __builtin_ia32_mulps256 (v8sf,v8sf)
v4df __builtin_ia32_orpd256 (v4df,v4df)
v8sf __builtin_ia32_orps256 (v8sf,v8sf)
v2df __builtin_ia32_pd_pd256 (v4df)
v4df __builtin_ia32_pd256_pd (v2df)
v4sf __builtin_ia32_ps_ps256 (v8sf)
v8sf __builtin_ia32_ps256_ps (v4sf)
int __builtin_ia32_ptestc256 (v4di,v4di,ptest)
int __builtin_ia32_ptestnzc256 (v4di,v4di,ptest)
int __builtin_ia32_ptestz256 (v4di,v4di,ptest)
v8sf __builtin_ia32_rcpps256 (v8sf)
v4df __builtin_ia32_roundpd256 (v4df,int)
v8sf __builtin_ia32_roundps256 (v8sf,int)
v8sf __builtin_ia32_rsqrtps_nr256 (v8sf)
v8sf __builtin_ia32_rsqrtps256 (v8sf)
v4df __builtin_ia32_shufpd256 (v4df,v4df,int)
v8sf __builtin_ia32_shufps256 (v8sf,v8sf,int)
v4si __builtin_ia32_si_si256 (v8si)
v8si __builtin_ia32_si256_si (v4si)
v4df __builtin_ia32_sqrtpd256 (v4df)
v8sf __builtin_ia32_sqrtps_nr256 (v8sf)
v8sf __builtin_ia32_sqrtps256 (v8sf)
void __builtin_ia32_storedqu256 (pchar,v32qi)
void __builtin_ia32_storeupd256 (pdouble,v4df)
void __builtin_ia32_storeups256 (pfloat,v8sf)
v4df __builtin_ia32_subpd256 (v4df,v4df)
v8sf __builtin_ia32_subps256 (v8sf,v8sf)
v4df __builtin_ia32_unpckhpd256 (v4df,v4df)
v8sf __builtin_ia32_unpckhps256 (v8sf,v8sf)
v4df __builtin_ia32_unpcklpd256 (v4df,v4df)
v8sf __builtin_ia32_unpcklps256 (v8sf,v8sf)
v4df __builtin_ia32_vbroadcastf128_pd256 (pcv2df)
v8sf __builtin_ia32_vbroadcastf128_ps256 (pcv4sf)
v4df __builtin_ia32_vbroadcastsd256 (pcdouble)
v4sf __builtin_ia32_vbroadcastss (pcfloat)
v8sf __builtin_ia32_vbroadcastss256 (pcfloat)
v2df __builtin_ia32_vextractf128_pd256 (v4df,int)
v4sf __builtin_ia32_vextractf128_ps256 (v8sf,int)
v4si __builtin_ia32_vextractf128_si256 (v8si,int)
v4df __builtin_ia32_vinsertf128_pd256 (v4df,v2df,int)
v8sf __builtin_ia32_vinsertf128_ps256 (v8sf,v4sf,int)
v8si __builtin_ia32_vinsertf128_si256 (v8si,v4si,int)
v4df __builtin_ia32_vperm2f128_pd256 (v4df,v4df,int)
v8sf __builtin_ia32_vperm2f128_ps256 (v8sf,v8sf,int)
v8si __builtin_ia32_vperm2f128_si256 (v8si,v8si,int)
v2df __builtin_ia32_vpermil2pd (v2df,v2df,v2di,int)
v4df __builtin_ia32_vpermil2pd256 (v4df,v4df,v4di,int)
v4sf __builtin_ia32_vpermil2ps (v4sf,v4sf,v4si,int)
v8sf __builtin_ia32_vpermil2ps256 (v8sf,v8sf,v8si,int)
v2df __builtin_ia32_vpermilpd (v2df,int)
v4df __builtin_ia32_vpermilpd256 (v4df,int)
v4sf __builtin_ia32_vpermilps (v4sf,int)
v8sf __builtin_ia32_vpermilps256 (v8sf,int)
v2df __builtin_ia32_vpermilvarpd (v2df,v2di)
v4df __builtin_ia32_vpermilvarpd256 (v4df,v4di)
v4sf __builtin_ia32_vpermilvarps (v4sf,v4si)
v8sf __builtin_ia32_vpermilvarps256 (v8sf,v8si)
int __builtin_ia32_vtestcpd (v2df,v2df,ptest)
int __builtin_ia32_vtestcpd256 (v4df,v4df,ptest)
int __builtin_ia32_vtestcps (v4sf,v4sf,ptest)
int __builtin_ia32_vtestcps256 (v8sf,v8sf,ptest)
int __builtin_ia32_vtestnzcpd (v2df,v2df,ptest)
int __builtin_ia32_vtestnzcpd256 (v4df,v4df,ptest)
int __builtin_ia32_vtestnzcps (v4sf,v4sf,ptest)
int __builtin_ia32_vtestnzcps256 (v8sf,v8sf,ptest)
int __builtin_ia32_vtestzpd (v2df,v2df,ptest)
int __builtin_ia32_vtestzpd256 (v4df,v4df,ptest)
int __builtin_ia32_vtestzps (v4sf,v4sf,ptest)
int __builtin_ia32_vtestzps256 (v8sf,v8sf,ptest)
void __builtin_ia32_vzeroall (void)
void __builtin_ia32_vzeroupper (void)
v4df __builtin_ia32_xorpd256 (v4df,v4df)
v8sf __builtin_ia32_xorps256 (v8sf,v8sf)
@end smallexample

The following built-in functions are available when @option{-mavx2} is
used. All of them generate the machine instruction that is part of the
name.

@smallexample
v32qi __builtin_ia32_mpsadbw256 (v32qi,v32qi,int)
v32qi __builtin_ia32_pabsb256 (v32qi)
v16hi __builtin_ia32_pabsw256 (v16hi)
v8si __builtin_ia32_pabsd256 (v8si)
v16hi __builtin_ia32_packssdw256 (v8si,v8si)
v32qi __builtin_ia32_packsswb256 (v16hi,v16hi)
v16hi __builtin_ia32_packusdw256 (v8si,v8si)
v32qi __builtin_ia32_packuswb256 (v16hi,v16hi)
v32qi __builtin_ia32_paddb256 (v32qi,v32qi)
v16hi __builtin_ia32_paddw256 (v16hi,v16hi)
v8si __builtin_ia32_paddd256 (v8si,v8si)
v4di __builtin_ia32_paddq256 (v4di,v4di)
v32qi __builtin_ia32_paddsb256 (v32qi,v32qi)
v16hi __builtin_ia32_paddsw256 (v16hi,v16hi)
v32qi __builtin_ia32_paddusb256 (v32qi,v32qi)
v16hi __builtin_ia32_paddusw256 (v16hi,v16hi)
v4di __builtin_ia32_palignr256 (v4di,v4di,int)
v4di __builtin_ia32_andsi256 (v4di,v4di)
v4di __builtin_ia32_andnotsi256 (v4di,v4di)
v32qi __builtin_ia32_pavgb256 (v32qi,v32qi)
v16hi __builtin_ia32_pavgw256 (v16hi,v16hi)
v32qi __builtin_ia32_pblendvb256 (v32qi,v32qi,v32qi)
v16hi __builtin_ia32_pblendw256 (v16hi,v16hi,int)
v32qi __builtin_ia32_pcmpeqb256 (v32qi,v32qi)
v16hi __builtin_ia32_pcmpeqw256 (v16hi,v16hi)
v8si __builtin_ia32_pcmpeqd256 (c8si,v8si)
v4di __builtin_ia32_pcmpeqq256 (v4di,v4di)
v32qi __builtin_ia32_pcmpgtb256 (v32qi,v32qi)
v16hi __builtin_ia32_pcmpgtw256 (16hi,v16hi)
v8si __builtin_ia32_pcmpgtd256 (v8si,v8si)
v4di __builtin_ia32_pcmpgtq256 (v4di,v4di)
v16hi __builtin_ia32_phaddw256 (v16hi,v16hi)
v8si __builtin_ia32_phaddd256 (v8si,v8si)
v16hi __builtin_ia32_phaddsw256 (v16hi,v16hi)
v16hi __builtin_ia32_phsubw256 (v16hi,v16hi)
v8si __builtin_ia32_phsubd256 (v8si,v8si)
v16hi __builtin_ia32_phsubsw256 (v16hi,v16hi)
v32qi __builtin_ia32_pmaddubsw256 (v32qi,v32qi)
v16hi __builtin_ia32_pmaddwd256 (v16hi,v16hi)
v32qi __builtin_ia32_pmaxsb256 (v32qi,v32qi)
v16hi __builtin_ia32_pmaxsw256 (v16hi,v16hi)
v8si __builtin_ia32_pmaxsd256 (v8si,v8si)
v32qi __builtin_ia32_pmaxub256 (v32qi,v32qi)
v16hi __builtin_ia32_pmaxuw256 (v16hi,v16hi)
v8si __builtin_ia32_pmaxud256 (v8si,v8si)
v32qi __builtin_ia32_pminsb256 (v32qi,v32qi)
v16hi __builtin_ia32_pminsw256 (v16hi,v16hi)
v8si __builtin_ia32_pminsd256 (v8si,v8si)
v32qi __builtin_ia32_pminub256 (v32qi,v32qi)
v16hi __builtin_ia32_pminuw256 (v16hi,v16hi)
v8si __builtin_ia32_pminud256 (v8si,v8si)
int __builtin_ia32_pmovmskb256 (v32qi)
v16hi __builtin_ia32_pmovsxbw256 (v16qi)
v8si __builtin_ia32_pmovsxbd256 (v16qi)
v4di __builtin_ia32_pmovsxbq256 (v16qi)
v8si __builtin_ia32_pmovsxwd256 (v8hi)
v4di __builtin_ia32_pmovsxwq256 (v8hi)
v4di __builtin_ia32_pmovsxdq256 (v4si)
v16hi __builtin_ia32_pmovzxbw256 (v16qi)
v8si __builtin_ia32_pmovzxbd256 (v16qi)
v4di __builtin_ia32_pmovzxbq256 (v16qi)
v8si __builtin_ia32_pmovzxwd256 (v8hi)
v4di __builtin_ia32_pmovzxwq256 (v8hi)
v4di __builtin_ia32_pmovzxdq256 (v4si)
v4di __builtin_ia32_pmuldq256 (v8si,v8si)
v16hi __builtin_ia32_pmulhrsw256 (v16hi, v16hi)
v16hi __builtin_ia32_pmulhuw256 (v16hi,v16hi)
v16hi __builtin_ia32_pmulhw256 (v16hi,v16hi)
v16hi __builtin_ia32_pmullw256 (v16hi,v16hi)
v8si __builtin_ia32_pmulld256 (v8si,v8si)
v4di __builtin_ia32_pmuludq256 (v8si,v8si)
v4di __builtin_ia32_por256 (v4di,v4di)
v16hi __builtin_ia32_psadbw256 (v32qi,v32qi)
v32qi __builtin_ia32_pshufb256 (v32qi,v32qi)
v8si __builtin_ia32_pshufd256 (v8si,int)
v16hi __builtin_ia32_pshufhw256 (v16hi,int)
v16hi __builtin_ia32_pshuflw256 (v16hi,int)
v32qi __builtin_ia32_psignb256 (v32qi,v32qi)
v16hi __builtin_ia32_psignw256 (v16hi,v16hi)
v8si __builtin_ia32_psignd256 (v8si,v8si)
v4di __builtin_ia32_pslldqi256 (v4di,int)
v16hi __builtin_ia32_psllwi256 (16hi,int)
v16hi __builtin_ia32_psllw256(v16hi,v8hi)
v8si __builtin_ia32_pslldi256 (v8si,int)
v8si __builtin_ia32_pslld256(v8si,v4si)
v4di __builtin_ia32_psllqi256 (v4di,int)
v4di __builtin_ia32_psllq256(v4di,v2di)
v16hi __builtin_ia32_psrawi256 (v16hi,int)
v16hi __builtin_ia32_psraw256 (v16hi,v8hi)
v8si __builtin_ia32_psradi256 (v8si,int)
v8si __builtin_ia32_psrad256 (v8si,v4si)
v4di __builtin_ia32_psrldqi256 (v4di, int)
v16hi __builtin_ia32_psrlwi256 (v16hi,int)
v16hi __builtin_ia32_psrlw256 (v16hi,v8hi)
v8si __builtin_ia32_psrldi256 (v8si,int)
v8si __builtin_ia32_psrld256 (v8si,v4si)
v4di __builtin_ia32_psrlqi256 (v4di,int)
v4di __builtin_ia32_psrlq256(v4di,v2di)
v32qi __builtin_ia32_psubb256 (v32qi,v32qi)
v32hi __builtin_ia32_psubw256 (v16hi,v16hi)
v8si __builtin_ia32_psubd256 (v8si,v8si)
v4di __builtin_ia32_psubq256 (v4di,v4di)
v32qi __builtin_ia32_psubsb256 (v32qi,v32qi)
v16hi __builtin_ia32_psubsw256 (v16hi,v16hi)
v32qi __builtin_ia32_psubusb256 (v32qi,v32qi)
v16hi __builtin_ia32_psubusw256 (v16hi,v16hi)
v32qi __builtin_ia32_punpckhbw256 (v32qi,v32qi)
v16hi __builtin_ia32_punpckhwd256 (v16hi,v16hi)
v8si __builtin_ia32_punpckhdq256 (v8si,v8si)
v4di __builtin_ia32_punpckhqdq256 (v4di,v4di)
v32qi __builtin_ia32_punpcklbw256 (v32qi,v32qi)
v16hi __builtin_ia32_punpcklwd256 (v16hi,v16hi)
v8si __builtin_ia32_punpckldq256 (v8si,v8si)
v4di __builtin_ia32_punpcklqdq256 (v4di,v4di)
v4di __builtin_ia32_pxor256 (v4di,v4di)
v4di __builtin_ia32_movntdqa256 (pv4di)
v4sf __builtin_ia32_vbroadcastss_ps (v4sf)
v8sf __builtin_ia32_vbroadcastss_ps256 (v4sf)
v4df __builtin_ia32_vbroadcastsd_pd256 (v2df)
v4di __builtin_ia32_vbroadcastsi256 (v2di)
v4si __builtin_ia32_pblendd128 (v4si,v4si)
v8si __builtin_ia32_pblendd256 (v8si,v8si)
v32qi __builtin_ia32_pbroadcastb256 (v16qi)
v16hi __builtin_ia32_pbroadcastw256 (v8hi)
v8si __builtin_ia32_pbroadcastd256 (v4si)
v4di __builtin_ia32_pbroadcastq256 (v2di)
v16qi __builtin_ia32_pbroadcastb128 (v16qi)
v8hi __builtin_ia32_pbroadcastw128 (v8hi)
v4si __builtin_ia32_pbroadcastd128 (v4si)
v2di __builtin_ia32_pbroadcastq128 (v2di)
v8si __builtin_ia32_permvarsi256 (v8si,v8si)
v4df __builtin_ia32_permdf256 (v4df,int)
v8sf __builtin_ia32_permvarsf256 (v8sf,v8sf)
v4di __builtin_ia32_permdi256 (v4di,int)
v4di __builtin_ia32_permti256 (v4di,v4di,int)
v4di __builtin_ia32_extract128i256 (v4di,int)
v4di __builtin_ia32_insert128i256 (v4di,v2di,int)
v8si __builtin_ia32_maskloadd256 (pcv8si,v8si)
v4di __builtin_ia32_maskloadq256 (pcv4di,v4di)
v4si __builtin_ia32_maskloadd (pcv4si,v4si)
v2di __builtin_ia32_maskloadq (pcv2di,v2di)
void __builtin_ia32_maskstored256 (pv8si,v8si,v8si)
void __builtin_ia32_maskstoreq256 (pv4di,v4di,v4di)
void __builtin_ia32_maskstored (pv4si,v4si,v4si)
void __builtin_ia32_maskstoreq (pv2di,v2di,v2di)
v8si __builtin_ia32_psllv8si (v8si,v8si)
v4si __builtin_ia32_psllv4si (v4si,v4si)
v4di __builtin_ia32_psllv4di (v4di,v4di)
v2di __builtin_ia32_psllv2di (v2di,v2di)
v8si __builtin_ia32_psrav8si (v8si,v8si)
v4si __builtin_ia32_psrav4si (v4si,v4si)
v8si __builtin_ia32_psrlv8si (v8si,v8si)
v4si __builtin_ia32_psrlv4si (v4si,v4si)
v4di __builtin_ia32_psrlv4di (v4di,v4di)
v2di __builtin_ia32_psrlv2di (v2di,v2di)
v2df __builtin_ia32_gathersiv2df (v2df, pcdouble,v4si,v2df,int)
v4df __builtin_ia32_gathersiv4df (v4df, pcdouble,v4si,v4df,int)
v2df __builtin_ia32_gatherdiv2df (v2df, pcdouble,v2di,v2df,int)
v4df __builtin_ia32_gatherdiv4df (v4df, pcdouble,v4di,v4df,int)
v4sf __builtin_ia32_gathersiv4sf (v4sf, pcfloat,v4si,v4sf,int)
v8sf __builtin_ia32_gathersiv8sf (v8sf, pcfloat,v8si,v8sf,int)
v4sf __builtin_ia32_gatherdiv4sf (v4sf, pcfloat,v2di,v4sf,int)
v4sf __builtin_ia32_gatherdiv4sf256 (v4sf, pcfloat,v4di,v4sf,int)
v2di __builtin_ia32_gathersiv2di (v2di, pcint64,v4si,v2di,int)
v4di __builtin_ia32_gathersiv4di (v4di, pcint64,v4si,v4di,int)
v2di __builtin_ia32_gatherdiv2di (v2di, pcint64,v2di,v2di,int)
v4di __builtin_ia32_gatherdiv4di (v4di, pcint64,v4di,v4di,int)
v4si __builtin_ia32_gathersiv4si (v4si, pcint,v4si,v4si,int)
v8si __builtin_ia32_gathersiv8si (v8si, pcint,v8si,v8si,int)
v4si __builtin_ia32_gatherdiv4si (v4si, pcint,v2di,v4si,int)
v4si __builtin_ia32_gatherdiv4si256 (v4si, pcint,v4di,v4si,int)
@end smallexample

The following built-in functions are available when @option{-maes} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
v2di __builtin_ia32_aesenc128 (v2di, v2di)
v2di __builtin_ia32_aesenclast128 (v2di, v2di)
v2di __builtin_ia32_aesdec128 (v2di, v2di)
v2di __builtin_ia32_aesdeclast128 (v2di, v2di)
v2di __builtin_ia32_aeskeygenassist128 (v2di, const int)
v2di __builtin_ia32_aesimc128 (v2di)
@end smallexample

The following built-in function is available when @option{-mpclmul} is
used.

@table @code
@item v2di __builtin_ia32_pclmulqdq128 (v2di, v2di, const int)
Generates the @code{pclmulqdq} machine instruction.
@end table

The following built-in function is available when @option{-mfsgsbase} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
unsigned int __builtin_ia32_rdfsbase32 (void)
unsigned long long __builtin_ia32_rdfsbase64 (void)
unsigned int __builtin_ia32_rdgsbase32 (void)
unsigned long long __builtin_ia32_rdgsbase64 (void)
void _writefsbase_u32 (unsigned int)
void _writefsbase_u64 (unsigned long long)
void _writegsbase_u32 (unsigned int)
void _writegsbase_u64 (unsigned long long)
@end smallexample

The following built-in function is available when @option{-mrdrnd} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
unsigned int __builtin_ia32_rdrand16_step (unsigned short *)
unsigned int __builtin_ia32_rdrand32_step (unsigned int *)
unsigned int __builtin_ia32_rdrand64_step (unsigned long long *)
@end smallexample

The following built-in functions are available when @option{-msse4a} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
void __builtin_ia32_movntsd (double *, v2df)
void __builtin_ia32_movntss (float *, v4sf)
v2di __builtin_ia32_extrq  (v2di, v16qi)
v2di __builtin_ia32_extrqi (v2di, const unsigned int, const unsigned int)
v2di __builtin_ia32_insertq (v2di, v2di)
v2di __builtin_ia32_insertqi (v2di, v2di, const unsigned int, const unsigned int)
@end smallexample

The following built-in functions are available when @option{-mxop} is used.
@smallexample
v2df __builtin_ia32_vfrczpd (v2df)
v4sf __builtin_ia32_vfrczps (v4sf)
v2df __builtin_ia32_vfrczsd (v2df)
v4sf __builtin_ia32_vfrczss (v4sf)
v4df __builtin_ia32_vfrczpd256 (v4df)
v8sf __builtin_ia32_vfrczps256 (v8sf)
v2di __builtin_ia32_vpcmov (v2di, v2di, v2di)
v2di __builtin_ia32_vpcmov_v2di (v2di, v2di, v2di)
v4si __builtin_ia32_vpcmov_v4si (v4si, v4si, v4si)
v8hi __builtin_ia32_vpcmov_v8hi (v8hi, v8hi, v8hi)
v16qi __builtin_ia32_vpcmov_v16qi (v16qi, v16qi, v16qi)
v2df __builtin_ia32_vpcmov_v2df (v2df, v2df, v2df)
v4sf __builtin_ia32_vpcmov_v4sf (v4sf, v4sf, v4sf)
v4di __builtin_ia32_vpcmov_v4di256 (v4di, v4di, v4di)
v8si __builtin_ia32_vpcmov_v8si256 (v8si, v8si, v8si)
v16hi __builtin_ia32_vpcmov_v16hi256 (v16hi, v16hi, v16hi)
v32qi __builtin_ia32_vpcmov_v32qi256 (v32qi, v32qi, v32qi)
v4df __builtin_ia32_vpcmov_v4df256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vpcmov_v8sf256 (v8sf, v8sf, v8sf)
v16qi __builtin_ia32_vpcomeqb (v16qi, v16qi)
v8hi __builtin_ia32_vpcomeqw (v8hi, v8hi)
v4si __builtin_ia32_vpcomeqd (v4si, v4si)
v2di __builtin_ia32_vpcomeqq (v2di, v2di)
v16qi __builtin_ia32_vpcomequb (v16qi, v16qi)
v4si __builtin_ia32_vpcomequd (v4si, v4si)
v2di __builtin_ia32_vpcomequq (v2di, v2di)
v8hi __builtin_ia32_vpcomequw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomeqw (v8hi, v8hi)
v16qi __builtin_ia32_vpcomfalseb (v16qi, v16qi)
v4si __builtin_ia32_vpcomfalsed (v4si, v4si)
v2di __builtin_ia32_vpcomfalseq (v2di, v2di)
v16qi __builtin_ia32_vpcomfalseub (v16qi, v16qi)
v4si __builtin_ia32_vpcomfalseud (v4si, v4si)
v2di __builtin_ia32_vpcomfalseuq (v2di, v2di)
v8hi __builtin_ia32_vpcomfalseuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomfalsew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomgeb (v16qi, v16qi)
v4si __builtin_ia32_vpcomged (v4si, v4si)
v2di __builtin_ia32_vpcomgeq (v2di, v2di)
v16qi __builtin_ia32_vpcomgeub (v16qi, v16qi)
v4si __builtin_ia32_vpcomgeud (v4si, v4si)
v2di __builtin_ia32_vpcomgeuq (v2di, v2di)
v8hi __builtin_ia32_vpcomgeuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomgew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomgtb (v16qi, v16qi)
v4si __builtin_ia32_vpcomgtd (v4si, v4si)
v2di __builtin_ia32_vpcomgtq (v2di, v2di)
v16qi __builtin_ia32_vpcomgtub (v16qi, v16qi)
v4si __builtin_ia32_vpcomgtud (v4si, v4si)
v2di __builtin_ia32_vpcomgtuq (v2di, v2di)
v8hi __builtin_ia32_vpcomgtuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomgtw (v8hi, v8hi)
v16qi __builtin_ia32_vpcomleb (v16qi, v16qi)
v4si __builtin_ia32_vpcomled (v4si, v4si)
v2di __builtin_ia32_vpcomleq (v2di, v2di)
v16qi __builtin_ia32_vpcomleub (v16qi, v16qi)
v4si __builtin_ia32_vpcomleud (v4si, v4si)
v2di __builtin_ia32_vpcomleuq (v2di, v2di)
v8hi __builtin_ia32_vpcomleuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomlew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomltb (v16qi, v16qi)
v4si __builtin_ia32_vpcomltd (v4si, v4si)
v2di __builtin_ia32_vpcomltq (v2di, v2di)
v16qi __builtin_ia32_vpcomltub (v16qi, v16qi)
v4si __builtin_ia32_vpcomltud (v4si, v4si)
v2di __builtin_ia32_vpcomltuq (v2di, v2di)
v8hi __builtin_ia32_vpcomltuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomltw (v8hi, v8hi)
v16qi __builtin_ia32_vpcomneb (v16qi, v16qi)
v4si __builtin_ia32_vpcomned (v4si, v4si)
v2di __builtin_ia32_vpcomneq (v2di, v2di)
v16qi __builtin_ia32_vpcomneub (v16qi, v16qi)
v4si __builtin_ia32_vpcomneud (v4si, v4si)
v2di __builtin_ia32_vpcomneuq (v2di, v2di)
v8hi __builtin_ia32_vpcomneuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomnew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomtrueb (v16qi, v16qi)
v4si __builtin_ia32_vpcomtrued (v4si, v4si)
v2di __builtin_ia32_vpcomtrueq (v2di, v2di)
v16qi __builtin_ia32_vpcomtrueub (v16qi, v16qi)
v4si __builtin_ia32_vpcomtrueud (v4si, v4si)
v2di __builtin_ia32_vpcomtrueuq (v2di, v2di)
v8hi __builtin_ia32_vpcomtrueuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomtruew (v8hi, v8hi)
v4si __builtin_ia32_vphaddbd (v16qi)
v2di __builtin_ia32_vphaddbq (v16qi)
v8hi __builtin_ia32_vphaddbw (v16qi)
v2di __builtin_ia32_vphadddq (v4si)
v4si __builtin_ia32_vphaddubd (v16qi)
v2di __builtin_ia32_vphaddubq (v16qi)
v8hi __builtin_ia32_vphaddubw (v16qi)
v2di __builtin_ia32_vphaddudq (v4si)
v4si __builtin_ia32_vphadduwd (v8hi)
v2di __builtin_ia32_vphadduwq (v8hi)
v4si __builtin_ia32_vphaddwd (v8hi)
v2di __builtin_ia32_vphaddwq (v8hi)
v8hi __builtin_ia32_vphsubbw (v16qi)
v2di __builtin_ia32_vphsubdq (v4si)
v4si __builtin_ia32_vphsubwd (v8hi)
v4si __builtin_ia32_vpmacsdd (v4si, v4si, v4si)
v2di __builtin_ia32_vpmacsdqh (v4si, v4si, v2di)
v2di __builtin_ia32_vpmacsdql (v4si, v4si, v2di)
v4si __builtin_ia32_vpmacssdd (v4si, v4si, v4si)
v2di __builtin_ia32_vpmacssdqh (v4si, v4si, v2di)
v2di __builtin_ia32_vpmacssdql (v4si, v4si, v2di)
v4si __builtin_ia32_vpmacsswd (v8hi, v8hi, v4si)
v8hi __builtin_ia32_vpmacssww (v8hi, v8hi, v8hi)
v4si __builtin_ia32_vpmacswd (v8hi, v8hi, v4si)
v8hi __builtin_ia32_vpmacsww (v8hi, v8hi, v8hi)
v4si __builtin_ia32_vpmadcsswd (v8hi, v8hi, v4si)
v4si __builtin_ia32_vpmadcswd (v8hi, v8hi, v4si)
v16qi __builtin_ia32_vpperm (v16qi, v16qi, v16qi)
v16qi __builtin_ia32_vprotb (v16qi, v16qi)
v4si __builtin_ia32_vprotd (v4si, v4si)
v2di __builtin_ia32_vprotq (v2di, v2di)
v8hi __builtin_ia32_vprotw (v8hi, v8hi)
v16qi __builtin_ia32_vpshab (v16qi, v16qi)
v4si __builtin_ia32_vpshad (v4si, v4si)
v2di __builtin_ia32_vpshaq (v2di, v2di)
v8hi __builtin_ia32_vpshaw (v8hi, v8hi)
v16qi __builtin_ia32_vpshlb (v16qi, v16qi)
v4si __builtin_ia32_vpshld (v4si, v4si)
v2di __builtin_ia32_vpshlq (v2di, v2di)
v8hi __builtin_ia32_vpshlw (v8hi, v8hi)
@end smallexample

The following built-in functions are available when @option{-mfma4} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2df __builtin_ia32_vfmaddpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmaddps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmaddsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmaddss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmsubpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmsubps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmsubsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmsubss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmaddpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmaddps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmaddsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmaddss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmsubpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmsubps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmsubsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmsubss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmaddsubpd  (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmaddsubps  (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmsubaddpd  (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmsubaddps  (v4sf, v4sf, v4sf)
v4df __builtin_ia32_vfmaddpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmaddps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfmsubpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmsubps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfnmaddpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfnmaddps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfnmsubpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfnmsubps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfmaddsubpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmaddsubps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfmsubaddpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmsubaddps256 (v8sf, v8sf, v8sf)

@end smallexample

The following built-in functions are available when @option{-mlwp} is used.

@smallexample
void __builtin_ia32_llwpcb16 (void *);
void __builtin_ia32_llwpcb32 (void *);
void __builtin_ia32_llwpcb64 (void *);
void * __builtin_ia32_llwpcb16 (void);
void * __builtin_ia32_llwpcb32 (void);
void * __builtin_ia32_llwpcb64 (void);
void __builtin_ia32_lwpval16 (unsigned short, unsigned int, unsigned short)
void __builtin_ia32_lwpval32 (unsigned int, unsigned int, unsigned int)
void __builtin_ia32_lwpval64 (unsigned __int64, unsigned int, unsigned int)
unsigned char __builtin_ia32_lwpins16 (unsigned short, unsigned int, unsigned short)
unsigned char __builtin_ia32_lwpins32 (unsigned int, unsigned int, unsigned int)
unsigned char __builtin_ia32_lwpins64 (unsigned __int64, unsigned int, unsigned int)
@end smallexample

The following built-in functions are available when @option{-mbmi} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
unsigned int __builtin_ia32_bextr_u32(unsigned int, unsigned int);
unsigned long long __builtin_ia32_bextr_u64 (unsigned long long, unsigned long long);
@end smallexample

The following built-in functions are available when @option{-mbmi2} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
unsigned int _bzhi_u32 (unsigned int, unsigned int)
unsigned int _pdep_u32 (unsigned int, unsigned int)
unsigned int _pext_u32 (unsigned int, unsigned int)
unsigned long long _bzhi_u64 (unsigned long long, unsigned long long)
unsigned long long _pdep_u64 (unsigned long long, unsigned long long)
unsigned long long _pext_u64 (unsigned long long, unsigned long long)
@end smallexample

The following built-in functions are available when @option{-mlzcnt} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
unsigned short __builtin_ia32_lzcnt_u16(unsigned short);
unsigned int __builtin_ia32_lzcnt_u32(unsigned int);
unsigned long long __builtin_ia32_lzcnt_u64 (unsigned long long);
@end smallexample

The following built-in functions are available when @option{-mfxsr} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_fxsave (void *)
void __builtin_ia32_fxrstor (void *)
void __builtin_ia32_fxsave64 (void *)
void __builtin_ia32_fxrstor64 (void *)
@end smallexample

The following built-in functions are available when @option{-mxsave} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_xsave (void *, long long)
void __builtin_ia32_xrstor (void *, long long)
void __builtin_ia32_xsave64 (void *, long long)
void __builtin_ia32_xrstor64 (void *, long long)
@end smallexample

The following built-in functions are available when @option{-mxsaveopt} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_xsaveopt (void *, long long)
void __builtin_ia32_xsaveopt64 (void *, long long)
@end smallexample

The following built-in functions are available when @option{-mtbm} is used.
Both of them generate the immediate form of the bextr machine instruction.
@smallexample
unsigned int __builtin_ia32_bextri_u32 (unsigned int,
                                        const unsigned int);
unsigned long long __builtin_ia32_bextri_u64 (unsigned long long,
                                              const unsigned long long);
@end smallexample


The following built-in functions are available when @option{-m3dnow} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
void __builtin_ia32_femms (void)
v8qi __builtin_ia32_pavgusb (v8qi, v8qi)
v2si __builtin_ia32_pf2id (v2sf)
v2sf __builtin_ia32_pfacc (v2sf, v2sf)
v2sf __builtin_ia32_pfadd (v2sf, v2sf)
v2si __builtin_ia32_pfcmpeq (v2sf, v2sf)
v2si __builtin_ia32_pfcmpge (v2sf, v2sf)
v2si __builtin_ia32_pfcmpgt (v2sf, v2sf)
v2sf __builtin_ia32_pfmax (v2sf, v2sf)
v2sf __builtin_ia32_pfmin (v2sf, v2sf)
v2sf __builtin_ia32_pfmul (v2sf, v2sf)
v2sf __builtin_ia32_pfrcp (v2sf)
v2sf __builtin_ia32_pfrcpit1 (v2sf, v2sf)
v2sf __builtin_ia32_pfrcpit2 (v2sf, v2sf)
v2sf __builtin_ia32_pfrsqrt (v2sf)
v2sf __builtin_ia32_pfsub (v2sf, v2sf)
v2sf __builtin_ia32_pfsubr (v2sf, v2sf)
v2sf __builtin_ia32_pi2fd (v2si)
v4hi __builtin_ia32_pmulhrw (v4hi, v4hi)
@end smallexample

The following built-in functions are available when @option{-m3dnowa} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2si __builtin_ia32_pf2iw (v2sf)
v2sf __builtin_ia32_pfnacc (v2sf, v2sf)
v2sf __builtin_ia32_pfpnacc (v2sf, v2sf)
v2sf __builtin_ia32_pi2fw (v2si)
v2sf __builtin_ia32_pswapdsf (v2sf)
v2si __builtin_ia32_pswapdsi (v2si)
@end smallexample

The following built-in functions are available when @option{-mrtm} is used
They are used for restricted transactional memory. These are the internal
low level functions. Normally the functions in 
@ref{x86 transactional memory intrinsics} should be used instead.

@smallexample
int __builtin_ia32_xbegin ()
void __builtin_ia32_xend ()
void __builtin_ia32_xabort (status)
int __builtin_ia32_xtest ()
@end smallexample

The following built-in functions are available when @option{-mmwaitx} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_monitorx (void *, unsigned int, unsigned int)
void __builtin_ia32_mwaitx (unsigned int, unsigned int, unsigned int)
@end smallexample

The following built-in functions are available when @option{-mclzero} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_i32_clzero (void *)
@end smallexample

The following built-in functions are available when @option{-mpku} is used.
They generate reads and writes to PKRU.
@smallexample
void __builtin_ia32_wrpkru (unsigned int)
unsigned int __builtin_ia32_rdpkru ()
@end smallexample

@node x86 transactional memory intrinsics
@subsection x86 Transactional Memory Intrinsics

These hardware transactional memory intrinsics for x86 allow you to use
memory transactions with RTM (Restricted Transactional Memory).
This support is enabled with the @option{-mrtm} option.
For using HLE (Hardware Lock Elision) see 
@ref{x86 specific memory model extensions for transactional memory} instead.

A memory transaction commits all changes to memory in an atomic way,
as visible to other threads. If the transaction fails it is rolled back
and all side effects discarded.

Generally there is no guarantee that a memory transaction ever succeeds
and suitable fallback code always needs to be supplied.

@deftypefn {RTM Function} {unsigned} _xbegin ()
Start a RTM (Restricted Transactional Memory) transaction. 
Returns @code{_XBEGIN_STARTED} when the transaction
started successfully (note this is not 0, so the constant has to be 
explicitly tested).  

If the transaction aborts, all side-effects 
are undone and an abort code encoded as a bit mask is returned.
The following macros are defined:

@table @code
@item _XABORT_EXPLICIT
Transaction was explicitly aborted with @code{_xabort}.  The parameter passed
to @code{_xabort} is available with @code{_XABORT_CODE(status)}.
@item _XABORT_RETRY
Transaction retry is possible.
@item _XABORT_CONFLICT
Transaction abort due to a memory conflict with another thread.
@item _XABORT_CAPACITY
Transaction abort due to the transaction using too much memory.
@item _XABORT_DEBUG
Transaction abort due to a debug trap.
@item _XABORT_NESTED
Transaction abort in an inner nested transaction.
@end table

There is no guarantee
any transaction ever succeeds, so there always needs to be a valid
fallback path.
@end deftypefn

@deftypefn {RTM Function} {void} _xend ()
Commit the current transaction. When no transaction is active this faults.
All memory side-effects of the transaction become visible
to other threads in an atomic manner.
@end deftypefn

@deftypefn {RTM Function} {int} _xtest ()
Return a nonzero value if a transaction is currently active, otherwise 0.
@end deftypefn

@deftypefn {RTM Function} {void} _xabort (status)
Abort the current transaction. When no transaction is active this is a no-op.
The @var{status} is an 8-bit constant; its value is encoded in the return 
value from @code{_xbegin}.
@end deftypefn

Here is an example showing handling for @code{_XABORT_RETRY}
and a fallback path for other failures:

@smallexample
#include <immintrin.h>

int n_tries, max_tries;
unsigned status = _XABORT_EXPLICIT;
...

for (n_tries = 0; n_tries < max_tries; n_tries++) 
  @{
    status = _xbegin ();
    if (status == _XBEGIN_STARTED || !(status & _XABORT_RETRY))
      break;
  @}
if (status == _XBEGIN_STARTED) 
  @{
    ... transaction code...
    _xend ();
  @} 
else 
  @{
    ... non-transactional fallback path...
  @}
@end smallexample

@noindent
Note that, in most cases, the transactional and non-transactional code
must synchronize together to ensure consistency.

@node Target Format Checks
@section Format Checks Specific to Particular Target Machines

For some target machines, GCC supports additional options to the
format attribute
(@pxref{Function Attributes,,Declaring Attributes of Functions}).

@menu
* Solaris Format Checks::
* Darwin Format Checks::
@end menu

@node Solaris Format Checks
@subsection Solaris Format Checks

Solaris targets support the @code{cmn_err} (or @code{__cmn_err__}) format
check.  @code{cmn_err} accepts a subset of the standard @code{printf}
conversions, and the two-argument @code{%b} conversion for displaying
bit-fields.  See the Solaris man page for @code{cmn_err} for more information.

@node Darwin Format Checks
@subsection Darwin Format Checks

Darwin targets support the @code{CFString} (or @code{__CFString__}) in the format
attribute context.  Declarations made with such attribution are parsed for correct syntax
and format argument types.  However, parsing of the format string itself is currently undefined
and is not carried out by this version of the compiler.

Additionally, @code{CFStringRefs} (defined by the @code{CoreFoundation} headers) may
also be used as format arguments.  Note that the relevant headers are only likely to be
available on Darwin (OSX) installations.  On such installations, the XCode and system
documentation provide descriptions of @code{CFString}, @code{CFStringRefs} and
associated functions.

@node Pragmas
@section Pragmas Accepted by GCC
@cindex pragmas
@cindex @code{#pragma}

GCC supports several types of pragmas, primarily in order to compile
code originally written for other compilers.  Note that in general
we do not recommend the use of pragmas; @xref{Function Attributes},
for further explanation.

@menu
* AArch64 Pragmas::
* ARM Pragmas::
* M32C Pragmas::
* MeP Pragmas::
* RS/6000 and PowerPC Pragmas::
* S/390 Pragmas::
* Darwin Pragmas::
* Solaris Pragmas::
* Symbol-Renaming Pragmas::
* Structure-Layout Pragmas::
* Weak Pragmas::
* Diagnostic Pragmas::
* Visibility Pragmas::
* Push/Pop Macro Pragmas::
* Function Specific Option Pragmas::
* Loop-Specific Pragmas::
@end menu

@node AArch64 Pragmas
@subsection AArch64 Pragmas

The pragmas defined by the AArch64 target correspond to the AArch64
target function attributes.  They can be specified as below:
@smallexample
#pragma GCC target("string")
@end smallexample

where @code{@var{string}} can be any string accepted as an AArch64 target
attribute.  @xref{AArch64 Function Attributes}, for more details
on the permissible values of @code{string}.

@node ARM Pragmas
@subsection ARM Pragmas

The ARM target defines pragmas for controlling the default addition of
@code{long_call} and @code{short_call} attributes to functions.
@xref{Function Attributes}, for information about the effects of these
attributes.

@table @code
@item long_calls
@cindex pragma, long_calls
Set all subsequent functions to have the @code{long_call} attribute.

@item no_long_calls
@cindex pragma, no_long_calls
Set all subsequent functions to have the @code{short_call} attribute.

@item long_calls_off
@cindex pragma, long_calls_off
Do not affect the @code{long_call} or @code{short_call} attributes of
subsequent functions.
@end table

@node M32C Pragmas
@subsection M32C Pragmas

@table @code
@item GCC memregs @var{number}
@cindex pragma, memregs
Overrides the command-line option @code{-memregs=} for the current
file.  Use with care!  This pragma must be before any function in the
file, and mixing different memregs values in different objects may
make them incompatible.  This pragma is useful when a
performance-critical function uses a memreg for temporary values,
as it may allow you to reduce the number of memregs used.

@item ADDRESS @var{name} @var{address}
@cindex pragma, address
For any declared symbols matching @var{name}, this does three things
to that symbol: it forces the symbol to be located at the given
address (a number), it forces the symbol to be volatile, and it
changes the symbol's scope to be static.  This pragma exists for
compatibility with other compilers, but note that the common
@code{1234H} numeric syntax is not supported (use @code{0x1234}
instead).  Example:

@smallexample
#pragma ADDRESS port3 0x103
char port3;
@end smallexample

@end table

@node MeP Pragmas
@subsection MeP Pragmas

@table @code

@item custom io_volatile (on|off)
@cindex pragma, custom io_volatile
Overrides the command-line option @code{-mio-volatile} for the current
file.  Note that for compatibility with future GCC releases, this
option should only be used once before any @code{io} variables in each
file.

@item GCC coprocessor available @var{registers}
@cindex pragma, coprocessor available
Specifies which coprocessor registers are available to the register
allocator.  @var{registers} may be a single register, register range
separated by ellipses, or comma-separated list of those.  Example:

@smallexample
#pragma GCC coprocessor available $c0...$c10, $c28
@end smallexample

@item GCC coprocessor call_saved @var{registers}
@cindex pragma, coprocessor call_saved
Specifies which coprocessor registers are to be saved and restored by
any function using them.  @var{registers} may be a single register,
register range separated by ellipses, or comma-separated list of
those.  Example:

@smallexample
#pragma GCC coprocessor call_saved $c4...$c6, $c31
@end smallexample

@item GCC coprocessor subclass '(A|B|C|D)' = @var{registers}
@cindex pragma, coprocessor subclass
Creates and defines a register class.  These register classes can be
used by inline @code{asm} constructs.  @var{registers} may be a single
register, register range separated by ellipses, or comma-separated
list of those.  Example:

@smallexample
#pragma GCC coprocessor subclass 'B' = $c2, $c4, $c6

asm ("cpfoo %0" : "=B" (x));
@end smallexample

@item GCC disinterrupt @var{name} , @var{name} @dots{}
@cindex pragma, disinterrupt
For the named functions, the compiler adds code to disable interrupts
for the duration of those functions.  If any functions so named 
are not encountered in the source, a warning is emitted that the pragma is
not used.  Examples:

@smallexample
#pragma disinterrupt foo
#pragma disinterrupt bar, grill
int foo () @{ @dots{} @}
@end smallexample

@item GCC call @var{name} , @var{name} @dots{}
@cindex pragma, call
For the named functions, the compiler always uses a register-indirect
call model when calling the named functions.  Examples:

@smallexample
extern int foo ();
#pragma call foo
@end smallexample

@end table

@node RS/6000 and PowerPC Pragmas
@subsection RS/6000 and PowerPC Pragmas

The RS/6000 and PowerPC targets define one pragma for controlling
whether or not the @code{longcall} attribute is added to function
declarations by default.  This pragma overrides the @option{-mlongcall}
option, but not the @code{longcall} and @code{shortcall} attributes.
@xref{RS/6000 and PowerPC Options}, for more information about when long
calls are and are not necessary.

@table @code
@item longcall (1)
@cindex pragma, longcall
Apply the @code{longcall} attribute to all subsequent function
declarations.

@item longcall (0)
Do not apply the @code{longcall} attribute to subsequent function
declarations.
@end table

@c Describe h8300 pragmas here.
@c Describe sh pragmas here.
@c Describe v850 pragmas here.

@node S/390 Pragmas
@subsection S/390 Pragmas

The pragmas defined by the S/390 target correspond to the S/390
target function attributes and some the additional options:

@table @samp
@item zvector
@itemx no-zvector
@end table

Note that options of the pragma, unlike options of the target
attribute, do change the value of preprocessor macros like
@code{__VEC__}.  They can be specified as below:

@smallexample
#pragma GCC target("string[,string]...")
#pragma GCC target("string"[,"string"]...)
@end smallexample

@node Darwin Pragmas
@subsection Darwin Pragmas

The following pragmas are available for all architectures running the
Darwin operating system.  These are useful for compatibility with other
Mac OS compilers.

@table @code
@item mark @var{tokens}@dots{}
@cindex pragma, mark
This pragma is accepted, but has no effect.

@item options align=@var{alignment}
@cindex pragma, options align
This pragma sets the alignment of fields in structures.  The values of
@var{alignment} may be @code{mac68k}, to emulate m68k alignment, or
@code{power}, to emulate PowerPC alignment.  Uses of this pragma nest
properly; to restore the previous setting, use @code{reset} for the
@var{alignment}.

@item segment @var{tokens}@dots{}
@cindex pragma, segment
This pragma is accepted, but has no effect.

@item unused (@var{var} [, @var{var}]@dots{})
@cindex pragma, unused
This pragma declares variables to be possibly unused.  GCC does not
produce warnings for the listed variables.  The effect is similar to
that of the @code{unused} attribute, except that this pragma may appear
anywhere within the variables' scopes.
@end table

@node Solaris Pragmas
@subsection Solaris Pragmas

The Solaris target supports @code{#pragma redefine_extname}
(@pxref{Symbol-Renaming Pragmas}).  It also supports additional
@code{#pragma} directives for compatibility with the system compiler.

@table @code
@item align @var{alignment} (@var{variable} [, @var{variable}]...)
@cindex pragma, align

Increase the minimum alignment of each @var{variable} to @var{alignment}.
This is the same as GCC's @code{aligned} attribute @pxref{Variable
Attributes}).  Macro expansion occurs on the arguments to this pragma
when compiling C and Objective-C@.  It does not currently occur when
compiling C++, but this is a bug which may be fixed in a future
release.

@item fini (@var{function} [, @var{function}]...)
@cindex pragma, fini

This pragma causes each listed @var{function} to be called after
main, or during shared module unloading, by adding a call to the
@code{.fini} section.

@item init (@var{function} [, @var{function}]...)
@cindex pragma, init

This pragma causes each listed @var{function} to be called during
initialization (before @code{main}) or during shared module loading, by
adding a call to the @code{.init} section.

@end table

@node Symbol-Renaming Pragmas
@subsection Symbol-Renaming Pragmas

GCC supports a @code{#pragma} directive that changes the name used in
assembly for a given declaration. While this pragma is supported on all
platforms, it is intended primarily to provide compatibility with the
Solaris system headers. This effect can also be achieved using the asm
labels extension (@pxref{Asm Labels}).

@table @code
@item redefine_extname @var{oldname} @var{newname}
@cindex pragma, redefine_extname

This pragma gives the C function @var{oldname} the assembly symbol
@var{newname}.  The preprocessor macro @code{__PRAGMA_REDEFINE_EXTNAME}
is defined if this pragma is available (currently on all platforms).
@end table

This pragma and the asm labels extension interact in a complicated
manner.  Here are some corner cases you may want to be aware of:

@enumerate
@item This pragma silently applies only to declarations with external
linkage.  Asm labels do not have this restriction.

@item In C++, this pragma silently applies only to declarations with
``C'' linkage.  Again, asm labels do not have this restriction.

@item If either of the ways of changing the assembly name of a
declaration are applied to a declaration whose assembly name has
already been determined (either by a previous use of one of these
features, or because the compiler needed the assembly name in order to
generate code), and the new name is different, a warning issues and
the name does not change.

@item The @var{oldname} used by @code{#pragma redefine_extname} is
always the C-language name.
@end enumerate

@node Structure-Layout Pragmas
@subsection Structure-Layout Pragmas

For compatibility with Microsoft Windows compilers, GCC supports a
set of @code{#pragma} directives that change the maximum alignment of
members of structures (other than zero-width bit-fields), unions, and
classes subsequently defined. The @var{n} value below always is required
to be a small power of two and specifies the new alignment in bytes.

@enumerate
@item @code{#pragma pack(@var{n})} simply sets the new alignment.
@item @code{#pragma pack()} sets the alignment to the one that was in
effect when compilation started (see also command-line option
@option{-fpack-struct[=@var{n}]} @pxref{Code Gen Options}).
@item @code{#pragma pack(push[,@var{n}])} pushes the current alignment
setting on an internal stack and then optionally sets the new alignment.
@item @code{#pragma pack(pop)} restores the alignment setting to the one
saved at the top of the internal stack (and removes that stack entry).
Note that @code{#pragma pack([@var{n}])} does not influence this internal
stack; thus it is possible to have @code{#pragma pack(push)} followed by
multiple @code{#pragma pack(@var{n})} instances and finalized by a single
@code{#pragma pack(pop)}.
@end enumerate

Some targets, e.g.@: x86 and PowerPC, support the @code{#pragma ms_struct}
directive which lays out structures and unions subsequently defined as the
documented @code{__attribute__ ((ms_struct))}.

@enumerate
@item @code{#pragma ms_struct on} turns on the Microsoft layout.
@item @code{#pragma ms_struct off} turns off the Microsoft layout.
@item @code{#pragma ms_struct reset} goes back to the default layout.
@end enumerate

Most targets also support the @code{#pragma scalar_storage_order} directive
which lays out structures and unions subsequently defined as the documented
@code{__attribute__ ((scalar_storage_order))}.

@enumerate
@item @code{#pragma scalar_storage_order big-endian} sets the storage order
of the scalar fields to big-endian.
@item @code{#pragma scalar_storage_order little-endian} sets the storage order
of the scalar fields to little-endian.
@item @code{#pragma scalar_storage_order default} goes back to the endianness
that was in effect when compilation started (see also command-line option
@option{-fsso-struct=@var{endianness}} @pxref{C Dialect Options}).
@end enumerate

@node Weak Pragmas
@subsection Weak Pragmas

For compatibility with SVR4, GCC supports a set of @code{#pragma}
directives for declaring symbols to be weak, and defining weak
aliases.

@table @code
@item #pragma weak @var{symbol}
@cindex pragma, weak
This pragma declares @var{symbol} to be weak, as if the declaration
had the attribute of the same name.  The pragma may appear before
or after the declaration of @var{symbol}.  It is not an error for
@var{symbol} to never be defined at all.

@item #pragma weak @var{symbol1} = @var{symbol2}
This pragma declares @var{symbol1} to be a weak alias of @var{symbol2}.
It is an error if @var{symbol2} is not defined in the current
translation unit.
@end table

@node Diagnostic Pragmas
@subsection Diagnostic Pragmas

GCC allows the user to selectively enable or disable certain types of
diagnostics, and change the kind of the diagnostic.  For example, a
project's policy might require that all sources compile with
@option{-Werror} but certain files might have exceptions allowing
specific types of warnings.  Or, a project might selectively enable
diagnostics and treat them as errors depending on which preprocessor
macros are defined.

@table @code
@item #pragma GCC diagnostic @var{kind} @var{option}
@cindex pragma, diagnostic

Modifies the disposition of a diagnostic.  Note that not all
diagnostics are modifiable; at the moment only warnings (normally
controlled by @samp{-W@dots{}}) can be controlled, and not all of them.
Use @option{-fdiagnostics-show-option} to determine which diagnostics
are controllable and which option controls them.

@var{kind} is @samp{error} to treat this diagnostic as an error,
@samp{warning} to treat it like a warning (even if @option{-Werror} is
in effect), or @samp{ignored} if the diagnostic is to be ignored.
@var{option} is a double quoted string that matches the command-line
option.

@smallexample
#pragma GCC diagnostic warning "-Wformat"
#pragma GCC diagnostic error "-Wformat"
#pragma GCC diagnostic ignored "-Wformat"
@end smallexample

Note that these pragmas override any command-line options.  GCC keeps
track of the location of each pragma, and issues diagnostics according
to the state as of that point in the source file.  Thus, pragmas occurring
after a line do not affect diagnostics caused by that line.

@item #pragma GCC diagnostic push
@itemx #pragma GCC diagnostic pop

Causes GCC to remember the state of the diagnostics as of each
@code{push}, and restore to that point at each @code{pop}.  If a
@code{pop} has no matching @code{push}, the command-line options are
restored.

@smallexample
#pragma GCC diagnostic error "-Wuninitialized"
  foo(a);                       /* error is given for this one */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
  foo(b);                       /* no diagnostic for this one */
#pragma GCC diagnostic pop
  foo(c);                       /* error is given for this one */
#pragma GCC diagnostic pop
  foo(d);                       /* depends on command-line options */
@end smallexample

@end table

GCC also offers a simple mechanism for printing messages during
compilation.

@table @code
@item #pragma message @var{string}
@cindex pragma, diagnostic

Prints @var{string} as a compiler message on compilation.  The message
is informational only, and is neither a compilation warning nor an error.

@smallexample
#pragma message "Compiling " __FILE__ "..."
@end smallexample

@var{string} may be parenthesized, and is printed with location
information.  For example,

@smallexample
#define DO_PRAGMA(x) _Pragma (#x)
#define TODO(x) DO_PRAGMA(message ("TODO - " #x))

TODO(Remember to fix this)
@end smallexample

@noindent
prints @samp{/tmp/file.c:4: note: #pragma message:
TODO - Remember to fix this}.

@end table

@node Visibility Pragmas
@subsection Visibility Pragmas

@table @code
@item #pragma GCC visibility push(@var{visibility})
@itemx #pragma GCC visibility pop
@cindex pragma, visibility

This pragma allows the user to set the visibility for multiple
declarations without having to give each a visibility attribute
(@pxref{Function Attributes}).

In C++, @samp{#pragma GCC visibility} affects only namespace-scope
declarations.  Class members and template specializations are not
affected; if you want to override the visibility for a particular
member or instantiation, you must use an attribute.

@end table


@node Push/Pop Macro Pragmas
@subsection Push/Pop Macro Pragmas

For compatibility with Microsoft Windows compilers, GCC supports
@samp{#pragma push_macro(@var{"macro_name"})}
and @samp{#pragma pop_macro(@var{"macro_name"})}.

@table @code
@item #pragma push_macro(@var{"macro_name"})
@cindex pragma, push_macro
This pragma saves the value of the macro named as @var{macro_name} to
the top of the stack for this macro.

@item #pragma pop_macro(@var{"macro_name"})
@cindex pragma, pop_macro
This pragma sets the value of the macro named as @var{macro_name} to
the value on top of the stack for this macro. If the stack for
@var{macro_name} is empty, the value of the macro remains unchanged.
@end table

For example:

@smallexample
#define X  1
#pragma push_macro("X")
#undef X
#define X -1
#pragma pop_macro("X")
int x [X];
@end smallexample

@noindent
In this example, the definition of X as 1 is saved by @code{#pragma
push_macro} and restored by @code{#pragma pop_macro}.

@node Function Specific Option Pragmas
@subsection Function Specific Option Pragmas

@table @code
@item #pragma GCC target (@var{"string"}...)
@cindex pragma GCC target

This pragma allows you to set target specific options for functions
defined later in the source file.  One or more strings can be
specified.  Each function that is defined after this point is as
if @code{attribute((target("STRING")))} was specified for that
function.  The parenthesis around the options is optional.
@xref{Function Attributes}, for more information about the
@code{target} attribute and the attribute syntax.

The @code{#pragma GCC target} pragma is presently implemented for
x86, PowerPC, and Nios II targets only.
@end table

@table @code
@item #pragma GCC optimize (@var{"string"}...)
@cindex pragma GCC optimize

This pragma allows you to set global optimization options for functions
defined later in the source file.  One or more strings can be
specified.  Each function that is defined after this point is as
if @code{attribute((optimize("STRING")))} was specified for that
function.  The parenthesis around the options is optional.
@xref{Function Attributes}, for more information about the
@code{optimize} attribute and the attribute syntax.
@end table

@table @code
@item #pragma GCC push_options
@itemx #pragma GCC pop_options
@cindex pragma GCC push_options
@cindex pragma GCC pop_options

These pragmas maintain a stack of the current target and optimization
options.  It is intended for include files where you temporarily want
to switch to using a different @samp{#pragma GCC target} or
@samp{#pragma GCC optimize} and then to pop back to the previous
options.
@end table

@table @code
@item #pragma GCC reset_options
@cindex pragma GCC reset_options

This pragma clears the current @code{#pragma GCC target} and
@code{#pragma GCC optimize} to use the default switches as specified
on the command line.
@end table

@node Loop-Specific Pragmas
@subsection Loop-Specific Pragmas

@table @code
@item #pragma GCC ivdep
@cindex pragma GCC ivdep
@end table

With this pragma, the programmer asserts that there are no loop-carried
dependencies which would prevent consecutive iterations of
the following loop from executing concurrently with SIMD
(single instruction multiple data) instructions.

For example, the compiler can only unconditionally vectorize the following
loop with the pragma:

@smallexample
void foo (int n, int *a, int *b, int *c)
@{
  int i, j;
#pragma GCC ivdep
  for (i = 0; i < n; ++i)
    a[i] = b[i] + c[i];
@}
@end smallexample

@noindent
In this example, using the @code{restrict} qualifier had the same
effect. In the following example, that would not be possible. Assume
@math{k < -m} or @math{k >= m}. Only with the pragma, the compiler knows
that it can unconditionally vectorize the following loop:

@smallexample
void ignore_vec_dep (int *a, int k, int c, int m)
@{
#pragma GCC ivdep
  for (int i = 0; i < m; i++)
    a[i] = a[i + k] * c;
@}
@end smallexample


@node Unnamed Fields
@section Unnamed Structure and Union Fields
@cindex @code{struct}
@cindex @code{union}

As permitted by ISO C11 and for compatibility with other compilers,
GCC allows you to define
a structure or union that contains, as fields, structures and unions
without names.  For example:

@smallexample
struct @{
  int a;
  union @{
    int b;
    float c;
  @};
  int d;
@} foo;
@end smallexample

@noindent
In this example, you are able to access members of the unnamed
union with code like @samp{foo.b}.  Note that only unnamed structs and
unions are allowed, you may not have, for example, an unnamed
@code{int}.

You must never create such structures that cause ambiguous field definitions.
For example, in this structure:

@smallexample
struct @{
  int a;
  struct @{
    int a;
  @};
@} foo;
@end smallexample

@noindent
it is ambiguous which @code{a} is being referred to with @samp{foo.a}.
The compiler gives errors for such constructs.

@opindex fms-extensions
Unless @option{-fms-extensions} is used, the unnamed field must be a
structure or union definition without a tag (for example, @samp{struct
@{ int a; @};}).  If @option{-fms-extensions} is used, the field may
also be a definition with a tag such as @samp{struct foo @{ int a;
@};}, a reference to a previously defined structure or union such as
@samp{struct foo;}, or a reference to a @code{typedef} name for a
previously defined structure or union type.

@opindex fplan9-extensions
The option @option{-fplan9-extensions} enables
@option{-fms-extensions} as well as two other extensions.  First, a
pointer to a structure is automatically converted to a pointer to an
anonymous field for assignments and function calls.  For example:

@smallexample
struct s1 @{ int a; @};
struct s2 @{ struct s1; @};
extern void f1 (struct s1 *);
void f2 (struct s2 *p) @{ f1 (p); @}
@end smallexample

@noindent
In the call to @code{f1} inside @code{f2}, the pointer @code{p} is
converted into a pointer to the anonymous field.

Second, when the type of an anonymous field is a @code{typedef} for a
@code{struct} or @code{union}, code may refer to the field using the
name of the @code{typedef}.

@smallexample
typedef struct @{ int a; @} s1;
struct s2 @{ s1; @};
s1 f1 (struct s2 *p) @{ return p->s1; @}
@end smallexample

These usages are only permitted when they are not ambiguous.

@node Thread-Local
@section Thread-Local Storage
@cindex Thread-Local Storage
@cindex @acronym{TLS}
@cindex @code{__thread}

Thread-local storage (@acronym{TLS}) is a mechanism by which variables
are allocated such that there is one instance of the variable per extant
thread.  The runtime model GCC uses to implement this originates
in the IA-64 processor-specific ABI, but has since been migrated
to other processors as well.  It requires significant support from
the linker (@command{ld}), dynamic linker (@command{ld.so}), and
system libraries (@file{libc.so} and @file{libpthread.so}), so it
is not available everywhere.

At the user level, the extension is visible with a new storage
class keyword: @code{__thread}.  For example:

@smallexample
__thread int i;
extern __thread struct state s;
static __thread char *p;
@end smallexample

The @code{__thread} specifier may be used alone, with the @code{extern}
or @code{static} specifiers, but with no other storage class specifier.
When used with @code{extern} or @code{static}, @code{__thread} must appear
immediately after the other storage class specifier.

The @code{__thread} specifier may be applied to any global, file-scoped
static, function-scoped static, or static data member of a class.  It may
not be applied to block-scoped automatic or non-static data member.

When the address-of operator is applied to a thread-local variable, it is
evaluated at run time and returns the address of the current thread's
instance of that variable.  An address so obtained may be used by any
thread.  When a thread terminates, any pointers to thread-local variables
in that thread become invalid.

No static initialization may refer to the address of a thread-local variable.

In C++, if an initializer is present for a thread-local variable, it must
be a @var{constant-expression}, as defined in 5.19.2 of the ANSI/ISO C++
standard.

See @uref{https://www.akkadia.org/drepper/tls.pdf,
ELF Handling For Thread-Local Storage} for a detailed explanation of
the four thread-local storage addressing models, and how the runtime
is expected to function.

@menu
* C99 Thread-Local Edits::
* C++98 Thread-Local Edits::
@end menu

@node C99 Thread-Local Edits
@subsection ISO/IEC 9899:1999 Edits for Thread-Local Storage

The following are a set of changes to ISO/IEC 9899:1999 (aka C99)
that document the exact semantics of the language extension.

@itemize @bullet
@item
@cite{5.1.2  Execution environments}

Add new text after paragraph 1

@quotation
Within either execution environment, a @dfn{thread} is a flow of
control within a program.  It is implementation defined whether
or not there may be more than one thread associated with a program.
It is implementation defined how threads beyond the first are
created, the name and type of the function called at thread
startup, and how threads may be terminated.  However, objects
with thread storage duration shall be initialized before thread
startup.
@end quotation

@item
@cite{6.2.4  Storage durations of objects}

Add new text before paragraph 3

@quotation
An object whose identifier is declared with the storage-class
specifier @w{@code{__thread}} has @dfn{thread storage duration}.
Its lifetime is the entire execution of the thread, and its
stored value is initialized only once, prior to thread startup.
@end quotation

@item
@cite{6.4.1  Keywords}

Add @code{__thread}.

@item
@cite{6.7.1  Storage-class specifiers}

Add @code{__thread} to the list of storage class specifiers in
paragraph 1.

Change paragraph 2 to

@quotation
With the exception of @code{__thread}, at most one storage-class
specifier may be given [@dots{}].  The @code{__thread} specifier may
be used alone, or immediately following @code{extern} or
@code{static}.
@end quotation

Add new text after paragraph 6

@quotation
The declaration of an identifier for a variable that has
block scope that specifies @code{__thread} shall also
specify either @code{extern} or @code{static}.

The @code{__thread} specifier shall be used only with
variables.
@end quotation
@end itemize

@node C++98 Thread-Local Edits
@subsection ISO/IEC 14882:1998 Edits for Thread-Local Storage

The following are a set of changes to ISO/IEC 14882:1998 (aka C++98)
that document the exact semantics of the language extension.

@itemize @bullet
@item
@b{[intro.execution]}

New text after paragraph 4

@quotation
A @dfn{thread} is a flow of control within the abstract machine.
It is implementation defined whether or not there may be more than
one thread.
@end quotation

New text after paragraph 7

@quotation
It is unspecified whether additional action must be taken to
ensure when and whether side effects are visible to other threads.
@end quotation

@item
@b{[lex.key]}

Add @code{__thread}.

@item
@b{[basic.start.main]}

Add after paragraph 5

@quotation
The thread that begins execution at the @code{main} function is called
the @dfn{main thread}.  It is implementation defined how functions
beginning threads other than the main thread are designated or typed.
A function so designated, as well as the @code{main} function, is called
a @dfn{thread startup function}.  It is implementation defined what
happens if a thread startup function returns.  It is implementation
defined what happens to other threads when any thread calls @code{exit}.
@end quotation

@item
@b{[basic.start.init]}

Add after paragraph 4

@quotation
The storage for an object of thread storage duration shall be
statically initialized before the first statement of the thread startup
function.  An object of thread storage duration shall not require
dynamic initialization.
@end quotation

@item
@b{[basic.start.term]}

Add after paragraph 3

@quotation
The type of an object with thread storage duration shall not have a
non-trivial destructor, nor shall it be an array type whose elements
(directly or indirectly) have non-trivial destructors.
@end quotation

@item
@b{[basic.stc]}

Add ``thread storage duration'' to the list in paragraph 1.

Change paragraph 2

@quotation
Thread, static, and automatic storage durations are associated with
objects introduced by declarations [@dots{}].
@end quotation

Add @code{__thread} to the list of specifiers in paragraph 3.

@item
@b{[basic.stc.thread]}

New section before @b{[basic.stc.static]}

@quotation
The keyword @code{__thread} applied to a non-local object gives the
object thread storage duration.

A local variable or class data member declared both @code{static}
and @code{__thread} gives the variable or member thread storage
duration.
@end quotation

@item
@b{[basic.stc.static]}

Change paragraph 1

@quotation
All objects that have neither thread storage duration, dynamic
storage duration nor are local [@dots{}].
@end quotation

@item
@b{[dcl.stc]}

Add @code{__thread} to the list in paragraph 1.

Change paragraph 1

@quotation
With the exception of @code{__thread}, at most one
@var{storage-class-specifier} shall appear in a given
@var{decl-specifier-seq}.  The @code{__thread} specifier may
be used alone, or immediately following the @code{extern} or
@code{static} specifiers.  [@dots{}]
@end quotation

Add after paragraph 5

@quotation
The @code{__thread} specifier can be applied only to the names of objects
and to anonymous unions.
@end quotation

@item
@b{[class.mem]}

Add after paragraph 6

@quotation
Non-@code{static} members shall not be @code{__thread}.
@end quotation
@end itemize

@node Binary constants
@section Binary Constants using the @samp{0b} Prefix
@cindex Binary constants using the @samp{0b} prefix

Integer constants can be written as binary constants, consisting of a
sequence of @samp{0} and @samp{1} digits, prefixed by @samp{0b} or
@samp{0B}.  This is particularly useful in environments that operate a
lot on the bit level (like microcontrollers).

The following statements are identical:

@smallexample
i =       42;
i =     0x2a;
i =      052;
i = 0b101010;
@end smallexample

The type of these constants follows the same rules as for octal or
hexadecimal integer constants, so suffixes like @samp{L} or @samp{UL}
can be applied.

@node C++ Extensions
@chapter Extensions to the C++ Language
@cindex extensions, C++ language
@cindex C++ language extensions

The GNU compiler provides these extensions to the C++ language (and you
can also use most of the C language extensions in your C++ programs).  If you
want to write code that checks whether these features are available, you can
test for the GNU compiler the same way as for C programs: check for a
predefined macro @code{__GNUC__}.  You can also use @code{__GNUG__} to
test specifically for GNU C++ (@pxref{Common Predefined Macros,,
Predefined Macros,cpp,The GNU C Preprocessor}).

@menu
* C++ Volatiles::       What constitutes an access to a volatile object.
* Restricted Pointers:: C99 restricted pointers and references.
* Vague Linkage::       Where G++ puts inlines, vtables and such.
* C++ Interface::       You can use a single C++ header file for both
                        declarations and definitions.
* Template Instantiation:: Methods for ensuring that exactly one copy of
                        each needed template instantiation is emitted.
* Bound member functions:: You can extract a function pointer to the
                        method denoted by a @samp{->*} or @samp{.*} expression.
* C++ Attributes::      Variable, function, and type attributes for C++ only.
* Function Multiversioning::   Declaring multiple function versions.
* Type Traits::         Compiler support for type traits.
* C++ Concepts::        Improved support for generic programming.
* Deprecated Features:: Things will disappear from G++.
* Backwards Compatibility:: Compatibilities with earlier definitions of C++.
@end menu

@node C++ Volatiles
@section When is a Volatile C++ Object Accessed?
@cindex accessing volatiles
@cindex volatile read
@cindex volatile write
@cindex volatile access

The C++ standard differs from the C standard in its treatment of
volatile objects.  It fails to specify what constitutes a volatile
access, except to say that C++ should behave in a similar manner to C
with respect to volatiles, where possible.  However, the different
lvalueness of expressions between C and C++ complicate the behavior.
G++ behaves the same as GCC for volatile access, @xref{C
Extensions,,Volatiles}, for a description of GCC's behavior.

The C and C++ language specifications differ when an object is
accessed in a void context:

@smallexample
volatile int *src = @var{somevalue};
*src;
@end smallexample

The C++ standard specifies that such expressions do not undergo lvalue
to rvalue conversion, and that the type of the dereferenced object may
be incomplete.  The C++ standard does not specify explicitly that it
is lvalue to rvalue conversion that is responsible for causing an
access.  There is reason to believe that it is, because otherwise
certain simple expressions become undefined.  However, because it
would surprise most programmers, G++ treats dereferencing a pointer to
volatile object of complete type as GCC would do for an equivalent
type in C@.  When the object has incomplete type, G++ issues a
warning; if you wish to force an error, you must force a conversion to
rvalue with, for instance, a static cast.

When using a reference to volatile, G++ does not treat equivalent
expressions as accesses to volatiles, but instead issues a warning that
no volatile is accessed.  The rationale for this is that otherwise it
becomes difficult to determine where volatile access occur, and not
possible to ignore the return value from functions returning volatile
references.  Again, if you wish to force a read, cast the reference to
an rvalue.

G++ implements the same behavior as GCC does when assigning to a
volatile object---there is no reread of the assigned-to object, the
assigned rvalue is reused.  Note that in C++ assignment expressions
are lvalues, and if used as an lvalue, the volatile object is
referred to.  For instance, @var{vref} refers to @var{vobj}, as
expected, in the following example:

@smallexample
volatile int vobj;
volatile int &vref = vobj = @var{something};
@end smallexample

@node Restricted Pointers
@section Restricting Pointer Aliasing
@cindex restricted pointers
@cindex restricted references
@cindex restricted this pointer

As with the C front end, G++ understands the C99 feature of restricted pointers,
specified with the @code{__restrict__}, or @code{__restrict} type
qualifier.  Because you cannot compile C++ by specifying the @option{-std=c99}
language flag, @code{restrict} is not a keyword in C++.

In addition to allowing restricted pointers, you can specify restricted
references, which indicate that the reference is not aliased in the local
context.

@smallexample
void fn (int *__restrict__ rptr, int &__restrict__ rref)
@{
  /* @r{@dots{}} */
@}
@end smallexample

@noindent
In the body of @code{fn}, @var{rptr} points to an unaliased integer and
@var{rref} refers to a (different) unaliased integer.

You may also specify whether a member function's @var{this} pointer is
unaliased by using @code{__restrict__} as a member function qualifier.

@smallexample
void T::fn () __restrict__
@{
  /* @r{@dots{}} */
@}
@end smallexample

@noindent
Within the body of @code{T::fn}, @var{this} has the effective
definition @code{T *__restrict__ const this}.  Notice that the
interpretation of a @code{__restrict__} member function qualifier is
different to that of @code{const} or @code{volatile} qualifier, in that it
is applied to the pointer rather than the object.  This is consistent with
other compilers that implement restricted pointers.

As with all outermost parameter qualifiers, @code{__restrict__} is
ignored in function definition matching.  This means you only need to
specify @code{__restrict__} in a function definition, rather than
in a function prototype as well.

@node Vague Linkage
@section Vague Linkage
@cindex vague linkage

There are several constructs in C++ that require space in the object
file but are not clearly tied to a single translation unit.  We say that
these constructs have ``vague linkage''.  Typically such constructs are
emitted wherever they are needed, though sometimes we can be more
clever.

@table @asis
@item Inline Functions
Inline functions are typically defined in a header file which can be
included in many different compilations.  Hopefully they can usually be
inlined, but sometimes an out-of-line copy is necessary, if the address
of the function is taken or if inlining fails.  In general, we emit an
out-of-line copy in all translation units where one is needed.  As an
exception, we only emit inline virtual functions with the vtable, since
it always requires a copy.

Local static variables and string constants used in an inline function
are also considered to have vague linkage, since they must be shared
between all inlined and out-of-line instances of the function.

@item VTables
@cindex vtable
C++ virtual functions are implemented in most compilers using a lookup
table, known as a vtable.  The vtable contains pointers to the virtual
functions provided by a class, and each object of the class contains a
pointer to its vtable (or vtables, in some multiple-inheritance
situations).  If the class declares any non-inline, non-pure virtual
functions, the first one is chosen as the ``key method'' for the class,
and the vtable is only emitted in the translation unit where the key
method is defined.

@emph{Note:} If the chosen key method is later defined as inline, the
vtable is still emitted in every translation unit that defines it.
Make sure that any inline virtuals are declared inline in the class
body, even if they are not defined there.

@item @code{type_info} objects
@cindex @code{type_info}
@cindex RTTI
C++ requires information about types to be written out in order to
implement @samp{dynamic_cast}, @samp{typeid} and exception handling.
For polymorphic classes (classes with virtual functions), the @samp{type_info}
object is written out along with the vtable so that @samp{dynamic_cast}
can determine the dynamic type of a class object at run time.  For all
other types, we write out the @samp{type_info} object when it is used: when
applying @samp{typeid} to an expression, throwing an object, or
referring to a type in a catch clause or exception specification.

@item Template Instantiations
Most everything in this section also applies to template instantiations,
but there are other options as well.
@xref{Template Instantiation,,Where's the Template?}.

@end table

When used with GNU ld version 2.8 or later on an ELF system such as
GNU/Linux or Solaris 2, or on Microsoft Windows, duplicate copies of
these constructs will be discarded at link time.  This is known as
COMDAT support.

On targets that don't support COMDAT, but do support weak symbols, GCC
uses them.  This way one copy overrides all the others, but
the unused copies still take up space in the executable.

For targets that do not support either COMDAT or weak symbols,
most entities with vague linkage are emitted as local symbols to
avoid duplicate definition errors from the linker.  This does not happen
for local statics in inlines, however, as having multiple copies
almost certainly breaks things.

@xref{C++ Interface,,Declarations and Definitions in One Header}, for
another way to control placement of these constructs.

@node C++ Interface
@section C++ Interface and Implementation Pragmas

@cindex interface and implementation headers, C++
@cindex C++ interface and implementation headers
@cindex pragmas, interface and implementation

@code{#pragma interface} and @code{#pragma implementation} provide the
user with a way of explicitly directing the compiler to emit entities
with vague linkage (and debugging information) in a particular
translation unit.

@emph{Note:} These @code{#pragma}s have been superceded as of GCC 2.7.2
by COMDAT support and the ``key method'' heuristic
mentioned in @ref{Vague Linkage}.  Using them can actually cause your
program to grow due to unnecessary out-of-line copies of inline
functions.

@table @code
@item #pragma interface
@itemx #pragma interface "@var{subdir}/@var{objects}.h"
@kindex #pragma interface
Use this directive in @emph{header files} that define object classes, to save
space in most of the object files that use those classes.  Normally,
local copies of certain information (backup copies of inline member
functions, debugging information, and the internal tables that implement
virtual functions) must be kept in each object file that includes class
definitions.  You can use this pragma to avoid such duplication.  When a
header file containing @samp{#pragma interface} is included in a
compilation, this auxiliary information is not generated (unless
the main input source file itself uses @samp{#pragma implementation}).
Instead, the object files contain references to be resolved at link
time.

The second form of this directive is useful for the case where you have
multiple headers with the same name in different directories.  If you
use this form, you must specify the same string to @samp{#pragma
implementation}.

@item #pragma implementation
@itemx #pragma implementation "@var{objects}.h"
@kindex #pragma implementation
Use this pragma in a @emph{main input file}, when you want full output from
included header files to be generated (and made globally visible).  The
included header file, in turn, should use @samp{#pragma interface}.
Backup copies of inline member functions, debugging information, and the
internal tables used to implement virtual functions are all generated in
implementation files.

@cindex implied @code{#pragma implementation}
@cindex @code{#pragma implementation}, implied
@cindex naming convention, implementation headers
If you use @samp{#pragma implementation} with no argument, it applies to
an include file with the same basename@footnote{A file's @dfn{basename}
is the name stripped of all leading path information and of trailing
suffixes, such as @samp{.h} or @samp{.C} or @samp{.cc}.} as your source
file.  For example, in @file{allclass.cc}, giving just
@samp{#pragma implementation}
by itself is equivalent to @samp{#pragma implementation "allclass.h"}.

Use the string argument if you want a single implementation file to
include code from multiple header files.  (You must also use
@samp{#include} to include the header file; @samp{#pragma
implementation} only specifies how to use the file---it doesn't actually
include it.)

There is no way to split up the contents of a single header file into
multiple implementation files.
@end table

@cindex inlining and C++ pragmas
@cindex C++ pragmas, effect on inlining
@cindex pragmas in C++, effect on inlining
@samp{#pragma implementation} and @samp{#pragma interface} also have an
effect on function inlining.

If you define a class in a header file marked with @samp{#pragma
interface}, the effect on an inline function defined in that class is
similar to an explicit @code{extern} declaration---the compiler emits
no code at all to define an independent version of the function.  Its
definition is used only for inlining with its callers.

@opindex fno-implement-inlines
Conversely, when you include the same header file in a main source file
that declares it as @samp{#pragma implementation}, the compiler emits
code for the function itself; this defines a version of the function
that can be found via pointers (or by callers compiled without
inlining).  If all calls to the function can be inlined, you can avoid
emitting the function by compiling with @option{-fno-implement-inlines}.
If any calls are not inlined, you will get linker errors.

@node Template Instantiation
@section Where's the Template?
@cindex template instantiation

C++ templates were the first language feature to require more
intelligence from the environment than was traditionally found on a UNIX
system.  Somehow the compiler and linker have to make sure that each
template instance occurs exactly once in the executable if it is needed,
and not at all otherwise.  There are two basic approaches to this
problem, which are referred to as the Borland model and the Cfront model.

@table @asis
@item Borland model
Borland C++ solved the template instantiation problem by adding the code
equivalent of common blocks to their linker; the compiler emits template
instances in each translation unit that uses them, and the linker
collapses them together.  The advantage of this model is that the linker
only has to consider the object files themselves; there is no external
complexity to worry about.  The disadvantage is that compilation time
is increased because the template code is being compiled repeatedly.
Code written for this model tends to include definitions of all
templates in the header file, since they must be seen to be
instantiated.

@item Cfront model
The AT&T C++ translator, Cfront, solved the template instantiation
problem by creating the notion of a template repository, an
automatically maintained place where template instances are stored.  A
more modern version of the repository works as follows: As individual
object files are built, the compiler places any template definitions and
instantiations encountered in the repository.  At link time, the link
wrapper adds in the objects in the repository and compiles any needed
instances that were not previously emitted.  The advantages of this
model are more optimal compilation speed and the ability to use the
system linker; to implement the Borland model a compiler vendor also
needs to replace the linker.  The disadvantages are vastly increased
complexity, and thus potential for error; for some code this can be
just as transparent, but in practice it can been very difficult to build
multiple programs in one directory and one program in multiple
directories.  Code written for this model tends to separate definitions
of non-inline member templates into a separate file, which should be
compiled separately.
@end table

G++ implements the Borland model on targets where the linker supports it,
including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows.
Otherwise G++ implements neither automatic model.

You have the following options for dealing with template instantiations:

@enumerate
@item
Do nothing.  Code written for the Borland model works fine, but
each translation unit contains instances of each of the templates it
uses.  The duplicate instances will be discarded by the linker, but in
a large program, this can lead to an unacceptable amount of code
duplication in object files or shared libraries.

Duplicate instances of a template can be avoided by defining an explicit
instantiation in one object file, and preventing the compiler from doing
implicit instantiations in any other object files by using an explicit
instantiation declaration, using the @code{extern template} syntax:

@smallexample
extern template int max (int, int);
@end smallexample

This syntax is defined in the C++ 2011 standard, but has been supported by
G++ and other compilers since well before 2011.

Explicit instantiations can be used for the largest or most frequently
duplicated instances, without having to know exactly which other instances
are used in the rest of the program.  You can scatter the explicit
instantiations throughout your program, perhaps putting them in the
translation units where the instances are used or the translation units
that define the templates themselves; you can put all of the explicit
instantiations you need into one big file; or you can create small files
like

@smallexample
#include "Foo.h"
#include "Foo.cc"

template class Foo<int>;
template ostream& operator <<
                (ostream&, const Foo<int>&);
@end smallexample

@noindent
for each of the instances you need, and create a template instantiation
library from those.

This is the simplest option, but also offers flexibility and
fine-grained control when necessary. It is also the most portable
alternative and programs using this approach will work with most modern
compilers.

@item
@opindex frepo
Compile your template-using code with @option{-frepo}.  The compiler
generates files with the extension @samp{.rpo} listing all of the
template instantiations used in the corresponding object files that
could be instantiated there; the link wrapper, @samp{collect2},
then updates the @samp{.rpo} files to tell the compiler where to place
those instantiations and rebuild any affected object files.  The
link-time overhead is negligible after the first pass, as the compiler
continues to place the instantiations in the same files.

This can be a suitable option for application code written for the Borland
model, as it usually just works.  Code written for the Cfront model 
needs to be modified so that the template definitions are available at
one or more points of instantiation; usually this is as simple as adding
@code{#include <tmethods.cc>} to the end of each template header.

For library code, if you want the library to provide all of the template
instantiations it needs, just try to link all of its object files
together; the link will fail, but cause the instantiations to be
generated as a side effect.  Be warned, however, that this may cause
conflicts if multiple libraries try to provide the same instantiations.
For greater control, use explicit instantiation as described in the next
option.

@item
@opindex fno-implicit-templates
Compile your code with @option{-fno-implicit-templates} to disable the
implicit generation of template instances, and explicitly instantiate
all the ones you use.  This approach requires more knowledge of exactly
which instances you need than do the others, but it's less
mysterious and allows greater control if you want to ensure that only
the intended instances are used.

If you are using Cfront-model code, you can probably get away with not
using @option{-fno-implicit-templates} when compiling files that don't
@samp{#include} the member template definitions.

If you use one big file to do the instantiations, you may want to
compile it without @option{-fno-implicit-templates} so you get all of the
instances required by your explicit instantiations (but not by any
other files) without having to specify them as well.

In addition to forward declaration of explicit instantiations
(with @code{extern}), G++ has extended the template instantiation
syntax to support instantiation of the compiler support data for a
template class (i.e.@: the vtable) without instantiating any of its
members (with @code{inline}), and instantiation of only the static data
members of a template class, without the support data or member
functions (with @code{static}):

@smallexample
inline template class Foo<int>;
static template class Foo<int>;
@end smallexample
@end enumerate

@node Bound member functions
@section Extracting the Function Pointer from a Bound Pointer to Member Function
@cindex pmf
@cindex pointer to member function
@cindex bound pointer to member function

In C++, pointer to member functions (PMFs) are implemented using a wide
pointer of sorts to handle all the possible call mechanisms; the PMF
needs to store information about how to adjust the @samp{this} pointer,
and if the function pointed to is virtual, where to find the vtable, and
where in the vtable to look for the member function.  If you are using
PMFs in an inner loop, you should really reconsider that decision.  If
that is not an option, you can extract the pointer to the function that
would be called for a given object/PMF pair and call it directly inside
the inner loop, to save a bit of time.

Note that you still pay the penalty for the call through a
function pointer; on most modern architectures, such a call defeats the
branch prediction features of the CPU@.  This is also true of normal
virtual function calls.

The syntax for this extension is

@smallexample
extern A a;
extern int (A::*fp)();
typedef int (*fptr)(A *);

fptr p = (fptr)(a.*fp);
@end smallexample

For PMF constants (i.e.@: expressions of the form @samp{&Klasse::Member}),
no object is needed to obtain the address of the function.  They can be
converted to function pointers directly:

@smallexample
fptr p1 = (fptr)(&A::foo);
@end smallexample

@opindex Wno-pmf-conversions
You must specify @option{-Wno-pmf-conversions} to use this extension.

@node C++ Attributes
@section C++-Specific Variable, Function, and Type Attributes

Some attributes only make sense for C++ programs.

@table @code
@item abi_tag ("@var{tag}", ...)
@cindex @code{abi_tag} function attribute
@cindex @code{abi_tag} variable attribute
@cindex @code{abi_tag} type attribute
The @code{abi_tag} attribute can be applied to a function, variable, or class
declaration.  It modifies the mangled name of the entity to
incorporate the tag name, in order to distinguish the function or
class from an earlier version with a different ABI; perhaps the class
has changed size, or the function has a different return type that is
not encoded in the mangled name.

The attribute can also be applied to an inline namespace, but does not
affect the mangled name of the namespace; in this case it is only used
for @option{-Wabi-tag} warnings and automatic tagging of functions and
variables.  Tagging inline namespaces is generally preferable to
tagging individual declarations, but the latter is sometimes
necessary, such as when only certain members of a class need to be
tagged.

The argument can be a list of strings of arbitrary length.  The
strings are sorted on output, so the order of the list is
unimportant.

A redeclaration of an entity must not add new ABI tags,
since doing so would change the mangled name.

The ABI tags apply to a name, so all instantiations and
specializations of a template have the same tags.  The attribute will
be ignored if applied to an explicit specialization or instantiation.

The @option{-Wabi-tag} flag enables a warning about a class which does
not have all the ABI tags used by its subobjects and virtual functions; for users with code
that needs to coexist with an earlier ABI, using this option can help
to find all affected types that need to be tagged.

When a type involving an ABI tag is used as the type of a variable or
return type of a function where that tag is not already present in the
signature of the function, the tag is automatically applied to the
variable or function.  @option{-Wabi-tag} also warns about this
situation; this warning can be avoided by explicitly tagging the
variable or function or moving it into a tagged inline namespace.

@item init_priority (@var{priority})
@cindex @code{init_priority} variable attribute

In Standard C++, objects defined at namespace scope are guaranteed to be
initialized in an order in strict accordance with that of their definitions
@emph{in a given translation unit}.  No guarantee is made for initializations
across translation units.  However, GNU C++ allows users to control the
order of initialization of objects defined at namespace scope with the
@code{init_priority} attribute by specifying a relative @var{priority},
a constant integral expression currently bounded between 101 and 65535
inclusive.  Lower numbers indicate a higher priority.

In the following example, @code{A} would normally be created before
@code{B}, but the @code{init_priority} attribute reverses that order:

@smallexample
Some_Class  A  __attribute__ ((init_priority (2000)));
Some_Class  B  __attribute__ ((init_priority (543)));
@end smallexample

@noindent
Note that the particular values of @var{priority} do not matter; only their
relative ordering.

@item warn_unused
@cindex @code{warn_unused} type attribute

For C++ types with non-trivial constructors and/or destructors it is
impossible for the compiler to determine whether a variable of this
type is truly unused if it is not referenced. This type attribute
informs the compiler that variables of this type should be warned
about if they appear to be unused, just like variables of fundamental
types.

This attribute is appropriate for types which just represent a value,
such as @code{std::string}; it is not appropriate for types which
control a resource, such as @code{std::lock_guard}.

This attribute is also accepted in C, but it is unnecessary because C
does not have constructors or destructors.

@end table

@node Function Multiversioning
@section Function Multiversioning
@cindex function versions

With the GNU C++ front end, for x86 targets, you may specify multiple
versions of a function, where each function is specialized for a
specific target feature.  At runtime, the appropriate version of the
function is automatically executed depending on the characteristics of
the execution platform.  Here is an example.

@smallexample
__attribute__ ((target ("default")))
int foo ()
@{
  // The default version of foo.
  return 0;
@}

__attribute__ ((target ("sse4.2")))
int foo ()
@{
  // foo version for SSE4.2
  return 1;
@}

__attribute__ ((target ("arch=atom")))
int foo ()
@{
  // foo version for the Intel ATOM processor
  return 2;
@}

__attribute__ ((target ("arch=amdfam10")))
int foo ()
@{
  // foo version for the AMD Family 0x10 processors.
  return 3;
@}

int main ()
@{
  int (*p)() = &foo;
  assert ((*p) () == foo ());
  return 0;
@}
@end smallexample

In the above example, four versions of function foo are created. The
first version of foo with the target attribute "default" is the default
version.  This version gets executed when no other target specific
version qualifies for execution on a particular platform. A new version
of foo is created by using the same function signature but with a
different target string.  Function foo is called or a pointer to it is
taken just like a regular function.  GCC takes care of doing the
dispatching to call the right version at runtime.  Refer to the
@uref{http://gcc.gnu.org/wiki/FunctionMultiVersioning, GCC wiki on
Function Multiversioning} for more details.

@node Type Traits
@section Type Traits

The C++ front end implements syntactic extensions that allow
compile-time determination of 
various characteristics of a type (or of a
pair of types).

@table @code
@item __has_nothrow_assign (type)
If @code{type} is const qualified or is a reference type then the trait is
false.  Otherwise if @code{__has_trivial_assign (type)} is true then the trait
is true, else if @code{type} is a cv class or union type with copy assignment
operators that are known not to throw an exception then the trait is true,
else it is false.  Requires: @code{type} shall be a complete type,
(possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_nothrow_copy (type)
If @code{__has_trivial_copy (type)} is true then the trait is true, else if
@code{type} is a cv class or union type with copy constructors that
are known not to throw an exception then the trait is true, else it is false.
Requires: @code{type} shall be a complete type, (possibly cv-qualified)
@code{void}, or an array of unknown bound.

@item __has_nothrow_constructor (type)
If @code{__has_trivial_constructor (type)} is true then the trait is
true, else if @code{type} is a cv class or union type (or array
thereof) with a default constructor that is known not to throw an
exception then the trait is true, else it is false.  Requires:
@code{type} shall be a complete type, (possibly cv-qualified)
@code{void}, or an array of unknown bound.

@item __has_trivial_assign (type)
If @code{type} is const qualified or is a reference type then the trait is
false.  Otherwise if @code{__is_pod (type)} is true then the trait is
true, else if @code{type} is a cv class or union type with a trivial
copy assignment ([class.copy]) then the trait is true, else it is
false.  Requires: @code{type} shall be a complete type, (possibly
cv-qualified) @code{void}, or an array of unknown bound.

@item __has_trivial_copy (type)
If @code{__is_pod (type)} is true or @code{type} is a reference type
then the trait is true, else if @code{type} is a cv class or union type
with a trivial copy constructor ([class.copy]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_trivial_constructor (type)
If @code{__is_pod (type)} is true then the trait is true, else if
@code{type} is a cv class or union type (or array thereof) with a
trivial default constructor ([class.ctor]) then the trait is true,
else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_trivial_destructor (type)
If @code{__is_pod (type)} is true or @code{type} is a reference type then
the trait is true, else if @code{type} is a cv class or union type (or
array thereof) with a trivial destructor ([class.dtor]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_virtual_destructor (type)
If @code{type} is a class type with a virtual destructor
([class.dtor]) then the trait is true, else it is false.  Requires:
@code{type} shall be a complete type, (possibly cv-qualified)
@code{void}, or an array of unknown bound.

@item __is_abstract (type)
If @code{type} is an abstract class ([class.abstract]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_base_of (base_type, derived_type)
If @code{base_type} is a base class of @code{derived_type}
([class.derived]) then the trait is true, otherwise it is false.
Top-level cv qualifications of @code{base_type} and
@code{derived_type} are ignored.  For the purposes of this trait, a
class type is considered is own base.  Requires: if @code{__is_class
(base_type)} and @code{__is_class (derived_type)} are true and
@code{base_type} and @code{derived_type} are not the same type
(disregarding cv-qualifiers), @code{derived_type} shall be a complete
type.  A diagnostic is produced if this requirement is not met.

@item __is_class (type)
If @code{type} is a cv class type, and not a union type
([basic.compound]) the trait is true, else it is false.

@item __is_empty (type)
If @code{__is_class (type)} is false then the trait is false.
Otherwise @code{type} is considered empty if and only if: @code{type}
has no non-static data members, or all non-static data members, if
any, are bit-fields of length 0, and @code{type} has no virtual
members, and @code{type} has no virtual base classes, and @code{type}
has no base classes @code{base_type} for which
@code{__is_empty (base_type)} is false.  Requires: @code{type} shall
be a complete type, (possibly cv-qualified) @code{void}, or an array
of unknown bound.

@item __is_enum (type)
If @code{type} is a cv enumeration type ([basic.compound]) the trait is
true, else it is false.

@item __is_literal_type (type)
If @code{type} is a literal type ([basic.types]) the trait is
true, else it is false.  Requires: @code{type} shall be a complete type,
(possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_pod (type)
If @code{type} is a cv POD type ([basic.types]) then the trait is true,
else it is false.  Requires: @code{type} shall be a complete type,
(possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_polymorphic (type)
If @code{type} is a polymorphic class ([class.virtual]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_standard_layout (type)
If @code{type} is a standard-layout type ([basic.types]) the trait is
true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_trivial (type)
If @code{type} is a trivial type ([basic.types]) the trait is
true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_union (type)
If @code{type} is a cv union type ([basic.compound]) the trait is
true, else it is false.

@item __underlying_type (type)
The underlying type of @code{type}.  Requires: @code{type} shall be
an enumeration type ([dcl.enum]).

@end table


@node C++ Concepts
@section C++ Concepts

C++ concepts provide much-improved support for generic programming. In
particular, they allow the specification of constraints on template arguments.
The constraints are used to extend the usual overloading and partial
specialization capabilities of the language, allowing generic data structures
and algorithms to be ``refined'' based on their properties rather than their
type names.

The following keywords are reserved for concepts.

@table @code
@item assumes
States an expression as an assumption, and if possible, verifies that the
assumption is valid. For example, @code{assume(n > 0)}.

@item axiom
Introduces an axiom definition. Axioms introduce requirements on values.

@item forall
Introduces a universally quantified object in an axiom. For example,
@code{forall (int n) n + 0 == n}).

@item concept
Introduces a concept definition. Concepts are sets of syntactic and semantic
requirements on types and their values.

@item requires
Introduces constraints on template arguments or requirements for a member
function of a class template.

@end table

The front end also exposes a number of internal mechanism that can be used
to simplify the writing of type traits. Note that some of these traits are
likely to be removed in the future.

@table @code
@item __is_same (type1, type2)
A binary type trait: true whenever the type arguments are the same.

@end table


@node Deprecated Features
@section Deprecated Features

In the past, the GNU C++ compiler was extended to experiment with new
features, at a time when the C++ language was still evolving.  Now that
the C++ standard is complete, some of those features are superseded by
superior alternatives.  Using the old features might cause a warning in
some cases that the feature will be dropped in the future.  In other
cases, the feature might be gone already.

While the list below is not exhaustive, it documents some of the options
that are now deprecated:

@table @code
@item -fexternal-templates
@itemx -falt-external-templates
These are two of the many ways for G++ to implement template
instantiation.  @xref{Template Instantiation}.  The C++ standard clearly
defines how template definitions have to be organized across
implementation units.  G++ has an implicit instantiation mechanism that
should work just fine for standard-conforming code.

@item -fstrict-prototype
@itemx -fno-strict-prototype
Previously it was possible to use an empty prototype parameter list to
indicate an unspecified number of parameters (like C), rather than no
parameters, as C++ demands.  This feature has been removed, except where
it is required for backwards compatibility.   @xref{Backwards Compatibility}.
@end table

G++ allows a virtual function returning @samp{void *} to be overridden
by one returning a different pointer type.  This extension to the
covariant return type rules is now deprecated and will be removed from a
future version.

The G++ minimum and maximum operators (@samp{<?} and @samp{>?}) and
their compound forms (@samp{<?=}) and @samp{>?=}) have been deprecated
and are now removed from G++.  Code using these operators should be
modified to use @code{std::min} and @code{std::max} instead.

The named return value extension has been deprecated, and is now
removed from G++.

The use of initializer lists with new expressions has been deprecated,
and is now removed from G++.

Floating and complex non-type template parameters have been deprecated,
and are now removed from G++.

The implicit typename extension has been deprecated and is now
removed from G++.

The use of default arguments in function pointers, function typedefs
and other places where they are not permitted by the standard is
deprecated and will be removed from a future version of G++.

G++ allows floating-point literals to appear in integral constant expressions,
e.g.@: @samp{ enum E @{ e = int(2.2 * 3.7) @} }
This extension is deprecated and will be removed from a future version.

G++ allows static data members of const floating-point type to be declared
with an initializer in a class definition. The standard only allows
initializers for static members of const integral types and const
enumeration types so this extension has been deprecated and will be removed
from a future version.

@node Backwards Compatibility
@section Backwards Compatibility
@cindex Backwards Compatibility
@cindex ARM [Annotated C++ Reference Manual]

Now that there is a definitive ISO standard C++, G++ has a specification
to adhere to.  The C++ language evolved over time, and features that
used to be acceptable in previous drafts of the standard, such as the ARM
[Annotated C++ Reference Manual], are no longer accepted.  In order to allow
compilation of C++ written to such drafts, G++ contains some backwards
compatibilities.  @emph{All such backwards compatibility features are
liable to disappear in future versions of G++.} They should be considered
deprecated.   @xref{Deprecated Features}.

@table @code
@item For scope
If a variable is declared at for scope, it used to remain in scope until
the end of the scope that contained the for statement (rather than just
within the for scope).  G++ retains this, but issues a warning, if such a
variable is accessed outside the for scope.

@item Implicit C language
Old C system header files did not contain an @code{extern "C" @{@dots{}@}}
scope to set the language.  On such systems, all header files are
implicitly scoped inside a C language scope.  Also, an empty prototype
@code{()} is treated as an unspecified number of arguments, rather
than no arguments, as C++ demands.
@end table

@c  LocalWords:  emph deftypefn builtin ARCv2EM SIMD builtins msimd
@c  LocalWords:  typedef v4si v8hi DMA dma vdiwr vdowr
