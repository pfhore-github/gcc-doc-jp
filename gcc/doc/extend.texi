c Copyright (C) 1988-2018 Free Software Foundation, Inc.

@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node C Extensions
@chapter C言語族への拡張
@cindex extensions, C language
@cindex C language extensions

@opindex pedantic
GNU Cは、ISO標準Cにはないいくつかの言語機能を提供している。（これらの機能のいずれかが使用されている場合、@ option{-pedantic}オプションはGCCに警告メッセージを出力するように指示する）。条件付きコンパイルでこれらの機能が利用できるかどうかをテストするために、あらかじめ定義されたマクロ@code{__ GNUC__}が常にGCCの下で定義されている。

これらの拡張は、CとObjective-Cで利用できる。 それらのほとんどはC++でも利用可能である。C++に@emph{のみ}適用する拡張機能は、@xref{C++ Extensions,,C++言語の拡張機能}。

ISO C99にはあるがC90やC++にはない機能のいくつかは、拡張機能として、C90モードとC++でGCCで受理される。

@menu
* Statement Exprs::     文と宣言を式の中に置く。
* Local Labels::        ブロックにローカルなラベル。
* Labels as Values::    ラベルへのポインタの取得と計算goto。
* Nested Functions::    AlgolとPascalのような、関数のレキシカルスコープ。
* Constructing Calls::  他の関数の呼び出しの派遣
* Typeof::              @code{typeof}: 式の型の参照。
* Conditionals::        @samp{?:}の第２引数の省略。
* __int128::            128ビット整数---@code{__int128}。
* Long Long::           ２ワード整数---@code{long long int}。
* Complex::             複素数のデータ型。
* Floating Types::      追加の浮動小数点型。
* Half-Precision::      半精度浮動小数点型。
* Decimal Float::       10進浮動小数点型。
* Hex Floats::         16進浮動小数点定数。
* Fixed-Point::         固定小数点型。
* Named Address Spaces:: 名前付きアドレス空間。
* Zero Length::         ゼロ長配列。
* Empty Structures::    メンバなしの構造体。
* Variable Length::     実行時に長さが計算される配列。
* Variadic Macros::     引数の数が可変のマクロ。
* Escaped Newlines::    エスケープされた改行のためのやや緩い規則。
* Subscripting::        配列は非左辺値でも添字を取ることができる。
* Pointer Arith::       @code{void}ポインタと関数ポインタでの算術。
* Pointers to Arrays::  修飾子付きの配列へのポインタは期待通りに機能する。
* Initializers::        非定数初期化子。
* Compound Literals::   値として構造体・共用体・配列を与える複合定数。
* Designated Inits::    初期化子の要素にラベルを与える。
* Case Ranges::         `case 1 ... 9'のようなもの。
* Cast to Union::       共用体の任意のメンバから共用体型へのキャスト。
* Mixed Declarations::  宣言とコードの混在。
* Function Attributes:: 関数が、副作用なし、並びに決して戻らないことを宣言する。
* Variable Attributes:: 変数の属性を指定する。
* Type Attributes::     型の属性を指定する。
* Label Attributes::    ラベルの属性を指定する。
* Enumerator Attributes:: 列挙の属性を指定する。
* Statement Attributes:: 文の属性を指定する。
* Attribute Syntax::    属性の正式な構文。
* Function Prototypes:: プロトタイプ宣言と旧式の定義。
* C++ Comments::        C++コメントは認識される。
* Dollar Signs::        ドル記号は識別子に許容される。
* Character Escapes::   @samp{\e}は@key{ESC}文字を表す。
* Alignment::           型または変数のアラインメントの照会。
* Inline::              （マクロと同等に速い）インライン関数の定義。
* Volatiles::           volatileオブジェクトへのアクセスを構成するもの。
* Using Assembly Language with C:: アセンブラとCのインタフェースをとるための命令と拡張。
* Alternate Keywords::  ヘッダファイル用の@code{__const__}, @code{__asm__}など。
* Incomplete Enums::    詳細を下に書く@code{enum foo;}。
* Function Names::      現在の関数の名前である印字可能な文字列。
* Return Address::      関数の戻り値またはフレームアドレスの取得。
* Vector Extensions::   組み込み関数によるベクトル命令の使用。
* Offsetof::            @code{offsetof}を実装する特別な構文。
* __sync Builtins::     アトミックメモリアクセス用の旧式の組み込み関数。
* __atomic Builtins::   メモリモデル付きのアトミック組み込み関数。
* Integer Overflow Builtins:: 算術と算術オーバーフローチェックを行う組み込み関数。
* x86 specific memory model extensions for transactional memory:: x86メモリモデル。
* Object Size Checking:: 制限されたバッファオーバーフローチェック用の組み込み関数。
* Pointer Bounds Checker builtins:: ポインタ範囲チェッカ用の組み込み関数。
* Other Builtins::      他の組み込み関数。
* Target Builtins::     特定のターゲットに固有の組み込み関数。
* Target Format Checks:: 特定のターゲットに固有のフォーマットチェック。
* Pragmas::             GCCによって受理されるプラグマ。
* Unnamed Fields::      構造体・共用体内の名無し構造体・共用体
* Thread-Local::        スレッドごとの変数。
* Binary constants::    @samp{0b}接頭辞を使った2進定数。
@end menu

@node Statement Exprs
@section 式内の文と宣言
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

@c the above section title wrapped and causes an underfull hbox.. i
@c changed it from "within" to "in". --mew 4feb93
括弧で囲まれた複合文は、GNU Cの式として現れてもよい。これにより、式内でループ、スイッチ、およびローカル変数を使用できる。

複合文は中括弧で囲まれた一連の文であることを思い出すこと。 この構造体では、かっこが中括弧の周りにある。 例えば：

@smallexample
(@{ int y = foo (); int z;
   if (y > 0) z = y;
   else z = - y;
   z; @})
@end smallexample

@noindent
は、@code{foo()}の絶対値のための（必要以上に複雑な）有効な式である。

複合文の最後のものは、式の後ろにセミコロンを続ける必要がある。 この部分式の値は構造全体の値として機能する。（丸かっこ内で他の種類の文を最後に使用した場合、構造は@code{void}型であり、実質的に値はない。）

この機能は、マクロ定義を「安全」にするために特に便利である（各オペランドを正確に1回評価するために）。 例えば、「最大」関数は、一般に、標準Cのマクロとして次のように定義される。

@smallexample
#define max(a,b) ((a) > (b) ? (a) : (b))
@end smallexample

@noindent
@cindex side effects, macro argument
しかし、この定義は@var{a}か@var{b}のどちらかを2回計算する。オペランドに副作用があると悪い結果が出る。 GNU Cでは、オペランド（ここでは@code{int}とする）の型を知っていれば、マクロを次のように安全に定義することができる：

@smallexample
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end smallexample

列挙定数の値、ビットフィールドの幅、または静的変数の初期値などの定数式では、埋め込み文は使用できない。

オペランドの型がわからない場合でもこれを行うことができるが、@code{typeof}や@code{__ auto_type}（@pxref{Typeof}）を使用する必要がある。

G++では、文式の結果値は配列と関数ポインタの格下げを受け、その値を囲む式に返される。 たとえば、@code{A}がクラスの場合、

@smallexample
        A a;

        (@{a;@}).Foo ()
@end smallexample

@noindent
は文の式の結果を保持する一時的な@code{A}オブジェクトを構築する。これは@code{Foo}を呼び出すために使用される。したがって、@code{Foo}によって観測される@code{this}ポインタは@code{a}のアドレスではない。

文の式では、文内で作成された一時変数は、その文の最後で破棄される。 これにより、マクロ内の文式は関数呼び出しとは少し異なる。 後者の場合、引数の評価中に導入された一時変数は、関数呼び出しを含む文の最後で破棄される。 文式の場合、それらは文式中に破棄される。 例えば、

@smallexample
#define macro(a)  (@{__typeof__(a) b = (a); b + 3; @})
template<typename T> T function(T a) @{ T b = a; return b + 3; @}

void foo ()
@{
  macro (X ());
  function (X ());
@}
@end smallexample

@noindent
は一時的なものが破壊される場所は異なる。 @code{macro}の場合、一時的な@code{X}は@code {b}の初期化直後に破棄される。 @code{function}の場合、関数が返ってきたら一時値は破壊される。

これらの考慮事項は、C++で動作するように設計されたヘッダーファイルでこの形式の式式を使用することは、おそらく悪い考えであることを意味する。 （一部のバージョンのGNU Cライブラリには、正確にこのバグにつながる文式を使ったヘッダファイルが含まれていた）。

@code{goto}を使うか、式文の中の@code{case}または@code{default}ラベルのある@code{switch}文を使って式文の中にジャンプすることはできない。計算@code{goto}（@pxref{Labels as Values}）で文式にジャンプすると、未定義の動作が発生する。式文からの飛び越しは許可されるが、式文がより大きい式の一部である場合、文の式の前後で評価する特定の部分式が必要な場合を除き、その式の他の部分式が評価されない 。 いずれにしても、関数呼び出しと同様に、文の式の評価は、その包含する式の他の部分の評価とインタリーブされない。 例えば、

@smallexample
  foo (), ((@{ bar1 (); goto a; 0; @}) + bar2 ()), baz();
@end smallexample

@noindent
は@code{foo}と@code{bar1}を呼び出し、@code{baz}を呼び出さずに@code{bar2}を呼び出すかもしれない。 @code{bar2}が呼び出されると、@code{foo}の後で@code{bar1}の前に呼び出される。

@node Local Labels
@section 局所的に宣言されたラベル
@cindex local labels
@cindex macros, local labels

GCCでは、ネストされたブロックスコープの@dfn{local labels}（ローカルラベル）を宣言できる。 ローカルラベルは通常のラベルと同じだが、宣言されている（@code{goto}文、あるいはそのアドレスを取ることで）ブロック内でのみ参照できる。

ローカルラベル宣言は次のようになる。

@smallexample
__label__ @var{label};
@end smallexample

@noindent
または、

@smallexample
__label__ @var{label1}, @var{label2}, /* @r{@dots{}} */;
@end smallexample

ローカルラベルの宣言は、ブロックの先頭、通常の宣言または文の前に来なければならない。

ラベル宣言はラベル@emph{名}を定義するが、ラベル自体は定義しない。 @code{@var{label}:}は、文の式の中で通常の方法で行う必要がある。

ローカルラベル機能は、複雑なマクロに便利である。 マクロにネストされたループが含まれている場合、@code{goto}はそれらのループを中断するのに便利である。 ただし、関数全体をスコープとする通常のラベルは使用できない。マクロを1つの関数で複数回展開できる場合、ラベルはその関数で複数定義される。 ローカルラベルはこの問題を回避する。 例えば：

@smallexample
#define SEARCH(value, array, target)              \
do @{                                              \
  __label__ found;                                \
  typeof (target) _SEARCH_target = (target);      \
  typeof (*(array)) *_SEARCH_array = (array);     \
  int i, j;                                       \
  int value;                                      \
  for (i = 0; i < max; i++)                       \
    for (j = 0; j < max; j++)                     \
      if (_SEARCH_array[i][j] == _SEARCH_target)  \
        @{ (value) = i; goto found; @}              \
  (value) = -1;                                   \
 found:;                                          \
@} while (0)
@end smallexample

これは文式を使って書くこともできる：

@smallexample
#define SEARCH(array, target)                     \
(@{                                                \
  __label__ found;                                \
  typeof (target) _SEARCH_target = (target);      \
  typeof (*(array)) *_SEARCH_array = (array);     \
  int i, j;                                       \
  int value;                                      \
  for (i = 0; i < max; i++)                       \
    for (j = 0; j < max; j++)                     \
      if (_SEARCH_array[i][j] == _SEARCH_target)  \
        @{ value = i; goto found; @}                \
  value = -1;                                     \
 found:                                           \
  value;                                          \
@})
@end smallexample

ローカルラベル宣言では、ネストされた関数が存在する場合には、それらがネストされた関数に可視であると宣言するラベルを作成する。  詳細は@xref{Nested Functions}。

@node Labels as Values
@section 値としてのラベル
@cindex labels as values
@cindex computed gotos
@cindex goto with computed label
@cindex address of a label

単項演算子@samp {&&}を使用して、現在の関数（または含む関数）で定義されているラベルのアドレスを取得できる。 値は型@code{void*}を持つ。 この値は定数であり、その型の定数が有効な場合はいつでも使用できる。 例えば：

@smallexample
void *ptr;
/* @r{@dots{}} */
ptr = &&foo;
@end smallexample

これらの値を使用するには、1つにジャンプする必要がある。 これは計算されたgoto文、@code{goto *@var{exp};}で行われる。@footnote{Fortranの類似機能は代入gotoと呼ばれるが、C言語では、単にローカル変数にラベルのアドレスを代入する以上のことを行うため、不適切である。}。例えば、

@smallexample
goto *ptr;
@end smallexample

@noindent
@code {void *}型の式はすべて使用できる。

これらの定数を使用する1つの方法は、ジャンプテーブルとして機能する静的配列を初期化することである。

@smallexample
static void *array[] = @{ &&foo, &&bar, &&hack @};
@end smallexample

@noindent
次に、次のように索引付けするラベルを選択できる。

@smallexample
goto *array[i];
@end smallexample

@noindent
これは、下付き文字が範囲内にあるかどうかをチェックしないことに注意せよ。Cでの配列のインデックス付けはそれを決して行わない。

このようなラベル値の配列は、@code{switch}文のような目的を果たす。 @code{switch}文はより洗練されているので、問題が@code{switch}文によく合わない場合を除き、配列ではなくその文を使用すること。

ラベル値の別の使用法は、スレッド化されたコードのインタプリタにある。インタプリタ関数内のラベルは、超高速ディスパッチのためにスレッドコードに格納することができる。

この機能を使用して、別の機能のコードにジャンプすることはできない。 そうすれば、全く予測できないことが起こる。 これを避ける最善の方法は、自動変数にのみラベルアドレスを格納し、それを引数として渡さないことである。

上記の例を書く別の方法は次のとおりです。

@smallexample
static const int array[] = @{ &&foo - &&foo, &&bar - &&foo,
                             &&hack - &&foo @};
goto *(&&foo + array[i]);
@end smallexample

@noindent
これは、必要な動的再配置の数を減らし、結果としてデータを読み取り専用にすることができるようになり、共有ライブラリでのコードにより適している。AVRターゲットでは、このラベルの差の代替方法はサポートされていない。AVRプログラムの最初の方法を使用すること。

同じラベルの@code{&& foo}式は、インクルードされた関数がインライン化またはクローン化されている場合、異なる値を持つことがある。 プログラムがそれらが常に同じであることに依存する場合、インライン化とクローン化を防ぐために@code{__attribute__((__noinline__,__noclone__))}を使用する必要がある。 @code{&& foo}を静的変数初期化子で使用すると、インライン化とクローン化は禁止される。

@node Nested Functions
@section 入れ子関数
@cindex nested functions
@cindex downward funargs
@cindex thunks

@dfn{nested function}（入れ子関数）は、別の関数の中で定義された関数である。入れ子関数は、GNU Cの拡張としてサポートされているが、GNU C++ではサポートされていない。

入れ子関数の名前は、それが定義されているブロックのローカルである。例えば、ここでは、@code{square}という入れ子関数を定義し、それを2回呼び出している。

@smallexample
@group
foo (double a, double b)
@{
  double square (double z) @{ return z * z; @}

  return square (a) + square (b);
@}
@end group
@end smallexample

入れ子関数は、その定義時点で表示されている包含関数のすべての変数にアクセスできる。 これは@dfn{lexical scoping}（レキシカルスコープ）と呼ばれる。 例えば、ここでは、継承された@code{offset}という名前の変数を使用する入れ子関数を示る。

@smallexample
@group
bar (int *array, int offset, int size)
@{
  int access (int *array, int index)
    @{ return array[index + offset]; @}
  int i;
  /* @r{@dots{}} */
  for (i = 0; i < size; i++)
    /* @r{@dots{}} */ access (array, i) /* @r{@dots{}} */
@}
@end group
@end smallexample

入れ子関数定義は、変数定義が許可されている場所の関数内で使用できる。 つまり、ブロック内の他の宣言とステートメントと混ぜることができる。

その入れ子関数をその名前の範囲外から呼び出すことは、そのアドレスを格納したり、そのアドレスを別の関数に渡したりすることで可能である。

@smallexample
hack (int *array, int size)
@{
  void store (int index, int value)
    @{ array[index] = value; @}

  intermediate (store, size);
@}
@end smallexample

ここで、関数@code{intermediate}は引数として@code{store}のアドレスを受け取る。 @code{intermediate}が@code{store}を呼び出す場合、@code{store}に与えられた引数は@code{array}に格納される。 しかし、このテクニックは、包含する関数（この例では@code{hack}）が終了しない限り動作する。

包含する関数が終了した後にネストされた関数をそのアドレスで呼び出そうとすると、すべての地獄が解放される。 スコープ・レベルが終了した後にコールしようとすると、スコープ・レベルがもはや存在しない変数の一部を参照している場合、幸運だったとしても、リスクを取るのは賢明ではない。 ただし、入れ子関数が範囲を外れたものを参照しない場合は、安全であるはずである。

GCCは、@dfn{trampolines}（トランポリン）と呼ばれる手法を使って入れ子関数のアドレスを取得する。 このテクニックは@cite{Lexical Closures for C++}（Thomas M. Breuel、USENIX C++ Conference Proceedings、1988年10月17-21日）に記述されている。

入れ子関数は、ラベルを含んでいる関数から継承したラベルにジャンプすることができる（ただし、ラベルは、その関数内で明示的に宣言されていなければならない@pxref {Local Labels}）。 このようなジャンプは、@code{goto}と中間関数を行ったネストされた関数を終了して、すぐに包含関数に戻る。 次に例を示す。

@smallexample
@group
bar (int *array, int offset, int size)
@{
  __label__ failure;
  int access (int *array, int index)
    @{
      if (index > size)
        goto failure;
      return array[index + offset];
    @}
  int i;
  /* @r{@dots{}} */
  for (i = 0; i < size; i++)
    /* @r{@dots{}} */ access (array, i) /* @r{@dots{}} */
  /* @r{@dots{}} */
  return 0;

 /* @r{Control comes here from @code{access}
    if it detects an error.}  */
 failure:
  return -1;
@}
@end group
@end smallexample

入れ子関数には常にリンケージはない。 @code{extern}または@code{static}で宣言するのは誤りである。 入れ子関数を定義する前に宣言する必要がある場合は、@code{auto}を使用する（関数宣言では意味がない）。

@smallexample
bar (int *array, int offset, int size)
@{
  __label__ failure;
  auto int access (int *, int);
  /* @r{@dots{}} */
  int access (int *array, int index)
    @{
      if (index > size)
        goto failure;
      return array[index + offset];
    @}
  /* @r{@dots{}} */
@}
@end smallexample

@node Constructing Calls
@section 関数呼び出しの構築
@cindex constructing calls
@cindex forwarding calls

以下に説明する組み込み関数を使用すると、関数が受け取った引数を記録し、引数の数や型を知らなくても、同じ引数を持つ別の関数を呼び出すことができる。

その関数呼び出しの戻り値を記録し、関数が返そうとしたデータ型がわからなくても（呼び出し元がそのデータ型を予期している限り）、後でその値を返すことができる。

しかし、これらの組み込み関数は、洗練された機能やその他の言語の拡張機能とうまく対話できないことがある。 したがって、単純なフォワーダとして機能する非常に単純な関数の外でそれらを使用することは推奨されない。

@deftypefn {Built-in Function} {void *} __builtin_apply_args ()
この組み込み関数は、現在の関数に渡されたのと同じ引数を使用して呼び出しを実行する方法を記述するデータへのポインターを返す。

この関数は、argポインタレジスタ、構造体値アドレス、および関数への引数をスタックに割り当てられたメモリブロックに渡すために使用されるすべてのレジスタを保存する。 次に、そのブロックのアドレスを返す。
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_apply (void (*@var{function})(), void *@var{arguments}, size_t @var{size})
この組み込み関数は、@var{arguments}と@var{size}で記述されたパラメータのコピーで@var{function}を呼び出す。

@var{arguments}の値は@code{__builtin_apply_args}によって返された値でなければならない。 引数@var{size}はスタック引数データのサイズをバイト単位で指定する。

この関数は、@var{function}が返す値を返す方法を記述するデータへのポインタを返す。 データはスタックに割り当てられたメモリブロックに保存される。

@var{size}に適切な値を計算することは必ずしも簡単ではない。 この値は@code{__builtin_apply}によってスタック上にプッシュされ、入ってくる引数領域からコピーされるべきデータの量を計算するために使われる。
@end deftypefn

@deftypefn {Built-in Function} {void} __builtin_return (void *@var{result})
この組み込み関数は、@var{result}で記述された値を含む関数から返された値を返す。 @code{__builtin_apply}で返された値を@var{result}に指定する必要がある。
@end deftypefn

@deftypefn {Built-in Function} {} __builtin_va_arg_pack ()
この組み込み関数は、インライン関数のすべての無名引数を表す。@code{__attribute__((__always_inline__))}や@code{__attribute__((__gnu_inline__))}の外部インライン関数を使用するような、常にインライン関数でコンパイルされたインライン関数でのみ使用できる。可変引数を持つ他の関数の最後の引数として渡されなければならない。 これは、プリプロセッサマクロを使用することが望ましくない場合に、可変引数関数用の小さなラッパーインラインを記述するのに便利である。 例えば：
@smallexample
extern int myprintf (FILE *f, const char *format, ...);
extern inline __attribute__ ((__gnu_inline__)) int
myprintf (FILE *f, const char *format, ...)
@{
  int r = fprintf (f, "myprintf: ");
  if (r < 0)
    return r;
  int s = fprintf (f, format, __builtin_va_arg_pack ());
  if (s < 0)
    return s;
  return r + s;
@}
@end smallexample
@end deftypefn

@deftypefn {Built-in Function} {size_t} __builtin_va_arg_pack_len ()
この組み込み関数は、インライン関数の無名引数の数を返す。@code{__attribute__((__always_inline__))}や@code{__attribute__((__gnu_inline__))}の外部インライン関数を使用するような、常にインライン関数でコンパイルされたインライン関数でのみ使用できる。 たとえば、最適化されたコードのopen引数のリンクまたは実行時のチェックは次のようになる。
@smallexample
#ifdef __OPTIMIZE__
extern inline __attribute__((__gnu_inline__)) int
myopen (const char *path, int oflag, ...)
@{
  if (__builtin_va_arg_pack_len () > 1)
    warn_open_too_many_arguments ();

  if (__builtin_constant_p (oflag))
    @{
      if ((oflag & O_CREAT) != 0 && __builtin_va_arg_pack_len () < 1)
        @{
          warn_open_missing_mode ();
          return __open_2 (path, oflag);
        @}
      return open (path, oflag, __builtin_va_arg_pack ());
    @}

  if (__builtin_va_arg_pack_len () < 1)
    return __open_2 (path, oflag);

  return open (path, oflag, __builtin_va_arg_pack ());
@}
#endif
@end smallexample
@end deftypefn

@node Typeof
@section @code{typeof}で型へ参照する
@findex typeof
@findex sizeof
@cindex macros, types of arguments

式の型を参照する別の方法は@code {typeof}である。このキーワードを使用する構文は@code{sizeof}のように見えるが、構文は意味的に@code{typedef}で定義された型名のように機能する。

引数を@code{typeof}に書くには、式を使うか型を書くかの2つの方法がある。 次の式を使用した例を示す。

@smallexample
typeof (x[0](1))
@end smallexample

@noindent
これは、@code{x}が関数へのポインタの配列であることを前提としている。記述されている型は関数の値の型である。

引数としてtypenameを使用した例を次に示す。

@smallexample
typeof (int *)
@end smallexample

@noindent
ここで説明する型は@code{int}へのポインタの型である。

ISO Cプログラムに含まれているときに動作する必要があるヘッダファイルを作成する場合は、@code{typeof}の代わりに@code{__typeof__}を記述する。
@xref{Alternate Keywords}.

@code{typeof}構文は、typedef名を使うことができるところならどこでも使うことができる。 たとえば、宣言、キャスト、または@code{sizeof}や@code {typeof}の内部で使用できる。

@code{typeof}のオペランドは、可変的に変更された型の式またはそのような型の名前である場合にのみ、その副作用を評価される。

@code{typeof}は、式文（@pxref {Statement Exprs}）と併用すると便利である。ここで2つの方法を組み合わせて、どの算術型でも動作し、それぞれの引数を正確に1回評価する安全な 「最大」'マクロを定義する方法を示す：

@smallexample
#define max(a,b) \
  (@{ typeof (a) _a = (a); \
      typeof (b) _b = (b); \
    _a > _b ? _a : _b; @})
@end smallexample

@cindex underscores in variables in macros
@cindex @samp{_} in variables in macros
@cindex local variables in macros
@cindex variables, local, in macros
@cindex macros, local variables in

ローカル変数に対してアンダースコアで始まる名前を使用する理由は、@code {a}と@code {b}の代わりに使用される式内で発生する変数名との競合を避けるためである。 最終的には、スコープが初期化子の後にのみ始まる変数を宣言できる新しい宣言構文を設計したいと考えている。 このような競合を防ぐより確実な方法になりだろう。

@noindent
@code {typeof}の使用に関するいくつかの例：

@itemize @bullet
@item
これは、@code{y}を@code{x}が指しているものの型で宣言する。

@smallexample
typeof (*x) y;
@end smallexample

@item
これは、そのような値の配列として@code{y}を宣言する。

@smallexample
typeof (*x) y[4];
@end smallexample

@item
これは、文字へのポインタの配列として@code{y}を宣言する。

@smallexample
typeof (typeof (char *)[4]) y;
@end smallexample

@noindent
これは、以下の従来のC宣言と同じである。

@smallexample
char *y[4];
@end smallexample

@code{typeof}を使用して宣言の意味を理解し、それがなぜ有用な方法であるのかを確認するには、次のマクロで書き直す。

@smallexample
#define pointer(T)  typeof(T *)
#define array(T, N) typeof(T [N])
@end smallexample

@noindent
これで宣言は次のように書き換えられる。

@smallexample
array (pointer (char), 4) y;
@end smallexample

@noindent
したがって、@code{array (pointer (char), 4)}は@code {char}への4つのポインタの配列の型である。
@end itemize

GNU C++ではなく、GNU Cでは、変数の型を@code{__auto_type}として宣言することもできる。 その場合、宣言はただ1つの変数を宣言しなければならない。宣言子は識別子でなければならず、宣言は初期化されなければならず、変数の型はイニシャライザによって決定される。 変数の名前は、イニシャライザの後までスコープ内にない。 （C++では、この目的のためにC++11 @code{auto}を使うべきである。）@code{__auto_type}を使うと、上の 「最大」マクロは以下のように書くことができる：

@smallexample
#define max(a,b) \
  (@{ __auto_type _a = (a); \
      __auto_type _b = (b); \
    _a > _b ? _a : _b; @})
@end smallexample

@code{typeof}の代わりに@code{__auto_type}を使うことには2つの利点がある：

@itemize @bullet
@item マクロへの各引数は、マクロの展開で一度だけ表示される。 これにより、そのようなマクロへの呼び出しがそのようなマクロの引数の中に入れ子になったときに、マクロ展開のサイズが指数関数的に増加するのを防ぐ。

@item マクロへの引数が可変的に変更された型の場合、@code{__auto_type}を使用する場合は1回だけ評価されるが、@code{typeof}を使用する場合は2回評価される。
@end itemize

@node Conditionals
@section 省略されたオペランドのある条件式
@cindex conditional expressions, extensions
@cindex omitted middle-operands
@cindex middle-operands, omitted
@cindex extensions, @code{?:}
@cindex @code{?:} extensions

条件式の中間のオペランドは省略することができる。 その時、第1オペランドがゼロ以外の場合、その値は条件式の値になる。

したがって、式

@smallexample
x ? : y
@end smallexample

@noindent
ゼロ以外の場合は、@code {x}の値を持つ。 それ以外の場合は、@code {y}の値となる。

この例は、以下と完全に等価である。

@smallexample
x ? x : y
@end smallexample

@cindex side effect in @code{?:}
@cindex @code{?:} side effect
@noindent
この単純なケースでは、中間のオペランドを省略することは特に有用ではない。 それが有用になるのは、最初のオペランドが副作用を持つ、または持つかもしれないときである。 その時、中間でオペランドを繰り返すと副作用が2回発生する。 中間のオペランドを省略すると、すでに計算された値が再計算の望ましくない影響なしに使用される。

@node __int128
@section 128ビット整数
@cindex @code{__int128} data types

拡張として、整数スカラー型@code {__int128}は、128ビットを保持するのに十分な整数モードを持つターゲットに対してサポートされている。符号なし128ビット整数の場合は@code{__int128}、符号なし128ビット整数の場合は@code{unsigned __int128}と書くだけである。 GCCでは、@code{long long}整数が128ビット幅未満のターゲットに対して@code{__int128}型の整数定数を表現するためのサポートはない。

@node Long Long
@section 倍長整数
@cindex @code{long long} data types
@cindex double-word arithmetic
@cindex multiprecision arithmetic
@cindex @code{LL} integer suffix
@cindex @code{ULL} integer suffix

ISO C99は、少なくとも64ビット幅の整数のデータ型をサポートしている。拡張としてGCCはC90モードとC++でそれらをサポートしている。符号付き整数の場合は@code{long long int}、符号なし整数の場合は@code{unsigned long long int}と書くだけである。 @code{long long int}型の整数定数を作成するには、接尾辞@samp{LL}を整数に追加する。 @code{unsigned long long int}型の整数定数を作るには、接尾辞@samp{ULL}を整数に加える。

これらの型は、他の整数型のように算術演算で使用できる。これらの型に対する加算、減算、およびビット単位の論理演算は、すべてのタイプのマシンでオープンコード化されている。 マシンがフルワードからダブルワードへの拡大乗算命令をサポートしている場合、乗算はオープンコーディングされている。 除算とシフトは特別なサポートを提供するマシンでのみ開かれている。 オープンコーディングされていない操作では、GCCに付属する特別なライブラリルーチンが使用される。

関数のプロトタイプなしで関数の引数に@code{long long}型を使用すると、落とし穴が生じることがある。 関数がその引数に@code{int}型を期待していて、@code{long long int}型の値を渡すと、呼び出し元とサブルーチンが引数のバイト数について不一致になるので混乱が生じる。 同様に、関数が@code{long long int}を期待し、@code{int}を渡してもである。 このような問題を避ける最善の方法は、プロトタイプを使用することである。

@node Complex
@section 複素数
@cindex complex numbers
@cindex @code{_Complex} keyword
@cindex @code{__complex__} keyword

ISO C99は浮動小数点複素数データ型をサポートしていて、拡張としてGCCはC90モードとC++でそれらをサポートしている。 GCCは、ISO C99の一部ではない整数複素数データ型もサポートしている。 キーワード@code{_Complex}を使用して複素数型を宣言できる。 拡張として、古いGNUキーワード@code{__complex__}もサポートされている。

たとえば、@samp{_Complex double x;}は、実数部と虚数部の両方が@code{double}型の変数として@code{x}を宣言する。 @samp{_Complex short int y;}は、@code{y}が@code {short int}型の実数部と虚数部を持つことを宣言する。 これは有用ではない可能性があるが、複素数型のセットが完全であることを示している。

複雑なデータ型を持つ定数を書くには、接尾辞@samp{i}または@samp{j}（どちらか、それらは同等である）を使用する。 たとえば、@code{2.5fi}は@code{_Complex float}型を持ち、@code{3i}は@code{_Complex int}型を持つ。 このような定数は、常に純粋な虚数値を持つが、実定数を加えることで、好きな複素数を作ることができる。 これはGNU拡張である。 ISO C99に準拠したCライブラリ（GNU Cライブラリなど）を持ち、浮動小数点型の複素定数を構築したい場合は、@code{<complex.h>}をインクルードし、代わりに@code{I}または@code {_Complex_I}マクロを使うべきである。

The ISO C++14 library also defines the @samp{i} suffix, so C++14 code
that includes the @samp{<complex>} header cannot use @samp{i} for the
GNU extension.  The @samp{j} suffix still has the GNU meaning.

@cindex @code{__real__} keyword
@cindex @code{__imag__} keyword
複素数値式@var {exp}の実数部を抽出するには、@code{__real__ @var{exp}}と書く。 同様に、@ code{__imag__}を使用して虚数部分を抽出する。 これはGNU拡張である。 浮動小数点型の値については、@code{<complex.h>}で宣言され、GCCの組み込み関数としても提供されているISO C99関数@code{crealf}、@code{creal}、@code{creall}、@code{cimagf}、@code{cimag}、@code{cimagl}を使うべきである。

@cindex complex conjugation
演算子@samp{~}は、複合型の値に使用されたときに複合共役を実行する。 これはGNU拡張である。 浮動小数点型の値については、@code{<complex.h>}で宣言され、GCCによって組み込み関数として提供されるISO C99関数@code {conjf}、@code {conj}と@code {conjl}を使うべきである。 

GCCは複素自動変数を不連続な方法で割り当てることができる。 虚数部がスタックにある一方、実数部がレジスタに入ることも可能である（またはその逆）。 DWARFデバッグ情報形式のみがこれを表すことができるので、DWARFを使用することを推奨する。 stabsデバッグ情報形式を使用している場合、GCCは、非コンプレックス型の2つの別々の変数であるかのように、非連続型複合変数を記述する。 変数の実際の名前が@code{foo}の場合、2つの架空の変数は@code{foo$real}と@code{foo$imag}という名前になる。 これらの2つの架空の変数は、デバッガで調べて設定できる。

@node Floating Types
@section 追加の浮動小数点型
@cindex additional floating types
@cindex @code{_Float@var{n}} data types
@cindex @code{_Float@var{n}x} data types
@cindex @code{__float80} data type
@cindex @code{__float128} data type
@cindex @code{__ibm128} data type
@cindex @code{w} floating point suffix
@cindex @code{q} floating point suffix
@cindex @code{W} floating point suffix
@cindex @code{Q} floating point suffix

ISO/IEC TS 18661-3：2015は、追加の浮動小数点型@code{_Float @var{n}}と@code{_Float @var{n}x}のCサポートを定義している。 サポートされる型のセットは、ターゲット・アーキテクチャーによって異なる。 これらの型は、C++のコンパイル時にはサポートされていない。これらの型の定数は、接尾辞@code{f@var{n}}または@code{F@var{n}}と@code{f@var{n}x}または@code{F@var{n}x}である。これらの型名は、@code {_Complex}とともに使用して、複素数型を宣言することができる。

拡張として、GNU CとGNU C++は、すべてのターゲットでサポートされていない追加の浮動型をサポートしている。

@itemize @bullet
@item @code{__float128}は、i386、x86_64、IA-64、hppa HP-UX、およびベクトルスカラー（VSX）命令セットを有効にするPowerPC GNU/Linuxターゲットで利用できる。 @code{__float128}は128ビット浮動型をサポートしている。 HP-UX以外のi386、x86_64、PowerPC、およびIA-64では、@code{__float128}は@code {_Float128}の別名である。hppaとIA-64 HP-UXでは、@code{__float128}は@code{long double}の別名である。

@item @code{__float80}は、i386、x86_64、IA-64ターゲットで使用でき、80ビット（@code{XFmode}）浮動小数点型をサポートする。 これらのターゲット上のタイプ名@code {_Float64x}の別名である。

@item @code{__ibm128}はPowerPCターゲットで使用でき、@code{long double}に使用される現在のフォーマットであるIBM拡張倍精度フォーマットへのアクセスを提供する。 将来、PowerPC上で@code{long double}が@code{__float128}に移行するとき、@code {__ibm128}は2つのタイプ間の変換に使用される。
@end itemize

これらの追加タイプのサポートには、算術演算子が含まれる。加算、減算、乗算、除算; 単項算術演算子; 関係演算子; 等価演算子; 整数や他の浮動小数点型との変換などがある。 @code{__float80}型及び@code{__ibm128}型のリテラル定数に@samp{w}や@samp{W}の接尾辞を使用する。 @code{_float128}には、接尾辞@samp {q}または@samp {Q}を使用する。

PowerPC Linuxシステムで@code{_Float128}、@code{__float128}、@code{__ibm128}を使用するには、@option{-mfloat128}オプションを使用する必要がある。 GCCの将来のバージョンでは、@code{_Float128}と@code{__float128}が自動的に有効になることが期待される。

@code{_Float128}タイプは、@code{__float128}がサポートされているか、@code{long double}がIEEE binary128フォーマットを持つすべてのシステムでサポートされている。 @code{_Float64x}タイプは、@code{__float128}がサポートされているすべてのシステムでサポートされている。 @code{_Float32}タイプは、IEEE binary32をサポートするすべてのシステムでサポートされている。 @code{_Float64}および@code{_Float32x}タイプは、IEEE binary64をサポートするすべてのシステムでサポートされている。 @code{_Float16}タイプは、デフォルトではAArch64システムでサポートされ、ARMシステムでは、@option{-mfp16-format = ieee}で16ビット浮動小数点タイプのIEEEフォーマットが選択されている場合にサポートされる。 GCCは現在、どのシステムでも@code{_Float128x}をサポートしていない。

i386、x86_64、IA-64、およびHP-UXターゲットでは、@code{__float80}型の@code{XCmode}と@code{__float128}型の@code{TCmode}を使用して、複素数型を宣言することができる：

@smallexample
typedef _Complex float __attribute__((mode(TC))) _Complex128;
typedef _Complex float __attribute__((mode(XC))) _Complex80;
@end smallexample

PowerPC Linux VSXターゲットでは、対応する内部複素数型@code{__float128}型の@code{KCmode}と@code{__ibm128}型の@code {ICmode}を使用して複素数型を宣言できる。

@smallexample
typedef _Complex float __attribute__((mode(KC))) _Complex_float128;
typedef _Complex float __attribute__((mode(IC))) _Complex_ibm128;
@end smallexample

@node Half-Precision
@section 半精度浮動小数点型
@cindex half-precision floating point
@cindex @code{__fp16} data type

RMおよびAArch64ターゲットでは、GCCはARM C言語拡張で定義された@code{__fp16}型を使用して、半精度（16ビット）浮動小数点をサポートしている。ARMシステムでは、この型を使用するには@option{-mfp16-format}コマンドラインオプションで明示的に有効にする必要がある。

ARMターゲットは、半精度の浮動小数点値に対して2つの互換性のない表現をサポートしている。 表現の1つを選択し、プログラムで一貫して使用する必要がある。

@option{-mfp16-format=ieee}を指定すると、IEEE 754-2008形式が選択される。この形式は、@math{2^{-14}}〜65504の範囲の正規化された値を表すことができる。有効精度は11ビット、10進数で約３桁である。

@option{-mfp16-format=alternative}を指定すると、ARM代替フォーマットが選択される。 この表現はIEEE形式に似ているが、無限またはNaNをサポートしていない。 代わりに指数の範囲が拡張され、この形式は@math{2^{-14}}から131008の範囲の正規化された値を表すことができる。

AArch64のGCCポートは、IEEE 754-2008フォーマットのみをサポートしているため、@option{-mfp16-format}コマンドラインオプションを使用する必要はない。

@code{__fp16}型は、@code{<arm_fp16.h>}で定義された組み込み関数の引数として、または格納形式としてのみ使用できる。 算術演算およびその他の演算のために、CまたはC++式の@code{__fp16}の値は自動的に@code{float}に昇格される。

ARMターゲットは、VFPおよびNEON（拡張SIMD）の拡張機能として@code{__fp16}値と@code{float}値の間の変換をハードウェアでサポートし、ARMv8-Aはハードウェアで@code{__fp16}と@code{double}の値の変換をサポートする。GCCは、それらのハードウェア命令を提供するFPUを選択するオプションでコンパイルする場合、これらのハードウェア命令を使用してコードを生成する。 例えば、半精度形式を選択するための@option{-mfp16-format}オプションに加えて、@option{-mfpu=neon-fp16 -mfloat-abi=softfp}を使う。

@code{__fp16}データ型の言語レベルのサポートは、GCCがハードウェア浮動小数点命令を使用してコードを生成するかどうかに依存しない。 ハードウェアのサポートが指定されていない場合、GCCは@code{__fp16}と他の型との間の変換をライブラリ呼び出しとして実装する。

移植性のあるコードは、ISO / IEC TS 18661-3：2015で定義されている@code{_Float16}タイプを使用することを推奨する。 @xref{Floating Types}.

@node Decimal Float
@section 10進浮動小数点型
@cindex decimal floating types
@cindex @code{_Decimal32} data type
@cindex @code{_Decimal64} data type
@cindex @code{_Decimal128} data type
@cindex @code{df} integer suffix
@cindex @code{dd} integer suffix
@cindex @code{dl} integer suffix
@cindex @code{DF} integer suffix
@cindex @code{DD} integer suffix
@cindex @code{DL} integer suffix

拡張として、GNU Cは、ISO/IEC WDTR24732のN1312ドラフトで定義されているような、10進浮動小数点型をサポートしている。 テクニカルレポート草案の変更に伴い、GCCの10進浮動型のサポートが進化する。ターゲットの呼び出し規則も変更される可能性がある。 すべてのターゲットが10進浮動型をサポートしているわけではない。

10進浮動型は、@code{_Decimal32}、@code{_Decimal64}、@code{_Decimal128}である。 基数がC標準で指定されていないが通常は2である浮動小数点型@code{float}、@code{double}、@code{long double}とは異なり、10の基数を使用する。

小数浮動小数点型のサポートには、算術演算子の加算、減算、乗算、除算、単項算術演算子、関係演算子、等価演算子、整数や他の浮動小数点型との変換などがある。@code{_Decimal32}のリテラル定数の接尾辞には@samp{df}または@samp{DF}、@code{_Decimal64}には@samp {dd}または@samp {DD}、@code{_Decimal128}の場合は@samp {dl}と@samp{DL}を使う。

ドラフト技術レポートで指定されている小数点浮動小数点のGCCサポートは不完全である：

@itemize @bullet
@item
10進浮動小数点型の値を、それが変換される整数型で表現できない場合、結果は、技術報告書草案で指定された結果値ではなく、未定義である。

@item
GCCは、@file{math.h}、@file{fenv.h}、@file{stdio.h}、@file{stdlib.h}、および@file{wchar.h}に関連するCライブラリ機能を提供していない。 これは、別個のCライブラリ実装から来なければならない。このため、GNU Cコンパイラは、実装が技術レポートに準拠していることを示すためにマクロ@code{__STDC_DEC_FP__}を定義していない。
@end itemize

タイプ@code{_Decimal32}、@code{_Decimal64}、@code{_Decimal128}は、DWARFデバッグ情報フォーマットでサポートされている。

@node Hex Floats
@section 16進浮動小数点数
@cindex hex floats

ISO C99は、@code{1.55e1}のような通常の10進表記だけでなく、16進形式で書かれた@code{0x1.fp3}のような数字で書いた浮動小数点数もサポートしている。 GNU拡張として、GCCはこれをC90モード（厳密に準拠している場合を除く）とC++でサポートしている。 そのフォーマットでは、@samp{0x}16進数導入子と@samp{p}または@samp{P}指数フィールドは必須である。 指数は、有意な部分が乗算される2の累乗を示す10進数である。従って@samp {0x1.f}は
@tex
$1 {15\over16}$,
@end tex
@ifnottex
1 15/16,
@end ifnottex
@samp {p3}は8を乗じ、@code{0x1.fp3}の値は@code {1.55e1}と同じである。

10進表記の浮動小数点数とは異なり、指数は常に16進表記で必要である。 さもなければ、コンパイラは、例えば@code{0x1.f}のあいまい性を解決することができない。@samp{f}は@code{float}型の浮動小数点定数の拡張でもあるので、これは@code{1.0f}または@code{1.9375}を意味する。

@node Fixed-Point
@section 固定小数点型
@cindex fixed-point types
@cindex @code{_Fract} data type
@cindex @code{_Accum} data type
@cindex @code{_Sat} data type
@cindex @code{hr} fixed-suffix
@cindex @code{r} fixed-suffix
@cindex @code{lr} fixed-suffix
@cindex @code{llr} fixed-suffix
@cindex @code{uhr} fixed-suffix
@cindex @code{ur} fixed-suffix
@cindex @code{ulr} fixed-suffix
@cindex @code{ullr} fixed-suffix
@cindex @code{hk} fixed-suffix
@cindex @code{k} fixed-suffix
@cindex @code{lk} fixed-suffix
@cindex @code{llk} fixed-suffix
@cindex @code{uhk} fixed-suffix
@cindex @code{uk} fixed-suffix
@cindex @code{ulk} fixed-suffix
@cindex @code{ullk} fixed-suffix
@cindex @code{HR} fixed-suffix
@cindex @code{R} fixed-suffix
@cindex @code{LR} fixed-suffix
@cindex @code{LLR} fixed-suffix
@cindex @code{UHR} fixed-suffix
@cindex @code{UR} fixed-suffix
@cindex @code{ULR} fixed-suffix
@cindex @code{ULLR} fixed-suffix
@cindex @code{HK} fixed-suffix
@cindex @code{K} fixed-suffix
@cindex @code{LK} fixed-suffix
@cindex @code{LLK} fixed-suffix
@cindex @code{UHK} fixed-suffix
@cindex @code{UK} fixed-suffix
@cindex @code{ULK} fixed-suffix
@cindex @code{ULLK} fixed-suffix

GNU Cは、ISO/IEC DTR 18037のN1169草案で定義されている固定小数点型をサポートしている。GCCの固定小数点型のサポートは、技術報告書のドラフトが変更されるにつれて進化する。 ターゲットの呼び出し規則も変更される可能性がある。 すべてのターゲットが固定小数点タイプをサポートするわけではない。

固定小数点型は
@code{short _Fract},
@code{_Fract},
@code{long _Fract},
@code{long long _Fract},
@code{unsigned short _Fract},
@code{unsigned _Fract},
@code{unsigned long _Fract},
@code{unsigned long long _Fract},
@code{_Sat short _Fract},
@code{_Sat _Fract},
@code{_Sat long _Fract},
@code{_Sat long long _Fract},
@code{_Sat unsigned short _Fract},
@code{_Sat unsigned _Fract},
@code{_Sat unsigned long _Fract},
@code{_Sat unsigned long long _Fract},
@code{short _Accum},
@code{_Accum},
@code{long _Accum},
@code{long long _Accum},
@code{unsigned short _Accum},
@code{unsigned _Accum},
@code{unsigned long _Accum},
@code{unsigned long long _Accum},
@code{_Sat short _Accum},
@code{_Sat _Accum},
@code{_Sat long _Accum},
@code{_Sat long long _Accum},
@code{_Sat unsigned short _Accum},
@code{_Sat unsigned _Accum},
@code{_Sat unsigned long _Accum},
@code{_Sat unsigned long long _Accum}である。

固定小数点データ値には、小数部分とオプションの整数部分が含まれる。固定小数点データのフォーマットは、ターゲットマシンによって異なる。

固定小数点型のサポートはいかを含む。
@itemize @bullet
@item
前置と後置のインクリメント・デクリメント演算子 (@code{++}, @code{--})
@item
単項算術演算子 (@code{+}, @code{-}, @code{!})
@item
二項算術演算子 (@code{+}, @code{-}, @code{*}, @code{/})
@item
2進シフト演算子 (@code{<<}, @code{>>})
@item
関係演算子 (@code{<}, @code{<=}, @code{>=}, @code{>})
@item
等価演算子 (@code{==}, @code{!=})
@item
代入演算子 (@code{+=}, @code{-=}, @code{*=}, @code{/=}, @code{<<=}, @code{>>=})
@item
整数・浮動小数点数・固定小数点の相互変換
@end itemize

固定小数点リテラル定数の接尾辞には以下を使う。
@itemize
@item @code{short _Fract}と@code{_Sat short _Fract}には@samp{hr}または@samp{HR}
@item @code{_Fract}と@code{_Sat _Fract}には@samp{r}または@samp{R}
@item @code{long _Fract}と@code{_Sat long _Fract}には@samp{lr}または@samp{LR}
@item @code{long long _Fract}と@code{_Sat long long _Fract}には@samp{llr}または@samp{LLR}
@item @code{unsigned short _Fract}と@code{_Sat unsigned short _Fract}には@samp{uhr}または@samp{UHR}
@item @code{unsigned _Fract}と@code{_Sat unsigned _Fract}には@samp{ur}または@samp{UR}
@item @code{unsigned long _Fract}と@code{_Sat unsigned long _Fract}には@samp{ulr}または@samp{ULR}
@item @code{unsigned long long _Fract}と@code{_Sat unsigned long long _Fract}には@samp{ullr}または@samp{ULLR}
@item @code{short _Accum}と@code{_Sat short _Accum}には@samp{hk}または@samp{HK}
@item @code{_Accum}と@code{_Sat _Accum}には@samp{k}または@samp{K}
@item @code{long _Accum}と@code{_Sat long _Accum}には@samp{lk}または@samp{LK}
@item @code{long long _Accum}と@code{_Sat long long _Accum}には@samp{llk}または@samp{LLK}
@item @code{unsigned short _Accum}と@code{_Sat unsigned short _Accum}には@samp{uhk}または@samp{UHK}
@item @code{unsigned _Accum}と@code{_Sat unsigned _Accum}には@samp{uk}または@samp{UK}
@item @code{unsigned long _Accum}と@code{_Sat unsigned long _Accum}には@samp{ulk}または@samp{ULK}
@item @code{unsigned long long _Accum}と@code{_Sat unsigned long long _Accum}には@samp{ullk}または@samp{ULLK}
@end itemize

テクニカルレポート草案で指定された固定小数点型のGCCサポートは不完全である：

@itemize @bullet
@item
オーバーフローや丸めの動作を制御するプラグマは実装されていない。
@end itemize

固定小数点タイプは、DWARFデバッグ情報フォーマットでサポートされている。

@node Named Address Spaces
@section 名前付きアドレス空間
@cindex Named Address Spaces

拡張として、GNU Cは、ISO/IEC DTR 18037のN1275ドラフトで定義されている名前付きアドレス空間をサポートしている。GCCの名前付きアドレス空間のサポートは、テクニカルレポート草案の変更に伴い進化する。 ターゲットの呼び出し規則も変更される可能性がある。 現在、AVR、SPU、M32C、RL78、およびx86ターゲットのみが汎用アドレス空間以外のアドレス空間をサポートしている。

アドレス空間識別子は、他のC型修飾子（例えば、@code{const}や@code{volatile}など）と全く同じように使用できる。 詳細については、N1275のマニュアルを参照せよ。

@anchor{AVR Named Address Spaces}
@subsection AVR名前付きアドレス空間

AVRターゲットには、読み込み専用のデータをフラッシュメモリに格納し、そのフラッシュから読み込みに必要な特別な命令@code{LPM}または@code{ELPM}を使用してそのデータにアクセスするために使用できるいくつかのアドレス空間がある。

@code{avrtiny}と@code{avrxmega3}に属するデバイスは、フラッシュメモリがRAMアドレス空間にマップされているため、@code{LD*}命令でフラッシュメモリにアクセスできる。 @code{__flash}や@ref{AVR Variable Attributes,,@code{progmem}}のような言語拡張は@emph{不要}である。これらのデバイスのデフォルトのリンカ記述ファイルはその機能を提供し、@ code {.rodata}はフラッシュに残る：コンパイラは@code{LD*}命令を生成し、リンカスクリプトはすべての@code{.rodata}シンボルにコア固有のオフセットを追加する：@code{avrtiny}の場合は@code{0x4000}、 @code {avrxmega3}の場合@code{0x8000}。それぞれのデバイスのリストについては、@ref{AVR Options}を参照せよ。

@code{avrtiny}や@code{avrxmega3}以外のデバイスでは、フラッシュメモリがRAMアドレス空間に見えないため、読み取り専用データを含むすべてのデータはRAM（汎用アドレス空間）に配置される。 （インライン）アセンブラコードを使用せずにこのデータにアクセスするための正しい命令を生成するために、フラッシュメモリ@emph{と}に読み出し専用データを配置するには、特別なアドレス空間が必要である。

@table @code
@item __flash
@cindex @code{__flash} AVR Named Address Spaces
@code{__flash}修飾子は、データを@code{.progmem.data}セクションに配置する。 データは@code{LPM}命令を使用して読み込まれる。 このアドレス空間へのポインタは16ビット幅である。

@item __flash1
@itemx __flash2
@itemx __flash3
@itemx __flash4
@itemx __flash5
@cindex @code{__flash1} AVR Named Address Spaces
@cindex @code{__flash2} AVR Named Address Spaces
@cindex @code{__flash3} AVR Named Address Spaces
@cindex @code{__flash4} AVR Named Address Spaces
@cindex @code{__flash5} AVR Named Address Spaces
これらは、@code{.progmem@var{N}.data}セクションのデータを検索する16ビットのアドレス空間である。ここで、@var{N}はアドレス空間@code {__flash@var{N}}を指す。コンパイラは、@code{ELPM}命令でデータを読み取る前に、@code{RAMPZ}セグメントレジスタを適切に設定する。

@item __memx
@cindex @code{__memx} AVR Named Address Spaces
これは、フラッシュとRAMを線形化する24ビットのアドレス空間である。アドレスの上位ビットがセットされると、下位2バイトをRAMアドレスとしてRAMからデータが読み出される。アドレスの上位ビットがクリアされている場合、アドレスの上位バイトに従って@code{RAMPZ}がセットされた状態でフラッシュからデータが読み出される。
@xref{AVR Built-in Functions,,@code{__builtin_avr_flash_segment}}.

このアドレス空間のオブジェクトは@code{.progmemx.data}にある。
@end table

@b{例}

@smallexample
char my_read (const __flash char ** p)
@{
    /* pはフラッシュへのポインタを指すRAMへのポインタである。
        pの最初の間接指定はRAMからのフラッシュポインタを読み込み、
        2番目の間接指定はこのフラッシュアドレスからcharを読み込む。 */

    return **p;
@}

/* フラッシュメモリにarray[]を配置する */
const __flash int array[] = @{ 3, 5, 7, 11, 13, 17, 19 @};

int i = 1;

int main (void)
@{
   /* フラッシュメモリから読んで17を返す */
   return array[array[i]];
@}
@end smallexample

@noindent
avr-gccでサポートされている名前付きアドレス空間ごとに、同じ名前の大文字の組み込みマクロが定義されている。目的は、それぞれのアドレス空間のサポートが利用可能かどうかをテストすることである：

@smallexample
#ifdef __FLASH
const __flash int var = 1;

int read_var (void)
@{
    return var;
@}
#else
#include <avr/pgmspace.h> /* From AVR-LibC */

const int var PROGMEM = 1;

int read_var (void)
@{
    return (int) pgm_read_word (&var);
@}
#endif /* __FLASH */
@end smallexample

@noindent
属性@ref{AVR Variable Attributes,,@code{progmem}}はデータをフラッシュに配置するが、汎用アドレス空間（RAMなど）から読み込んだデータにアクセスするため、@w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC}}の@code{pgm_read_byte}などの特別なアクセサが属性@code {progmem}とともに必要になる。

@noindent
@b{制限と警告}

@itemize
@item
@code{__flash}または@code{__flash@var{N}}アドレス空間の64KiBセクション境界を読み取ることは、未定義の動作を示す。 64KiBフラッシュセグメントの境界を越えた読取りをサポートする唯一のアドレス空間は@code{__memx}である。

@item
@code{__flash@var{N}}アドレス空間の1つを使用する場合は、必要に応じて@code{.progmem@var{N}.data}セクションを見つけるためにリンカースクリプトを配置する必要がある。

@item
非汎用アドレス空間へのデータまたはポインタは、すべて@code{const}、すなわち読み取り専用データとしてとして修飾する必要がある。これは、ソフトウェアのバージョン番号やキャリブレーションルックアップテーブルのようなアドレス空間のいずれかのデータが、ブートローダなどのロード時間の後に変更されることが意図されている場合にも適用される。 この場合、正しい修飾は@code {const} @code{volatile}であるため、コンパイラは既知の値を最適化したり、命令のオペランドに即値として挿入したりしてはならない。

@item
次のコードは、静的ストレージにある変数@code{pfoo}を24ビットアドレスで初期化する。
@smallexample
extern const __memx char foo;
const __memx void *pfoo = &foo;
@end smallexample

@item
ATtiny40のような縮小されたTinyデバイスでは、アドレススペースはサポートされていない。上に概説したように、オーバーヘッドなしでバニラC/C++コードを使用する。属性@code{progmem}はサポートされているが、動作が異なる。@ref{AVR Variable Attributes}を参照せよ。

@end itemize

@subsection M32C名前付きアドレス空間
@cindex @code{__far} M32C Named Address Spaces

M32Cターゲットでは、R8CおよびM16C CPUのバリエーションでは、最初の64Kバイトを超えるメモリにアクセスするために、32ビットアドレスを使用して@code{__far}で修飾された変数にアクセスする。 @code{__far}をM32CMまたはM32C CPUのバリアントとともに使用すると、効果はない。

@subsection RL78名前付きアドレス空間
@cindex @code{__far} RL78 Named Address Spaces

RL78ターゲットでは、@code{__far}で修飾された変数は、デフォルトの16ビットアドレスではなく32ビットポインタ（20ビットアドレス）でアクセスされる。 非遠隔変数は、アドレス空間の最上位64KiBに現れると仮定する。

@subsection SPU名前付きアドレス空間
@cindex @code{__ea} SPU Named Address Spaces

SPUのターゲット変数は、タイプを@code{__ea}アドレス空間識別子で修飾することによって、別のアドレス空間に属するものとして宣言することができる。

@smallexample
extern int __ea i;
@end smallexample

@noindent 
コンパイラは変数@code{i}にアクセスするための特別なコードを生成する。ランタイムライブラリのサポートを使用したり、そのアドレス空間にアクセスするための特別なマシン命令を生成することができる。

@subsection x86名前付きアドレス空間
@cindex x86 named address spaces

x86ターゲットでは、変数は@code{％fs}または@code{％gs}セグメントとの相対的なものとして宣言できる。

@table @code
@item __seg_fs
@itemx __seg_gs
@cindex @code{__seg_fs} x86 named address space
@cindex @code{__seg_gs} x86 named address space
オブジェクトは、それぞれのセグメントオーバーライド接頭辞でアクセスされる。

それぞれのセグメントベースは、オペレーティングシステム固有のいくつかの方法で設定する必要がある。 セグメントベースを検索するために高価なシステムコールを必要とするのではなく、これらのアドレス空間は汎用（フラット）アドレス空間の部分空間であるとはみなされない。これは、これらのアドレス空間と汎用アドレス空間の間のポインタを変換するために明示的なキャストが必要であることを意味する。実際には、アプリケーションは@code{uintptr_t}にキャストし、以前にインストールしたセグメントベースオフセットを適用する必要がある。

プリプロセッサシンボル@code{__SEG_FS}と@code{__SEG_GS}は、これらのアドレス空間がサポートされているときに定義される。
@end table

@node Zero Length
@section 長さゼロの配列
@cindex arrays of length zero
@cindex zero-length arrays
@cindex length-zero arrays
@cindex flexible array members

長さがゼロの配列はGNU Cでは許されている。実際には可変長オブジェクトのヘッダである構造体の最後の要素として非常に便利である。

@smallexample
struct line @{
  int length;
  char contents[0];
@};

struct line *thisline = (struct line *)
  malloc (sizeof (struct line) + this_length);
thisline->length = this_length;
@end smallexample

ISO C90では、@code{contents}の長さを1にする必要がある。つまり、スペースを浪費したり、@code{malloc}の引数を複雑にすることになる。

ISO C99では、@dfn{flexible array member}（可変長配列メンバ）を使用する。これは構文とセマンティクスが少し異なる。

@itemize @bullet
@item
可変長配列メンバは@code{contents []}と、@code {0}なしで書かれている。

@item
可変長配列メンバは型が不完全なため、@code{sizeof}演算子は適用されてはならない。 ゼロ長配列の元々の実装では、@code {sizeof}はゼロに評価される。

@item
可変長配列メンバは@code {struct}の最後のメンバとして表示され、それ以外の場合は非空でなければならない。

@item
可変長配列メンバを含む構造体またはそのような構造体を含む共用体（おそらく再帰的に）は、配列の構造体または要素のメンバであってはならない。 （ただし、これらの用途はGCCによって拡張機能として許可される）。
@end itemize

ゼロ長配列の空でない初期化は、配列よりも多くの初期化要素がある場合と同様に扱われる。「配列の余分な要素」に関する適切な警告が与えられ、余分な要素（この場合すべて ）は無視される。

GCCでは、可変長配列メンバの静的初期化が可能である。これは、元の構造体を含む新しい構造体を定義し、続いてデータを格納するのに十分な大きさの配列を定義することと同じである。たとえば以下のように、@code{f1}は@code{f2}のように宣言されているかのように構築される。

@smallexample
struct f1 @{
  int x; int y[];
@} f1 = @{ 1, @{ 2, 3, 4 @} @};

struct f2 @{
  struct f1 f1; int data[3];
@} f2 = @{ @{ 1 @}, @{ 2, 3, 4 @} @};
@end smallexample

@noindent
この拡張の利便性は、@code{f1}が望ましい型を持っているので、一貫して@code{f2.f1}を参照する必要がなくなる。

これは、未知のサイズの配列も@code{[]}で書かれている点で、通常の静的配列と対称的である。

もちろん、この拡張は、トップレベルのオブジェクトの最後に余分なデータがある場合にのみ意味を持つ。それ以外の場合は、後続のオフセットでデータを上書きする。 過度のネストされた配列の初期化による過度の複雑化と混乱を避けるために、構造体がトップレベルオブジェクトである場合を除いて、空ではない初期化を単に許可しない。 例えば：

@smallexample
struct foo @{ int x; int y[]; @};
struct bar @{ struct foo z; @};

struct foo a = @{ 1, @{ 2, 3, 4 @} @};        // @r{Valid.}
struct bar b = @{ @{ 1, @{ 2, 3, 4 @} @} @};    // @r{Invalid.}
struct bar c = @{ @{ 1, @{ @} @} @};            // @r{Valid.}
struct foo d[1] = @{ @{ 1, @{ 2, 3, 4 @} @} @};  // @r{Invalid.}
@end smallexample

@node Empty Structures
@section メンバなしの構造体
@cindex empty structures
@cindex zero-size structures

GCCでは、C構造体にメンバを持たせないことができる：

@smallexample
struct empty @{
@};
@end smallexample

構造体のサイズはゼロである。 C++では、空の構造が言語の一部である。 G++は、空の構造体が@code{char}型の単一のメンバーを持つかのように扱う。

@node Variable Length
@section 可変長の配列
@cindex variable-length arrays
@cindex arrays of variable length
@cindex VLAs

ISO C99では可変長の自動配列が許可されていて、GCCはC90モードとC++でそれらを受け入れる。 これらの配列は他の自動配列と同様に宣言されるが、長さは定数式ではない。 記憶域は宣言のポイントに割り当てられ、宣言を含むブロックスコープが終了すると割り当てが解除される。 例えば：

@smallexample
FILE *
concat_fopen (char *s1, char *s2, char *mode)
@{
  char str[strlen (s1) + strlen (s2) + 1];
  strcpy (str, s1);
  strcat (str, s2);
  return fopen (str, mode);
@}
@end smallexample

@cindex scope of a variable length array
@cindex variable-length array scope
@cindex deallocating variable length arrays
配列名の範囲を飛び越したり抜けたりすると、記憶域の割り当てが解放される。 スコープにジャンプすることはできない。 そのためのエラーメッセージが表示される。

@cindex variable-length array in a structure
拡張として、GCCは可変長配列を構造体または共用体のメンバーとして受け入れる。 例えば：

@smallexample
void
foo (int n)
@{
  struct S @{ int x[n]; @};
@}
@end smallexample

@cindex @code{alloca} vs variable-length arrays
可変長配列によく似た効果を得るには、関数@code{alloca}を使うことができる。 関数@code{alloca}は他の多くのC実装で利用可能である（ただし、すべてではない）。 一方、可変長配列はよりエレガントである。

これらの2つの方法には他にも違いがある。 @code{alloca}で割り当てられたスペースは、それを含む@emph{関数}が返るまで存在する。可変長配列の空間は、このスコープで@code{alloca}も使用しない限り、配列名のスコープが終了するとすぐに割り当てから解放される。

関数の引数として可変長配列を使うこともできる：

@smallexample
struct entry
tester (int len, char data[len][len])
@{
  /* @r{@dots{}} */
@}
@end smallexample

配列の長さは、記憶域が割り当てられたときに1回計算され、@code{sizeof}でアクセスする場合には配列のスコープのために記憶される。

最初に配列を渡し、後に長さを渡す場合は、パラメータリストの前方宣言---別のGNU拡張を使用できる。

@smallexample
struct entry
tester (int len; char data[len][len], int len)
@{
  /* @r{@dots{}} */
@}
@end smallexample

@cindex parameter forward declaration
セミコロンの前の@samp{int len}は@dfn{parameter forward declaration}（パラメータの前方宣言）であり、@code {data}の宣言が解析されるときに、@code{len}という名前を知らせる目的に役立つ。

このようなパラメータの前方宣言は、パラメータリストに任意の数書くことができる。 それらはカンマまたはセミコロンで区切ることができるが、最後のものはセミコロンで終わらなければならない。その後に「実」パラメータ宣言が続く。 各前方宣言は、パラメータ名とデータ型の「実際の」宣言と一致しなければならない。 ISO C99では、パラメータの前方宣言はサポートされていない。

@node Variadic Macros
@section 可変長の引数を持つマクロ
@cindex variable number of arguments
@cindex macro with variable arguments
@cindex rest argument (in macro)
@cindex variadic macros

1999年のISO C標準では、マクロが関数のできる限り多くの引数を受け入れると宣言することができる。 マクロを定義する構文は、関数の構文に似ている。 次に例を示す。

@smallexample
#define debug(format, ...) fprintf (stderr, format, __VA_ARGS__)
@end smallexample

@noindent
@samp{@dots{}}は@dfn{variable argument}（可変引数）である。 このようなマクロの呼び出しでは、カンマを含めて呼び出しを終了する閉じ括弧まで0個以上のトークンを表す。 このトークンのセットは、マクロ本体の識別子@code{__VA_ARGS__}を置き換える。 詳細については、CPPマニュアルを参照せよ。

GCCは可変長マクロを長い間サポートしていて、他の引数と同じように可変引数に名前を付けることを可能にする別の構文を使用していた。 次に例を示す。

@smallexample
#define debug(format, args...) fprintf (stderr, format, args)
@end smallexample

@noindent
これは、上記のISO Cの例とすべての点で同じだが、おそらく読みやすく記述的である。

GNU CPPにはさらに2つの可変長マクロ拡張があり、上記のマクロ定義のいずれかで使用することができる。

標準Cでは、可変引数を完全に除外することはできない。 空の引数を渡すことは許されている。 たとえば、この呼び出しはISO Cでは無効である。文字列の後にカンマがないためである。

@smallexample
debug ("A message")
@end smallexample

GNU CPPでは、このように可変引数を完全に省略することができる。 上記の例では、マクロの展開にフォーマット文字列の後に余分なカンマが残っているため、コンパイラは不平を言う。

この問題を解決するために、CPPはトークンペースト演算子@samp {##}で使用される可変引数に対して特別に動作する。 代わりにこう書く場合

@smallexample
#define debug(format, ...) fprintf (stderr, format, ## __VA_ARGS__)
@end smallexample

@noindent
そして可変引数が省略または空の場合、@samp{##}演算子はプリプロセッサに前のコンマを削除させる。 マクロ呼び出しでいくつかの可変引数を指定した場合、GNU CPPは貼り付け操作について不平を言わず、可変引数をカンマの後ろに置く。 貼り付けられた他のマクロ引数と同じように、これらの引数はマクロ展開されない。

@node Escaped Newlines
@section エスケープされた改行のためのややゆるい規則
@cindex escaped newlines
@cindex newlines (escaped)

エスケープされた改行のプリプロセッサ処理は、改行がバックスラッシュの直後に続くことを必要とするC90標準で指定されているものよりも緩やかである。GCCの実装では、空白、水平および垂直のタブ、およびバックスラッシュとそれに続く改行の間の書式フィードの形で空白を使用できる。 プリプロセッサは警告を出すが、有効なエスケープされた改行として扱い、2行を結合して1つの論理行を形成する。 これは、コメントとトークン、およびトークン間で機能する。 コメントはこのリラクゼーションの目的のために空白として扱われ@emph{ない}。なぜならそれらはまだスペースで置き換えられていないからである。

@node Subscripting
@section 非左辺値配列には添え字が付くことができる
@cindex subscripting
@cindex arrays, non-lvalue

@cindex subscripting and function values
ISO C99では、左辺値ではない配列はポインタに成り下がり、添え字付きになることができるが、変更、次のシーケンスポイントの後での使用、単項@samp{＆}演算子への適用は許されていない。 拡張として、GNU Cはそのような配列をC90モードで添え字にすることができるが、それ以外の場合はC99モード以外のポインタには成り下がらない。 例えば、これはGNU Cでは有効だが、C90では有効ではない：

@smallexample
@group
struct foo @{int a[4];@};

struct foo f();

bar (int index)
@{
  return f().a[index];
@}
@end group
@end smallexample

@node Pointer Arith
@section @code{void}と関数ポインタの算術
@cindex void pointers, arithmetic
@cindex void, size of pointer to
@cindex function pointers, arithmetic
@cindex function, size of pointer to

GNU Cでは、@code{void}へのポインタと関数へのポインタについて、加算と減算の操作がサポートされている。 これは、@code{void}や関数のサイズを1として扱うことによって行われる。

その結果、@code{sizeof}は@code{void}と関数型でも許され、1を返す。

@opindex Wpointer-arith
@option {-Wpointer-arith}オプションは、これらの拡張が使用されている場合に警告を要求する。

@node Pointers to Arrays
@section 修飾子付き配列へのポインタは期待どおりに動作する
@cindex pointers to arrays
@cindex const qualifier

GNU Cでは、修飾子を持つ配列へのポインタは、他の修飾された型へのポインタと同様の働きをする。 たとえば、@code{int(*)[5]}型の変数を使用して、@code{const int(*)[5]}型の変数を初期化することができる。これらの型はISO Cでは互換性がない。@code{const}修飾子は配列自体ではなく配列の要素型に正式に付けられているからである。

@smallexample
extern void
transpose (int N, int M, double out[M][N], const double in[N][M]);
double x[3][2];
double y[2][3];
@r{@dots{}}
transpose(3, 2, y, x);
@end smallexample

@node Initializers
@section 非定数初期化子
@cindex initializers, non-constant
@cindex non-constant initializers

標準C++やISO C99のように、自動変数の集約イニシャライザの要素は、GNU Cでは定数式である必要はない。実行時に変化する要素を持つイニシャライザの例を次に示す。

@smallexample
foo (float f, float g)
@{
  float beat_freqs[2] = @{ f-g, f+g @};
  /* @r{@dots{}} */
@}
@end smallexample

@node Compound Literals
@section 複合リテラル
@cindex constructor expressions
@cindex initializations in expressions
@cindex structures, constructor expression
@cindex expressions, constructor
@cindex compound literals
@c The GNU C name for what C99 calls compound literals was "constructor expressions".

複合リテラルは、中括弧で囲まれた集約初期化子リストのキャストのように見える。 その値は、初期化子で指定された要素を含むキャストで指定された型のオブジェクトである。キャストの結果とは異なり、複合リテラルは左辺値である。 ISO C99以降では複合リテラルをサポートしている。 拡張として、GCCはC90モードとC++でも複合リテラルをサポートしているが、後述するようにC++のセマンティクスは多少異なる。

通常、複合リテラルの指定された型は構造体である。 以下のように@code{struct foo}と@code{structure}が宣言されているとする。

@smallexample
struct foo @{int a; char b[2];@} structure;
@end smallexample

@noindent
複合リテラルで@code{struct foo}を構築する例を次に示す。

@smallexample
structure = ((struct foo) @{x + y, 'a', 0@});
@end smallexample

@noindent
これは、次の記述と同じである。

@smallexample
@{
  struct foo temp = @{x + y, 'a', 0@};
  structure = temp;
@}
@end smallexample

以下で説明するように、C++では危険だが、配列を作成することもできる。 複合リテラルのすべての要素が、静的記憶期間のオブジェクトのイニシャライザでの使用に適した簡単な定数式であれば、複合リテラルはその最初の要素へのポインタに強制され、そのようなイニシャライザで使用される。 ここに示すように：

@smallexample
char **foo = (char *[]) @{ "x", "y", "z" @};
@end smallexample

スカラ型と共用体型の複合リテラルも使用できる。 以下の例では、変数@code{i}は、複合リテラルによって作成された名前のないオブジェクトをインクリメントした結果、値@code{2}に初期化される。

@smallexample
int i = ++(int) @{ 1 @};
@end smallexample

GNUの拡張として、GCCはコンパイルリテラルによる静的な格納期間を持つオブジェクトの初期化を可能にする（初期化子は定数ではないためISO C99では不可能である）。 複合リテラルとオブジェクトの型が一致する場合は、中括弧で囲まれたリストでオブジェクトが初期化されたかのように扱われる。複合リテラルの要素は定数でなければならない。初期化されるオブジェクトの配列型が未知のサイズの場合、サイズは複合リテラルのサイズによって決まる。

@smallexample
static struct foo x = (struct foo) @{1, 'a', 'b'@};
static int y[] = (int []) @{1, 2, 3@};
static int z[] = (int [3]) @{1@};
@end smallexample

@noindent
上記の行は、次の行に相当する。
@smallexample
static struct foo x = @{1, 'a', 'b'@};
static int y[] = @{1, 2, 3@};
static int z[] = @{1, 0, 0@};
@end smallexample

Cでは、複合リテラルは、静的または自動記憶期間を持つ名前のないオブジェクトを指定する。 C++では、複合リテラルは、完全表現の終わりまで存続する一時オブジェクトを指定する。その結果、複合リテラルのサブオブジェクトのアドレスを取得する明確に定義されたCコードは、C++では未定義となるため、G++は一時配列のポインタへの変換を拒否する。たとえば、上記の配列の複合リテラルの例が関数内に現れた場合、C++で@code{foo}を使用すると、配列の寿命が@code{foo}の宣言の後で終わるため、未定義の動作になる。

最適化として、G++は、配列の複合リテラルの寿命を長くすることがある：配列が関数の外に出現するか、@ code{const}修飾型を持つ場合である。 @code{foo}とその初期化子が@code{char *}ではなく@code{char * const}型の要素を持っていた場合、または@code{foo}がグローバル変数であった場合、配列は静的な記憶期間を持つ。 しかし、おそらくC++コードで配列複合リテラルを使用しないようにするのが最も安全である。

@node Designated Inits
@section 指示付きの初期化子
@cindex initializers with labeled elements
@cindex labeled elements in initializers
@cindex case labels in initializers
@cindex designated initializers

標準C90では、イニシャライザの要素は、初期化される配列または構造体の要素の順序と同じ、固定された順序で表示する必要がある。

ISO C99では、配列のインデックスや構造体フィールド名を指定して任意の順序で要素を与えることができ、GNU CではこれをC90モードの拡張としても許可する。 この拡張はGNU C++では実装されていない。

配列インデックスを指定するには、要素値の前に@samp{[@var{index}]=}を記述する。 例えば、

@smallexample
int a[6] = @{ [4] = 29, [2] = 15 @};
@end smallexample

@noindent
は以下と等価である。

@smallexample
int a[6] = @{ 0, 0, 15, 0, 29, 0 @};
@end smallexample

@noindent
初期化される配列が自動であっても、インデックス値は定数式でなければならない。

GCC 2.5以降では時代遅れとなったが、GCCがまだ受け入れている代替構文は、エレメント値の前に@samp{[@var{index}]}を書くことである。@samp{=}はない。

要素の範囲を同じ値に初期化するには、@samp{[@var{first}...@var{last}]=@var{value}}と記述する。 これはGNU拡張である。 例えば、

@smallexample
int widths[] = @{ [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 @};
@end smallexample

@noindent
その値に副作用がある場合、副作用は、初期化されたフィールドごとにではなく、範囲初期化子によって1回だけ発生する。

@noindent
配列の長さは指定された最大値+1であることに注意せよ。

構造体初期化子で、要素値の前に@samp {.@var{fieldname}=}で初期化するフィールドの名前を指定する。 例えば、以下の構造が与えられると、

@smallexample
struct point @{ int x, y; @};
@end smallexample

@noindent
以下の初期化子は

@smallexample
struct point p = @{ .y = yvalue, .x = xvalue @};
@end smallexample

@noindent
以下と等価である。

@smallexample
struct point p = @{ xvalue, yvalue @};
@end smallexample

同じ意味を持ち、GCC 2.5から廃止された別の構文@samp{@var{fieldname}:}では、ここに示すように：

@smallexample
struct point p = @{ y: yvalue, x: xvalue @};
@end smallexample

省略されたフィールドメンバは、静的格納期間を持つオブジェクトと同じように暗黙的に初期化される。

@cindex designators
@samp{[@var{index}]}や@samp{.@var{fieldname}}は@dfn{designator}（指定子）として知られている。 また、共用体を初期化するときに、指定子（または廃止されたコロン構文）を使用して、共用体のどの要素を使用するかを指定することもできる。 例えば、

@smallexample
union foo @{ int i; double d; @};

union foo f = @{ .d = 4 @};
@end smallexample

@noindent
2番目の要素を使用して4を@code{double}に変換して共用体に格納する。 対照的に、4を型@code{union foo}にキャストすると、それは整数なので整数@code{i}として共用体に格納される。@xref{Cast to Union}.

要素を命名するこの手法を、連続する要素の通常のC初期化と組み合わせることができる。 指定子を持たない各初期化子要素は、配列または構造体の次の連続する要素に適用される。 例えば、

@smallexample
int a[6] = @{ [1] = v1, v2, [4] = v4 @};
@end smallexample

@noindent
は以下と等価である。

@smallexample
int a[6] = @{ 0, v1, v2, 0, v4, 0 @};
@end smallexample

配列の初期化子の要素にラベルを付けることは、インデックスが文字であるか、@code{enum}型に属している場合に特に便利である。例えば：

@smallexample
int whitespace[256]
  = @{ [' '] = 1, ['\t'] = 1, ['\h'] = 1,
      ['\f'] = 1, ['\n'] = 1, ['\r'] = 1 @};
@end smallexample

@cindex designator lists
@samp{=}の前に一連の@samp{.@var{fieldname}}と@samp{[@var{index}]}を書くことで、ネストされたサブオブジェクトを指定して初期化することもできる。 そのリストは、最も近い周囲の中括弧対に対応するサブオブジェクトに関連して取られる。 たとえば、上記の@samp{struct point}宣言を使用すると、次のようになる。

@smallexample
struct point ptarray[10] = @{ [2].y = yv2, [2].x = xv2, [0].x = xv0 @};
@end smallexample

@noindent
同じフィールドが複数回初期化されている場合、最後の初期化の値を持つ。 そのような上書きされた初期化が副作用を持つ場合、副作用が発生するかどうかは不明である。 現在、GCCはそれらを破棄して警告を出す。

@node Case Ranges
@section Case範囲
@cindex case ranges
@cindex ranges in case statements

以下のように、単一の@code {case}ラベルに連続した値の範囲を指定することができる。

@smallexample
case @var{low} ... @var{high}:
@end smallexample

@noindent
これは@var {low}から@var {high}までの整数値ごとに1つずつ、個々の@code {case}ラベルの適切な数と同じ効果を持つ。

この機能は、ASCII文字コードの範囲で特に便利である。

@smallexample
case 'A' ... 'Z':
@end smallexample

@strong{注意:} @code {...}の周囲にスペースを入れること。そうしないと、整数値を使うときに間違って解釈される可能性がある。 たとえば、次のように記述する。

@smallexample
case 1 ... 5:
@end smallexample

@noindent
こうではなく：

@smallexample
case 1...5:
@end smallexample

@node Cast to Union
@section 共用体型へのキャスト
@cindex cast to a union
@cindex union, casting to a

共用体型へのキャストは、指定された型が共用体型であることを除いて、他のキャストと似ている。 型を@code{union}キーワードか、共用体を参照する@code {typedef}名で指定することができる。 共用体へのキャストは実際に複合リテラルを作成し、真のキャストのような右辺値ではなく左辺値を生成する。@xref{Compound Literals}.

共用体型にキャストされる型は、共用体のメンバーの型である。 したがって、以下の結合と変数が与えられているとすると

@smallexample
union foo @{ int i; double d; @};
int x;
double y;
@end smallexample

@noindent
@code{x}と@code{y}の両方を@code{union foo}へキャストすることができる。

共用体型の変数への代入の右辺としてのキャストを使用することは、共用体型のメンバーに格納することと同じである。

@smallexample
union foo u;
/* @r{@dots{}} */
u = (union foo) x  @equiv{}  u.i = x
u = (union foo) y  @equiv{}  u.d = y
@end smallexample

関数の引数としてユニオンキャストを使うこともできる：

@smallexample
void hack (union foo);
/* @r{@dots{}} */
hack ((union foo) x);
@end smallexample

@node Mixed Declarations
@section 宣言とコードの混在
@cindex mixed declarations and code
@cindex declarations, mixed with code
@cindex code, mixed with declarations

ISO C99およびISO C++では、複合宣言内で宣言とコードを自由に混在させることができる。 拡張として、GNU CではC90モードも可能である。 たとえば、次のようにすることができる。

@smallexample
int i;
/* @r{@dots{}} */
i++;
int j = i + 2;
@end smallexample

各識別子は、それが囲まれたブロックの終わりまで宣言されているところから見ることができる。

@node Function Attributes
@section 関数属性の宣言
@cindex function attributes
@cindex declaring attributes of functions
@cindex @code{volatile} applied to function
@cindex @code{const} applied to function

GNU Cでは、関数属性を使用して、プログラムで呼び出される関数について特定のものを宣言することができる。これは、コンパイラが呼び出しを最適化し、コードをより慎重にチェックするのに役立つ。 たとえば、属性を使用して関数が決して返されない（@code{noreturn}）、引数だけに依存する値を返す（@code{pure}）、または@code{printf}スタイルの引数@code{format}）。

また、属性を使用して、注釈を付ける関数内のメモリ配置、コード生成オプション、またはコール/リターン規則を制御することもできる。 これらの属性の多くはターゲット固有である。 たとえば、多くのターゲットでは、割り込みハンドラ関数を定義するための属性がサポートされている。これらの関数は、通常、特殊なレジスタの使用法とリターン規則に従わなければならない。

関数の属性は宣言の@code{__attribute__}キーワードによって導入され、その後に二重括弧で囲まれた属性指定が続く。 宣言で複数の属性を指定するには、ダブルカッコ内でコンマで区切るか、別の属性宣言で属性宣言の直後に記述する。属性の構文と配置に関する正確な規則については、@xref{Attribute Syntax}を参照せよ。 同じ関数の異なる宣言上の互換性のある属性指定はマージされる。 同じ関数の宣言にすでに適用されている属性と互換性のない属性指定は、警告とともに無視される。

GCCは変数宣言（@pxref{Variable Attributes}）、ラベル（@pxref{Label Attributes}）、列挙子（@pxref{Enumerator Attributes}）、文（@pxref{Statement Attributes}）、型（@pxref{Type Attributes}）の属性もサポートしている。

属性とプラグマの目的にはいくつかの重複がある（@pxref{Pragmas,,GCCで受け入れられるプラグマ}）。 @code {#pragma}は自然に文法の一部を形成しない他のコンパイラや構文との互換性のために使用されるが、@code{__attribute__}を使用して対応する宣言に属性を自然に付加することが便利であることがわかった。

ここに記述されている属性に加えて、GCCプラグインは独自の属性を提供することがある。

@menu
* Common Function Attributes::
* AArch64 Function Attributes::
* ARC Function Attributes::
* ARM Function Attributes::
* AVR Function Attributes::
* Blackfin Function Attributes::
* CR16 Function Attributes::
* Epiphany Function Attributes::
* H8/300 Function Attributes::
* IA-64 Function Attributes::
* M32C Function Attributes::
* M32R/D Function Attributes::
* m68k Function Attributes::
* MCORE Function Attributes::
* MeP Function Attributes::
* MicroBlaze Function Attributes::
* Microsoft Windows Function Attributes::
* MIPS Function Attributes::
* MSP430 Function Attributes::
* NDS32 Function Attributes::
* Nios II Function Attributes::
* Nvidia PTX Function Attributes::
* PowerPC Function Attributes::
* RISC-V Function Attributes::
* RL78 Function Attributes::
* RX Function Attributes::
* S/390 Function Attributes::
* SH Function Attributes::
* SPU Function Attributes::
* Symbian OS Function Attributes::
* V850 Function Attributes::
* Visium Function Attributes::
* x86 Function Attributes::
* Xstormy16 Function Attributes::
@end menu

@node Common Function Attributes
@subsection 共通関数属性

次の属性は、ほとんどのターゲットでサポートされている。

@table @code
@c Keep this table alphabetized by attribute name.  Treat _ as space.

@item alias ("@var{target}")
@cindex @code{alias} function attribute
@code{alias}属性は宣言を他のシンボルのエイリアスとして出力し、指定する必要がある。 例えば、

@smallexample
void __f () @{ /* @r{Do something.} */; @}
void f () __attribute__ ((weak, alias ("__f")));
@end smallexample

@noindent
は、@samp{f}が@samp{__f}の弱いエイリアスであると定義している。 C++では、ターゲットの変更された名前を使用する必要がある。 @samp{__f}が同じ翻訳単位で定義されていないと、エラーになる。

この属性には、アセンブラとオブジェクトファイルのサポートが必要である。また、すべてのターゲットで使用できるわけではない。

@item aligned (@var{alignment})
@cindex @code{aligned} function attribute
この属性は、関数の最小アラインメントをバイト単位で指定する。

この属性を使用して関数のアラインメントを減らすことはできない。 しかし、関数の配置を明示的に指定すると、この関数の@option{-falign-functions}（@pxref{Optimize Options}）オプションの効果が上書きされる。

@code{aligned}属性の有効性は、リンカの固有の制限によって制限されることに注意せよ。 多くのシステムでは、リンカは関数が特定の最大アラインメントまで整列するようにのみ調整することができる。 （一部のリンカでは、サポートされている最大のアラインメントは非常に小さいかもしれない）。詳細については、リンカのマニュアルを参照せよ。

@code{aligned}属性は、変数やフィールドにも使用できる（@pxref {Variable Attributes}。）

@item alloc_align
@cindex @code{alloc_align} function attribute
@code{alloc_align}属性は、関数の戻り値がメモリを指していることをコンパイラに知らせるために使用される。返されるポインタの最小アラインメントは、関数のパラメータの1つによって与えられる。 GCCは、この情報を使用してポインタのアラインメント解析を改善する。

割り当てられたアラインメントを示す関数パラメータは、整数の引数で指定される。その数は属性の引数である。引数の番号付けは1から始まる。

例えば、

@smallexample
void* my_memalign(size_t, size_t) __attribute__((alloc_align(1)))
@end smallexample

@noindent
@code {my_memalign}はパラメータ1によって与えられた最小整列でメモリを返すと宣言する。

@item alloc_size
@cindex @code{alloc_size} function attribute
@code{alloc_size}属性は、関数の戻り値がメモリを指していることをコンパイラに知らせるために使用される。サイズは関数のパラメータの1つまたは2つで与えられる。 GCCはこの情報を使って@code{__builtin_object_size}の正しさを向上させる。

割り当てられたサイズを示す関数パラメータは、属性に供給される1つまたは2つの整数引数によって指定される。 割り当てられたサイズは、指定された単一の関数引数の値か、指定された2つの関数引数の積のいずれかである。 引数の番号付けは1から始まる。

例えば、

@smallexample
void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))
void* my_realloc(void*, size_t) __attribute__((alloc_size(2)))
@end smallexample

@noindent
@code{my_calloc}はパラメータ1と2の積によって与えられたサイズのメモリを返し、@code{my_realloc}はパラメータ2で与えられたサイズのメモリを返すと宣言する。

@item always_inline
@cindex @code{always_inline} function attribute
一般に、最適化が指定されない限り、関数はインライン化されない。インラインで宣言された関数の場合、この属性はインライン展開に適用される制限とは関係なく関数をインライン化する。このような機能をインライン化できない場合は、エラーと診断される。このような関数が間接的に呼び出された場合、コンパイラは最適化レベルに応じてインライン展開することも、インライン展開しないこともあり、間接呼び出しをインライン化できないかどうかは診断されることもない。

@item artificial
@cindex @code{artificial} function attribute
この属性は、可能であればデバッグ中にユニットとして表示されるべき小さなインラインラッパーに役立つ。 デバッグ情報のフォーマットに応じて、関数を人為的なものとしてマークするか、インラインボディ内のすべての命令に対して呼び出し元の位置を使用することを意味する。

@item assume_aligned
@cindex @code{assume_aligned} function attribute
@code{assume_aligned}属性は、関数の戻り値がメモリを指すことをコンパイラに伝えるために使用される。返されるポインタの最小アラインメントは最初の引数によって与えらる。 属性に2つの引数がある場合、2番目の引数は位置ずれオフセットである。

例えば、

@smallexample
void* my_alloc1(size_t) __attribute__((assume_aligned(16)))
void* my_alloc2(size_t) __attribute__((assume_aligned(32, 8)))
@end smallexample

@noindent
は、@code{my_alloc1}が16バイトにアラインメントされたポインタを返し、@code{my_alloc2}は32を法とする値が8に等しいポインタを返すと宣言する。

@item bnd_instrument
@cindex @code{bnd_instrument} function attribute
関数の@code{bnd_instrument}属性は、コンパイラに@option{-fchkp-instrument-marked-only}オプションを指定してコンパイルしたときに、関数を計装する必要があることをコンパイラに通知するために使用される。

@item bnd_legacy
@cindex @code{bnd_legacy} function attribute
@cindex Pointer Bounds Checker attributes
関数の@code{bnd_legacy}属性は、コンパイラに@option{-fcheck-pointer-bounds}オプションを指定してコンパイルしたときに、関数を計装してはならないことをコンパイラに通知するために使用される。

@item cold
@cindex @code{cold} function attribute
関数の@code{cold}属性は、関数が実行される可能性が低いことをコンパイラに通知するために使用される。関数はスピードではなくサイズに最適化される。多くのターゲットでは、テキストセクションの特別なサブセクションに配置されるため、すべてのコールド関数が近くに出力され、プログラムの非コールドパートのコードローカリティが向上する。コード内のコールド関数の呼び出しにつながるパスは、分岐予測メカニズムによってはそうでないとマークされる。したがって、@code{perror}のような、考えられない状況を処理するために使用される関数をcoldとしてマークして、まれにマーク関数を呼び出すホット関数の最適化を改善すると便利である。

@option{-fprofile-use}を介してプロファイルのフィードバックが利用可能になると、コールド関数が自動的に検出され、この属性は無視される。

@item const
@cindex @code{const} function attribute
@cindex functions that have no side effects
多くの関数は、引数を除くすべての値を調べず、値を返す以外の効果はない。 そのような関数への呼び出しは、共通部分式消去などの最適化に役立つ。@code{const}属性は、関数がグローバル変数を読み取ることを禁止するため、以下の同様の@code{pure}属性よりも関数の定義に大きな制限を課す。 その結果、関数宣言に属性が存在すると、GCCは関数呼び出しのためにより効率的なコードを出力することができる。 同じ関数を@code{const}属性と@code{pure}属性の両方で修飾すると診断される。

@cindex pointer arguments
ポインタ引数を持ち、指されるデータを調べる関数は、@code{const}と宣言されては@emph{ならない}ことに注意せよ。 同様に、非@code{const}関数を呼び出す関数は、通常は@code{const}であってはならない。 @code{const}関数は副作用を持つことができないので、そのような関数が@code{void}を返すのは意味がない。このような関数を宣言すると診断される。

@item constructor
@itemx destructor
@itemx constructor (@var{priority})
@itemx destructor (@var{priority})
@cindex @code{constructor} function attribute
@cindex @code{destructor} function attribute
@code{constructor}属性は、実行が自動的に@code{main()}に入る前に呼び出される。 同様に、@code{destructor}属性は、@code{main()}が完了した後、または@code {exit()}が呼び出された後に関数が自動的に呼び出されるようにする。 これらの属性を持つ関数は、プログラムの実行中に暗黙的に使用されるデータを初期化するのに便利である。

オプションの整数優先順位を指定して、コンストラクタ関数とデストラクタ関数の実行順序を制御できる。より小さい優先順位番号を持つコンストラクタは、より大きな優先順位番号を持つコンストラクタの前で実行される。 反対の関係はデストラクタにも当てはまる。したがって、リソースを割り当てるコンストラクタと同じリソースを割り当て解除するデストラクタがある場合、通常は両方の関数の優先度が同じになる。コンストラクタとデストラクタ関数の優先順位は、名前空間スコープのC++オブジェクト（@pxref{C++ Attributes}）で指定されたものと同じである。しかし、現時点では、静的な記憶期間と属性@code{constructor}で装飾された関数を持つC++オブジェクトのコンストラクタが呼び出される順序は不定である。混合宣言では、属性@code{init_priority}を使用して特定の順序付けを行うことができる。

@item deprecated
@itemx deprecated (@var{msg})
@cindex @code{deprecated} function attribute
関数がソースファイルのどこでも使用されている場合、@code{deprecated}属性は警告を出す。 これは、将来のバージョンのプログラムで削除される予定の機能を識別する場合に便利である。 この警告には、非推奨機能の宣言の場所も含まれている。これにより、ユーザーは、その機能が廃止された理由、またはその代わりに何をすべきかに関する情報を簡単に見つけることができる。 警告は使用時にのみ発生することに注意せよ。

@smallexample
int old_fn () __attribute__ ((deprecated));
int old_fn ();
int (*fn_ptr)() = old_fn;
@end smallexample

@noindent
3行目では警告が出ますが、2行目では表示されない。文字列でなければならないオプションの@var{msg}引数は、警告があれば出力される。

@code{deprecated}属性は、変数と型（@pxref{Variable Attributes}、@ pxref{Type Attributes}）にも使用できる。

@item error ("@var{message}")
@itemx warning ("@var{message}")
@cindex @code{error} function attribute
@cindex @code{warning} function attribute
@code{error}属性や@code {warning}属性が関数宣言で使用され、そのような関数の呼び出しがデッドコードの削除やその他の最適化によって排除されない場合、@var{message}を含むエラー及び警告が診断される。これはコンパイル時のチェック、特に@code{__builtin_constant_p}およびインライン関数の引数のチェックがトリック@code{extern char [(condition) ? 1 : -1];}では不可能なインライン関数に便利である。

関数を未定義のままにしてリンクエラーを引き起こすことは可能だが（@code {.gnu.warning *}セクションのメッセージで関数を定義する）、これらの属性を使用すると、インライン関数が存在する場合でも、デバッグ情報を出力しない場合でも、問題が早期に診断され、呼び出しの正確な位置で診断される。

@item externally_visible
@cindex @code{externally_visible} function attribute
グローバル変数または関数に付加されたこの属性は、@option{-fwhole-program}コマンドラインオプションの効果を無効にして、オブジェクトは現在のコンパイル単位の外側に表示されたままになる。

@option{-fwhole-program}を@option{-flto}と一緒に使用し、@command{gold}をリンカプラグインとして使用すると、@code{externally_visible}属性が関数に自動的に追加される。 @command{gold}によって生成された解決ファイルに従って、LTOオブジェクトの外部からアクセスされる。解決ファイルを生成できない他のリンカーに対しては、明示的な@code{externally_visible}属性が必要である。

@item flatten
@cindex @code{flatten} function attribute
一般に、関数へのインライン展開は限られている。 この属性でマークされた関数の場合、可能であれば、この関数内のすべての呼び出しがインライン展開される。関数自体がインライン展開の対象かどうかは、そのサイズと現在のインライン化パラメータによって異なる。

@item format (@var{archetype}, @var{string-index}, @var{first-to-check})
@cindex @code{format} function attribute
@cindex functions with @code{printf}, @code{scanf}, @code{strftime} or @code{strfmon} style arguments
@opindex Wformat
@code{format}属性は、関数がフォーマット文字列に対して型チェックされるべき@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}スタイルの引数をとることを指定する。 たとえば、次のような宣言があると、

@smallexample
extern int
my_printf (void *my_object, const char *my_format, ...)
      __attribute__ ((format (printf, 2, 3)));
@end smallexample

@noindent
コンパイラは@code{printf}形式の書式文字列引数@code{my_format}と一貫性を保つために@code{my_printf}への呼び出しで引数をチェックする。

パラメータ@var{archetype}はフォーマット文字列がどのように解釈されるかを決定し、@code{printf}、 @code{scanf}、 @code{strftime}、 @code{gnu_printf}、 @code{gnu_scanf}、 @code{gnu_strftime}、 @code{strfmon}のどれかである。 (@code{__printf__}、 @code{__scanf__}、 @code{__strftime__}、 @code{__strfmon__}を使うこともできる。)  MinGWターゲットでは、@code{ms_printf}、@code{ms_scanf}、@code{ms_strftime}も存在する。@code{printf}のような@var{archetype}の値は、システムのCランタイムライブラリが受け入れる形式を参照し、@samp{gnu_}が付いた値は常にGNU Cライブラリが受け入れた形式を参照する。Microsoft Windowsターゲットでは、@samp{ms_}という接頭辞の付いた値は、@file{msvcrt.dll}ライブラリで受け入れられる形式を参照する。@var{string-index}は、書式文字列の引数（1から始まる）を指定する。@var{first-to-check}は、書式文字列に対してチェックする最初の引数の番号である。引数がチェックできない関数（@code{vprintf}など）の場合は、3番目のパラメータをゼロとして指定する。 この場合、コンパイラは一貫性のために書式文字列のみをチェックする。 @code{strftime}形式の場合、3番目のパラメータはゼロにする必要がある。非静的なC++メソッドは暗黙の@code{this}引数を持つので、@var{string-index}と@var{first-to-check}の値を与えるときには、そのようなメソッドの引数を１ではなく2から数えてカウントする必要がある。

上記の例では、フォーマット文字列（@code{my_format}）は関数@code{my_print}の2番目の引数であり、チェックする引数は3番目の引数で始まるので、format属性の正しいパラメータは2と3である。

@opindex ffreestanding
@opindex fno-builtin
@code{format}属性を使うと、書式文字列を引数とする独自の関数を識別することができ、GCCはこれらの関数の呼び出しをエラーでチェックできる。 （@option{-freestanding}や@option{-fno-builtin}を使用しない限り）コンパイラは常に標準ライブラリ関数@code{printf}、 @code{fprintf}、 @code{sprintf}、 @code{scanf}、 @code{fscanf}、 @code{sscanf}、 @code{strftime}、 @code{vprintf}、 @code{vfprintf}、@code{vsprintf} ）をチェックするので、ヘッダファイル@file{stdio.h}を変更する必要はない。C99モードでは、関数@code{snprintf}、@code{vsnprintf}、@code{vscanf}、@code{vfscanf}、@code{vsscanf}もチェックされる。 厳密に準拠しているC標準モードを除いて、X/Open関数@code{strfmon}、@code{printf_unlocked}、@code{fprintf_unlocked}もチェックされる。@xref{C Dialect Options,,C変種を制御するオプション}。

Objective-C変種の場合、@code{NSString}（または@code{__NSString__}）は同じコンテキストで認識される。 これらの書式属性を含む宣言は正しい構文で解析されるが、そのような書式文字列のチェック結果はまだ定義されていないため、このバージョンのコンパイラでは実行されない。

ターゲットは、追加のタイプのフォーマットチェックを提供することもできる。@xref{Target Format Checks,,特定のターゲット機種に固有の書式チェック}。

@item format_arg (@var{string-index})
@cindex @code{format_arg} function attribute
@opindex Wformat-nonliteral
@code{format_arg}属性は、関数が@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}スタイル関数の書式文字列を取り、それを変更する（たとえば、 その結果を言語へと翻訳する）ことを指定し、@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}スタイル関数に渡すことができるようになる（書式関数の残りの引数は 変更されていない文字列の場合と同じである）。 たとえば、次のような宣言があると：

@smallexample
extern char *
my_dgettext (char *my_domain, const char *my_format)
      __attribute__ ((format_arg (2)));
@end smallexample

@noindent
コンパイラは、@code{printf}、@code{scanf}、@code{strftime}または@code{strfmon}型関数の呼び出しで引数をチェックする。書式文字列の引数は、@code{ my_dgettext}関数を使用して、書式文字列引数@code{my_format}と一貫性を保つ。@code{format_arg}属性が指定されていない場合、 書式関数へのそのような呼び出しに対してコンパイラが伝えることができるすべてのことは、フォーマット文字列の引数が定数ではないことである。@option{-Wformat-nonliteral}が使用されているときに警告が生成されるが、属性なしでは呼び出しをチェックすることはできない。

パラメータ@var{string-index}は、どの引数が書式文字列引数（1から始まる）かを指定する。 非静的なC++のメソッドは暗黙の@code{this}引数を持つので、そのようなメソッドの引数は2つから数える必要がある。

@code{format_arg}属性を使うと、書式文字列を変更する独自の関数を識別することができる。これにより、GCCはオペランドが自分の関数の呼び出しである@code{printf}、 @code{scanf}、@code{strftime}、@code{strfmon}型の関数への呼び出しをチェックできる。コンパイラは、@option{-ansi}および適切な@option{-std}オプションによって厳密なISO Cサポートが要求される場合、または@option{-freestanding}および@option {-fno-builtin}が使用される場合を除いて、この方法で@code{gettext}、@code{dgettext}、@code{dcgettext}を扱う。@xref{C Dialect Options,,C変種を制御するオプション}。

Objective-C変種の場合、@code{format-arg}属性は上記の@code{format}属性との互換性のために@code{NSString}参照を参照することがある。

ターゲットは@code{format-arg}属性で追加の型を許可するかもしれない。@xref{Target Format Checks,,特定のターゲット機種に固有の書式チェック}。

@item gnu_inline
@cindex @code{gnu_inline} function attribute
この属性は、@code{inline}キーワードも宣言されている関数で使用する必要がある。 GCCは、C99またはgnu99モードでコンパイルしていてもgnu90モードで定義されているかのように関数を扱うように指示する。

関数が@code{extern}と宣言されている場合、この関数の定義はインライン化にのみ使用される。関数がスタンドアロン関数としてコンパイルされることはない。たとえそのアドレスを明示的に指定したとしても、関数はコンパイルされない。
  このようなアドレスは、あたかも関数を宣言していて、定義していないかのように、外部参照になる。これはほとんどマクロの効果である。 これを使用する方法は、この属性を持つヘッダファイルに関数定義を置き、関数の別のコピーを@code{extern}なしでライブラリファイルに置くことである。ヘッダーファイルの定義によって、関数へのほとんどの呼び出しがインライン化される。 関数の使用が残っている場合は、ライブラリ内の単一のコピーを参照する。関数の2つの定義は正確に同じである必要はないが、同じ効果を持たなければプログラムが奇妙に動作する可能性がある。

Cでは、関数が@code{extern}でも@code{static}でもない場合、関数はスタンドアロン関数としてコンパイルされ、可能な限りインライン化される。

これは、GCCが伝統的に@code{inline}と宣言された関数をどのように扱うかを示している。 ISO C99では@code{inline}には異なるセマンティクスが指定されているので、この関数属性は遷移の指標として提供され、それ自体の有用な機能として提供される。 この属性はGCC 4.1.3以降で利用可能である。 プリプロセッサマクロ@code{__GNUC_GNU_INLINE__}または@code{__GNUC_STDC_INLINE__}のいずれかが定義されている場合に使用できる。

C++では、この属性は決して@code{extern}に依存しないが、特別な動作を可能にするためにはまだ@code{inline}キーワードが必要である。

@item hot
@cindex @code{hot} function attribute
関数の@code{hot}属性は、関数がコンパイルされたプログラムのホットスポットであることをコンパイラに知らせるために使用される。 この関数はより積極的に最適化され、多くのターゲットではテキストセクションの特別なサブセクションに配置されるので、すべてのホット関数が近くに出力され、地域性が向上する。

@option{-fprofile-use}を介してプロファイルのフィードバックが利用可能になると、ホット機能が自動的に検出され、この属性は無視される。

@item ifunc ("@var{resolver}")
@cindex @code{ifunc} function attribute
@cindex indirect functions
@cindex functions that are dynamically resolved
@code{ifunc}属性は、関数をELF標準へのSTT_GNU_IFUNCシンボル型拡張を使用して間接関数としてマークするために使用される。 これにより、ロード時にシンボル値の分解能を動的に決定することができ、最適化されたバージョンのルーチンを特定のプロセッサまたはそれ以外のシステム特性に対して選択される。この属性を使用するには、まず使用可能な実装関数を定義し、選択された実装関数へのポインタを返すリゾルバ関数を定義する。 実装関数の宣言は実装されている関数のAPIと一致していなければならない。リゾルバは、引数をとらず、実装と同じ型の関数へのポインタを返す関数であると宣言されるべきである。 例えば：

@smallexample
void *my_memcpy (void *dst, const void *src, size_t len)
@{
  @dots{}
  return dst;
@}

static void * (*resolve_memcpy (void))(void *, const void *, size_t)
@{
  return my_memcpy; // we will just always select this routine
@}
@end smallexample

@noindent
ユーザーが呼び出す関数を宣言したエクスポートされたヘッダーファイルには次のものが含まれる。

@smallexample
extern void *memcpy (void *, const void *, size_t);
@end smallexample

@noindent
これにより、ユーザーは実装を認識しない通常の関数として@code{memcpy}を呼び出すことができる。 最後に、間接関数をリゾルバ関数と同じ翻訳単位で定義する必要がある。

@smallexample
void *memcpy (void *, const void *, size_t)
     __attribute__ ((ifunc ("resolve_memcpy")));
@end smallexample

C++では、@code{ifunc}属性は、リゾルバ関数のマングル化された文字列を取る。 @code{C}クラスの非静的メンバ関数用のC++リゾルバは、非メンバ関数へのポインタを返すよう宣言し、最初の引数として@code{C}へのポインタをとり、実装関数と同じ引数が続くように宣言するべきである。G++は2つの関数のシグネチャをチェックし、不一致に関する@option{-Wattribute-alias}警告を発行する。実装メンバ関数へのポインタから対応する非メンバ関数の型への必要なキャストの警告を抑制するには、@option {-Wno-pmf-conversions}オプションを使用する。 例えば：

@smallexample
class S
@{
private:
  int debug_impl (int);
  int optimized_impl (int);

  typedef int Func (S*, int);
  
  static Func* resolver ();
public:

  int interface (int);
@};

int S::debug_impl (int) @{ /* @r{@dots{}} */ @}
int S::optimized_impl (int) @{ /* @r{@dots{}} */ @}

S::Func* S::resolver ()
@{
  int (S::*pimpl) (int)
    = getenv ("DEBUG") ? &S::debug_impl : &S::optimized_impl;

  // Cast triggers -Wno-pmf-conversions.
  return reinterpret_cast<Func*>(pimpl);
@}

int S::interface (int) __attribute__ ((ifunc ("_ZN1S8resolverEv")));
@end smallexample

間接関数を弱めることはできない。 この機能を使用するには、Binutilsバージョン2.20.1以降およびGNU Cライブラリバージョン2.11.1が必要である。

@item interrupt
@itemx interrupt_handler
多くのGCCバックエンドは、関数が割り込みハンドラであることを示す属性をサポートしている。これは、コンパイラが通常の関数とは異なる関数の入力および終了シーケンスを生成するように指示する。 正確な構文と動作はターゲット固有である。 詳細については、以下のサブセクションを参照せよ。

@item leaf
@cindex @code{leaf} function attribute
この属性を持つ外部関数への呼び出しは、リターンまたは例外処理によってのみ現在のコンパイル単位に戻されなければならない。特に、リーフ関数は、現在のコンパイル単位から渡されたコールバック関数を呼び出すこと、コンパイル単位によってエクスポートされた関数を直接呼び出すこと、またはコンパイル単位へと@code{longjmp}することはできない。 リーフ関数は他のコンパイル単位から関数を呼び出すかもしれないので、関数呼び出しをまったく含まないという意味で必ずしもリーフ関数ではない。

この属性は、ライブラリ関数がデータフロー解析を改善することを目的としている。コンパイラーは、現在のコンパイル単位を脱出しないデータは、リーフ関数で使用または変更できないというヒントを取る。 たとえば、@code{sin}関数はリーフ関数だが、@code{qsort}はリーフ関数ではない。

リーフ関数は、静的変数を使用する現在のコンパイル単位で定義されたシグナルハンドラを間接的に実行する可能性があることに注意せよ。同様に、遅延シンボル解決が有効な場合、リーフ関数は、リゾルバ関数または実装関数が現在のコンパイル単位で定義され、静的変数を使用する間接関数を呼び出すことがある。 このようなシグナルハンドラ、リゾルバ関数、または実装関数を書く標準に準拠した方法はなく、@code{leaf}属性を削除するか、そのような静的変数をすべて@code{volatile}とマークすることができる。最後に、シンボルの挿入をサポートするELFベースのシステムでは、現在のコンパイル単位で定義された関数が、定義された標準モードと定義された機能テストマクロに基づいて他のシンボルを予期せず挿入することに注意しなければならない。 そうしないと偶発的なコールバックが追加される。

この属性は、現在のコンパイル単位内で定義された関数には影響しない。 これは、例えば、リンク時の最適化を使用することによって、複数のコンパイル単位を1つに簡単にマージすることができる。 このため、間接呼び出しに注釈を付ける型では属性を使用できない。

@item malloc
@cindex @code{malloc} function attribute
@cindex functions that behave like malloc
これは、関数が@code {malloc}のようなものであることをコンパイラに伝える。すなわち、関数によって返されたポインタ@var{P}は、関数が返ったときに有効な他のポインタをエイリアスできず、 正当なオブジェクトへのどんなポインタも@var{P}で扱われる任意の記憶域を占めることはない。

この属性を使用すると、最適化が向上する。 @code{malloc}や@code{calloc}のような関数は、初期化されていない、またはゼロアウトしたストレージへのポインタを返すので、このプロパティを持っている。 しかし、@ code{realloc}のような関数は、ポインタを含む記憶域へのポインタを返すことができるので、このプロパティを持たない。

@item no_icf
@cindex @code{no_icf} function attribute
この関数属性は、関数が他の意味的に同等の関数とマージされることを防ぐ。

@item no_instrument_function
@cindex @code{no_instrument_function} function attribute
@opindex finstrument-functions
@option{-finstrument-functions}を指定すると、ユーザがコンパイルしたほとんどの関数の入口と出口でプロファイリング関数呼び出しが生成される。この属性を持つ関数は計装されない。

@item no_profile_instrument_function
@cindex @code{no_profile_instrument_function} function attribute
関数の@code{no_profile_instrument_function}属性は、プロファイルフィードバックに基づく最適化コード計測を処理すべきでないことをコンパイラーに通知するために使用される。

@item no_reorder
@cindex @code{no_reorder} function attribute
@code{no_reorder}とマークされた関数や変数を互いに並べ替えたり、トップレベルのアセンブラ文を実行可能ファイルと並べ替えたりしない。プログラムの実際の順序は、リンカーのコマンドラインによって異なる。 このようにマークされた静的変数も削除されない。これは@option{-fno-toplevel-reorder}オプションと同様の効果を持つが、マークされたシンボルにのみ適用される。

@item no_sanitize ("@var{sanitize_option}")
@cindex @code{no_sanitize} function attribute
The @code{no_sanitize} attribute on functions is used
to inform the compiler that it should not do sanitization of all options
mentioned in @var{sanitize_option}.  A list of values acceptable by
@option{-fsanitize} option can be provided.

@smallexample
void __attribute__ ((no_sanitize ("alignment", "object-size")))
f () @{ /* @r{Do something.} */; @}
@end smallexample

@item no_sanitize_address
@itemx no_address_safety_analysis
@cindex @code{no_sanitize_address} function attribute
関数の@code {no_sanitize_address}属性は、@option{-fsanitize=address}オプションを指定してコンパイルするときに関数内でメモリアクセスを計測しないようにコンパイラに通知するために使用される。@code{no_address_safety_analysis}は非推奨の@code{no_sanitize_address}属性のエイリアスである。新しいコードでは@code{no_sanitize_address}を使用するべきである。

@item no_sanitize_thread
@cindex @code{no_sanitize_thread} function attribute
関数の@code{no_sanitize_thread}属性は、コンパイラに@option{-fsanitize = thread}オプションを指定してコンパイルするときに関数内でメモリアクセスを計測すべきでないことをコンパイラに通知するために使用される。

@item no_sanitize_undefined
@cindex @code{no_sanitize_undefined} function attribute
関数の@code{no_sanitize_undefined}属性は、コンパイラが@option{-fsanitize=undefined}オプションを使用してコンパイルするときに、関数内の未定義の動作をチェックしないことをコンパイラに通知するために使用される。

@item no_split_stack
@cindex @code{no_split_stack} function attribute
@opindex fsplit-stack
@option{-fsplit-stack}を指定した場合、関数はスタックを分割するかどうかを決定する小さなプロローグを持つ。 @code{no_split_stack}属性を持つ関数は、そのプロローグを持たないため、使用可能なスタックスペースがわずかしかなくても実行できる。

@item no_stack_limit
@cindex @code{no_stack_limit} function attribute
この属性は、@option{-fstack-limit-register}および@option{-fstack-limit-symbol}のコマンドラインオプションを局所的に上書きする。 それに適用される関数でスタック制限チェックを無効にするという効果がある。

@item noclone
@cindex @code{noclone} function attribute
この関数属性は、関数の特殊なコピーを生成し、手続き間の定数伝搬によって（現在）実行されている機構である、クローニングのために関数が考慮されないようにする。

@item noinline
@cindex @code{noinline} function attribute
この関数属性は、関数がインライン展開のために考慮されないようにする。
@c Don't enumerate the optimizations by name here; we try to be
@c future-compatible with this mechanism.
関数が副作用を持たない場合は、インライン化以外の最適化があり、関数呼び出しがライブであるにもかかわらず、最適化された関数呼び出しを引き起こす。 そのような呼び出しが最適化されないようにするには、以下を置く。
@smallexample
asm ("");
@end smallexample

@noindent
(@pxref{Extended Asm})は特別な副作用として機能するために、呼び出された関数内で使用される。

@item noipa
@cindex @code{noipa} function attribute
あたかも呼び出し側を最適化するときに関数の本体が利用できないかのように、この属性とその呼び出し元との間で手続き間の最適化を無効にし、本体を最適化するときに呼び出し元を使用できなくする。 この属性は、@code{noinline}、@code{noclone}属性と@code{no_icf}属性を意味する。 ただし、この属性は、プロシージャ間分析を使用した既存および将来の最適化を抑制することを目的としているため、他の属性の組み合わせと同等ではない。 この属性は、主にコンパイラをテストする目的でサポートされている。

@item nonnull (@var{arg-index}, @dots{})
@cindex @code{nonnull} function attribute
@cindex functions with non-null pointer arguments
@code{nonnull}属性は、いくつかの関数のパラメータがnull以外のポインタであることを指定する。 例えば、宣言は：

@smallexample
extern void *
my_memcpy (void *dest, const void *src, size_t len)
        __attribute__((nonnull (1, 2)));
@end smallexample

@noindent
は、コンパイラが@code{my_memcpy}への呼び出しで引数@var{dest}と@var{src}がnullでないことをチェックさせる。 コンパイラーが、ヌルポインターが非ヌルとしてマークされた引数スロットに渡され、@option{-Wnonnull}オプションが有効であると判断すると、警告が発行される。 コンパイラは、特定の関数の引数が決してnullにならないという知識に基づいて最適化を行うこともできる。

引数インデックスリストが@code{nonnull}属性に与えられない場合、すべてのポインタ引数はnull以外としてマークされる。 例として、次の宣言は前の例と同じである。

@smallexample
extern void *
my_memcpy (void *dest, const void *src, size_t len)
        __attribute__((nonnull));
@end smallexample

@item noplt
@cindex @code{noplt} function attribute
@code{noplt}属性は、オプション@option{-fno-plt}に対応している。位置に依存しないコードでこの属性でマークされた関数を呼び出すと、PLTは使用されない。

@smallexample
@group
/* Externally defined function foo.  */
int foo () __attribute__ ((noplt));

int
main (/* @r{@dots{}} */)
@{
  /* @r{@dots{}} */
  foo ();
  /* @r{@dots{}} */
@}
@end group
@end smallexample

関数@code{foo}の@code{noplt}属性は、コンパイラに関数@code{foo}が外部的に定義されていると仮定し、@code{foo}への呼び出しは位置に依存しないコードでPLTを避けなければならないと伝える。

位置依存コードでは、いくつかのターゲットは、GOTを代わりに使用するためにPLTを使用しないようにマークされた関数に呼び出しを変換する。

@item noreturn
@cindex @code{noreturn} function attribute
@cindex functions that never return
@code{abort}や@code {exit}のようないくつかの標準ライブラリ関数は返らない。 GCCはこれを自動的に認識する。 一部のプログラムは、決して戻ってこない独自の関数を定義している。 コンパイラにこの事実を伝えるために@code{noreturn}を宣言することができる。 例えば、

@smallexample
@group
void fatal () __attribute__ ((noreturn));

void
fatal (/* @r{@dots{}} */)
@{
  /* @r{@dots{}} */ /* @r{Print error message.} */ /* @r{@dots{}} */
  exit (1);
@}
@end group
@end smallexample

@code{noreturn}キーワードは、@code{fatal}が返ることができないとコンパイラに指示する。 @code{fatal}が復帰した場合に起こることに関係なく最適化することができる。 これは少し良いコードを作成する。 さらに重要なことは、初期化されていない変数の偽の警告を避けることである。

@code{noreturn}キーワードは、それが適用される例外的なパスには影響しない：@code{noreturn}マークされた関数は、例外を投げたり@code{longjmp}を呼び出すことによっても呼び出し元に戻ることができる。

@code{noreturn}関数を呼び出す前に、呼び出し関数によって保存されたレジスタが復元されたと仮定しないこと。

@code{noreturn}関数が@code {void}以外の戻り値の型を持つことは意味がない。

@item nothrow
@cindex @code{nothrow} function attribute
@code{nothrow}属性は、関数が例外をスローできないことをコンパイラに通知するために使用される。 例えば、標準Cライブラリのほとんどの関数は、関数ポインタの引数を取る@code{qsort}と@code{bsearch}を例外として、例外を投げないことを保証することができる。

@item optimize
@cindex @code{optimize} function attribute
@code{optimize}属性は、関数がコマンドラインで指定されたものとは異なる最適化オプションでコンパイルされることを指定するために使用される。 引数は数値または文字列のいずれかである。 数値は最適化レベルとみなされる。@code{O}で始まる文字列は最適化オプションとみなされ、他のオプションは@code {-f}の接頭辞とともに使用されるものとみなされる。 @samp{#pragma GCC optimize}プラグマを使用して、複数の関数に影響を与える最適化オプションを設定することもできる。@samp{#pragma GCC optimize}プラグマの詳細は@xref{Function Specific Option Pragmas}。

この属性は、デバッグ目的でのみ使用するべきである。 プロダクションコードには適していない。

@item patchable_function_entry
@cindex @code{patchable_function_entry} function attribute
@cindex extra NOP instructions at the function entry point
ターゲットのテキストセグメントを実行時に任意の手段で書き込み可能にすることができる場合、関数エントリに多数のNOPを埋め込むことで、計測のための普遍的なツールを提供することができる。

@code{patchable_function_entry}関数属性を使用して、NOPの数を任意の値に変更することができる。 2値構文は@option{-fpatchable-function-entry=N,M}のコマンドラインスイッチの場合と同じで、@var{N}のNOPが生成され、@var{M}番目のM命令の前に関数開始ポイントがある。@var{M}は省略された場合、デフォルトで0になる、例えば、関数開始ポイントは最初のNOPの前になる。

コマンドラインオプション@option{-fpatchable-function-entry=N,M}を使用してパッチ可能な関数エントリがグローバルに有効になっている場合、再帰を防止するために@code{patchable_function_entry(0)}を使用して計装フレームワークの一部であるすべての関数で計装を無効化しなければならない。

@item pure
@cindex @code{pure} function attribute
@cindex functions that have no side effects
多くの関数は戻り値以外の効果を持たず、戻り値はパラメータかつ/またはグローバル変数のみに依存する。このような関数への呼出は、算術演算子と同じように共通の部分式消去とループ最適化の対象となることができる。 これらの関数は@code{pure}属性で宣言する必要がある。 例えば、

@smallexample
int square (int) __attribute__ ((pure));
@end smallexample

@noindent
仮説的な関数@code {square}は、プログラムが言うよりも少ない回数だけ呼び出すのが安全だと言う。

純粋な関数の一般的な例としては、@code {strlen}や@code {memcmp}がある。興味深い非純粋な関数は、無限ループを持つ関数、または揮発性メモリや他のシステムリソースに依存する関数で、2回の連続した呼び出し（マルチスレッド環境の@code{feof}など）の間で変更される可能性がある。

The @code{pure} attribute imposes similar but looser restrictions on
a function's defintion than the @code{const} attribute: it allows the
function to read global variables.  Decorating the same function with
both the @code{pure} and the @code{const} attribute is diagnosed.
Because a @code{pure} function cannot have any side effects it does not
make sense for such a function to return @code{void}.  Declaring such
a function is diagnosed.

@item returns_nonnull
@cindex @code{returns_nonnull} function attribute
@code{returns_nonnull}属性は、関数の戻り値がNULLでないポインタでなければならないことを指定する。 例えば、宣言は：

@smallexample
extern void *
mymalloc (size_t len) __attribute__((returns_nonnull));
@end smallexample

@noindent
コンパイラは戻り値が決してnullにならないという知識に基づいて呼び出し元を最適化する。

@item returns_twice
@cindex @code{returns_twice} function attribute
@cindex functions that return more than once
@code{returns_twice}属性は、関数が複数回返す可能性があることをコンパイラに知らせる。 コンパイラは、そのような関数を呼び出す前にすべてのレジスタが停止していることを確認し、関数からの2回目の復帰後に矛盾する可能性のある変数についての警告を発する。 このような関数の例は@code{setjmp}と@code {vfork}である。そのような関数の@code{longjmp}のような対応物は、@code{noreturn}属性でマークする必要があるかもしれない。

@item section ("@var{section-name}")
@cindex @code{section} function attribute
@cindex functions in arbitrary sections
通常、コンパイラは生成するコードを@code{text}セクションに配置する。しかし、場合によっては追加セクションが必要な場合や、特別なセクションに表示する特定の機能が必要な場合もある。 @code{section}属性は、関数が特定のセクションに存在することを指定する。たとえば、次のような宣言があると、

@smallexample
extern void foobar (void) __attribute__ ((section ("bar")));
@end smallexample

@noindent
関数@code{foobar}を@code{bar}セクションに置く。

一部のファイル形式では任意のセクションはサポートされないため、@code{section}属性はすべてのプラットフォームで使用できるわけではない。 モジュールの内容全体を特定のセクションにマップする必要がある場合は、代わりにリンカーの機能を使用することを検討せよ。

@item sentinel
@cindex @code{sentinel} function attribute
この関数属性は、関数呼び出しのパラメータが明示的な@code{NULL}であることを保証する。 属性は可変長関数でのみ有効である。 デフォルトでは、センチネルは、関数呼び出しの最後のパラメータである位置0にある。 オプションの整数位置引数Pが属性に与えられた場合、センチネルは、引数リストの最後から逆方向に数えて位置Pになければならない。

@smallexample
__attribute__ ((sentinel))
は以下と等価である。
__attribute__ ((sentinel(0)))
@end smallexample

属性は組み込み関数@code{execl}と@code{execlp}の位置が0になるように自動的に設定される。 組み込み関数@code{execle}の属性の位置は1である。

この文脈で有効な@code{NULL}は、ポインタ型を持つゼロとして定義されている。 あなたのシステムが@code {NULL}マクロを整数型で定義している場合、明示的なキャストを追加する必要がある。 GCCは@code{stddef.h}を、NULLを適切に再定義するコピーに置き換える。

@option{-Wformat}を指定すると、不正義または間違っている警告の警告が有効になる。

@item simd
@itemx simd("@var{mask}")
@cindex @code{simd} function attribute
この属性を使用すると、1回の呼び出しでSIMD命令を使用して複数の引数を処理できる1つ以上の関数バージョンを作成できる。 この属性を指定すると、コンパイラは、そのようなバージョンがリンク時に利用可能であると想定することができる（同じ翻訳単位または別の翻訳単位で提供される）。 生成されたバージョンはターゲットに依存し、対応するVector ABIドキュメントに記述されている。 x86_64ターゲットの場合、この文書は@w{@uref{https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&do=view&target=VectorABI.txt,here}}で見つけることができる。

オプションの引数@var{mask}は、値@code{notinbranch}または@code{inbranch}を持つことができ、それに対応してマスクされていないクローンまたはマスクされたクローンを生成するようにコンパイラに指示する。 デフォルトでは、すべてのクローンが生成される。

属性が指定され、@code{#pragma omp declare simd}が宣言にあり、@option{-fopenmp}または@option{-fopenmp-simd}スイッチが指定されている場合、属性は無視される。

@item stack_protect
@cindex @code{stack_protect} function attribute
この属性は、フラグ@option{-fstack-protector}、@option{-fstack-protector-strong}または@option{-fstack-protector-explicit}が設定されている場合にスタック保護コードを関数に追加する。

@item target (@var{options})
@cindex @code{target} function attribute
複数のターゲットバックエンドは@code{target}属性を実装して、コマンドラインで指定されたものとは異なるターゲットオプションで関数をコンパイルすることを指定する。これは、例えば、デフォルトとは異なるISA（命令セットアーキテクチャ）でコンパイルされた関数を持つために使用できる。@samp{#pragma GCC target}プラグマを使用して、複数の関数を特定のターゲットオプションでコンパイルするように設定することもできる。@samp{#pragma GCC target}プラグマの詳細については、@xref{Function Specific Option Pragmas}を参照せよ。

たとえば、x86では、@code{target( "sse4.1,arch=core2")}属性を持つ関数と@code{target( "sse4a,arch=amdfam10")}関数を宣言できる。 これは、@option{-msse4.1}と@option{-march = core2}オプションで最初の関数をコンパイルし、@option{-msse4a}と@option{-march = amdfam10}オプションで2番目の関数をコンパイルするのと同じである。 関数がコンパイルされた特定のISAをサポートしているマシンでのみ呼び出されるようにすることは、あなたが任されている（たとえば、x86上で@code {cpuid}を使ってどの機能ビットとアーキテクチャファミリが使用されているかを判断する）。

@smallexample
int core2_func (void) __attribute__ ((__target__ ("arch=core2")));
int sse3_func (void) __attribute__ ((__target__ ("sse3")));
@end smallexample

コンマで区切られた複数の文字列を使用して、複数のオプションを指定するか、単一の文字列内でコンマ（@samp {,}）でオプションを区切ることができる。

サポートされるオプションは、各ターゲットに固有です。詳細は@ref{x86 Function Attributes}、@ref{PowerPC Function Attributes}、 @ref{ARM Function Attributes}、 @ref{AArch64 Function Attributes}、 @ref{Nios II Function Attributes}、@ref{S/390 Function Attributes}を参照。

@item target_clones (@var{options})
@cindex @code{target_clones} function attribute
@code{target_clones}属性は、関数がコマンドラインで指定されたものとは異なるターゲットオプションでコンパイルされた複数のバージョンに複製されることを指定するために使用される。 サポートされるオプションと制限は、@code{target}属性と同じである。

たとえば、x86では、@code{target_clones("sse4.1,avx")}で関数をコンパイルできる。 GCCは、@option{-msse4.1}と@option{-mavx}でコンパイルされた2つのファンクションクローンを作成する。PowerPCでは、@code{target_clones("cpu=power9,default")}で関数をコンパイルできる。
GCCは、@option{-mcpu=power9}でコンパイルされたファンクションクローンとデフォルトオプションを持つファンクションクローンの2つを作成する。@code{target_clones}属性を使用するには、GLIBC 2.23以降を使用するようにGCCを設定する必要がある。

また、現在のアーキテクチャに適したクローンを動的に選択するリゾルバ関数（上記の@code{ifunc}属性を参照）を作成する。 @code{target_clones}属性を持つ関数の使用がある場合のみ、リゾルバが作成される。

@item unused
@cindex @code{unused} function attribute
関数に付随するこの属性は、関数が未使用である可能性があることを意味します。 GCCはこの関数に対して警告を出さない。

@item used
@cindex @code{used} function attribute
関数に付随するこの属性は、その関数が参照されていないように見えても、関数に対してコードを発行する必要があることを意味する。 これは、関数がインラインアセンブリでのみ参照される場合などに便利である。

C++クラステンプレートのメンバ関数に適用すると、クラス自体がインスタンス化されている場合、その関数がインスタンス化されることも意味する。

@item visibility ("@var{visibility_type}")
@cindex @code{visibility} function attribute
この属性は、それがアタッチされている宣言のリンケージに影響する。関数だけでなく、変数（@pxref{Common Variable Attributes}）や型（@pxref{Common Type Attributes}）にも適用できる。

サポートされる4つの@var{visibility_type}値があります：default, hidden, protected, internal可視性。

@smallexample
void __attribute__ ((visibility ("protected")))
f () @{ /* @r{Do something.} */; @}
int i __attribute__ ((visibility ("hidden")));
@end smallexample

@var{visibility_type}の値は、ELF gABIの可視性設定に対応している。

@table @code
@c keep this list of visibilities in alphabetical order.

@item default
default(デフォルト)の可視性は、オブジェクトファイル形式の通常の場合である。この値は、visibility属性で使用可能で、エンティティの想定される可視性を変更する可能性のある他のオプションをオーバーライドする。

ELFでは、default可視性は、宣言が他のモジュールに見えることを意味し、共有ライブラリでは、宣言されたエンティティがオーバーライドされる可能性があることを意味する。

Darwinでは、default可視性は、その宣言が他のモジュールから見えることを意味する。

default可視性は、言語の「外部リンケージ」に対応する。

@item hidden
hidden(非表示)の可視性は、宣言されたエンティティが新しい形式のリンケージを持っていることを示している。これを「隠れリンケージ」と呼ぶ。 隠れたリンケージを持つオブジェクトの2つの宣言は、同じ共有オブジェクトにある場合、同じオブジェクトを参照する。

@item internal
internal(内部)可視性はhidden可視性と似ているが、追加のプロセッサ固有の意味がある。 psABIで別途指定されていない限り、GCCはinternal可視性を、関数が@emph{決して}他のモジュールから呼び出されることはないと定義する。 これを他のモジュールが直接参照することはできないが、関数ポインタを介して間接的に参照できる隠し関数と比較する。 関数がモジュールの外部から呼び出せないことを示すことによって、GCCは、呼び出し元関数が正しい値をロードしたことが分かっているため、例えばPICレジスタのロードを省略することができる。

@item protected
protected(保護された)可視性は、定義モジュール内の参照がそのモジュールの定義にバインドされていることを示している点を除き、default可視性と似ている。 つまり、宣言されたエンティティを別のモジュールで上書きすることはできない。

@end table
すべての可視性は、ELFターゲットの多くで（しかしすべてではなく）サポートされている（アセンブラが@samp{.visibility}疑似オペレーションをサポートするときにサポートされる）。default可視性はどこでもサポートされている。 hidden可視性はDarwinターゲットでサポートされている。

visibility属性は、それ以外の場合は外部リンクを持つ宣言にのみ適用する必要がある。 属性は一貫して適用する必要がある。そのため、同じエンティティを属性の異なる設定で宣言することはできない。

C++では、visibility属性は型や関数、オブジェクトに適用される。なぜならC++型ではリンケージがあるからである。 クラスは非静的なデータメンバの型や基底よりも大きな可視性を持ってはならず、クラスメンバはそのクラスの可視性をdefaultにする。 また、明示的な可視性のない宣言は、その型の可視性に限定される。

C++では、クラスのメンバ関数と静的メンバ変数をvisibility属性でマークすることができる。 これは、特定のメソッドまたは静的メンバー変数が1つの共有オブジェクトからのみ使用されることがわかっている場合に便利である。 クラスの残りの部分がdefault可視性を持っている一方、それをhiddenにすることができる。 1つの定義ルールを破らないように注意する必要がある。 例えば、クラス全体をhiddenにすることなく、インラインメソッドをhiddenとしてマークすることは、通常、有用ではない。

C++の名前空間宣言にも、visibility属性を含めることができる。

@smallexample
namespace nspace1 __attribute__ ((visibility ("protected")))
@{ /* @r{Do something.} */; @}
@end smallexample

この属性は特定の名前空間本体にのみ適用され、同じ名前空間の他の定義には適用されない。 @samp{#pragma GCC visibility}を名前空間の定義の前後に使用すること（@pxref{Visibility Pragmas}）と同じである。

C++では、テンプレート引数の可視性が制限されている場合、この制限はテンプレートのインスタンス化に暗黙的に伝播される。それ以外の場合は、テンプレートの実体化と特殊化は、デフォルトでテンプレートの可視性になる。

テンプレートクラスと囲みクラスの両方に明示的な可視性がある場合、テンプレートからの可視性が使用される。

@item warn_unused_result
@cindex @code{warn_unused_result} function attribute
この属性を持つ関数の呼び出し側が戻り値を使用しない場合、@code{warn_unused_result}属性は警告を発行する。 これは、@code{realloc}のように、結果をチェックしないとセキュリティ上の問題であるか、常にバグである関数に役立つ。

@smallexample
int fn () __attribute__ ((warn_unused_result));
int foo ()
@{
  if (fn () < 0) return -1;
  fn ();
  return 0;
@}
@end smallexample

@noindent
5行目に警告が表示される。

@item weak
@cindex @code{weak} function attribute
@code{weak}属性は、宣言がグローバルではなく弱いシンボルとして出力されるようにする。 これは主に、ユーザーコードでオーバーライドできるライブラリ関数を定義するのに便利であるが、関数以外の宣言でも使用できる。 弱いシンボルは、ELFターゲット、およびGNUアセンブラとリンカを使用するときのa.outターゲットでサポートされている。

@item weakref
@itemx weakref ("@var{target}")
@cindex @code{weakref} function attribute
@code{weakref}属性は、宣言を弱い参照としてマークする。引数がなければ、それは@code{alias}属性にターゲットシンボルの名前を付ける必要がある。 オプションで、@code{weakref}自体の引数として@var{target}を与えることができる。 どちらの場合でも、@code{weakref}は宣言を暗黙的に@code{weak}とマークする。 @code{weakref}や@code{alias}の引数として与えられた@var{target}がなければ、@code{weakref}は@code {weak}と同等である。

@smallexample
static int x() __attribute__ ((weakref ("y")));
/* is equivalent to... */
static int x() __attribute__ ((weak, weakref, alias ("y")));
/* and to... */
static int x() __attribute__ ((weakref));
static int x() __attribute__ ((alias ("y")));
@end smallexample

弱参照は、それ自身ではターゲットシンボルに対して定義を与える必要がないエイリアスである。 ターゲットシンボルが弱参照によってのみ参照される場合、それは@code{weak}未定義シンボルになる。 ただし、直接参照されている場合は、そのような強力な参照が優先され、シンボルには定義が必要である。必ずしも同じ翻訳単位である必要はない。

この効果は、エイリアスへのすべての参照を別の翻訳単位に移動し、エイリアスをエイリアスシンボルの名前に変更し、弱いと宣言し、2つの別々の翻訳単位をコンパイルし、再読み込み可能なリンクを実行することと同じである。

現在のところ、@code{weakref}が付加されている宣言は@code{static}にしかできない。


@end table

@c This is the end of the target-independent attribute table

@node AArch64 Function Attributes
@subsection AArch64関数属性

AArch64ターゲットでは、次のターゲット固有の関数属性を使用できる。 ほとんどの場合、これらのオプションは、同様のコマンドラインオプション（@pxref{AArch64 Options}）の動作をミラーリングするが、関数ごとに反映される。

@table @code
@item general-regs-only
@cindex @code{general-regs-only} function attribute, AArch64
この関数のコードを生成するときに、浮動小数点またはアドバンストSIMDレジスタを使用しないことを示す。 関数が明示的に浮動小数点コードを使用する場合、コンパイラはエラーを返す。 これは、コマンド行オプション@option{-mgeneral-regs-only}と同じ動作である。

@item fix-cortex-a53-835769
@cindex @code{fix-cortex-a53-835769} function attribute, AArch64
この関数にCortex-A53 erratum 835769の回避策を適用する必要があることを示す。 この関数の回避策を明示的に無効にするには、無効な形式を指定する：@code{no-fix-cortex-a53-835769}。 これは、コマンド行オプション@option{-mfix-cortex-a53-835769}と@option{-mno-fix-cortex-a53-835769}の動作に対応する。

@item cmodel=
@cindex @code{cmodel=} function attribute, AArch64
この関数の特定のコードモデルに対してコードを生成する必要があることを示す。 動作と許容される引数は、コマンドラインオプション@option{-mcmodel=}と同じである。

@item strict-align
@cindex @code{strict-align} function attribute, AArch64
コンパイラーは、境界整列されていないメモリー参照がシステムによって処理されると想定してはならないことを示す。 動作は、コマンドラインオプション@option{-mstrict-align}と同じである。

@item omit-leaf-frame-pointer
@cindex @code{omit-leaf-frame-pointer} function attribute, AArch64
リーフ関数呼び出しのためにフレームポインタを省略するべきであることを示す。フレームポインタを保持するために、逆属性@code{no-omit-leaf-frame-pointer}を指定することができる。 これらの属性は、コマンド行オプション@option{-momit-leaf-frame-pointer}および@option{-mno-omit-leaf-frame-pointer}と同じ動作をする。

@item tls-dialect=
@cindex @code{tls-dialect=} function attribute, AArch64
この関数に使用するTLS方言を指定する。 動作と許容される引数は、コマンドラインオプション@option{-mtls-dialect=}と同じである。

@item arch=
@cindex @code{arch=} function attribute, AArch64
この機能に使用するアーキテクチャーのバージョンとアーキテクチャー拡張を指定する。 動作と許容される引数は、@option{-march=}コマンドラインオプションと同じである。

@item tune=
@cindex @code{tune=} function attribute, AArch64
この機能のパフォーマンスをチューニングするコアを指定する。動作と許容可能な引数は、@option{-mtune=}コマンドラインオプションと同じである。

@item cpu=
@cindex @code{cpu=} function attribute, AArch64
この機能のパフォーマンスをチューニングするコアと、使用するアーキテクチャ上の機能を指定する。 動作と有効な引数は、@option{-mcpu=}コマンドラインオプションと同じである。

@item sign-return-address
@cindex @code{sign-return-address} function attribute, AArch64
戻りアドレスの署名が適用される関数スコープを選択する。 動作と許容される引数は、コマンドラインオプションの@option{-msign-return-address=}と同じである。 デフォルト値は@code{none}である。

@end table

上記のターゲット属性は、次のように指定できる。

@smallexample
__attribute__((target("@var{attr-string}")))
int
f (int a)
@{
  return a + 5;
@}
@end smallexample

ここで@code{@var{attr-string}}は、上記で指定した属性文字列の1つである。

さらに、アーキテクチャ拡張文字列は単独で指定することもできる。 これは、特定のアーキテクチャーのバージョンまたはコアを指定することなく、特定のアーキテクチャー拡張をオンまたはオフにするために使用できる。 例：

@smallexample
__attribute__((target("+crc+nocrypto")))
int
foo (int a)
@{
  return a + 5;
@}
@end smallexample

この例では、@code{target("+crc+nocrypto")}は@code{crc}拡張を有効にし、既存の@option{-march=}または@option{-mcpu}オプションを変更せずに@code{foo}関数の@code{crypto}拡張を無効にする。

カンマで区切って複数のターゲット関数属性を指定することができる。 例えば：
@smallexample
__attribute__((target("arch=armv8-a+crc+crypto,tune=cortex-a53")))
int
foo (int a)
@{
  return a + 5;
@}
@end smallexample

は有効で、ARMv8-Aの関数@code{foo}を@code{crc}と@code{crypto}拡張でコンパイルし、@code{cortex-a53}のために調整する。

@subsubsection インライン規則
異なるターゲットオプションを使用してコンパイルされた翻訳ユニット間で、個々の関数のターゲット属性を指定したり、リンク時の最適化を実行すると、関数のインライン化ルールに影響がでる。

特に、呼び出し元関数は、呼び出し先が利用可能なアーキテクチャ上の機能が呼び出し元が使用できる機能のサブセットである場合にのみ、呼び出し先関数をインライン化できる。例：@option{-march=armv8-a+crc}でコンパイルされた、または同等の@code {arch = armv8-a + crc}属性でタグ付けされた関数@code{foo}は、関数をインラインで@code{@code{bar}}は@option{-march=armv8-a+nocrc}でコンパイルされている。なぜなら、@code {bar}が必要とするすべてのアーキテクチャ機能が@code{foo}を機能させるためである。 逆に関数@code {bar}は関数@code{foo}をインライン化できない。

さらに@option{-mstrict-align}でコンパイルされた関数を@code{-mstrict-align}なしでコンパイルされた関数にインライン展開することはできない。ただし、@option{-mstrict-align}を指定せずにコンパイルされた関数を、@option{-mstrict-align}でコンパイルされた関数にインライン展開することはできる。

@option{-mcpu=}、@option{-mtune=}のようなCPUチューニングオプションと属性は、@option{-mcpu=}オプションまたは@code{cpu=}属性は、上記で指定したアーキテクチャ機能ルールと競合する。

@node ARC Function Attributes
@subsection ARC関数属性

これらの関数属性は、ARCバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, ARC
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

ARCでは、次のように割り込み属性のパラメータで処理される割り込みの種類を指定する必要がある。

@smallexample
void f () __attribute__ ((interrupt ("ilink1")));
@end smallexample

このパラメータの許容値は次のとおりである： @w{@code{ilink1}}と@w{@code{ilink2}}.

@item long_call
@itemx medium_call
@itemx short_call
@cindex @code{long_call} function attribute, ARC
@cindex @code{medium_call} function attribute, ARC
@cindex @code{short_call} function attribute, ARC
@cindex indirect calls, ARC
これらの属性は、特定の関数の呼び出し方法を指定する。これらの属性は、@option{-mlong-calls}と@option{-mmedium-calls}（@pxref{ARC Options}）コマンドラインスイッチと@code{#pragma long_calls}設定よりも優先される。

ARCでは、@code{long_call}属性でマークされた関数は常にレジスタ間接jump-and-link命令を使用して呼び出され、呼び出された関数を32ビットアドレス空間のどこにでも配置できるようにする。 @code{medium_call}属性でマークされた関数は、コールサイトから25ビットのオフセットを持つ無条件の分岐およびリンク命令で呼び出すことができるくらい近くにある。 @code{short_call}属性でマークされた関数は、コールサイトから21ビットのオフセットを持つ条件付き分岐/リンク命令で呼び出すのに十分に近い状態になる。

@item jli_always
@cindex @code{jli_always} function attribute, ARC
@code {jli}命令を使用して特定の関数を呼び出すようにする。 @code{jli}命令は、@code{.jlitab}セクションに格納されたテーブルを利用する。このセクションは、この命令を使ってアドレス指定された関数の位置を保持する。

@item jli_fixed
@cindex @code{jli_fixed} function attribute, ARC
上記と同じだが、@ code {jli}テーブル内の関数の位置は既知であり、属性パラメータとして与えられている。

@item secure_call
@cindex @code{secure_call} function attribute, ARC
この属性により、通常モードから呼び出し可能なセキュアコード関数をマークすることができる。 @code{sjli}テーブルへの安全な呼び出し関数の場所は、引数として渡す必要がある。

@end table

@node ARM Function Attributes
@subsection ARM関数属性

これらの関数属性は、ARMターゲットでサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, ARM
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

割り込み属性にオプションのパラメータを追加することで、処理する割り込みの種類を指定することができる。

@smallexample
void f () __attribute__ ((interrupt ("IRQ")));
@end smallexample

@noindent
このパラメータの許容値は次のとおりである。 @code{IRQ}、 @code{FIQ}、@code{SWI}、 @code{ABORT}、@code{UNDEF}.

ARMv7-Mでは、割り込みタイプは無視され、属性はワードアラインされたスタックポインタで呼び出されることを意味する。

@item isr
@cindex @code{isr} function attribute, ARM
割り込みサービスルーチンを書き込むには、ARMでこの属性を使用する。 上記の@code{interrupt}属性の別名である。

@item long_call
@itemx short_call
@cindex @code{long_call} function attribute, ARM
@cindex @code{short_call} function attribute, ARM
@cindex indirect calls, ARM
これらの属性は、特定の関数の呼び出し方法を指定する。これらの属性は、@option{-mlong-calls}（@pxref{ARM Options}）コマンドラインスイッチと@code{#pragma long_calls}設定を上書きする。ARMの場合、@code{long_call}属性は、関数がコールサイトから離れていて、別の（より高価な）呼び出しシーケンスを必要とする可能性があることを示す。 @code{short_call}属性は常に、コールサイトからの関数にオフセットを@samp{BL}命令に直接置く。

@item naked
@cindex @code{naked} function attribute, ARM
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。 基本的な@code{asm}文（@pxref{Basic Asm}）だけが安全にnaked関数に含まれることができる。 拡張@code{asm}または基本的な@code{asm}とCコードの混在を使用すると動作するように見えるかもしれないが、信頼できる動作に依存することはできず、サポートされていない。

@item pcs
@cindex @code{pcs} function attribute, ARM
@code{pcs}属性は、ARM上の関数に使用される呼び出し規約を制御するために使用できる。 この属性は、使用する呼び出し規約を指定する引数をとる。

AAPCS ABI（またはその変形版）を使用してコンパイルする場合、引数の有効な値は@code{"aapcs"}と@code{"aapcs-vfp"}である。@code{"aapcs"}以外のバリアントを使用するには、コンパイラは適切なコプロセッサレジスタを使用する必要がある（つまり、 @code{"aapcs-vfp"}を使用するにはVFPレジスタを使用できる必要がある）。例えば、

@smallexample
/* Argument passed in r0, and result returned in r0+r1.  */
double f2d (float) __attribute__((pcs("aapcs")));
@end smallexample

Variadic関数は常に@code{"aapcs"}呼び出し規約を使用し、コンパイラは代替を指定しようとする試みを拒否する。

@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

ARMでは、次のオプションを使用できる。

@table @samp
@item thumb
@cindex @code{target("thumb")} function attribute, ARM
アーキテクチャレベルに応じて、Thumb（T16/T32）ISAにコードを強制的に生成する。

@item arm
@cindex @code{target("arm")} function attribute, ARM
ARM（A32）ISAのコード生成を強制する。

異なるモードの関数は、呼び出し元のモードでインライン化できます。

@item fpu=
@cindex @code{target("fpu=")} function attribute, ARM
この関数のパフォーマンスを調整するためのfpuを指定する。動作と許容可能な引数は、@option{-mfpu=}コマンドラインオプションと同じである。

@end table

@item arch=
@cindex @code{arch=} function attribute, ARM
Specifies the architecture version and architectural extensions to use
for this function.  The behavior and permissible arguments are the same as
for the @option{-march=} command-line option.

The above target attributes can be specified as follows:

@smallexample
__attribute__((target("arch=armv8-a+crc")))
int
f (int a)
@{
  return a + 5;
@}
@end smallexample

Additionally, the architectural extension string may be specified on its
own.  This can be used to turn on and off particular architectural extensions
without having to specify a particular architecture version or core.  Example:

@smallexample
__attribute__((target("+crc+nocrypto")))
int
foo (int a)
@{
  return a + 5;
@}
@end smallexample

In this example @code{target("+crc+nocrypto")} enables the @code{crc}
extension and disables the @code{crypto} extension for the function @code{foo}
without modifying an existing @option{-march=} or @option{-mcpu} option.

@end table

@node AVR Function Attributes
@subsection AVR関数属性

これらの関数属性は、AVRバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, AVR
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

AVRでは、ハードウェアは割り込みが実行されると割り込みをグローバルに無効化する。 この属性で宣言された割り込みハンドラの最初の命令は、割り込みを再び有効にするための@code{SEI}命令である。 @code{SEI}命令を挿入しない@code{signal}関数属性も参照せよ。 同じ関数に対して@code{signal}と@code{interrupt}の両方が指定されている場合、@code{signal}は暗黙のうちに無視される。

@item naked
@cindex @code{naked} function attribute, AVR
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本的な@code{asm}文（@pxref{Basic Asm}）だけが安全にnaked関数に含まれることができる。 拡張@code{asm}または基本的な@code{asm}とCコードの混在を使用すると動作するように見えるかもしれないが、信頼できる動作に依存することはできず、サポートされていない。

@item no_gccisr
@cindex @code{no_gccisr} function attribute, AVR
Do not use @code{__gcc_isr} pseudo instructions in a function with
the @code{interrupt} or @code{signal} attribute aka. interrupt
service routine (ISR).
Use this attribute if the preamble of the ISR prologue should always read
@example
push  __zero_reg__
push  __tmp_reg__
in    __tmp_reg__, __SREG__
push  __tmp_reg__
clr   __zero_reg__
@end example
and accordingly for the postamble of the epilogue --- no matter whether
the mentioned registers are actually used in the ISR or not.
Situations where you might want to use this attribute include:
@itemize @bullet
@item
Code that (effectively) clobbers bits of @code{SREG} other than the
@code{I}-flag by writing to the memory location of @code{SREG}.
@item
Code that uses inline assembler to jump to a different function which
expects (parts of) the prologue code as outlined above to be present.
@end itemize
To disable @code{__gcc_isr} generation for the whole compilation unit,
there is option @option{-mno-gas-isr-prologues}, @pxref{AVR Options}.

@item OS_main
@itemx OS_task
@cindex @code{OS_main} function attribute, AVR
@cindex @code{OS_task} function attribute, AVR
AVRでは、@code{OS_main}属性または@code{OS_task}属性を持つ関数は、プロローグ/エピローグに呼び出し保存レジスタを保存/復元しない。

関数が入力された時点で割り込みが無効になっていることが@emph{保証されている}場合は、@code{OS_main}属性を使用できる。 これにより、ローカル変数のフレームを設定するためにスタックポインタを変更する必要がある場合に、リソースが節約される。

@code{OS_task}属性は、その関数が例えばマルチスレッド・オペレーティング・システムのタスク関数のように入力されたときに割り込みが無効になっているという保証がない場合に使用できる。その場合、スタックポインタレジスタの変更は、グローバル割込み許可フラグのセーブ/クリア/リストアによって保護される。

@code{naked}関数の属性との違いは次のとおりである。
@itemize @bullet
@item @code{naked}関数は戻り命令を持たないが、@code{OS_main}関数と@code{OS_task}関数は@code{RET}または@code{RETI}戻り命令を持っている。
@item @code{naked}関数はローカル変数やフレームポインタのフレームを設定しまないが、@code{OS_main}と@code{OS_task}はこれを必要に応じて行う。
@end itemize

@item signal
@cindex @code{signal} function attribute, AVR
AVRでこの属性を使用して、指定された機能が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@code{interrupt}関数属性も参照せよ。

AVRハードウェアは、割り込みが実行されたときに割り込みをグローバルに無効化する。@code{signal}属性で定義された割り込みハンドラ関数は、割り込みを再び有効にしない。 これは、@code{signal}ハンドラで割り込みを有効にするために保存される。 この「保存」は、コンパイラによって生成されたコードにのみ適用され、アプリケーションの責任であるアプリケーションのIRQレイアウトには適用されない。

同じ関数に対して@code{signal}と@code{interrupt}の両方が指定されている場合、@code{signal}は暗黙のうちに無視される。
@end table

@node Blackfin Function Attributes
@subsection Blackfin関数属性

これらの関数属性は、Blackfinバックエンドによってサポートされている。

@table @code

@item exception_handler
@cindex @code{exception_handler} function attribute
@cindex exception handler functions, Blackfin
Blackfinでこの属性を使用すると、指定された関数が例外ハンドラであることを示す。 コンパイラは、この属性が存在する場合、例外ハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item interrupt_handler
@cindex @code{interrupt_handler} function attribute, Blackfin
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@item kspisusp
@cindex @code{kspisusp} function attribute, Blackfin
@cindex User stack pointer in interrupts on the Blackfin
@code{interrupt_handler}、@code{exception_handler}または@code{nmi_handler}とともに使用すると、関数プロローグのUSPレジスタからスタックポインタをロードするコードが生成される。

@item l1_text
@cindex @code{l1_text} function attribute, Blackfin
この属性は、L1命令SRAMに配置される関数を指定する。関数は@code {.l1.text}という特定のセクションに置かれる。@option{-mfdpic}では、呼び出し先や呼び出し元がインラインPLTを使用するような関数呼び出しを伴う関数呼び出しである。

@item l2
@cindex @code{l2} function attribute, Blackfin
この属性は、L2 SRAMに配置される関数を指定する。 この関数は@code{.l2.text}という名前の特定のセクションに置かれる。 @option{-mfdpic}では、このような関数の呼び出し側はインラインPLTを使用する。

@item longcall
@itemx shortcall
@cindex indirect calls, Blackfin
@cindex @code{longcall} function attribute, Blackfin
@cindex @code{shortcall} function attribute, Blackfin
@code{longcall}属性は、関数がコールサイトから離れていて、別の（より高価な）呼び出しシーケンスを必要とする可能性があることを示す。 @code{shortcall}属性は、短い呼び出しシーケンスを使用するために関数が常に十分に近いことを示す。これらの属性は、@option{-mlongcall}スイッチよりも優先される。

@item nesting
@cindex @code{nesting} function attribute, Blackfin
@cindex Allow nesting in an interrupt handler on the Blackfin processor
この属性を@code{interrupt_handler}、@code{exception_handler}または@code{nmi_handler}とともに使用して、関数エントリコードがネストされた割り込みまたは例外を有効にする必要があることを示す。

@item nmi_handler
@cindex @code{nmi_handler} function attribute, Blackfin
@cindex NMI handler functions on the Blackfin processor
指定された機能がNMIハンドラであることを示すには、この属性をBlackfinで使用する。 コンパイラは、この属性が存在する場合、NMIハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item saveall
@cindex @code{saveall} function attribute, Blackfin
@cindex save all registers on the Blackfin
スタックポインタを使用するかどうかにかかわらず、スタックポインタを除くすべてのレジスタをプロローグに保存する必要があることを示すには、この属性を使用する。
@end table

@node CR16 Function Attributes
@subsection CR16関数属性

これらの関数属性は、CR16のバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, CR16
この属性を使用して、指定された関数が割り込みハンドラであることを示す。コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。
@end table

@node Epiphany Function Attributes
@subsection Epiphany関数属性

これらの関数属性はEpiphanyバックエンドによってサポートされている：

@table @code
@item disinterrupt
@cindex @code{disinterrupt} function attribute, Epiphany
この属性により、コンパイラは指定された関数の実行中に割り込みを無効にする命令を発行する。

@item forwarder_section
@cindex @code{forwarder_section} function attribute, Epiphany
この属性は、割り込みハンドラの動作を変更する。割り込みハンドラは、分岐命令では到達できない外部メモリにある可能性があるため、制御を転送するためにローカルメモリのトランポリンを生成する。 単一のパラメータは、トランポリンが配置されているセクションを識別する。

@item interrupt
@cindex @code{interrupt} function attribute, Epiphany
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。 また、割り込みベクタテーブルを初期化するためのコードを含む特別なセクションを生成することもある。

Epiphanyターゲットでは、次のように1つ以上のオプションパラメータを追加できる。

@smallexample
void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();
@end smallexample

これらのパラメータの可能な値は： @w{@code{reset}}、@w{@code{software_exception}}、 @w{@code{page_miss}}、@w{@code{timer0}}、 @w{@code{timer1}}、 @w{@code{message}}、@w{@code{dma0}}、 @w{@code{dma1}}、 @w{@code{wand}}、@w{@code{swi}}である。複数のパラメータは、割り込みベクタテーブル内の複数のエントリをこの関数に対して初期化する必要があることを示す。各パラメータ@w{@var{name}}に対して、関数へのジャンプはセクション@w{ivt_entry_@var{name}}に生成される。 パラメータは完全に省略されてもよく、この場合、割り込みベクタテーブルエントリは提供されない。

@code{disinterrupt}属性も指定されていない限り、関数内で割り込みが有効になることに注意せよ。

次の例は、Epiphanyターゲットでこれらの属性をすべて有効に使用する例である。
@smallexample
void __attribute__ ((interrupt)) universal_handler ();
void __attribute__ ((interrupt ("dma1"))) dma1_handler ();
void __attribute__ ((interrupt ("dma0, dma1"))) 
  universal_dma_handler ();
void __attribute__ ((interrupt ("timer0"), disinterrupt))
  fast_timer_handler ();
void __attribute__ ((interrupt ("dma0, dma1"), 
                     forwarder_section ("tramp")))
  external_dma_handler ();
@end smallexample

@item long_call
@itemx short_call
@cindex @code{long_call} function attribute, Epiphany
@cindex @code{short_call} function attribute, Epiphany
@cindex indirect calls, Epiphany
これらの属性は、特定の関数の呼び出し方法を指定する。これらの属性は、@option{-mlong-calls}（@pxref{Adapteva Epiphany Options}）コマンドラインスイッチと@code{#pragma long_calls}設定を上書きする。
@end table


@node H8/300 Function Attributes
@subsection H8/300関数属性

これらの関数属性は、H8 / 300ターゲットで使用できる。

@table @code
@item function_vector
@cindex @code{function_vector} function attribute, H8/300
H8 / 300、H8 / 300H、H8Sでは、この属性を使用して、指定した関数を関数ベクタで呼び出す必要があることを示す。関数ベクトルを介して関数を呼び出すと、コードサイズが小さくなる。 関数ベクトルのサイズは制限されていて（H8 / 300では最大128エントリ、H8 / 300HおよびH8Sでは64エントリ）、割り込みベクタと空間を共有する。

@item interrupt_handler
@cindex @code{interrupt_handler} function attribute, H8/300
H8/300、H8/300H、H8Sでこの属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@item saveall
@cindex @code{saveall} function attribute, H8/300
@cindex save all registers on the H8/300, H8/300H, and H8S
H8/300、H8/300H、H8Sではスタックポインタを除くすべてのレジスタを使用するかどうかにかかわらずプロローグに退避する必要があることを示すために使用する。
@end table

@node IA-64 Function Attributes
@subsection IA-64関数属性

これらの関数属性は、IA-64ターゲットでサポートされている。

@table @code
@item syscall_linkage
@cindex @code{syscall_linkage} function attribute, IA-64
この属性は、すべての入力レジスタをすべての関数終了でライブとしてマークすることによって、IA-64呼び出し規約を変更するために使用される。 これにより、入力レジスタを退避/復帰させることなく割り込み後にシステムコールを再開することができる。 これにより、カーネルデータがアプリケーションコードに漏洩することも防止される。

@item version_id
@cindex @code{version_id} function attribute, IA-64
グローバル変数または関数にアタッチされたこのIA-64 HP-UXアトリビュートは、シンボルの名前を変更してバージョン文字列を含むため、ファンクションレベルのバージョニングが可能である。 HP-UXシステムのヘッダーファイルは、一部のシステムコールで機能レベルのバージョニングを使用することがある。

@smallexample
extern int foo () __attribute__((version_id ("20040821")));
@end smallexample

@noindent
@code{foo}の呼び出しは@code{foo@{20040821@}}の呼び出しにマップされる。
@end table

@node M32C Function Attributes
@subsection M32C関数属性

これらの関数属性は、M32Cバックエンドによってサポートされている。

@table @code
@item bank_switch
@cindex @code{bank_switch} function attribute, M32C
M32Cポートで割り込みハンドラに追加すると、プロローグとエピローグでスタックに保存するのではなく、レジスタを保存するためにバンク切り替えを使用する。

@item fast_interrupt
@cindex @code{fast_interrupt} function attribute, M32C
指定された機能が高速割り込みハンドラであることを示すには、M32Cポートでこの属性を使用する。 これは、復帰するため@code{reit}の代わりに@code{freit}を使う点を除いて、@code{interrupt}属性と同じである。

@item function_vector
@cindex @code{function_vector} function attribute, M16C/M32C
M16C/M32Cターゲットでは、@code{function_vector}属性は特別なページサブルーチン呼び出し関数を宣言する。 この属性を使用すると、サブルーチンに生成される呼び出しごとにコードサイズが2バイト減少する。 属性への引数は、サブルーチンのエントリアドレスの下位16ビットを含む特殊ページベクタテーブルからのベクタ番号エントリである。 各ベクタテーブルには、@code{jsrs}命令で使用される特別なページ番号（18〜255）がある。 ルーチンのジャンプアドレスは、ベクタテーブルに設定されている2バイトアドレスに0x0F0000（M16Cターゲットの場合）または0xFF0000（M32Cターゲットの場合）を加算して生成する。 したがって、すべての特殊ページベクタルーチンがアドレス範囲0x0F0000〜0x0FFFFF（M16Cの場合）と0xFF0000〜0xFFFFFF（M32Cの場合）にマッピングされるようにする必要がある。

次の例では、関数@code{foo}の呼び出しごとに2バイトが節約される。

@smallexample
void foo (void) __attribute__((function_vector(0x18)));
void foo (void)
@{
@}

void bar (void)
@{
    foo();
@}
@end smallexample

関数が1つのファイルで定義され、別のファイルで呼び出されている場合は、この宣言を両方のファイルに必ず書き込むこと。

この属性はR8Cターゲットでは無視される。

@item interrupt
@cindex @code{interrupt} function attribute, M32C
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。
@end table

@node M32R/D Function Attributes
@subsection M32R/D関数属性

これらの関数属性は、M32R / Dバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, M32R/D
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに、割り込みハンドラで使用するのに適した関数入力および終了シーケンスを生成する。

@item model (@var{model-name})
@cindex @code{model} function attribute, M32R/D
@cindex function addressability on the M32R/D
M32R/Dでは、この属性を使用してオブジェクトのアドレス可能性を設定し、関数用に生成されたコードを設定する。 識別子@var{model-name}は、各コードモデルを表す@code{small}、@code{medium}、または@code{large}のいずれかである。

smallモデルオブジェクトは、メモリの下位16MBにあり（そのアドレスに@code{ld24}命令でロードできるように）、@code{bl}命令で呼び出し可能である。

mediumモデルオブジェクトは32ビットアドレス空間のどこにでも存在することができる（コンパイラはアドレスをロードするための@code{seth/add3}命令を生成する）。@code{bl}命令で呼び出し可能である。

kargeモデルオブジェクトは、32ビットアドレス空間のどこにでも置くことができ、（コンパイラはアドレスをロードするために@code{seth/add3}命令を生成する）@code {bl}命令では到達できないかもしれない（コンパイラはずっと遅い@code{seth/add3/jl}命令シーケンスを生成する）
@end table

@node m68k Function Attributes
@subsection m68k関数属性

これらの関数属性は、m68kバックエンドによってサポートされている。

@table @code
@item interrupt
@itemx interrupt_handler
@cindex @code{interrupt} function attribute, m68k
@cindex @code{interrupt_handler} function attribute, m68k
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。 いずれかの名前を使用できる。

@item interrupt_thread
@cindex @code{interrupt_thread} function attribute, fido
指定された関数がスレッドとして実行されるように設計された割り込みハンドラであることを示すために、この属性をm68kのサブアーキテクチャであるfidoに使用する。 コンパイラは、プロローグ/エピローグシーケンスの生成を省略し、リターン命令を@code{sleep}命令に置き換える。 この属性はfidoでのみ使用できる。
@end table

@node MCORE Function Attributes
@subsection MCORE関数属性

これらの関数属性は、MCOREバックエンドによってサポートされている。

@table @code
@item naked
@cindex @code{naked} function attribute, MCORE
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。 基本@code{asm}文だけが安全にnaked関数（@pxref {Basic Asm}）に含まれることができる。 拡張@code {asm}または基本@code {asm}とCコードの混在を使用すると動作するように見えるかもしれないが、信頼できる動作に依存することはできず、サポートされていない。
@end table

@node MeP Function Attributes
@subsection MeP関数属性

これらの関数属性は、MePバックエンドによってサポートされている。

@table @code
@item disinterrupt
@cindex @code{disinterrupt} function attribute, MeP
MePターゲットでは、この属性により、コンパイラは指定された関数の実行中に割り込みを無効にする命令を発行する。

@item interrupt
@cindex @code{interrupt} function attribute, MeP
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item near
@cindex @code{near} function attribute, MeP
この属性により、コンパイラは、@option{-mtf}コマンドラインオプションをオーバーライドして、呼び出された関数が通常の呼び出し規約を使用するのに十分近いと想定する。

@item far
@cindex @code{far} function attribute, MeP
MePターゲットでは、コンパイラは呼び出された関数が組み込みアドレッシングモードではあまりにも遠すぎると仮定した呼び出し規約を使用する。

@item vliw
@cindex @code{vliw} function attribute, MeP
@code{vliw}属性は、コアモードではなくVLIWモードで命令を発行するようにコンパイラに指示する。 VLIWコプロセッサがコマンドラインオプションによって構成され、有効にされていない限り、この属性は使用できない。
@end table

@node MicroBlaze Function Attributes
@subsection MicroBlaze関数属性

これらの関数属性は、MicroBlazeターゲットでサポートされている。

@table @code
@item save_volatiles
@cindex @code{save_volatiles} function attribute, MicroBlaze
この属性を使用して、関数が割り込みハンドラであることを示す。 （不揮発性レジスタに加えて）すべての揮発性レジスタは、関数プロローグに保存される。 関数がリーフ関数の場合、関数が使用する揮発性物質のみが保存される。 割り込みからの復帰ではなく、通常の関数戻りが生成される。

@item break_handler
@cindex @code{break_handler} function attribute, MicroBlaze
@cindex break handler functions
この属性を使用して、指定された関数がブレークハンドラであることを示す。 コンパイラーは、この属性が存在する場合にブレーク・ハンドラーでの使用に適した関数入力および出口シーケンスを生成する。 @code{break_handler}からの復帰は@code{rtsd}ではなく@code{rtbd}によって行われる。

@smallexample
void f () __attribute__ ((break_handler));
@end smallexample

@item interrupt_handler
@itemx fast_interrupt 
@cindex @code{interrupt_handler} function attribute, MicroBlaze
@cindex @code{fast_interrupt} function attribute, MicroBlaze
これらの属性は、指定された関数が割り込みハンドラであることを示す。 低レイテンシの割り込みモードで使用されるハンドラを示すには@code{fast_interrupt}属性を使用し、低レイテンシハンドラを使用しない割り込みには@code{interrupt_handler}を使用する。 どちらの場合も、GCCは適切なプロローグコードを生成し、@code {rtsd}の代わりに@code{rtid}を使用してハンドラからのリターンを生成する。
@end table

@node Microsoft Windows Function Attributes
@subsection Microsoft Windows関数属性

次の属性は、Microsoft WindowsおよびSymbian OSターゲットで使用できる。

@table @code
@item dllexport
@cindex @code{dllexport} function attribute
@cindex @code{__declspec(dllexport)}
Microsoft WindowsターゲットとSymbian OSターゲットでは、@code{dllexport}属性を使用すると、コンパイラーはDLLのポインターへのグローバルポインターを提供し、@code{dllimport}属性で参照できるようになる。 Microsoft Windowsターゲットでは、@code{_imp__}と関数名または変数名を組み合わせてポインタ名を作成する。

他のコンパイラとの互換性のため、@code{__declspec(dllexport)}を@code{__attribute__((dllexport))}と同義語として使うことができる。

@code{visibility}属性をサポートするシステムでは、この属性は「default」の可視性も意味する。 他の可視性を明示的に指定するのは誤りである。

GCCのデフォルトの動作は、@code{dllexport}属性を持つすべてのインライン関数を出力することである。 これはオブジェクトファイルサイズの膨張を引き起こす可能性があるので、@option{-fkeep-inline-functions}フラグが代わりに使用されない限り、GCCにインライン関数の属性を無視するように指示する@option{-fno-keep-inline-dllexport}を使用できる。

定義されていないシンボルの場合、属性は無視される。

C++クラスに適用すると、属性は非インラインメンバー関数と静的データメンバーをエクスポートとして定義する。 クラス内で初期化された静的constは、クラス外でも定義されていない限り、マークされない。

Microsoft Windowsターゲットでは、@code{EXPORTS}セクションで@file{.def}ファイルを使用するか、@option{--export-all}リンカーフラグを使用してGNU ldでシンボルをDLLのエクスポートテーブルに組み込む方法がある。

@item dllimport
@cindex @code{dllimport} function attribute
@cindex @code{__declspec(dllimport)}
Microsoft WindowsおよびSymbian OSターゲットでは、@code{dllimport}属性により、コンパイラはシンボルをエクスポートするDLLによって設定されたポインタへのグローバルポインタを介して関数または変数を参照する。 この属性は@code{extern}を意味する。 Microsoft Windowsターゲットでは、@code{_imp__}と関数名または変数名を組み合わせてポインタ名を作成する。

他のコンパイラとの互換性のため、@code{__declspec(dllimport)}を@code {__attribute__((dllimport))}の同義語として使うことができる。

@code{visibility}属性をサポートするシステムでは、この属性は「default」の可視性も意味する。 他の可視性を明示的に指定するのは誤りである。

現在、インライン関数の場合、属性は無視される。属性がシンボル@emph{定義}に適用されると、エラーが報告される。以前に@code{dllimport}と宣言されたシンボルが後で定義された場合、その属性は後続の参照では無視され、警告が発行される。この属性は、以降の@code{dllexport}の宣言によっても上書きされる。

C++クラスに適用すると、属性はインラインでないメンバ関数と静的データメンバをインポートとしてマークする。 ただし、サンクを使用してvtableを作成できるようにする仮想メソッドでは、属性は無視される。

SH Symbian OSターゲットでは、@code{dllimport}属性には別の影響もある。クラスのvtableおよび実行時の型情報がエクスポートされる可能性がある。これは、クラスにdllimportされたコンストラクタまたは非インラインで純粋でない仮想関数があり、（これらの2つの条件のいずれかに対して）クラスにインラインコンストラクタまたはデストラクタがあり、現在の翻訳単位で定義されているキー関数を持っている場合に発生する。

Microsoft Windowsターゲットでは、関数に@code{dllimport}属性を使用する必要はないが、DLL内のサンクを除去することでパフォーマンスが少し向上する。@option{-enable-auto-import}スイッチをGNUリンカーに渡すことで、インポートされた変数に@code{dllimport}属性を使用することを避けることができる。 関数と同様に、変数の属性を使用すると、DLL内のサンクがなくなる。

この属性を使用することの1つの欠点は、@code{dllimport}とマークされた@emph{変数}へのポインタを定数アドレスとして使用できないことである。 しかし、@code{dllimport}属性を持つ@emph{関数}へのポインタは定数初期化子として使用できる。 この場合、インポートlib内のスタブ関数のアドレスが参照される。 Microsoft Windowsターゲットでは、@option{-mnop-fun-dllimport}フラグを設定することで、関数の属性を無効にすることができる。
@end table

@node MIPS Function Attributes
@subsection MIPS関数属性

これらの関数属性は、MIPSバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, MIPS
この属性を使用して、指定された関数が割り込みハンドラであることを示す。コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。割込みモードを記述できるようにするために、オプションの引数が割込み属性に対してサポートされている。 デフォルトでは、GCCは外部割り込みコントローラ（EIC）モードが使用されていることを前提としている。これは、@ code{eic}を使って明示的に設定できる。割込みがマスクされていない場合、要求された割込み優先レベル（IPL）が現在のIPLにコピーされ、優先順位の高い割込みのみを有効にする効果がある。ベクタ割り込みモードを使用するには、引数@code{vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5}を使用する。これはマスクされていない割り込みサポートの動作を変更し、GCCはsw0から指定された割り込みベクタまでのすべての割り込みをマスクするように手配する。

次の属性を使用して、割り込みハンドラの動作を変更できる。
@table @code
@item use_shadow_register_set
@cindex @code{use_shadow_register_set} function attribute, MIPS
ハンドラが主な汎用レジスタの代わりにシャドウレジスタセットを使用すると仮定する。 オプションの引数@code{intstack}は、シャドウレジスタセットに有効なスタックポインタが含まれていることを示すためにサポートされている。

@item keep_interrupts_masked
@cindex @code{keep_interrupts_masked} function attribute, MIPS
関数全体に対して割り込みをマスクしておく。 この属性がなければ、GCCは可能な限り多くの関数に対して割り込みを再び有効にしようとする。

@item use_debug_exception_return
@cindex @code{use_debug_exception_return} function attribute, MIPS
@code{deret}命令を使用して復帰する。 この属性を持たない割り込みハンドラは、代わりに@code{eret}を使用して復帰する。
@end table

以下に示すように、これらの属性の任意の組み合わせを使用できる。
@smallexample
void __attribute__ ((interrupt)) v0 ();
void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();
void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();
void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();
void __attribute__ ((interrupt, use_shadow_register_set,
                     keep_interrupts_masked)) v4 ();
void __attribute__ ((interrupt, use_shadow_register_set,
                     use_debug_exception_return)) v5 ();
void __attribute__ ((interrupt, keep_interrupts_masked,
                     use_debug_exception_return)) v6 ();
void __attribute__ ((interrupt, use_shadow_register_set,
                     keep_interrupts_masked,
                     use_debug_exception_return)) v7 ();
void __attribute__ ((interrupt("eic"))) v8 ();
void __attribute__ ((interrupt("vector=hw3"))) v9 ();
@end smallexample

@item long_call
@itemx short_call
@itemx near
@itemx far
@cindex indirect calls, MIPS
@cindex @code{long_call} function attribute, MIPS
@cindex @code{short_call} function attribute, MIPS
@cindex @code{near} function attribute, MIPS
@cindex @code{far} function attribute, MIPS
これらの属性は、特定の関数がMIPSでどのように呼び出されるかを指定する。属性は@option{-mlong-calls}（@pxref{MIPS Options}）コマンドラインスイッチよりも優先される。 @code{long_call}属性と@code{far}属性は同義語であり、コンパイラは最初にそのアドレスをレジスタにロードし、次にそのレジスタの内容を使用して関数を呼び出すようにする。@code{short_call}と@code{near}属性は同義語であり、逆の効果を持つ。 より効率的な@code{jal}命令を使用して非PIC呼び出しを行う必要があることを指定する。

@item mips16
@itemx nomips16
@cindex @code{mips16} function attribute, MIPS
@cindex @code{nomips16} function attribute, MIPS
MIPSターゲットでは、@code{mips16}および@code{nomips16}関数属性を使用して、MIPS16コード生成を局所的に選択または無効にすることができる。@code{mips16}属性を持つ関数はMIPS16コードとして出力される一方、MIPS16コード生成は@code{nomips16}属性を持つ関数では無効になる。 これらの属性は、コマンド行の@option{-mips16}オプションと@option{-mno-mips16}オプションをオーバーライドする(@pxref{MIPS Options})。

MIPS16とMIPS16の混在したコードを含むファイルをコンパイルするとき、プリプロセッサシンボル@code{__ mips16}は個々の関数内の設定ではなく、コマンドラインでの設定を反映する。MIPS16と非MIPS16コードの混合は、@code{__ builtin_apply}のようないくつかのGCC拡張とうまくやりとりできない。(@pxref{Constructing Calls}).

@item micromips, MIPS
@itemx nomicromips, MIPS
@cindex @code{micromips} function attribute
@cindex @code{nomicromips} function attribute
MIPSターゲットでは、@code{micromips}および@code{nomicromips}関数属性を使用して、microMIPSコード生成を局所的に選択またはオフにすることができる。@code{micromips}属性を持つ関数は、microMIPSコードとして出力される一方、microMIPSコード生成は、@code{nomicromips}属性を持つ関数に対しては無効である。これらの属性は、コマンド行の@option{-mmicromips}オプションと@option{-mno-micromips}オプションよりも優先される(@pxref{MIPS Options})。

microMIPSとnon-microMIPSの混在したファイルをコンパイルする場合、プリプロセッサシンボル@code{__mips_micromips}は個々の関数内の設定ではなく、コマンドラインの設定を反映する。 混合microMIPSと非microMIPSコードは、@code{__ builtin_apply}のようないくつかのGCC拡張とうまくやりとりできない。(@pxref{Constructing Calls})。

@item nocompression
@cindex @code{nocompression} function attribute, MIPS
MIPSターゲットでは、@code{nocompression}関数属性を使用して、MIPS16およびmicroMIPSコードの生成を局所的にオフにすることができる。 この属性は、コマンド行の@option{-mips16}オプションと@option{-mmicromips}オプションをオーバーライドする。(@pxref{MIPS Options}).
@end table

@node MSP430 Function Attributes
@subsection MSP430関数属性

これらの関数属性は、MSP430バックエンドによってサポートされている。

@table @code
@item critical
@cindex @code{critical} function attribute, MSP430
critical関数は、入力時に割り込みを無効にし、終了時に以前の割り込み状態を復元する。 critical関数は、@code{naked}属性や@code{reentrant}属性を持つこともできない。 それらは@code{interrupt}属性を持つことができる。

@item interrupt
@cindex @code{interrupt} function attribute, MSP430
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

名前または番号を指定する割り込み属性に引数を指定できる。 引数が数値の場合、このハンドラを割り当てるべき割込みベクタテーブル（0〜31）のスロットを示す。 引数が名前の場合は、ベクトルスロットのシンボリック名として扱われる。 これらの名前は、リンカースクリプトの適切なエントリと一致する必要がある。 デフォルトでは、ベクトル26は@code{watchdog}、ベクトル30は@code{nmi}、ベクトル31は@code{reset}という名前が認識される。

@item naked
@cindex @code{naked} function attribute, MSP430
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。

@item reentrant
@cindex @code{reentrant} function attribute, MSP430
reentrant関数は、入力時に割り込みを無効にし、終了時に割り込みを有効にする。reentrant関数は@code{naked}属性や@code{critical}属性を持つこともできない。 それらは@code{interrupt}属性を持つことができる。

@item wakeup
@cindex @code{wakeup} function attribute, MSP430
この属性は割り込み関数にのみ適用される。 非割り込み関数に適用されると、暗黙のうちに無視される。 ウェイクアップ割り込み関数は、関数が終了したときに低電力の可能性がある状態からプロセッサを起床させる。

@item lower
@itemx upper
@itemx either
@cindex @code{lower} function attribute, MSP430
@cindex @code{upper} function attribute, MSP430
@cindex @code{either} function attribute, MSP430
MSP430ターゲットでは、これらの属性を使用して、関数または変数を低メモリ、高メモリに配置するか、プレースメントをリンカーに任せて決定するかを指定できる。 属性は、MSP430Xアーキテクチャ用にコンパイルする場合にのみ意味を持つ。

この属性は、セクションを@code{.lower}と@code{.upper}というプレフィックスで配置する場所を指定するために拡張されたリンカスクリプトと連携して動作する。たとえば、@code{.data}セクションを配置するだけでなく、@code{.lower.data}セクションと@code {.upper.data}セクションの配置も指定する。その目的は、@code{lower}セクションが小さいがアクセスしやすいメモリ領域に配置され、上部セクションがより大きいがアクセスは遅い領域に配置されることである。
@code{either}属性は特別である。 それは、オブジェクトに対応する@code{lower}セクションにオブジェクトを配置するようリンカに指示する。 十分な空きがない場合、オブジェクトは代わりに対応する@code{upper}セクションに配置される。 配置アルゴリズムはあまり洗練されていないことに注意せよ。 @code{lower}セクションの最適なパッキングを見つけることを試みない。 それは単にオブジェクトをワンパスで作り、可能な限りベストを尽くす。 しかし、@option{-ffunction-sections}と@option{-fdata-sections}のコマンドラインオプションを使うと、パックする領域が小さくて簡単になるので、パッキングに役立つ。
@end table

@node NDS32 Function Attributes
@subsection NDS32関数属性

これらの関数属性は、NDS32バックエンドによってサポートされている。

@table @code
@item exception
@cindex @code{exception} function attribute
@cindex exception handler functions, NDS32
指定された関数が例外ハンドラであることを示すには、NDS32ターゲットでこの属性を使用する。 コンパイラは、対応するセクションを生成して例外ハンドラで使用する。

@item interrupt
@cindex @code{interrupt} function attribute, NDS32
NDS32ターゲットでは、この属性は指定された関数が割り込みハンドラであることを示す。 コンパイラは、対応するセクションを生成して割り込みハンドラで使用する。 次の属性を使用して動作を変更できる。
@table @code
@item nested
@cindex @code{nested} function attribute, NDS32
この割り込みサービスルーチンは割り込み可能である。
@item not_nested
@cindex @code{not_nested} function attribute, NDS32
この割り込みサービスルーチンは中断できない。
@item nested_ready
@cindex @code{nested_ready} function attribute, NDS32
この割り込みサービスルーチンは、@code{PSW.GIE}（グローバル割り込み許可）がセットされた後に割り込み可能である。 これにより、割り込みサービスルーチンは、割り込みを有効にする前に、いくつかの重要な短いコードを終了することができる。
@item save_all
@cindex @code{save_all} function attribute, NDS32
システムは、割り込みハンドラに入る前にすべてのレジスタをスタックに保存するのを助ける。
@item partial_save
@cindex @code{partial_save} function attribute, NDS32
システムは、割り込みハンドラに入る前に呼び出し元レジスタをスタックに保存するのを助ける。
@end table

@item naked
@cindex @code{naked} function attribute, NDS32
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。

@item reset
@cindex @code{reset} function attribute, NDS32
@cindex reset handler functions
指定された関数がリセットハンドラであることを示すには、NDS32ターゲットでこの属性を使用する。 コンパイラは対応するセクションを生成し、リセットハンドラで使用する。 追加の例外処理を提供するには、次の属性を使用できる。
@table @code
@item nmi
@cindex @code{nmi} function attribute, NDS32
NMI例外を処理するユーザー定義関数を提供する。
@item warm
@cindex @code{warm} function attribute, NDS32
ウォームリセット例外を処理するためのユーザー定義関数を提供する。
@end table
@end table

@node Nios II Function Attributes
@subsection Nios II関数属性

これらの関数属性は、Nios IIバックエンドでサポートされている。

@table @code
@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

Nios II用にコンパイルする場合は、次のオプションを使用できる。

@table @samp
@item custom-@var{insn}=@var{N}
@itemx no-custom-@var{insn}
@cindex @code{target("custom-@var{insn}=@var{N}")} function attribute, Nios II
@cindex @code{target("no-custom-@var{insn}")} function attribute, Nios II
各@samp{custom-@var{insn}=@var{N}}属性は、@var{insn}を使用するコードを生成するときに@var{N}をエンコードしてカスタム命令をローカルで使用できるようにする。 同様に、@samp{no-custom-@var{insn}}はカスタム命令@var{insn}の使用をローカルで禁止する。これらのターゲット属性は、@option{-mcustom-@var{insn}=@var{N}}および@option{-mno-custom-@var{insn}}コマンドラインオプションに対応し、 @var{insn}キーワードと同じセットをサポートする。詳細は@xref{Nios II Options}を参照せよ。

@item custom-fpu-cfg=@var{name}
@cindex @code{target("custom-fpu-cfg=@var{name}")} function attribute, Nios II
この属性は@option{-mcustom-fpu-cfg=@var{name}}コマンドラインオプションに対応し、@var{name}というカスタム命令の定義済みセットを選択する。さらなる情報は@xref{Nios II Options}。
@end table
@end table

@node Nvidia PTX Function Attributes
@subsection Nvidia PTX関数属性

これらの関数属性は、Nvidia PTXバックエンドによってサポートされている。

@table @code
@item kernel
@cindex @code{kernel} attribute, Nvidia PTX
この属性は、対応する関数をCUDA RTライブラリ経由でホストから呼び出すことができるカーネル関数としてコンパイルする必要があることを示す。デフォルトでは、関数は他のPTX関数からのみ呼び出すことができる。

カーネル関数は@code {void}戻り型を持たなければならない。
@end table

@node PowerPC Function Attributes
@subsection PowerPC関数属性

これらの関数属性は、PowerPCバックエンドによってサポートされている。

@table @code
@item longcall
@itemx shortcall
@cindex indirect calls, PowerPC
@cindex @code{longcall} function attribute, PowerPC
@cindex @code{shortcall} function attribute, PowerPC
@code{longcall}属性は、関数がコールサイトから離れていて、別の（より高価な）呼び出しシーケンスを必要とする可能性があることを示す。 @code{shortcall}属性は、短い呼び出しシーケンスを使用するために関数が常に十分に近いことを示す。 これらの属性は、@option{-mlongcall}スイッチと@code{#pragma longcall}設定の両方を上書きする。

長いコールが必要かどうかの詳細については、@xref{RS/6000 and PowerPC Options}。

@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

PowerPCでは、次のオプションを使用できる。

@table @samp
@item altivec
@itemx no-altivec
@cindex @code{target("altivec")} function attribute, PowerPC
AltiVec命令を使用するコードを生成する（しない）。 32ビットコードでは、コマンドラインで@option{-mabi=altivec}を使用しない限り、AltiVec命令を有効にすることはできない。

@item cmpb
@itemx no-cmpb
@cindex @code{target("cmpb")} function attribute, PowerPC
POWER6プロセッサーおよびPowerPC V2.05アーキテクチャーをサポートする他のプロセッサーでインプリメントされた比較バイト命令を使用する（使用しない）コードを生成する。

@item dlmzb
@itemx no-dlmzb
@cindex @code{target("dlmzb")} function attribute, PowerPC
IBM 405、440、464、および476プロセッサーで文字列検索@samp{dlmzb}命令を使用する（使用しない）コードを生成する。 この命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item fprnd
@itemx no-fprnd
@cindex @code{target("fprnd")} function attribute, PowerPC
POWER5+プロセッサーおよびPowerPC V2.03アーキテクチャーをサポートする他のプロセッサーに実装された整数値命令を使用する（使用しない）コードを生成する。

@item hard-dfp
@itemx no-hard-dfp
@cindex @code{target("hard-dfp")} function attribute, PowerPC
一部のPOWERプロセッサーで実装されている10進浮動小数点命令を使用する（使用しない）コードを生成する。

@item isel
@itemx no-isel
@cindex @code{target("isel")} function attribute, PowerPC
ISEL命令を使用する（使用しない）コードを生成する。

@item mfcrf
@itemx no-mfcrf
@cindex @code{target("mfcrf")} function attribute, PowerPC
POWER4プロセッサーおよびPowerPC V2.01アーキテクチャーをサポートする他のプロセッサーで実装された条件レコード・フィールド命令を使用する（使用しない）コードを生成する。

@item mfpgpr
@itemx no-mfpgpr
@cindex @code{target("mfpgpr")} function attribute, PowerPC
POWER6Xプロセッサーおよび拡張PowerPC V2.05アーキテクチャーをサポートする他のプロセッサーで実装された汎用レジスタ命令とのFP移動を使用する（使用しない）コードを生成する。

@item mulhw
@itemx no-mulhw
@cindex @code{target("mulhw")} function attribute, PowerPC
IBM 405,440,464、および476プロセッサ上のハーフワード乗算命令および乗算累算命令を使用する（使用しない）コードを生成する。これらの命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item multiple
@itemx no-multiple
@cindex @code{target("multiple")} function attribute, PowerPC
複数ワードのロード命令とストアの複数ワード命令を使用する（使用しない）コードを生成する。

@item update
@itemx no-update
@cindex @code{target("update")} function attribute, PowerPC
ベースレジスタを計算されたメモリ位置のアドレスに更新するロードまたはストア命令を使用する（使用しない）コードを生成する。

@item popcntb
@itemx no-popcntb
@cindex @code{target("popcntb")} function attribute, PowerPC
POWER5プロセッサーおよびPowerPC V2.02アーキテクチャーをサポートする他のプロセッサーで実装されたポップカウントおよび倍精度のFP逆数推定命令を使用する（使用しない）コードを生成する。

@item popcntd
@itemx no-popcntd
@cindex @code{target("popcntd")} function attribute, PowerPC
POWER7プロセッサーおよびPowerPC V2.06アーキテクチャーをサポートする他のプロセッサーに実装されたpopcount命令を使用する（使用しない）コードを生成する。

@item powerpc-gfxopt
@itemx no-powerpc-gfxopt
@cindex @code{target("powerpc-gfxopt")} function attribute, PowerPC
浮動小数点選択を含むグラフィックスグループのオプションのPowerPCアーキテクチャ命令を使用する（使用しない）コードを生成する。

@item powerpc-gpopt
@itemx no-powerpc-gpopt
@cindex @code{target("powerpc-gpopt")} function attribute, PowerPC
浮動小数点平方根を含む汎用目的グループのオプションのPowerPCアーキテクチャ命令を使用する（使用しない）コードを生成する。

@item recip-precision
@itemx no-recip-precision
@cindex @code{target("recip-precision")} function attribute, PowerPC
逆数見積もり命令がPowerPC ABIよりも高い精度の見積もりを提供すると仮定する（仮定しない）。

@item string
@itemx no-string
@cindex @code{target("string")} function attribute, PowerPC
ロード文字列命令とストア文字列ワード命令を使用し、複数のレジスタを保存し、小さなブロック移動を行う（行わない）コードを生成する。

@item vsx
@itemx no-vsx
@cindex @code{target("vsx")} function attribute, PowerPC
ベクトル/スカラー（VSX）命令を使用する（使用しない）コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にする。 32ビットコードでは、コマンドラインで@option{-mabi = altivec}を使用しない限り、VSXまたはAltiVec命令を有効にすることはできない。

@item friz
@itemx no-friz
@cindex @code{target("friz")} function attribute, PowerPC
@option{-funsafe-math-optimizations}オプションを使用して浮動小数点値の64ビット整数への丸めと浮動小数点への最適化を最適化する場合、@code{friz}命令を生成するい（生成しない）。 浮動小数点数が大きすぎて整数に収まらない場合、@code{friz}命令は同じ値を返さない。

@item avoid-indexed-addresses
@itemx no-avoid-indexed-addresses
@cindex @code{target("avoid-indexed-addresses")} function attribute, PowerPC
インデックス付きのロードまたはストア命令の使用を回避する（回避しない）コードを生成する。

@item paired
@itemx no-paired
@cindex @code{target("paired")} function attribute, PowerPC
PAIRED simd命令の生成を使用する（使用しない）コードを生成する。

@item longcall
@itemx no-longcall
@cindex @code{target("longcall")} function attribute, PowerPC
すべての呼び出しが遠く離れていると想定している（想定していない）コードを生成し、より高価な呼び出しシーケンスが必要になるようにする。

@item cpu=@var{CPU}
@cindex @code{target("cpu=@var{CPU}")} function attribute, PowerPC
関数のコンパイル時にコードを生成するアーキテクチャを指定します。 32ビットコードを生成するときに@code {target("cpu=power7")}属性を選択すると、コマンドラインで@option{-mabi=altivec}オプションを使用しない限り、VSXおよびAltiVec命令は生成されない。

@item tune=@var{TUNE}
@cindex @code{target("tune=@var{TUNE}")} function attribute, PowerPC
関数のコンパイル時にチューニングするアーキテクチャを指定する。 @code{target("tune=@var{TUNE}")}属性を指定せず、@code{target("cpu=@var{CPU}")}属性を指定すると、コマンドラインで指定されたデフォルトのチューニングではなく、@var{CPU}アーキテクチャ向けにコンパイルする。
@end table

PowerPCでは、呼び出し側が呼び出し側のターゲットオプションのサブセットを持っていない限り、インライナーは呼び出し側とは異なるターゲットオプションを持つ関数をインラインしない。
@end table

@node RISC-V Function Attributes
@subsection RISC-V Function Attributes

These function attributes are supported by the RISC-V back end:

@table @code
@item naked
@cindex @code{naked} function attribute, RISC-V
This attribute allows the compiler to construct the
requisite function declaration, while allowing the body of the
function to be assembly code. The specified function will not have
prologue/epilogue sequences generated by the compiler. Only basic
@code{asm} statements can safely be included in naked functions
(@pxref{Basic Asm}). While using extended @code{asm} or a mixture of
basic @code{asm} and C code may appear to work, they cannot be
depended upon to work reliably and are not supported.
@end table

@node RL78 Function Attributes
@subsection RL78関数属性

これらの関数属性は、RL78バックエンドによってサポートされている。

@table @code
@item interrupt
@itemx brk_interrupt
@cindex @code{interrupt} function attribute, RL78
@cindex @code{brk_interrupt} function attribute, RL78
これらの属性は、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@code{BRK}オペコード（つまり、@code{RETI}の代わりに@code{RETB}で終わらなければならないもの）で使用するハンドラには、@code{interrupt}の代わりに@code{brk_interrupt}を使用すること。

@item naked
@cindex @code{naked} function attribute, RL78
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。
@end table

@node RX Function Attributes
@subsection RX関数属性

これらの関数属性は、RXバックエンドによってサポートされている。

@table @code
@item fast_interrupt
@cindex @code{fast_interrupt} function attribute, RX
指定された機能が高速割り込みハンドラであることを示すには、この属性をRXポートで使用する。 これは、@code{reit}の代わりに@code{freit}が返される点を除いて、@code{interrupt}属性と同じである。

@item interrupt
@cindex @code{interrupt} function attribute, RX
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

RXとRL78ターゲットでは、1つまたは複数のベクタ番号を属性の引数として指定し、代替テーブル名の名前を付けることができる。 パラメータは順次処理されるため、1つのハンドラを複数のテーブルの複数のエントリに割り当てることができる。 また、現在のテーブルの空きスロットに関数を使用させるために、マジック文字列@code{"$ default"}を渡すこともできる。

この例では、デフォルトテーブルの1つのベクトルに関数を単純に代入している（チップ固有のシンボリックベクトル名にはプリプロセッサマクロを使用できることに注意）。
@smallexample
void __attribute__ ((interrupt (5))) txd1_handler ();
@end smallexample

この例では、デフォルトテーブルの2つのスロットに関数を割り当て（プリプロセッサマクロを他の場所で定義して使用）、@code{dct}テーブルのデフォルトにする。
@smallexample
void __attribute__ ((interrupt (RXD1_VECT,RXD2_VECT,"dct","$default")))
	txd1_handler ();
@end smallexample

@item naked
@cindex @code{naked} function attribute, RX
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。

@item vector
@cindex @code{vector} function attribute, RX
このRX属性は、パラメータを含む@code{interrupt}属性に似ていまるが、関数を割り込みハンドラ型関数にしない（つまり、通常のC関数呼び出しABIを保持する）。 その引数の説明については、@code{interrupt}属性を参照せよ。
@end table

@node S/390 Function Attributes
@subsection S/390関数属性

これらの関数属性は、S/390でサポートされている。

@table @code
@item hotpatch (@var{halfwords-before-function-label},@var{halfwords-after-function-label})
@cindex @code{hotpatch} function attribute, S/390

S/390 System zターゲットでは、この関数属性を使用して、GCCに「ホット・パッチ」機能のプロローグを生成させることができる。 @option{-mhotpatch =}コマンドラインオプションを同時に使用すると、@code{hotpatch}属性が優先される。 最初の2つの引数は、関数ラベルの前に追加するハーフワードの数を指定する。 2番目の引数を使用して、関数ラベルの後ろに追加するハーフワードの数を指定できる。 両方の引数について、最大許容値は1000000である。

両方の引数がゼロの場合、ホットパッチは無効になる。

@item target (@var{options})
@cindex @code{target} function attribute
@ref{Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

S/390では、以下のオプションがサポートされています。

@table @samp
@item arch=
@item tune=
@item stack-guard=
@item stack-size=
@item branch-cost=
@item warn-framesize=
@item backchain
@itemx no-backchain
@item hard-dfp
@itemx no-hard-dfp
@item hard-float
@itemx soft-float
@item htm
@itemx no-htm
@item vx
@itemx no-vx
@item packed-stack
@itemx no-packed-stack
@item small-exec
@itemx no-small-exec
@item mvcle
@itemx no-mvcle
@item warn-dynamicstack
@itemx no-warn-dynamicstack
@end table

これらのオプションは、S/390固有のコマンドラインオプション（@option {-m}のプレフィックスなし）とまったく同じように機能するが、機能マクロは変更されない。 例えば、

@smallexample
@code{target("no-vx")}
@end smallexample

は@code {__ VEC__}マクロを定義解除しない。
@end table

@node SH Function Attributes
@subsection SH関数属性

これらの関数属性は、SHファミリのプロセッサでサポートされている。

@table @code
@item function_vector
@cindex @code{function_vector} function attribute, SH
@cindex calling functions through the function vector on SH2A
SH2Aターゲットでは、この属性はTBR相対アドレッシングモードを使用して呼び出される関数を宣言する。 この属性の引数は、すべてのTBR相対アドレス可能関数を含むベクトルテーブル内の同じ関数のエントリ番号である。 正しい動作のためには、この属性を持つ関数が呼び出される前に、ベクタテーブルの開始点を指すようにTBRを設定する必要がある。 通常、初期化を行うには、スタートアップルーチンが適している。 TBR相対ベクトルテーブルは最大256の機能エントリを有することができる。 これらの関数へのジャンプは、SH2A固有の遅延なし分岐命令JSR/N @@(disp8, TBR)を使用して生成される。 この属性が正しく機能するには、GNU binutilsバージョン2.7以降のGASおよびGLDを使用する必要がある。

アプリケーションでは、一度呼び出される関数の場合、この属性は少なくとも8バイトのコードを保存する。 同じ関数に対して他の連続した呼び出しが行われている場合は、これらの呼び出しごとに2バイトのコードが保存される。

@item interrupt_handler
@cindex @code{interrupt_handler} function attribute, SH
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。

@item nosave_low_regs
@cindex @code{nosave_low_regs} function attribute, SH
@code{interrupt_handler}関数がレジスタR0..R7を保存して復元してはならないことを示すには、SHターゲットでこの属性を使用する。 これは、リエントラントでない割り込みハンドラに対して2番目のR0..R7レジスタバンクを持つSH3*およびSH4*ターゲットで使用できる。

@item renesas
@cindex @code{renesas} function attribute, SH
SHターゲットでは、この属性はルネサスABIの後に関数または構造体が続くことを指定する。

@item resbank
@cindex @code{resbank} function attribute, SH
SH2Aターゲットでは、@code{interrupt_handler}ルーチン用のレジスタバンクを使用して高速レジスタの保存と復元が可能である。 バンクへのセーブは、CPUがレジスタバンクを使用する割り込みを受け付けた後に自動的に実行される。

汎用レジスタR0〜R14、制御レジスタGBR、およびシステム・レジスタMACH、MACL、PRおよびベクタ・テーブル・アドレス・オフセットを含む19の32ビット・レジスタは、レジスタ・バンクに保存される。 レジスタバンクはファーストイン・ラスト・アウト（FILO）シーケンスでスタックされている。 RESBANK命令を発行することにより、バンクからの復元が実行される。

@item sp_switch
@cindex @code{sp_switch} function attribute, SH
この属性をSHで使用すると、@code{interrupt_handler}関数を代替スタックに切り替える必要がある。 代替スタックのアドレスを保持するグローバル変数に名前を付ける文字列引数が必要である。

@smallexample
void *alt_stack;
void f () __attribute__ ((interrupt_handler,
                          sp_switch ("alt_stack")));
@end smallexample

@item trap_exit
@cindex @code{trap_exit} function attribute, SH
@code{interrupt_handler}が@code {trap}の代わりに@code {rte}を使用して戻るには、SHのこの属性を使用する。 この属性には、使用されるトラップ番号を指定する整数引数が必要である。

@item trapa_handler
@cindex @code{trapa_handler} function attribute, SH
SHターゲットでは、この関数属性は@code{interrupt_handler}と似ているが、すべてのレジスタを保存して復元するわけではない。
@end table

@node SPU Function Attributes
@subsection SPU関数属性

これらの関数属性は、SPUバックエンドによってサポートされている。

@table @code
@item naked
@cindex @code{naked} function attribute, SPU
この属性により、コンパイラは関数の本体をアセンブリコードにしながら、必要な関数宣言を構築することができる。 指定された関数は、コンパイラによって生成されたプロローグ/エピローグシーケンスを持たない。基本@code{asm}文だけが安全にnaked関数（@pxref{Basic Asm}）に含まれることができる。 拡張@code{asm}または基本@code{asm}とCコードの混在を使用すると動作するように見えていても、信頼できる動作に依存することはできず、サポートされていない。
@end table

@node Symbian OS Function Attributes
@subsection Symbian OS関数属性

@code {dllexport}属性と@code {dllimport}属性の議論には、@xref{Microsoft Windows Function Attributes}。

@node V850 Function Attributes
@subsection V850関数属性

V850バックエンドは、次の関数属性をサポートしている。

@table @code
@item interrupt
@itemx interrupt_handler
@cindex @code{interrupt} function attribute, V850
@cindex @code{interrupt_handler} function attribute, V850
これらの属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、どちらかの属性が存在する場合に割り込みハンドラで使用するのに適した関数の入力および終了シーケンスを生成する。
@end table

@node Visium Function Attributes
@subsection Visium関数属性

これらの関数属性は、Visiumバックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, Visium
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。
@end table

@node x86 Function Attributes
@subsection x86関数属性

これらの関数属性は、x86バックエンドによってサポートされている。

@table @code
@item cdecl
@cindex @code{cdecl} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
@opindex mrtd
x86-32ターゲットでは、@code{cdecl}属性により、コンパイラは呼び出し元の関数が引数を渡すために使用されたスタック領域をポップすると想定する。 これは、@option{-mrtd}スイッチの効果を無効にするのに便利である。

@item fastcall
@cindex @code{fastcall} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
x86-32ターゲットでは、@code{fastcall}属性により、コンパイラはレジスタECXの最初の引数（整数型の場合）とレジスタEDXの2番目の引数（整数型の場合）を渡す。 後続およびその他の型付き引数がスタックに渡される。 呼び出された関数は引数をスタックからポップする。 引数の数が可変であれば、すべての引数がスタックにプッシュされる。

@item thiscall
@cindex @code{thiscall} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
x86-32ターゲットでは、@code{thiscall}属性はコンパイラにレジスタECXの最初の引数（整数型の場合）を渡させる。 後続およびその他の型付き引数がスタックに渡される。 呼び出された関数は引数をスタックからポップする。 引数の数が可変であれば、すべての引数がスタックにプッシュされる。@code{thiscall}属性は、C++非静的メンバ関数を対象としている。GCCの拡張として、この呼び出し規約はC関数や静的メンバーメソッドに使用できる。

@item ms_abi
@itemx sysv_abi
@cindex @code{ms_abi} function attribute, x86
@cindex @code{sysv_abi} function attribute, x86
32ビットおよび64ビットのx86ターゲットでは、ABI属性を使用して、関数に使用する呼び出し規則を指定できる。@code{ms_abi}属性は、Microsoft ABIを使用するようにコンパイラに指示する。@code {sysv_abi}属性は、GNU/Linuxなどのシステムで使用されるABIを使用するようコンパイラに指示する。 デフォルトでは、Windowsを対象とするときにMicrosoft ABIを使用する。 他のすべてのシステムでは、デフォルトはx86/AMD ABIである。

Microsoft Windowsの64ビットターゲットの@code{ms_abi}属性には、現在、@option{-maccumulate-outgoing-args}オプションが必要であることに注意せよ。

@item callee_pop_aggregate_return (@var{number})
@cindex @code{callee_pop_aggregate_return} function attribute, x86
x86-32ターゲットでは、この属性を使用して、集約がメモリー内で返される方法を制御できる。 呼び出し側が非表示のポインタを残りの引数と一緒にポップする必要がある場合は、@var{number}をゼロと指定する。 呼び出し先が非表示のポインタをポップする場合は、@var{number}を1と指定する。

デフォルトのx86-32 ABIでは、呼び出し先が非表示のポインタのスタックをポップすることを前提としている。 ただし、x86-32 Microsoft Windowsターゲットでは、コンパイラは呼び出し元が非表示のポインタのスタックをポップすることを前提としている。

@item ms_hook_prologue
@cindex @code{ms_hook_prologue} function attribute, x86
32ビットおよび64ビットx86ターゲットでは、この関数属性を使用して、Microsoft Windows XP Service Pack 2以降のWin32 API関数で使用される「ホットパッチ」関数プロローグをGCCに生成させることができる。

@item naked
@cindex @code{naked} function attribute, x86
This attribute allows the compiler to construct the
requisite function declaration, while allowing the body of the
function to be assembly code. The specified function will not have
prologue/epilogue sequences generated by the compiler. Only basic
@code{asm} statements can safely be included in naked functions
(@pxref{Basic Asm}). While using extended @code{asm} or a mixture of
basic @code{asm} and C code may appear to work, they cannot be
depended upon to work reliably and are not supported.

@item regparm (@var{number})
@cindex @code{regparm} function attribute, x86
@cindex functions that are passed arguments in registers on x86-32
x86-32ターゲットで、@code{regparm}属性により、整数型である場合には、コンパイラは1個から@var{number}個までの引数をスタックの代わりにレジスタEAX、EDX、およびECXで渡す。可変数の引き数を取る関数は引き続きスタック上のすべての引数を渡す。

一部のELFシステムでは、この属性は、遅延バインディング（デフォルト）である共有ライブラリのグローバル関数には適していないことに注意せよ。遅延バインディングは、標準の呼び出し規約に従って、EAX、EDX、ECXが破壊できると仮定しているローダ内の解決コードを介して、最初の呼び出しを送信する。 Solaris 8はこの影響を受ける。 GNU Cライブラリバージョン2.1以上とFreeBSDを搭載したシステムは、そこにあるローダーがEAX、EDX、ECXを保存するので安全だと考えられている。 （問題が発生しないように、必要に応じて遅延バインディングをリンカまたはローダで無効にすることができる）。

@item sseregparm
@cindex @code{sseregparm} function attribute, x86
SSEをサポートしているx86-32ターゲットでは、@code{sseregparm}属性により、コンパイラーはスタック上ではなくSSEレジスターで最大3つの浮動小数点引数を渡す。 可変数の引数をとる関数は、スタック上のすべての浮動小数点引数を引き続き渡す。

@item force_align_arg_pointer
@cindex @code{force_align_arg_pointer} function attribute, x86
x86ターゲットでは、@code{force_align_arg_pointer}属性を個々の関数定義に適用して、必要に応じて実行時スタックを再調整する代替のプロローグとエピローグを生成することができる。 これは、SSEとの互換性のために16バイトのスタックを維持する最新のコードと4バイトの整列されたスタックで実行されるレガシーコードの混在をサポートする。

@item stdcall
@cindex @code{stdcall} function attribute, x86-32
@cindex functions that pop the argument stack on x86-32
x86-32ターゲットでは、@code{stdcall}属性は、可変数の引数を取らない限り、引数を渡すために使用されるスタック領域から、呼び出された関数がポップすることをコンパイラが想定するようにする。

@item no_caller_saved_registers
@cindex @code{no_caller_saved_registers} function attribute, x86
指定された関数に呼び出し元保存レジスタがないことを示すには、この属性を使用する。 つまり、すべてのレジスタが呼び出し先保存される。 たとえば、この属性は割り込みハンドラから呼び出された関数に使用できる。 コンパイラは、EFLAGSレジスタを除いて、変更されたレジスタを保存および復元するために、適切な関数入力および終了シーケンスを生成する。 GCCはMPX、SSE、MMX、およびx87状態を保持しないので、@code{no_caller_saved_registers}属性を持つ関数をコンパイルするには、GCCオプションの@option{-mgeneral-regs-only}を使用する必要がある。

@item interrupt
@cindex @code{interrupt} function attribute, x86
この属性を使用して、指定された関数が割り込みハンドラまたは例外ハンドラであることを示す。（さらに説明されているように、関数に渡されるパラメータに応じて）。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。 @code{RET}命令の代わりに@code{IRET}命令が、割り込みハンドラから復帰するために使用される。 @code{IRET}命令で復元されるEFLAGSレジスタを除くすべてのレジスタは、コンパイラによって保持される。 GCCはMPX、SSE、MMX、およびx87の状態を保持しないので、GCCオプションの@option{-mgeneral-regs-only}を使用して割り込みハンドラと例外ハンドラをコンパイルする必要がある。

スタック切り替えなしで割り込み可能なコードは、@option{-mno-red-zone}でコンパイルする必要がある。なぜなら、ハードウェア設計のために割り込みハンドラがレッド・ゾーンに触れることができるからである。

割り込みハンドラは、必須のポインタ引数で宣言する必要がある。

@smallexample
struct interrupt_frame;

__attribute__ ((interrupt))
void
f (struct interrupt_frame *frame)
@{
@}
@end smallexample

@noindent
プロセッサーのマニュアルで説明されているように、@code{struct interrupt_frame}を定義する必要がある。

例外ハンドラは、スタック上にエラーコードをプッシュするため、割り込みハンドラとは異なる。 例外ハンドラの宣言は、割り込みハンドラの宣言と似ているが、必須の関数シグネチャは異なる。 コンパイラは@code{IRET}命令の前にスタックからエラーコードをポップするように手配する。

@smallexample
#ifdef __x86_64__
typedef unsigned long long int uword_t;
#else
typedef unsigned int uword_t;
#endif

struct interrupt_frame;

__attribute__ ((interrupt))
void
f (struct interrupt_frame *frame, uword_t error_code)
@{
  ...
@}
@end smallexample

例外ハンドラは、エラーコードをプッシュする例外に対してのみ使用する必要がある。 それ以外の場合は割り込みハンドラを使用する必要がある。 間違った種類のハンドラが使用されると、システムがクラッシュする。

@item target (@var{options})
@cindex @code{target} function attribute
@ref {Common Function Attributes}で説明したように、この属性ではターゲット固有のコンパイルオプションを指定できる。

x86では、次のオプションを使用できる。
@table @samp
@item abm
@itemx no-abm
@cindex @code{target("abm")} function attribute, x86
拡張ビット命令の生成を有効/無効にする。

@item aes
@itemx no-aes
@cindex @code{target("aes")} function attribute, x86
AES命令の生成を有効/無効にする。

@item default
@cindex @code{target("default")} function attribute, x86
@xref{Function Multiversioning}デフォルトの関数バージョンを指定するために使用される。

@item mmx
@itemx no-mmx
@cindex @code{target("mmx")} function attribute, x86
MMX命令の生成を有効/無効にする。

@item pclmul
@itemx no-pclmul
@cindex @code{target("pclmul")} function attribute, x86
PCLMUL命令の生成を有効/無効にする。

@item popcnt
@itemx no-popcnt
@cindex @code{target("popcnt")} function attribute, x86
POPCNT命令の生成を有効/無効にする。

@item sse
@itemx no-sse
@cindex @code{target("sse")} function attribute, x86
SSE命令の生成を有効/無効にする。

@item sse2
@itemx no-sse2
@cindex @code{target("sse2")} function attribute, x86
SSE2命令の生成を有効/無効にする。

@item sse3
@itemx no-sse3
@cindex @code{target("sse3")} function attribute, x86
SSE3命令の生成を有効/無効にする。

@item sse4
@itemx no-sse4
@cindex @code{target("sse4")} function attribute, x86
SSE4命令の生成を有効/無効にする。（SSE4.1とSSE4.2の両方。）

@item sse4.1
@itemx no-sse4.1
@cindex @code{target("sse4.1")} function attribute, x86
SSE4.1命令の生成を有効/無効にする。

@item sse4.2
@itemx no-sse4.2
@cindex @code{target("sse4.2")} function attribute, x86
SSE4.2命令の生成を有効/無効にする。

@item sse4a
@itemx no-sse4a
@cindex @code{target("sse4a")} function attribute, x86
SSE4A命令の生成を有効/無効にする。

@item fma4
@itemx no-fma4
@cindex @code{target("fma4")} function attribute, x86
FMA4命令の生成を有効/無効にする。

@item xop
@itemx no-xop
@cindex @code{target("xop")} function attribute, x86
XOP命令の生成を有効/無効にする。

@item lwp
@itemx no-lwp
@cindex @code{target("lwp")} function attribute, x86
LWP命令の生成を有効/無効にする。

@item ssse3
@itemx no-ssse3
@cindex @code{target("ssse3")} function attribute, x86
SSSE3命令の生成を有効/無効にする。

@item cld
@itemx no-cld
@cindex @code{target("cld")} function attribute, x86
文字列が移動する前にCLDの生成を有効/無効にする。

@item fancy-math-387
@itemx no-fancy-math-387
@cindex @code{target("fancy-math-387")} function attribute, x86
387浮動小数点ユニットの@code{sin}、@code{cos}、および@code{sqrt}命令の生成を有効/無効にする。

@item ieee-fp
@itemx no-ieee-fp
@cindex @code{target("ieee-fp")} function attribute, x86
IEEE演算に依存する浮動小数点の生成を有効/無効にする。

@item inline-all-stringops
@itemx no-inline-all-stringops
@cindex @code{target("inline-all-stringops")} function attribute, x86
文字列操作のインライン展開を有効または無効にする。

@item inline-stringops-dynamically
@itemx no-inline-stringops-dynamically
@cindex @code{target("inline-stringops-dynamically")} function attribute, x86
小さな文字列操作を実行するためのインラインコードの生成と大きな操作のためにライブラリルーチンを呼び出しを有効または無効にする。

@item align-stringops
@itemx no-align-stringops
@cindex @code{target("align-stringops")} function attribute, x86
インラインストリング操作の宛先を揃える。

@item recip
@itemx no-recip
@cindex @code{target("recip")} function attribute, x86
浮動小数点除算の代わりに追加のNewton-Raphsonステップの実行が後に続くRCPSS、RCPPS、RSQRTSS、およびRSQRTPS命令の生成を有効/無効にする。

@item arch=@var{ARCH}
@cindex @code{target("arch=@var{ARCH}")} function attribute, x86
関数をコンパイルするためのコードを生成するアーキテクチャを指定する。

@item tune=@var{TUNE}
@cindex @code{target("tune=@var{TUNE}")} function attribute, x86
関数のコンパイル時にチューニングするアーキテクチャを指定する。

@item fpmath=@var{FPMATH}
@cindex @code{target("fpmath=@var{FPMATH}")} function attribute, x86
使用する浮動小数点ユニットを指定する。 コンマは異なるオプションを分離するため、@code{target( "fpmath=sse,387")}オプションは@code{target("fpmath=sse+387")}と指定する必要がある。

@item indirect_branch("@var{choice}")
@cindex @code{indirect_branch} function attribute, x86
x86ターゲットでは、@code{indirect_branch}属性で関数に間接呼び出しとジャンプを@var{choice}を使って変換するようにさせる。 @samp{keep}は間接呼び出しとジャンプを保持する。@samp{thunk}は間接呼び出しとジャンプを、サンクの呼び出しと復帰に変換する。@samp{thunk-inline}は間接呼び出しとジャンプをインライン化されたサンクの呼び出しと復帰に変換する。@samp{thunk-extern}は間接呼び出しとジャンプを別のオブジェクトファイルで提供されたサンクへの外部呼び出しと復帰に変換する。

@item function_return("@var{choice}")
@cindex @code{function_return} function attribute, x86
x86ターゲットでは、@code{function_return}属性に@var{choice}で関数復帰を変換するようにさせる。@samp{keep}は、関数復帰は変更されない。 @samp{thunk}は関数復帰をサンクの呼び出しと復帰に変換する。 @samp{thunk-inline}は、関数復帰をインライン化されたサンクの呼び出しと復帰に変換する。 @samp {thunk-extern}は、関数復帰を、別のオブジェクトファイルで提供されるサンクの呼び出しと復帰に変換する。

@item nocf_check
@cindex @code{nocf_check} function attribute
関数の@code{nocf_check}属性は、コンパイラに@option{-fcf-protection=branch}オプションを指定してコンパイルしたときに、関数のプロローグが計装されるべきでないことをコンパイラに通知するために使用される。 コンパイラは、関数のアドレスが制御フロー転送の有効なターゲットであるとみなす。

関数へのポインタ型の@code{nocf_check}属性は、@option{-fcf-protection=branch}オプションを指定してコンパイルしたときに、ポインタを通じた呼び出しが計装されてはならないことをコンパイラに通知するために使用される。 コンパイラは、ポインタからの関数のアドレスが制御フロー転送の有効なターゲットであると仮定する。 関数名による直接関数呼び出しは安全な呼び出しとみなされ、直接呼び出しはコンパイラーによって計装されない。

@code{nocf_check}属性はオブジェクトの型に適用される。関数アドレスまたは関数ポインタを別のポインタに代入する場合、その属性は右側のオブジェクトの型から持ち越されない。左辺値のオブジェクトのタイプは変更されない。 コンパイラは、@code{nocf_check}属性の不一致をチェックし、不一致の場合に警告を報告する。

@smallexample
@{
int foo (void) __attribute__(nocf_check);
void (*foo1)(void) __attribute__(nocf_check);
void (*foo2)(void);

/* foo's address is assumed to be valid.  */
int
foo (void) 

  /* This call site is not checked for control-flow 
     validity.  */
  (*foo1)();

  /* A warning is issued about attribute mismatch.  */
  foo1 = foo2; 

  /* This call site is still not checked.  */
  (*foo1)();

  /* This call site is checked.  */
  (*foo2)();

  /* A warning is issued about attribute mismatch.  */
  foo2 = foo1; 

  /* This call site is still checked.  */
  (*foo2)();

  return 0;
@}
@end smallexample

@end table

x86では、呼び出し側が呼び出し元のターゲットオプションのサブセットを持たない限り、インライナは呼び出し元とは異なるターゲットオプションを持つ関数をインライン化しない。 たとえば、@code{-msse3}は@code{-msse2}を意味するため、@code{target("sse3")}で宣言された関数は@code{target("sse2")}で関数をインライン化できる。
@end table

@node Xstormy16 Function Attributes
@subsection Xstormy16関数属性

これらの関数属性は、Xstormy16バックエンドによってサポートされている。

@table @code
@item interrupt
@cindex @code{interrupt} function attribute, Xstormy16
この属性を使用して、指定された関数が割り込みハンドラであることを示す。 コンパイラは、この属性が存在するときに割り込みハンドラでの使用に適した関数の入力および終了シーケンスを生成する。
@end table

@node Variable Attributes
@section 変数の属性の実行指定
@cindex attribute of variables
@cindex variable attributes

キーワード@code {__ attribute__}を使用すると、変数や構造体フィールドの特別な属性を指定できる。このキーワードの後には、二重括弧内の属性指定が続く。いくつかの属性は現在、変数に対して一般的に定義されている。 他の属性は、特定のターゲットシステム上の変数に対して定義されている。他の属性は、関数(@pxref{Function Attributes})、ラベル(@pxref{Label Attributes})、列挙子(@pxref{Enumerator Attributes})、文(@pxref{Statement Attributes})、および型 (@pxref{Type Attributes})に対して定義されている。他のフロントエンドはより多くの属性を定義するかもしれない。
(@pxref{C++ Extensions,,C++言語族に対する拡張}).

属性を使った正確な構文の詳細は@xref{Attribute Syntax}。

@menu
* Common Variable Attributes::
* ARC Variable Attributes::
* AVR Variable Attributes::
* Blackfin Variable Attributes::
* H8/300 Variable Attributes::
* IA-64 Variable Attributes::
* M32R/D Variable Attributes::
* MeP Variable Attributes::
* Microsoft Windows Variable Attributes::
* MSP430 Variable Attributes::
* Nvidia PTX Variable Attributes::
* PowerPC Variable Attributes::
* RL78 Variable Attributes::
* SPU Variable Attributes::
* V850 Variable Attributes::
* x86 Variable Attributes::
* Xstormy16 Variable Attributes::
@end menu

@node Common Variable Attributes
@subsection 共通変数属性

次の属性は、ほとんどのターゲットでサポートされている。

@table @code
@cindex @code{aligned} variable attribute
@item aligned (@var{alignment})
この属性は、変数または構造体フィールドの最小整列をバイト単位で指定する。 たとえば、次のような宣言があると、

@smallexample
int x __attribute__ ((aligned (16))) = 0;
@end smallexample

@noindent
コンパイラはグローバル変数@code {x}を16バイトの境界に割り当てる。 68040では、これを@code{asm}式と共に使用して、16バイトのアライメントされたオペランドを必要とする@code{move16}命令にアクセスできる。

構造体フィールドの配置を指定することもできる。 たとえば、ダブルワードアライメントの@code{int}ペアを作成するには、次のように記述する。

@smallexample
struct foo @{ int x[2] __attribute__ ((aligned (8))); @};
@end smallexample

@noindent
これは、@code{double}メンバを使用して共用体を作成して、共用体を強制的にダブルワードアライメントすることに代わるものである。

前述の例のように、コンパイラが指定した変数または構造体フィールドに対して使用する整列（バイト単位）を明示的に指定することができる。あるいは、アラインメント係数を省略して、変数またはフィールドを、コンパイル対象のターゲットアーキテクチャのデフォルトアライメントに合わせるようにコンパイラに依頼することもできる。デフォルトの配置はすべてのスカラー型で十分であるが、ベクトル操作をサポートするターゲット上のすべてのベクトル型では不十分な場合がある。デフォルトの配置は、特定のターゲットABIに対して固定されている。

GCCは、コンパイル対象のマシン上の任意のデータ型に対してこれまで使用されていた最大の配列であるターゲット固有のマクロ@code{__BIGGEST_ALIGNMENT__}も提供する。 たとえば、次のように書くことができる。

@smallexample
short array[3] __attribute__ ((aligned (__BIGGEST_ALIGNMENT__)));
@end smallexample

コンパイラは、宣言された変数またはフィールドの配置を自動的に@code{__BIGGEST_ALIGNMENT__}に設定する。この方法で整列された変数やフィールドとの間でコピーを実行するときに、コンパイラは最大のメモリチャンクをコピーするので、コピー操作をより効率的にすることができる。 @code{__BIGGEST_ALIGNMENT__}の値は、コマンドラインオプションによって変わる可能性があることに注意せよ。

構造体または構造体メンバで使用する場合、@code{aligned}属性はアライメントを増加させるだけである。 これを減らすために@code{packed}属性も指定する必要がある。 typedefの一部として使用する場合、@code{aligned}属性はアラインメントを増減できる。また、@code{packed}属性を指定すると警告が生成される。

@code{aligned}属性の有効性は、リンカの固有の制限によって制限されることに注意せよ。 多くのシステムでは、リンカーは、変数が特定の最大整列まで整列するようにのみ調整することができる。 （リンカの中には、サポートされている最大のアライメントが非常に小さいものもある。）リンカが変数を最大8バイトのアラインメントまでしかアライメントできない場合、@code {aligned__(16)}を@code{__attribute__}に指定しても8バイトのアラインメントしか得られない。 詳細については、リンカーのマニュアルを参照せよ。

@code {aligned}属性は、関数にも使用できる。(@pxref{Common Function Attributes}.)

@cindex @code{warn_if_not_aligned} variable attribute
@item warn_if_not_aligned (@var{alignment})
This attribute specifies a threshold for the structure field, measured
in bytes.  If the structure field is aligned below the threshold, a
warning will be issued.  For example, the declaration:

@smallexample
struct foo
@{
  int i1;
  int i2;
  unsigned long long x __attribute__((warn_if_not_aligned(16)));
@};
@end smallexample

@noindent
causes the compiler to issue an warning on @code{struct foo}, like
@samp{warning: alignment 8 of 'struct foo' is less than 16}.
The compiler also issues a warning, like @samp{warning: 'x' offset
8 in 'struct foo' isn't aligned to 16}, when the structure field has
the misaligned offset:

@smallexample
struct foo
@{
  int i1;
  int i2;
  unsigned long long x __attribute__((warn_if_not_aligned(16)));
@} __attribute__((aligned(16)));
@end smallexample

This warning can be disabled by @option{-Wno-if-not-aligned}.
The @code{warn_if_not_aligned} attribute can also be used for types
(@pxref{Common Type Attributes}.)

@item cleanup (@var{cleanup_function})
@cindex @code{cleanup} variable attribute
@code {cleanup}属性は、変数がスコープから外れると関数を実行する。 この属性は、自動関数スコープ変数にのみ適用できる。 静的記憶期間を有するパラメータまたは変数には適用できない。 関数は1つのパラメーター、変数と互換性のある型へのポインターを取る必要がある。 関数の戻り値（存在する場合）は無視される。

@option{-fexceptions}を有効にすると、例外の処理中に発生するスタックの巻き戻し中に@var{cleanup_function}が実行される。 @code{cleanup}属性は、例外を捕捉することを許可せず、アクションの実行のみを許可することに注意せよ。@var{cleanup_function}が正常に返されなかった場合の動作は未定義である。

@item common
@itemx nocommon
@cindex @code{common} variable attribute
@cindex @code{nocommon} variable attribute
@opindex fcommon
@opindex fno-common
@code{common}属性は、GCCに変数を「共通」ストレージに配置するよう要求する。 @code{nocommon}属性は、反対である。直接に空間を割り当てることを要求する。

これらの属性は、それぞれ@option{-fno-common}フラグと@option{-fcommon}フラグによって選択されたデフォルトを上書きする。

@item deprecated
@itemx deprecated (@var{msg})
@cindex @code{deprecated} variable attribute
変数がソースファイルのどこでも使用されている場合、@code{deprecated}属性は警告を出す。 これは、将来のバージョンのプログラムで削除されると予想される変数を識別する場合に便利である。 この警告には、廃止予定の変数の宣言の場所も含まれている。なぜなら、ユーザーは、変数が廃止された理由、またはその代わりに何をすべきかに関する詳細情報を簡単に見つけることができるようにするためである。 この警告は、使用時にのみ発生することに注意せよ。

@smallexample
extern int old_var __attribute__ ((deprecated));
extern int old_var;
int new_fn () @{ return old_var; @}
@end smallexample

@noindent
は行3では警告が表示されるが、行2では表示されない。文字列でなければならないオプションの@var{msg}引数は、警告があれば出力される。

@code{deprecated}属性は、関数および型にも使用できる。 (@pxref{Common Function Attributes}, @pxref{Common Type Attributes}).

@item nonstring
@cindex @code{nonstring} variable attribute
The @code{nonstring} variable attribute specifies that an object or member
declaration with type array of @code{char}, @code{signed char}, or
@code{unsigned char}, or pointer to such a type is intended to store
character arrays that do not necessarily contain a terminating @code{NUL}.
This is useful in detecting uses of such arrays or pointers with functions
that expect @code{NUL}-terminated strings, and to avoid warnings when such
an array or pointer is used as an argument to a bounded string manipulation
function such as @code{strncpy}.  For example, without the attribute, GCC
will issue a warning for the @code{strncpy} call below because it may
truncate the copy without appending the terminating @code{NUL} character.
Using the attribute makes it possible to suppress the warning.  However,
when the array is declared with the attribute the call to @code{strlen} is
diagnosed because when the array doesn't contain a @code{NUL}-terminated
string the call is undefined.  To copy, compare, of search non-string
character arrays use the @code{memcpy}, @code{memcmp}, @code{memchr},
and other functions that operate on arrays of bytes.  In addition,
calling @code{strnlen} and @code{strndup} with such arrays is safe
provided a suitable bound is specified, and not diagnosed.

@smallexample
struct Data
@{
  char name [32] __attribute__ ((nonstring));
@};

int f (struct Data *pd, const char *s)
@{
  strncpy (pd->name, s, sizeof pd->name);
  @dots{}
  return strlen (pd->name);   // unsafe, gets a warning
@}
@end smallexample

@item mode (@var{mode})
@cindex @code{mode} variable attribute
この属性は、宣言のデータ型を指定する。どちらの型もモード@var{mode}に対応しする。 実際には、幅に応じて整数型または浮動小数点型を要求できる。

@xref{Machine Modes,,, gccint, GNU Compiler Collection (GCC) Internals}は、@var {mode}の可能なキーワードのリストを参照する。また、1バイトの整数に対応するモードを示すために、@code{byte}または@code{__byte__}のモードを、1ワード整数のモードの場合は@code {word}または@code{__word__}、ポインタの表現に使用されるモードの場合は@code {pointer}または@code {__ pointer__}を指定することもできる。

@item packed
@cindex @code{packed} variable attribute
@code{aligned}属性でより大きい値を指定しない限り、@code{packed}属性は、変数または構造体フィールドの配置が最小になるように指定する。変数には1バイト、フィールドには1ビットを指定する 。

ここで構造体のフィールド@code{x}がパックされているので、すぐに@code {a}に続く：

@smallexample
struct foo
@{
  char a;
  int x[2] __attribute__ ((packed));
@};
@end smallexample

@emph{_注意_:} GCCの4.1、4.2および4.3シリーズは、@code{char}型のビットフィールドの@code{packed}属性を無視する。 これはGCC 4.4で修正されているが、変更によって構造のレイアウトが異なる場合がある。 詳細については、@option{-Wpacked-bitfield-compat}のドキュメントを参照せよ。

@item section ("@var{section-name}")
@cindex @code{section} variable attribute
通常、コンパイラは生成するオブジェクトを@code{data}や@code{bss}のようなセクションに配置する。 ただし、特別なハードウェアにマップするなど、特別なセクションに表示するには、セクションを追加する必要がある。 @code{section}属性は、変数（または関数）が特定のセクションに存在することを指定する。 たとえば、この小さなプログラムでは、いくつかの特定のセクション名を使用する。

@smallexample
struct duart a __attribute__ ((section ("DUART_A"))) = @{ 0 @};
struct duart b __attribute__ ((section ("DUART_B"))) = @{ 0 @};
char stack[10000] __attribute__ ((section ("STACK"))) = @{ 0 @};
int init_data __attribute__ ((section ("INITDATA")));

main()
@{
  /* @r{Initialize stack pointer} */
  init_sp (stack + sizeof (stack));

  /* @r{Initialize initialized data} */
  memcpy (&init_data, &data, &edata - &data);

  /* @r{Turn on the serial ports} */
  init_duart (&a);
  init_duart (&b);
@}
@end smallexample

@noindent
この例に示すように、@emph{ローカル}変数ではなく、@emph{グローバル}変数で@code{section}属性を使用すること。

初期化されている、または初期化されていないグローバル変数で@code{section}属性を使うことができるが、リンカは各オブジェクトを一度定義する必要がある。例外は、初期化されていない変数は@code{common}（または@code{bss}）セクションに一時的に置かれ、複数回「定義」されることができることである。@code{section}属性を使用すると、変数に入るセクションが変更され、初期化されていない変数に複数の定義がある場合、リンカにエラーが発生する可能性がある。変数を@option{-fno-common}フラグまたは@code {nocommon}属性で強制的に初期化することができる。

一部のファイル形式では任意のセクションはサポートされないため、@code{section}属性はすべてのプラットフォームで使用できるわけではない。モジュールの内容全体を特定のセクションにマップする必要がある場合は、代わりにリンカの機能を使用することを検討せよ。

@item tls_model ("@var{tls_model}")
@cindex @code{tls_model} variable attribute
@code{tls_model}属性は、特定の@code{__thread}変数のスレッドローカルストレージモデル（@pxref{Thread-Local}）を設定し@option{-ftls-model =}コマンドラインスイッチを、 変動単位で上書きする。@var{tls_model}引数は@code{global-dynamic}、@code{local-dynamic}、@code{initial-exec}または@code {local-exec}のいずれかでなければならない。

すべてのターゲットがこの属性をサポートするわけではない。

@item unused
@cindex @code{unused} variable attribute
変数に付けられたこの属性は、その変数が使用されていない可能性があることを意味する。 GCCはこの変数に対して警告を生成しない。

@item used
@cindex @code{used} variable attribute
この属性は、静的記憶域を持つ変数に添付されると、変数が参照されていないように見えても変数を発行する必要があることを意味する。

C++クラス・テンプレートの静的データ・メンバーに適用される場合、その属性は、クラス自体がインスタンス化された場合にメンバーがインスタンス化されることも意味する。

@item vector_size (@var{bytes})
@cindex @code{vector_size} variable attribute
この属性は、変数のベクトルサイズをバイト単位で指定する。 たとえば、次のような宣言があると：

@smallexample
int foo __attribute__ ((vector_size (16)));
@end smallexample

@noindent
コンパイラは@code{foo}のモードを16バイトに設定し、@code{int}サイズ単位に分割する。 32ビット整数（4バイトの4単位のベクトル）を仮定すると、対応する@code{foo}のモードはV4SIである。

この属性は、整数、浮動小数点スカラーにのみ適用されるが、配列、ポインタ、および関数の戻り値は、この構造とともに使用できる。

この属性を持つ集合知は、対応するスカラーと同じサイズであっても無効である。 たとえば、次のような宣言は、

@smallexample
struct S @{ int a; @};
struct S  __attribute__ ((vector_size (16))) foo;
@end smallexample

@noindent
構造体のサイズが@code {int}のサイズと同じであっても無効である。

@item visibility ("@var{visibility_type}")
@cindex @code{visibility} variable attribute
この属性は、それがアタッチされている宣言のリンケージに影響します。
@code {visibility}属性については、@ref{Common Function Attributes}.

@item weak
@cindex @code{weak} variable attribute
@code {weak}属性については、@ref{Common Function Attributes}.

@end table

@node ARC Variable Attributes
@subsection ARC Variable Attributes

@table @code
@item aux
@cindex @code{aux} variable attribute, ARC
The @code{aux} attribute is used to directly access the ARC's
auxiliary register space from C.  The auxilirary register number is
given via attribute argument.

@end table

@node AVR Variable Attributes
@subsection AVR変数属性

@table @code
@item progmem
@cindex @code{progmem} variable attribute, AVR
@code{progmem}属性は、AVRで読み取り専用データを不揮発性プログラムメモリ（フラッシュ）に配置するために使用される。 @code{progmem}属性は、それぞれの変数を@code{.progmem}で始まるセクションに入れることでこれを実現する。

この属性は@code {section}属性と同様の働きをするが、追加のチェックを追加する。

@table @asis
@item @bullet{}@tie{} 32個の汎用レジスタを持つ通常のAVRコア：
@code{progmem}はデータの場所に影響するが、このデータへのアクセス方法には影響しない。 @code{progmem}属性のデータを読み込むために（インライン）アセンブラを使用する必要がある。
@smallexample
/* Use custom macros from @w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC}} */
#include <avr/pgmspace.h> 

/* Locate var in flash memory */
const int var[2] PROGMEM = @{ 1, 2 @};

int read_var (int i)
@{
    /* Access var[] by accessor macro from avr/pgmspace.h */
    return (int) pgm_read_word (& var[i]);
@}
@end smallexample

AVRはハーバードアーキテクチャのプロセッサであり、データおよびリードオンリーデータは通常、データメモリ（RAM）に常駐する。

フラッシュメモリ内のデータを検索してアクセスする別の方法については、@ref{AVR Named Address Spaces}セクションを参照せよ。

@item @bullet{}@tie{} RAMアドレス範囲でフラッシュメモリが可視なAVRコア
このようなデバイスでは、@code{progmem}属性や@ref{AVR Named Address Spaces,,@code{__flash}}修飾子はまったく必要ない。標準C/C++を使用すること。 コンパイラは@code{LD*}命令を生成する。 フラッシュメモリはRAMアドレス範囲に表示され、デフォルトのリンカスクリプトはRAM内の@code{.rodata}を検索@emph{しない}ため、読み取り専用データ用にRAMを無駄にしたり、フラッシュから読み込まないように特別な機能は必要ない。 @code{progmem}と@code{__flash}を避けることで、パフォーマンスが少し向上するかもしれない。 これは@code{avrtiny}と@code{avrxmega3}ファミリのデバイスに適用される。詳細については、@ref{AVR Options}を参照せよ。

@item @bullet{}@tie{}AVRの削減ATtiny40のような小型コア：
コンパイラは、@code{0x4000}を@code {progmem}のオブジェクトと宣言のアドレスに追加し、オブジェクトをフラッシュメモリ、つまりセクション@code{.progmem.data}に配置する。フラッシュメモリがアドレス@code{0x4000}から始まるRAMアドレス空間に表示されるので、オフセットが必要である。

@code{progmem}のデータは、通常のCコードでアクセスすることができる。特殊な関数やマクロは必要ない。

@smallexample
/* var is located in flash memory */
extern const int var[2] __attribute__((progmem));

int read_var (int i)
@{
    return var[i];
@}
@end smallexample

これらのデバイスでは、@code{progmem}はまったく必要ないことに注意すること。 

@end table

@item io
@itemx io (@var{addr})
@cindex @code{io} variable attribute, AVR
@code{io}属性を持つ変数は、ioアドレス範囲内のメモリマップされたペリフェラルに対処するために使用される。アドレスが指定されている場合、変数にはそのアドレスが割り当てられ、その値はデータアドレス空間のアドレスとして解釈される。例：

@smallexample
volatile int porta __attribute__((io (0x22)));
@end smallexample

データアドレス範囲のアドレスに指定されたアドレス。

それ以外の場合、変数にはアドレスは割り当てられないが、コンパイラは適用可能な場合にイン/アウト命令を使用し、他の一部のモジュールがアドレス範囲内のアドレスを割り当てると仮定する。 例：

@smallexample
extern volatile int porta __attribute__((io));
@end smallexample

@item io_low
@itemx io_low (@var{addr})
@cindex @code{io_low} variable attribute, AVR
これは@code{io}属性と似ているが、オブジェクトがI/O領域の下半分にあることをコンパイラに通知し、@code {cbi}、@code{sbi}、@code{sbic}命令と@code {sbis}命令の使用を可能とする。

@item address
@itemx address (@var{addr})
@cindex @code{address} variable attribute, AVR
@code {address}属性を持つ変数は、ioアドレス範囲外にある可能性があるメモリマップされた周辺機器に対処するために使用される。

@smallexample
volatile int porta __attribute__((address (0x600)));
@end smallexample

@item absdata
@cindex @code{absdata} variable attribute, AVR
静的記憶域の変数と@code{absdata}属性の変数は、絶対アドレスを取る@code{LDS}命令と@code{STS}命令でアクセスできる。

@itemize @bullet
@item
この属性は、ATtiny40のような縮小AVR Tinyコアでのみサポートされている。

@item
それぞれのデータが、@code {0x40} @dots{} @code{0xbf}の@code{LDS}と@code{STS}のアドレス範囲にあることを確認する必要がある。これを実現する1つの方法は、適切なリンカー記述ファイルである。

@item
場所が@code {LDS}と@code {STS}のアドレス範囲に合っていない場合、現在のところ（Binutils 2.26）以下のような不特定の警告がある。
@quotation
@code{module.c:(.text+0x1c): warning: internal error: out of range error}
@end quotation

@end itemize

@option{-mabsdata} @ref{AVR Options,command-line option}も参照。

@end table

@node Blackfin Variable Attributes
@subsection Blackfin変数属性

現在、Blackfinには3つの属性が定義されている。

@table @code
@item l1_data
@itemx l1_data_A
@itemx l1_data_B
@cindex @code{l1_data} variable attribute, Blackfin
@cindex @code{l1_data_A} variable attribute, Blackfin
@cindex @code{l1_data_B} variable attribute, Blackfin
これらの属性をBlackfinで使用して、変数をL1データSRAMに配置する。@code{l1_data}属性の変数は、@code{.l1.data}という特定のセクションに配置される。@code{l1_data_A}属性を持つものは、@code{.l1.data.A}という特定のセクションに置かれる。@code{l1_data_B}属性を持つものは、@code{.l1.data.B}という特定のセクションに置かれる。

@item l2
@cindex @code{l2} variable attribute, Blackfin
この属性をBlackfinで使用して、変数をL2 SRAMに配置する。@code{l2}属性の変数は、@code{.l2.data}という特定のセクションに配置される。
@end table

@node H8/300 Variable Attributes
@subsection H8/300変数属性

これらの変数属性は、H8 / 300ターゲットで使用できる。

@table @code
@item eightbit_data
@cindex @code{eightbit_data} variable attribute, H8/300
@cindex eight-bit data on the H8/300, H8/300H, and H8S
H8/300、H8/300H、およびH8Sでこの属性を使用して、指定された変数を8ビットデータセクションに配置する必要があることを示す。コンパイラは、8ビットデータ領域内のデータに対する特定の操作に対してより効率的なコードを生成する。 8ビットのデータ領域は256バイトのデータに制限されていることに注意せよ。

この属性が正しく機能するには、GNU binutilsバージョン2.7以降のGASおよびGLDを使用する必要がある。

@item tiny_data
@cindex @code{tiny_data} variable attribute, H8/300
@cindex tiny data section on the H8/300H and H8S
H8/300HおよびH8Sでは、この属性を使用して、指定された変数を小さなデータセクションに配置する必要があることを示す。コンパイラは、小さなデータセクションのデータの読み込みと格納のために、より効率的なコードを生成する。 小さなデータ領域はわずか32KB未満のデータに限定されている。

@end table

@node IA-64 Variable Attributes
@subsection IA-64変数属性

IA-64バックエンドは、次の変数属性をサポートしている。

@table @code
@item model (@var{model-name})
@cindex @code{model} variable attribute, IA-64
IA-64では、この属性を使用してオブジェクトのアドレス可能性を設定する。現在のところ、@var{model-name}のサポートされている識別子は@code{small}であり、「小さい」（22ビット）アドレスによるアドレス指定可能性を示している（アドレスに@code{add }命令）。 注意：そのようなアドレッシングは定義上の位置独立性ではないため、この属性は共有ライブラリによって定義されたオブジェクトに使用されてはならない。

@end table

@node M32R/D Variable Attributes
@subsection M32R/D変数属性

1つの属性が現在M32R / Dに対して定義されている。

@table @code
@item model (@var{model-name})
@cindex @code{model-name} variable attribute, M32R/D
@cindex variable addressability on the M32R/D
M32R/Dでオブジェクトのアドレス可能性を設定するには、この属性を使用する。識別子@var{model-name}は、各コードモデルを表す@code{small}、@ code{medium}、または@code{large}のいずれかである。

小さなモデルオブジェクトは、メモリの下位16MBに存在する（そのため、アドレスは@code{ld24}命令でロードできる）。

中規模および大規模モデルオブジェクトは、32ビットアドレス空間のどこにでも置くことができる（コンパイラは、アドレスをロードするための@code{seth/add3}命令を生成する）。
@end table

@node MeP Variable Attributes
@subsection MeP変数属性

MePターゲットにはいくつかのアドレッシングモードとバスがある。@code{near}空間は、標準メモリ空間の最初の16メガバイト（24ビット）に及んでいる。 @code{far}空間は32ビットメモリ空間全体に広がる。@code{based}空間は、メモリ空間の128バイトの領域で、@code{$tp}レジスタに相対してアドレス指定される。@code{tiny}空間は、@code{$gp}レジスタを基準にして65536バイトの領域である。これらのメモリ領域に加えて、MePターゲットには@code{cb}属性で指定された別個の16ビット制御バスがある。

@table @code

@item based
@cindex @code{based} variable attribute, MeP
@code{based}属性を持つ変数は@code{.based}セクションに割り当てられ、@code{$tp}レジスタ相対でアクセスされる。

@item tiny
@cindex @code{tiny} variable attribute, MeP
同様に、@code{tiny}属性は@code{.tiny}セクションに変数を割り当て、@code{$gp}レジスタ相対である。

@item near
@cindex @code{near} variable attribute, MeP
@code{near}属性を持つ変数は、24ビットアドレッシングモードに適合するアドレスを持つとみなされる。 これは大きな変数（@code{-mtiny=4}がデフォルト）のデフォルトだが、この属性は小さな変数の場合は@code{-mtiny=}を上書きするか、さもなくば@code{-ml}を上書きすることができる。

@item far
@cindex @code{far} variable attribute, MeP
@code{far}属性を持つ変数は、完全な32ビットアドレスを使用してアドレス指定される。 これはメモリ空間全体をカバーするので、モジュールは変数がどこに格納されるかについて何の仮定もしない。

@item io
@cindex @code{io} variable attribute, MeP
@itemx io (@var{addr})
@code{io}属性の変数は、メモリマップされた周辺機器のアドレス指定に使用される。 アドレスが指定されていれば、変数はそのアドレスに割り当てられる。そうでなければ、アドレスに割り当てられない（他のモジュールがアドレスを割り当てると仮定する）。 例：

@smallexample
int timer_count __attribute__((io(0x123)));
@end smallexample

@item cb
@itemx cb (@var{addr})
@cindex @code{cb} variable attribute, MeP
@code{cb}属性の変数は、特別な指示を使用してコントロールバスにアクセスするために使用される。 @code{addr}はコントロールバスのアドレスを示す。 例：

@smallexample
int cpu_clock __attribute__((cb(0x123)));
@end smallexample

@end table

@node Microsoft Windows Variable Attributes
@subsection Microsoft Windows変数属性

これらの属性をMicrosoft Windowsターゲットで使用できる。 @ref{x86 Variable Attributes}は、すべてのx86ターゲットで使用可能な追加のWindows互換性属性である。

@table @code
@item dllimport
@itemx dllexport
@cindex @code{dllimport} variable attribute
@cindex @code{dllexport} variable attribute
@code {dllimport}属性と@code {dllexport}属性については、@ref{Microsoft Windows Function Attributes}。

@item selectany
@cindex @code{selectany} variable attribute
@code{selectany}属性は、初期化されたグローバル変数にリンク時セマンティクスを持たせる。 変数の複数の定義にリンカーが遭遇すると、最初のものが選択され、残りは破棄される。 Microsoftコンパイラによる使用に続いて、リンカは複数の定義のサイズや内容の違いについて警告@emph{しない}と伝える。

この属性の主な用途はPOD型のためだが、属性はコンストラクタによって初期化されるグローバルC++オブジェクトにも適用できる。 この場合、オブジェクトの静的初期化コードおよび破棄コードがオブジェクトを定義する各変換で発行されるが、コンストラクタおよびデストラクタへの呼び出しはリンク時ガード変数によって保護される。

@code{selectany}属性は、Microsoft Windowsターゲットでのみ使用できる。 他のコンパイラとの互換性のため、@code{__declspec(selectany)}を@code {__attribute__((selectany))}の同義語として使うことができる。

@item shared
@cindex @code{shared} variable attribute
Microsoft Windowsでは、名前付きセクションに変数定義を追加するだけでなく、実行可能ファイルまたはDLLのすべての実行中のコピーでセクションを共有することもできる。 たとえば、この小さなプログラムは、共有データを名前付きセクション@code{shared}に入れ、共有可能セクションにマークを付けることで定義する。

@smallexample
int foo __attribute__((section ("shared"), shared)) = 0;

int
main()
@{
  /* @r{Read and write foo.  All running
     copies see the same value.}  */
  return 0;
@}
@end smallexample

@noindent
@code{section}属性とともに@code{shared}属性と、完全に初期化されたグローバル定義のみを使うことができるのは、リンカの仕組みに由来する。 詳細については、@code{section}属性を参照せよ。

@code{shared}属性はMicrosoft Windowsでのみ利用可能である。

@end table

@node MSP430 Variable Attributes
@subsection MSP430変数属性

@table @code
@item noinit
@cindex @code{noinit} variable attribute, MSP430 
@code{noinit}属性を持つデータは、Cランタイムスタートアップコードまたはプログラムローダーによって初期化されない。 このようにデータを初期化しないと、プログラムの起動時間を短縮できる。

@item persistent
@cindex @code{persistent} variable attribute, MSP430 
@code{persistent}属性を持つ変数は、Cランタイムスタートアップコードによって初期化されない。 代わりに、その値は、アプリケーションがロードされると一度設定され、プロセッサがリセットされたりプログラムが再起動しても、再び初期化されることはない。 永続的なデータはFLASH RAMに配置されることを意図しており、その値はリセット時に保持される。 アプリケーションを作成するために使用されるリンカースクリプトは、永続データが正しく配置されるようにする必要がある。

@item lower
@itemx upper
@itemx either
@cindex @code{lower} variable attribute, MSP430 
@cindex @code{upper} variable attribute, MSP430 
@cindex @code{either} variable attribute, MSP430 
これらの属性は、同じ名前のMSP430関数属性と同じである（@pxref{MSP430 Function Attributes}）。これらの属性は、関数と変数の両方に適用できる。
@end table

@node Nvidia PTX Variable Attributes
@subsection Nvidia PTX変数属性

これらの変数属性は、Nvidia PTXバックエンドによってサポートされている。

@table @code
@item shared
@cindex @code{shared} attribute, Nvidia PTX
この属性を使用して変数を@code{.shared}メモリ空間に配置する。このメモリ空間は、協調スレッド配列ごとにプライベートである。 1つのスレッドブロック内のスレッドのみが変数の同じインスタンスを参照する。ランタイムは、このメモリ空間内の変数を初期化しない。
@end table

@node PowerPC Variable Attributes
@subsection PowerPC変数属性

PowerPC設定では、@code{altivec}、@code{ms_struct}、@code{gcc_struct}という3つの属性が定義されている。

@cindex @code{ms_struct} variable attribute, PowerPC
@cindex @code{gcc_struct} variable attribute, PowerPC
構造体の属性の詳細は@ref{x86 Variable Attributes}のドキュメントを参照せよ。

@cindex @code{altivec} variable attribute, PowerPC
@code {altivec}属性のドキュメントについては、@ref{PowerPC Type Attributes}のドキュメントを参照せよ。

@node RL78 Variable Attributes
@subsection RL78変数属性

@cindex @code{saddr} variable attribute, RL78
RL78バックエンドは@code{saddr}変数属性をサポートしている。 これは、対応する変数のSADDR領域への配置を指定する。これで、デフォルトのメモリ領域より効率的にアクセスできる。

@node SPU Variable Attributes
@subsection SPU変数属性

@cindex @code{spu_vector} variable attribute, SPU
SPUは変数の@code {spu_vector}属性をサポートしている。 この属性のドキュメントについては、@ref{SPU Type Attributes}.

@node V850 Variable Attributes
@subsection V850変数属性

これらの可変属性は、V850バックエンドによってサポートされている。

@table @code

@item sda
@cindex @code{sda} variable attribute, V850
この属性を使用して、64 KBまで保持できる小さなデータ領域に明示的に変数を配置する。

@item tda
@cindex @code{tda} variable attribute, V850
この属性を使用して、変数を明示的に非常に小さなデータ領域に配置する。これは合計で最大256バイトまで保持できる。

@item zda
@cindex @code{zda} variable attribute, V850
この属性を使用して、最初の32キロバイトのメモリに変数を明示的に配置する。
@end table

@node x86 Variable Attributes
@subsection x86変数属性

現在のところ、x86構成では、@code{ms_struct}と@code{gcc_struct}という2つの属性が定義されている。

@table @code
@item ms_struct
@itemx gcc_struct
@cindex @code{ms_struct} variable attribute, x86
@cindex @code{gcc_struct} variable attribute, x86

構造体で@code{packed}が使用されている場合、またはビットフィールドが使用されている場合は、Microsoft ABIがGCCの通常の方法とは異なる構造をレイアウトしている可能性がある。 特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラ（関数呼び出しまたはファイル内のデータ）の間でパックされたデータを移動する場合は、どちらの形式にもアクセスする必要がある。

@code{ms_struct}属性と@code{gcc_struct}属性は、それぞれコマンドラインオプション@option{-mms-bitfields}と@option{-mno-ms-bitfields}に対応する。 構造体レイアウトの影響の詳細については、@ref{x86 Options}を参照せよ。型の対応する属性については、@xref{x86 Type Attributes}を参照せよ。

@end table

@node Xstormy16 Variable Attributes
@subsection Xstormy16変数属性

現在、xstormy16構成に対して1つの属性が定義されている。@code{below100}.

@table @code
@item below100
@cindex @code{below100} variable attribute, Xstormy16
変数に@code {below100}属性（@code{BELOW100}も許可されている）がある場合、GCCは変数を最初の0x100バイトのメモリに置き、特殊なオペコードを使用してアクセスする。 このような変数は、@code{.bss_below100}セクションまたは@code{.data_below100}セクションに置かれる。

@end table

@node Type Attributes
@section 型の属性を指定する
@cindex attribute of types
@cindex type attributes

キーワード@code {__attribute__}を使用すると、型の特殊属性を指定できる。 ある型の属性は@code{struct}型と@code{union}型にのみ適用されるが、その他の型は@code{typedef}宣言で定義された型に適用できる。 他の属性は関数（@pxref{Function Attributes}）、ラベル（@pxref{Label Attributes}）、列挙子（@pxref{Enumerator Attributes}）、文（@pxref{Statement Attributes}）、変数@pxref{Variable Attributes}）に定義されている。

@code{__attribute__}キーワードの後ろには二重括弧で囲まれた属性指定が続く。

@code{struct}、@code{union}、@code{enum}キーワードの直後に置くことで、型属性をenum、struct、または共用体の型宣言または定義に指定することができる。 あまり推奨されない構文は、それらを定義の最後の中括弧の直前に置くことである。

型属性を@code{typedef}宣言に含めることもできる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。

@menu
* Common Type Attributes::
* ARC Type Attributes::
* ARM Type Attributes::
* MeP Type Attributes::
* PowerPC Type Attributes::
* SPU Type Attributes::
* x86 Type Attributes::
@end menu

@node Common Type Attributes
@subsection 共通型属性

ほとんどのターゲットでは、次のタイプ属性がサポートされている。

@table @code
@cindex @code{aligned} type attribute
@item aligned (@var{alignment})
この属性は、指定された型の変数の最小整列（バイト単位）を指定する。 たとえば、次の宣言があると。

@smallexample
struct S @{ short f[3]; @} __attribute__ ((aligned (8)));
typedef int more_aligned_int __attribute__ ((aligned (8)));
@end smallexample

@noindent
@code{struct S}または@code {more_aligned_int}の各変数が@emph{少なくとも}8バイト境界に割り当てられていることをコンパイラーに（可能な限り）保証させる。SPARCでは、@code{struct S}型の変数をすべて8バイトの境界に揃えておくと、 @code {struct S}型の変数を別のものにコピーするときに、コンパイラは@code {ldd}と@code{std}（ダブルワードのロードとストア）命令を使用して、実行時の効率が向上する。

@code {struct}型や@code {union}型のアライメントは、ISO C標準では、少なくとも問題の@code{struct}または@code{union}のすべてのメンバーのアライメントの最低公倍数の完全な倍数であることが要求されることに注意せよ。つまり、@code{aligned}属性をそのような型のメンバのいずれかに付加することによって、@code {struct}型または@code{union}型の整列を効果的に調整することができるが、 上の例では、コンパイラに@code{struct}型または@code{union}型全体のアライメントを調整するように要求する、より明白で直感的で読みやすい方法を示している。

前の例と同様に、コンパイラが指定された@code{struct}型または@code{union}型に対して使用する整列（バイト単位）を明示的に指定することができる。 あるいは、アラインメント係数を省略して、コンパイルするターゲットマシンの最大の有効なアライメントにタイプを合わせるようにコンパイラーに依頼することもできる。 たとえば、次のように書くことができる。

@smallexample
struct S @{ short f[3]; @} __attribute__ ((aligned));
@end smallexample

アラインメント係数を@code{aligned}属性指定で除外すると、コンパイラは自動的にそのタイプのアライメントを、コンパイルするターゲットマシンの任意のデータ型に使用された最大のアライメントに設定する。コンパイラは、このように整列した型を持つ変数との間でコピーを実行するときに、最大のメモリチャンクをコピーする命令を使用できるため、コピー操作をより効率的にすることができる。

上記の例では、各@code{short}のサイズが2バイトの場合、@code{struct S}タイプ全体のサイズは6バイトである。 2以上の最小の累乗は8以上であるため、コンパイラは@code{struct S}型全体のアラインメントを8バイトに設定する。

特定の型に対して時間効率の良いアライメントを選択し、その型の個々のスタンドアロンオブジェクトのみを宣言するようにコンパイラに依頼することはできるが、コンパイラの時間効率的な配置を選択する機能は、関連する（効率的に配置された）タイプの変数の配列を作成する予定がある場合にのみ、主に有効である。効率的に整列された型の変数の配列を宣言または使用すると、プログラムは関連する型へのポインタに対してポインタ算術（または同じものになる添え字付け）も行うが、コンパイラがこれらのポインタ算術演算用に生成するコードは、他の型より効率的に配置された型の方が効率がよいことがよくある。

@code{aligned}属性の有効性は、リンカの固有の制限によって制限されることに注意せよ。 多くのシステムでは、リンカは、変数が特定の最大整列まで整列するようにのみ調整することができる。 （一部のリンカでは、サポートされている最大のアラインメントは非常に小さいかもしれない）。リンカが変数を最大8バイトのアラインメントまでしかアライメントできない場合、@code{aligned(16)}を@code {__attribute__}に指定しても8バイトのアラインメントしか得られない。 詳細については、リンカのマニュアルを参照せよ。

@code {aligned}属性はアラインメントを増加させるだけである。 @code {packed}属性を指定することで、アラインメントを減らすことができる。 下記参照。

@cindex @code{warn_if_not_aligned} type attribute
@item warn_if_not_aligned (@var{alignment})
This attribute specifies a threshold for the structure field, measured
in bytes.  If the structure field is aligned below the threshold, a
warning will be issued.  For example, the declaration:

@smallexample
typedef unsigned long long __u64
   __attribute__((aligned(4),warn_if_not_aligned(8)));

struct foo
@{
  int i1;
  int i2;
  __u64 x;
@};
@end smallexample

@noindent
causes the compiler to issue an warning on @code{struct foo}, like
@samp{warning: alignment 4 of 'struct foo' is less than 8}.
It is used to define @code{struct foo} in such a way that
@code{struct foo} has the same layout and the structure field @code{x}
has the same alignment when @code{__u64} is aligned at either 4 or
8 bytes.  Align @code{struct foo} to 8 bytes:

@smallexample
struct foo
@{
  int i1;
  int i2;
  __u64 x;
@} __attribute__((aligned(8)));
@end smallexample

@noindent
silences the warning.  The compiler also issues a warning, like
@samp{warning: 'x' offset 12 in 'struct foo' isn't aligned to 8},
when the structure field has the misaligned offset:

@smallexample
struct foo
@{
  int i1;
  int i2;
  int i3;
  __u64 x;
@} __attribute__((aligned(8)));
@end smallexample

This warning can be disabled by @option{-Wno-if-not-aligned}.

@item bnd_variable_size
@cindex @code{bnd_variable_size} type attribute
@cindex Pointer Bounds Checker attributes
構造体フィールドに適用されるとき、この属性はポインタの境界チェッカーに、このフィールドのサイズを静的型情報を使用して計算すべきではないことを伝える。 これは、構造体の終わりに配置された可変サイズの静的配列フィールドをマークするために使用される。

@smallexample
struct S
@{
  int size;
  char data[1];
@}
S *p = (S *)malloc (sizeof(S) + 100);
p->data[10] = 0; //Bounds violation
@end smallexample

@noindent
フィールドの属性を使用することにより、望ましくない拘束違反チェックを避けることができる：

@smallexample
struct S
@{
  int size;
  char data[1] __attribute__((bnd_variable_size));
@}
S *p = (S *)malloc (sizeof(S) + 100);
p->data[10] = 0; //OK
@end smallexample

@item deprecated
@itemx deprecated (@var{msg})
@cindex @code{deprecated} type attribute
@code{deprecated}属性は、型がソースファイルのどこでも使用されている場合、警告を出す。 これは、将来のバージョンのプログラムで削除されることが予想される型を識別する場合に便利である。可能であれば、警告には非推奨型の宣言の場所も含まれているため、ユーザーはその型が推奨されない理由やその代わりに何をすべきかに関する情報を簡単に見つけることができる。警告は使用時にのみ発生し、その型自体が非推奨として宣言されていない識別子に適用されている場合に限り発生することに注意せよ。

@smallexample
typedef int T1 __attribute__ ((deprecated));
T1 x;
typedef T1 T2;
T2 y;
typedef T1 T3 __attribute__ ((deprecated));
T3 z __attribute__ ((deprecated));
@end smallexample

@noindent
2行目と3行目には警告が表示されるが、4行目、5行目、または6行目には警告は表示されない。T2は明示的に推奨されていないため、4行目には警告は発行されない。 T3は明示的に推奨されていないため、5行目に警告はない。６行目も同様である。 文字列でなければならないオプションの@var{msg}引数は、警告が表示されている場合に出力される。

@code {deprecated}属性は、関数や変数にも使用できる。 (@pxref{Function Attributes}, @pxref{Variable Attributes})

@item designated_init
@cindex @code{designated_init} type attribute
この属性は構造体型にのみ適用できる。 このタイプのオブジェクトの初期化では、位置初期化子ではなく、指示子付き初期化子を使用する必要があることを示している。 この属性の目的は、構造体のレイアウトが変更される可能性があることを、したがって位置の初期化に依存すると将来の破損が生じる可能性があることをプログラマが示すことができるようにすることである。

GCCはデフォルトでこの属性に基づいて警告を出す。 @option{-Wno-designated-init}を使用してそれらを抑制できる。

@item may_alias
@cindex @code{may_alias} type attribute
この属性を持つ型へのポインタによるアクセスは、型に基づくエイリアス解析の対象ではないが、代わりに他の型のオブジェクトのエイリアスが可能であると想定される。 C99標準の第6.5節第7項の文脈では、そのようなポインタを逆参照する左辺式は、文字型のように扱われる。 エイリアスの問題の詳細については、@option{-fstrict-aliasing}を参照せよ。 この拡張は、あるベクトル型へのポインタが別のベクトル型へのポインタの別名付けを許可されているいくつかのベクトルAPIをサポートするために存在する。

この属性を持つ型のオブジェクトは特別なセマンティクスを持たないことに注意せよ。

使用の例：

@smallexample
typedef short __attribute__((__may_alias__)) short_a;

int
main (void)
@{
  int a = 0x12345678;
  short_a *b = (short_a *) &a;

  b[1] = 0;

  if (a == 0x12345678)
    abort();

  exit(0);
@}
@end smallexample

@noindent
変数宣言で@code{short_a}を@code{short}に置き換えた場合、@option{-O2}以上でデフォルトでオンになる@option{-fstrict-aliasing}でコンパイルすると、上記のプログラムは強制終了するだろう。

@item packed
@cindex @code{packed} type attribute
@code{struct}型または@code {union}型定義に添付されているこの属性は、構造体または共用体の各メンバ（ゼロ幅のビットフィールド以外）が必要なメモリを最小限に抑えるように配置されることを指定する。 @code{enum}定義に付けると、最小の整数型を使用する必要があることを示す。

@opindex fshort-enums
@code{struct}型と@code{union}型に@code{packed}属性を指定することは、構造体または共用体の各メンバで@code{packed}属性を指定するのと同じである。 コマンドラインで@option{-fshort-enums}フラグを指定することは、すべての@code{enum}定義で@code{packed}属性を指定するのと同じである。

次の例では、@code {struct my_packed_struct}のメンバーは密接にまとめられているが、@code{s}メンバーの内部レイアウトはパックされていない。そうするためには、@code{struct my_unpacked_struct}もパックする必要がある。

@smallexample
struct my_unpacked_struct
 @{
    char c;
    int i;
 @};

struct __attribute__ ((__packed__)) my_packed_struct
  @{
     char c;
     int  i;
     struct my_unpacked_struct s;
  @};
@end smallexample

列挙型、構造体、共用体を定義していない@code {typedef}ではなく@code{enum}、@code {struct}または@code{union}の定義にのみ@code{packed}属性属性を指定することができる。

@item scalar_storage_order ("@var{endianness}")
@cindex @code{scalar_storage_order} type attribute
@code{union}または@code {struct}にアタッチされている場合、この属性は型のスカラフィールド、およびコンポーネントがスカラーである配列フィールドの格納順序、つまりエンディアンを設定する。 サポートされるエンディアンは@code{big-endian}と@code{little-endian}である。この属性は、それ自身が@code{union}、@code{struct}、またはその構成要素が@code{union}または@code{struct}の配列であるフィールドには影響せず、これらのフィールドは囲むタイプとは異なるスカラー格納順序を持つことができる。

この属性は、揃ったデフォルトのスカラーストレージオーダーを使用するターゲット（幸運なことに、ほとんど）、つまりスカラーをすべてビッグエンディアンまたはリトルエンディアンに格納するターゲットでのみサポートされる。

ターゲットのスカラー格納順序とは逆のスカラ格納順序を持つ型に対しては、追加の制限が適用される。

@itemize
@item 逆スカラー格納順序の@code{union}または@code {struct}のスカラーフィールドのアドレスを取ることは許されず、エラーが発生する。
@item @option{-Wno-scalar-storage-name}が指定されていない限り、構成要素がスカラーである、配列フィールドのアドレスを逆スカラー格納順序の@code{union}または@code {struct}の配列フィールドのアドレスを取ることは許可されるが、警告が生成される。
@item 逆スカラー格納順序の@code {union}または@code {struct}のアドレスを取ることは許可されている。
@end itemize

これらの制約は、スカラーのアドレスまたはスカラーコンポーネントを持つ配列のアドレスが取られたときに記憶順序属性が失われるために存在する。したがって、このアドレスを介して間接的に格納するのは一般的に機能しない。それにもかかわらず、第2の場合は、配列との間でブロックコピーを実行することができる。

さらに、格納順序を切り替えるための型キャストやエイリアシングの使用はサポートされていない。 つまり、指定されたスカラーオブジェクトは、別の記憶順序を割り当てる別の型を通してアクセスすることはできない。

@item transparent_union
@cindex @code{transparent_union} type attribute

@code{union}型定義に添付されているこの属性は、その共用体型を持つ関数パラメータがその関数への呼び出しを特別な方法で扱うことを示す。

まず、透明な共用体型に対応する引数は、共用体内のどの型でもよい。 キャストは必要ない。 また、共用体にポインタ型が含まれている場合、対応する引数にはNULLポインタ定数またはvoidポインタ式を指定できる。 共用体にvoidポインタ型が含まれている場合、対応する引数は任意のポインタ式になる。 共用体メンバ型がポインタの場合、通常のポインタ変換と同様に、参照される型の@code{const}のような修飾子を尊重する必要がある。

第2に、引数は、共用体自体の呼び出し規約ではなく、透明な共用体の最初のメンバーの呼び出し規約を使用して関数に渡される。 共用体のすべてのメンバーは、同じマシン表現を持たなければならない。 この引数が正しく動作するためには、これが必要である。

透明な共用体は、互換性の理由で複数のインタフェースを持つライブラリ関数用に設計されている。 たとえば、@code{wait}関数がPOSIXに準拠するために@code{int *}型の値を受け入れるか、4.1BSDインタフェースに準拠するために@code{union wait *}型の値を受け入れる必要があるとする。 @code{wait}のパラメータが@code{void *}の場合、@code{wait}は両方の種類の引数を受け入れるが、他のポインタ型も受け入れる。 代わりに、@code{<sys/wait.h>}は次のようにインタフェースを定義してもよい：

@smallexample
typedef union __attribute__ ((__transparent_union__))
  @{
    int *__ip;
    union wait *__up;
  @} wait_status_ptr_t;

pid_t wait (wait_status_ptr_t);
@end smallexample

@noindent
このインタフェースでは、@code{int *}呼び出し規約を使用して、@code{int *}または@code{union wait *}引数を渡すことができる。 プログラムはどちらの型の引数でも@code{wait}を呼び出すことができる：

@smallexample
int w1 () @{ int w; return wait (&w); @}
int w2 () @{ union wait w; return wait (&w); @}
@end smallexample

@noindent
このインタフェースでは、@code{wait}の実装は次のようになる。

@smallexample
pid_t wait (wait_status_ptr_t p)
@{
  return waitpid (-1, p.__ip, 0);
@}
@end smallexample

@item unused
@cindex @code{unused} type attribute
型（@code{union}や@code{struct}を含む）に接続すると、この型の変数は使用されない可能性があることを意味する。 変数が何もしないように見えても、GCCはその型の変数について警告を出さない。 これは通常、定義されて参照されないが、自明ではない簿記機能を持つコンストラクタとデストラクタを含むロッククラスまたはスレッドクラスのケースである。

@item visibility
@cindex @code{visibility} type attribute
C++では、属性の可視性（@pxref {Function Attributes}）はクラス、構造体、共用体、列挙型にも適用できる。 他の型の属性とは異なり、属性は初期キーワードと型の名前の間になければならない。 タイプのボディの後には出現できない。

タイプの可視性は、クラス（vtable、typeinfoノードなど）に関連付けられた曖昧なリンケージエンティティに適用されることに注意せよ。 特に、あるクラスがある共有オブジェクト内で例外としてスローされ、別の共有オブジェクトで捕捉された場合、そのクラスはデフォルトの可視性を持たなければならない。 それ以外の場合は、2つの共有オブジェクトが同じtypeinfoノードを使用できず、例外処理が中断される。

@end table

複数の属性を指定するには、ダブルカッコ内でコンマで区切る。例えば、 @samp{__attribute__ ((aligned (16), packed))}.

@node ARC Type Attributes
@subsection ARC Type Attributes

@cindex @code{uncached} type attribute, ARC
Declaring objects with @code{uncached} allows you to exclude
data-cache participation in load and store operations on those objects
without involving the additional semantic implications of
@code{volatile}.  The @code{.di} instruction suffix is used for all
loads and stores of data declared @code{uncached}.

@node ARM Type Attributes
@subsection ARM型属性

@cindex @code{notshared} type attribute, ARM
@code{dllimport}（Symbian OSなど）をサポートするARMターゲットでは、@code{notshared}属性を使用して、クラスの仮想テーブルやその他の同様のデータをDLLからエクスポートしないことを指定できる。 例えば：

@smallexample
class __declspec(notshared) C @{
public:
  __declspec(dllimport) C();
  virtual void f();
@}

__declspec(dllexport)
C::C() @{@}
@end smallexample

@noindent
このコードでは、@code{C::C}は現在のDLLからエクスポートされるが、@code{C}の仮想テーブルはエクスポートされない。 必要に応じて@code{__declspec}の代わりに@code{__attribute__}を使うことができるが、ほとんどのSymbian OSコードは@code{__declspec}を使用している）。

@node MeP Type Attributes
@subsection MeP型属性

@cindex @code{based} type attribute, MeP
@cindex @code{tiny} type attribute, MeP
@cindex @code{near} type attribute, MeP
@cindex @code{far} type attribute, MeP
MeP変数属性の多くは、型にも適用できる。具体的には、@code{based}、@code{tiny}、@code{near}、@code{far}のいずれかの属性を適用することができる。 @code{io}属性と@code{cb}属性は型には適用されない。

@node PowerPC Type Attributes
@subsection PowerPC型属性

PowerPCの設定では、@code{altivec}、@code{ms_struct}、@code{gcc_struct}という3つの属性が定義されている。

@cindex @code{ms_struct} type attribute, PowerPC
@cindex @code{gcc_struct} type attribute, PowerPC
@code{ms_struct}属性と@code{gcc_struct}属性の詳細については、@ref{x86 Type Attributes}のドキュメントを参照せよ。

@cindex @code{altivec} type attribute, PowerPC
@code{altivec}属性は、AltiVec Programming Interface ManualでサポートされているAltiVecベクタデータ型を宣言することができる。 属性には、@code{vector__}、@code{pixel__}（常にunsigned short）、@code{bool__}（常に符号なし）の3種類のベクトル型のいずれかを指定する引数が必要である。

@smallexample
__attribute__((altivec(vector__)))
__attribute__((altivec(pixel__))) unsigned short
__attribute__((altivec(bool__))) unsigned
@end smallexample

これらの属性は主に、@code{__vector}、@code{__pixel}、@code{__bool}のAltiVecキーワードをサポートすることを意図している。

@node SPU Type Attributes
@subsection SPU型属性

@cindex @code{spu_vector} type attribute, SPU
SPUは型の@code{spu_vector}属性をサポートしている。 この属性を使用すると、ソニー/東芝/IBM SPU言語拡張仕様でサポートされているベクトルデータ型を宣言できる。 @code{__vector}キーワードをサポートすることを意図している。

@node x86 Type Attributes
@subsection x86型属性

現在のところ、x86構成では、@code{ms_struct}と@code{gcc_struct}という2つの属性が定義されている。

@table @code

@item ms_struct
@itemx gcc_struct
@cindex @code{ms_struct} type attribute, x86
@cindex @code{gcc_struct} type attribute, x86

構造体で@code{packed}が使用されている場合、またはビットフィールドが使用されている場合は、Microsoft ABIが通常GCCパックとは異なる方法でパックしている可能性がある。 特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラ（関数呼び出しまたはファイル内のデータ）の間でパックされたデータを移動する場合は、どちらの形式にもアクセスする必要がある。

@code{ms_struct}属性と@code{gcc_struct}属性は、それぞれコマンドラインオプション@option{-mms-bitfields}と@option{-mno-ms-bitfields}に対応する。 構造体レイアウトの影響の詳細については、@ref{x86 Options}を参照せよ。 変数の対応する属性については、@xref{x86 Variable Attributes}を参照せよ。

@end table

@node Label Attributes
@section ラベル属性
@cindex Label Attributes

GCCでは、属性をCラベルに設定できる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。他の属性は、関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、列挙(@pxref{Enumerator Attributes})、文(@pxref{Statement Attributes})、型(@pxref{Type Attributes})である。

この例では、@code{Error}タグのラベル属性を使用して、@code{ErrorHandling}ブランチが実行されにくく、@code{ErrorHandling}ラベルが使用されていないことを示している。

@smallexample

   asm goto ("some asm" : : : : NoError);

/* This branch (the fall-through from the asm) is less commonly used */
ErrorHandling: 
   __attribute__((cold, unused)); /* Semi-colon is required here */
   printf("error\n");
   return 0;

NoError:
   printf("no error\n");
   return 1;
@end smallexample

@table @code
@item unused
@cindex @code{unused} label attribute
この機能は、未使用のラベルを含む可能性があるが、@option {-Wall}でコンパイルされたプログラム生成コードを対象としている。 人間が作成したコードを使用するのは通常は適切ではないが、ラベルにジャンプするコードが@code{#ifdef}条件に含まれる場合に役立つ。

@item hot
@cindex @code{hot} label attribute
ラベルの@code{hot}属性は、ラベルに続くパスが注釈されていないパスよりも可能性が高いことをコンパイラに通知するために使用される。 この属性は、@code{__builtin_expect}が使用できない場合、たとえば計算gotoまたは@code{asm goto}で使用される。

@item cold
@cindex @code{cold} label attribute
ラベルの@code{cold}属性は、ラベルに続くパスが実行される可能性が低いことをコンパイラに通知するために使用される。 この属性は、@code{__builtin_expect}が使用できない場合、たとえば計算gotoまたは@code{asm goto}で使用される。

@end table

@node Enumerator Attributes
@section 列挙属性
@cindex Enumerator Attributes

GCCでは、属性を列挙に設定できる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。他の属性は、関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、ラベル(@pxref{Label Attributes})、文(@pxref{Statement Attributes})、型(@pxref{Type Attributes})である。

この例では、@code{deprecated}列挙子属性を使用して、@code{oldval}列挙子が廃止予定であることを示している。

@smallexample
enum E @{
  oldval __attribute__((deprecated)),
  newval
@};

int
fn (void)
@{
  return oldval;
@}
@end smallexample

@table @code
@item deprecated
@cindex @code{deprecated} enumerator attribute
列挙子がソースファイルのどこで使用されている場合でも、@code{deprecated}属性は警告を出す。 これは、将来のバージョンのプログラムで削除されると予想される列挙子を識別する場合に便利である。 この警告には、廃止された列挙子の宣言の場所も含まれているため、列挙子が廃止された理由やその代わりに何をすべきかに関する情報をユーザーが簡単に見つけることができる。 警告は、使用時にのみ発生することに注意せよ。

@end table

@node Statement Attributes
@section 文属性
@cindex Statement Attributes

GCCでは、属性を空文に設定できる。 属性を使用するための正確な構文の詳細については、@xref{Attribute Syntax}を参照せよ。他の属性は、関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、ラベル(@pxref{Label Attributes})、列挙(@pxref{Enumerator Attributes})、型(@pxref{Type Attributes})である。

この例では、@code{fallthrough}文属性を使用して、@option{-Wimplicit-fallthrough}警告を出力しないことを示している。

@smallexample
switch (cond)
  @{
  case 1:
    bar (1);
    __attribute__((fallthrough));
  case 2:
    @dots{}
  @}
@end smallexample

@table @code
@item fallthrough
@cindex @code{fallthrough} statement attribute
空文を持つ@code{fallthrough}属性はフォールスルー文として機能する。 switchステートメント内の別のcaseラベルまたはユーザー定義ラベルに渡すステートメントは意図的なものであるため、@option{-Wimplicit-fallthrough}警告はトリガーしてはならないことをコンパイラーに示唆している。 フォールスルー属性は、各属性リストに最大で1回しか表示されず、他の属性と混在することはできない。 switchステートメントでのみ使用できる（コンパイラーは別の方法でエラーを出します）。これは、直前の文の後で、論理的に後続するcaseラベルまたはユーザー定義ラベルの前である。

@end table

@node Attribute Syntax
@section 属性構文
@cindex attribute syntax

この節では、C言語の@code{__attribute__}が使用される構文と、属性指定子が結合される構文について説明する。 いくつかの詳細は、C++とObjective-Cで異なる場合がある。 属性の文法の情報が不十分であるため、ここに記載されている一部の書式はすべての場合に正常に解析されないことがある。

C++の属性のセマンティクスにはいくつかの問題がある。 たとえば、コードの生成に影響する可能性があるが、属性のマングリングはない。したがって、属性付きの型をテンプレートやオーバーロードとともに使用すると問題が発生する可能性がある。 同様に、@code{typeid}は属性の異なる型を区別しない。 C++での属性のサポートは、将来は宣言のみの属性に制限されるが、ネストされた宣言子では制限されない。

関数に適用する属性の意味の詳細は@xref{Function Attributes}。変数に適用される属性の意味の詳細は@xref{Variable Attributes}。構造体、共用体、列挙型に適用される属性の意味の詳細は@xref{Type Attributes}。ラベルに適用される属性の意味の詳細は@xref{Label Attributes}。列挙子に適用される属性の意味の詳細は@xref{Enumerator Attributes}。文に適用される属性の意味の詳細は@xref{Statement Attributes}

@dfn{attribute specifier}（属性指定子）は形式@code{__attribute__ ((@var{attribute-list}))}を持つ。@dfn{attribute list}（属性リスト）は@dfn{attributes}のコンマで区切られた空を許容する列であり、それぞれは以下の一つである。

@itemize @bullet
@item
空。空属性は無視される。

@item
属性名。（@code{unused}のような識別子か、@code{const}のような予約後かもしれない）

@item
属性名の後に、属性のパラメータのカッコで囲まれたリストが続く。 これらのパラメータは、次のいずれかの形式をとる。

@itemize @bullet
@item
識別子。例えば、@code{mode}属性はこの形式を持つ。

@item
識別子のあとに、式のコンマで区切られた空でないリストが続く。例えば、@code{format}属性はこの形式を使う。

@item
式の空を許容するコンマ区切りのリスト。例えば、@code{format_arg}属性はこの形式を使用し、リストは単一の整数定数式であり、@code {alias}属性はこのフォームを使用し、リストは単一の文字列定数になる。
@end itemize
@end itemize

@dfn{attribute specifier list}（属性指定子リスト）は、他のトークンで区切られていない、1つ以上の属性指定子の列である。

属性名の前に@samp{__}を付けて属性名を指定することもできる。 これにより、同じ名前の可能性のあるマクロを気にせずにヘッダファイルでそれらを使用することができる。 たとえば、@code {noreturn}ではなく@code{__noreturn__}という属性名を使用できる。

@subsubheading ラベル属性

GNU Cでは、@code{case}や@code{default}ラベル以外のラベルの後にコロンの後に属性指定子リストが現れる。 GNU C++では、属性指定子の直後にセミコロンが続く場合（つまり、空文にラベルが適用される）、ラベルの属性のみが許可される。 セミコロンがない場合、C++のラベル属性はあいまいである。属性リストで始まる宣言がC++でラベル付けされる可能性があるためである。 宣言はC90またはC99ではラベル付けできないため、あいまいさはそこでは発生しない。

@subsubheading 列挙属性

GNU Cでは、属性指定子リストが列挙子の一部として現れるてもよい。属性は列挙定数の後、（存在する場合）@code{=}の前に置かれる。 列挙子のオプションの属性は、列挙定数に属す。 存在する場合、定数式の後に属性を配置することはできない。

@subsubheading 文属性
GNU Cでは、属性指定子リストが空文の一部として現れることができる。 属性はセミコロンの前に置かれる。

@subsubheading 型属性
属性指定子リストは@code{struct}、@code{union}または@code{enum}指定子の一部として現れることができる。 @code{struct}、@code{union}、@code{enum}キーワードの直後、または閉じ括弧の後に置くことができる。 前者の構文が好ましい。属性指定子が閉じ括弧の後に続く場合、それらは構造体、共用体、または列挙型に関連しているとみなされ、型指定子が含まれる囲み宣言には関係せず、定義された型は属性指定子の後まで完全ではない。
@c Otherwise, there would be the following problems: a shift/reduce
@c conflict between attributes binding the struct/union/enum and
@c binding to the list of specifiers/qualifiers; and "aligned"
@c attributes could use sizeof for the structure, but the size could be
@c changed later by "packed" attributes.


@subsubheading 他のすべての属性

それ以外の場合、属性指定子は宣言の一部として現れ、それは名前無しのパラメータと型名、そしてその宣言、及び宣言内の特定の宣言に関連するもの（例えば、パラメータ宣言の場合の用に、他の宣言内で入れ子になっているかもしれない）が含まれる。属性指定子が関数または配列として宣言されたパラメータに適用される場合、そのパラメータは暗黙的に変換されるポインタではなく関数または配列に適用されるが、これはまだ正しく実装されていない。

宣言の先頭にある指定子と修飾子のリストには、そのようなリストに格納クラス指定子が含まれているかどうかにかかわらず、属性指定子を含めることができる。 （ただし、一部の属性は本質的にストレージクラス指定子の性質を持ち、ストレージクラス指定子が使用される場所、たとえば、@code{section}などにのみ意味がある。）この構文には、必要な制限が1つある。関数定義の最初の旧式のパラメータ宣言は、属性指定子で始めることはできない。これは、後述の構文ではなく関数に適用されるためである。 （ただし、このケースはまだ実装されていない。）他の場合では、属性指定子はこの文法では許可されているが、コンパイラではまだサポートされていない。この場所のすべての属性指定子は、宣言全体に関連している。@code{int}の型が型指定子がないことによって暗示される時代遅れの使用法では、そのような指定子と修飾子のリストは、他の指定子や修飾子を持たない属性指定子リストである。

現在、関数プロトタイプの最初のパラメータには、属性指定子ではない型指定子が必要である。 これは@code{void f(int
(__attribute__((foo)) x))}の解釈のあいまいさを解決するが、変更される可能性がある。 現時点では、関数宣言子の括弧に属性のみが含まれている場合、エラーや警告を出すのではなく、int型の単一のパラメータを指定するのでもなく、これらの属性は無視されるが、変更される可能性がある。

属性指定子リストは、指定子と修飾子の単一のリストを使用する複数の識別子の宣言で、宣言子のコンマ区切りリスト内の宣言子（最初のものを除く）の直前に現れる。 そのような属性指定子は、その宣言子が出現する前の識別子にのみ適用される。 たとえば、

@smallexample
__attribute__((noreturn)) void d0 (void),
    __attribute__((format(printf, 1, 2))) d1 (const char *, ...),
     d2 (void);
@end smallexample

@noindent
@code{noreturn}属性は宣言されたすべての関数に適用される。 @code{format}属性は@code{d1}にのみ適用される。

属性指定子リストはカンマの直前に現れる。@code{=}またはセミコロンは、関数定義以外の識別子の宣言を終了する。 このような属性指定子は、宣言されたオブジェクトまたは関数に適用される。 オブジェクトまたは関数のアセンブラ名が指定されている場合（@pxref {Asm Labels}）、属性は@code {asm}の指定に従わなければならない。

属性指定子リストは、将来、（古いスタイルのパラメータ宣言または関数本体の前の）関数定義の宣言子の後に現れるようにすることができるかもしれない。

属性指定子は、配列が暗黙的に変換されるポインタにそのような修飾子が適用されるC99構造のパラメータ配列宣言子の@code{[]}の中に現れる型修飾子と混在することができる。 そのような属性指定子は、配列ではなくポインタに適用されるが、現在実装されておらず、無視されている。

属性指定子リストは、ネストされた宣言子の先頭に現れることがある。 現在のところ、この使用法にはいくつかの制限がある。属性は宣言子に正しく適用されますが、ほとんどの個々の属性では、これが意味するセマンティクスは実装されていない。 属性指定子がポインタ宣言子の@code{*}の後にある場合、それらは任意のタイプの修飾子と混在することがある。 以下では、この構文の正式なセマンティクスについて説明する。 ISO C標準の宣言子の正式な仕様に精通している場合は、最も理にかなっている。

（C99の節6.7.5の4節のように）@code {T D1}という宣言があると仮定し、ここで@code{T}には、型@var{Type}（@code {int}など）を指定する宣言指定子が含まれていて、@code {D1}は識別子@var{ident}を含む宣言子である。 属性指定子を含まない派生宣言子の@var{ident}に指定された型は、ISO C標準の場合と同じである。

もし@code{D1}が形式@code{( @var{attribute-specifier-list} D )}を持ち、宣言@code{T D}が@var{idnet}の型「@var{derived-declarator-type-list} @var{Type}」を指定するならば、@code{T D1}は@var{ident}の型「@var{derived-declarator-type-list} @var{attribute-specifier-list} @var{Type}」を指定する。

もし@code{D1}が形式@code{* @var{type-qualifier-and-attribute-specifier-list} D}を持ち、宣言@code{T D}が@var{idnet}の型「@var{derived-declarator-type-list} @var{Type}」を指定するならば、@code{T D1} は@var{ident}の型「@var{Type}への@var{derived-declarator-type-list} @var{type-qualifier-and-attribute-specifier-list}ポインタ」型を指定する。

例えば、

@smallexample
void (__attribute__((noreturn)) ****f) (void);
@end smallexample

@noindent
は「@code{void}を返す返らない関数へのインタへのポインタへのポインタへのポインタ」の型を指定する。別の例として、

@smallexample
char *__attribute__((aligned(8))) *f;
@end smallexample

@noindent
は＠cpde{char}への8バイト境界のポインタへのポインタを指定する。これはほとんどの属性では機能しないことに再び注意すること。 たとえば、上記の@samp{aligned}属性と@samp{noreturn}属性の使用はまだサポートされていない。

ネストされた宣言子の属性を実装していないコンパイラのバージョン用に書かれた既存のコードとの互換性のために、属性の配置にある程度の寛容さが許されている。型にのみ適用される属性が宣言に適用される場合、その宣言の型に適用されるものとして扱われる。宣言にのみ適用される属性が宣言の型に適用される場合、その宣言に適用するものとして扱われる。そして識別子が宣言される直前に属性を配置するコードとの互換性のために、関数の戻り型に適用されるこのような属性は、関数型に適用されるものとして扱われ、配列要素型に適用されるそのような属性は、配列型に適用されるものとして扱われる。関数型にのみ適用される属性が関数型へのポインタ型に適用される場合、それはポインタのターゲット型に適用されるものとして扱われる。そのような属性が関数へのポインタ型ではない関数戻り型に適用された場合、それは関数型に適用するものとして扱われる。

@node Function Prototypes
@section プロトタイプと旧式の関数宣言
@cindex function prototype declarations
@cindex old-style function definitions
@cindex promotion of formal parameters

GNU Cは、ISO Cを拡張して、関数プロトタイプが後の古いスタイルの非プロトタイプ定義を上書きできるようにする。 次の例を考える。

@smallexample
/* @r{Use prototypes unless the compiler is old-fashioned.}  */
#ifdef __STDC__
#define P(x) x
#else
#define P(x) ()
#endif

/* @r{Prototype function declaration.}  */
int isroot P((uid_t));

/* @r{Old-style function definition.}  */
int
isroot (x)   /* @r{??? lossage here ???} */
     uid_t x;
@{
  return x == 0;
@}
@end smallexample

@code {uid_t}型が@code {short}であるとする。 ISO Cでは、旧式の非プロトタイプ定義のサブワード引数が昇格されるため、この例は許可されない。 したがって、この例では、関数定義の引数は実際には@code{int}で、プロトタイプ引数の型@code{short}と一致しない。

このISO Cの制限により、プログラマーは@code{uid_t}型が@code{short}、@code{int}、または@code{long}であるかどうかわからないため、従来のCコンパイラに移植可能なコードを書くのが難しくなる。 したがって、これらのような場合、これらのGNU Cではプロトタイプが古いスタイルの定義を上書きすることができる。 より正確には、GNU Cでは、関数プロトタイプの引数型は、前の型が宣言前の後者の型と同じ場合は、後の旧式の型定義で指定された引数の型を上書きする。 したがって、GNU Cでは、上記の例は次のようになる。

@smallexample
int isroot (uid_t);

int
isroot (uid_t x)
@{
  return x == 0;
@}
@end smallexample

@noindent
GNU C++は古いスタイルの関数定義をサポートしていないので、この拡張は無関係である。

@node C++ Comments
@section C++形式のコメント
@cindex @code{//}
@cindex C++ comments
@cindex comments, C++ style

GNU Cでは、C++スタイルのコメントを使うことができる。コメントは@samp {//}で始まり、行末まで続く。 他の多くのC実装では、このようなコメントが許可されており、1999 C標準に含まれている。 しかし、C99の前にISO Cのバージョンを指定する@option {-std}オプション、または@option{-ansi}（@option{-std = c90}と同等）を指定すると、C++スタイルのコメントは認識されない。

@node Dollar Signs
@section 識別子名でのドル記号
@cindex $
@cindex dollar signs in identifier names
@cindex identifier names, dollar signs in

GNU Cでは、通常、識別子名にドル記号を使用することができる。これは、多くの伝統的なC実装がそのような識別子を許可するためである。ただし、いくつかのターゲット・マシンでは、識別子のドル記号をターゲット・アセンブラーがそれらを許可しないため、サポートされない。

@node Character Escapes
@section 定数での@key{ESC}文字

文字列または文字定数で@samp{\e}というシーケンスを使用すると、ASCII文字@key{ESC}を表すことができる。

@node Alignment
@section 型及び変数のアラインメントの検査
@cindex alignment
@cindex type alignment
@cindex variable alignment

キーワード@code{__alignof__}を使うと、オブジェクトがどのように整列されているか、及び型によって通常必要とされる最小整列について問い合わせることができる。 その構文は@code{sizeof}と同じである。

たとえば、ターゲットマシンが@code {double}値を8バイト境界に揃える必要がある場合、@code {__alignof__(double)}は8である。これは多くのRISCマシンで当てはまる。 より伝統的なマシン設計では、@code{__alignof__(double)}は4または2である。

一部のマシンでは実際にはアラインメントが必要ない。それらは、奇数アドレスであっても任意のデータ型への参照を可能にする。これらのマシンでは、@code{__alignof__}は、GCCがデータ型を与える最小のアライメントを報告する。通常、ターゲットABIが指定する。

@code{__alignof__}のオペランドが型ではなく左辺値の場合、その値は、GCCの@code{__attribute__}拡張子（@pxref{Variable Attributes}）で指定された最小整列を考慮して、その型の必要な整列である 。 たとえば、次の宣言の後に：

@smallexample
struct foo @{ int x; char y; @} foo1;
@end smallexample

@noindent
@code{__alignof__(foo1.y)}の値は、実際の配置がおそらく2または4であっても、@code{__alignof__(int)}と同じ1である。

不完全な型のアライメントを求めるのは誤りである。


@node Inline
@section マクロと同等に速いインライン関数
@cindex inline functions
@cindex integrating function code
@cindex open coding
@cindex macros, inline alternative

関数をインラインで宣言することで、GCCにその関数の呼び出しをより高速にするように指示できる。 GCCがこれを達成できる1つの方法は、その関数のコードを呼び出し元のコードに統合することである。 これにより、関数呼び出しのオーバーヘッドを排除して実行を高速化する。 さらに、実際の引数の値のいずれかが定数である場合、それらの既知の値によって、コンパイル時の簡略化が可能になり、インライン関数のコードのすべてを含める必要はなくなる。 コードサイズへの影響はあまり予測できない。 特定の場合に応じて、関数インライン化によってオブジェクトコードが大きくても小さくなるかもしれない。 また、GCCに対して、@option{-finline-functions}オプションを使用して、すべての「単純な」関数を呼び出し元に統合しようとすることもできる。

GCCは、関数をインラインで宣言するという3つの異なるセマンティクスを実装している。 1つは、@option{-std=gnu89}または@option{-fgnu89-inline}、または@code{gnu_inline}属性がすべてのインライン宣言に存在する場合、もう1つは@option{-fgnu89-inline}を指定せずに@option{-std=c99}、@option{-std=gnu99}またはそれ以降のCバージョンを指定するとき、三番目はC++をコンパイルするときに使用される。

関数をインラインで宣言するには、宣言に次のように@code{inline}キーワードを使用する。

@smallexample
static inline int
inc (int *a)
@{
  return (*a)++;
@}
@end smallexample

ISO C90プログラムにインクルードするヘッダーファイルを作成する場合は、@code{inline}ではなく@code{__inline__}を記述する。@xref{Alternate Keywords}.

3つのタイプのインライン展開は、2つの重要なケースで同様に動作する。上記の例のように@code{static}関数で@code{inline}キーワードを使用するとき、そして以下のように、関数が@code{inline}キーワードを使わずに宣言され、その後@code{inline}で定義されるとき。

@smallexample
extern int inc (int *a);
inline int
inc (int *a)
@{
  return (*a)++;
@}
@end smallexample

これらの一般的な場合の両方で、プログラムは速度以外は@code{inline}キーワードを使用しなかった場合と同じように動作する。

@cindex inline functions, omission of
@opindex fkeep-inline-functions
関数がインラインと@code{static}の両方の場合、関数へのすべての呼び出しが呼び出し側に統合され、関数のアドレスが決して使用されないと、関数自身のアセンブラコードは決して参照されない。この場合、オプション@option{-fkeep-inline-functions}を指定しない限り、GCCは関数のアセンブラコードを実際に出力しない。統合されていない呼び出しがある場合、関数はいつものようにアセンブラコードにコンパイルされる。 インライン化できないため、プログラムがそのアドレスを参照している場合は、通常どおりコンパイルする必要がある。

@opindex Winline
関数定義の特定の用途は、インライン置換には適していないことに注意せよ。 これらの使用法の中には、可変長引数関数、@code{alloca}の使用、計算gotoの使用（@pxref{Labels as Values}）、非局所的なgotoの使用、入れ子関数の使用、@code{setjmp}の使用、 @code{__builtin_longjmp}と@code{__builtin_return}または@code{__builtin_apply_args}の使用。 @option{-Winline}を使用すると、@code{inline}とマークされた関数を代入できなかったときに警告が表示され、失敗の理由が示される。

@cindex automatic @code{inline} for C++ member fns
@cindex @code{inline} automatic for C++ member fns
@cindex member fns, automatically @code{inline}
@cindex C++ member fns, automatically @code{inline}
@opindex fno-default-inline
GCCは、ISO C++の必要条件として、クラスの本体内で定義されたメンバ関数が、@code{inline}キーワードで明示的に宣言されていなくてもインラインでマークされると見なる。 これを@option{-fno-default-inline}で上書きすることができる。 @pxref{C++ Dialect Options,,C++変種を制御するオプション}

GCCは、関数に@samp{always_inline}属性を指定しない限り、最適化していないときに関数をインライン化しない。

@smallexample
/* @r{Prototype.}  */
inline void foo (const char) __attribute__((always_inline));
@end smallexample

このセクションの残りの部分は、GNU C90のインライン展開に特有のものである。

@cindex non-static inline function
インライン関数が@code{static}でない場合、コンパイラは他のソースファイルからの呼び出しがあると想定する必要がある。 グローバルシンボルはどのプログラムでも一度しか定義できないので、関数を他のソースファイルで定義してはいけないので、その中の呼び出しを統合することはできない。 したがって、非@code{static}インライン関数は常に通常の方法でそれ自身でコンパイルされる。

関数定義で@code{inline}と@code{extern}の両方を指定すると、定義はインライン化にのみ使用される。 たとえあなたがそのアドレスを明示的に参照したとしても、関数はそれ自身でコンパイルされることはない。 このようなアドレスは、あたかも関数を宣言していて、定義していないかのように、外部参照になる。

この@code{inline}と@code{extern}の組み合わせは、ほとんどマクロの効果を持つ。 これを使う方法は、これらのキーワードを使ってヘッダファイルに関数定義を置き、ライブラリファイルに定義の別のコピー（@code{inline}と@code{extern}がない）を置くことである。 ヘッダーファイルの定義によって、関数へのほとんどの呼び出しがインライン化される。 関数の使用が残っている場合は、ライブラリ内の単一のコピーを参照する。

@node Volatiles
@section いつvolatileオブジェクトにアクセスするか
@cindex accessing volatiles
@cindex volatile read
@cindex volatile write
@cindex volatile access

Cにはvolatileオブジェクトの概念がある。 これらは通常ポインターによってアクセスされ、ハードウェアまたはスレッド間通信にアクセスするために使用される。 この標準では、コンパイラがvolatileオブジェクトへのアクセスに関する最適化を控えるように勧めているが、何が揮発性のアクセスを構成するかについて実装定義のままとしている。 シーケンスポイントでは、volatileオブジェクトへの以前のすべてのアクセスが安定し、その後のアクセスは発生していないことが最低限必要である。 したがって、実装では、シーケンスポイント間で発生するvolatileアクセスを並べ替えて組み合わせることは自由であるが、シーケンスポイント間のアクセスでは実行できない。 volatileを使用すると、2つのシーケンスポイント間でオブジェクトを複数回更新する際の制限に違反することはできない。

不揮発性オブジェクトへのアクセスは、volatileアクセスに関しては順序付けられていない。 非volatileメモリへの一連の書き込みを順序付けるために、volatileオブジェクトをメモリバリアとして使用することはできない。 例えば：

@smallexample
int *ptr = @var{something};
volatile int vobj;
*ptr = @var{something};
vobj = 1;
@end smallexample

@noindent
@var{*ptr}と@var{vobj}にエイリアスを付けることができない限り、@var{*ptr}への書き込みは、@var{vobj}の更新が発生するまでに発生することは保証されない。 この保証が必要な場合は、次のような強力なメモリバリアを使用する必要がある。

@smallexample
int *ptr = @var{something};
volatile int vobj;
*ptr = @var{something};
asm volatile ("" : : : "memory");
vobj = 1;
@end smallexample

スカラー揮発性オブジェクトは、voidコンテキストでアクセスされると読み込まれる。

@smallexample
volatile int *src = @var{somevalue};
*src;
@end smallexample

このような式は右辺値であり、GCCはこれがvolatileオブジェクトの読み込みとして指し示すものとして実装する。

代入は式でもあり、右辺値を持つ。 ただし、スカラー揮発性に割り当てるときは、代入式の右辺値が使用されているかどうかにかかわらず、volatileオブジェクトは再読み込みされない。 代入の右辺値が使用されている場合、その値はvolatileオブジェクトに割り当てられた値になる。 たとえば、次のすべての場合に@var{vobj}の読み込みはない。

@smallexample
int obj;
volatile int vobj;
vobj = @var{something};
obj = vobj = @var{something};
obj ? vobj = @var{onething} : vobj = @var{anotherthing};
obj = (@var{something}, vobj = @var{anotherthing});
@end smallexample

代入が発生した後にvolatileオブジェクトを読み取る必要がある場合は、介在するシーケンスポイントを持つ別の式を使用する必要がある。

ビットフィールドが個別にアドレス可能ではないので、volatileビットフィールドは、書き込まれるとき、または隣接するビットフィールドがアクセスされるときに暗黙的に読み取られ得る。 ビットフィールド動作は、隣接するビットフィールドが記憶装置の境界をまたぐ場合、部分的にのみアクセスされるように最適化することができる。 これらの理由から、volatileビットフィールドを使用してハードウェアにアクセスすることは賢明ではない。

@node Using Assembly Language with C
@section Cコードでインラインアセンブリ言語を使う方法
@cindex @code{asm} keyword
@cindex assembly language in C
@cindex inline assembly language
@cindex mixing assembly language and C

@code{asm}キーワードを使用すると、Cコード内にアセンブラ命令を埋め込むことができる。 GCCは2つの形式のインライン@code{asm}文を提供する。@dfn{basic @code{asm}}(基本 asm)文はオペランドを持たず (@pxref{Basic Asm})、一方@dfn{extended @code{asm}}(拡張asm)は一つ以上のオペランドを含む。拡張形式は、関数内でC言語とアセンブリ言語を混合する場合に好まれるが、アセンブリ言語を最上位レベルに組み込むには、基本@code{asm}を使用する必要がある。

@code{asm}キーワードを使用して、Cシンボルのアセンブラ名を上書きしたり、C変数を特定のレジスタに配置したりすることもできる。

@menu
* Basic Asm::          オペランドなしのインラインアセンブラ
* Extended Asm::       オペランドのあるインラインアセンブラ
* Constraints::        @code{asm}オペランドの制約
* Asm Labels::         Cシンボル用に使うためのアセンブラの名前を指定する
* Explicit Register Variables::  指定されたレジスタに存在する変数の定義。
* Size of an asm::     GCCが@code{asm}ブロックのサイズを計算する方法。
@end menu

@node Basic Asm
@subsection 基本Asm --- オペランドなしのアセンブラ命令
@cindex basic @code{asm}
@cindex assembly language in C, basic

基本@code{asm}文は以下の構文を持つ。

@example
asm @r{[} volatile @r{]} ( @var{AssemblerInstructions} )
@end example

@code{asm}キーワードはGNU拡張である。@option{-ansi}とさまざまな@option{-std}オプションでコンパイルできるコードを書くときは、@code{asm}の代わりに@code{__asm__}（@pxref {Alternate Keywords}）を使用すること。
(@pxref{Alternate Keywords}).

@subsubheading 限定子
@table @code
@item volatile
オプションの@code{volatile}修飾子は効果がない。すべての基本的な@code{asm}ブロックは暗黙的に揮発性である。
@end table

@subsubheading パラメータ
@table @var

@item AssemblerInstructions（アセンブラ命令）
これは、アセンブラコードを指定するリテラル文字列である。 この文字列には、ディレクティブを含め、アセンブラで認識されるすべての命令を含めることができる。GCCはアセンブラ命令自体を解析せず、それらが何を意味するのか、またそれらが有効なアセンブラ入力であるかを知らない。

1つの@code {asm}文字列に、システムのアセンブリコードで通常使用される文字で区切られた、複数のアセンブラ命令を一緒に配置することができる。 ほとんどの場所で動作する組み合わせは、改行とタブ文字（@samp {\n\t}と書かれる）である。一部のアセンブラではセミコロンを行区切り記号として使用できる。 ただし、アセンブラの方言の中には、セミコロンを使用してコメントを開始するものがある。
@end table

@subsubheading 注意
拡張@code{asm}（@pxref{Extended Asm}）を使うと、通常、より小さく、より安全で、より効率的なコードが生成され、ほとんどの場合、基本@code{asm}より優れた解決策である。 しかし、基本@code{asm}だけが使用できる2つの状況がある：

@itemize @bullet
@item
拡張@code{asm}文はC関数内になければならない。したがって、C関数の外部でファイルスコープ（ 「トップレベル 」）にインラインアセンブリ言語を書くには、基本@code{asm}を使用する必要がある。この手法を使用して、アセンブラディレクティブを発行したり、ファイル内の別の場所で呼び出せるアセンブリ言語マクロを定義したり、アセンブリ言語で関数全体を記述したりすることができる。

@item
@code {naked}属性で宣言された関数も、基本的な@code {asm}を必要とする。(@pxref{Function Attributes}).
@end itemize

基本@code{asm}から安全にCデータにアクセスし、関数を呼び出すことは、見かけよりも複雑である。 Cデータにアクセスするには、拡張@code{asm}を使用する方が良い。

コンパイル後に@code{asm}文のシーケンスが完全に連続しているとは思ってはならない。 特定の命令を連続して出力に残す必要がある場合は、それらを単一のマルチ命令@code{asm}文に入れる。 GCCのオプティマイザは、ジャンプを含めた他のコードと比較して@code{asm}文を移動できることに注意せよ。

@code{asm}文は他の@code {asm}文にジャンプしてはならない。GCCはこれらのジャンプについて知らないため、最適化の方法を決める際には考慮することができない。 @code{asm}からCラベルへのジャンプは、拡張@code{asm}でのみサポートされる。

特定の状況下では、GCCは最適化するときにアセンブリコードを複製（または重複を取り除く）することがある。 アセンブラコードでシンボルまたはラベルが定義されていると、コンパイル時に予期しない重複シンボルエラーが発生する可能性がある。

@strong{警告:} Cの標準は@code{asm}のセマンティクスを指定していないので、コンパイラ間の非互換性の原因となる。 これらの非互換性によって、コンパイラの警告/エラーが発生することはない。

GCCは基本@code{asm}の@var{AssemblerInstructions}を解析しない。つまり、内部で何が起こっているのかをコンパイラに伝える方法がない。 GCCは@code{asm}内のシンボルの可視性を持たず、参照されていないものとして破棄することがある。 また、メモリやレジスタの変更など、アセンブラコードの副作用についても認識しない。 いくつかのコンパイラとは異なり、GCCは汎用レジスタへの変更は起こらないと仮定している。 この仮定は、将来のリリースで変更される可能性がある。

将来のセマンティクスの変更やコンパイラ間の互換性の問題を避けるため、基本@code{asm}を拡張@code{asm}に置き換えることを検討せよ。 この変換の実行方法については、@uref{https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended、基本asmから拡張asmへの変換方法}を参照すること。

コンパイラは、拡張@code{asm}で使用可能な変種や@samp{％}演算子を処理せずに、基本的な@code{asm}のアセンブラ命令をアセンブリ言語出力ファイルにそのままコピーする。 これにより、基本@code{asm}文字列と拡張された@code{asm}テンプレートの間には小さな違いが生じる。 たとえば、レジスタを参照するには、基本@code{asm}では@samp {％eax}を、拡張@code{asm}では@samp{%%eax}を使用する。

複数のアセンブラ変種をサポートするx86などのターゲットでは、すべての基本@code{asm}ブロックが@option{-masm}コマンドラインオプション（@pxref {x86オプション}）で指定されたアセンブラ変種を使用する。基本@code{asm}は、異なる変種に対して異なるアセンブラ文字列を提供する仕組みを提供しない。

GCCは、アセンブラブロックが汎用レジスタを変更しないと仮定するが、グローバルにアクセス可能な変数を読み書きすることができる。

i386の基本的な@code {asm}の例を次に示す。

@example
/* Note that this code will not compile with -masm=intel */
#define DebugBreak() asm("int $3")
@end example

@node Extended Asm
@subsection 拡張Asm - C式オペランドのあるアセンブラ命令
@cindex extended @code{asm}
@cindex assembly language in C, extended

拡張@code{asm}を使用すると、アセンブラからC変数を読み書きし、アセンブラコードからCラベルにジャンプすることができる。拡張@code{asm}構文は、アセンブラテンプレートの後にオペランドパラメータを区切るためにコロン（@samp{:}）を使用する：

@example
asm @r{[}volatile@r{]} ( @var{AssemblerTemplate} 
                 : @var{OutputOperands} 
                 @r{[} : @var{InputOperands}
                 @r{[} : @var{Clobbers} @r{]} @r{]})

asm @r{[}volatile@r{]} goto ( @var{AssemblerTemplate} 
                      : 
                      : @var{InputOperands}
                      : @var{Clobbers}
                      : @var{GotoLabels})
@end example

@code{asm}キーワードはGNU拡張である。@option{-ansi}と様々な@option {-std}オプションでコンパイルできるコードを書くときは、@code{asm}の代わりに@code{__asm__}を使う。 (@pxref{Alternate Keywords}).

@subsubheading 限定子
@table @code

@item volatile
拡張@code{asm}文の典型的な使い方は、入力値を操作して出力値を生成することである。 しかし、@code{asm}文は、副作用も生じる。 その場合は、特定の最適化を無効にするために@code{volatile}修飾子を使用する必要がある。@xref{Volatile}.

@item goto
この修飾子は、@code{asm}文が@var{GotoLabels}にリストされているラベルの1つにジャンプする可能性があることをコンパイラに通知する。@xref{GotoLabels}.
@end table

@subsubheading パラメータ
@table @var
@item AssemblerTemplate
これは、アセンブラコードのテンプレートであるリテラル文字列である。 入力テキスト、出力テキスト、およびgotoパラメータを参照する固定テキストとトークンの組み合わせである。@xref{AssemblerTemplate}.

@item OutputOperands（出力オペランド）
@var{AssemblerTemplate}の命令で変更されたC変数のカンマ区切りのリスト。 空のリストが許可される。@xref{OutputOperands}.

@item InputOperands（入力オペランド）
@var{AssemblerTemplate}の命令で読み取られるC式のカンマ区切りリスト。 空のリストが許可される。@xref{InputOperands}.

@item Clobbers（破壊子）
出力としてリストされたものを覗いた、@var{AssemblerTemplate}によって変更されたレジスタまたはその他の値のコンマ区切りのリスト。空のリストが許可される。@xref{Clobbers and Scratch Registers}.

@item GotoLabels（Gotoラベル）
@code{asm}の@code{goto}形式を使用している場合、このセクションには、@var{AssemblerTemplate}のコードがジャンプする可能性のあるすべてのCラベルのリストが含まれている。
@xref{GotoLabels}.

@code{asm}文は、リストされた@var{GotoLabels}に対してのみジャンプすることができ、他の@code{asm}文にジャンプすることはできない。GCCのオプティマイザは他のジャンプについて知らない。したがって、どのように最適化するかを決めるときに、それらを考慮に入れることはできない。
@end table

入力+出力+ gotoオペランドの合計数は30に制限されている。

@subsubheading 注意
@code{asm}ステートメントを使用すると、Cコード内にアセンブリ命令を直接組み込むことができる。 これは、時間に敏感なコードのパフォーマンスを最大化したり、Cプログラムがすぐに利用できないアセンブリ命令にアクセスするのに役立つ。

拡張@code {asm}文は関数内になければならないことに注意。基本@code{asm}だけが関数の外にあることができる（@pxref {Basic Asm}）。@code{naked}属性で宣言された関数も、基本@code{asm}を必要とする。 (@pxref{Function Attributes}).

@code{asm}の使用方法は多種多様だが、入力パラメータを出力パラメータに変換する一連の低レベル命令として@code{asm}文を考えると役に立つ。なので、@code{asm}を使ったi386のシンプルな（特に有用ではないにしても）例は次のようになる：

@example
int src = 1;
int dst;   

asm ("mov %1, %0\n\t"
    "add $1, %0"
    : "=r" (dst) 
    : "r" (src));

printf("%d\n", dst);
@end example

このコードは@code{src}を@code{dst}にコピーし、1を@code{dst}に追加する。

@anchor{Volatile}
@subsubsection Volatile
@cindex volatile @code{asm}
@cindex @code{asm} volatile
GCCのオプティマイザは、出力変数の必要がないと判断した場合、@code {asm}文を破棄することがある。 また、オプティマイザは、コードが常に同じ結果を返すと考えられる場合（つまり、入力値のいずれも呼び出し間で変化しない場合）、コードをループから移動させる可能性がある。 @code{volatile}修飾子を使用すると、これらの最適化が無効になる。 @code{asm goto}文を含む出力オペランドを持たない@code{asm}文は暗黙的にvolatileである。

このi386コードは、@code{volatile}修飾子を使用しない（または必要とする）ケースを示している。 アサーションチェックを実行している場合、このコードは@code{asm}を使用して検証を実行する。それ以外の場合、@code{dwRes}はどのコードでも参照されない。 結果として、オプティマイザは@code{asm}文を破棄することができ、@code{DoCheck}ルーチン全体が不要になる。@code{volatile}修飾子を省略すると、オプティマイザは可能な限り効率的なコードを生成できる。

@example
void DoCheck(uint32_t dwSomeValue)
@{
   uint32_t dwRes;

   // Assumes dwSomeValue is not zero.
   asm ("bsfl %1,%0"
     : "=r" (dwRes)
     : "r" (dwSomeValue)
     : "cc");

   assert(dwRes > 3);
@}
@end example

次の例は、オプティマイザが関数の実行中に入力（@ code{dwSomeValue}）が決して変化しないことを認識できるので、より効率的なコードを生成するためにループの外側に@code{asm}を移動できる。ここでも、@code{volatile}を使用すると、このタイプの最適化が無効になる。

@example
void do_print(uint32_t dwSomeValue)
@{
   uint32_t dwRes;

   for (uint32_t x=0; x < 5; x++)
   @{
      // Assumes dwSomeValue is not zero.
      asm ("bsfl %1,%0"
        : "=r" (dwRes)
        : "r" (dwSomeValue)
        : "cc");

      printf("%u: %u %u\n", x, dwSomeValue, dwRes);
   @}
@}
@end example

次の例は、@code{volatile}修飾子を使用する必要がある場合を示している。x86の@code{rdtsc}命令を使用して、コンピュータのタイムスタンプカウンタを読み取る。 オプティマイザは、@code{volatile}修飾子を指定しないと、@code{asm}ブロックが常に同じ値を返すと仮定して、2番目の呼び出しを最適化する。

@example
uint64_t msr;

asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
        "shl $32, %%rdx\n\t"  // Shift the upper bits left.
        "or %%rdx, %0"        // 'Or' in the lower bits.
        : "=a" (msr)
        : 
        : "rdx");

printf("msr: %llx\n", msr);

// Do other work...

// Reprint the timestamp
asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
        "shl $32, %%rdx\n\t"  // Shift the upper bits left.
        "or %%rdx, %0"        // 'Or' in the lower bits.
        : "=a" (msr)
        : 
        : "rdx");

printf("msr: %llx\n", msr);
@end example

GCCのオプティマイザは、以前の例ではこのコードを不揮発性コードのように扱っていない。 以前の呼び出しの結果が依然として有効であるという前提で、ループから移動したり、ループを省略することはない。

コンパイラはジャンプ命令全体を含む、他のコードと相対で揮発性の@code {asm}命令も移動させることができる。 たとえば、多くのターゲットでは、浮動小数点演算の丸めモードを制御するシステム・レジスタがある。 揮発性の@code{asm}で設定すると、次のPowerPCの例のように確実に動作しない。

@example
asm volatile("mtfsf 255, %0" : : "f" (fpenv));
sum = x + y;
@end example

コンパイラは、volatile @code{asm}の前に加算を動かすかもしれない。期待通りに動作させるには、後続のコードで変数を参照することで、@code{asm}に人為的な依存関係を追加する。例えば、

@example
asm volatile ("mtfsf 255,%1" : "=X" (sum) : "f" (fpenv));
sum = x + y;
@end example

特定の状況下では、GCCは最適化するときにアセンブリコードを複製（または重複を除去）することがある。 これにより、asmコードでシンボルまたはラベルが定義されていると、コンパイル時に予期しない重複シンボルエラーが発生する可能性がある。@samp{％=}（@pxref {AssemblerTemplate}）を使用すると、この問題を解決できる。

@anchor{AssemblerTemplate}
@subsubsection アセンブラテンプレート
@cindex @code{asm} assembler template

アセンブラテンプレートは、アセンブラ命令を含むリテラル文字列である。コンパイラは、入力、出力、およびgotoラベルを参照するテンプレート内のトークンを置き換え、結果の文字列をアセンブラに出力する。この文字列には、ディレクティブを含め、アセンブラで認識されるすべての命令を含めることができる。GCCはアセンブラ命令自体を解析せず、それらが何を意味するのか、またそれらが有効なアセンブラ入力であるかを知らないが、文は数える。(@pxref{Size of an asm}).

1つの@code{asm}文字列に、システムのアセンブリコードで通常使用される文字で区切られた、複数のアセンブラ命令を一緒に配置することができる。ほとんどの場所で動作する組み合わせは、行を改行する改行と、タブフィールド（@samp{\n \t}と書かれる）に移動するためのタブ文字である。一部のアセンブラではセミコロンを行区切り記号として使用できる。 ただし、アセンブラの方言の中には、セミコロンを使用してコメントを開始するものがある。

@code{volatile}修飾子を使用していても、コンパイル後に一連の@code{asm}文が完全に連続しているとは期待しないこと。特定の命令を連続して出力に残す必要がある場合は、それらを単一のマルチ命令asm文に入れる。

入力/出力オペランドを使用せずに（たとえば、アセンブラテンプレートからグローバルシンボルを使用して）Cプログラムからデータにアクセスすると、期待どおりに動作しないことがある。同様に、アセンブラテンプレートから関数を直接呼び出すには、ターゲットアセンブラとABIの詳細な理解が必要である。

GCCはアセンブラテンプレートを解析しないので、参照するシンボルの可視性はない。 これにより、GCCは、入力、出力、またはgotoオペランドとしてもリストされていない限り、これらのシンボルを参照されないものとして破棄することがある。

@subsubheading 特別なフォーマット文字列

input、output、およびgotoオペランドで記述されたトークンに加えて、これらのトークンはアセンブラテンプレートに特別な意味を持つ。

@table @samp
@item %% 
単一の@samp {％}をアセンブラコードに出力する。

@item %= 
コンパイル全体で@code{asm}文の各インスタンスに固有の番号を出力する。 このオプションは、ローカルラベルを作成し、複数のアセンブラ命令を生成する1つのテンプレートでそれらを複数回参照する場合に便利である。

@item %@{
@itemx %|
@itemx %@}
@samp{@{}、@samp{|}、@samp{@}}文字をそれぞれアセンブラコードに出力する。 エスケープされていない場合、これらの文字は、以下に説明するように、複数のアセンブラ方言を示すために特別な意味を持つ。
@end table

@subsubheading @code{asm}テンプレートでの複数のアセンブラ変種

x86などのターゲットでは、GCCは複数のアセンブラ変種をサポートしている。@option{-masm}オプションは、GCCがインラインアセンブラのデフォルトとして使用するダイアレクトを制御する。 @option{-masm}オプションのターゲット固有のドキュメントには、サポートされている変種のリストと、オプションが指定されていない場合のデフォルトの変種が含まれている。ある方言を使ってコンパイルしたときに正しく動作するアセンブラコードは、別の方言を使ってコンパイルすると失敗する可能性があるため、この情報は理解するのに重要である。@xref{x86 Options}.

コードが複数のアセンブラ変種をサポートする必要がある場合（例えば、さまざまなコンパイルオプションをサポートする必要があるパブリックヘッダを書く場合）、このフォームの構文を使用する：

@example
@{ dialect0 | dialect1 | dialect2... @}
@end example

この構文は、変種＃0を使用してコードをコンパイルするときに@code{dialect0}、変種＃1に@code {dialect1}などを出力する。中括弧内の代替語句がコンパイラがサポートする変種の数より少ない場合、構文は何も出力しない。

たとえば、x86コンパイラが2つの変種（@samp{att}、@samp{intel}）をサポートしている場合、次のようなアセンブラテンプレートは：

@example
"bt@{l %[Offset],%[Base] | %[Base],%[Offset]@}; jc %l2"
@end example

@noindent
以下の一つと等価である

@example
"btl %[Offset],%[Base] ; jc %l2"   @r{/* att dialect */}
"bt %[Base],%[Offset]; jc %l2"     @r{/* intel dialect */}
@end example

同じコンパイラを使用して、このコードは：

@example
"xchg@{l@}\t@{%%@}ebx, %1"
@end example

@noindent
いずれかに対応する

@example
"xchgl\t%%ebx, %1"                 @r{/* att dialect */}
"xchg\tebx, %1"                    @r{/* intel dialect */}
@end example

代替のネストをサポートしていない。

@anchor{OutputOperands}
@subsubsection 出力オペランド
@cindex @code{asm} output operands

@code{asm}文には、アセンブラコードによって変更されたC変数の名前を示す0個以上の出力オペランドがある。

このi386の例では、@code{old}（テンプレート文字列の@code{％0}として参照される）と@code{*Base}（@code{％1}）は出力であり、@code{Offset}（@code {％2}）は入力である：

@example
bool old;

__asm__ ("btsl %2,%1\n\t" // Turn on zero-based bit #Offset in Base.
         "sbb %0,%0"      // Use the CF to calculate old.
   : "=r" (old), "+rm" (*Base)
   : "Ir" (Offset)
   : "cc");

return old;
@end example

オペランドはコンマで区切られます。 各オペランドは次の形式である。

@example
@r{[} [@var{asmSymbolicName}] @r{]} @var{constraint} (@var{cvariablename})
@end example

@table @var
@item asmSymbolicName
オペランドのシンボリック名を指定する。アセンブラテンプレートの名前は、角括弧（@samp{％[Value]}）で囲んで参照する。名前のスコープは、定義を含む@code{asm}ステートメントである。 周囲のコードにすでに定義されている名前を含め、任意の有効なC変数名を使用できる。同じ@code{asm}ステートメント内に2つのオペランドが同じシンボリック名を使用することはできない。

@var{asmSymbolicName}を使用しないときは、アセンブラ・テンプレートのオペランドのリスト内のオペランドの（ゼロからの）位置を使用する。 たとえば、3つの出力オペランドがある場合は、最初のものをテンプレートの@samp{％0}で、2番目の@samp{％1}と3番目のものの@samp{％2}を使用して参照する。

@item constraint
オペランドの配置に関する制約を指定する文字列定数。詳細は@xref{Constraints}を参照せよ。

出力制約は、@samp{=}（既存の値を上書きする変数）または@samp{+}（読み書き時）で始まる必要がある。 @samp{=}を使用する場合、オペランドが入力に接続されている場合を除いて、その場所に@code{asm}への入力時に既存の値が含まれていると仮定しないこと。@pxref{InputOperands,,Input Operands}.

接頭辞の後には、値がどこにあるかを記述する1つ以上の追加の制約（@pxref{Constraints}）が必要である。一般的な制約には、レジスタの@samp{r}とメモリの@samp{m}がある。 可能な場所を複数指定すると（たとえば@code{"rm"}）、コンパイラは現在のコンテキストに基づいて最も効率的な場所を選択する。@code{asm}文で許される数だけアルファベットを指定すると、オプティマイザは可能な限り最良のコードを生成できる。特定のレジスタを使用する必要があるが、機種制約が必要な特定のレジスタを選択するのに十分な制御を提供していない場合、ローカルレジスタ変数が解決策を提供する（@pxref {Local Register Variables}）。

@item cvariablename
出力を保持するC言語の式（通常は変数名）を指定します。囲み括弧は構文の必須部分である。

@end table
コンパイラが出力オペランドを表すために使用するレジスタを選択すると、clobberedレジスタは使用されない。(@pxref{Clobbers and Scratch Registers})。

出力オペランド式は左辺値でなければならない。 コンパイラは、オペランドが実行されている命令に合ったデータ型を持っているかどうかをチェックすることはできない。直接アドレス可能ではない出力式（たとえばビットフィールド）の場合、制約でレジスタを許可する必要がある。 その場合、GCCはレジスタを@code{asm}の出力として使用し、そのレジスタを出力に格納する。

@samp{+}制約修飾子を使用するオペランドは、@code{asm}ステートメントごとに最大30個のオペランドまでの2つのオペランド（つまり、入力と出力の両方）としてカウントされる。

@samp{&}制約修飾子（@pxref {Modifiers}）は、入力と重複してはならないすべての出力オペランドに対して使用する。 さもなければ、GCCは出力を生成する前にアセンブラコードがその入力を消費すると仮定して、無関係の入力オペランドと同じレジスタに出力オペランドを割り当てることができる。 アセンブラコードが実際に複数の命令で構成されている場合、この仮定は誤っている可能性がある。

1つの出力パラメータ（@var{a}）がレジスタ制約を許可し、別の出力パラメータ（@var{b}）がメモリ制約を許容する場合、同じ問題が発生する可能性がある。@var{b}のメモリアドレスにアクセスするためにGCCによって生成されたコードは、@var{a}によって共有される@emph{可能性のある}レジスタを含むかもしれず、GCCはこれらのレジスタをasmへの入力と見なす。上記のように、GCCは、出力が書き込まれる前にそのような入力レジスタが消費されると仮定する。この仮定は、asmが@var{b}を使用する前に@var{a}に書き込むと正しく動作しなくなる可能性がある。@samp{&}修飾子を@var{a}のレジスタ制約と組み合わせると、@var{a}の変更が@var{b}が参照するアドレスに影響しないようになる。そうでなければ、@var{a}が変更されてから@var{b}が使用されると、@var{b}の位置は未定義である。

@code{asm}はオペランドのオペランド修飾子をサポートしている（例えば@samp{％2}の代わりに@samp{％k2}）。 通常、これらの修飾子はハードウェアに依存する。 x86でサポートされている修飾子のリストは、次の場所にあります。
@ref{x86Operandmodifiers,x86 Operand modifiers}.

@code{asm}に続くCコードが出力オペランドを何も使用しない場合は、オプティマイザが未使用として@code{asm}文を破棄しないように@code {asm}文に@code{volatile}を使用する。(@ref{Volatile}参照。)

このコードはオプションの@var{asmSymbolicName}を使用しない。 そのため、最初の出力オペランドを@code{％0}（2番目に@code {％1}など）として参照する。 最初の入力オペランドの数は、最後の出力オペランドの数より1多い。 このi386の例では、@code{Mask}は@code{％1}として参照される：

@example
uint32_t Mask = 1234;
uint32_t Index;

  asm ("bsfl %1, %0"
     : "=r" (Index)
     : "r" (Mask)
     : "cc");
@end example

そのコードは変数@code{Index}（@samp{=}）を上書きし、その値をレジスタ（@ samp{r}）に入れる。特定のレジスタの制約の代わりに汎用の@samp{r}制約を使用すると、コンパイラは使用するレジスタを選択できるため、より効率的なコードが生成される。 アセンブラ命令で特定のレジスタが必要な場合、これは不可能である。

次のi386の例では、@var{asmSymbolicName}構文を使用している。上記のコードと同じ結果が得られるが、オペランドを追加または削除するときには、インデックス番号を並べ替える必要がないため、より読みやすく保守性が高いと考えるユーザーもいる。 @code{aIndex}と@code{aMask}という名前は、この例では、どの名前がどこで使用されるのか強調するためにのみ使用されている。@code{Index}と@code{Mask}という名前を再利用してもよい。

@example
uint32_t Mask = 1234;
uint32_t Index;

  asm ("bsfl %[aMask], %[aIndex]"
     : [aIndex] "=r" (Index)
     : [aMask] "r" (Mask)
     : "cc");
@end example

出力オペランドのいくつかの例を次に示す。

@example
uint32_t c = 1;
uint32_t d;
uint32_t *e = &c;

asm ("mov %[e], %[d]"
   : [d] "=rm" (d)
   : [e] "rm" (*e));
@end example

ここで、@code{d}はレジスタまたはメモリのどちらかにある。 コンパイラはすでにレジスタ内の@code{e}が指している@code{uint32_t}位置の現在の値をすでに持っている可能性があるので、両方の制約を指定することで@code{d}の最適な場所を選択できる。

@anchor{FlagOutputOperands}
@subsubsection フラグ出力オペランド
@cindex @code{asm} flag output operands

一部のターゲットには、操作または比較の結果の「フラグ」を保持する特別なレジスタがある。 通常、そのレジスタの内容はasmによって変更されないか、asmが内容を破壊するとみなされる。

いくつかのターゲットでは、flagsレジスタの条件をasmの出力とすることができる特別な形式の出力オペランドが存在する。 サポートされる条件のセットはターゲット固有だが、一般的なルールは出力変数がスカラー整数で、値はブール値でなければならない。サポートされている場合、ターゲットはプリプロセッサシンボル@code{__GCC_ASM_FLAG_OUTPUTS__}を定義する。

フラグ出力オペランドの特別な性質のため、制約には代替が含まれてはならない。

ほとんどの場合、ターゲットにはフラグレジスタが1つしかないため、多くの命令の暗黙のオペランドになる。 この場合、アセンブリ言語に対応するテキストがないので、オペランドは@code{％0}などを介してアセンブラテンプレート内で参照されるべきではない。

@table @asis
@item x86ファミリ
x86ファミリのフラグ出力の制約は、@code {j@var{cond}}のISAマニュアルで定義されている標準条件の1つで、@var{cond}は@samp {=@@cc@var{cond}}または@code{set@var{cc}}を使用する。

@table @code
@item a
「上(above)」、すなわち符号なしのより大きい
@item ae
「上(above)及び等しい(equal)」、すなわち、符号なしの以上
@item b
「下(below)」すなわち符号なしの未満
@item be
「下(below)及び等しい(equal)」、すなわち、符号なしの以下
@item c
キャリーフラグセット
@item e
@itemx z
「等しい(equal)」、すなわちゼロフラグセット
@item g
符号ありのより大きい
@item ge
符号ありの以上
@item l
符号ありの未満
@item le
符号ありの以下
@item o
オーバーフローセット
@item p
パリティフラグセット
@item s
符号フラグセット
@item na
@itemx nae
@itemx nb
@itemx nbe
@itemx nc
@itemx ne
@itemx ng
@itemx nge
@itemx nl
@itemx nle
@itemx no
@itemx np
@itemx ns
@itemx nz
@var{flag}「でない(not)」、すなわち、上の逆バージョン
@end table

@end table

@anchor{InputOperands}
@subsubsection 入力オペランド
@cindex @code{asm} input operands
@cindex @code{asm} expressions

入力オペランドは、C変数および式から値をアセンブリコードで使用できるようにする。

オペランドはコンマで区切られる。 各オペランドは次の形式である。

@example
@r{[} [@var{asmSymbolicName}] @r{]} @var{constraint} (@var{cexpression})
@end example

@table @var
@item asmSymbolicName
オペランドのシンボリック名を指定する。アセンブラテンプレートの名前は、角括弧（@samp{％[Value]}）で囲んで参照する。名前のスコープは、定義を含む@code{asm}ステートメントである。 周囲のコードにすでに定義されている名前を含め、任意の有効なC変数名を使用できる。同じ@code{asm}ステートメント内に2つのオペランドが同じシンボリック名を使用することはできない。

@var{asmSymbolicName}を使用しないときは、アセンブラ・テンプレートのオペランドのリスト内のオペランドの（ゼロからの）位置を使用する。たとえば、2つの出力オペランドと3つの入力がある場合は、テンプレートの@samp{％2}を使用して最初の入力オペランドを参照し、@samp{％3}で2番目、@samp{％4}で3番目となる。

@item constraint
オペランドの配置に関する制約を指定する文字列定数。詳細は@xref{Constraints}を参照せよ。

入力制約文字列は、@samp{=}か@samp{+}で始まることはできない。可能な場所を複数指定すると（@samp{"irm"}など）、コンパイラは現在のコンテキストに基づいて最も効率的な場所を選択する。特定のレジスタを使用する必要があるにもかかわらず、Machine Constraintsが必要な特定のレジスタを選択するための十分な制御を提供しない場合、ローカルレジスタ変数が解決策を提供する。(@pxref{Local Register Variables}).

入力制約は、数字（たとえば、@code{"0"}）にもできる。これは、指定された入力が、出力制約リストの（ゼロベースの）インデックスの出力制約と同じ場所になければならないことを示す。出力オペランドに@var{asmSymbolicName}構文を使用する場合、数字の代わりにこれらの名前（大括弧@samp{[]}に囲まれた）を使用できる。

@item cexpression
これは、入力として@code{asm}ステートメントに渡されるC変数または式である。 囲み括弧は構文の必須部分である。

@end table

コンパイラが入力オペランドを表すために使用するレジスタを選択すると、破壊されたレジスタ（@pxref{Clobbers and Scratch Registers}）は使用されない。

出力オペランドがないが入力オペランドがある場合は、出力オペランドが続くところに2つの連続するコロンを配置する。

@example
__asm__ ("some instructions"
   : /* No outputs. */
   : "r" (Offset / 8));
@end example

@strong{警告:} 入力専用オペランドの内容を変更しては@emph{ならない}（出力に接続された入力を除く）。コンパイラは、@code{asm}文を終了すると、これらのオペランドには文を実行する前と同じ値が含まれているとみなす。これらの入力値が変化していることをコンパイラーに知らせるためにクローバーを使用することはでき@emph{ない}。 1つの一般的な回避策は、変化する入力変数を決して使用されない出力変数に結びつけることである。 ただし、@code{asm}文に続くコードが出力オペランドを使用しない場合、GCCオプティマイザは@code{asm}ステートメントを不要として破棄することがある。(@ref{Volatile}を見よ。)

@code{asm}はオペランドのオペランド修飾子をサポートしている（例えば@samp{％2}の代わりに@samp{％k2}）。 通常、これらの修飾子はハードウェアに依存する。 x86でサポートされている修飾子のリストは、@ref{x86Operandmodifiers,x86 Operand modifiers}にある。

この例では、架空の@code{combine}命令を使用して、入力オペランド1の制約@code {"0"}は、出力オペランド0と同じ位置を占める必要があると示している。入力オペランドだけが制約内の数値を使用し、 それぞれが出力オペランドを参照する必要がある。 制約内の数字（またはシンボリックアセンブラ名）のみが、あるオペランドが別のオペランドと同じ場所にあることを保証できる。 @code{foo}が両方のオペランドの値であるという単なる事実は、それらが生成されたアセンブラコード内の同じ場所にあることを保証するには不十分である。

@example
asm ("combine %2, %0" 
   : "=r" (foo) 
   : "0" (foo), "g" (bar));
@end example

シンボリック名を使用した例を次に示す。

@example
asm ("cmoveq %1, %2, %[result]" 
   : [result] "=r"(result) 
   : "r" (test), "r" (new), "[result]" (old));
@end example

@anchor{Clobbers and Scratch Registers}
@subsubsection 破壊とスクラッチレジスタ
@cindex @code{asm} clobbers
@cindex @code{asm} scratch registers

コンパイラは出力オペランドにリストされているエントリの変更を認識しているが、インラインの@code{asm}コードは出力以外を変更することがある。 たとえば、計算に追加のレジスタが必要な場合や、プロセッサが特定のアセンブラ命令の副作用としてレジスタを上書きする場合がある。コンパイラにこれらの変更を通知するには、それらをclobberリストに並べる。 clobberリスト項目は、レジスタ名または特殊Clobber（以下にリストされています）である。 各clobberリスト項目は、二重引用符で囲みコンマで区切られた文字列定数である。

clobber記述は、入力オペランドまたは出力オペランドと重複してはならない。 たとえば、clobberリストにそのレジスタをリストするときに、1つのメンバを持つレジスタクラスを記述するオペランドを持つことはできない。 特定のレジスタに存在すると宣言された変数（@pxref{Explicit Register Variables}）、@code{asm}の入力オペランドまたは出力オペランドとして使用する変数は、clobberの記述には何も記述することはできない。 特に、入力オペランドが出力オペランドとしても指定されていない状態では変更されるように指定する方法はない。

コンパイラは、入力および出力オペランドを表すために使用するレジスタを選択するとき、clobberedレジスタを使用しない。 その結果、アセンブラコード内での使用には、clobberedレジスタが使用できる。

VAXがclobberedレジスタの使用を示す現実的な例を次に示す。

@example
asm volatile ("movc3 %0, %1, %2"
                   : /* No outputs. */
                   : "g" (from), "g" (to), "g" (count)
                   : "r0", "r1", "r2", "r3", "r4", "r5", "memory");
@end example

また、特別なclobber引数が2つある。

@table @code
@item "cc"
@code{"cc"} clobberは、アセンブラコードがフラグレジスタを変更することを示す。 一部のマシンでは、GCCは条件コードを特定のハードウェアレジスタとして表す。 @code{"cc"}はこのレジスタの名前を指定する。他のマシンでは、条件コードの処理が異なり、@code{"cc"}を指定しても効果はない。 しかし、それはどんなターゲットであっても有効である。

@item "memory"
@code{"memory"} clobberは、アセンブラコードが入出力オペランドにリストされているもの以外のメモリ（例えば、入力パラメータの1つが指すメモリにアクセスする）への読み書きを実行することをコンパイラに伝える。メモリに正しい値が含まれていることを確認するために、GCCは@code{asm}を実行する前に特定のレジスタ値をメモリにフラッシュする必要がある。 さらに、コンパイラは、@code{asm}の前にメモリから読み込まれた値がその@code{asm}の後も変わらないと仮定しない。 必要に応じて再ロードする。@code{"memory"} clobberを使用すると、コンパイラの読み書き可能メモリバリアが効果的に形成される。

このclobberは、@emph{プロセッサ}が@code{asm}ステートメントより先に投機的な読み込みを行うことを妨げないことに注意せよ。 これを防ぐには、プロセッサ固有のフェンス命令が必要である。

@end table

メモリへのレジスタのフラッシュはパフォーマンスに影響を与え、時間に敏感なコードの問題となる可能性がある。 次の例に示すように、これを避けるためにGCCにより良い情報を提供することができる。 最低限、エイリアシング規則により、GCCはフラッシュする必要の@emph{ない}メモリを知ることができる。

ここでは、メモリ内の浮動小数点値への2つのポインタをとり、浮動小数点レジスタの出力を生成する架空の命令の架空の和の命令がある。@code{x}と@code{y}は、@code{asm}パラメータで2回、アクセスされたメモリを指定するために1回、@code{asm}で使用されるベースレジスタを指定するために1回ずつ表示される。 GCCは両方の目的で同じレジスタを使用できるため、これを行うことで通常はレジスタを無駄にすることはない。 しかし、この@code{asm}の@code{x}に@code{%1}と@code{%3}の両方を使用し、それらが同じであることを期待するのは愚かだろう。 実際、@code{%3}はレジスタではないかもしれない。 これは、@code{x}が指すオブジェクトへのシンボリックメモリ参照である可能性がある。

@smallexample
asm ("sumsq %0, %1, %2"
     : "+f" (result)
     : "r" (x), "r" (y), "m" (*x), "m" (*y));
@end smallexample

ここに架空の@code{*z++ = *x++ * *y++}命令がある。@code{x}、@code{y}と@code{z}ポインタレジスタは、@code{asm}がそれらを変更するため、入出力として指定する必要があることに注意せよ。

@smallexample
asm ("vecmul %0, %1, %2"
     : "+r" (z), "+r" (x), "+r" (y), "=m" (*z)
     : "m" (*x), "m" (*y));
@end smallexample

文字列memory引数の長さが不明なx86の例。

@smallexample
asm("repne scasb"
    : "=c" (count), "+D" (p)
    : "m" (*(const char (*)[]) p), "0" (-1), "a" (0));
@end smallexample

上のコードが10バイトの配列だけを読み取ることが分かっている場合は、代わりに次のようなメモリ入力を使用できる。@code{"m" (*(const char (*)[10]) p)}.

次に、アセンブリで実装されたPowerPCベクトルスケールの例を示す。ベクトルと条件コードの破壊子と、@code{asm}によって変更されていない初期化されたオフセットレジスタがある。

@smallexample
void
dscal (size_t n, double *x, double alpha)
@{
  asm ("/* lots of asm here */"
       : "+m" (*(double (*)[n]) x), "+&r" (n), "+b" (x)
       : "d" (alpha), "b" (32), "b" (48), "b" (64),
         "b" (80), "b" (96), "b" (112)
       : "cr0",
         "vs32","vs33","vs34","vs35","vs36","vs37","vs38","vs39",
         "vs40","vs41","vs42","vs43","vs44","vs45","vs46","vs47");
@}
@end smallexample

@code{asm}文のためのスクラッチレジスタを提供するためにクローバを介して固定レジスタを割り当てるのではなく、代替案は以下の例でのように変数を定義し、@code{a2}と@code{a3}のように早期破壊クローバー出力にすることである。これにより、コンパイラのレジスタアロケータの自由度が増す。 また、変数を定義して、@code{a0}と@code{a1}のように入力に結び付けられた出力を@code{ap}と@code{lda}にそれぞれ結びつけることもできる。 もちろん、結合された出力では、@code{asm}は出力レジスタを変更した後で入力値を使用することはできない。さらに、出力上の早期破壊子を省略すると、GCCが@code{asm}への入力時に同じ値を持つことが証明できれば、GCCが別の入力に同じレジスタを割り当てる可能性がある。これが@code{a1}が早期破壊子クローバーを持っている理由である。その結合された入力、@code{lda}は値16を持つことが既知なので、早期破壊子の共有は@code{％11}と同じレジスタを持たないことが考えられる。一方、@code{ap}は他の入力と同じにすることはできないので、@code{a0}の早期破壊子は必要ない。この場合も望ましくはない。 @code{a0}の早期破壊子は、GCCに@code{"m" (*(const double (*)[]) ap)}入力のための別個のレジスタを割り当てさせるだろう。入力を出力に結びつけようとすることは、@code{asm}文で修正された初期化された一時レジスタを設定する方法であることに注意すること。出力に結びついていない入力は、GCCによって変更されていないとみなされる。たとえば、以下の@code{"b"(16)}は@code{％11}を16に設定し、GCCはたまたま値16が必要になったときにはそのレジスタを使用する。スクラッチが使用される前に、同じレジスタを共有する可能性があるすべての入力が消費された場合、通常の@code{asm}出力を使用することもできる。 @code{asm}文で詰まったVSXレジスタは、GCCの@code{asm}パラメータの数の制限を除いて、この手法を使用することができた。

@smallexample
static void
dgemv_kernel_4x4 (long n, const double *ap, long lda,
                  const double *x, double *y, double alpha)
@{
  double *a0;
  double *a1;
  double *a2;
  double *a3;

  __asm__
    (
     /* lots of asm here */
     "#n=%1 ap=%8=%12 lda=%13 x=%7=%10 y=%0=%2 alpha=%9 o16=%11\n"
     "#a0=%3 a1=%4 a2=%5 a3=%6"
     :
       "+m" (*(double (*)[n]) y),
       "+&r" (n),	// 1
       "+b" (y),	// 2
       "=b" (a0),	// 3
       "=&b" (a1),	// 4
       "=&b" (a2),	// 5
       "=&b" (a3)	// 6
     :
       "m" (*(const double (*)[n]) x),
       "m" (*(const double (*)[]) ap),
       "d" (alpha),	// 9
       "r" (x),		// 10
       "b" (16),	// 11
       "3" (ap),	// 12
       "4" (lda)	// 13
     :
       "cr0",
       "vs32","vs33","vs34","vs35","vs36","vs37",
       "vs40","vs41","vs42","vs43","vs44","vs45","vs46","vs47"
     );
@}
@end smallexample

@anchor{GotoLabels}
@subsubsection Gotoラベル
@cindex @code{asm} goto labels
@code{asm goto}はアセンブリコードを1つまたは複数のCラベルにジャンプさせることを可能にする。@code{asm goto}文の@var{GotoLabels}セクションには、アセンブラコードがジャンプするすべてのCラベルのコンマ区切りリストが含まれている。GCCは@code{asm}の実行が次の文に進むと仮定する（そうでない場合は、@code{__builtin_unreachable}組み込み関数の使用を検討せよ）。@code{asm goto}の最適化は、@code{hot}と@code{cold}のラベル属性を使うことで改善されるかもしれない。(@pxref{Label Attributes}。)

@code{asm goto}文には出力がない。これは、コンパイラの内部制限によるものである。制御転送命令には出力がない。アセンブラコードが何かを変更する場合は、@code{"memory"} clobberを使用して、オプティマイザにすべてのレジスタ値をメモリにフラッシュさせ、必要に応じて@code{asm}文の後に再ロードする。

また、@code{asm goto}文は常に暗黙的にvolatileとみなされる。

アセンブラテンプレートのラベルを参照するには、@var{GotoLabels}に入力オペランドの数を加えた@samp{％l}（小文字@samp{L}）とその後ろに（ゼロベースの）位置を付ける。たとえば、@code{asm}に3つの入力があり、2つのラベルを参照する場合は、最初のラベルを@samp{％l3}、2番目のラベルを@samp{％l4}とする。

あるいは、カッコで囲まれた実際のCラベル名を使用してラベルを参照することもできる。 たとえば、@code{carry}という名前のラベルを参照するには、@samp{％l [carry]}を使用できる。 この方法を使用する場合でも、ラベルはまだ@var{GotoLabels}セクションにリストされていなければならない。

i386の@code {asm goto}の例を次に示す。

@example
asm goto (
    "btl %1, %0\n\t"
    "jc %l2"
    : /* No outputs. */
    : "r" (p1), "r" (p2) 
    : "cc" 
    : carry);

return 0;

carry:
return 1;
@end example

次の例は、メモリclobberを使用する@code {asm goto}を示している。

@example
int frob(int x)
@{
  int y;
  asm goto ("frob %%r5, %1; jc %l[error]; mov (%2), %%r5"
            : /* No outputs. */
            : "r"(x), "r"(&y)
            : "r5", "memory" 
            : error);
  return y;
error:
  return -1;
@}
@end example

@anchor{x86Operandmodifiers}
@subsubsection x86オペランド修正子

拡張された@code{asm}ステートメントのアセンブラテンプレートのinput、output、およびgotoオペランドへの参照は、修飾子を使用して、オペランドがコード出力の中でアセンブラにフォーマットされる方法に影響を与えることができる。 たとえば、次のコードでは、x86の@samp{h}および@samp{b}修飾子を使用している。

@example
uint16_t  num;
asm volatile ("xchg %h0, %b0" : "+a" (num) );
@end example

@noindent
これらの修飾子は、このアセンブラコードを生成する。

@example
xchg %ah, %al
@end example

この説明の残りの部分では、説明の目的で次のコードを使用する。

@example
int main()
@{
   int iInt = 1;

top:

   asm volatile goto ("some assembler instructions here"
   : /* No outputs. */
   : "q" (iInt), "X" (sizeof(unsigned char) + 1)
   : /* No clobbers. */
   : top);
@}
@end example

修飾子がない場合、アセンブラの@samp{att}と@samp{intel}の変種のオペランドからの出力は次のようになる。

@multitable {Operand} {$.L2} {OFFSET FLAT:.L2}
@headitem Operand @tab @samp{att} @tab @samp{intel}
@item @code{%0}
@tab @code{%eax}
@tab @code{eax}
@item @code{%1}
@tab @code{$2}
@tab @code{2}
@item @code{%2}
@tab @code{$.L2}
@tab @code{OFFSET FLAT:.L2}
@end multitable

下の表は、サポートされている修飾子のリストとその効果を示している。

@multitable {Modifier} {Print the opcode suffix for the size of th} {Operand} {@samp{att}} {@samp{intel}}
@headitem 修正子 @tab 説明 @tab Operand @tab @samp{att} @tab @samp{intel}
@item @code{z}
@tab 現在の整数オペランドのサイズのオペコード接尾辞を出力する (@code{b}/@code{w}/@code{l}/@code{q}のどれか)。
@tab @code{%z0}
@tab @code{l}
@tab 
@item @code{b}
@tab レジスタのQIモード名を出力する。
@tab @code{%b0}
@tab @code{%al}
@tab @code{al}
@item @code{h}
@tab 「上位」レジスタ用のQIモード名を出力する。.
@tab @code{%h0}
@tab @code{%ah}
@tab @code{ah}
@item @code{w}
@tab レジスタのHIモード名を出力する
@tab @code{%w0}
@tab @code{%ax}
@tab @code{ax}
@item @code{k}
@tab レジスタのSIモード名を出力する。
@tab @code{%k0}
@tab @code{%eax}
@tab @code{eax}
@item @code{q}
@tab レジスタのDIモード名を出力する
@tab @code{%q0}
@tab @code{%rax}
@tab @code{rax}
@item @code{l}
@tab 句読点なしでラベル名を出力する。
@tab @code{%l2}
@tab @code{.L2}
@tab @code{.L2}
@item @code{c}
@tab 定数オペランドを必要とし、定数式を句読点なしで出力する。
@tab @code{%c1}
@tab @code{2}
@tab @code{2}
@end multitable

@code{V}は、完全な整数レジスタの名前を@code{％}なしで出力する特別な修飾子である。

@anchor{x86floatingpointasmoperands}
@subsubsection x86浮動小数点@code{asm}オペランド

x86ターゲットでは、@code{asm}のオペランドにスタック型レジスタの使用法に関するいくつかの規則がある。 これらの規則は、スタック状のレジスタであるオペランドにのみ適用される。

@enumerate
@item
@code{asm}で死に至る入力レジスタのセットが与えられると、どれが暗黙的に@code{asm}によってポップされ、どれがGCCによって明示的にポップされなければならないことを知る必要がある。

@code{asm}によって暗黙的にポップされる入力レジスタは、出力オペランドと一致するように制約されない限り、明示的に破壊されなければならない。

@item
暗黙的に@code{asm}でポップされる入力レジスタの場合、ポップを補うためにスタックを調整する方法を知る必要がある。ポップされていない入力が暗黙的にポップされたレジスタよりもreg-stackの先頭に近い場合、スタックの外観を知ることはできない。スタックの残りの部分がどのように「滑り落ちる」かは不明瞭である。

すべての暗黙的にポップされた入力レジスタは、暗黙的にポップされていない入力よりもregスタックの先頭に近い必要がある。

入力が@code{asm}で終了した場合、コンパイラは出力リロードに入力レジスタを使用する可能性がある。 この例を考える。

@smallexample
asm ("foo" : "=t" (a) : "f" (b));
@end smallexample

@noindent
このコードは、入力@code{b}が@code{asm}によってポップされず、@code{asm}が結果をreg-stackにプッシュすると言う。つまり、スタックは@code{asm}以前のものよりも1段深くなっている。 しかし、リロードは入力と出力の両方に同じレジスタを使用できると考えることも可能である。

これを防ぐために、入力オペランドが@samp{f}制約を使用する場合、すべての出力レジスタ制約で@samp{&} early-clobber修飾子を使用する必要がある。

上記の例は以下のように正しく記述される：

@smallexample
asm ("foo" : "=&t" (a) : "f" (b));
@end smallexample

@item
いくつかのオペランドはスタック上の特定の場所にある必要がある。すべての出力オペランドはこのカテゴリに属す。GCCは、制約内でこれを指定しない限り、出力がどのレジスタに現れるかを知る他の方法はない。

出力オペランドは、出力が@code{asm}の後に現れるレジスタを具体的に示さなければならない。 @samp{= f}は許されない：オペランドの制約は、単一のレジスタを持つクラスを選択しなければならない。

@item
出力オペランドは、既存のスタックレジスタ間に「挿入」されないことがある。387オペコードは読取り/書込みオペランドを使用しないので、すべての出力オペランドは@code{asm}より前に死に、@code{asm}によってプッシュされる。regスタックの最上部以外の場所にプッシュするのは意味がない。

出力オペランドはreg-stackの先頭で始まらなければならない。出力オペランドはレジスタを「スキップ」しない。

@item
@code{asm}文の中には、内部計算のために余分なスタック領域が必要なものがある。 これは、入力と出力に無関係なスタックレジスタを壊すことによって保証される。

@end enumerate

この@code{asm}は内部的にポップされた1つの入力を受け取り、2つの出力を生成する。

@smallexample
asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));
@end smallexample

@noindent
この@code{asm}は2つの入力を受け取り、@code{fyl2xp1}オペコードでポップされ、1つの出力に置き換えらる。 コンパイラが@code{fyl2xp1}が両方の入力をポップすることを知るためには、@code{st(1)}clobberが必要である。


@smallexample
asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");
@end smallexample

@lowersections
@include md.texi
@raisesections

@node Asm Labels
@subsection アセンブラコードで使われる名前を制御する
@cindex assembler names for identifiers
@cindex names used in assembler code
@cindex identifiers, names in assembler code

宣言子の後ろに@code{asm}（または@code{__asm__}）キーワードを書くことによって、C関数または変数のアセンブラコードで使用される名前を指定できる。選択したアセンブラ名が他のアセンブラシンボルまたは参照レジスタと競合しないようにすることは、あなたの責任である。

@subsubheading データ用のアセンブラ名

このサンプルは、データのアセンブラ名を指定する方法を示している。

@smallexample
int foo asm ("myfoo") = 2;
@end smallexample

@noindent
これは、アセンブラコードの変数@code {foo}に使用される名前が通常の@samp{_foo}ではなく@samp{myfoo}であることを指定する。

通常、アンダースコアがC変数の名前の前に付加されているシステムでは、この機能を使用して、アンダースコアで始まらないリンカーの名前を定義できる。GCCでは静的でないローカル変数は、アセンブラ名を持たないためにこの機能を使用することはサポートしていない。 変数を特定のレジスタに入れる場合は、@ref{Explicit Register Variables}を参照せよ。

@subsubheading 関数のアセンブラ名

関数のアセンブラ名を指定するには、その定義の前に関数の宣言を記述し、そこに@code{asm}を入れる。

@smallexample
int func (int x, int y) asm ("MYFUNC");
     
int func (int x, int y)
@{
   /* @r{@dots{}} */
@end smallexample

@noindent
これは、アセンブラコードの関数@code {func}に使用される名前が@code{MYFUNC}であることを指定する。

@node Explicit Register Variables
@subsection 指定されたレジスタでの変数
@anchor{Explicit Reg Vars}
@cindex explicit register variables
@cindex variables in specified registers
@cindex specified registers

GNU Cでは、特定のハードウェアレジスタをC変数に関連付けることができる。 ほとんどの場合、コンパイラにレジスタの割り当てを許可すると、最良のコードが生成される。 しかし、特殊な状況下では、可変記憶域をより正確に制御する必要がある。

グローバル変数とローカル変数の両方をレジスタに関連付けることができる。 この関連付けを実行することの結果は、以下のセクションで説明するように、2つの場合で大きく異なる。

@menu
* Global Register Variables::   グローバルスコープで宣言された変数。
* Local Register Variables::    関数内で宣言された変数。
@end menu

@node Global Register Variables
@subsubsection グローバルレジスタ変数の定義
@anchor{Global Reg Vars}
@cindex global register variables
@cindex registers, global variables in
@cindex registers, global allocation

このように、グローバルレジスタ変数を定義して指定されたレジスタと関連づけることができる。

@smallexample
register int *foo asm ("r12");
@end smallexample

@noindent
ここで@code{r12}は使用すべきレジスタの名前である。 これはローカルレジスタ変数を定義するのと同じ構文であることに注意せよ。しかし、グローバル変数の場合、宣言は関数の外に現れる。 @code{register}キーワードは必須で、@code{static}と組み合わせることはできない。 レジスタ名は、ターゲットプラットフォームの有効なレジスタ名でなければならない。

ほとんどのシステムではレジスタは貴重なリソースであり、コンパイラがその使用法を管理できるようにすることで、通常は最良のコードが得られる。 しかし、特別な状況の下では、グローバルにいくつかを確保することが理にかなっている。 例えば、これは非常に頻繁にアクセスされる2つのグローバル変数を持つプログラミング言語インタープリタのようなプログラムで有用かもしれない。

現在のコンパイル単位のグローバルレジスタ変数を定義した後は、次のようになる。

@itemize @bullet
@item この使用のためにレジスタは完全に予約されており、他の目的では割り当てられない。
@item このレジスタは、どの関数機能によっても保存・復元されない。
@item このレジスタへのストアは、たとえ死んでいるように見えても決して削除されないが、参照は削除、移動、または簡略化されるかもしれない。
@end itemize

これらの点は、定義でコンパイルされたコードに@emph{のみ}適用される。 単にリンクされているコード（例えば、ライブラリのコード）の動作は影響を受けない。

グローバルレジスタ変数を実際に使用していないソースファイルを再コンパイルして、他の目的に使用しないようにするには、ソースコードにグローバルレジスタ宣言を実際に追加する必要はない。 レジスタを予約するには、コンパイラオプション@option{-ffixed-@var{reg}}（@pxref{Code Gen Options}）を指定するだけで十分である。

@subsubheading 変数の宣言

実行可能ファイルにはレジスタの初期内容を提供する手段がないため、グローバルレジスタ変数は初期値を持つことはできない。

レジスタを選択するときは、通常は保存され、マシン上の関数呼び出しによって復元されたものを選択する。 これにより、この予約を知らないコード（ライブラリルーチンなど）は、復帰前に復元される。

レジスタウィンドウを持つマシンでは、関数呼び出しメカニズムによって魔法の影響を受けないグローバルレジスタを選択すること。

@subsubheading Using the variable

@cindex @code{qsort}, and global register variables
予約を認識していないルーチンを呼び出すときは、それらのルーチンがそれらを使用するコードにコールバックするかどうかに注意せよ。 例えば、@code{qsort}のシステムライブラリバージョンを呼び出すと、実行中にレジスタが壊れる可能性があるが、適切なレジスタを選択した場合は、復帰前に復元される。 しかし、@code{qsort}の比較関数を呼び出す前にそれらを復元し@emph{ない}。 その結果、@code{qsort}関数自体が再構築されない限り、グローバル関数の値は比較関数で確実に利用できなくなる。

同様に、シグナルハンドラや複数の制御スレッドからグローバルレジスタ変数にアクセスすることは安全ではない。 手元のタスクのためにそれらを特別に再コンパイルしない限り、システムライブラリルーチンは他のもののために一時的にレジスタを使用するかもしれない。

@cindex register variable after @code{longjmp}
@cindex global register after @code{longjmp}
@cindex value after @code{longjmp}
@findex longjmp
@findex setjmp
ほとんどのマシンでは、@code{longjmp}は@code{setjmp}の時に持っていた値を各グローバルレジスタ変数に復元する。 しかし、一部のマシンでは、@code{longjmp}はグローバルレジスタ変数の値を変更しない。 移植性を持たせるために、@code{setjmp}を呼び出した関数は、グローバルレジスタ変数の値を保存し、それらを@code{longjmp}に復元するための他の準備をしなければならない。 このようにして、@code{longjmp}とは関係なく同じことが起こります。

最終的にコンパイラに自動的にレジスタを選択させる方法があるかもしれないが、最初に選択方法と選択方法を導き出す方法を理解する必要がある。 解決策は明らかではない。

@node Local Register Variables
@subsubsection ローカル変数用のレジスタを指定する
@anchor{Local Reg Vars}
@cindex local variables, specifying registers
@cindex specifying registers for local variables
@cindex registers for local variables

ローカルレジスタ変数を定義し、次のように指定されたレジスタに関連付けることができる：

@smallexample
register int *foo asm ("r12");
@end smallexample

@noindent
ここで@code{r12}は使用すべきレジスタの名前である。これはグローバルレジスタ変数の定義と同じ構文だが、ローカル変数の場合は宣言が関数内に表示される。 @code{register}キーワードは必須で、@code{static}と組み合わせることはできない。 レジスタ名は、ターゲットプラットフォームの有効なレジスタ名でなければならない。

グローバルレジスタ変数の場合と同様に、通常は保存され、マシン上の関数呼び出しによってリストアされるレジスタを選択することを推奨する。これにより、ライブラリルーチンへの呼び出しがそれを壊さないようにする。

この機能で唯一サポートされているのは、Extended @code{asm}（@pxref {Extended Asm}）を呼び出すときに入力オペランドと出力オペランドのためのレジスタを指定することである。 これは、特定の機械に対する制約が所望のレジスタを選択するのに十分な制御を提供しない場合に必要となることがある。 オペランドを強制的にレジスタに入れるには、ローカル変数を作成し、その変数の宣言の後にレジスタ名を指定する。 次に、@code{asm}オペランドにローカル変数を使用し、レジスタと一致する制約文字を指定する。

@smallexample
register int *p1 asm ("r0") = @dots{};
register int *p2 asm ("r1") = @dots{};
register int *result asm ("r0");
asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));
@end smallexample

@emph{_警告_:} 上記の例では、関数呼び出しと他の変数の算術演算子のライブラリ呼び出し（例えば、@code{p2}の初期化などを含む、後続のコードによってレジスタ（たとえば@code{r0}）を呼び出すことができることに注意せよ）。 この場合、レジスタ割り当て間の式には一時変数を使用する。

@smallexample
int t1 = @dots{};
register int *p1 asm ("r0") = @dots{};
register int *p2 asm ("r1") = t1;
register int *result asm ("r0");
asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));
@end smallexample

レジスタ変数を定義しても、レジスタは予約されない。 拡張@code{asm}を呼び出すとき以外は、指定されたレジスタの内容は保証されない。 このため、以下の用途は明示的にに対応してい@emph{ない}。 動作しているように見える場合は偶然であり、周辺コードの（一見）関連のない変更、またはgccの将来のバージョンの最適化におけるマイナーな変更のために意図したとおりに動作を停止する可能性がある。

@itemize @bullet
@item 基本@code{asm}とのパラメータのやり取り
@item 入力・出力オペランドを使わずに拡張@code{asm}とのパラメータのやり取り
@item 非標準の呼び出し規約を使ったアセンブラ（及び他の言語）で書かれたルーチンとのパラメータのやり取り
@end itemize

いくつかの開発者は、gccのレジスタの割り当てを改善するために、特に大きな関数でローカルレジスタ変数を使用する。 この場合、レジスタ名は基本的にレジスタアロケータのヒントになる。場合によってはより良いコードを生成することができるが、改善はアロケータ/オプティマイザの気まぐれに左右される。あなたの改善が失われないという保証はないので、このローカルレジスタ変数の使用は推奨しない。

MIPSプラットフォームでは、特性が少し異なるローカルレジスタ変数（@pxref {MIPS CoprocessorsDefining coprocessor specifics for MIPS targets, gccint, 
GNU Compiler Collection (GCC) Internals}）に関連する用途がある。

@node Size of an asm
@subsection @code{asm}のサイズ

ターゲットによっては、GCCが正しいコードを生成するために使用される各命令のサイズを追跡する必要がある。 @code{asm}ステートメントで生成されるコードの最終的な長さはアセンブラでしか認識されないため、GCCはどれくらいの大きさになるかについての見積もりを行う必要がある。 これは、@code{asm}のパターンで命令の数を数え、そのプロセッサでサポートされている最長命令の長さで乗算することで行う。 （命令数を試してみると、改行やアセンブラでサポートされている文の区切り文字（通常@samp {;} ---）があれば、命令の終わりを示しているとみなされる。

通常、正しいコードが生成されるようにGCCの見積もりは適切だが、複数の実命令に展開する擬似命令またはアセンブラマクロを使用する場合、単一の命令で必要とされるよりも多くのオブジェクトファイル内の領域に展開するアセンブラディレクティブを使用する場合、コンパイラを混乱させる可能性がある。この場合、アセンブラはラベルに到達できないという診断を生成することがある。

@node Alternate Keywords
@section 代替キーワード
@cindex alternate keywords
@cindex keywords, alternate

@option {-ansi}とさまざまな@option {-std}オプションは、特定のキーワードを無効にする。 これは、GNU C拡張、またはISO Cプログラムを含むすべてのプログラムで使用可能な汎用ヘッダファイルを使用するときに問題を引き起こす。 @option{-ansi}または@option{-std}でコンパイルされたプログラムでは、キーワード@code{asm}、@code{typeof}と@code{inline}は使用できない（ただし、@code{inline}は @option{-std=c99}または@option{-std=c11}でコンパイルされたプログラムでは使用できる）。 ISO C99キーワード@code{restrict}は、@option{-std=gnu99}（結局はデフォルトである）または@option{-std=c99}（または同等の@option{-std=iso9899:1999}）以降の標準のオプションバージョンが使用されるときだけ利用可能である。

これらの問題を解決する方法は、各問題のキーワードの先頭と最後に@samp {__}を入れることである。 たとえば、@code{asm}ではなく@code{__asm__}を使用し、@code{inline}ではなく@code{__inline__}を使用する。

他のCコンパイラはこれらの代替キーワードを受け入れない。 別のコンパイラでコンパイルする場合は、代替キーワードをマクロとして定義して、通常のキーワードと置き換えることができる。 これは次のようになる。

@smallexample
#ifndef __GNUC__
#define __asm__ asm
#endif
@end smallexample

@findex __extension__
@opindex pedantic
@option{-pedantic}と他のオプションは、多くのGNU C拡張の警告を引き起こす。式の前に@code{__extension__}を書くことで、そのような警告を防ぐことができる。 @code{__extension__}はこれとは別に何の効果もない。

@node Incomplete Enums
@section 不完全@code{enum}型

可能な値を指定せずに@code {enum}タグを定義することができる。これは要素を記述せずに@code{struct foo}を書くと非常に似ている、不完全な型になる。 可能な値を指定する後の宣言は型を完成させる。

変数が不完全な場合は、型を使用して変数または記憶域を割り当てることはできない。 ただし、その型へのポインタで作業することはできる。

この拡張はそれほど有用ではないかもしれないが、@code{struct}と@code{union}の扱い方と@code{enum}の扱いがより一貫している。

この拡張はGNU C++ではサポートされていない。

@node Function Names
@section 文字列としての関数名
@cindex @code{__func__} identifier
@cindex @code{__FUNCTION__} identifier
@cindex @code{__PRETTY_FUNCTION__} identifier

GCCは現在の関数の名前を文字列として保持する3つのマジック定数を提供する。 C++11以降のモードでは、3つすべてが定数式として扱われ、@code{constexpr}文脈で使用できる。これらの定数の最初のものはC99標準の一部である@code{__func__}である：

識別子@code{__func__}は、各関数定義の開始中括弧の直後に宣言

@smallexample
static const char __func__[] = "function-name";
@end smallexample

@noindent
が出現した場合と同様に、トランスレータによって暗黙的に宣言される。function-nameは字句を囲む関数の名前である。 この名前は、機能の未装飾の名前である。 拡張として、ファイル（または、C++では名前空間の）スコープで、@code{__func__}は空の文字列を評価する。

@code{__FUNCTION__}は、GCCの旧バージョンとの下位互換性のために提供されている@code {__func__}の別の名前である。

Cでは、@code{__PRETTY_FUNCTION__}は、ファイル（またはC++では名前空間の）スコープで@code {"top level"}という文字列になる点を除いて、@code{__func__}のもう一つの名前である。さらに、C++では、@code{__PRETTY_FUNCTION__}には関数の署名とその裸の名前が含まれている。 たとえば、次のプログラム：

@smallexample
extern "C" int printf (const char *, ...);

class a @{
 public:
  void sub (int i)
    @{
      printf ("__FUNCTION__ = %s\n", __FUNCTION__);
      printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
    @}
@};

int
main (void)
@{
  a ax;
  ax.sub (0);
  return 0;
@}
@end smallexample

@noindent
は以下を出力する。

@smallexample
__FUNCTION__ = sub
__PRETTY_FUNCTION__ = void a::sub(int)
@end smallexample

これらの識別子はプリプロセッサマクロではなく変数であり、@code{char}配列の初期化や文字列リテラルとの連結には使用できない。

@node Return Address
@section 関数のリターン・フレームアドレスの取得

これらの関数は、関数の呼び出し元に関する情報を取得するために使用できる。

@deftypefn {Built-in Function} {void *} __builtin_return_address (unsigned int @var{level})
この関数は、現在の関数またはその呼び出し元のいずれかの戻りアドレスを返す。 @var{level}引数は、呼び出しスタックをスキャンするフレームの数である。 @code{0}の値は現在の関数の戻りアドレスを返し、@ code{1}の値は現在の関数の呼び出し元の戻りアドレスなどを返す。インライン化では、予期される振る舞いは、関数が返される関数のアドレスを返すことである。 この問題を回避するには、@code{noinline}関数属性を使用する。

@var{level}引数は定数でなければならない。

マシンによっては、現在のもの以外の機能の戻りアドレスを特定できない場合がある。 そのような場合、またはスタックの最上部に達したとき、この関数は@code{0}またはランダム値を返す。さらに、@code{__builtin_frame_address}は、スタックの先頭に到達したかどうかを判断するために使用できる。

戻り値の追加の後処理が必要な場合がある。@code{__builtin_extract_return_addr}を参照せよ。

ゼロ以外の引数を指定してこの関数を呼び出すと、呼び出し元プログラムがクラッシュするなど、予期しない結果が生じる可能性がある。 その結果、@option{-Wframe-address}オプションが有効な場合、安全でないとみなされる呼び出しは診断が出される。 そのような呼び出しは、デバッグ状況でのみ行うべきである。
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_extract_return_addr (void *@var{addr})
@code{__builtin_return_address}で返されたアドレスは、実際のコード化されたアドレスを取得するためにこの関数に渡さなければならないかもしれない。 たとえば、31ビットS/390プラットフォームでは、最上位ビットをマスクする必要がある。また、SPARCプラットフォームでは、真の次の命令を実行するためにオフセットを追加する必要がある。

フィックスアップが必要ない場合、この関数は単純に@var{addr}を渡す。
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_frob_return_address (void *@var{addr})
この関数は@code{__builtin_extract_return_addr}の逆を行う。
@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_frame_address (unsigned int @var{level})
この関数は@code{__builtin_return_address}と似ているが、関数の戻りアドレスではなく関数フレームのアドレスを返す。 @code{0}の値を持つ@code{__builtin_frame_address}を呼び出すと、現在の関数のフレームアドレスが返され、@code{1}の値は現在の関数の呼び出し元のフレームアドレスなどを返す。

フレームは、ローカル変数と保存されたレジスタを保持するスタック上の領域である。 フレームアドレスは、通常、関数によってスタックにプッシュされた最初のワードのアドレスである。 しかし、正確な定義はプロセッサーと呼び出し規約によって異なる。 プロセッサに専用のフレームポインタレジスタがあり、関数にフレームがある場合、@code{__builtin_frame_address}はフレームポインタレジスタの値を返す。

一部のマシンでは、現在のもの以外の関数のフレームアドレスを判別することができない場合がある。 そのような場合、またはスタックの先頭に達したとき、この関数は最初のフレームポインタがスタートアップコードによって適切に初期化されていれば@code{0}を返す。

ゼロ以外の引数を指定してこの関数を呼び出すと、呼び出し元プログラムがクラッシュするなど、予期しない結果が生じる可能性がある。 その結果、@option{-Wframe-address}オプションが有効な場合、安全でないとみなされる呼び出しは診断が出される。 そのような呼び出しは、デバッグ状況でのみ行うべきである。

@end deftypefn

@node Vector Extensions
@section 組み込み関数を通してベクトル命令を使う

いくつかのターゲットでは、命令セットには、同時に1つの大きなレジスタに格納された複数の値で動作するSIMDベクタ命令が含まれている。たとえば、x86ではMMX、3DNow！、 SSE拡張はこの方法で使用できる。

これらの拡張機能を使用するための最初のステップは、必要なデータ型を提供することである。 これは、適切な@code{typedef}を使って行う必要がある。

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));
@end smallexample

@noindent
@code{int}型は基本型を指定し、属性は変数のベクトルサイズをバイト単位で指定する。 たとえば、上記の宣言では、コンパイラは@code{v4si}型のモードを16バイト幅に設定し、@code{int}サイズの単位に分割する。32ビットの@code{int}の場合、これは4バイトの4単位のベクトルを意味し、対応する@code{foo}のモードは@acronym{V4SI}である。

@code{vector_size}属性は、整数、浮動小数点スカラーにのみ適用されるが、配列、ポインタ、および関数の戻り値はこの構造体と一緒に使用できる。 現在、2の累乗であるサイズのみが許可されている。

すべての基本整数型は、signed型とunsigned型の両方で、基本型として使用できる：@code{char}、@code{short}、@code{int}、@code{long}、@code{long long}。さらに、@code{float}と@code{double}を使用して、浮動小数点型を構築することができる。

現在のアーキテクチャに対して有効でない組み合わせを指定すると、GCCはより狭いモードを使用して命令を合成する。たとえば、@code{V4SI}型の変数を指定し、アーキテクチャがこの特定のSIMD型を許可しない場合、GCCは4つの@code{SIs}を使用するコードを生成する。

このように定義された型は、通常のC操作のサブセットとともに使用できる。 現在、GCCでは次のタイプの演算子を使用できる。@code{+, -, *, /, unary minus, ^, |, &, ~, %}。

操作はC++@code {valarrays}のように動作する。 加算は、オペランドの対応する要素の加算として定義される。 たとえば、以下のコードでは、@var{a}の4つの要素のそれぞれが@var {b}の対応する4つの要素に追加され、結果のベクトルは@var{c}に格納される。

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a, b, c;

c = a + b;
@end smallexample

減算、乗算、除算、論理演算も同様に動作すうる。 同様に、ベクトル型に対して単項マイナス演算子または補数演算子を使用した結果は、その要素がオペランドの対応する要素の負または補数の値であるベクトルである。

整数型のベクトルにシフト演算子@code{<<}、@code {>>}を使用することは可能である。 @code{@{a0, a1, @dots{}, an@} >> @{b0, b1, @dots{}, bn@} == @{a0 >> b0, a1 >> b1, @dots{}, an >> bn@}}。 ベクトルオペランドは、同じ数の要素を持たなければならない。

便宜上、1つのオペランドがスカラーである場合、2進ベクトル演算を使用することが許される。 その場合、コンパイラはスカラー・オペランドをベクトルに変換する。ここで、各要素は操作のスカラーである。 スカラーがベクトル要素型に安全に変換できる場合にのみ変換が行われる。次のコードを考える。

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a, b, c;
long l;

a = b + 1;    /* a = b + @{1,1,1,1@}; */
a = 2 * b;    /* a = @{2,2,2,2@} * b; */

a = l + a;    /* Error, cannot convert long to int. */
@end smallexample

ベクトルは、ベクトルが同じ数の要素と基底型を持つ配列であるかのように添え字を付けることができる。 境界外アクセスは、実行時に未定義の動作を呼び出す。 ベクタの添字の境界外の警告は、@option{-Warray-bounds}で有効にすることができる。

ベクトル比較は、標準比較演算子@code{==, !=, <, <=, >, >=}でサポートされている。 比較オペランドは、整数型または実型のベクトル式にすることができる。 整数型ベクトルと実型ベクトルの比較はサポートされていない。 比較の結果は、符号付き整数要素型の比較オペランドと同じ幅および要素数のベクトルである。

ベクトルは、要素が比較され、比較が偽である場合は0を生成し、それ以外の場合は-1を返す（すべてのビットが設定されている場合は適切な型の定数）。 次の例を考える。

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a = @{1,2,3,4@};
v4si b = @{3,2,1,4@};
v4si c;

c = a >  b;     /* The result would be @{0, 0,-1, 0@}  */
c = a == b;     /* The result would be @{0,-1, 0,-1@}  */
@end smallexample

C++では、三項演算子@code{?:}を使用できる。 @code{a？b：c}は、ここで@code{b}と@code{c}は同じ型のベクトルで、@code{a}は@code{b}および@code{c}と同じサイズの同じ要素数を持つ整数ベクトルであるとき、 3つの引数をすべて計算し、ベクトル@code{@{a[0]?b[0]:c[0], a[1]?b[1]:c[1], @dots{}@}}を作成する。 OpenCLとは異なり、@code{a}は@code{a！= 0}と解釈され、@code{a <0}と解釈されないことに注意せよ。バイナリ演算の場合と同様に、この構文は、@code {b}または@code{c}のいずれかがベクトルに変換されるスカラーである場合にも受け入れられる。 @code{b}と@code{c}の両方がスカラーで、@code{true？b：c}の型が@code {a}の要素の型と同じ大きさであれば、@code{b}と @code{c}は、この型を持ち、@code{a}と同じ数の要素を持つベクトル型に変換される。

C++では、ベクトルの論理演算子@code {!, &&、||}を使用できまる。@code{a && b}は@code{a！= 0＆b！= 0}と、@code {a || b}hは、@code{a！= 0 | b！= 0}と同等である。スカラ@code{s}とベクトル@code{v}との混合演算の場合、@code{s && v}は@code{s？v！= 0：0}と等価である（評価は短絡である） 。@code{v && s}は@code{v！= 0＆（s？-1：0）}と等価である。

@findex __builtin_shuffle
ベクトルシャッフルは、関数@code{__builtin_shuffle(vec、mask)}と@code {__builtin_shuffle(vec0ｍ, vec1, mask)}を使用して利用できる。両方の関数は、1つまたは2つのベクトルから要素の置換を構成し、入力ベクトルと同じ型のベクトルを返す。@var{mask}は出力ベクトルと同じ幅（@ var{W}）と要素数（@ var{N}）を持つ整数ベクトルである。

入力ベクトルの要素には、0から始まる@var{vec0}と@var{N}で始まる@var {vec1}のメモリ順序で番号が付けられる。 @var{mask}の要素は、シングルオペランドの場合は@var{N}をモジュロと見なし、2オペランドの場合は@math{2 * @ var {N}}をモジュロと見なす。

以下の例を考える。

@smallexample
typedef int v4si __attribute__ ((vector_size (16)));

v4si a = @{1,2,3,4@};
v4si b = @{5,6,7,8@};
v4si mask1 = @{0,1,1,3@};
v4si mask2 = @{0,4,2,5@};
v4si res;

res = __builtin_shuffle (a, mask1);       /* res is @{1,2,2,4@}  */
res = __builtin_shuffle (a, b, mask2);    /* res is @{1,5,3,6@}  */
@end smallexample

@code{__builtin_shuffle}は、OpenCL @code{shuffle}関数および@code{shuffle2}関数と意図的に意味的に互換性があることに注意せよ。

変数を宣言して、関数の呼び出しや戻り、代入やキャストなどで変数を使用できる。 関数の戻り値の型としてベクトル型を指定できる。 ベクトル型を関数の引数として使用することもできる。 同じサイズのものであれば、あるベクトル型から別の型にキャストすることができる（実際には、同じサイズの他のデータ型との間でベクトルをキャストすることもできる。）。

キャストなしでは、異なる長さのベクトル間で操作することはできない。

@node Offsetof
@section @code{offsetof}のサポート
@findex __builtin_offsetof

GCCはCとC++の両方に@code{offsetof}マクロを実装するための構文拡張を実装している。

@smallexample
primary:
        "__builtin_offsetof" "(" @code{typename} "," offsetof_member_designator ")"

offsetof_member_designator:
          @code{identifier}
        | offsetof_member_designator "." @code{identifier}
        | offsetof_member_designator "[" @code{expr} "]"
@end smallexample

この拡張は、X

@smallexample
#define offsetof(@var{type}, @var{member})  __builtin_offsetof (@var{type}, @var{member})
@end smallexample

@noindent
が@code{offsetof}マクロの適切な定義となるように十分である。 C++では、@var{type}は依存している可能性がある。 どちらの場合でも、@var{member}は単一の識別子、またはメンバーアクセスと配列参照のシーケンスで構成される。

@node __sync Builtins
@section アトミック・メモリアクセスのための古い@code{__sync}組み込み関数

次の組み込み関数は、@cite{Intel Itanium Processor-specific Application Binary Interface}のセクション7.4で説明されているものと互換性があることを意図している。 したがって、それらは@samp{__builtin_}接頭辞を使用しないことによって、また複数の型で動作するようにオーバーロードされることによって、通常のGCCの慣行から逸脱する。

インテルのドキュメントに書かれている定義は、@code{int}、@code{long}、@code{long long}またはそれらの符号なし対応物の使用のみを許可する。 GCCでは、C型@code{_Bool}やC++型@code{bool}以外の1,2,4,8バイトのいずれかのスカラ型を使用できる。ポインタ引数の操作は、オペランドが@code{uintptr_t}型であるかのように実行される。 つまり、ポインタが指している型のサイズによってはスケーリングされない。

これらの関数は@samp{__atomic}組み込み関数（@pxref{__atomic Builtins}）で実装されている。 新しいコードのために使うべきではなく、代わりに@samp{__atomic}組み込み関数を使うべきである。

すべての操作がすべてのターゲットプロセッサでサポートされているわけではない。 ターゲットプロセッサ上で特定の操作を実装できない場合は、警告が生成され、外部関数への呼び出しが生成される。 外部関数には、@samp{_@ var{n}}という接尾辞が付いた組み込みバージョンと同じ名前が付けられる。ここで、@var{n}はデータ型のサイズである。

@c ??? Should we have a mechanism to suppress this warning?  This is almost
@c useful for implementing the operation under the control of an external
@c mutex.

ほとんどの場合、これらの組み込み関数は@dfn{full barrier}（フルバリア）とみなされる。つまり、メモリーオペランドは、操作の前後に移動しない。 さらに、オペレーションの間、およびオペレーションの後の待ち行列ストアからプロセッサが負荷を推測するのを防ぐために、必要に応じて命令が発行される。

すべてのルーチンは、「メモリバリアによって保護された変数のオプションリスト」を取るように、インテルのドキュメントに記載されている。 それが何を意味するのかははっきりしない。 リストされた変数@emph{のみ}が保護されているか、さもなければ保護されるべき追加の変数のリストを意味する可能性がある。 このリストはGCCによって無視され、GCCはそれを空として扱う。 GCCは、空のリストを、グローバルにアクセス可能なすべての変数を保護する必要があると解釈する。

@table @code
@item @var{type} __sync_fetch_and_add (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_sub (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_or (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_and (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_xor (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_fetch_and_nand (@var{type} *ptr, @var{type} value, ...)
@findex __sync_fetch_and_add
@findex __sync_fetch_and_sub
@findex __sync_fetch_and_or
@findex __sync_fetch_and_and
@findex __sync_fetch_and_xor
@findex __sync_fetch_and_nand
これらの組み込み関数は、名前で示された操作を実行し、以前にメモリにあった値を返す。 つまり、整数オペランドの操作は次の意味を持つ。 ポインタ引数の操作は、オペランドが@code{uintptr_t}型であるかのように実行される。 つまり、ポインタが指している型のサイズによってはスケーリングされない。

@smallexample
@{ tmp = *ptr; *ptr @var{op}= value; return tmp; @}
@{ tmp = *ptr; *ptr = ~(tmp & value); return tmp; @}   // nand
@end smallexample

最初の引数が指すオブジェクトは、整数型またはポインタ型でなければなりません。 ブール型であってはならない。

@emph{_注意_:} GCC 4.4以降では、@code{__sync_fetch_and_nand}を、@code{*ptr =~tmp＆value}ではなく@code{*ptr =~(tmp＆value)}として実装している。

@item @var{type} __sync_add_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_sub_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_or_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_and_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_xor_and_fetch (@var{type} *ptr, @var{type} value, ...)
@itemx @var{type} __sync_nand_and_fetch (@var{type} *ptr, @var{type} value, ...)
@findex __sync_add_and_fetch
@findex __sync_sub_and_fetch
@findex __sync_or_and_fetch
@findex __sync_and_and_fetch
@findex __sync_xor_and_fetch
@findex __sync_nand_and_fetch
これらの組み込み関数は、名前が示す操作を実行し、新しい値を返す。 つまり、整数オペランドの操作は次の意味を持つ。 ポインタオペランドの操作は、オペランドの型が@code{uintptr_t}であるかのように実行される。

@smallexample
@{ *ptr @var{op}= value; return *ptr; @}
@{ *ptr = ~(*ptr & value); return *ptr; @}   // nand
@end smallexample

引数の同じ制約は、対応する@code{__sync_op_and_fetch}組み込み関数の場合と同様に適用される。

@emph{_注意_:} GCC 4.4以降では、@code{__sync_nand_and_fetch}を、@code{*ptr =~tmp＆value}ではなく@code{*ptr =~(tmp＆value)}として実装している。

@item bool __sync_bool_compare_and_swap (@var{type} *ptr, @var{type} oldval, @var{type} newval, ...)
@itemx @var{type} __sync_val_compare_and_swap (@var{type} *ptr, @var{type} oldval, @var{type} newval, ...)
@findex __sync_bool_compare_and_swap
@findex __sync_val_compare_and_swap
これらの組み込み関数は、アトミック比較およびスワップを実行する。つまり、@code{*@var{ptr}}の現在の値が@var {oldval}の場合、@var{newval}を@code{*@var{ptr}}に書き出す。

比較が成功し、@var{newval}が書かれていれば、 "bool"バージョンは真を返す。 "val"バージョンは操作の前の@code{*@var{ptr}}の内容を返す。

@item __sync_synchronize (...)
@findex __sync_synchronize
この組み込み関数は、完全なメモリバリアを発行する。

@item @var{type} __sync_lock_test_and_set (@var{type} *ptr, @var{type} value, ...)
@findex __sync_lock_test_and_set
この組み込み関数は、Intelによって記述されているように、従来のテスト・アンド・セット操作ではなく、アトミック交換操作である。 @var{value}を@code{*@var{ptr}}に書き込み、以前の@code{*@var{ptr}}の内容を返す。

多くのターゲットは、そのようなロックに対して最小限のサポートしか持たず、完全な交換操作をサポートしていない。 この場合、ターゲットは直接的な定数1であるようなストアするための有効な値@emph{のみ}の縮小された機能性をサポートする。実際には@code{*@var {ptr}}に格納されている正確な値は実装定義である。

この組み込み関数は完全なバリアではなく、むしろ@dfn{acquire barrier}（獲得バリア）である。 つまり、操作後の参照は操作の前に移動できない（または推測することはできない）が、以前のメモリー・ストアはまだグローバルに可視でない可能性があり、前のメモリー・ロードはまだ満たされていない可能性がある。

@item void __sync_lock_release (@var{type} *ptr, ...)
@findex __sync_lock_release
この組み込み関数は、@code{__sync_lock_test_and_set}で獲得したロックを解放する。通常これは定数0を@code{*@var{ptr}}に書き込むことを意味する。

この組み込み関数は完全なバリアではなく、むしろ@dfn{release barrier}（解放バリア）である。これは、すべての以前のメモリ・ストアがグローバルに可視であり、かつすべての以前のメモリ・ロードが満たされているが、その後のメモリ・リードがバリアの前に推測されることを妨げられないことを意味する。
@end table

@node __atomic Builtins
@section メモリモデルを関知するアトミック操作用の組み込み関数

次の組み込み関数は、C++11メモリモデルの要件とほぼ同じである。 それらはすべて接頭辞@samp{__atomic}によって識別され、大部分は複数の型で動作するようにオーバーロードされる。

これらの関数は、従来の@samp{__sync}組み込み関数を置き換えることを意図している。 主な違いは、要求されたメモリの順序が関数のパラメータであることである。 新しいコードでは、@samp{__sync}組み込み関数ではなく@samp{__atomic}組み込み関数を常に使用するべきである。

@samp{__atomic}組み込み関数は、プログラムがC++11のメモリモデルに準拠していることを前提としている。 特に、それらはプログラムにはデータ競争がないと仮定している。 詳細な要件については、C++ 11の標準を参照せよ。

@samp{__atomic}組み込み関数は、長さが1,2,4、または8バイトの整数スカラーまたはポインター型で使用できる。 @samp{__int128}（@pxref{__int128}）がアーキテクチャでサポートされている場合は、16バイトの整数型も使用できる。

4つの非算術関数（load、store、exchange、およびcompare_exchange）はすべて汎用バージョンを持っている。 この汎用バージョンは、どのデータ型でも動作する。 特定のデータ型サイズが可能な場合は、ロックフリーの組み込み関数を使用する。 それ以外の場合は、実行時に外部呼び出しが解決される。 この外部呼び出しは、@samp{size_t}パラメータが追加された同じフォーマットで、指定されたオブジェクトのサイズを示す最初のパラメータとして挿入される。すべてのオブジェクトは同じサイズでなければならない。

指定できるメモリ順序は6種類ある。 これらは、同じ名前のC++11メモリ順序に対応している。詳細な定義については、C++11標準または@uref{http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync,GCC wiki on atomic synchronization}を参照せよ。 個々のターゲットは、特定のアーキテクチャで使用するための追加のメモリ順序をサポートするかもしれない。 これらの詳細については、対象のドキュメントを参照せよ。

アトミックオペレーションは、コードの動きを制限し、スレッド間の同期（例えばフェンス）のためのハードウェア命令にマッピングすることがありうる。 これがどの程度起こるかは、ここでは強さの昇順で列挙されているメモリの順序によって制御される。 各メモリの順序の説明は、その効果を概略的に示すためのものであり、仕様ではない。 正確なセマンティクスについては、C++ 11のメモリモデルを参照せよ。

@table  @code
@item __ATOMIC_RELAXED
スレッド間順序制約がないことを暗黙に指定する。
@item __ATOMIC_CONSUME
これは現在、@code{memory_order_consume}に対するC++11のセマンティクスの欠如のために、より強力な@code{__ATOMIC_ACQUIRE}メモリ命令を使用して実装されている。
@item __ATOMIC_ACQUIRE
解放（またはそれ以上）のセマンティックストアからこのロード取得までのスレッド間の発生前制約を作成する。 操作の前にコードを持ち上げるのを防ぐことができる
@item __ATOMIC_RELEASE
この解放ストアから読み取ったセマンティックロードを取得するためにスレッド間の発生前制約を作成する。 操作後にコードが沈むのを防ぐことができる。
@item __ATOMIC_ACQ_REL
@code{__ATOMIC_ACQUIRE}と@code{__ATOMIC_RELEASE}の両方の効果を組み合わせる。
@item __ATOMIC_SEQ_CST
その他すべての@code{__ATOMIC_SEQ_CST}操作で順序付けを強制します。
@end table
C++ 11メモリモデルにおいて、@emph{フェンス}（例えば、@samp{__atomic_thread_fence}）は、特定のメモリ位置（例えば、アトミックロード）上の他のアトミック演算と組み合わせて有効であることに注意すること。 特定のメモリ位置に対する操作は、必ずしも同じように他の操作に影響するとは限らない。

ターゲット・アーキテクチャーは、アトミック組み込み関数ごとに独自のパターンを提供することが推奨される。 ターゲットが指定されていない場合は、@samp{__sync}アトミック組み込み関数の元の非メモリモデルセットが、適切な動作を達成するために必要な同期フェンスとともに使用される。 この場合の実行には、組み込み関数と同じ制限が適用される。

ロックフリーの命令シーケンスを提供するパターンまたはメカニズムがない場合、実行時に解決される同じパラメータを持つ外部ルーチンが呼び出される。

これらの組み込み関数のパターンを実装する場合、最も厳しい@code{__ATOMIC_SEQ_CST}メモリの順序を実装している限り、メモリ順序パラメータは無視できる。 他のメモリ順序のどれもがこのメモリ順序で正しく実行されるが、緩和された要件のより適切な実装で可能な限り効率的には実行されない可能性がある。

C++11標準では、コンパイル時ではなく実行時にメモリの順序パラメータを決めることができる。 これらの組み込み関数は、ランタイムライブラリ呼び出しを呼び出すか、switch文をインライン化するのではなく、ランタイム値を@code{__ATOMIC_SEQ_CST}にマップする。 これは標準に準拠し、安全であり、今のところ最も簡単なアプローチである。

メモリ順序パラメータは符号付きintだが、メモリ順序のために予約されているのは下位16ビットだけである。 符号付き整数の残りはターゲット用に予約されていて、0である必要がある。あらかじめ定義されたアトミック値を使用すると、適切な使用が保証される。

@deftypefn {Built-in Function} @var{type} __atomic_load_n (@var{type} *ptr, int memorder)
この組み込み関数はアトミックロード命令を実装する。それは@code{*@var{ptr}}の内容を返す。

正当なメモリ順序変種は@code{__ATOMIC_RELAXED}、@code{__ATOMIC_SEQ_CST}、@code{__ATOMIC_ACQUIRE}、@code{__ATOMIC_CONSUME}である。

@end deftypefn

@deftypefn {Built-in Function} void __atomic_load (@var{type} *ptr, @var{type} *ret, int memorder)
これはアトミック・ロードの汎用バージョンである。それは@code{*@var{ret}}での@code{*@var{ptr}}の内容を返す。

@end deftypefn

@deftypefn {Built-in Function} void __atomic_store_n (@var{type} *ptr, @var{type} val, int memorder)
この組み込み関数はアトミックストア命令を実装する。それは@code{@var{val}}を@code{*@var{ptr}}に返す。

正当なメモリ順序変種は@code{__ATOMIC_RELAXED}、@code{__ATOMIC_SEQ_CST}、@code{__ATOMIC_RELEASE}である。

@end deftypefn

@deftypefn {Built-in Function} void __atomic_store (@var{type} *ptr, @var{type} *val, int memorder)
これはアトミックストアの汎用バージョンである。それは@code{*@var{val}}の値を@code{*@var{ptr}}へ格納する。

@end deftypefn

@deftypefn {Built-in Function} @var{type} __atomic_exchange_n (@var{type} *ptr, @var{type} val, int memorder)
この組み込み関数はアトミック交換命令を実装する。それは@var{val}を@code{*@var{ptr}}へと書き、@code{*@var{ptr}}の前の内容を返す。

正当なメモリ順序変種は@code{__ATOMIC_RELAXED}、@code{__ATOMIC_SEQ_CST}、@code{__ATOMIC_ACQUIRE}、@code{__ATOMIC_RELEASE}、@code{__ATOMIC_ACQ_REL}である。

@end deftypefn

@deftypefn {Built-in Function} void __atomic_exchange (@var{type} *ptr, @var{type} *val, @var{type} *ret, int memorder)
これはアトミック交換の汎用バージョンである。それは@code{*@var{val}}の内容を@code{*@var{ptr}}へと格納する。@code{*@var{ptr}}のもとの値は@code{*@var{ret}}へとコピーされる。

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_compare_exchange_n (@var{type} *ptr, @var{type} *expected, @var{type} desired, bool weak, int success_memorder, int failure_memorder)
この組み込み関数はアトミックの比較・交換操作を実装する。これは@code{*@var{ptr}}の内容を@code{*@var{expected}}と比較する。もし等しければ操作は、@var{desired}を@code{*@var{ptr}}へと書き出す@emph{読み込み・修正・書き出し}である。もし等しくなければ、操作を@emph{読み出し}であり、@code{*@var{ptr}}の現在の内容が@code{*@var{expected}}へと書かれる。@var{week}は見せかけの失敗をするかもしれない弱い比較交換の時ではtrueであり、決して見せかけの失敗をしない強いバリエーションではfalseである。多くのターゲットでは強いバリエーションのみを提供して、パラメータは無視される。疑いがあるときには、強いバリエーションを使うこと。

@var{desired}が@code{*@var{ptr}}に書き込まれると、trueが返される。メモリは@var{success_memorder}で指定されたメモリ順序に従って影響を受ける。 ここで使用できるメモリ順序に制限はない。

それ以外の場合は、falseが返され、メモリは@var{failure_memorder}に従って影響を受ける。 このメモリの順序は@code{__ATOMIC_RELEASE}および@code{__ATOMIC_ACQ_REL}であることはできない。 また、@var{success_memorder}で指定されたものよりも強力な順序にすることもできない。

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_compare_exchange (@var{type} *ptr, @var{type} *expected, @var{type} *desired, bool weak, int success_memorder, int failure_memorder)
この組み込み関数は、@code{__atomic_compare_exchange}の汎用バージョンを実装する。 この関数は、目的の値もポインタであることを除いて、実質的に@code{__atomic_compare_exchange_n}と同じである。

@end deftypefn

@deftypefn {Built-in Function} @var{type} __atomic_add_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_sub_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_and_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_xor_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_or_fetch (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_nand_fetch (@var{type} *ptr, @var{type} val, int memorder)
これらの組み込み関数は、名前が示す操作を実行し、操作の結果を返す。 ポインタ引数の操作は、オペランドが@code{uintptr_t}型であるかのように実行される。 つまり、ポインタが指している型のサイズによってはスケーリングされない。

@smallexample
@{ *ptr @var{op}= val; return *ptr; @}
@end smallexample

最初の引数が指すオブジェクトは、整数型またはポインタ型でなければならない。 ブール型であってはならない。 すべてのメモリ順序が有効である。

@end deftypefn

@deftypefn {Built-in Function} @var{type} __atomic_fetch_add (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_sub (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_and (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_xor (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_or (@var{type} *ptr, @var{type} val, int memorder)
@deftypefnx {Built-in Function} @var{type} __atomic_fetch_nand (@var{type} *ptr, @var{type} val, int memorder)
これらの組み込み関数は、名前で示される操作を実行し、以前に@code{*@var{ptr}}にあった値を返す。 ポインタ引数の操作は、オペランドが@code{uintptr_t}型であるかのように実行される。 つまり、ポインタが指している型のサイズによってはスケーリングされない。

@smallexample
@{ tmp = *ptr; *ptr @var{op}= val; return tmp; @}
@end smallexample

引数に関する制約は、対応する@code{__atomic_op_fetch}組み込み関数の場合と同じである。 すべてのメモリ順序が有効である。

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_test_and_set (void *ptr, int memorder)

この組み込み関数は、@code{*@var{ptr}}のバイトに対してアトミックなテスト・アンド・セット操作を実行する。 バイトは、ある実装で定義された非ゼロの"set"値に設定され、前の内容が "set"だった場合にのみ、戻り値は@code{true}になる。これは、@code{bool}型または@code{char}型のオペランドに対してのみ使用すべきである。 他のタイプの場合、値の一部のみを設定されるかもしれない。

すべてのメモリ順序が有効である。
 
@end deftypefn

@deftypefn {Built-in Function} void __atomic_clear (bool *ptr, int memorder)

この組み込み関数は、@code{*@var{ptr}}に対してアトミックなクリア操作を実行する。 操作後、@code{*@var{ptr}}には0が入る。これは、@code{bool}型または@code{char}型と@code{__atomic_test_and_set}との組み合わせでのみ使用すべきである。他のタイプの場合は、部分的にしかクリアされないかもしれないできません。 タイプが@code{bool}でないなら、@code{__atomic_store}を使用すること。

正当なメモリ順序変種は@code{__ATOMIC_RELAXED}、@code{__ATOMIC_SEQ_CST}、@code{__ATOMIC_RELEASE}である。

@end deftypefn

@deftypefn {Built-in Function} void __atomic_thread_fence (int memorder)

この組み込み関数は、指定されたメモリ順序に基づいてスレッド間の同期フェンスとして機能する。

すべてのメモリ順序が有効である。

@end deftypefn

@deftypefn {Built-in Function} void __atomic_signal_fence (int memorder)

この組み込み関数は、同じスレッドに基づくスレッドハンドラとシグナルハンドラ間の同期フェンスとして機能する。

すべてのメモリ順序が有効である。

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_always_lock_free (size_t size,  void *ptr)

この組み込み関数は、@var{size}バイトのオブジェクトが常にターゲットアーキテクチャのロックフリーアトミック命令を生成する場合にtrueを返す。@var{size}はコンパイル時定数に解決されなければならず、結果はコンパイル時定数にも解決される。

@var{ptr}は、アラインメントを決定するために使用されるオブジェクトへのオプションのポインタである。 0の値は、通常のアラインメントを使用する必要があることを示す。 コンパイラはこのパラメータも無視することがある。

@smallexample
if (__atomic_always_lock_free (sizeof (long long), 0))
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} bool __atomic_is_lock_free (size_t size, void *ptr)

この組み込み関数は、@var{size}バイトのオブジェクトが常にターゲットアーキテクチャのロックフリーアトミック命令を生成する場合にtrueを返す。 組み込み関数がロックフリーでないとわかっていない場合は、@code{__atomic_is_lock_free}というランタイムルーチンが呼び出される。

@var{ptr}は、アラインメントを決定するために使用されるオブジェクトへのオプションのポインタである。 0の値は、通常のアラインメントを使用する必要があることを示す。 コンパイラはこのパラメータも無視するかもしれない。
@end deftypefn

@node Integer Overflow Builtins
@section オーバーフローチェックつきの算術を実行する組み込み関数

次の組み込み関数を使用すると、簡単な算術演算と一緒に操作がオーバーフローしたかどうかをチェックすることができる。

@deftypefn {Built-in Function} bool __builtin_add_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)
@deftypefnx {Built-in Function} bool __builtin_sadd_overflow (int a, int b, int *res)
@deftypefnx {Built-in Function} bool __builtin_saddl_overflow (long int a, long int b, long int *res)
@deftypefnx {Built-in Function} bool __builtin_saddll_overflow (long long int a, long long int b, long long int *res)
@deftypefnx {Built-in Function} bool __builtin_uadd_overflow (unsigned int a, unsigned int b, unsigned int *res)
@deftypefnx {Built-in Function} bool __builtin_uaddl_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)
@deftypefnx {Built-in Function} bool __builtin_uaddll_overflow (unsigned long long int a, unsigned long long int b, unsigned long long int *res)

これらの組み込み関数は、最初の2つのオペランドを無限精度の符号付き型に昇格させ、昇格したオペランドに対して加算を実行する。 その結果は、3番目のポインタ引数が指す型にキャストされ、そこに格納される。格納された結果が無限精度結果と等しい場合、組み込み関数はfalseを返し、そうでない場合はtrueを返す。 加算は無限の符号付き精度で実行されるため、これらの組み込み関数はすべての引数値に対して完全に定義された動作をする。

最初の組み込み関数はオペランドの任意の整数型を許可し、結果型は列挙型またはブール型以外の整数型へのポインタでなければならない。組み込み関数の残りの部分は明示的な整数型を持つ。

コンパイラは、可能であればこれらのビルトイン関数をハードウェア命令を使用して、実装しようとする（加算後のオーバーフローでの条件ジャンプ、キャリーでの条件付きジャンプなど）。

@end deftypefn

@deftypefn {Built-in Function} bool __builtin_sub_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)
@deftypefnx {Built-in Function} bool __builtin_ssub_overflow (int a, int b, int *res)
@deftypefnx {Built-in Function} bool __builtin_ssubl_overflow (long int a, long int b, long int *res)
@deftypefnx {Built-in Function} bool __builtin_ssubll_overflow (long long int a, long long int b, long long int *res)
@deftypefnx {Built-in Function} bool __builtin_usub_overflow (unsigned int a, unsigned int b, unsigned int *res)
@deftypefnx {Built-in Function} bool __builtin_usubl_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)
@deftypefnx {Built-in Function} bool __builtin_usubll_overflow (unsigned long long int a, unsigned long long int b, unsigned long long int *res)

これらの組み込み関数は、上記の組み込み関数のチェックのオーバーフローと似ているが、加算ではなく減算を行い、最初の引数から2番めの引数を減算することが異なる。

@end deftypefn

@deftypefn {Built-in Function} bool __builtin_mul_overflow (@var{type1} a, @var{type2} b, @var{type3} *res)
@deftypefnx {Built-in Function} bool __builtin_smul_overflow (int a, int b, int *res)
@deftypefnx {Built-in Function} bool __builtin_smull_overflow (long int a, long int b, long int *res)
@deftypefnx {Built-in Function} bool __builtin_smulll_overflow (long long int a, long long int b, long long int *res)
@deftypefnx {Built-in Function} bool __builtin_umul_overflow (unsigned int a, unsigned int b, unsigned int *res)
@deftypefnx {Built-in Function} bool __builtin_umull_overflow (unsigned long int a, unsigned long int b, unsigned long int *res)
@deftypefnx {Built-in Function} bool __builtin_umulll_overflow (unsigned long long int a, unsigned long long int b, unsigned long long int *res)

これらの組み込み関数は、加算の代わりに乗算を実行する点を除いて、上記のビルトイン関数のオーバーフローチェックと同様である。

@end deftypefn

次のビルトイン関数は、単純な算術演算がオーバフローするかどうかのチェックを可能にする。

@deftypefn {Built-in Function} bool __builtin_add_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)
@deftypefnx {Built-in Function} bool __builtin_sub_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)
@deftypefnx {Built-in Function} bool __builtin_mul_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)

これらの組み込み関数は、算術演算の結果をどこにも格納せず、最後の引数がポインタではなく、列挙型またはブール型以外の整数型の式であることを除いて、@code{__builtin_add_overflow}、@code {__builtin_sub_overflow}、または@code {__builtin_mul_overflow}と似ている。

組み込み関数は、最初の2つのオペランドを無限精度の符号付き型に昇格させ、昇格したオペランドに対して加算を実行する。 結果は3番目の引数の型にキャストされる。 キャスト結果が無限精度結果と等しい場合、組み込み関数はfalseを返し、そうでない場合はtrueを返す。3番目の引数の値は無視され、3番目の引数の副作用のみが評価され、最後の引数に対して整数引数の昇格は実行されない。3番目の引数がビットフィールドの場合、結果キャストに使用される型は、基になる型の精度と符号ではなく、指定されたビットフィールドの精度と符号を持つ。

例えば、以下のマクロは、コンパイル時に、2つの定数がオーバーフローするかどうかをポータブルにチェックし、安全であることがわかっていて、@option{-Woverflow}警告をトリガしない場合にのみ加算を実行できる。

@smallexample
#define INT_ADD_OVERFLOW_P(a, b) \
   __builtin_add_overflow_p (a, b, (__typeof__ ((a) + (b))) 0)

enum @{
    A = INT_MAX, B = 3,
    C = INT_ADD_OVERFLOW_P (A, B) ? 0 : A + B,
    D = __builtin_add_overflow_p (1, SCHAR_MAX, (signed char) 0)
@};
@end smallexample

コンパイラは、可能であれば、ハードウェア命令を使用してこれらのビルトイン関数を実装しようとする（加算後のオーバーフローでの条件ジャンプ、キャリーでの条件付きジャンプなど）。
 
@end deftypefn

@node x86 specific memory model extensions for transactional memory
@section x86固有のトランザクションメモリ用のメモリモデル拡張

x86アーキテクチャーは、ハードウェア・ロック除去用のクリティカル・セクションをマークする追加のメモリー順序付けフラグをサポートしている。これらは、アトミック組み込み関数に対する既存のメモリー順序に加えて指定する必要がある。

@table @code
@item __ATOMIC_HLE_ACQUIRE
ロック変数でのロック除去を開始する。メモリ順序は@code{__ATOMIC_ACQUIRE}以上に強くなくてはならない。
@item __ATOMIC_HLE_RELEASE
ロック変数でのロック除去を終了する。メモリ順序は@code{__ATOMIC_RELEASE}以上に強くなくてはならない。
@end table

ロック獲得に失敗した場合、良いパフォーマンスですぐにトランザクションを中断する必要がある。 これは@code{_mm_pause}で行うことができる。

@smallexample
#include <immintrin.h> // For _mm_pause

int lockvar;

/* Acquire lock with lock elision */
while (__atomic_exchange_n(&lockvar, 1, __ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))
    _mm_pause(); /* Abort failed transaction */
...
/* Free lock with lock elision */
__atomic_store_n(&lockvar, 0, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);
@end smallexample

@node Object Size Checking
@section オブジェクトサイズチェック組み込み関数
@findex __builtin_object_size
@findex __builtin___memcpy_chk
@findex __builtin___mempcpy_chk
@findex __builtin___memmove_chk
@findex __builtin___memset_chk
@findex __builtin___strcpy_chk
@findex __builtin___stpcpy_chk
@findex __builtin___strncpy_chk
@findex __builtin___strcat_chk
@findex __builtin___strncat_chk
@findex __builtin___sprintf_chk
@findex __builtin___snprintf_chk
@findex __builtin___vsprintf_chk
@findex __builtin___vsnprintf_chk
@findex __builtin___printf_chk
@findex __builtin___vprintf_chk
@findex __builtin___fprintf_chk
@findex __builtin___vfprintf_chk

GCCは、データが書き込まれようとしているオブジェクトのサイズを判断し、サイズが不十分な場合に書き込みを防止することによって、バッファオーバーフロー攻撃を防ぐことができる、限られたバッファオーバーフロー保護メカニズムを実装している。 以下に説明する組み込み関数は、一緒に使用した場合、および最適化が有効な場合に最良の結果をもたらす。たとえば、関数の境界を越えてオブジェクトのサイズを検出したり、ポインタの割り当てに従わないようにするには、@option{-O2}で有効になっているさまざまな最適化パスを使用する。ただし、限られた範囲では、最適化を行わなくても使用できる。

@deftypefn {Built-in Function} {size_t} __builtin_object_size (const void * @var{ptr}, int @var{type})
（コンパイル時にわかっている場合）@var{ptr}から@var{ptr}ポインタが指すオブジェクトの終わりまで定数バイト数を返すビルトイン構造である。 @code{__builtin_object_size}は副作用のために引数を評価しない。 それらに副作用がある場合、@var{type}0または1には@code{(size_t)-1}を、@var{type}2または3には@code{(size_t)0}を返す。もし@var{ptr}が指すことができる複数のオブジェクトがあり、それらがすべてコンパイル時にわかっている場合、返される数値は、@var {type}＆2が0で、 非ゼロで最小値の場合は、それらのオブジェクトの残りのバイト数の最大値である。 @var{type}＆2が0でゼロ以外ならば、それらのオブジェクトの残っているバイト数の最大値が返される。 コンパイル時に@var{ptr}がどのオブジェクトを指しているのかを判断できない場合、@code{__builtin_object_size}は@var{type}0または1には@code{(size_t)-1}を、@var{type}2または3には@code{(size_t)0}を返す。

@var{type}は0から3までの整数定数である。最下位ビットがクリアされている場合、オブジェクトは全体変数である。設定されている場合、最も近い周囲のサブオブジェクトはポインタが指すオブジェクトと見なされる。2番目のビットは、残りのバイトの最大値または最小値が計算されるかどうかを決定する。

@smallexample
struct V @{ char buf1[10]; int b; char buf2[10]; @} var;
char *p = &var.buf1[1], *q = &var.b;

/* Here the object p points to is var.  */
assert (__builtin_object_size (p, 0) == sizeof (var) - 1);
/* The subobject p points to is var.buf1.  */
assert (__builtin_object_size (p, 1) == sizeof (var.buf1) - 1);
/* The object q points to is var.  */
assert (__builtin_object_size (q, 0)
        == (char *) (&var + 1) - (char *) &var.b);
/* The subobject q points to is var.b.  */
assert (__builtin_object_size (q, 1) == sizeof (var.b));
@end smallexample
@end deftypefn

@code{memcpy} @code{__builtin___memcpy_chk}ビルトインなど、多くの一般的な文字列操作関数用に組み込み関数が追加されている。 このビルトインには最後の追加引数がある。これは、@var{dest}引数が指すオブジェクトに残っているバイト数である。サイズがわからない場合は@code{(size_t)-1}になる。

組み込み関数は、最後の引数が@code {(size_t)-1}の場合、または、コンパイル時に宛先オブジェクトがオーバーフローしないことがわかっている場合は@code{memcpy}のような通常の文字列関数に最適化される。コンパイラがコンパイル時にオブジェクトが常にオーバーフローすると判断できる場合は、警告を出す。

意図される用途は、例えば：

@smallexample
#undef memcpy
#define bos0(dest) __builtin_object_size (dest, 0)
#define memcpy(dest, src, n) \
  __builtin___memcpy_chk (dest, src, n, bos0 (dest))

char *volatile p;
char buf[10];
/* It is unknown what object p points to, so this is optimized
   into plain memcpy - no checking is possible.  */
memcpy (p, "abcde", n);
/* Destination is known and length too.  It is known at compile
   time there will be no overflow.  */
memcpy (&buf[5], "abcde", 5);
/* Destination is known, but the length is not known at compile time.
   This will result in __memcpy_chk call that can check for overflow
   at run time.  */
memcpy (&buf[5], "abcde", n);
/* Destination is known and it is known at compile time there will
   be overflow.  There will be a warning and __memcpy_chk call that
   will abort the program at run time.  */
memcpy (&buf[6], "abcde", 5);
@end smallexample

このような組み込み関数は、@code{memcpy}、@code{mempcpy}、@code{memmove}、@code{memset}、@code{strcpy}、@code{stpcpy}、@code{strncpy}、
@code{strcat}、@code{strncat}である。

フォーマットされた出力関数の組み込み関数もチェックする。
@smallexample
int __builtin___sprintf_chk (char *s, int flag, size_t os, const char *fmt, ...);
int __builtin___snprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                              const char *fmt, ...);
int __builtin___vsprintf_chk (char *s, int flag, size_t os, const char *fmt,
                              va_list ap);
int __builtin___vsnprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                               const char *fmt, va_list ap);
@end smallexample

追加された@var{flag}引数は変更されずに@code{__sprintf_chk}などの関数に渡される。@code{％n}の処理方法など、チェック機能がどのような追加のセキュリティ対策をとるかについての実装固有のフラグを含めることができる。

@var{os}引数は、他の組み込み関数と同様に、@var{s}が指すオブジェクトのサイズである。 @var{os}が@code{(size_t)-1}の場合、組み込み関数は@var{flag}が0の場合にのみ非検査関数に最適化され、 それ以外の場合は、@code{(size_t)-1}に@var{os}引数を設定してチェック関数を呼び出す。

これに加えて、組み込み関数@code{__builtin___printf_chk}、@code {__builtin___vprintf_chk}、@code {__builtin___fprintf_chk}と@code {__builtin___vfprintf_chk}のチェックがある。これらは、@var{fmt}の書式文字列の直前に@var{flag}という引数が1つだけある。 コンパイラが@code{fputc}などの関数に最適化できれば、そうする。そうでなければチェック関数が呼び出され、@var{flag}引数が渡される。

@node Pointer Bounds Checker builtins
@section ポインタ境界チェッカ組み込み関数
@cindex Pointer Bounds Checker builtins
@findex __builtin___bnd_set_ptr_bounds
@findex __builtin___bnd_narrow_ptr_bounds
@findex __builtin___bnd_copy_ptr_bounds
@findex __builtin___bnd_init_ptr_bounds
@findex __builtin___bnd_null_ptr_bounds
@findex __builtin___bnd_store_ptr_bounds
@findex __builtin___bnd_chk_ptr_lbounds
@findex __builtin___bnd_chk_ptr_ubounds
@findex __builtin___bnd_chk_ptr_bounds
@findex __builtin___bnd_get_ptr_lbound
@findex __builtin___bnd_get_ptr_ubound

GCCは、Pointer Bounds Checker計測を制御する組み込み関数のセットを提供する。 Pointer Bounds Checkerをオフにしてコンパイルしても（@option{-fno-check-pointer-bounds}）、すべてのPointer Bounds Checker組み込み関数を使用できることに注意すること。このような場合は、下記のように動作が異なる場合がある。

@deftypefn {Built-in Function} {void *} __builtin___bnd_set_ptr_bounds (const void *@var{q}, size_t @var{size})

この組み込み関数は、@var{q}の値を持つ新しいポインタを返し、それをbounds [@var{q}、@var{q} + @var{size} -1]に関連付ける。 Pointer Bounds Checkerをオフにすると、ビルトイン関数は最初の引数を返す。

@smallexample
extern void *__wrap_malloc (size_t n)
@{
  void *p = (void *)__real_malloc (n);
  if (!p) return __builtin___bnd_null_ptr_bounds (p);
  return __builtin___bnd_set_ptr_bounds (p, n);
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_narrow_ptr_bounds (const void *@var{p}, const void *@var{q}, size_t  @var{size})

この組み込み関数は、@var{p}の値を持つ新しいポインタを返し、それを@var{q}に関連付けられた境界と境界[@var{p}、@var{p} + @var{size} - 1]の交差によって形成される狭められた境界に関連付ける。Pointer Bounds Checkerをオフにすると、ビルトイン関数は最初の引数を返す。

@smallexample
void init_objects (object *objs, size_t size)
@{
  size_t i;
  /* Initialize objects one-by-one passing pointers with bounds of 
     an object, not the full array of objects.  */
  for (i = 0; i < size; i++)
    init_object (__builtin___bnd_narrow_ptr_bounds (objs + i, objs,
                                                    sizeof(object)));
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_copy_ptr_bounds (const void *@var{q}, const void *@var{r})

この組み込み関数は、@var{q}の値を持つ新しいポインタを返し、ポインタ@var{r}にすでに関連付けられている境界に関連付ける。Pointer Bounds Checkerをオフにすると、ビルトイン関数は最初の引数を返す。

@smallexample
/* Here is a way to get pointer to object's field but
   still with the full object's bounds.  */
int *field_ptr = __builtin___bnd_copy_ptr_bounds (&objptr->int_field, 
                                                  objptr);
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_init_ptr_bounds (const void *@var{q})

この組み込み関数は、@var{q}の値を持つ新しいポインタを返し、それを（全メモリアクセスを許可する）INIT境界に関連付ける。Pointer Bounds Checkerをオフにすると、ビルトイン関数は最初の引数を返す。

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin___bnd_null_ptr_bounds (const void *@var{q})

この組み込み関数は、@var{q}の値を持つ新しいポインタを返し、それを（メモリアクセスを許可しない）NULL境界に関連付ける。Pointer Bounds Checkerをオフにすると、ビルトイン関数は最初の引数を返す。

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_store_ptr_bounds (const void **@var{ptr_addr}, const void *@var{ptr_val})

この組み込み関数は、ポインタ@var{ptr_val}および位置@var{ptr_addr}に関連付けられた境界を境界テーブルに格納する。これはポインタが整数としてコピーされたときに関連するポインタのメモリに触れることなく、レガシーコードから境界を伝播するのに便利である。 Pointer Bounds Checkerをオフにすると、ビルトイン関数呼び出しは無視される。

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_lbounds (const void *@var{q})

この組み込み関数は、ポインタ@var{q}が関連する境界の下限内にあるかどうかをチェックする。 Pointer Bounds Checkerをオフにすると、ビルトイン関数呼び出しは無視される。

@smallexample
extern void *__wrap_memset (void *dst, int c, size_t len)
@{
  if (len > 0)
    @{
      __builtin___bnd_chk_ptr_lbounds (dst);
      __builtin___bnd_chk_ptr_ubounds ((char *)dst + len - 1);
      __real_memset (dst, c, len);
    @}
  return dst;
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_ubounds (const void *@var{q})

この組み込み関数は、ポインタ@var{q}が関連する境界の上限内にあるかどうかをチェックする。 Pointer Bounds Checkerをオフにすると、ビルトイン関数呼び出しは無視される。

@end deftypefn

@deftypefn {Built-in Function} void __builtin___bnd_chk_ptr_bounds (const void *@var{q}, size_t @var{size})

この組み込み関数は、[@var{q}、@var{q} + @var{size} - 1]が@var {q}に関連付けられた上限と下限の範囲内にあるかどうかをチェックする。 Pointer Bounds Checkerをオフにすると、ビルトイン関数呼び出しは無視される。

@smallexample
extern void *__wrap_memcpy (void *dst, const void *src, size_t n)
@{
  if (n > 0)
    @{
      __bnd_chk_ptr_bounds (dst, n);
      __bnd_chk_ptr_bounds (src, n);
      __real_memcpy (dst, src, n);
    @}
  return dst;
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {const void *} __builtin___bnd_get_ptr_lbound (const void *@var{q})

この組み込み関数はポインタ@var{q}に関連付けられた下限をポインタ値として返します。これは@code{printf}を使ってデバッグするのに便利である。 Pointer Bounds Checkerをオフにすると、組み込み関数は0を返す。

@smallexample
void *lb = __builtin___bnd_get_ptr_lbound (q);
void *ub = __builtin___bnd_get_ptr_ubound (q);
printf ("q = %p  lb(q) = %p  ub(q) = %p", q, lb, ub);
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {const void *} __builtin___bnd_get_ptr_ubound (const void *@var{q})

この組み込み関数は、ポインタ@var{q}に関連付けられた上限（ポインタ）を返す。 Pointer Bounds Checkerをオフにすると、組み込み関数は-1を返す。

@end deftypefn

@node Other Builtins
@section GCCで提供されている他の組み込み関数
@cindex built-in functions
@findex __builtin_alloca
@findex __builtin_alloca_with_align
@findex __builtin_alloca_with_align_and_max
@findex __builtin_call_with_static_chain
@findex __builtin_extend_pointer
@findex __builtin_fpclassify
@findex __builtin_isfinite
@findex __builtin_isnormal
@findex __builtin_isgreater
@findex __builtin_isgreaterequal
@findex __builtin_isinf_sign
@findex __builtin_isless
@findex __builtin_islessequal
@findex __builtin_islessgreater
@findex __builtin_isunordered
@findex __builtin_powi
@findex __builtin_powif
@findex __builtin_powil
@findex _Exit
@findex _exit
@findex abort
@findex abs
@findex acos
@findex acosf
@findex acosh
@findex acoshf
@findex acoshl
@findex acosl
@findex alloca
@findex asin
@findex asinf
@findex asinh
@findex asinhf
@findex asinhl
@findex asinl
@findex atan
@findex atan2
@findex atan2f
@findex atan2l
@findex atanf
@findex atanh
@findex atanhf
@findex atanhl
@findex atanl
@findex bcmp
@findex bzero
@findex cabs
@findex cabsf
@findex cabsl
@findex cacos
@findex cacosf
@findex cacosh
@findex cacoshf
@findex cacoshl
@findex cacosl
@findex calloc
@findex carg
@findex cargf
@findex cargl
@findex casin
@findex casinf
@findex casinh
@findex casinhf
@findex casinhl
@findex casinl
@findex catan
@findex catanf
@findex catanh
@findex catanhf
@findex catanhl
@findex catanl
@findex cbrt
@findex cbrtf
@findex cbrtl
@findex ccos
@findex ccosf
@findex ccosh
@findex ccoshf
@findex ccoshl
@findex ccosl
@findex ceil
@findex ceilf
@findex ceill
@findex cexp
@findex cexpf
@findex cexpl
@findex cimag
@findex cimagf
@findex cimagl
@findex clog
@findex clogf
@findex clogl
@findex clog10
@findex clog10f
@findex clog10l
@findex conj
@findex conjf
@findex conjl
@findex copysign
@findex copysignf
@findex copysignl
@findex cos
@findex cosf
@findex cosh
@findex coshf
@findex coshl
@findex cosl
@findex cpow
@findex cpowf
@findex cpowl
@findex cproj
@findex cprojf
@findex cprojl
@findex creal
@findex crealf
@findex creall
@findex csin
@findex csinf
@findex csinh
@findex csinhf
@findex csinhl
@findex csinl
@findex csqrt
@findex csqrtf
@findex csqrtl
@findex ctan
@findex ctanf
@findex ctanh
@findex ctanhf
@findex ctanhl
@findex ctanl
@findex dcgettext
@findex dgettext
@findex drem
@findex dremf
@findex dreml
@findex erf
@findex erfc
@findex erfcf
@findex erfcl
@findex erff
@findex erfl
@findex exit
@findex exp
@findex exp10
@findex exp10f
@findex exp10l
@findex exp2
@findex exp2f
@findex exp2l
@findex expf
@findex expl
@findex expm1
@findex expm1f
@findex expm1l
@findex fabs
@findex fabsf
@findex fabsl
@findex fdim
@findex fdimf
@findex fdiml
@findex ffs
@findex floor
@findex floorf
@findex floorl
@findex fma
@findex fmaf
@findex fmal
@findex fmax
@findex fmaxf
@findex fmaxl
@findex fmin
@findex fminf
@findex fminl
@findex fmod
@findex fmodf
@findex fmodl
@findex fprintf
@findex fprintf_unlocked
@findex fputs
@findex fputs_unlocked
@findex frexp
@findex frexpf
@findex frexpl
@findex fscanf
@findex gamma
@findex gammaf
@findex gammal
@findex gamma_r
@findex gammaf_r
@findex gammal_r
@findex gettext
@findex hypot
@findex hypotf
@findex hypotl
@findex ilogb
@findex ilogbf
@findex ilogbl
@findex imaxabs
@findex index
@findex isalnum
@findex isalpha
@findex isascii
@findex isblank
@findex iscntrl
@findex isdigit
@findex isgraph
@findex islower
@findex isprint
@findex ispunct
@findex isspace
@findex isupper
@findex iswalnum
@findex iswalpha
@findex iswblank
@findex iswcntrl
@findex iswdigit
@findex iswgraph
@findex iswlower
@findex iswprint
@findex iswpunct
@findex iswspace
@findex iswupper
@findex iswxdigit
@findex isxdigit
@findex j0
@findex j0f
@findex j0l
@findex j1
@findex j1f
@findex j1l
@findex jn
@findex jnf
@findex jnl
@findex labs
@findex ldexp
@findex ldexpf
@findex ldexpl
@findex lgamma
@findex lgammaf
@findex lgammal
@findex lgamma_r
@findex lgammaf_r
@findex lgammal_r
@findex llabs
@findex llrint
@findex llrintf
@findex llrintl
@findex llround
@findex llroundf
@findex llroundl
@findex log
@findex log10
@findex log10f
@findex log10l
@findex log1p
@findex log1pf
@findex log1pl
@findex log2
@findex log2f
@findex log2l
@findex logb
@findex logbf
@findex logbl
@findex logf
@findex logl
@findex lrint
@findex lrintf
@findex lrintl
@findex lround
@findex lroundf
@findex lroundl
@findex malloc
@findex memchr
@findex memcmp
@findex memcpy
@findex mempcpy
@findex memset
@findex modf
@findex modff
@findex modfl
@findex nearbyint
@findex nearbyintf
@findex nearbyintl
@findex nextafter
@findex nextafterf
@findex nextafterl
@findex nexttoward
@findex nexttowardf
@findex nexttowardl
@findex pow
@findex pow10
@findex pow10f
@findex pow10l
@findex powf
@findex powl
@findex printf
@findex printf_unlocked
@findex putchar
@findex puts
@findex remainder
@findex remainderf
@findex remainderl
@findex remquo
@findex remquof
@findex remquol
@findex rindex
@findex rint
@findex rintf
@findex rintl
@findex round
@findex roundf
@findex roundl
@findex scalb
@findex scalbf
@findex scalbl
@findex scalbln
@findex scalblnf
@findex scalblnf
@findex scalbn
@findex scalbnf
@findex scanfnl
@findex signbit
@findex signbitf
@findex signbitl
@findex signbitd32
@findex signbitd64
@findex signbitd128
@findex significand
@findex significandf
@findex significandl
@findex sin
@findex sincos
@findex sincosf
@findex sincosl
@findex sinf
@findex sinh
@findex sinhf
@findex sinhl
@findex sinl
@findex snprintf
@findex sprintf
@findex sqrt
@findex sqrtf
@findex sqrtl
@findex sscanf
@findex stpcpy
@findex stpncpy
@findex strcasecmp
@findex strcat
@findex strchr
@findex strcmp
@findex strcpy
@findex strcspn
@findex strdup
@findex strfmon
@findex strftime
@findex strlen
@findex strncasecmp
@findex strncat
@findex strncmp
@findex strncpy
@findex strndup
@findex strpbrk
@findex strrchr
@findex strspn
@findex strstr
@findex tan
@findex tanf
@findex tanh
@findex tanhf
@findex tanhl
@findex tanl
@findex tgamma
@findex tgammaf
@findex tgammal
@findex toascii
@findex tolower
@findex toupper
@findex towlower
@findex towupper
@findex trunc
@findex truncf
@findex truncl
@findex vfprintf
@findex vfscanf
@findex vprintf
@findex vscanf
@findex vsnprintf
@findex vsprintf
@findex vsscanf
@findex y0
@findex y0f
@findex y0l
@findex y1
@findex y1f
@findex y1l
@findex yn
@findex ynf
@findex ynl

GCCは、上記以外の多数の組み込み関数を提供する。 これらのうちのいくつかは、例外や可変長引数リストの処理における内部使用のためのものであり、時折変更される可能性があるためここには記載されていない。 これらの機能の一般的な使用は推奨しない。

残りの機能は、最適化のために提供されている。

以下で説明する標準的なCライブラリ関数などのライブラリに相当するもの、またはライブラリ呼び出しに展開する組み込み関数を除き、GCCの組み込み関数は常にインライン展開され、対応するエントリポイントを持たず、そのアドレスは得られない。 関数呼び出し以外の式でそれらを使用しようとすると、コンパイル時にエラーが発生する。

@opindex fno-builtin
GCCには、標準Cライブラリの多くの関数の組み込みバージョンが含まれている。 これらの関数には2つの形式がある：名前が接頭辞@code{__builtin_}で始まるものと、接頭辞なしのもの。 どちらの形式も、@option{-fno-builtin}オプションを指定したとしても、Cライブラリ関数と同じタイプ（プロトタイプを含む）、同じアドレス（アドレスの取得時）、同じ意味を持つ@pxref{C Dialect Options}）。 これらの関数の多くは、特定の場合にのみ最適化される。 特定のケースで最適化されていない場合は、ライブラリ関数の呼び出しが発行される。

@opindex ansi
@opindex std
厳密ISO Cモード (@option{-ansi}, @option{-std=c90}, @option{-std=c99}, @option{-std=c11})の外では、関数@code{_exit}, @code{alloca}, @code{bcmp}, @code{bzero}, @code{dcgettext}, @code{dgettext}, @code{dremf}, @code{dreml}, @code{drem}, @code{exp10f}, @code{exp10l}, @code{exp10}, @code{ffsll}, @code{ffsl}, @code{ffs}, @code{fprintf_unlocked}, @code{fputs_unlocked}, @code{gammaf}, @code{gammal}, @code{gamma}, @code{gammaf_r}, @code{gammal_r}, @code{gamma_r}, @code{gettext}, @code{index}, @code{isascii}, @code{j0f}, @code{j0l}, @code{j0}, @code{j1f}, @code{j1l}, @code{j1}, @code{jnf}, @code{jnl}, @code{jn}, @code{lgammaf_r}, @code{lgammal_r}, @code{lgamma_r}, @code{mempcpy}, @code{pow10f}, @code{pow10l}, @code{pow10}, @code{printf_unlocked}, @code{rindex}, @code{scalbf}, @code{scalbl}, @code{scalb}, @code{signbit}, @code{signbitf}, @code{signbitl}, @code{signbitd32}, @code{signbitd64}, @code{signbitd128}, @code{significandf}, @code{significandl}, @code{significand}, @code{sincosf}, @code{sincosl}, @code{sincos}, @code{stpcpy}, @code{stpncpy}, @code{strcasecmp}, @code{strdup}, @code{strfmon}, @code{strncasecmp}, @code{strndup}, @code{toascii}, @code{y0f}, @code{y0l}, @code{y0}, @code{y1f}, @code{y1l}, @code{y1}, @code{ynf}, @code{ynl},  @code{yn}は組み込み関数として扱うかもしれない。これらの関数はすべて、 @code{__builtin_}という接頭辞を持つ対応するバージョンを持っている。これは厳密なC90モードでも使用できる。

ISO C99 関数
@code{_Exit}, @code{acoshf}, @code{acoshl}, @code{acosh}, @code{asinhf},
@code{asinhl}, @code{asinh}, @code{atanhf}, @code{atanhl}, @code{atanh},
@code{cabsf}, @code{cabsl}, @code{cabs}, @code{cacosf}, @code{cacoshf},
@code{cacoshl}, @code{cacosh}, @code{cacosl}, @code{cacos},
@code{cargf}, @code{cargl}, @code{carg}, @code{casinf}, @code{casinhf},
@code{casinhl}, @code{casinh}, @code{casinl}, @code{casin},
@code{catanf}, @code{catanhf}, @code{catanhl}, @code{catanh},
@code{catanl}, @code{catan}, @code{cbrtf}, @code{cbrtl}, @code{cbrt},
@code{ccosf}, @code{ccoshf}, @code{ccoshl}, @code{ccosh}, @code{ccosl},
@code{ccos}, @code{cexpf}, @code{cexpl}, @code{cexp}, @code{cimagf},
@code{cimagl}, @code{cimag}, @code{clogf}, @code{clogl}, @code{clog},
@code{conjf}, @code{conjl}, @code{conj}, @code{copysignf}, @code{copysignl},
@code{copysign}, @code{cpowf}, @code{cpowl}, @code{cpow}, @code{cprojf},
@code{cprojl}, @code{cproj}, @code{crealf}, @code{creall}, @code{creal},
@code{csinf}, @code{csinhf}, @code{csinhl}, @code{csinh}, @code{csinl},
@code{csin}, @code{csqrtf}, @code{csqrtl}, @code{csqrt}, @code{ctanf},
@code{ctanhf}, @code{ctanhl}, @code{ctanh}, @code{ctanl}, @code{ctan},
@code{erfcf}, @code{erfcl}, @code{erfc}, @code{erff}, @code{erfl},
@code{erf}, @code{exp2f}, @code{exp2l}, @code{exp2}, @code{expm1f},
@code{expm1l}, @code{expm1}, @code{fdimf}, @code{fdiml}, @code{fdim},
@code{fmaf}, @code{fmal}, @code{fmaxf}, @code{fmaxl}, @code{fmax},
@code{fma}, @code{fminf}, @code{fminl}, @code{fmin}, @code{hypotf},
@code{hypotl}, @code{hypot}, @code{ilogbf}, @code{ilogbl}, @code{ilogb},
@code{imaxabs}, @code{isblank}, @code{iswblank}, @code{lgammaf},
@code{lgammal}, @code{lgamma}, @code{llabs}, @code{llrintf}, @code{llrintl},
@code{llrint}, @code{llroundf}, @code{llroundl}, @code{llround},
@code{log1pf}, @code{log1pl}, @code{log1p}, @code{log2f}, @code{log2l},
@code{log2}, @code{logbf}, @code{logbl}, @code{logb}, @code{lrintf},
@code{lrintl}, @code{lrint}, @code{lroundf}, @code{lroundl},
@code{lround}, @code{nearbyintf}, @code{nearbyintl}, @code{nearbyint},
@code{nextafterf}, @code{nextafterl}, @code{nextafter},
@code{nexttowardf}, @code{nexttowardl}, @code{nexttoward},
@code{remainderf}, @code{remainderl}, @code{remainder}, @code{remquof},
@code{remquol}, @code{remquo}, @code{rintf}, @code{rintl}, @code{rint},
@code{roundf}, @code{roundl}, @code{round}, @code{scalblnf},
@code{scalblnl}, @code{scalbln}, @code{scalbnf}, @code{scalbnl},
@code{scalbn}, @code{snprintf}, @code{tgammaf}, @code{tgammal},
@code{tgamma}, @code{truncf}, @code{truncl}, @code{trunc},
@code{vfscanf}, @code{vscanf}, @code{vsnprintf} and @code{vsscanf}
はISO C90モード(@option{-ansi}または@option{-std=c90})でない限り組み込み関数として扱われる。

ISO C90はISO C99がそれらの名前を付ける目的でこれらの名前を予約しているので、どのモードでも認識される@code{acosf}, @code{acosl}, @code{asinf}, @code{asinl}, @code{atan2f},
@code{atan2l}, @code{atanf}, @code{atanl}, @code{ceilf}, @code{ceill},
@code{cosf}, @code{coshf}, @code{coshl}, @code{cosl}, @code{expf},
@code{expl}, @code{fabsf}, @code{fabsl}, @code{floorf}, @code{floorl},
@code{fmodf}, @code{fmodl}, @code{frexpf}, @code{frexpl}, @code{ldexpf},
@code{ldexpl}, @code{log10f}, @code{log10l}, @code{logf}, @code{logl},
@code{modfl}, @code{modf}, @code{powf}, @code{powl}, @code{sinf},
@code{sinhf}, @code{sinhl}, @code{sinl}, @code{sqrtf}, @code{sqrtl},
@code{tanf}, @code{tanhf}, @code{tanhl} and @code{tanl}
関数がある。 これらの関数には対応するバージョンの接頭辞@code {__builtin_}がある。

サポートされた型TS18661-3関数@code{_Float@var{n}}と@code{_Float@var{n}x}用の
@code{fabsf@var{n}}, @code{fabsf@var{n}x}, @code{copysignf@var{n}} and @code{copysignf@var{n}x}に対応する組み込み関数@code{__builtin_fabsf@var{n}}, @code{__builtin_fabsf@var{n}x}, @code{__builtin_copysignf@var{n}}, @code{__builtin_copysignf@var{n}x}も存在する。

ISO C99によって将来の使用用に名前が予約されているGNU拡張関数@code{clog10}, @code{clog10f}, @code{clog10l}もある。これらの関数すべては@code{__builtin_}が前置したバージョンがある。

ISO C94関数@code{iswalnum}, @code{iswalpha}, @code{iswcntrl}, @code{iswdigit},
@code{iswgraph}, @code{iswlower}, @code{iswprint}, @code{iswpunct},
@code{iswspace}, @code{iswupper}, @code{iswxdigit}, @code{towlower}, 
@code{towupper}は厳密なISO C90モード(@option{-ansi}または@option{-std=c90})
出ない限りは組み込み関数として扱われる。

ISO C90関数
@code{abort}, @code{abs}, @code{acos}, @code{asin}, @code{atan2},
@code{atan}, @code{calloc}, @code{ceil}, @code{cosh}, @code{cos},
@code{exit}, @code{exp}, @code{fabs}, @code{floor}, @code{fmod},
@code{fprintf}, @code{fputs}, @code{frexp}, @code{fscanf},
@code{isalnum}, @code{isalpha}, @code{iscntrl}, @code{isdigit},
@code{isgraph}, @code{islower}, @code{isprint}, @code{ispunct},
@code{isspace}, @code{isupper}, @code{isxdigit}, @code{tolower},
@code{toupper}, @code{labs}, @code{ldexp}, @code{log10}, @code{log},
@code{malloc}, @code{memchr}, @code{memcmp}, @code{memcpy},
@code{memset}, @code{modf}, @code{pow}, @code{printf}, @code{putchar},
@code{puts}, @code{scanf}, @code{sinh}, @code{sin}, @code{snprintf},
@code{sprintf}, @code{sqrt}, @code{sscanf}, @code{strcat},
@code{strchr}, @code{strcmp}, @code{strcpy}, @code{strcspn},
@code{strlen}, @code{strncat}, @code{strncmp}, @code{strncpy},
@code{strpbrk}, @code{strrchr}, @code{strspn}, @code{strstr},
@code{tanh}, @code{tan}, @code{vfprintf}, @code{vprintf}, @code{vsprintf}
はすべて、@option{-fno-builtin}が指定されている（もしくは個別の関数に対して@option{-fno-builtin-@var{function}}が指定されている）のでない限り、組み込み関数として認識される。これらの関数はすべて対応する接頭辞@code{__builtin_}つきのバージョンがある。

GCCには、順序付けられていないオペランドに対する例外を発生させない、ISO C99浮動小数点比較マクロの組み込みバージョンが用意されている。 標準マクロ（@code{isgreater}、@code{isgreaterequal}、@code{isless}、@code{islessequre}、@code{islessgreater}、@code{isunordered}）と同じ名前を持ち、@code{__builtin_}が接頭辞付きである。ライブラリの実装者が各標準マクロを組み込み関数に@code{#define}できるようにするためを意図している。同じ方法で、GCCは@code{__ builtin_}を接頭辞として使用して、@code{fpclassify}、@code{isfinite}、@code{isinf_sign}、@code{notnormal}および@code{signbit}組み込み関数を提供する。 @code{isinf}と@code{isnan}組み込み関数は、接頭辞@code{__ builtin_}の有無に関係なく存在する。

@deftypefn {Built-in Function} void *__builtin_alloca (size_t size)
@code {__ builtin_alloca}関数はブロックスコープで呼び出さなければならない。この関数は、呼び出し関数のスタック上で@var{size}バイトのオブジェクトを割り当てる。 オブジェクトは、@code{__BIGGEST_ALIGNMENT__}マクロによって決定されたターゲットのデフォルトスタック境界境界にアラインメントされる。 @code{__ builtin_alloca}関数は、割り当てられたオブジェクトの最初のバイトへのポインタを返す。割り当てられたオブジェクトの存続期間は、呼び出し元関数が呼び出し元に戻る直前に終了する。 これは、ネストされたブロック内で@code{__ builtin_alloca}が呼び出された場合でもそうである。

たとえば、次の関数はスタック上に@code{n}バイトの8つのオブジェクトを割り当て、配列の各要素にポインタ@code{a}を格納する。 次に配列を関数@code{g}に渡す。これは各配列要素が指す記憶域を安全に使用できる。

@smallexample
void f (unsigned n)
@{
  void *a [8];
  for (int i = 0; i != 8; ++i)
    a [i] = __builtin_alloca (n);

  g (a, n);   // @r{safe}
@}
@end smallexample

@code{__ builtin_alloca}関数は引数を検証しないので、引数がスタックサイズの制限を超えないようにすることは呼び出し元の責任である。@code{__builtin_alloca}関数は、実行時に計算される上限を持つスタック配列に割り当てることを可能にするために提供されている。 C99の可変長配列は移植可能でより便利で安全なインタフェースの下で同様の機能を提供するので代わりに推奨され、GCCが拡張としてC99とC++プログラムの両方で提供される。詳細は@xref{Variable Length}。

@end deftypefn

@deftypefn {Built-in Function} void *__builtin_alloca_with_align (size_t size, size_t alignment)
ブロックスコープで@code{__builtin_alloca_with_align}関数を呼び出さなければならない。この関数は、呼び出し関数のスタック上で@var{size}バイトのオブジェクトを割り当てる。割り当てられたオブジェクトは、ユニットがビット（バイトではない）で与えられる引数@var{alignment}で指定された境界に揃えられる。 @var{size}引数は正で、スタックサイズ制限を超えてはならない。 @var{alignment}引数は、@code{CHAR_BIT}以上である未指定の最大値よりも小さい2の累乗に評価される定数の整数式でなければならない。他の値の呼び出しは拒否され、有効な境界を示すエラーが返される。この関数は、割り当てられたオブジェクトの最初のバイトへのポインタを返す。割り当てられたオブジェクトの存続期間は、関数が呼び出されたブロックの終わりで終了する。割り当てられた記憶域は、呼び出し元関数が呼び出し元に戻る直前に解放されるが、関数が呼び出されたブロックの最後に解放される可能性がある。

たとえば、次の関数では、@code{overalign}がゼロでないとき、@code{__ builtin_alloca_with_align}によって割り当てられた領域は、それが呼び出された@code{if}ステートメントの終わりに解放されている可能性があるので@code{g}の呼び出しは安全でない。

@smallexample
void f (unsigned n, bool overalign)
@{
  void *p;
  if (overalign)
    p = __builtin_alloca_with_align (n, 64 /* bits */);
  else
    p = __builtin_alloc (n);

  g (p, n);   // @r{unsafe}
@}
@end smallexample

@code{__ __builtin_alloca_with_align}関数は引数を検証しないので、引数がスタックサイズの制限を超えないようにすることは呼び出し元の責任である。@code {__ builtin_alloca_with_align}関数は、オーバーアラインメントされたスタックの配列に、実行時に計算される上限を割り当てることを可能にするために提供されている。 C99の可変長配列は移植可能でより便利で安全なインタフェースの下で同様の機能を提供するので代わりに推奨され、GCCが拡張としてC99とC++プログラムの両方で提供される。詳細は@xref{Variable Length}。

@end deftypefn

@deftypefn {Built-in Function} void *__builtin_alloca_with_align_and_max (size_t size, size_t alignment, size_t max_size)
@code{__builtin_alloca_with_align}と似ているが、@value{-fstack-usage}、@option{-Wstack-usage}と@option {-Walloca-greater-than}で使用するためにコンパイル時に値を計算できない場合に@var{size}の上限を指定する追加の引数をとる。@var{max_size}は定数の整数式でなければならない。コード生成に影響はなく、@var{size}との互換性をチェックしようとしない。

@end deftypefn

@deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})

組み込み関数@code{__builtin_types_compatible_p}を使用して、2つの型が同じかどうかを判断できる。

この組み込み関数は、@var{type1}および@var{type2}の型（式ではなく型）の非修飾バージョンが互換性がある場合は1を、それ以外の場合は0を返す。 この組み込み関数の結果は、整数定数式で使用できる。

この組み込み関数はトップレベルの修飾子（例えば、@code{const}、@code{volatile}）を無視する。 たとえば、@code{int}は@code{const int}と同じである。

@code{int[]}と@code{int[5]}は互換性がある。 一方、@code{int}と@code{char*}は、その型のサイズが特定のアーキテクチャ上で同じであっても、互換性がない。 また、類似性を判定する際に、ポインタ間接指示の量も考慮されます。 したがって、@code{short *}は@code{short **}と似ていない。 さらに、typedefされた2つの型は、それらの基本型が互換性がある場合、互換性があるとみなされる。

@code{enum}型は、両方とも同じ整数型と互換性があっても、別の@code{enum}型と互換性があるとはみなされない。 これはC標準が指定するものである。 たとえば、@code{enum @{foo、bar @}}は@code{enum @{hot、dog @}}と似ていない。

通常、この関数は引数の型によって実行が異なるコードで使用する。 例えば：

@smallexample
#define foo(x)                                                  \
  (@{                                                           \
    typeof (x) tmp = (x);                                       \
    if (__builtin_types_compatible_p (typeof (x), long double)) \
      tmp = foo_long_double (tmp);                              \
    else if (__builtin_types_compatible_p (typeof (x), double)) \
      tmp = foo_double (tmp);                                   \
    else if (__builtin_types_compatible_p (typeof (x), float))  \
      tmp = foo_float (tmp);                                    \
    else                                                        \
      abort ();                                                 \
    tmp;                                                        \
  @})
@end smallexample

@emph{注意:} この構造はCでのみ利用可能である

@end deftypefn

@deftypefn {Built-in Function} @var{type} __builtin_call_with_static_chain (@var{call_exp}, @var{pointer_exp})

@var{call_exp}式は関数呼び出しでなければならず、@var{pointer_exp}式はポインタでなければならない。 @var{pointer_exp}は、ターゲットの静的チェーンの場所にある関数呼び出しに渡される。 組み込み関数の結果は、関数呼び出しの結果である。

@emph{注意e:} この組み込みはCでの利用可能である。この組み込みはCでのからGoクロージャーを呼ぶために使うことができる。
@end deftypefn

@deftypefn {Built-in Function} @var{type} __builtin_choose_expr (@var{const_exp}, @var{exp1}, @var{exp2})

定数式の値に応じて、組み込み関数@code{__builtin_choose_expr}を使用してコードを評価することができる。 この組み込み関数は、整数定数式である@var{const_exp}がゼロでない場合、@var{exp1}を返す。 それ以外の場合は、@var{exp2}を返す。

この組み込み関数は、返される式の型がプロモーションルールによって変更されていない点を除いて、Cでの@samp{? :}演算子に似ている。また、組み込み関数は、選択されていない式も評価しない。 たとえば、@var{const_exp}がtrueと評価された場合、@var{exp2}は副作用があっても評価されない。

この組み込み関数は、選択した引数が左辺値の場合は左辺値を返す。

@var{exp1}が返された場合、戻り値の型は@var{exp1}の型と同じである。 同様に、@var{exp2}が返された場合、その戻り値の型は@var{exp2}と同じである。

例：

@smallexample
#define foo(x)                                                    \
  __builtin_choose_expr (                                         \
    __builtin_types_compatible_p (typeof (x), double),            \
    foo_double (x),                                               \
    __builtin_choose_expr (                                       \
      __builtin_types_compatible_p (typeof (x), float),           \
      foo_float (x),                                              \
      /* @r{The void expression results in a compile-time error}  \
         @r{when assigning the result to something.}  */          \
      (void)0))
@end smallexample

@emph{注意:} この構造はCでのみ利用可能である。さらに、未使用の式（@var{const_exp}の値に応じて@var{exp1}または@var{exp2}）でも構文エラーが発生する可能性がある。 これは将来の改訂で変更される可能性がある。

@end deftypefn

@deftypefn {Built-in Function} @var{type} __builtin_tgmath (@var{functions}, @var{arguments})

CおよびObjective-Cでのみ使用できる組み込み関数@code{__ builtin_tgmath}は、@code{<tgmath.h>}マクロの規則に従って決定された関数を呼び出す。 そのヘッダーの実装で使用することを意図している。そのヘッダーからのマクロの展開は、そのマクロの呼び出しがそのマクロへの他の呼び出しの引数の中に入れ子になっているときの問題を避けるために、 さらに、他のGNU C言語機能を使用する実装よりも、@code{<tgmath.h>}マクロに対する無効な呼び出しの診断が向上する。 たとえば、@code{pow}型汎用マクロは次のように定義される。

@smallexample
#define pow(a, b) __builtin_tgmath (powf, pow, powl, \
                                    cpowf, cpow, cpowl, a, b)
@end smallexample

@code{__builtin_tgmath}への引数は、関数への少なくとも2つのポインタと、型ジェネリックマクロへの引数（選択された関数への引数として渡される）である。 関数へのポインタはプロトタイプ関数へのポインタでなければならず、そのいずれも可変引数を持たず、すべてが同じ数のパラメータを持たなければならない。 最初の関数のパラメータの数は、@code{__builtin_tgmath}に対する引数の数を関数ポインタとして解釈し、呼び出された関数への引数の数を決定する。

指定された関数の型はすべて異なっていなければならないが、@code{<tgmath.h>}内のマクロによって選択される関数のセットと同じ方法で互いに関連している必要がある。 これは、関数がそのような関数ごとに異なる浮動小数点型@var{t}によってパラメータ化されていることを意味する。 関数の戻り値の型は、すべて同じ型でもよいし、それぞれの関数で@var{t}であってもよいし、それぞれの関数で@var{t}に対応する実数型（@var{t}型のいくつかが複素数であるならば）であってもよい。 同様に、各パラメータの位置について、その位置のパラメータの型は常に同じ型であるか、それぞれの関数で@var{t}であるか（この場合は少なくとも1つのパラメータの位置に適用する必要がある）か、または 各関数の@var {t}に対応する実数型であってもよい。

@code{<tgmath.h>}マクロの標準規則は、関数間で型が異なるパラメータの引数の型から共通型@var{u}を見つけるために使用される。複素整数型（GNU拡張）はこの目的では@code{_Complex double}のように扱われる。（もしくは、もし全関数戻り値型が同じ@code{_Float@var{n}}か@code{_Float@var{n}x}型ならば@code{_Complex _Float64}）関数の戻り値の型が異なる場合、またはすべてが同じ整数型の場合、呼び出される関数は@var{t}が@var{u}の関数であり、そのような関数がない場合はエラーとなる。 関数の戻り値の型がすべて同じ浮動小数点型である場合、型ジェネリックマクロは結果をより狭い型に丸めたTS 18661のマクロの1つと解釈される。 @var{t}が@var {u}である関数があればそれが呼び出され、そうでない場合は@var{t}が@var{u}が呼び出され、そのような関数がない場合はエラーとなる。

@end deftypefn

@deftypefn {Built-in Function} @var{type} __builtin_complex (@var{real}, @var{imag})

組み込み関数@code{__builtin_complex}は、ISO C11マクロ@code{CMPLXF}、@code{CMPLX}、@ code{CMPLXL}の実装に使用される。 @var{real}と@var {imag}は同じ型、実際のバイナリ浮動小数点型を持つ必要があり、結果は実部と虚部が@var{real}と@var{imag}に対応する複素数型を持つ。@samp{@var{real} + I * @var{imag}}とは異なり、無限大、NaN、負のゼロが関与している場合でも、これは機能する。

@end deftypefn

@deftypefn {Built-in Function} int __builtin_constant_p (@var{exp})
組み込み関数@code{__builtin_constant_p}を使用して、コンパイル時に値が定数位であることが分かり、GCCがその値を含む式に定数畳み込みを実行できるかどうかを判断できる。 関数の引数はテストする値である。 この関数は、引数がコンパイル時定数である場合は整数1を返し、コンパイル時定数でない場合は0を返す。 0が返されても、その値が定数で@emph{ない}のはなく、GCCが@option{-O}オプションの指定された値で定数であることを証明できないことを意味する。

通常、メモリを重要なリソースとする組み込みアプリケーションでこの機能を使用する。 複雑な計算をしている場合は、定数が含まれていれば畳み込みたいが、そうでない場合は関数を呼び出す必要があるかもしれない。 例えば：

@smallexample
#define Scale_Value(X)      \
  (__builtin_constant_p (X) \
  ? ((X) * SCALE + OFFSET) : Scale (X))
@end smallexample

この組み込み関数は、マクロ関数またはインライン関数のどちらでも使用できる。 しかし、インライン関数でそれを使用し、その関数の引数を組み込みの引数として渡すと、GCCは文字列定数または複合リテラル（@pxref {Compound Literals}）でインライン関数を呼び出すと決して1を返さない ）、@option{-O}オプションを指定しない限り、インライン関数に定数数値を渡すと1を返さない。

静的データのイニシャライザで@code{__builtin_constant_p}を使用することもできる。 たとえば、次のように書くことができる。

@smallexample
static const int table[] = @{
   __builtin_constant_p (EXPRESSION) ? (EXPRESSION) : -1,
   /* @r{@dots{}} */
@};
@end smallexample

@noindent
@var {EXPRESSION}が定数式にならない場合でも@code{__builtin_constant_p}が1を返す場合を含め、これは許容される初期化子である。@var{EXPRESSION}は静的イニシャライザ（@code{0 && foo（）}など）では他に許可されていない。 GCCは、最適化を実行する機会がないので、この場合の組み込み関数を評価することについてより慎重でなければならない。
@end deftypefn

@deftypefn {Built-in Function} long __builtin_expect (long @var{exp}, long @var{c})
@opindex fprofile-arcs
@code{__ builtin_expect}を使用して、分岐予測情報をコンパイラに提供することができる。 一般的に、プログラマーはプログラムが実際にどのように実行されるかを予測することが悪いことが多いので、これに実際のプロファイルフィードバック（@option{-fprofile-arcs}）を使用する方がよいだろう。 しかし、このデータを収集するのは難しいアプリケーションがある。

戻り値は、@var{exp}の値であり、これは整数式でなければならない。組み込みの意味は、@var{exp} == @var{c}が期待されることである。 例えば：

@smallexample
if (__builtin_expect (x, 0))
  foo ();
@end smallexample

@noindent
は@code{x}がゼロであると予想しているので、@code{foo}を呼び出すことを期待していないことを示す。 @var{exp}は整数に限られているので、ポインタ及び浮動小数点値をテストするときは

@smallexample
if (__builtin_expect (ptr != NULL, 1))
  foo (*ptr);
@end smallexample

@noindent
のような構造を使うべきである。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_trap (void)
この関数は、プログラムを異常終了させる。 GCCは、ターゲットに依存するメカニズム（意図的に不正な命令を実行するなど）を使用するか、@code{abort}を呼び出すことによってこの機能を実装する。 使用されるメカニズムはリリースごとに異なる場合があるので、特定の実装に依存するべきではない。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_unreachable (void)
制御フローが@code{__ builtin_unreachable}のポイントに達すると、プログラムは未定義である。 これは、コンパイラがコードの到達不能を推定できない場合に便利である。

このようなケースの1つは、決して終わらないか、制御を他の場所に移して戻ってこない@code{asm}ステートメントの直後である。 この例では、@code{__builtin_unreachable}を指定せずに、GCCは制御が非void関数の終わりに達するという警告を出す。 @code{asm}の後ろに戻るコードも生成する。

@smallexample
int f (int c, int v)
@{
  if (c)
    @{
      return v;
    @}
  else
    @{
      asm("jmp error_handler");
      __builtin_unreachable ();
    @}
@}
@end smallexample

@noindent
@code{asm}文は無条件に関数から制御を移すので、制御は決して関数本体の終わりに達しない。 実際、@code {__builtin_unreachable}は到達不能で、この事実をコンパイラに伝える。

@code{__builtin_unreachable}の別の使い方は、この例のように決して返らないが、@code{__attribute__((noreturn))}宣言されていない関数を呼び出すことである。

@smallexample
void function_that_never_returns (void);

int g (int c)
@{
  if (c)
    @{
      return 1;
    @}
  else
    @{
      function_that_never_returns ();
      __builtin_unreachable ();
    @}
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_assume_aligned (const void *@var{exp}, size_t @var{align}, ...)
この関数は最初の引数を返し、コンパイラは返されたポインタが少なくとも@var{align}バイト整列していると仮定することができるようにするます。 この組み込み関数は、2つまたは3つの引数を持つことができ、3つの引数を持つ場合、3つ目の引数は整数型を持ち、0以外の場合は位置合わせのオフセットを意味する。 例えば：

@smallexample
void *x = __builtin_assume_aligned (arg, 16);
@end smallexample

@noindent
コンパイラが@code{x}を@code{arg}に設定し、少なくとも16バイト整列していると仮定できることを意味する一方、

@smallexample
void *x = __builtin_assume_aligned (arg, 32, 8);
@end smallexample

@noindent
コンパイラが@code{x}を@code{arg}に設定し、@code{(char *) x - 8}を32バイトに整列させることができることを意味する。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_LINE ()
この関数は、プリプロセッサの@code{__ LINE__}マクロに相当し、ビルトインの呼び出しの行番号を評価する定数の整数式を返す。 関数@var{F}のC++のデフォルト引数として使用すると、@var{F}への呼び出しの行番号を返す。
@end deftypefn

@deftypefn {Built-in Function} {const char *} __builtin_FUNCTION ()
この関数は、@code{__FUNCTION__}シンボルに相当し、ビルトインが呼び出された関数の名前を指すアドレス定数を返す。呼び出しが関数スコープでない場合は空の文字列を返す。 @var{F}の関数のC++のデフォルト引数として使用すると、@var{F}の呼び出し元の名前、または関数スコープで呼び出しが行われなかった場合は空文字列が返される。
@end deftypefn

@deftypefn {Built-in Function} {const char *} __builtin_FILE ()
この関数はプリプロセッサの@code{__FILE__}マクロに相当し、ビルトインの呼び出しを含むファイル名を指すアドレス定数を返す。呼び出しが関数スコープにない場合は空の文字列を返す。 関数@var{F}のC ++のデフォルト引数として使用すると、@var {F}への呼び出しのファイル名、または関数スコープで呼び出しが行われなかった場合は空文字列が返される。

たとえば、以下では、関数@code{foo}を呼び出すたびに、@code{"file.c:123:foo:message"}と同様の、@code{printf}呼び出しのファイル名と行番号、関数@code{foo}の名前、@code{message}という単語が続けて出力される。

@smallexample
const char*
function (const char *func = __builtin_FUNCTION ())
@{
  return func;
@}

void foo (void)
@{
  printf ("%s:%i: %s: message\n", file (), line (), function ());
@}
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} void __builtin___clear_cache (char *@var{begin}, char *@var{end})
この関数は、プロセッサの命令キャッシュを@var{begin}と@var{end}との間のメモリ領域に対してフラッシュするために使用される。 確定的な振る舞いを得るためには、コードを含むメモリを変更した後には、命令キャッシュをフラッシュする必要がある。

ターゲットが命令キャッシュのフラッシュを必要としない場合、@code{__builtin___clear_cache}は効果がない。 そうでなければ、命令キャッシュをクリアするインラインで発行されるか、libgccの@code{__ clear_cache}関数の呼び出しが行われるかのどちらかが行われる。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_prefetch (const void *@var{addr}, ...)
この機能は、データがアクセスされる前にキャッシュにデータを移動することによって、キャッシュミスのレイテンシを最小限に抑えるために使用される。@code{__builtin_prefetch}への呼び出しを、すぐにアクセスされる可能性が高いメモリ内のデータのアドレスを知っているコードに挿入することができる。ターゲットがそれらをサポートする場合、データプリフェッチ命令が生成される。プリフェッチがアクセスの前に早めに行われた場合、データはアクセスされるまでにキャッシュに格納される。

@var {addr}の値は、プリフェッチするメモリのアドレスである。オプション引数@var{rw}と@var{locality}がある。@var{rw}の値はコンパイル時定数1または0である。 1は、プリフェッチがメモリアドレスへの書き込みを準備していることを意味し、0はデフォルトであり、プリフェッチが読み出しを準備していることを意味する。値@var{locality}は、0と3の間のコンパイル時定数でなければならない。 ゼロの値は、データに時間的局所性がないことを意味するため、アクセス後にキャッシュに残す必要はない。 値が3の場合、データの時間的局所性が高く、可能なすべてのレベルのキャッシュに残す必要がある。 1と2の値はそれぞれ、低いまたは中程度の時間的局所性を意味する。 デフォルトは3である。

@smallexample
for (i = 0; i < n; i++)
  @{
    a[i] = a[i] + b[i];
    __builtin_prefetch (&a[i+j], 1, 1);
    __builtin_prefetch (&b[i+j], 0, 1);
    /* @r{@dots{}} */
  @}
@end smallexample

@var{addr}が無効な場合、データプリフェッチはフォルトを生成しない、アドレス式自体は有効でなければならない。 たとえば、@code{p->next}が有効なアドレスではない場合、@code{p->next}のプリフェッチは失敗しないが、@code{p}が有効なアドレスでない場合、評価に失敗する。

ターゲットがデータプリフェッチをサポートしていない場合、アドレス式は副作用が含まれていても他のコードは生成されず、GCCは警告を出さない。
@end deftypefn

@deftypefn {Built-in Function} double __builtin_huge_val (void)
浮動小数点形式でサポートされている場合は正の無限大を返し、そうでなければ@code{DBL_MAX}を返す。 この関数はISO Cマクロ@code{HUGE_VAL}を実装するのに適している。
@end deftypefn

@deftypefn {Built-in Function} float __builtin_huge_valf (void)
@code{__builtin_huge_val}と似ているが、戻り値の型は@code{float}である。
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_huge_vall (void)
@code{__builtin_huge_val}と似ているが、戻り値の型は@code{long double}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_huge_valf@var{n} (void)
@code{__builtin_huge_val}と似ているが、戻り値の型は@code{_Float@var{n}}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n}x __builtin_huge_valf@var{n}x (void)
@code{__builtin_huge_val}と似ているが、戻り値の型は@code{_Float@var{n}x}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_fpclassify (int, int, int, int, int, ...)
この組み込み関数は、C99 fpclassify機能を実装する。 最初の5つのint引数は、ターゲットライブラリの可能なFPクラスの概念でなければならず、戻り値として使用される。 これらは定数値でなければならず、次の順序で表示されなければならない。@code{FP_NAN}、@code{FP_INFINITE}、@code{FP_NORMAL}、@code{FP_SUBNORMAL}、@code{FP_ZERO}である。 省略記号は、正確に1つの浮動小数点値を分類するためのものである。 GCCは最後の引数を型ジェネリックとして扱う。つまり、floatからdoubleへのデフォルトの昇格は行わない。
@end deftypefn

@deftypefn {Built-in Function} double __builtin_inf (void)
@code{__builtin_huge_val}と似ているが、ターゲット浮動小数点フォーマットが無限をサポートしていない場合に警告が生成される点が異なる。
@end deftypefn

@deftypefn {Built-in Function} _Decimal32 __builtin_infd32 (void)
@code{__builtin_inf}と似ているが、戻り値の型は@code{_Decimal32}である。
@end deftypefn

@deftypefn {Built-in Function} _Decimal64 __builtin_infd64 (void)
@code{__builtin_inf}と似ているが、戻り値の型は@code{_Decimal64}である。
@end deftypefn

@deftypefn {Built-in Function} _Decimal128 __builtin_infd128 (void)
@code{__builtin_inf}と似ているが、戻り値の型は@code{_Decimal128}である。
@end deftypefn

@deftypefn {Built-in Function} float __builtin_inff (void)
@code{__builtin_inf}と似ているが、戻り値の型は@code{float}である。この関数は、ISO C99マクロ@code {INFINITY}を実装するのに適している。
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_infl (void)
@code{__builtin_inf}と似ているが、戻り値の型は@code{long double}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_inff@var{n} (void)
@code{__builtin_inf}と似ているが、戻り値の型は@code{_Float@var{n}}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_inff@var{n}x (void)
@code{__builtin_inf}と似ているが、戻り値の型は@code{_Float@var{n}x}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_isinf_sign (...)
引数が@code{-inf}の場合-1、引数が@code{+Inf}の場合1であるのを除き、@code{isinf}と同様である。パラメータリストは省略記号だが、この関数は1つの浮動小数点引数のみを受け入れる。 GCCはこのパラメータを型ジェネリックとして扱う。つまり、floatからdoubleへのデフォルト昇格は行わない。
@end deftypefn

@deftypefn {Built-in Function} double __builtin_nan (const char *str)
これは、ISO C99関数@code {nan}の実装である。

ISO C99では、我々が実装していない@code{strtod}の観点からこの関数を定義しているので、解析の説明が順番になります。 文字列は@code{strtol}のように解析される。 つまり、基底は@samp{0}や@samp{0x}プレフィックスの先頭で認識される。 解析された数は、仮数部の最下位ビットが仮数部の最下位ビットになるように仮数部に配置される。 指定された仮数フィールドに合うように数値が切り捨てられｒｙ。 仮数部は静かなNaNでなければならない。

この関数は、@code{strtol}によって消費された文字列リテラルが与えられた場合、コンパイル時定数と見なされるほど早く評価される。
@end deftypefn

@deftypefn {Built-in Function} _Decimal32 __builtin_nand32 (const char *str)
@code{__builtin_nan}と似ているが、戻り値の型は@code{_Decimal32}である。
@end deftypefn

@deftypefn {Built-in Function} _Decimal64 __builtin_nand64 (const char *str)
@code{__builtin_nan}と似ているが、戻り値の型は@code{_Decimal64}である。
@end deftypefn

@deftypefn {Built-in Function} _Decimal128 __builtin_nand128 (const char *str)
@code{__builtin_nan}と似ているが、戻り値の型は@code{_Decimal128}である。
@end deftypefn

@deftypefn {Built-in Function} float __builtin_nanf (const char *str)
@code{__builtin_nan}と似ているが、戻り値の型は@code{float}である。
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_nanl (const char *str)
@code{__builtin_nan}と似ているが、戻り値の型は@code{long double}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_nanf@var{n} (const char *str)
@code{__builtin_nan}と似ているが、戻り値の型は@code{_Float@var{n}}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n}x __builtin_nanf@var{n}x (const char *str)
@code{__builtin_nan}と似ているが、戻り値の型は@code{_Float@var{n}x}である。
@end deftypefn

@deftypefn {Built-in Function} double __builtin_nans (const char *str)
@code{__builtin_nan}と似ているが、仮数部は強制的にシグナリングNaNになる。 @code{nans}関数は
@uref{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm,,WG14 N965}で提案されている。
@end deftypefn

@deftypefn {Built-in Function} float __builtin_nansf (const char *str)
@code{__builtin_nans}と似ているが、戻り値の型は@code{float}である。
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_nansl (const char *str)
@code{__builtin_nans}と似ているが、戻り値の型は@code{long double}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n} __builtin_nansf@var{n} (const char *str)
@code{__builtin_nans}と似ているが、戻り値の型は@code{_Float@var{n}}である。
@end deftypefn

@deftypefn {Built-in Function} _Float@var{n}x __builtin_nansf@var{n}x (const char *str)
@code{__builtin_nans}と似ているが、戻り値の型は@code{_Float@var{n}x}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ffs (int x)
@var{x}の最下位1ビットのインデックスに1を加えたものを返すか、@var{x}がゼロの場合はゼロを返す。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clz (unsigned int x)
@var{x}の先頭の0ビットの数を最上位ビット位置から返す。@var{x}が0の場合、結果は未定義である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ctz (unsigned int x)
@var{x}の末尾の0ビットの数を最下位ビット位置から返す。 @var{x}が0の場合、結果は未定義である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clrsb (int x)
@var{x}の先頭にある冗長符号ビットの数を返す。つまり、それと同一の最上位ビットに続くビット数である。 0やその他の値には特別な場合はない。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_popcount (unsigned int x)
@var {x}の1ビット数を返す。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_parity (unsigned int x)
@var{x}のパリティを返す。すなわち、2を法とする@var{x}の1ビットの数である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ffsl (long)
@code{__builtin_ffs}と似ているが、引数の型は@code{long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clzl (unsigned long)
@code{__builtin_clz}と似ているが、引数の型は@code{unsigned long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ctzl (unsigned long)
@code{__builtin_cyz}と似ているが、引数の型は@code{unsigned long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clrsbl (long)
@code{__builtin_clrsb}と似ているが、引数の型は@code{long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_popcountl (unsigned long)
@code{__builtin_popcount}と似ているが、引数の型は@code{unsigned long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_parityl (unsigned long)
@code{__builtin_parity}と似ているが、引数の型は@code{unsigned long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ffsll (long long)
@code{__builtin_ffs}と似ているが、引数の型は@code{long long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clzll (unsigned long long)
@code{__builtin_clz}と似ているが、引数の型は@code{unsigned long long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_ctzll (unsigned long long)
@code{__builtin_ctz}と似ているが、引数の型は@code{unsigned long long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_clrsbll (long long)
@code{__builtin_clrsb}と似ているが、引数の型は@code{long long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_popcountll (unsigned long long)
@code{__builtin_popcount}と似ているが、引数の型は@code{unsigned long long}である。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_parityll (unsigned long long)
@code{__builtin_parity}と似ているが、引数の型は@code{unsigned long long}である。
@end deftypefn

@deftypefn {Built-in Function} double __builtin_powi (double, int)
最初の引数を2番目の累乗に戻して返す。 @code{pow}関数とは異なり、精度や丸めの保証はない。
@end deftypefn

@deftypefn {Built-in Function} float __builtin_powif (float, int)
@code{__builtin_powi}と似ているが、引数と戻り値型は@code{float}である。
@end deftypefn

@deftypefn {Built-in Function} {long double} __builtin_powil (long double, int)
@code{__builtin_powi}と似ているが、引数と戻り値型は@code{long double}である。
@end deftypefn

@deftypefn {Built-in Function} uint16_t __builtin_bswap16 (uint16_t x)
バイトの順序を逆にして@var{x}を返す。 たとえば、@code{0xaabb}は@code{0xbbaa}になる。 ここでのバイトは常に正確に8ビットを意味しする。
@end deftypefn

@deftypefn {Built-in Function} uint32_t __builtin_bswap32 (uint32_t x)
@code{__builtin_bswap16}と似ているが、引数と戻り値型は32ビットである。
@end deftypefn

@deftypefn {Built-in Function} uint64_t __builtin_bswap64 (uint64_t x)
@code{__builtin_bswap32}と似ているが、引数と戻り値型は64ビットである。
@end deftypefn

@deftypefn {Built-in Function} Pmode __builtin_extend_pointer (void * x)
ユーザーの可視ポインタサイズが実際のハードウェアアドレスのサイズより小さいターゲットでは、この関数は拡張ユーザーポインタを返す。 これが真であるターゲットには、x86_64またはAarch64のILP32モードが含まれている。 この関数は、主にインラインアセンブリコードを記述するときに便利である。
@end deftypefn

@node Target Builtins
@section 特定のターゲット機種に固有の組み込み関数

一部のターゲットマシンでは、GCCはそれらのマシンに固有の組み込み関数を多くサポートしている。 一般に、これらは特定のマシン命令への呼び出しを生成するが、コンパイラーがそれらの呼び出しをスケジュールできるようする。

@menu
* AArch64 Built-in Functions::
* Alpha Built-in Functions::
* Altera Nios II Built-in Functions::
* ARC Built-in Functions::
* ARC SIMD Built-in Functions::
* ARM iWMMXt Built-in Functions::
* ARM C Language Extensions (ACLE)::
* ARM Floating Point Status and Control Intrinsics::
* ARM ARMv8-M Security Extensions::
* AVR Built-in Functions::
* Blackfin Built-in Functions::
* FR-V Built-in Functions::
* MIPS DSP Built-in Functions::
* MIPS Paired-Single Support::
* MIPS Loongson Built-in Functions::
* MIPS SIMD Architecture (MSA) Support::
* Other MIPS Built-in Functions::
* MSP430 Built-in Functions::
* NDS32 Built-in Functions::
* picoChip Built-in Functions::
* PowerPC Built-in Functions::
* PowerPC AltiVec/VSX Built-in Functions::
* PowerPC Hardware Transactional Memory Built-in Functions::
* PowerPC Atomic Memory Operation Functions::
* RX Built-in Functions::
* S/390 System z Built-in Functions::
* SH Built-in Functions::
* SPARC VIS Built-in Functions::
* SPU Built-in Functions::
* TI C6X Built-in Functions::
* TILE-Gx Built-in Functions::
* TILEPro Built-in Functions::
* x86 Built-in Functions::
* x86 transactional memory intrinsics::
* x86 control-flow protection intrinsics::
@end menu

@node AArch64 Built-in Functions
@subsection AArch64組み込み関数

これらの組み込み関数は、AArch64ファミリのプロセッサで使用できる。
@smallexample
unsigned int __builtin_aarch64_get_fpcr ()
void __builtin_aarch64_set_fpcr (unsigned int)
unsigned int __builtin_aarch64_get_fpsr ()
void __builtin_aarch64_set_fpsr (unsigned int)
@end smallexample

@node Alpha Built-in Functions
@subsection Alpha組み込み関数

これらの組み込み関数は、使用されているコマンドラインスイッチに応じて、Alphaファミリのプロセッサで使用できる。

以下の組み込み関数は常に利用可能である。 それらはすべて、名前の一部である機械命令を生成する。

@smallexample
long __builtin_alpha_implver (void)
long __builtin_alpha_rpcc (void)
long __builtin_alpha_amask (long)
long __builtin_alpha_cmpbge (long, long)
long __builtin_alpha_extbl (long, long)
long __builtin_alpha_extwl (long, long)
long __builtin_alpha_extll (long, long)
long __builtin_alpha_extql (long, long)
long __builtin_alpha_extwh (long, long)
long __builtin_alpha_extlh (long, long)
long __builtin_alpha_extqh (long, long)
long __builtin_alpha_insbl (long, long)
long __builtin_alpha_inswl (long, long)
long __builtin_alpha_insll (long, long)
long __builtin_alpha_insql (long, long)
long __builtin_alpha_inswh (long, long)
long __builtin_alpha_inslh (long, long)
long __builtin_alpha_insqh (long, long)
long __builtin_alpha_mskbl (long, long)
long __builtin_alpha_mskwl (long, long)
long __builtin_alpha_mskll (long, long)
long __builtin_alpha_mskql (long, long)
long __builtin_alpha_mskwh (long, long)
long __builtin_alpha_msklh (long, long)
long __builtin_alpha_mskqh (long, long)
long __builtin_alpha_umulh (long, long)
long __builtin_alpha_zap (long, long)
long __builtin_alpha_zapnot (long, long)
@end smallexample

以下の組み込み関数は、常に@option{-mmax}または@option{-mcpu=@var{cpu}}を使用する。@var{cpu}は@code{pca56}以降である。 それらはすべて、名前の一部である機械命令を生成する。

@smallexample
long __builtin_alpha_pklb (long)
long __builtin_alpha_pkwb (long)
long __builtin_alpha_unpkbl (long)
long __builtin_alpha_unpkbw (long)
long __builtin_alpha_minub8 (long, long)
long __builtin_alpha_minsb8 (long, long)
long __builtin_alpha_minuw4 (long, long)
long __builtin_alpha_minsw4 (long, long)
long __builtin_alpha_maxub8 (long, long)
long __builtin_alpha_maxsb8 (long, long)
long __builtin_alpha_maxuw4 (long, long)
long __builtin_alpha_maxsw4 (long, long)
long __builtin_alpha_perr (long, long)
@end smallexample

以下の組み込み関数は、常に@option{-mcix}または@option{-mcpu=@var{cpu}}で、@var{cpu}は@code{ev67}以降である。 それらはすべて、名前の一部である機械命令を生成する。

@smallexample
long __builtin_alpha_cttz (long)
long __builtin_alpha_ctlz (long)
long __builtin_alpha_ctpop (long)
@end smallexample

以下の組み込み関数は、OSF/1 PALcodeを使用するシステムで使用できる。 通常は@code{rduniq}と@code{wruniq}のPAL呼び出しを呼び出すが、@option{-mtls-kernel}で呼び出されると、@code{rdval}と@code{wrval}が呼び出される。

@smallexample
void *__builtin_thread_pointer (void)
void __builtin_set_thread_pointer (void *)
@end smallexample

@node Altera Nios II Built-in Functions
@subsection Altera Nios II組み込み関数

これらの組み込み関数は、Altera Nios IIプロセッサ・ファミリで使用できる。

以下の組み込み関数は常に利用可能である。 それらはすべて、名前の一部である機械命令を生成する。

@example
int __builtin_ldbio (volatile const void *)
int __builtin_ldbuio (volatile const void *)
int __builtin_ldhio (volatile const void *)
int __builtin_ldhuio (volatile const void *)
int __builtin_ldwio (volatile const void *)
void __builtin_stbio (volatile void *, int)
void __builtin_sthio (volatile void *, int)
void __builtin_stwio (volatile void *, int)
void __builtin_sync (void)
int __builtin_rdctl (int) 
int __builtin_rdprs (int, int)
void __builtin_wrctl (int, int)
void __builtin_flushd (volatile void *)
void __builtin_flushda (volatile void *)
int __builtin_wrpie (int);
void __builtin_eni (int);
int __builtin_ldex (volatile const void *)
int __builtin_stex (volatile void *, int)
int __builtin_ldsex (volatile const void *)
int __builtin_stsex (volatile void *, int)
@end example

以下の組み込み関数は常に利用可能である。 それらはすべてNios IIカスタム命令を生成する。 関数の名前は、関数が受け取り、返す型を表す。 @code{n}の前の文字は戻り値の型である。存在しない場合はvoidである。 @code{n}は、すべてのカスタム命令の最初のパラメータ、つまりカスタム命令番号を表す。@code{n}の後の2文字は、関数の最大2つのパラメータを表す。

文字は次のデータ型を表す。
@table @code
@item <no letter>
戻り値型では@code{void}、パラメータ型ではパラメータなし。

@item i
戻り値型とパラメータ型で@code{int}

@item f
戻り値型とパラメータ型で@code{float}

@item p
戻り値型とパラメータ型で@code{void*}

@end table

関数名は次のとおりである。
@example
void __builtin_custom_n (void)
void __builtin_custom_ni (int)
void __builtin_custom_nf (float)
void __builtin_custom_np (void *)
void __builtin_custom_nii (int, int)
void __builtin_custom_nif (int, float)
void __builtin_custom_nip (int, void *)
void __builtin_custom_nfi (float, int)
void __builtin_custom_nff (float, float)
void __builtin_custom_nfp (float, void *)
void __builtin_custom_npi (void *, int)
void __builtin_custom_npf (void *, float)
void __builtin_custom_npp (void *, void *)
int __builtin_custom_in (void)
int __builtin_custom_ini (int)
int __builtin_custom_inf (float)
int __builtin_custom_inp (void *)
int __builtin_custom_inii (int, int)
int __builtin_custom_inif (int, float)
int __builtin_custom_inip (int, void *)
int __builtin_custom_infi (float, int)
int __builtin_custom_inff (float, float)
int __builtin_custom_infp (float, void *)
int __builtin_custom_inpi (void *, int)
int __builtin_custom_inpf (void *, float)
int __builtin_custom_inpp (void *, void *)
float __builtin_custom_fn (void)
float __builtin_custom_fni (int)
float __builtin_custom_fnf (float)
float __builtin_custom_fnp (void *)
float __builtin_custom_fnii (int, int)
float __builtin_custom_fnif (int, float)
float __builtin_custom_fnip (int, void *)
float __builtin_custom_fnfi (float, int)
float __builtin_custom_fnff (float, float)
float __builtin_custom_fnfp (float, void *)
float __builtin_custom_fnpi (void *, int)
float __builtin_custom_fnpf (void *, float)
float __builtin_custom_fnpp (void *, void *)
void * __builtin_custom_pn (void)
void * __builtin_custom_pni (int)
void * __builtin_custom_pnf (float)
void * __builtin_custom_pnp (void *)
void * __builtin_custom_pnii (int, int)
void * __builtin_custom_pnif (int, float)
void * __builtin_custom_pnip (int, void *)
void * __builtin_custom_pnfi (float, int)
void * __builtin_custom_pnff (float, float)
void * __builtin_custom_pnfp (float, void *)
void * __builtin_custom_pnpi (void *, int)
void * __builtin_custom_pnpf (void *, float)
void * __builtin_custom_pnpp (void *, void *)
@end example

@node ARC Built-in Functions
@subsection ARC組み込み関数

ARCターゲットには、次の組み込み関数が用意されている。 組み込み関数は、対応するアセンブリ命令を生成する。 以下の例では、生成されたコードでは、しばしばオペランドまたは結果がレジスタに存在する必要がある。 必要であれば、これが真実であることを保証するためにさらなるコードが生成されるが、簡潔にするために、これはそれぞれの場合に記載されていない。

@emph{注意:} 組み込み関数を使用してターゲットでサポートされていない命令を生成すると、問題が発生する可能性がある。 現在のところ、コンパイラはそのような誤使用を検出することは保証されてなく、その結果、内部コンパイラエラーが生成される可能性がある。

@deftypefn {Built-in Function} int __builtin_arc_aligned (void *@var{val}, int @var{alignval})
@var{val}が@var{alignval}によって与えられたバイト配列を持つことがわかっている場合は1を返し、それ以外の場合は0を返す。これは、
@smallexample
__alignof__(*(char *)@var{val}) >= alignval
@end smallexample
とは__alignof__は逆参照の型だけを参照するのに対し、__builtin_arc_alignはポインターから参照されたポ型の整列情報を使用するため、異なっていることに注意する。
利用可能な情報は、最適化レベルによって異なる。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_brk (void)
以下を生成する
@example
brk
@end example
@end deftypefn

@deftypefn {Built-in Function} {unsigned int} __builtin_arc_core_read (unsigned int @var{regno})
オペランドは、読み込むレジスタの番号である。以下を生成する：
@example
mov  @var{dest}, r@var{regno}
@end example
ここで@var{dest}の値はビルトインから返された結果になる。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_core_write (unsigned int @var{regno}, unsigned int @var{val})
第1オペランドは書き込まれるレジスタの番号であり、第2オペランドはそのレジスタに書き込むコンパイル時定数である。以下を生成する：
@example
mov  r@var{regno}, @var{val}
@end example
@end deftypefn

@deftypefn {Built-in Function} int __builtin_arc_divaw (int @var{a}, int @var{b})
@option{-mcpu=ARC700}または@option{-meA}が設定されている場合にのみ使用できる。以下を生成する：
@example
divaw  @var{dest}, @var{a}, @var{b}
@end example
ここで@var{dest}の値は組み込みから返された結果になる。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_flag (unsigned int @var{a})
以下を生成する
@example
flag  @var{a}
@end example
@end deftypefn

@deftypefn {Built-in Function} {unsigned int} __builtin_arc_lr (unsigned int @var{auxr})
オペランド@var{auxv}は補助レジスタのアドレスであり、コンパイル時定数でなければならない。以下を生成する：
@example
lr  @var{dest}, [@var{auxr}]
@end example
@var{dest}の値は、組み込み関数から返される結果になる。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_mul64 (int @var{a}, int @var{b})
@option{-mmul64}でのみ利用可能である。 以下を生成する：
@example
mul64  @var{a}, @var{b}
@end example
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_mulu64 (unsigned int @var{a}, unsigned int @var{b})
@option{-mmul64}でのみ利用可能である。 以下を生成する：
@example
mulu64  @var{a}, @var{b}
@end example
@end deftypefn

@deftypefn {Built-in Function} void __builtin_arc_nop (void)
以下を生成する：
@example
nop
@end example
@end deftypefn

@deftypefn {Built-in Function} int __builtin_arc_norm (int @var{src})
@samp{norm}命令が@option{-mnorm}オプションで使用可能な場合、または@option{-mcpu=ARC700}でデフォルトで有効である。以下を生成する：
@example
norm  @var{dest}, @var{src}
@end example
@var{dest}の値は、組み込み関数から返される結果になる。
@end deftypefn

@deftypefn {Built-in Function}  {short int} __builtin_arc_normw (short int @var{src})
@samp{normw}命令が@option{-mnorm}オプションで使用可能な場合、また@option{-mcpu = ARC700}ではデフォルトで有効である。以下を生成する：
@example
normw  @var{dest}, @var{src}
@end example
@var{dest}の値は、組み込み関数から返される結果になる。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_rtie (void)
以下を生成する：
@example
rtie
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_sleep (int @var{a})
以下を生成する：
@example
sleep  @var{a}
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_sr (unsigned int @var{auxr}, unsigned int @var{val})
最初の引数@var{auxv}は補助レジスタのアドレスで、2番目の引数@var{val}はレジスタに書き込まれるコンパイル時定数である。以下を生成する：
@example
sr  @var{auxr}, [@var{val}]
@end example
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_arc_swap (int @var{src})
@option{-mswap}でのみ有効である。以下を生成する。
@example
swap  @var{dest}, @var{src}
@end example
@var{dest}の値は、組み込み関数から返される結果になる。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_swi (void)
以下を生成する：
@example
swi
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_sync (void)
@option{-mcpu=ARC700}でのみ利用可能である。以下を生成する。
@example
sync
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_trap_s (unsigned int @var{c})
@option{-mcpu=ARC700}でのみ利用可能である。以下を生成する。
@example
trap_s  @var{c}
@end example
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_arc_unimp_s (void)
@option{-mcpu=ARC700}でのみ利用可能である。以下を生成する。
@example
unimp_s
@end example
@end deftypefn

次の組み込み関数によって生成される命令は、スケジューリングの候補とはみなされない。 スケジューリング中にコンパイラによって移動されることはないため、Cコードのどこに配置されるかは予測可能である。
@example
__builtin_arc_brk()
__builtin_arc_core_read()
__builtin_arc_core_write()
__builtin_arc_flag()
__builtin_arc_lr()
__builtin_arc_sleep()
__builtin_arc_sr()
__builtin_arc_swi()
@end example

@node ARC SIMD Built-in Functions
@subsection ARC SIMD組み込み関数

コンパイラによって提供されるSIMD組み込み関数は、ベクトル命令を生成するために使用できる。 このセクションでは、使用可能な組み込み関数とそのプログラムでの使用法について説明する。 @option{-msimd}オプションを使用すると、コンパイラは128ビットのベクトル型を提供する。これは@code{vector_size}属性を使用して指定できる。 ヘッダーファイル@file{arc-simd.h}は、次の定義済み型を使用するためにインクルードできる。
@example
typedef int __v4si   __attribute__((vector_size(16)));
typedef short __v8hi __attribute__((vector_size(16)));
@end example

これらの型を使用して、128ビットの変数を定義することができる。これらの変数で使用して、 次のセクションにリストされた組み込み関数を、ベクトル演算を生成するために使うことができる。

@code{__builtin_arc_@var{someinsn}}のすべての組み込み関数について、ヘッダーファイル@file{arc-simd.h}には、プログラミングの容易さと読みやすさが向上したプログラミングに使用できる@code{_@var{someinsn}}という同等のマクロも用意されている。DMA制御用の以下のマクロも提供されている。
@example
#define _setup_dma_in_channel_reg _vdiwr
#define _setup_dma_out_channel_reg _vdowr
@end example

以下は、ARCのために提供されるすべてのSIMDビルトインの完全なリストであり、呼び出しシグネチャでグループ化されている。

次は2つの@code{__ v8hi}引数をとり、@code{__ v8hi}の結果を返す。
@example
__v8hi __builtin_arc_vaddaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vaddw (__v8hi, __v8hi)
__v8hi __builtin_arc_vand (__v8hi, __v8hi)
__v8hi __builtin_arc_vandaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vavb (__v8hi, __v8hi)
__v8hi __builtin_arc_vavrb (__v8hi, __v8hi)
__v8hi __builtin_arc_vbic (__v8hi, __v8hi)
__v8hi __builtin_arc_vbicaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vdifaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vdifw (__v8hi, __v8hi)
__v8hi __builtin_arc_veqw (__v8hi, __v8hi)
__v8hi __builtin_arc_vh264f (__v8hi, __v8hi)
__v8hi __builtin_arc_vh264ft (__v8hi, __v8hi)
__v8hi __builtin_arc_vh264fw (__v8hi, __v8hi)
__v8hi __builtin_arc_vlew (__v8hi, __v8hi)
__v8hi __builtin_arc_vltw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmaxaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmaxw (__v8hi, __v8hi)
__v8hi __builtin_arc_vminaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vminw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr1aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr1w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr2aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr2w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr3aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr3w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr4aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr4w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr5aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr5w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr6aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr6w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr7aw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmr7w (__v8hi, __v8hi)
__v8hi __builtin_arc_vmrb (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulfaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulfw (__v8hi, __v8hi)
__v8hi __builtin_arc_vmulw (__v8hi, __v8hi)
__v8hi __builtin_arc_vnew (__v8hi, __v8hi)
__v8hi __builtin_arc_vor (__v8hi, __v8hi)
__v8hi __builtin_arc_vsubaw (__v8hi, __v8hi)
__v8hi __builtin_arc_vsubw (__v8hi, __v8hi)
__v8hi __builtin_arc_vsummw (__v8hi, __v8hi)
__v8hi __builtin_arc_vvc1f (__v8hi, __v8hi)
__v8hi __builtin_arc_vvc1ft (__v8hi, __v8hi)
__v8hi __builtin_arc_vxor (__v8hi, __v8hi)
__v8hi __builtin_arc_vxoraw (__v8hi, __v8hi)
@end example

以下は@code{__ v8hi}と@code{int}引数をとり、@code{__ v8hi}の結果を返す：

@example
__v8hi __builtin_arc_vbaddw (__v8hi, int)
__v8hi __builtin_arc_vbmaxw (__v8hi, int)
__v8hi __builtin_arc_vbminw (__v8hi, int)
__v8hi __builtin_arc_vbmulaw (__v8hi, int)
__v8hi __builtin_arc_vbmulfw (__v8hi, int)
__v8hi __builtin_arc_vbmulw (__v8hi, int)
__v8hi __builtin_arc_vbrsubw (__v8hi, int)
__v8hi __builtin_arc_vbsubw (__v8hi, int)
@end example

次の1つの@code{__v8hi}引数と1つの@code{int}引数をとり、後者はレジスタ番号I0〜I7を示す3ビットのコンパイル時定数でなければならない。それらは@code{__v8hi}の結果を返す。

@example
__v8hi __builtin_arc_vasrw (__v8hi, const int)
__v8hi __builtin_arc_vsr8 (__v8hi, const int)
__v8hi __builtin_arc_vsr8aw (__v8hi, const int)
@end example

以下は1つの@code{__ v8hi}引数と1つの@code{int}引数をとり、後者は6ビットのコンパイル時定数でなければならない。 それらは@code{__v8hi}の結果を返す。

@example
__v8hi __builtin_arc_vasrpwbi (__v8hi, const int)
__v8hi __builtin_arc_vasrrpwbi (__v8hi, const int)
__v8hi __builtin_arc_vasrrwi (__v8hi, const int)
__v8hi __builtin_arc_vasrsrwi (__v8hi, const int)
__v8hi __builtin_arc_vasrwi (__v8hi, const int)
__v8hi __builtin_arc_vsr8awi (__v8hi, const int)
__v8hi __builtin_arc_vsr8i (__v8hi, const int)
@end example

以下は1つの@code{__v8hi}引数と1つの@code{int}引数を取り、後者は8ビットのコンパイル時定数でなければならない。それらは@code{__v8hi}の結果を返す。

@example
__v8hi __builtin_arc_vd6tapf (__v8hi, const int)
__v8hi __builtin_arc_vmvaw (__v8hi, const int)
__v8hi __builtin_arc_vmvw (__v8hi, const int)
__v8hi __builtin_arc_vmvzw (__v8hi, const int)
@end example

以下は2つの@code{int}引数を取る。そのうち2つ目は8ビットのコンパイル時定数でなければならない。 それらは@code{__ v8hi}の結果を返す：

@example
__v8hi __builtin_arc_vmovaw (int, const int)
__v8hi __builtin_arc_vmovw (int, const int)
__v8hi __builtin_arc_vmovzw (int, const int)
@end example

以下は単一の@code{__ v8hi}引数をとり、@code{__ v8hi}の結果を返す：

@example
__v8hi __builtin_arc_vabsaw (__v8hi)
__v8hi __builtin_arc_vabsw (__v8hi)
__v8hi __builtin_arc_vaddsuw (__v8hi)
__v8hi __builtin_arc_vexch1 (__v8hi)
__v8hi __builtin_arc_vexch2 (__v8hi)
__v8hi __builtin_arc_vexch4 (__v8hi)
__v8hi __builtin_arc_vsignw (__v8hi)
__v8hi __builtin_arc_vupbaw (__v8hi)
__v8hi __builtin_arc_vupbw (__v8hi)
__v8hi __builtin_arc_vupsbaw (__v8hi)
__v8hi __builtin_arc_vupsbw (__v8hi)
@end example

以下は2つの@code{int}引数をとり、結果を返さない：

@example
void __builtin_arc_vdirun (int, int)
void __builtin_arc_vdorun (int, int)
@end example

以下は2つの@code{int}引数をとり、結果を返さない。 最初の引数は、DR0-DR7 DMAセットアップチャネルの1つを示す3ビットのコンパイル時定数でなければならない。
@example
void __builtin_arc_vdiwr (const int, int)
void __builtin_arc_vdowr (const int, int)
@end example

以下は@code{int}引数をとり、結果を返さない：

@example
void __builtin_arc_vendrec (int)
void __builtin_arc_vrec (int)
void __builtin_arc_vrecrun (int)
void __builtin_arc_vrun (int)
@end example

以下は@code{__v8hi}引数と2つの@code{int}引数をとり、@code{__v8hi}の結果を返す。 2番目の引数は3ビットのコンパイル時定数で、レジスタI0〜I7の1つを示し、3番目の引数は8ビットのコンパイル時定数でなければならない。

@emph{注意:} 同等のハードウェア命令はオペランドとしてSIMDレジスタを取らないが、これらの組み込み関数では、第1引数として提供される@code{__ v8hi}レジスタの関連ビットをSDMでの@code{[Ib、u8]}位置からロードされた値で上書きする。

@example
__v8hi __builtin_arc_vld32 (__v8hi, const int, const int)
__v8hi __builtin_arc_vld32wh (__v8hi, const int, const int)
__v8hi __builtin_arc_vld32wl (__v8hi, const int, const int)
__v8hi __builtin_arc_vld64 (__v8hi, const int, const int)
@end example

以下は2つの@code{int}引数をとり、@code{__ v8hi}の結果を返す。 最初の引数は3ビットのコンパイル時定数で、レジスタI0〜I7の1つを示し、2番目の引数は8ビットのコンパイル時定数でなければならない。

@example
__v8hi __builtin_arc_vld128 (const int, const int)
__v8hi __builtin_arc_vld64w (const int, const int)
@end example

以下は@code{__v8hi}引数と2つの@code{int}引数をとり、結果を返さない。 2番目の引数は3ビットのコンパイル時定数で、レジスタI0〜I7の1つを示し、3番目の引数は8ビットのコンパイル時定数でなければならない。

@example
void __builtin_arc_vst128 (__v8hi, const int, const int)
void __builtin_arc_vst64 (__v8hi, const int, const int)
@end example

以下は@code{__v8hi}引数と@code{int}引数をとり、結果を返さない。 2番目の引数は、格納される16ビットのサブレジスタを識別する3ビットのコンパイル時定数でなければならず、3番目の引数はレジスタI0〜I7の1つを示す3ビットのコンパイル時定数でなければならず、4番目の引数は8ビットのコンパイル時定数でなければならない。

@example
void __builtin_arc_vst16_n (__v8hi, const int, const int, const int)
void __builtin_arc_vst32_n (__v8hi, const int, const int, const int)
@end example

@node ARM iWMMXt Built-in Functions
@subsection ARM iWMMXt組み込み関数

これらの組み込み関数は、@option {-mcpu=iwmmxt}スイッチを使用すると、ARMファミリのプロセッサで使用できる。

@smallexample
typedef int v2si __attribute__ ((vector_size (8)));
typedef short v4hi __attribute__ ((vector_size (8)));
typedef char v8qi __attribute__ ((vector_size (8)));

int __builtin_arm_getwcgr0 (void)
void __builtin_arm_setwcgr0 (int)
int __builtin_arm_getwcgr1 (void)
void __builtin_arm_setwcgr1 (int)
int __builtin_arm_getwcgr2 (void)
void __builtin_arm_setwcgr2 (int)
int __builtin_arm_getwcgr3 (void)
void __builtin_arm_setwcgr3 (int)
int __builtin_arm_textrmsb (v8qi, int)
int __builtin_arm_textrmsh (v4hi, int)
int __builtin_arm_textrmsw (v2si, int)
int __builtin_arm_textrmub (v8qi, int)
int __builtin_arm_textrmuh (v4hi, int)
int __builtin_arm_textrmuw (v2si, int)
v8qi __builtin_arm_tinsrb (v8qi, int, int)
v4hi __builtin_arm_tinsrh (v4hi, int, int)
v2si __builtin_arm_tinsrw (v2si, int, int)
long long __builtin_arm_tmia (long long, int, int)
long long __builtin_arm_tmiabb (long long, int, int)
long long __builtin_arm_tmiabt (long long, int, int)
long long __builtin_arm_tmiaph (long long, int, int)
long long __builtin_arm_tmiatb (long long, int, int)
long long __builtin_arm_tmiatt (long long, int, int)
int __builtin_arm_tmovmskb (v8qi)
int __builtin_arm_tmovmskh (v4hi)
int __builtin_arm_tmovmskw (v2si)
long long __builtin_arm_waccb (v8qi)
long long __builtin_arm_wacch (v4hi)
long long __builtin_arm_waccw (v2si)
v8qi __builtin_arm_waddb (v8qi, v8qi)
v8qi __builtin_arm_waddbss (v8qi, v8qi)
v8qi __builtin_arm_waddbus (v8qi, v8qi)
v4hi __builtin_arm_waddh (v4hi, v4hi)
v4hi __builtin_arm_waddhss (v4hi, v4hi)
v4hi __builtin_arm_waddhus (v4hi, v4hi)
v2si __builtin_arm_waddw (v2si, v2si)
v2si __builtin_arm_waddwss (v2si, v2si)
v2si __builtin_arm_waddwus (v2si, v2si)
v8qi __builtin_arm_walign (v8qi, v8qi, int)
long long __builtin_arm_wand(long long, long long)
long long __builtin_arm_wandn (long long, long long)
v8qi __builtin_arm_wavg2b (v8qi, v8qi)
v8qi __builtin_arm_wavg2br (v8qi, v8qi)
v4hi __builtin_arm_wavg2h (v4hi, v4hi)
v4hi __builtin_arm_wavg2hr (v4hi, v4hi)
v8qi __builtin_arm_wcmpeqb (v8qi, v8qi)
v4hi __builtin_arm_wcmpeqh (v4hi, v4hi)
v2si __builtin_arm_wcmpeqw (v2si, v2si)
v8qi __builtin_arm_wcmpgtsb (v8qi, v8qi)
v4hi __builtin_arm_wcmpgtsh (v4hi, v4hi)
v2si __builtin_arm_wcmpgtsw (v2si, v2si)
v8qi __builtin_arm_wcmpgtub (v8qi, v8qi)
v4hi __builtin_arm_wcmpgtuh (v4hi, v4hi)
v2si __builtin_arm_wcmpgtuw (v2si, v2si)
long long __builtin_arm_wmacs (long long, v4hi, v4hi)
long long __builtin_arm_wmacsz (v4hi, v4hi)
long long __builtin_arm_wmacu (long long, v4hi, v4hi)
long long __builtin_arm_wmacuz (v4hi, v4hi)
v4hi __builtin_arm_wmadds (v4hi, v4hi)
v4hi __builtin_arm_wmaddu (v4hi, v4hi)
v8qi __builtin_arm_wmaxsb (v8qi, v8qi)
v4hi __builtin_arm_wmaxsh (v4hi, v4hi)
v2si __builtin_arm_wmaxsw (v2si, v2si)
v8qi __builtin_arm_wmaxub (v8qi, v8qi)
v4hi __builtin_arm_wmaxuh (v4hi, v4hi)
v2si __builtin_arm_wmaxuw (v2si, v2si)
v8qi __builtin_arm_wminsb (v8qi, v8qi)
v4hi __builtin_arm_wminsh (v4hi, v4hi)
v2si __builtin_arm_wminsw (v2si, v2si)
v8qi __builtin_arm_wminub (v8qi, v8qi)
v4hi __builtin_arm_wminuh (v4hi, v4hi)
v2si __builtin_arm_wminuw (v2si, v2si)
v4hi __builtin_arm_wmulsm (v4hi, v4hi)
v4hi __builtin_arm_wmulul (v4hi, v4hi)
v4hi __builtin_arm_wmulum (v4hi, v4hi)
long long __builtin_arm_wor (long long, long long)
v2si __builtin_arm_wpackdss (long long, long long)
v2si __builtin_arm_wpackdus (long long, long long)
v8qi __builtin_arm_wpackhss (v4hi, v4hi)
v8qi __builtin_arm_wpackhus (v4hi, v4hi)
v4hi __builtin_arm_wpackwss (v2si, v2si)
v4hi __builtin_arm_wpackwus (v2si, v2si)
long long __builtin_arm_wrord (long long, long long)
long long __builtin_arm_wrordi (long long, int)
v4hi __builtin_arm_wrorh (v4hi, long long)
v4hi __builtin_arm_wrorhi (v4hi, int)
v2si __builtin_arm_wrorw (v2si, long long)
v2si __builtin_arm_wrorwi (v2si, int)
v2si __builtin_arm_wsadb (v2si, v8qi, v8qi)
v2si __builtin_arm_wsadbz (v8qi, v8qi)
v2si __builtin_arm_wsadh (v2si, v4hi, v4hi)
v2si __builtin_arm_wsadhz (v4hi, v4hi)
v4hi __builtin_arm_wshufh (v4hi, int)
long long __builtin_arm_wslld (long long, long long)
long long __builtin_arm_wslldi (long long, int)
v4hi __builtin_arm_wsllh (v4hi, long long)
v4hi __builtin_arm_wsllhi (v4hi, int)
v2si __builtin_arm_wsllw (v2si, long long)
v2si __builtin_arm_wsllwi (v2si, int)
long long __builtin_arm_wsrad (long long, long long)
long long __builtin_arm_wsradi (long long, int)
v4hi __builtin_arm_wsrah (v4hi, long long)
v4hi __builtin_arm_wsrahi (v4hi, int)
v2si __builtin_arm_wsraw (v2si, long long)
v2si __builtin_arm_wsrawi (v2si, int)
long long __builtin_arm_wsrld (long long, long long)
long long __builtin_arm_wsrldi (long long, int)
v4hi __builtin_arm_wsrlh (v4hi, long long)
v4hi __builtin_arm_wsrlhi (v4hi, int)
v2si __builtin_arm_wsrlw (v2si, long long)
v2si __builtin_arm_wsrlwi (v2si, int)
v8qi __builtin_arm_wsubb (v8qi, v8qi)
v8qi __builtin_arm_wsubbss (v8qi, v8qi)
v8qi __builtin_arm_wsubbus (v8qi, v8qi)
v4hi __builtin_arm_wsubh (v4hi, v4hi)
v4hi __builtin_arm_wsubhss (v4hi, v4hi)
v4hi __builtin_arm_wsubhus (v4hi, v4hi)
v2si __builtin_arm_wsubw (v2si, v2si)
v2si __builtin_arm_wsubwss (v2si, v2si)
v2si __builtin_arm_wsubwus (v2si, v2si)
v4hi __builtin_arm_wunpckehsb (v8qi)
v2si __builtin_arm_wunpckehsh (v4hi)
long long __builtin_arm_wunpckehsw (v2si)
v4hi __builtin_arm_wunpckehub (v8qi)
v2si __builtin_arm_wunpckehuh (v4hi)
long long __builtin_arm_wunpckehuw (v2si)
v4hi __builtin_arm_wunpckelsb (v8qi)
v2si __builtin_arm_wunpckelsh (v4hi)
long long __builtin_arm_wunpckelsw (v2si)
v4hi __builtin_arm_wunpckelub (v8qi)
v2si __builtin_arm_wunpckeluh (v4hi)
long long __builtin_arm_wunpckeluw (v2si)
v8qi __builtin_arm_wunpckihb (v8qi, v8qi)
v4hi __builtin_arm_wunpckihh (v4hi, v4hi)
v2si __builtin_arm_wunpckihw (v2si, v2si)
v8qi __builtin_arm_wunpckilb (v8qi, v8qi)
v4hi __builtin_arm_wunpckilh (v4hi, v4hi)
v2si __builtin_arm_wunpckilw (v2si, v2si)
long long __builtin_arm_wxor (long long, long long)
long long __builtin_arm_wzero ()
@end smallexample


@node ARM C Language Extensions (ACLE)
@subsection ARM C言語拡張(ACLE)

GCCは、@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf}で見つかるARM C言語拡張（ACLE）仕様に記述されている、Cの拡張を実装している。

GCCはACLEの一部として、ARM C言語拡張仕様で説明されているように拡張SIMDの拡張を実装している。 高度なSIMD組み込み関数の完全なリストは@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf}で見つかる。拡張SIMD拡張の組み込み関数は、NEONが有効な場合に使用できる。

現在、ARMおよびAArch64のバックエンドは、ACLE 2.0を完全にサポートしていない。 両方のバックエンドはCRC32の組み込み関数をサポートし、ARMのバックエンドは@file{arm_acle.h}のコプロセッサー組み込み関数をサポートしている。 ARMバックエンドの16ビット浮動小数点アドバンストSIMD組み込み関数は、現在、ACLE v1.1に準拠している。AArch64のバックエンドはまだ16ビット浮動小数点アドバンストSIMD組み込み関数をサポートしていない。

拡張機能の利用可能性の詳細については、@ref{ARM Options}と@ref{AArch64 Options}を参照せよ。

@node ARM Floating Point Status and Control Intrinsics
@subsection ARM浮動小数点ステータスと制御組み込み関数

これらの組み込み関数は、浮動小数点ユニットを持つARMファミリのプロセッサで使用できる。

@smallexample
unsigned int __builtin_arm_get_fpscr ()
void __builtin_arm_set_fpscr (unsigned int)
@end smallexample

@node ARM ARMv8-M Security Extensions
@subsection ARM ARMv8-Mセキュリティ拡張

GCCは、@uref{http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf}で見つかる「ARMv8-Mセキュリティ拡張：開発ツールのエンジニアリング仕様に関する要件」で説明されている、ARMv8-Mセキュリティ拡張を実装している。

セキュリティ拡張の一部として、GCCは2つの新しい関数属性、@code{cmse_nonsecure_entry}と@code{cmse_nonsecure_call}を実装している。

セキュリティ拡張の一部として、GCCは以下の組み込み関数を実装する。 FPTRは、関数のポインタ型を意味するためにここで使用される。

@smallexample
cmse_address_info_t cmse_TT (void *)
cmse_address_info_t cmse_TT_fptr (FPTR)
cmse_address_info_t cmse_TTT (void *)
cmse_address_info_t cmse_TTT_fptr (FPTR)
cmse_address_info_t cmse_TTA (void *)
cmse_address_info_t cmse_TTA_fptr (FPTR)
cmse_address_info_t cmse_TTAT (void *)
cmse_address_info_t cmse_TTAT_fptr (FPTR)
void * cmse_check_address_range (void *, size_t, int)
typeof(p) cmse_nsfptr_create (FPTR p)
intptr_t cmse_is_nsfptr (FPTR)
int cmse_nonsecure_caller (void)
@end smallexample

@node AVR Built-in Functions
@subsection AVR組み込み関数

AVRの組み込み関数ごとに、同じ名前の大文字の組み込みマクロが定義されている。 こうすることで、ユーザーは特定のビルトインが実装されているかどうかを簡単に照会できる。 たとえば、@code{__builtin_avr_nop}は利用可能ならば、マクロ@code{__BUILTIN_AVR_NOP}は@code {1}に定義され、それ以外の場合は未定義である。

@table @code

@item void __builtin_avr_nop (void)
@itemx void __builtin_avr_sei (void)
@itemx void __builtin_avr_cli (void)
@itemx void __builtin_avr_sleep (void)
@itemx void __builtin_avr_wdr (void)
@itemx unsigned char __builtin_avr_swap (unsigned char)
@itemx unsigned int __builtin_avr_fmul (unsigned char, unsigned char)
@itemx int __builtin_avr_fmuls (char, char)
@itemx int __builtin_avr_fmulsu (char, unsigned char)
これらの組み込み関数はそれぞれの機械命令に対応する、すなわち、それぞれ、@code{nop}, @code{sei}, @code{cli}, @code{sleep}, @code{wdr}, @code{swap}, @code{fmul}, @code{fmuls}, @code{fmulsu}. 
3つの@code{fmul *}組み込み関数は、ハードウェア乗数がない場合はライブラリ呼び出しとして実装される。

@item void __builtin_avr_delay_cycles (unsigned long ticks)
@var{ticks}サイクルの遅延実行。 この組み込み関数は、遅延時間を増加させる可能性のある割り込みの影響を考慮していないことに注意せよ。 @var{ticks}はコンパイル時の整数定数でなければならない。 可変サイクル数の遅延はサポートされていない。

@item char __builtin_avr_flash_segment (const __memx void*)
この組み込み関数は、24ビットの@ref{AVR Named Address Spaces,アドレス空間} @code {__ memx}にバイトアドレスを取り、アドレスが指すフラッシュセグメント（64 KiBチャンク）の番号を返す。 カウントは@code{0}から始まる。 アドレスがフラッシュメモリを指していない場合は、@code{-1}を返す。

@item uint8_t __builtin_avr_insert_bits (uint32_t map, uint8_t bits, uint8_t val)
@var{bits}から@var{val}にビットを挿入し、結果の値を返す。 @var{map}のニブルは、挿入がどのように行われるかを決定する：@var{X}を@var{map}の@var{n}番目のニブルにするとき
@enumerate
@item もし@var{X}が@code{0xf}ならば、
@var{val}の@var{n}ビットは変更されずに返される。

@item もしXが範囲0から7ならば、
@var{n}番目の結果ビットは@var{bits}の@var{X}ビットにセットされる

@item もしXが範囲8から@code{0xe}ならば、
@ var {n}番目の結果ビットは未定義である。
@end enumerate

@noindent
この組み込み関数の典型的な使用例の1つは、入力値と出力値を不連続なポートレイアウトに調整することです。 いくつかの例：

@smallexample
// same as val, bits is unused
__builtin_avr_insert_bits (0xffffffff, bits, val)
@end smallexample

@smallexample
// same as bits, val is unused
__builtin_avr_insert_bits (0x76543210, bits, val)
@end smallexample

@smallexample
// same as rotating bits by 4
__builtin_avr_insert_bits (0x32107654, bits, 0)
@end smallexample

@smallexample
// high nibble of result is the high nibble of val
// low nibble of result is the low nibble of bits
__builtin_avr_insert_bits (0xffff3210, bits, val)
@end smallexample

@smallexample
// reverse the bit order of bits
__builtin_avr_insert_bits (0x01234567, bits, 0)
@end smallexample

@item void __builtin_avr_nops (unsigned count)
@var{count}の@code{NOP}命令を挿入する。命令の数は、コンパイル時の整数定数でなければならない。

@end table

@noindent
ISO / IEC TR 18037 "Embedded C"の7.18a.6節の固定小数点関数を実装するために使用されるAVR固有の組み込み関数がさらに多くある。 これらの組み込み関数を直接使用する必要はない。代わりに、GNU-C99の@code{stdfix.h}ヘッダーで指定されている宣言を使用する。

@smallexample
#include <stdfix.h>

// Re-interpret the bit representation of unsigned 16-bit
// integer @var{uval} as Q-format 0.16 value.
unsigned fract get_bits (uint_ur_t uval)
@{
    return urbits (uval);
@}
@end smallexample

@node Blackfin Built-in Functions
@subsection Blackfin組み込み関数

現在、Blackfin固有の組み込み関数が2つある。 これらは、インラインアセンブリを使用せずに@code{CSYNC}と@code{SSYNC}マシン命令を生成するために使用される。 これらの組み込み関数を使用することにより、コンパイラはこれらの命令を含むハードウェアエラッタの回避策を自動的に追加できる。 これらの関数の名前は次のとおりである。

@smallexample
void __builtin_bfin_csync (void)
void __builtin_bfin_ssync (void)
@end smallexample

@node FR-V Built-in Functions
@subsection FR-V組み込み関数

GCCは多くのFR-V固有の組み込み関数を提供します。 一般に、これらの関数は@cite{FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor}で記述されているものと互換性があることを意図している。 2つの例外は@code{__MDUNPACKH}と@code{__MBTOHE}で、GCC形式のものは値ではなくポインタで128ビットの値を渡す。

ほとんどの機能は、特定のFR-V命令の名前に基づいている。そのような機能は「直接マッピング」されており、ここでは表形式で要約されている。

@menu
* Argument Types::
* Directly-mapped Integer Functions::
* Directly-mapped Media Functions::
* Raw read/write Functions::
* Other Built-in Functions::
@end menu

@node Argument Types
@subsubsection 引数型

組み込み関数への引数は、レジスタ番号、コンパイル時定数、および実行時の値の3つのグループに分けられる。 この分類を一目瞭然にするために、引数と戻り値には次の擬似型が与えられる。

@multitable @columnfractions .20 .30 .15 .35
@item 擬似型 @tab 真のC型 @tab 定数? @tab 説明
@item @code{uh} @tab @code{unsigned short} @tab No @tab 符号なしのハーフワード
@item @code{uw1} @tab @code{unsigned int} @tab No @tab 符号なしのワード
@item @code{sw1} @tab @code{int} @tab No @tab 符号ありのワード
@item @code{uw2} @tab @code{unsigned long long} @tab No
@tab 符号なしのダブルワード
@item @code{sw2} @tab @code{long long} @tab No @tab 符号ありのダブルワード
@item @code{const} @tab @code{int} @tab Yes @tab 整数定数
@item @code{acc} @tab @code{int} @tab Yes @tab ACCレジスタ番号
@item @code{iacc} @tab @code{int} @tab Yes @tab IACCレジスタ番号
@end multitable

これらの擬似型はGCCでは定義されていないが、本書では表記上の便宜のために使用している。

@code{uh}、@code{uw1}、@code{sw1}、@code{uw2}、@code{sw2}の引数は、実行時に評価される。 それらは、基礎をなすFR-V命令のレジスタオペランドに対応する。

@code{const}引数は、基になるFR-V命令の即値オペランドを表す。 コンパイル時定数でなければならない。

@code{acc}引数はコンパイル時に評価され、アキュムレータレジスタの数を指定する。 たとえば、2の@code{acc}引数はACC2レジスタを選択する。

@code{iacc}引数は@code{acc}引数に似ているが、IACCレジスタの番号を指定する。 詳細については、@pxref{Other Built-in Functions}を参照せよ。

@node Directly-mapped Integer Functions
@subsubsection 直接マップされた整数関数

以下の関数は、FR-V Iタイプの命令に直接マップされている。

@multitable @columnfractions .45 .32 .23
@item 関数プロトタイプ @tab 使用例 @tab アセンブリの出力
@item @code{sw1 __ADDSS (sw1, sw1)}
@tab @code{@var{c} = __ADDSS (@var{a}, @var{b})}
@tab @code{ADDSS @var{a},@var{b},@var{c}}
@item @code{sw1 __SCAN (sw1, sw1)}
@tab @code{@var{c} = __SCAN (@var{a}, @var{b})}
@tab @code{SCAN @var{a},@var{b},@var{c}}
@item @code{sw1 __SCUTSS (sw1)}
@tab @code{@var{b} = __SCUTSS (@var{a})}
@tab @code{SCUTSS @var{a},@var{b}}
@item @code{sw1 __SLASS (sw1, sw1)}
@tab @code{@var{c} = __SLASS (@var{a}, @var{b})}
@tab @code{SLASS @var{a},@var{b},@var{c}}
@item @code{void __SMASS (sw1, sw1)}
@tab @code{__SMASS (@var{a}, @var{b})}
@tab @code{SMASS @var{a},@var{b}}
@item @code{void __SMSSS (sw1, sw1)}
@tab @code{__SMSSS (@var{a}, @var{b})}
@tab @code{SMSSS @var{a},@var{b}}
@item @code{void __SMU (sw1, sw1)}
@tab @code{__SMU (@var{a}, @var{b})}
@tab @code{SMU @var{a},@var{b}}
@item @code{sw2 __SMUL (sw1, sw1)}
@tab @code{@var{c} = __SMUL (@var{a}, @var{b})}
@tab @code{SMUL @var{a},@var{b},@var{c}}
@item @code{sw1 __SUBSS (sw1, sw1)}
@tab @code{@var{c} = __SUBSS (@var{a}, @var{b})}
@tab @code{SUBSS @var{a},@var{b},@var{c}}
@item @code{uw2 __UMUL (uw1, uw1)}
@tab @code{@var{c} = __UMUL (@var{a}, @var{b})}
@tab @code{UMUL @var{a},@var{b},@var{c}}
@end multitable

@node Directly-mapped Media Functions
@subsubsection 直接マップされたメディア関数

以下の関数は、FR-V Mタイプの命令に直接マップされている。

@multitable @columnfractions .45 .32 .23
@item 関数プロトタイプ @tab 使用例 @tab アセンブリの出力
@item @code{uw1 __MABSHS (sw1)}
@tab @code{@var{b} = __MABSHS (@var{a})}
@tab @code{MABSHS @var{a},@var{b}}
@item @code{void __MADDACCS (acc, acc)}
@tab @code{__MADDACCS (@var{b}, @var{a})}
@tab @code{MADDACCS @var{a},@var{b}}
@item @code{sw1 __MADDHSS (sw1, sw1)}
@tab @code{@var{c} = __MADDHSS (@var{a}, @var{b})}
@tab @code{MADDHSS @var{a},@var{b},@var{c}}
@item @code{uw1 __MADDHUS (uw1, uw1)}
@tab @code{@var{c} = __MADDHUS (@var{a}, @var{b})}
@tab @code{MADDHUS @var{a},@var{b},@var{c}}
@item @code{uw1 __MAND (uw1, uw1)}
@tab @code{@var{c} = __MAND (@var{a}, @var{b})}
@tab @code{MAND @var{a},@var{b},@var{c}}
@item @code{void __MASACCS (acc, acc)}
@tab @code{__MASACCS (@var{b}, @var{a})}
@tab @code{MASACCS @var{a},@var{b}}
@item @code{uw1 __MAVEH (uw1, uw1)}
@tab @code{@var{c} = __MAVEH (@var{a}, @var{b})}
@tab @code{MAVEH @var{a},@var{b},@var{c}}
@item @code{uw2 __MBTOH (uw1)}
@tab @code{@var{b} = __MBTOH (@var{a})}
@tab @code{MBTOH @var{a},@var{b}}
@item @code{void __MBTOHE (uw1 *, uw1)}
@tab @code{__MBTOHE (&@var{b}, @var{a})}
@tab @code{MBTOHE @var{a},@var{b}}
@item @code{void __MCLRACC (acc)}
@tab @code{__MCLRACC (@var{a})}
@tab @code{MCLRACC @var{a}}
@item @code{void __MCLRACCA (void)}
@tab @code{__MCLRACCA ()}
@tab @code{MCLRACCA}
@item @code{uw1 __Mcop1 (uw1, uw1)}
@tab @code{@var{c} = __Mcop1 (@var{a}, @var{b})}
@tab @code{Mcop1 @var{a},@var{b},@var{c}}
@item @code{uw1 __Mcop2 (uw1, uw1)}
@tab @code{@var{c} = __Mcop2 (@var{a}, @var{b})}
@tab @code{Mcop2 @var{a},@var{b},@var{c}}
@item @code{uw1 __MCPLHI (uw2, const)}
@tab @code{@var{c} = __MCPLHI (@var{a}, @var{b})}
@tab @code{MCPLHI @var{a},#@var{b},@var{c}}
@item @code{uw1 __MCPLI (uw2, const)}
@tab @code{@var{c} = __MCPLI (@var{a}, @var{b})}
@tab @code{MCPLI @var{a},#@var{b},@var{c}}
@item @code{void __MCPXIS (acc, sw1, sw1)}
@tab @code{__MCPXIS (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXIS @var{a},@var{b},@var{c}}
@item @code{void __MCPXIU (acc, uw1, uw1)}
@tab @code{__MCPXIU (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXIU @var{a},@var{b},@var{c}}
@item @code{void __MCPXRS (acc, sw1, sw1)}
@tab @code{__MCPXRS (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXRS @var{a},@var{b},@var{c}}
@item @code{void __MCPXRU (acc, uw1, uw1)}
@tab @code{__MCPXRU (@var{c}, @var{a}, @var{b})}
@tab @code{MCPXRU @var{a},@var{b},@var{c}}
@item @code{uw1 __MCUT (acc, uw1)}
@tab @code{@var{c} = __MCUT (@var{a}, @var{b})}
@tab @code{MCUT @var{a},@var{b},@var{c}}
@item @code{uw1 __MCUTSS (acc, sw1)}
@tab @code{@var{c} = __MCUTSS (@var{a}, @var{b})}
@tab @code{MCUTSS @var{a},@var{b},@var{c}}
@item @code{void __MDADDACCS (acc, acc)}
@tab @code{__MDADDACCS (@var{b}, @var{a})}
@tab @code{MDADDACCS @var{a},@var{b}}
@item @code{void __MDASACCS (acc, acc)}
@tab @code{__MDASACCS (@var{b}, @var{a})}
@tab @code{MDASACCS @var{a},@var{b}}
@item @code{uw2 __MDCUTSSI (acc, const)}
@tab @code{@var{c} = __MDCUTSSI (@var{a}, @var{b})}
@tab @code{MDCUTSSI @var{a},#@var{b},@var{c}}
@item @code{uw2 __MDPACKH (uw2, uw2)}
@tab @code{@var{c} = __MDPACKH (@var{a}, @var{b})}
@tab @code{MDPACKH @var{a},@var{b},@var{c}}
@item @code{uw2 __MDROTLI (uw2, const)}
@tab @code{@var{c} = __MDROTLI (@var{a}, @var{b})}
@tab @code{MDROTLI @var{a},#@var{b},@var{c}}
@item @code{void __MDSUBACCS (acc, acc)}
@tab @code{__MDSUBACCS (@var{b}, @var{a})}
@tab @code{MDSUBACCS @var{a},@var{b}}
@item @code{void __MDUNPACKH (uw1 *, uw2)}
@tab @code{__MDUNPACKH (&@var{b}, @var{a})}
@tab @code{MDUNPACKH @var{a},@var{b}}
@item @code{uw2 __MEXPDHD (uw1, const)}
@tab @code{@var{c} = __MEXPDHD (@var{a}, @var{b})}
@tab @code{MEXPDHD @var{a},#@var{b},@var{c}}
@item @code{uw1 __MEXPDHW (uw1, const)}
@tab @code{@var{c} = __MEXPDHW (@var{a}, @var{b})}
@tab @code{MEXPDHW @var{a},#@var{b},@var{c}}
@item @code{uw1 __MHDSETH (uw1, const)}
@tab @code{@var{c} = __MHDSETH (@var{a}, @var{b})}
@tab @code{MHDSETH @var{a},#@var{b},@var{c}}
@item @code{sw1 __MHDSETS (const)}
@tab @code{@var{b} = __MHDSETS (@var{a})}
@tab @code{MHDSETS #@var{a},@var{b}}
@item @code{uw1 __MHSETHIH (uw1, const)}
@tab @code{@var{b} = __MHSETHIH (@var{b}, @var{a})}
@tab @code{MHSETHIH #@var{a},@var{b}}
@item @code{sw1 __MHSETHIS (sw1, const)}
@tab @code{@var{b} = __MHSETHIS (@var{b}, @var{a})}
@tab @code{MHSETHIS #@var{a},@var{b}}
@item @code{uw1 __MHSETLOH (uw1, const)}
@tab @code{@var{b} = __MHSETLOH (@var{b}, @var{a})}
@tab @code{MHSETLOH #@var{a},@var{b}}
@item @code{sw1 __MHSETLOS (sw1, const)}
@tab @code{@var{b} = __MHSETLOS (@var{b}, @var{a})}
@tab @code{MHSETLOS #@var{a},@var{b}}
@item @code{uw1 __MHTOB (uw2)}
@tab @code{@var{b} = __MHTOB (@var{a})}
@tab @code{MHTOB @var{a},@var{b}}
@item @code{void __MMACHS (acc, sw1, sw1)}
@tab @code{__MMACHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMACHS @var{a},@var{b},@var{c}}
@item @code{void __MMACHU (acc, uw1, uw1)}
@tab @code{__MMACHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMACHU @var{a},@var{b},@var{c}}
@item @code{void __MMRDHS (acc, sw1, sw1)}
@tab @code{__MMRDHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMRDHS @var{a},@var{b},@var{c}}
@item @code{void __MMRDHU (acc, uw1, uw1)}
@tab @code{__MMRDHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMRDHU @var{a},@var{b},@var{c}}
@item @code{void __MMULHS (acc, sw1, sw1)}
@tab @code{__MMULHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMULHS @var{a},@var{b},@var{c}}
@item @code{void __MMULHU (acc, uw1, uw1)}
@tab @code{__MMULHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMULHU @var{a},@var{b},@var{c}}
@item @code{void __MMULXHS (acc, sw1, sw1)}
@tab @code{__MMULXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MMULXHS @var{a},@var{b},@var{c}}
@item @code{void __MMULXHU (acc, uw1, uw1)}
@tab @code{__MMULXHU (@var{c}, @var{a}, @var{b})}
@tab @code{MMULXHU @var{a},@var{b},@var{c}}
@item @code{uw1 __MNOT (uw1)}
@tab @code{@var{b} = __MNOT (@var{a})}
@tab @code{MNOT @var{a},@var{b}}
@item @code{uw1 __MOR (uw1, uw1)}
@tab @code{@var{c} = __MOR (@var{a}, @var{b})}
@tab @code{MOR @var{a},@var{b},@var{c}}
@item @code{uw1 __MPACKH (uh, uh)}
@tab @code{@var{c} = __MPACKH (@var{a}, @var{b})}
@tab @code{MPACKH @var{a},@var{b},@var{c}}
@item @code{sw2 __MQADDHSS (sw2, sw2)}
@tab @code{@var{c} = __MQADDHSS (@var{a}, @var{b})}
@tab @code{MQADDHSS @var{a},@var{b},@var{c}}
@item @code{uw2 __MQADDHUS (uw2, uw2)}
@tab @code{@var{c} = __MQADDHUS (@var{a}, @var{b})}
@tab @code{MQADDHUS @var{a},@var{b},@var{c}}
@item @code{void __MQCPXIS (acc, sw2, sw2)}
@tab @code{__MQCPXIS (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXIS @var{a},@var{b},@var{c}}
@item @code{void __MQCPXIU (acc, uw2, uw2)}
@tab @code{__MQCPXIU (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXIU @var{a},@var{b},@var{c}}
@item @code{void __MQCPXRS (acc, sw2, sw2)}
@tab @code{__MQCPXRS (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXRS @var{a},@var{b},@var{c}}
@item @code{void __MQCPXRU (acc, uw2, uw2)}
@tab @code{__MQCPXRU (@var{c}, @var{a}, @var{b})}
@tab @code{MQCPXRU @var{a},@var{b},@var{c}}
@item @code{sw2 __MQLCLRHS (sw2, sw2)}
@tab @code{@var{c} = __MQLCLRHS (@var{a}, @var{b})}
@tab @code{MQLCLRHS @var{a},@var{b},@var{c}}
@item @code{sw2 __MQLMTHS (sw2, sw2)}
@tab @code{@var{c} = __MQLMTHS (@var{a}, @var{b})}
@tab @code{MQLMTHS @var{a},@var{b},@var{c}}
@item @code{void __MQMACHS (acc, sw2, sw2)}
@tab @code{__MQMACHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMACHS @var{a},@var{b},@var{c}}
@item @code{void __MQMACHU (acc, uw2, uw2)}
@tab @code{__MQMACHU (@var{c}, @var{a}, @var{b})}
@tab @code{MQMACHU @var{a},@var{b},@var{c}}
@item @code{void __MQMACXHS (acc, sw2, sw2)}
@tab @code{__MQMACXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMACXHS @var{a},@var{b},@var{c}}
@item @code{void __MQMULHS (acc, sw2, sw2)}
@tab @code{__MQMULHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULHS @var{a},@var{b},@var{c}}
@item @code{void __MQMULHU (acc, uw2, uw2)}
@tab @code{__MQMULHU (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULHU @var{a},@var{b},@var{c}}
@item @code{void __MQMULXHS (acc, sw2, sw2)}
@tab @code{__MQMULXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULXHS @var{a},@var{b},@var{c}}
@item @code{void __MQMULXHU (acc, uw2, uw2)}
@tab @code{__MQMULXHU (@var{c}, @var{a}, @var{b})}
@tab @code{MQMULXHU @var{a},@var{b},@var{c}}
@item @code{sw2 __MQSATHS (sw2, sw2)}
@tab @code{@var{c} = __MQSATHS (@var{a}, @var{b})}
@tab @code{MQSATHS @var{a},@var{b},@var{c}}
@item @code{uw2 __MQSLLHI (uw2, int)}
@tab @code{@var{c} = __MQSLLHI (@var{a}, @var{b})}
@tab @code{MQSLLHI @var{a},@var{b},@var{c}}
@item @code{sw2 __MQSRAHI (sw2, int)}
@tab @code{@var{c} = __MQSRAHI (@var{a}, @var{b})}
@tab @code{MQSRAHI @var{a},@var{b},@var{c}}
@item @code{sw2 __MQSUBHSS (sw2, sw2)}
@tab @code{@var{c} = __MQSUBHSS (@var{a}, @var{b})}
@tab @code{MQSUBHSS @var{a},@var{b},@var{c}}
@item @code{uw2 __MQSUBHUS (uw2, uw2)}
@tab @code{@var{c} = __MQSUBHUS (@var{a}, @var{b})}
@tab @code{MQSUBHUS @var{a},@var{b},@var{c}}
@item @code{void __MQXMACHS (acc, sw2, sw2)}
@tab @code{__MQXMACHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQXMACHS @var{a},@var{b},@var{c}}
@item @code{void __MQXMACXHS (acc, sw2, sw2)}
@tab @code{__MQXMACXHS (@var{c}, @var{a}, @var{b})}
@tab @code{MQXMACXHS @var{a},@var{b},@var{c}}
@item @code{uw1 __MRDACC (acc)}
@tab @code{@var{b} = __MRDACC (@var{a})}
@tab @code{MRDACC @var{a},@var{b}}
@item @code{uw1 __MRDACCG (acc)}
@tab @code{@var{b} = __MRDACCG (@var{a})}
@tab @code{MRDACCG @var{a},@var{b}}
@item @code{uw1 __MROTLI (uw1, const)}
@tab @code{@var{c} = __MROTLI (@var{a}, @var{b})}
@tab @code{MROTLI @var{a},#@var{b},@var{c}}
@item @code{uw1 __MROTRI (uw1, const)}
@tab @code{@var{c} = __MROTRI (@var{a}, @var{b})}
@tab @code{MROTRI @var{a},#@var{b},@var{c}}
@item @code{sw1 __MSATHS (sw1, sw1)}
@tab @code{@var{c} = __MSATHS (@var{a}, @var{b})}
@tab @code{MSATHS @var{a},@var{b},@var{c}}
@item @code{uw1 __MSATHU (uw1, uw1)}
@tab @code{@var{c} = __MSATHU (@var{a}, @var{b})}
@tab @code{MSATHU @var{a},@var{b},@var{c}}
@item @code{uw1 __MSLLHI (uw1, const)}
@tab @code{@var{c} = __MSLLHI (@var{a}, @var{b})}
@tab @code{MSLLHI @var{a},#@var{b},@var{c}}
@item @code{sw1 __MSRAHI (sw1, const)}
@tab @code{@var{c} = __MSRAHI (@var{a}, @var{b})}
@tab @code{MSRAHI @var{a},#@var{b},@var{c}}
@item @code{uw1 __MSRLHI (uw1, const)}
@tab @code{@var{c} = __MSRLHI (@var{a}, @var{b})}
@tab @code{MSRLHI @var{a},#@var{b},@var{c}}
@item @code{void __MSUBACCS (acc, acc)}
@tab @code{__MSUBACCS (@var{b}, @var{a})}
@tab @code{MSUBACCS @var{a},@var{b}}
@item @code{sw1 __MSUBHSS (sw1, sw1)}
@tab @code{@var{c} = __MSUBHSS (@var{a}, @var{b})}
@tab @code{MSUBHSS @var{a},@var{b},@var{c}}
@item @code{uw1 __MSUBHUS (uw1, uw1)}
@tab @code{@var{c} = __MSUBHUS (@var{a}, @var{b})}
@tab @code{MSUBHUS @var{a},@var{b},@var{c}}
@item @code{void __MTRAP (void)}
@tab @code{__MTRAP ()}
@tab @code{MTRAP}
@item @code{uw2 __MUNPACKH (uw1)}
@tab @code{@var{b} = __MUNPACKH (@var{a})}
@tab @code{MUNPACKH @var{a},@var{b}}
@item @code{uw1 __MWCUT (uw2, uw1)}
@tab @code{@var{c} = __MWCUT (@var{a}, @var{b})}
@tab @code{MWCUT @var{a},@var{b},@var{c}}
@item @code{void __MWTACC (acc, uw1)}
@tab @code{__MWTACC (@var{b}, @var{a})}
@tab @code{MWTACC @var{a},@var{b}}
@item @code{void __MWTACCG (acc, uw1)}
@tab @code{__MWTACCG (@var{b}, @var{a})}
@tab @code{MWTACCG @var{a},@var{b}}
@item @code{uw1 __MXOR (uw1, uw1)}
@tab @code{@var{c} = __MXOR (@var{a}, @var{b})}
@tab @code{MXOR @var{a},@var{b},@var{c}}
@end multitable

@node Raw read/write Functions
@subsubsection 生の読み書き関数

このセクションでは、メモリにアクセスするための読み出しおよび書き込み命令に関連する組み込み関数について説明する。 これらの関数は、適切な場所でI / Oロード・ストアをフラッシュするための@code{membar}命令を生成する（前述の富士通のマニュアルに記載されている）。

@table @code

@item unsigned char __builtin_read8 (void *@var{data})
@item unsigned short __builtin_read16 (void *@var{data})
@item unsigned long __builtin_read32 (void *@var{data})
@item unsigned long long __builtin_read64 (void *@var{data})

@item void __builtin_write8 (void *@var{data}, unsigned char @var{datum})
@item void __builtin_write16 (void *@var{data}, unsigned short @var{datum})
@item void __builtin_write32 (void *@var{data}, unsigned long @var{datum})
@item void __builtin_write64 (void *@var{data}, unsigned long long @var{datum})
@end table

@node Other Built-in Functions
@subsubsection 他の組み込み関数

このセクションでは、特定のFR-V命令の後に命名されない組み込み関数について説明する。

@table @code
@item sw2 __IACCreadll (iacc @var{reg})
IACC0の完全な64ビット値を返す。 @var{reg}引数は将来の拡張用に予約されており、0でなければならない。

@item sw1 __IACCreadl (iacc @var{reg})
@var{reg}が0の場合はIACC0Hの値を返し、@var{reg}が1の場合はIACC0Lを返す。その他の@var{reg}の値は無効として拒否される。

@item void __IACCsetll (iacc @var{reg}, sw2 @var{x})
IACC0の全64ビット値を@var{x}に設定する。 @var{reg}引数は将来の拡張用に予約されており、0でなければならない。

@item void __IACCsetl (iacc @var{reg}, sw1 @var{x})
@var{reg}が0の場合はIACC0Hを、@var{reg}が1の場合はIACC0Lを@var{x}に設定する。@var{reg}の他の値は無効として拒否される。

@item void __data_prefetch0 (const void *@var{x})
@code{dcpl}命令を使用してアドレス@var{x}の内容をデータキャッシュにロードする。

@item void __data_prefetch (const void *@var{x})
@code{nldub}命令を使用して、アドレス@var{x}の内容をデータキャッシュにロードする。 命令はスロットI1で発行される。
@end table

@node MIPS DSP Built-in Functions
@subsection MIPS DSP組み込み関数

MIPS DSPアプリケーション固有拡張（ASE）には、DSPおよびメディアアプリケーションのパフォーマンスを向上させるための新しい命令が含まれている。 パックド8ビット/16ビット整数データ、Q7、Q15、Q31分数データで動作する命令を提供する。

GCCは、汎用ベクトル拡張（@pxref{Vector Extensions}）とMIPS固有の組み込み関数のコレクションの両方を使用してMIPS DSP演算をサポートしている。 どちらの種類のサポートも、@option{-mdsp}コマンドラインオプションによって有効になる。

ASEのリビジョン2は2006年後半に導入された。このリビジョンでは、元のASEに追加の命令が追加されるが、それ以外の場合は後方互換性がある。 コマンド行オプション@option{-mdspr2}を使用してリビジョン2を選択できる。 このオプションは@option{-mdsp}を意味する。

DSP制御レジスタのSCOUNTビットとPOSビットはグローバルである。 WRDSP命令、EXTPDP命令、EXTPDPV命令、MTHLIP命令は、SCOUNTビットとPOSビットを変更する。 最適化中、コンパイラはこれらの命令を削除せず、これらの命令を含む関数への呼び出しも削除しない。

現在のところ、GCCは32ビット・ベクタに対する演算のみをサポートしている。 8ビットの整数データに関連付けられたベクトル型は通常@code{v4i8}と呼ばれ、Q7に関連付けられたベクトル型は通常@code{v4q7}と呼ばれ、16ビット整数データに関連付けられたベクトル型は通常@code{v2i16}と呼ばれ、Q15に関連付けられたベクトル型は通常@code{v2q15}と呼ばれる。 それらはCで次のように定義できる。

@smallexample
typedef signed char v4i8 __attribute__ ((vector_size(4)));
typedef signed char v4q7 __attribute__ ((vector_size(4)));
typedef short v2i16 __attribute__ ((vector_size(4)));
typedef short v2q15 __attribute__ ((vector_size(4)));
@end smallexample

@code{v4i8}、@code{v4q7}、@code{v2i16}および@code{v2q15}の値は、集計と同じ方法で初期化される。 例えば：

@smallexample
v4i8 a = @{1, 2, 3, 4@};
v4i8 b;
b = (v4i8) @{5, 6, 7, 8@};

v2q15 c = @{0x0fcb, 0x3a75@};
v2q15 d;
d = (v2q15) @{0.1234 * 0x1.0p15, 0.4567 * 0x1.0p15@};
@end smallexample

@emph{注意:} CPUのエンディアンは、値がパックされる順序を決定する。 リトルエンディアンのターゲットでは、最初の値が最下位であり、最後の値が最上位である。 反対の順序はビッグエンディアンのターゲットに適用される。 たとえば、上記のコードは、リトルエンディアンのターゲットで@code{a}の最下位バイトを@code{1}に、ビッグエンディアンのターゲットで@code{4}に設定する。

@emph{注意:} Q7、Q15、Q31の値は整数表現で初期化する必要がある。 この例に示すように、Q7値の整数表現は、分数の値に@code{0x1.0p7}を掛けて得ることができる。 Q15の値に相当するのは、@code{0x1.0p15}を掛けることである。 Q31の値に相当するのは、@code{0x1.0p31}を掛けることである。

次の表は、ハードウェアサポートが存在する@code{v4i8}および@code{v2q15}操作の一覧である。@code{a}と@code{b}は@code{v4i8}の値で、@code{c}と@code{d}は@code{v2q15}の値である。

@multitable @columnfractions .50 .50
@item Cコード @tab MIPS命令
@item @code{a + b} @tab @code{addu.qb}
@item @code{c + d} @tab @code{addq.ph}
@item @code{a - b} @tab @code{subu.qb}
@item @code{c - d} @tab @code{subq.ph}
@end multitable

次の表は、DSP ASE REV 2のハードウェアサポートが存在する@code{v2i16}操作を示している。@code{e}および@code{f}は@code{v2i16}の値である。

@multitable @columnfractions .50 .50
@item Cコード code @tab MIPS命令
@item @code{e * f} @tab @code{mul.ph}
@end multitable

最初に以下のタイプを定義すると、DSP組み込み関数を記述する方が簡単である。

@smallexample
typedef int q31;
typedef int i32;
typedef unsigned int ui32;
typedef long long a64;
@end smallexample

@code{q31}と@code{i32}は実際には@code{int}と同じだが、我々はQ31の端数値を示すために@code{q31}を使用し、32ビットの整数値には@code{i32}を使う。 同様に、@code{a64}は@code {long long}と同じだが、4つのDSPアキュムレータ（@code{$ac0}、@code{$ac1}、@code{$ac2}または@code{$ac3}）のひとつに置かれた値を示すために使用する。

また、組み込み関数の中には、即値を直接パラメータとして使用するものがある。対応するDSP命令は、即値とオペランドの両方を受け入れるか、即値のみを受け入れるためである。 即値のパラメータは以下の通りである。

@smallexample
imm0_3: 0 to 3.
imm0_7: 0 to 7.
imm0_15: 0 to 15.
imm0_31: 0 to 31.
imm0_63: 0 to 63.
imm0_255: 0 to 255.
imm_n32_31: -32 to 31.
imm_n512_511: -512 to 511.
@end smallexample

以下の組み込み関数は、特定のMIPS DSP命令に直接マップする。 各命令の詳細については、アーキテクチャの仕様を参照せよ。

@smallexample
v2q15 __builtin_mips_addq_ph (v2q15, v2q15)
v2q15 __builtin_mips_addq_s_ph (v2q15, v2q15)
q31 __builtin_mips_addq_s_w (q31, q31)
v4i8 __builtin_mips_addu_qb (v4i8, v4i8)
v4i8 __builtin_mips_addu_s_qb (v4i8, v4i8)
v2q15 __builtin_mips_subq_ph (v2q15, v2q15)
v2q15 __builtin_mips_subq_s_ph (v2q15, v2q15)
q31 __builtin_mips_subq_s_w (q31, q31)
v4i8 __builtin_mips_subu_qb (v4i8, v4i8)
v4i8 __builtin_mips_subu_s_qb (v4i8, v4i8)
i32 __builtin_mips_addsc (i32, i32)
i32 __builtin_mips_addwc (i32, i32)
i32 __builtin_mips_modsub (i32, i32)
i32 __builtin_mips_raddu_w_qb (v4i8)
v2q15 __builtin_mips_absq_s_ph (v2q15)
q31 __builtin_mips_absq_s_w (q31)
v4i8 __builtin_mips_precrq_qb_ph (v2q15, v2q15)
v2q15 __builtin_mips_precrq_ph_w (q31, q31)
v2q15 __builtin_mips_precrq_rs_ph_w (q31, q31)
v4i8 __builtin_mips_precrqu_s_qb_ph (v2q15, v2q15)
q31 __builtin_mips_preceq_w_phl (v2q15)
q31 __builtin_mips_preceq_w_phr (v2q15)
v2q15 __builtin_mips_precequ_ph_qbl (v4i8)
v2q15 __builtin_mips_precequ_ph_qbr (v4i8)
v2q15 __builtin_mips_precequ_ph_qbla (v4i8)
v2q15 __builtin_mips_precequ_ph_qbra (v4i8)
v2q15 __builtin_mips_preceu_ph_qbl (v4i8)
v2q15 __builtin_mips_preceu_ph_qbr (v4i8)
v2q15 __builtin_mips_preceu_ph_qbla (v4i8)
v2q15 __builtin_mips_preceu_ph_qbra (v4i8)
v4i8 __builtin_mips_shll_qb (v4i8, imm0_7)
v4i8 __builtin_mips_shll_qb (v4i8, i32)
v2q15 __builtin_mips_shll_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shll_ph (v2q15, i32)
v2q15 __builtin_mips_shll_s_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shll_s_ph (v2q15, i32)
q31 __builtin_mips_shll_s_w (q31, imm0_31)
q31 __builtin_mips_shll_s_w (q31, i32)
v4i8 __builtin_mips_shrl_qb (v4i8, imm0_7)
v4i8 __builtin_mips_shrl_qb (v4i8, i32)
v2q15 __builtin_mips_shra_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shra_ph (v2q15, i32)
v2q15 __builtin_mips_shra_r_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shra_r_ph (v2q15, i32)
q31 __builtin_mips_shra_r_w (q31, imm0_31)
q31 __builtin_mips_shra_r_w (q31, i32)
v2q15 __builtin_mips_muleu_s_ph_qbl (v4i8, v2q15)
v2q15 __builtin_mips_muleu_s_ph_qbr (v4i8, v2q15)
v2q15 __builtin_mips_mulq_rs_ph (v2q15, v2q15)
q31 __builtin_mips_muleq_s_w_phl (v2q15, v2q15)
q31 __builtin_mips_muleq_s_w_phr (v2q15, v2q15)
a64 __builtin_mips_dpau_h_qbl (a64, v4i8, v4i8)
a64 __builtin_mips_dpau_h_qbr (a64, v4i8, v4i8)
a64 __builtin_mips_dpsu_h_qbl (a64, v4i8, v4i8)
a64 __builtin_mips_dpsu_h_qbr (a64, v4i8, v4i8)
a64 __builtin_mips_dpaq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_dpaq_sa_l_w (a64, q31, q31)
a64 __builtin_mips_dpsq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_dpsq_sa_l_w (a64, q31, q31)
a64 __builtin_mips_mulsaq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_maq_s_w_phl (a64, v2q15, v2q15)
a64 __builtin_mips_maq_s_w_phr (a64, v2q15, v2q15)
a64 __builtin_mips_maq_sa_w_phl (a64, v2q15, v2q15)
a64 __builtin_mips_maq_sa_w_phr (a64, v2q15, v2q15)
i32 __builtin_mips_bitrev (i32)
i32 __builtin_mips_insv (i32, i32)
v4i8 __builtin_mips_repl_qb (imm0_255)
v4i8 __builtin_mips_repl_qb (i32)
v2q15 __builtin_mips_repl_ph (imm_n512_511)
v2q15 __builtin_mips_repl_ph (i32)
void __builtin_mips_cmpu_eq_qb (v4i8, v4i8)
void __builtin_mips_cmpu_lt_qb (v4i8, v4i8)
void __builtin_mips_cmpu_le_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_eq_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_lt_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_le_qb (v4i8, v4i8)
void __builtin_mips_cmp_eq_ph (v2q15, v2q15)
void __builtin_mips_cmp_lt_ph (v2q15, v2q15)
void __builtin_mips_cmp_le_ph (v2q15, v2q15)
v4i8 __builtin_mips_pick_qb (v4i8, v4i8)
v2q15 __builtin_mips_pick_ph (v2q15, v2q15)
v2q15 __builtin_mips_packrl_ph (v2q15, v2q15)
i32 __builtin_mips_extr_w (a64, imm0_31)
i32 __builtin_mips_extr_w (a64, i32)
i32 __builtin_mips_extr_r_w (a64, imm0_31)
i32 __builtin_mips_extr_s_h (a64, i32)
i32 __builtin_mips_extr_rs_w (a64, imm0_31)
i32 __builtin_mips_extr_rs_w (a64, i32)
i32 __builtin_mips_extr_s_h (a64, imm0_31)
i32 __builtin_mips_extr_r_w (a64, i32)
i32 __builtin_mips_extp (a64, imm0_31)
i32 __builtin_mips_extp (a64, i32)
i32 __builtin_mips_extpdp (a64, imm0_31)
i32 __builtin_mips_extpdp (a64, i32)
a64 __builtin_mips_shilo (a64, imm_n32_31)
a64 __builtin_mips_shilo (a64, i32)
a64 __builtin_mips_mthlip (a64, i32)
void __builtin_mips_wrdsp (i32, imm0_63)
i32 __builtin_mips_rddsp (imm0_63)
i32 __builtin_mips_lbux (void *, i32)
i32 __builtin_mips_lhx (void *, i32)
i32 __builtin_mips_lwx (void *, i32)
a64 __builtin_mips_ldx (void *, i32) [MIPS64 only]
i32 __builtin_mips_bposge32 (void)
a64 __builtin_mips_madd (a64, i32, i32);
a64 __builtin_mips_maddu (a64, ui32, ui32);
a64 __builtin_mips_msub (a64, i32, i32);
a64 __builtin_mips_msubu (a64, ui32, ui32);
a64 __builtin_mips_mult (i32, i32);
a64 __builtin_mips_multu (ui32, ui32);
@end smallexample

以下の組み込み関数は、特定のMIPS DSP REV 2命令に直接マップする。 各命令の詳細については、アーキテクチャの仕様を参照せよ。

@smallexample
v4q7 __builtin_mips_absq_s_qb (v4q7);
v2i16 __builtin_mips_addu_ph (v2i16, v2i16);
v2i16 __builtin_mips_addu_s_ph (v2i16, v2i16);
v4i8 __builtin_mips_adduh_qb (v4i8, v4i8);
v4i8 __builtin_mips_adduh_r_qb (v4i8, v4i8);
i32 __builtin_mips_append (i32, i32, imm0_31);
i32 __builtin_mips_balign (i32, i32, imm0_3);
i32 __builtin_mips_cmpgdu_eq_qb (v4i8, v4i8);
i32 __builtin_mips_cmpgdu_lt_qb (v4i8, v4i8);
i32 __builtin_mips_cmpgdu_le_qb (v4i8, v4i8);
a64 __builtin_mips_dpa_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dps_w_ph (a64, v2i16, v2i16);
v2i16 __builtin_mips_mul_ph (v2i16, v2i16);
v2i16 __builtin_mips_mul_s_ph (v2i16, v2i16);
q31 __builtin_mips_mulq_rs_w (q31, q31);
v2q15 __builtin_mips_mulq_s_ph (v2q15, v2q15);
q31 __builtin_mips_mulq_s_w (q31, q31);
a64 __builtin_mips_mulsa_w_ph (a64, v2i16, v2i16);
v4i8 __builtin_mips_precr_qb_ph (v2i16, v2i16);
v2i16 __builtin_mips_precr_sra_ph_w (i32, i32, imm0_31);
v2i16 __builtin_mips_precr_sra_r_ph_w (i32, i32, imm0_31);
i32 __builtin_mips_prepend (i32, i32, imm0_31);
v4i8 __builtin_mips_shra_qb (v4i8, imm0_7);
v4i8 __builtin_mips_shra_r_qb (v4i8, imm0_7);
v4i8 __builtin_mips_shra_qb (v4i8, i32);
v4i8 __builtin_mips_shra_r_qb (v4i8, i32);
v2i16 __builtin_mips_shrl_ph (v2i16, imm0_15);
v2i16 __builtin_mips_shrl_ph (v2i16, i32);
v2i16 __builtin_mips_subu_ph (v2i16, v2i16);
v2i16 __builtin_mips_subu_s_ph (v2i16, v2i16);
v4i8 __builtin_mips_subuh_qb (v4i8, v4i8);
v4i8 __builtin_mips_subuh_r_qb (v4i8, v4i8);
v2q15 __builtin_mips_addqh_ph (v2q15, v2q15);
v2q15 __builtin_mips_addqh_r_ph (v2q15, v2q15);
q31 __builtin_mips_addqh_w (q31, q31);
q31 __builtin_mips_addqh_r_w (q31, q31);
v2q15 __builtin_mips_subqh_ph (v2q15, v2q15);
v2q15 __builtin_mips_subqh_r_ph (v2q15, v2q15);
q31 __builtin_mips_subqh_w (q31, q31);
q31 __builtin_mips_subqh_r_w (q31, q31);
a64 __builtin_mips_dpax_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dpsx_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dpaqx_s_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpaqx_sa_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpsqx_s_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpsqx_sa_w_ph (a64, v2q15, v2q15);
@end smallexample


@node MIPS Paired-Single Support
@subsection MIPSペア単精度サポート

MIPS64アーキテクチャには、単精度浮動小数点値のペアで動作する多くの命令が含まれている。各ペアは64ビットの浮動小数点レジスタにパックされ、一方の要素は「上半分」に指定され、もう一方は「下半分」に指定される。

GCCは、ジェネリックベクタ拡張（@pxref{Vector Extensions}）とMIPS固有の組み込み関数のコレクションの両方を使用したペアオペレーションをサポートしている。 どちらの種類のサポートも@option{-mpaired-single}コマンドラインオプションによって有効になる。

対になった単一の値に関連付けられたベクトル型は、通常、@code{v2sf}と呼ばれる。 これはC言語で次のように定義できる。

@smallexample
typedef float v2sf __attribute__ ((vector_size (8)));
@end smallexample

@code {v2sf}の値は、集約値と同じ方法で初期化される。例えば：

@smallexample
v2sf a = @{1.5, 9.1@};
v2sf b;
float e, f;
b = (v2sf) @{e, f@};
@end smallexample

@emph{注意:} CPUのエンディアンは、どの値がレジスタの上半分に格納され、どの値が下半分に格納されるかを決定する。
リトルエンディアンのターゲットでは、最初の値は下位の値で、2番目の値は上の値である。 反対の順序はビッグエンディアンのターゲットに適用される。たとえば、上のコードは、@code{a}の下半分をリトルエンディアンのターゲットで@code{1.5}に、ビッグエンディアンのターゲットで@code{9.1}に設定する。

@node MIPS Loongson Built-in Functions
@subsection MIPS Loongson組み込み関数

GCCは、ST Microelectronics Loongson-2Eおよび-2Fプロセッサーによって提供されるSIMD命令にアクセスするための組み込み関数を提供する。 これらの組み込み関数は、@code{loongson.h}ヘッダファイルをインクルードした後に利用可能で、次の64ビットベクトル型で動作する。

@itemize
@item @code{uint8x8_t}, 8の符号なし8ビット整数のベクタ
@item @code{uint16x4_t}, 4の符号なし16ビット整数のベクタ
@item @code{uint32x2_t}, 2の符号なし32ビット整数のベクタ
@item @code{int8x8_t}, 8の符号あり8ビット整数のベクタ
@item @code{int16x4_t}, 4の符号あり16ビット整数のベクタ
@item @code{int32x2_t}, 2の符号あり32ビット整数のベクタ
@end itemize

提供される組み込み関数を以下に示す。 各マシン命令に対応するマシン命令の名前が付けられ、同じマシン命令に拡張されていて異なる引数タイプを持つ命令を区別するのに適切な添え字が追加されている。 各命令の機能の説明については、アーキテクチャのドキュメントを参照せよ。

@smallexample
int16x4_t packsswh (int32x2_t s, int32x2_t t);
int8x8_t packsshb (int16x4_t s, int16x4_t t);
uint8x8_t packushb (uint16x4_t s, uint16x4_t t);
uint32x2_t paddw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t paddh_u (uint16x4_t s, uint16x4_t t);
uint8x8_t paddb_u (uint8x8_t s, uint8x8_t t);
int32x2_t paddw_s (int32x2_t s, int32x2_t t);
int16x4_t paddh_s (int16x4_t s, int16x4_t t);
int8x8_t paddb_s (int8x8_t s, int8x8_t t);
uint64_t paddd_u (uint64_t s, uint64_t t);
int64_t paddd_s (int64_t s, int64_t t);
int16x4_t paddsh (int16x4_t s, int16x4_t t);
int8x8_t paddsb (int8x8_t s, int8x8_t t);
uint16x4_t paddush (uint16x4_t s, uint16x4_t t);
uint8x8_t paddusb (uint8x8_t s, uint8x8_t t);
uint64_t pandn_ud (uint64_t s, uint64_t t);
uint32x2_t pandn_uw (uint32x2_t s, uint32x2_t t);
uint16x4_t pandn_uh (uint16x4_t s, uint16x4_t t);
uint8x8_t pandn_ub (uint8x8_t s, uint8x8_t t);
int64_t pandn_sd (int64_t s, int64_t t);
int32x2_t pandn_sw (int32x2_t s, int32x2_t t);
int16x4_t pandn_sh (int16x4_t s, int16x4_t t);
int8x8_t pandn_sb (int8x8_t s, int8x8_t t);
uint16x4_t pavgh (uint16x4_t s, uint16x4_t t);
uint8x8_t pavgb (uint8x8_t s, uint8x8_t t);
uint32x2_t pcmpeqw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t pcmpeqh_u (uint16x4_t s, uint16x4_t t);
uint8x8_t pcmpeqb_u (uint8x8_t s, uint8x8_t t);
int32x2_t pcmpeqw_s (int32x2_t s, int32x2_t t);
int16x4_t pcmpeqh_s (int16x4_t s, int16x4_t t);
int8x8_t pcmpeqb_s (int8x8_t s, int8x8_t t);
uint32x2_t pcmpgtw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t pcmpgth_u (uint16x4_t s, uint16x4_t t);
uint8x8_t pcmpgtb_u (uint8x8_t s, uint8x8_t t);
int32x2_t pcmpgtw_s (int32x2_t s, int32x2_t t);
int16x4_t pcmpgth_s (int16x4_t s, int16x4_t t);
int8x8_t pcmpgtb_s (int8x8_t s, int8x8_t t);
uint16x4_t pextrh_u (uint16x4_t s, int field);
int16x4_t pextrh_s (int16x4_t s, int field);
uint16x4_t pinsrh_0_u (uint16x4_t s, uint16x4_t t);
uint16x4_t pinsrh_1_u (uint16x4_t s, uint16x4_t t);
uint16x4_t pinsrh_2_u (uint16x4_t s, uint16x4_t t);
uint16x4_t pinsrh_3_u (uint16x4_t s, uint16x4_t t);
int16x4_t pinsrh_0_s (int16x4_t s, int16x4_t t);
int16x4_t pinsrh_1_s (int16x4_t s, int16x4_t t);
int16x4_t pinsrh_2_s (int16x4_t s, int16x4_t t);
int16x4_t pinsrh_3_s (int16x4_t s, int16x4_t t);
int32x2_t pmaddhw (int16x4_t s, int16x4_t t);
int16x4_t pmaxsh (int16x4_t s, int16x4_t t);
uint8x8_t pmaxub (uint8x8_t s, uint8x8_t t);
int16x4_t pminsh (int16x4_t s, int16x4_t t);
uint8x8_t pminub (uint8x8_t s, uint8x8_t t);
uint8x8_t pmovmskb_u (uint8x8_t s);
int8x8_t pmovmskb_s (int8x8_t s);
uint16x4_t pmulhuh (uint16x4_t s, uint16x4_t t);
int16x4_t pmulhh (int16x4_t s, int16x4_t t);
int16x4_t pmullh (int16x4_t s, int16x4_t t);
int64_t pmuluw (uint32x2_t s, uint32x2_t t);
uint8x8_t pasubub (uint8x8_t s, uint8x8_t t);
uint16x4_t biadd (uint8x8_t s);
uint16x4_t psadbh (uint8x8_t s, uint8x8_t t);
uint16x4_t pshufh_u (uint16x4_t dest, uint16x4_t s, uint8_t order);
int16x4_t pshufh_s (int16x4_t dest, int16x4_t s, uint8_t order);
uint16x4_t psllh_u (uint16x4_t s, uint8_t amount);
int16x4_t psllh_s (int16x4_t s, uint8_t amount);
uint32x2_t psllw_u (uint32x2_t s, uint8_t amount);
int32x2_t psllw_s (int32x2_t s, uint8_t amount);
uint16x4_t psrlh_u (uint16x4_t s, uint8_t amount);
int16x4_t psrlh_s (int16x4_t s, uint8_t amount);
uint32x2_t psrlw_u (uint32x2_t s, uint8_t amount);
int32x2_t psrlw_s (int32x2_t s, uint8_t amount);
uint16x4_t psrah_u (uint16x4_t s, uint8_t amount);
int16x4_t psrah_s (int16x4_t s, uint8_t amount);
uint32x2_t psraw_u (uint32x2_t s, uint8_t amount);
int32x2_t psraw_s (int32x2_t s, uint8_t amount);
uint32x2_t psubw_u (uint32x2_t s, uint32x2_t t);
uint16x4_t psubh_u (uint16x4_t s, uint16x4_t t);
uint8x8_t psubb_u (uint8x8_t s, uint8x8_t t);
int32x2_t psubw_s (int32x2_t s, int32x2_t t);
int16x4_t psubh_s (int16x4_t s, int16x4_t t);
int8x8_t psubb_s (int8x8_t s, int8x8_t t);
uint64_t psubd_u (uint64_t s, uint64_t t);
int64_t psubd_s (int64_t s, int64_t t);
int16x4_t psubsh (int16x4_t s, int16x4_t t);
int8x8_t psubsb (int8x8_t s, int8x8_t t);
uint16x4_t psubush (uint16x4_t s, uint16x4_t t);
uint8x8_t psubusb (uint8x8_t s, uint8x8_t t);
uint32x2_t punpckhwd_u (uint32x2_t s, uint32x2_t t);
uint16x4_t punpckhhw_u (uint16x4_t s, uint16x4_t t);
uint8x8_t punpckhbh_u (uint8x8_t s, uint8x8_t t);
int32x2_t punpckhwd_s (int32x2_t s, int32x2_t t);
int16x4_t punpckhhw_s (int16x4_t s, int16x4_t t);
int8x8_t punpckhbh_s (int8x8_t s, int8x8_t t);
uint32x2_t punpcklwd_u (uint32x2_t s, uint32x2_t t);
uint16x4_t punpcklhw_u (uint16x4_t s, uint16x4_t t);
uint8x8_t punpcklbh_u (uint8x8_t s, uint8x8_t t);
int32x2_t punpcklwd_s (int32x2_t s, int32x2_t t);
int16x4_t punpcklhw_s (int16x4_t s, int16x4_t t);
int8x8_t punpcklbh_s (int8x8_t s, int8x8_t t);
@end smallexample

@menu
* Paired-Single Arithmetic::
* Paired-Single Built-in Functions::
* MIPS-3D Built-in Functions::
@end menu

@node Paired-Single Arithmetic
@subsubsection ペア単精度算術

次の表は、ハードウェアサポートが存在する@code{v2sf}操作を示している。 @code{a}、@code{b}と@code{c}は@code{v2sf}の値で、@code{x}は整数値である。

@multitable @columnfractions .50 .50
@item Cコード @tab MIPS命令
@item @code{a + b} @tab @code{add.ps}
@item @code{a - b} @tab @code{sub.ps}
@item @code{-a} @tab @code{neg.ps}
@item @code{a * b} @tab @code{mul.ps}
@item @code{a * b + c} @tab @code{madd.ps}
@item @code{a * b - c} @tab @code{msub.ps}
@item @code{-(a * b + c)} @tab @code{nmadd.ps}
@item @code{-(a * b - c)} @tab @code{nmsub.ps}
@item @code{x ? a : b} @tab @code{movn.ps}/@code{movz.ps}
@end multitable

乗加算命令は、コマンドラインオプション@code{-mno-fused-madd}を使用して無効にすることができる。

@node Paired-Single Built-in Functions
@subsubsection ペア単精度組み込み関数

以下のペア単精度関数は、特定のMIPS命令に直接マップする。 各命令の詳細については、アーキテクチャの仕様を参照せよ。

@table @code
@item v2sf __builtin_mips_pll_ps (v2sf, v2sf)
ペア下位・下位 (@code{pll.ps})。

@item v2sf __builtin_mips_pul_ps (v2sf, v2sf)
ペア上位・下位 (@code{pul.ps})。

@item v2sf __builtin_mips_plu_ps (v2sf, v2sf)
ペア下位・上位 (@code{plu.ps})。

@item v2sf __builtin_mips_puu_ps (v2sf, v2sf)
ペア上位・上位 (@code{puu.ps})。

@item v2sf __builtin_mips_cvt_ps_s (float, float)
ペアをペア単精度に変換 (@code{cvt.ps.s})。

@item float __builtin_mips_cvt_s_pl (v2sf)
ペア下位と単精度に変換 (@code{cvt.s.pl})。

@item float __builtin_mips_cvt_s_pu (v2sf)
ペア上位と単精度に変換 (@code{cvt.s.pu})。

@item v2sf __builtin_mips_abs_ps (v2sf)
絶対値 (@code{abs.ps})。

@item v2sf __builtin_mips_alnv_ps (v2sf, v2sf, int)
変数の整列 (@code{alnv.ps})。

@emph{注意:} 3番目のパラメータの値は、8または8を法とする0または4でなければならない。そうでない場合、結果は予測できない。 詳細は、命令の説明を読むこと。
@end table

以下の複数命令関数も利用できる。それぞれの場合で、@var{cond}は16の浮動小数点条件のどれかである：
@code{f}, @code{un}, @code{eq}, @code{ueq}, @code{olt}, @code{ult},
@code{ole}, @code{ule}, @code{sf}, @code{ngle}, @code{seq}, @code{ngl},
@code{lt}, @code{nge}, @code{le}, @code{ngt}.

@table @code
@item v2sf __builtin_mips_movt_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx v2sf __builtin_mips_movf_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
浮動小数点比較に基づいた条件付きムーブ (@code{c.@var{cond}.ps}, @code{movt.ps}/@code{movf.ps}).

@code{movt}関数は以下で計算された@var{x}の値を返す

@smallexample
c.@var{cond}.ps @var{cc},@var{a},@var{b}
mov.ps @var{x},@var{c}
movt.ps @var{x},@var{d},@var{cc}
@end smallexample

@code{movf}関数は同様だが@code{movt.ps}の代わりに@code{movf.ps}を返す。

@item int __builtin_mips_upper_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_lower_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
2つのペア単精度値の比較(@code{c.@var{cond}.ps}, @code{bc1t}/@code{bc1f}).

これらの関数は@var{a}と@var{b}を@code{c.@var{cond}.ps}を使って比較して結果の上位と下位のどちらかを返す。例えば、

@smallexample
v2sf a, b;
if (__builtin_mips_upper_c_eq_ps (a, b))
  upper_halves_are_equal ();
else
  upper_halves_are_unequal ();

if (__builtin_mips_lower_c_eq_ps (a, b))
  lower_halves_are_equal ();
else
  lower_halves_are_unequal ();
@end smallexample
@end table

@node MIPS-3D Built-in Functions
@subsubsection MIPS-3D組み込み関数

MIPS-3Dアプリケーション固有エクステンション（ASE）には、3Dグラフィックス操作のパフォーマンスを向上させるために設計されたペア単精度命令が追加で含まれている。 これらの命令のサポートは、@option{-mips3d}コマンドラインオプションによって制御される。

以下に挙げる機能は、特定のMIPS-3D命令に直接マップする。 各命令の詳細については、アーキテクチャの仕様を参照せよ。

@table @code
@item v2sf __builtin_mips_addr_ps (v2sf, v2sf)
還元加算 (@code{addr.ps}).

@item v2sf __builtin_mips_mulr_ps (v2sf, v2sf)
還元乗算 (@code{mulr.ps}).

@item v2sf __builtin_mips_cvt_pw_ps (v2sf)
ペア単精度とペアワードに変換 (@code{cvt.pw.ps}).

@item v2sf __builtin_mips_cvt_ps_pw (v2sf)
ペアワードをペア単精度に変換 (@code{cvt.ps.pw}).

@item float __builtin_mips_recip1_s (float)
@itemx double __builtin_mips_recip1_d (double)
@itemx v2sf __builtin_mips_recip1_ps (v2sf)
低精度逆数（列ステップ１） (@code{recip1.@var{fmt}}).

@item float __builtin_mips_recip2_s (float, float)
@itemx double __builtin_mips_recip2_d (double, double)
@itemx v2sf __builtin_mips_recip2_ps (v2sf, v2sf)
低精度逆数（列ステップ２） (@code{recip2.@var{fmt}}).

@item float __builtin_mips_rsqrt1_s (float)
@itemx double __builtin_mips_rsqrt1_d (double)
@itemx v2sf __builtin_mips_rsqrt1_ps (v2sf)
低制度逆数平方根（列ステップ１）(@code{rsqrt1.@var{fmt}}).

@item float __builtin_mips_rsqrt2_s (float, float)
@itemx double __builtin_mips_rsqrt2_d (double, double)
@itemx v2sf __builtin_mips_rsqrt2_ps (v2sf, v2sf)
低制度逆数平方根（列ステップ２）(@code{rsqrt2.@var{fmt}}).
@end table

以下の複数命令関数も利用できる。それぞれの場合で、@var{cond}は16の浮動小数点条件のどれかである：
@code{f}, @code{un}, @code{eq}, @code{ueq}, @code{olt}, @code{ult},
@code{ole}, @code{ule}, @code{sf}, @code{ngle}, @code{seq},
@code{ngl}, @code{lt}, @code{nge}, @code{le}, @code{ngt}.

@table @code
@item int __builtin_mips_cabs_@var{cond}_s (float @var{a}, float @var{b})
@itemx int __builtin_mips_cabs_@var{cond}_d (double @var{a}, double @var{b})
２つのスカラー値の絶対値比較 (@code{cabs.@var{cond}.@var{fmt}}, @code{bc1t}/@code{bc1f}).

これらの関数は@var{a}と@var{b}を@code{cabs.@var{cond}.s}または@code{cabs.@var{cond}.d}を使って比較して結果を真偽値として返す。例えば、

@smallexample
float a, b;
if (__builtin_mips_cabs_eq_s (a, b))
  true ();
else
  false ();
@end smallexample

@item int __builtin_mips_upper_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_lower_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
２つのペア単精度値の絶対値比較(@code{cabs.@var{cond}.ps}, @code{bc1t}/@code{bc1f}).

これらの関数は@var{a}と@var{b}を@code{cabs.@var{cond}.ps}を使って比較して結果を上位または下位を返す。例えば、

@smallexample
v2sf a, b;
if (__builtin_mips_upper_cabs_eq_ps (a, b))
  upper_halves_are_equal ();
else
  upper_halves_are_unequal ();

if (__builtin_mips_lower_cabs_eq_ps (a, b))
  lower_halves_are_equal ();
else
  lower_halves_are_unequal ();
@end smallexample

@item v2sf __builtin_mips_movt_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx v2sf __builtin_mips_movf_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
絶対値比較に基づいた条件付きムーブ (@code{cabs.@var{cond}.ps}, @code{movt.ps}/@code{movf.ps}).

@code{movt}関数は以下によって計算された@var{x}の値を返す

@smallexample
cabs.@var{cond}.ps @var{cc},@var{a},@var{b}
mov.ps @var{x},@var{c}
movt.ps @var{x},@var{d},@var{cc}
@end smallexample

@code{movf}関数は同様だが@code{movt.ps}の代わりに@code{movf.ps}を使う。

@item int __builtin_mips_any_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_all_c_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_any_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
@itemx int __builtin_mips_all_cabs_@var{cond}_ps (v2sf @var{a}, v2sf @var{b})
２つのペア単精度値の比較(@code{c.@var{cond}.ps}/@code{cabs.@var{cond}.ps}, @code{bc1any2t}/@code{bc1any2f}).

これらの関数は@var{a}と@var{b}を@code{c.@var{cond}.ps}または@code{cabs.@var{cond}.ps}で比較する。
@code{any}形式はどちらかの結果が真ならば真を返し、@code{all}形式は両方の結果が真ならば真を返す。例えば、

@smallexample
v2sf a, b;
if (__builtin_mips_any_c_eq_ps (a, b))
  one_is_true ();
else
  both_are_false ();

if (__builtin_mips_all_c_eq_ps (a, b))
  both_are_true ();
else
  one_is_false ();
@end smallexample

@item int __builtin_mips_any_c_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx int __builtin_mips_all_c_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx int __builtin_mips_any_cabs_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
@itemx int __builtin_mips_all_cabs_@var{cond}_4s (v2sf @var{a}, v2sf @var{b}, v2sf @var{c}, v2sf @var{d})
Comparison of four paired-single values
(@code{c.@var{cond}.ps}/@code{cabs.@var{cond}.ps},
@code{bc1any4t}/@code{bc1any4f}).

これらの関数は、@var{a}と@var{b}を比較し、@var{c}と@var{d}を比較するために@code{c.@var{cond}.ps}または@code{cabs.@var{cond}.ps}を使う。@code{any}形式は、4つの結果のいずれかが真であれば真を返し、@code{all}形式は4つの結果がすべて真であるならば真を返す。 例えば、

@smallexample
v2sf a, b, c, d;
if (__builtin_mips_any_c_eq_4s (a, b, c, d))
  some_are_true ();
else
  all_are_false ();

if (__builtin_mips_all_c_eq_4s (a, b, c, d))
  all_are_true ();
else
  some_are_false ();
@end smallexample
@end table

@node MIPS SIMD Architecture (MSA) Support
@subsection MIPS SIMD Architecture (MSA)サポート

@menu
* MIPS SIMD Architecture Built-in Functions::
@end menu

GCCは、MSA MIPS SIMDアーキテクチャによって提供されるSIMD命令にアクセスするための組み込み関数を提供する。 このインターフェイスは、@code{<msa.h>}をインクルードして、@option{-mmsa -mhard-float -mfp64 -mnan=2008}を使用することで利用可能になる。各@code{__builtin_msa_*}には、組み込み関数の短縮名@code{__msa_*}がある。

MSAは、8ビット、16ビット、32ビットおよび64ビット整数、16ビットおよび32ビット固定小数点、または32ビットおよび64ビットの浮動小数点データ要素で動作する128ビット幅のベクトルレジスタを実装する。 @code {msa.h}には以下のベクタのtypedefが含まれている：
@itemize
@item @code{v16i8}, 16の符号あり8ビット整数のベクタ
@item @code{v16u8}, 16の符号なし8ビット整数のベクタ
@item @code{v8i16}, 8の符号あり16ビット整数のベクタ
@item @code{v8u16}, 8の符号なし16ビット整数のベクタ
@item @code{v4i32}, 4の符号あり32ビット整数のベクタ
@item @code{v4u32}, 4の符号なし32ビット整数のベクタ
@item @code{v2i64}, 2の符号あり64ビット整数のベクタ
@item @code{v2u64}, 2の符号なし64ビット整数のベクタ
@item @code{v4f32}, 4の32ビット単精度のベクタ
@item @code{v2f64}, 2の64ビット倍精度のベクタ
@end itemize

命令と対応するビルトインには、追加の制限や入出力値の操作がある場合がある。
@itemize
@item @code{imm0_1}, 0から1までの整数定数
@item @code{imm0_3}, 0から3までの整数定数
@item @code{imm0_7}, 0から7までの整数定数
@item @code{imm0_15}, 0から15までの整数定数
@item @code{imm0_31}, 0から31までの整数定数
@item @code{imm0_63}, 0から63までの整数定数
@item @code{imm0_255}, 0から255までの整数定数
@item @code{imm_n16_15},-16から15までの整数定数
@item @code{imm_n512_511}, -512から511までの整数定数
@item @code{imm_n1024_1022}, -512から511までを1左シフトした整数定数、すなわち、-1024, -1022, @dots{}, 1020, 1022
@item @code{imm_n2048_2044}, -512から511までを2左シフトした整数定数、すなわち、-2048, -2044, @dots{}, 2040, 2044
@item @code{imm_n4096_4088}, -512から511までを3左シフトした整数定数、すなわち、-4096, -4088, @dots{}, 4080, 4088
@item @code{imm1_4}, 1から4までの整数定数
@item @code{i32, i64, u32, u64, f32, f64}, 以下のように定義される
@end itemize

@smallexample
@{
typedef int i32;
#if __LONG_MAX__ == __LONG_LONG_MAX__
typedef long i64;
#else
typedef long long i64;
#endif

typedef unsigned int u32;
#if __LONG_MAX__ == __LONG_LONG_MAX__
typedef unsigned long u64;
#else
typedef unsigned long long u64;
#endif

typedef double f64;
typedef float f32;
@}
@end smallexample

@node MIPS SIMD Architecture Built-in Functions
@subsubsection MIPS SIMD アーキテクチャ組み込み関数

提供される組み込み関数を以下に示す。 それぞれに機械命令の名前が付けられる。

@smallexample
v16i8 __builtin_msa_add_a_b (v16i8, v16i8);
v8i16 __builtin_msa_add_a_h (v8i16, v8i16);
v4i32 __builtin_msa_add_a_w (v4i32, v4i32);
v2i64 __builtin_msa_add_a_d (v2i64, v2i64);

v16i8 __builtin_msa_adds_a_b (v16i8, v16i8);
v8i16 __builtin_msa_adds_a_h (v8i16, v8i16);
v4i32 __builtin_msa_adds_a_w (v4i32, v4i32);
v2i64 __builtin_msa_adds_a_d (v2i64, v2i64);

v16i8 __builtin_msa_adds_s_b (v16i8, v16i8);
v8i16 __builtin_msa_adds_s_h (v8i16, v8i16);
v4i32 __builtin_msa_adds_s_w (v4i32, v4i32);
v2i64 __builtin_msa_adds_s_d (v2i64, v2i64);

v16u8 __builtin_msa_adds_u_b (v16u8, v16u8);
v8u16 __builtin_msa_adds_u_h (v8u16, v8u16);
v4u32 __builtin_msa_adds_u_w (v4u32, v4u32);
v2u64 __builtin_msa_adds_u_d (v2u64, v2u64);

v16i8 __builtin_msa_addv_b (v16i8, v16i8);
v8i16 __builtin_msa_addv_h (v8i16, v8i16);
v4i32 __builtin_msa_addv_w (v4i32, v4i32);
v2i64 __builtin_msa_addv_d (v2i64, v2i64);

v16i8 __builtin_msa_addvi_b (v16i8, imm0_31);
v8i16 __builtin_msa_addvi_h (v8i16, imm0_31);
v4i32 __builtin_msa_addvi_w (v4i32, imm0_31);
v2i64 __builtin_msa_addvi_d (v2i64, imm0_31);

v16u8 __builtin_msa_and_v (v16u8, v16u8);

v16u8 __builtin_msa_andi_b (v16u8, imm0_255);

v16i8 __builtin_msa_asub_s_b (v16i8, v16i8);
v8i16 __builtin_msa_asub_s_h (v8i16, v8i16);
v4i32 __builtin_msa_asub_s_w (v4i32, v4i32);
v2i64 __builtin_msa_asub_s_d (v2i64, v2i64);

v16u8 __builtin_msa_asub_u_b (v16u8, v16u8);
v8u16 __builtin_msa_asub_u_h (v8u16, v8u16);
v4u32 __builtin_msa_asub_u_w (v4u32, v4u32);
v2u64 __builtin_msa_asub_u_d (v2u64, v2u64);

v16i8 __builtin_msa_ave_s_b (v16i8, v16i8);
v8i16 __builtin_msa_ave_s_h (v8i16, v8i16);
v4i32 __builtin_msa_ave_s_w (v4i32, v4i32);
v2i64 __builtin_msa_ave_s_d (v2i64, v2i64);

v16u8 __builtin_msa_ave_u_b (v16u8, v16u8);
v8u16 __builtin_msa_ave_u_h (v8u16, v8u16);
v4u32 __builtin_msa_ave_u_w (v4u32, v4u32);
v2u64 __builtin_msa_ave_u_d (v2u64, v2u64);

v16i8 __builtin_msa_aver_s_b (v16i8, v16i8);
v8i16 __builtin_msa_aver_s_h (v8i16, v8i16);
v4i32 __builtin_msa_aver_s_w (v4i32, v4i32);
v2i64 __builtin_msa_aver_s_d (v2i64, v2i64);

v16u8 __builtin_msa_aver_u_b (v16u8, v16u8);
v8u16 __builtin_msa_aver_u_h (v8u16, v8u16);
v4u32 __builtin_msa_aver_u_w (v4u32, v4u32);
v2u64 __builtin_msa_aver_u_d (v2u64, v2u64);

v16u8 __builtin_msa_bclr_b (v16u8, v16u8);
v8u16 __builtin_msa_bclr_h (v8u16, v8u16);
v4u32 __builtin_msa_bclr_w (v4u32, v4u32);
v2u64 __builtin_msa_bclr_d (v2u64, v2u64);

v16u8 __builtin_msa_bclri_b (v16u8, imm0_7);
v8u16 __builtin_msa_bclri_h (v8u16, imm0_15);
v4u32 __builtin_msa_bclri_w (v4u32, imm0_31);
v2u64 __builtin_msa_bclri_d (v2u64, imm0_63);

v16u8 __builtin_msa_binsl_b (v16u8, v16u8, v16u8);
v8u16 __builtin_msa_binsl_h (v8u16, v8u16, v8u16);
v4u32 __builtin_msa_binsl_w (v4u32, v4u32, v4u32);
v2u64 __builtin_msa_binsl_d (v2u64, v2u64, v2u64);

v16u8 __builtin_msa_binsli_b (v16u8, v16u8, imm0_7);
v8u16 __builtin_msa_binsli_h (v8u16, v8u16, imm0_15);
v4u32 __builtin_msa_binsli_w (v4u32, v4u32, imm0_31);
v2u64 __builtin_msa_binsli_d (v2u64, v2u64, imm0_63);

v16u8 __builtin_msa_binsr_b (v16u8, v16u8, v16u8);
v8u16 __builtin_msa_binsr_h (v8u16, v8u16, v8u16);
v4u32 __builtin_msa_binsr_w (v4u32, v4u32, v4u32);
v2u64 __builtin_msa_binsr_d (v2u64, v2u64, v2u64);

v16u8 __builtin_msa_binsri_b (v16u8, v16u8, imm0_7);
v8u16 __builtin_msa_binsri_h (v8u16, v8u16, imm0_15);
v4u32 __builtin_msa_binsri_w (v4u32, v4u32, imm0_31);
v2u64 __builtin_msa_binsri_d (v2u64, v2u64, imm0_63);

v16u8 __builtin_msa_bmnz_v (v16u8, v16u8, v16u8);

v16u8 __builtin_msa_bmnzi_b (v16u8, v16u8, imm0_255);

v16u8 __builtin_msa_bmz_v (v16u8, v16u8, v16u8);

v16u8 __builtin_msa_bmzi_b (v16u8, v16u8, imm0_255);

v16u8 __builtin_msa_bneg_b (v16u8, v16u8);
v8u16 __builtin_msa_bneg_h (v8u16, v8u16);
v4u32 __builtin_msa_bneg_w (v4u32, v4u32);
v2u64 __builtin_msa_bneg_d (v2u64, v2u64);

v16u8 __builtin_msa_bnegi_b (v16u8, imm0_7);
v8u16 __builtin_msa_bnegi_h (v8u16, imm0_15);
v4u32 __builtin_msa_bnegi_w (v4u32, imm0_31);
v2u64 __builtin_msa_bnegi_d (v2u64, imm0_63);

i32 __builtin_msa_bnz_b (v16u8);
i32 __builtin_msa_bnz_h (v8u16);
i32 __builtin_msa_bnz_w (v4u32);
i32 __builtin_msa_bnz_d (v2u64);

i32 __builtin_msa_bnz_v (v16u8);

v16u8 __builtin_msa_bsel_v (v16u8, v16u8, v16u8);

v16u8 __builtin_msa_bseli_b (v16u8, v16u8, imm0_255);

v16u8 __builtin_msa_bset_b (v16u8, v16u8);
v8u16 __builtin_msa_bset_h (v8u16, v8u16);
v4u32 __builtin_msa_bset_w (v4u32, v4u32);
v2u64 __builtin_msa_bset_d (v2u64, v2u64);

v16u8 __builtin_msa_bseti_b (v16u8, imm0_7);
v8u16 __builtin_msa_bseti_h (v8u16, imm0_15);
v4u32 __builtin_msa_bseti_w (v4u32, imm0_31);
v2u64 __builtin_msa_bseti_d (v2u64, imm0_63);

i32 __builtin_msa_bz_b (v16u8);
i32 __builtin_msa_bz_h (v8u16);
i32 __builtin_msa_bz_w (v4u32);
i32 __builtin_msa_bz_d (v2u64);

i32 __builtin_msa_bz_v (v16u8);

v16i8 __builtin_msa_ceq_b (v16i8, v16i8);
v8i16 __builtin_msa_ceq_h (v8i16, v8i16);
v4i32 __builtin_msa_ceq_w (v4i32, v4i32);
v2i64 __builtin_msa_ceq_d (v2i64, v2i64);

v16i8 __builtin_msa_ceqi_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_ceqi_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_ceqi_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_ceqi_d (v2i64, imm_n16_15);

i32 __builtin_msa_cfcmsa (imm0_31);

v16i8 __builtin_msa_cle_s_b (v16i8, v16i8);
v8i16 __builtin_msa_cle_s_h (v8i16, v8i16);
v4i32 __builtin_msa_cle_s_w (v4i32, v4i32);
v2i64 __builtin_msa_cle_s_d (v2i64, v2i64);

v16i8 __builtin_msa_cle_u_b (v16u8, v16u8);
v8i16 __builtin_msa_cle_u_h (v8u16, v8u16);
v4i32 __builtin_msa_cle_u_w (v4u32, v4u32);
v2i64 __builtin_msa_cle_u_d (v2u64, v2u64);

v16i8 __builtin_msa_clei_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_clei_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_clei_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_clei_s_d (v2i64, imm_n16_15);

v16i8 __builtin_msa_clei_u_b (v16u8, imm0_31);
v8i16 __builtin_msa_clei_u_h (v8u16, imm0_31);
v4i32 __builtin_msa_clei_u_w (v4u32, imm0_31);
v2i64 __builtin_msa_clei_u_d (v2u64, imm0_31);

v16i8 __builtin_msa_clt_s_b (v16i8, v16i8);
v8i16 __builtin_msa_clt_s_h (v8i16, v8i16);
v4i32 __builtin_msa_clt_s_w (v4i32, v4i32);
v2i64 __builtin_msa_clt_s_d (v2i64, v2i64);

v16i8 __builtin_msa_clt_u_b (v16u8, v16u8);
v8i16 __builtin_msa_clt_u_h (v8u16, v8u16);
v4i32 __builtin_msa_clt_u_w (v4u32, v4u32);
v2i64 __builtin_msa_clt_u_d (v2u64, v2u64);

v16i8 __builtin_msa_clti_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_clti_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_clti_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_clti_s_d (v2i64, imm_n16_15);

v16i8 __builtin_msa_clti_u_b (v16u8, imm0_31);
v8i16 __builtin_msa_clti_u_h (v8u16, imm0_31);
v4i32 __builtin_msa_clti_u_w (v4u32, imm0_31);
v2i64 __builtin_msa_clti_u_d (v2u64, imm0_31);

i32 __builtin_msa_copy_s_b (v16i8, imm0_15);
i32 __builtin_msa_copy_s_h (v8i16, imm0_7);
i32 __builtin_msa_copy_s_w (v4i32, imm0_3);
i64 __builtin_msa_copy_s_d (v2i64, imm0_1);

u32 __builtin_msa_copy_u_b (v16i8, imm0_15);
u32 __builtin_msa_copy_u_h (v8i16, imm0_7);
u32 __builtin_msa_copy_u_w (v4i32, imm0_3);
u64 __builtin_msa_copy_u_d (v2i64, imm0_1);

void __builtin_msa_ctcmsa (imm0_31, i32);

v16i8 __builtin_msa_div_s_b (v16i8, v16i8);
v8i16 __builtin_msa_div_s_h (v8i16, v8i16);
v4i32 __builtin_msa_div_s_w (v4i32, v4i32);
v2i64 __builtin_msa_div_s_d (v2i64, v2i64);

v16u8 __builtin_msa_div_u_b (v16u8, v16u8);
v8u16 __builtin_msa_div_u_h (v8u16, v8u16);
v4u32 __builtin_msa_div_u_w (v4u32, v4u32);
v2u64 __builtin_msa_div_u_d (v2u64, v2u64);

v8i16 __builtin_msa_dotp_s_h (v16i8, v16i8);
v4i32 __builtin_msa_dotp_s_w (v8i16, v8i16);
v2i64 __builtin_msa_dotp_s_d (v4i32, v4i32);

v8u16 __builtin_msa_dotp_u_h (v16u8, v16u8);
v4u32 __builtin_msa_dotp_u_w (v8u16, v8u16);
v2u64 __builtin_msa_dotp_u_d (v4u32, v4u32);

v8i16 __builtin_msa_dpadd_s_h (v8i16, v16i8, v16i8);
v4i32 __builtin_msa_dpadd_s_w (v4i32, v8i16, v8i16);
v2i64 __builtin_msa_dpadd_s_d (v2i64, v4i32, v4i32);

v8u16 __builtin_msa_dpadd_u_h (v8u16, v16u8, v16u8);
v4u32 __builtin_msa_dpadd_u_w (v4u32, v8u16, v8u16);
v2u64 __builtin_msa_dpadd_u_d (v2u64, v4u32, v4u32);

v8i16 __builtin_msa_dpsub_s_h (v8i16, v16i8, v16i8);
v4i32 __builtin_msa_dpsub_s_w (v4i32, v8i16, v8i16);
v2i64 __builtin_msa_dpsub_s_d (v2i64, v4i32, v4i32);

v8i16 __builtin_msa_dpsub_u_h (v8i16, v16u8, v16u8);
v4i32 __builtin_msa_dpsub_u_w (v4i32, v8u16, v8u16);
v2i64 __builtin_msa_dpsub_u_d (v2i64, v4u32, v4u32);

v4f32 __builtin_msa_fadd_w (v4f32, v4f32);
v2f64 __builtin_msa_fadd_d (v2f64, v2f64);

v4i32 __builtin_msa_fcaf_w (v4f32, v4f32);
v2i64 __builtin_msa_fcaf_d (v2f64, v2f64);

v4i32 __builtin_msa_fceq_w (v4f32, v4f32);
v2i64 __builtin_msa_fceq_d (v2f64, v2f64);

v4i32 __builtin_msa_fclass_w (v4f32);
v2i64 __builtin_msa_fclass_d (v2f64);

v4i32 __builtin_msa_fcle_w (v4f32, v4f32);
v2i64 __builtin_msa_fcle_d (v2f64, v2f64);

v4i32 __builtin_msa_fclt_w (v4f32, v4f32);
v2i64 __builtin_msa_fclt_d (v2f64, v2f64);

v4i32 __builtin_msa_fcne_w (v4f32, v4f32);
v2i64 __builtin_msa_fcne_d (v2f64, v2f64);

v4i32 __builtin_msa_fcor_w (v4f32, v4f32);
v2i64 __builtin_msa_fcor_d (v2f64, v2f64);

v4i32 __builtin_msa_fcueq_w (v4f32, v4f32);
v2i64 __builtin_msa_fcueq_d (v2f64, v2f64);

v4i32 __builtin_msa_fcule_w (v4f32, v4f32);
v2i64 __builtin_msa_fcule_d (v2f64, v2f64);

v4i32 __builtin_msa_fcult_w (v4f32, v4f32);
v2i64 __builtin_msa_fcult_d (v2f64, v2f64);

v4i32 __builtin_msa_fcun_w (v4f32, v4f32);
v2i64 __builtin_msa_fcun_d (v2f64, v2f64);

v4i32 __builtin_msa_fcune_w (v4f32, v4f32);
v2i64 __builtin_msa_fcune_d (v2f64, v2f64);

v4f32 __builtin_msa_fdiv_w (v4f32, v4f32);
v2f64 __builtin_msa_fdiv_d (v2f64, v2f64);

v8i16 __builtin_msa_fexdo_h (v4f32, v4f32);
v4f32 __builtin_msa_fexdo_w (v2f64, v2f64);

v4f32 __builtin_msa_fexp2_w (v4f32, v4i32);
v2f64 __builtin_msa_fexp2_d (v2f64, v2i64);

v4f32 __builtin_msa_fexupl_w (v8i16);
v2f64 __builtin_msa_fexupl_d (v4f32);

v4f32 __builtin_msa_fexupr_w (v8i16);
v2f64 __builtin_msa_fexupr_d (v4f32);

v4f32 __builtin_msa_ffint_s_w (v4i32);
v2f64 __builtin_msa_ffint_s_d (v2i64);

v4f32 __builtin_msa_ffint_u_w (v4u32);
v2f64 __builtin_msa_ffint_u_d (v2u64);

v4f32 __builtin_msa_ffql_w (v8i16);
v2f64 __builtin_msa_ffql_d (v4i32);

v4f32 __builtin_msa_ffqr_w (v8i16);
v2f64 __builtin_msa_ffqr_d (v4i32);

v16i8 __builtin_msa_fill_b (i32);
v8i16 __builtin_msa_fill_h (i32);
v4i32 __builtin_msa_fill_w (i32);
v2i64 __builtin_msa_fill_d (i64);

v4f32 __builtin_msa_flog2_w (v4f32);
v2f64 __builtin_msa_flog2_d (v2f64);

v4f32 __builtin_msa_fmadd_w (v4f32, v4f32, v4f32);
v2f64 __builtin_msa_fmadd_d (v2f64, v2f64, v2f64);

v4f32 __builtin_msa_fmax_w (v4f32, v4f32);
v2f64 __builtin_msa_fmax_d (v2f64, v2f64);

v4f32 __builtin_msa_fmax_a_w (v4f32, v4f32);
v2f64 __builtin_msa_fmax_a_d (v2f64, v2f64);

v4f32 __builtin_msa_fmin_w (v4f32, v4f32);
v2f64 __builtin_msa_fmin_d (v2f64, v2f64);

v4f32 __builtin_msa_fmin_a_w (v4f32, v4f32);
v2f64 __builtin_msa_fmin_a_d (v2f64, v2f64);

v4f32 __builtin_msa_fmsub_w (v4f32, v4f32, v4f32);
v2f64 __builtin_msa_fmsub_d (v2f64, v2f64, v2f64);

v4f32 __builtin_msa_fmul_w (v4f32, v4f32);
v2f64 __builtin_msa_fmul_d (v2f64, v2f64);

v4f32 __builtin_msa_frint_w (v4f32);
v2f64 __builtin_msa_frint_d (v2f64);

v4f32 __builtin_msa_frcp_w (v4f32);
v2f64 __builtin_msa_frcp_d (v2f64);

v4f32 __builtin_msa_frsqrt_w (v4f32);
v2f64 __builtin_msa_frsqrt_d (v2f64);

v4i32 __builtin_msa_fsaf_w (v4f32, v4f32);
v2i64 __builtin_msa_fsaf_d (v2f64, v2f64);

v4i32 __builtin_msa_fseq_w (v4f32, v4f32);
v2i64 __builtin_msa_fseq_d (v2f64, v2f64);

v4i32 __builtin_msa_fsle_w (v4f32, v4f32);
v2i64 __builtin_msa_fsle_d (v2f64, v2f64);

v4i32 __builtin_msa_fslt_w (v4f32, v4f32);
v2i64 __builtin_msa_fslt_d (v2f64, v2f64);

v4i32 __builtin_msa_fsne_w (v4f32, v4f32);
v2i64 __builtin_msa_fsne_d (v2f64, v2f64);

v4i32 __builtin_msa_fsor_w (v4f32, v4f32);
v2i64 __builtin_msa_fsor_d (v2f64, v2f64);

v4f32 __builtin_msa_fsqrt_w (v4f32);
v2f64 __builtin_msa_fsqrt_d (v2f64);

v4f32 __builtin_msa_fsub_w (v4f32, v4f32);
v2f64 __builtin_msa_fsub_d (v2f64, v2f64);

v4i32 __builtin_msa_fsueq_w (v4f32, v4f32);
v2i64 __builtin_msa_fsueq_d (v2f64, v2f64);

v4i32 __builtin_msa_fsule_w (v4f32, v4f32);
v2i64 __builtin_msa_fsule_d (v2f64, v2f64);

v4i32 __builtin_msa_fsult_w (v4f32, v4f32);
v2i64 __builtin_msa_fsult_d (v2f64, v2f64);

v4i32 __builtin_msa_fsun_w (v4f32, v4f32);
v2i64 __builtin_msa_fsun_d (v2f64, v2f64);

v4i32 __builtin_msa_fsune_w (v4f32, v4f32);
v2i64 __builtin_msa_fsune_d (v2f64, v2f64);

v4i32 __builtin_msa_ftint_s_w (v4f32);
v2i64 __builtin_msa_ftint_s_d (v2f64);

v4u32 __builtin_msa_ftint_u_w (v4f32);
v2u64 __builtin_msa_ftint_u_d (v2f64);

v8i16 __builtin_msa_ftq_h (v4f32, v4f32);
v4i32 __builtin_msa_ftq_w (v2f64, v2f64);

v4i32 __builtin_msa_ftrunc_s_w (v4f32);
v2i64 __builtin_msa_ftrunc_s_d (v2f64);

v4u32 __builtin_msa_ftrunc_u_w (v4f32);
v2u64 __builtin_msa_ftrunc_u_d (v2f64);

v8i16 __builtin_msa_hadd_s_h (v16i8, v16i8);
v4i32 __builtin_msa_hadd_s_w (v8i16, v8i16);
v2i64 __builtin_msa_hadd_s_d (v4i32, v4i32);

v8u16 __builtin_msa_hadd_u_h (v16u8, v16u8);
v4u32 __builtin_msa_hadd_u_w (v8u16, v8u16);
v2u64 __builtin_msa_hadd_u_d (v4u32, v4u32);

v8i16 __builtin_msa_hsub_s_h (v16i8, v16i8);
v4i32 __builtin_msa_hsub_s_w (v8i16, v8i16);
v2i64 __builtin_msa_hsub_s_d (v4i32, v4i32);

v8i16 __builtin_msa_hsub_u_h (v16u8, v16u8);
v4i32 __builtin_msa_hsub_u_w (v8u16, v8u16);
v2i64 __builtin_msa_hsub_u_d (v4u32, v4u32);

v16i8 __builtin_msa_ilvev_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvev_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvev_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvev_d (v2i64, v2i64);

v16i8 __builtin_msa_ilvl_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvl_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvl_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvl_d (v2i64, v2i64);

v16i8 __builtin_msa_ilvod_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvod_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvod_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvod_d (v2i64, v2i64);

v16i8 __builtin_msa_ilvr_b (v16i8, v16i8);
v8i16 __builtin_msa_ilvr_h (v8i16, v8i16);
v4i32 __builtin_msa_ilvr_w (v4i32, v4i32);
v2i64 __builtin_msa_ilvr_d (v2i64, v2i64);

v16i8 __builtin_msa_insert_b (v16i8, imm0_15, i32);
v8i16 __builtin_msa_insert_h (v8i16, imm0_7, i32);
v4i32 __builtin_msa_insert_w (v4i32, imm0_3, i32);
v2i64 __builtin_msa_insert_d (v2i64, imm0_1, i64);

v16i8 __builtin_msa_insve_b (v16i8, imm0_15, v16i8);
v8i16 __builtin_msa_insve_h (v8i16, imm0_7, v8i16);
v4i32 __builtin_msa_insve_w (v4i32, imm0_3, v4i32);
v2i64 __builtin_msa_insve_d (v2i64, imm0_1, v2i64);

v16i8 __builtin_msa_ld_b (void *, imm_n512_511);
v8i16 __builtin_msa_ld_h (void *, imm_n1024_1022);
v4i32 __builtin_msa_ld_w (void *, imm_n2048_2044);
v2i64 __builtin_msa_ld_d (void *, imm_n4096_4088);

v16i8 __builtin_msa_ldi_b (imm_n512_511);
v8i16 __builtin_msa_ldi_h (imm_n512_511);
v4i32 __builtin_msa_ldi_w (imm_n512_511);
v2i64 __builtin_msa_ldi_d (imm_n512_511);

v8i16 __builtin_msa_madd_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_madd_q_w (v4i32, v4i32, v4i32);

v8i16 __builtin_msa_maddr_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_maddr_q_w (v4i32, v4i32, v4i32);

v16i8 __builtin_msa_maddv_b (v16i8, v16i8, v16i8);
v8i16 __builtin_msa_maddv_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_maddv_w (v4i32, v4i32, v4i32);
v2i64 __builtin_msa_maddv_d (v2i64, v2i64, v2i64);

v16i8 __builtin_msa_max_a_b (v16i8, v16i8);
v8i16 __builtin_msa_max_a_h (v8i16, v8i16);
v4i32 __builtin_msa_max_a_w (v4i32, v4i32);
v2i64 __builtin_msa_max_a_d (v2i64, v2i64);

v16i8 __builtin_msa_max_s_b (v16i8, v16i8);
v8i16 __builtin_msa_max_s_h (v8i16, v8i16);
v4i32 __builtin_msa_max_s_w (v4i32, v4i32);
v2i64 __builtin_msa_max_s_d (v2i64, v2i64);

v16u8 __builtin_msa_max_u_b (v16u8, v16u8);
v8u16 __builtin_msa_max_u_h (v8u16, v8u16);
v4u32 __builtin_msa_max_u_w (v4u32, v4u32);
v2u64 __builtin_msa_max_u_d (v2u64, v2u64);

v16i8 __builtin_msa_maxi_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_maxi_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_maxi_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_maxi_s_d (v2i64, imm_n16_15);

v16u8 __builtin_msa_maxi_u_b (v16u8, imm0_31);
v8u16 __builtin_msa_maxi_u_h (v8u16, imm0_31);
v4u32 __builtin_msa_maxi_u_w (v4u32, imm0_31);
v2u64 __builtin_msa_maxi_u_d (v2u64, imm0_31);

v16i8 __builtin_msa_min_a_b (v16i8, v16i8);
v8i16 __builtin_msa_min_a_h (v8i16, v8i16);
v4i32 __builtin_msa_min_a_w (v4i32, v4i32);
v2i64 __builtin_msa_min_a_d (v2i64, v2i64);

v16i8 __builtin_msa_min_s_b (v16i8, v16i8);
v8i16 __builtin_msa_min_s_h (v8i16, v8i16);
v4i32 __builtin_msa_min_s_w (v4i32, v4i32);
v2i64 __builtin_msa_min_s_d (v2i64, v2i64);

v16u8 __builtin_msa_min_u_b (v16u8, v16u8);
v8u16 __builtin_msa_min_u_h (v8u16, v8u16);
v4u32 __builtin_msa_min_u_w (v4u32, v4u32);
v2u64 __builtin_msa_min_u_d (v2u64, v2u64);

v16i8 __builtin_msa_mini_s_b (v16i8, imm_n16_15);
v8i16 __builtin_msa_mini_s_h (v8i16, imm_n16_15);
v4i32 __builtin_msa_mini_s_w (v4i32, imm_n16_15);
v2i64 __builtin_msa_mini_s_d (v2i64, imm_n16_15);

v16u8 __builtin_msa_mini_u_b (v16u8, imm0_31);
v8u16 __builtin_msa_mini_u_h (v8u16, imm0_31);
v4u32 __builtin_msa_mini_u_w (v4u32, imm0_31);
v2u64 __builtin_msa_mini_u_d (v2u64, imm0_31);

v16i8 __builtin_msa_mod_s_b (v16i8, v16i8);
v8i16 __builtin_msa_mod_s_h (v8i16, v8i16);
v4i32 __builtin_msa_mod_s_w (v4i32, v4i32);
v2i64 __builtin_msa_mod_s_d (v2i64, v2i64);

v16u8 __builtin_msa_mod_u_b (v16u8, v16u8);
v8u16 __builtin_msa_mod_u_h (v8u16, v8u16);
v4u32 __builtin_msa_mod_u_w (v4u32, v4u32);
v2u64 __builtin_msa_mod_u_d (v2u64, v2u64);

v16i8 __builtin_msa_move_v (v16i8);

v8i16 __builtin_msa_msub_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_msub_q_w (v4i32, v4i32, v4i32);

v8i16 __builtin_msa_msubr_q_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_msubr_q_w (v4i32, v4i32, v4i32);

v16i8 __builtin_msa_msubv_b (v16i8, v16i8, v16i8);
v8i16 __builtin_msa_msubv_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_msubv_w (v4i32, v4i32, v4i32);
v2i64 __builtin_msa_msubv_d (v2i64, v2i64, v2i64);

v8i16 __builtin_msa_mul_q_h (v8i16, v8i16);
v4i32 __builtin_msa_mul_q_w (v4i32, v4i32);

v8i16 __builtin_msa_mulr_q_h (v8i16, v8i16);
v4i32 __builtin_msa_mulr_q_w (v4i32, v4i32);

v16i8 __builtin_msa_mulv_b (v16i8, v16i8);
v8i16 __builtin_msa_mulv_h (v8i16, v8i16);
v4i32 __builtin_msa_mulv_w (v4i32, v4i32);
v2i64 __builtin_msa_mulv_d (v2i64, v2i64);

v16i8 __builtin_msa_nloc_b (v16i8);
v8i16 __builtin_msa_nloc_h (v8i16);
v4i32 __builtin_msa_nloc_w (v4i32);
v2i64 __builtin_msa_nloc_d (v2i64);

v16i8 __builtin_msa_nlzc_b (v16i8);
v8i16 __builtin_msa_nlzc_h (v8i16);
v4i32 __builtin_msa_nlzc_w (v4i32);
v2i64 __builtin_msa_nlzc_d (v2i64);

v16u8 __builtin_msa_nor_v (v16u8, v16u8);

v16u8 __builtin_msa_nori_b (v16u8, imm0_255);

v16u8 __builtin_msa_or_v (v16u8, v16u8);

v16u8 __builtin_msa_ori_b (v16u8, imm0_255);

v16i8 __builtin_msa_pckev_b (v16i8, v16i8);
v8i16 __builtin_msa_pckev_h (v8i16, v8i16);
v4i32 __builtin_msa_pckev_w (v4i32, v4i32);
v2i64 __builtin_msa_pckev_d (v2i64, v2i64);

v16i8 __builtin_msa_pckod_b (v16i8, v16i8);
v8i16 __builtin_msa_pckod_h (v8i16, v8i16);
v4i32 __builtin_msa_pckod_w (v4i32, v4i32);
v2i64 __builtin_msa_pckod_d (v2i64, v2i64);

v16i8 __builtin_msa_pcnt_b (v16i8);
v8i16 __builtin_msa_pcnt_h (v8i16);
v4i32 __builtin_msa_pcnt_w (v4i32);
v2i64 __builtin_msa_pcnt_d (v2i64);

v16i8 __builtin_msa_sat_s_b (v16i8, imm0_7);
v8i16 __builtin_msa_sat_s_h (v8i16, imm0_15);
v4i32 __builtin_msa_sat_s_w (v4i32, imm0_31);
v2i64 __builtin_msa_sat_s_d (v2i64, imm0_63);

v16u8 __builtin_msa_sat_u_b (v16u8, imm0_7);
v8u16 __builtin_msa_sat_u_h (v8u16, imm0_15);
v4u32 __builtin_msa_sat_u_w (v4u32, imm0_31);
v2u64 __builtin_msa_sat_u_d (v2u64, imm0_63);

v16i8 __builtin_msa_shf_b (v16i8, imm0_255);
v8i16 __builtin_msa_shf_h (v8i16, imm0_255);
v4i32 __builtin_msa_shf_w (v4i32, imm0_255);

v16i8 __builtin_msa_sld_b (v16i8, v16i8, i32);
v8i16 __builtin_msa_sld_h (v8i16, v8i16, i32);
v4i32 __builtin_msa_sld_w (v4i32, v4i32, i32);
v2i64 __builtin_msa_sld_d (v2i64, v2i64, i32);

v16i8 __builtin_msa_sldi_b (v16i8, v16i8, imm0_15);
v8i16 __builtin_msa_sldi_h (v8i16, v8i16, imm0_7);
v4i32 __builtin_msa_sldi_w (v4i32, v4i32, imm0_3);
v2i64 __builtin_msa_sldi_d (v2i64, v2i64, imm0_1);

v16i8 __builtin_msa_sll_b (v16i8, v16i8);
v8i16 __builtin_msa_sll_h (v8i16, v8i16);
v4i32 __builtin_msa_sll_w (v4i32, v4i32);
v2i64 __builtin_msa_sll_d (v2i64, v2i64);

v16i8 __builtin_msa_slli_b (v16i8, imm0_7);
v8i16 __builtin_msa_slli_h (v8i16, imm0_15);
v4i32 __builtin_msa_slli_w (v4i32, imm0_31);
v2i64 __builtin_msa_slli_d (v2i64, imm0_63);

v16i8 __builtin_msa_splat_b (v16i8, i32);
v8i16 __builtin_msa_splat_h (v8i16, i32);
v4i32 __builtin_msa_splat_w (v4i32, i32);
v2i64 __builtin_msa_splat_d (v2i64, i32);

v16i8 __builtin_msa_splati_b (v16i8, imm0_15);
v8i16 __builtin_msa_splati_h (v8i16, imm0_7);
v4i32 __builtin_msa_splati_w (v4i32, imm0_3);
v2i64 __builtin_msa_splati_d (v2i64, imm0_1);

v16i8 __builtin_msa_sra_b (v16i8, v16i8);
v8i16 __builtin_msa_sra_h (v8i16, v8i16);
v4i32 __builtin_msa_sra_w (v4i32, v4i32);
v2i64 __builtin_msa_sra_d (v2i64, v2i64);

v16i8 __builtin_msa_srai_b (v16i8, imm0_7);
v8i16 __builtin_msa_srai_h (v8i16, imm0_15);
v4i32 __builtin_msa_srai_w (v4i32, imm0_31);
v2i64 __builtin_msa_srai_d (v2i64, imm0_63);

v16i8 __builtin_msa_srar_b (v16i8, v16i8);
v8i16 __builtin_msa_srar_h (v8i16, v8i16);
v4i32 __builtin_msa_srar_w (v4i32, v4i32);
v2i64 __builtin_msa_srar_d (v2i64, v2i64);

v16i8 __builtin_msa_srari_b (v16i8, imm0_7);
v8i16 __builtin_msa_srari_h (v8i16, imm0_15);
v4i32 __builtin_msa_srari_w (v4i32, imm0_31);
v2i64 __builtin_msa_srari_d (v2i64, imm0_63);

v16i8 __builtin_msa_srl_b (v16i8, v16i8);
v8i16 __builtin_msa_srl_h (v8i16, v8i16);
v4i32 __builtin_msa_srl_w (v4i32, v4i32);
v2i64 __builtin_msa_srl_d (v2i64, v2i64);

v16i8 __builtin_msa_srli_b (v16i8, imm0_7);
v8i16 __builtin_msa_srli_h (v8i16, imm0_15);
v4i32 __builtin_msa_srli_w (v4i32, imm0_31);
v2i64 __builtin_msa_srli_d (v2i64, imm0_63);

v16i8 __builtin_msa_srlr_b (v16i8, v16i8);
v8i16 __builtin_msa_srlr_h (v8i16, v8i16);
v4i32 __builtin_msa_srlr_w (v4i32, v4i32);
v2i64 __builtin_msa_srlr_d (v2i64, v2i64);

v16i8 __builtin_msa_srlri_b (v16i8, imm0_7);
v8i16 __builtin_msa_srlri_h (v8i16, imm0_15);
v4i32 __builtin_msa_srlri_w (v4i32, imm0_31);
v2i64 __builtin_msa_srlri_d (v2i64, imm0_63);

void __builtin_msa_st_b (v16i8, void *, imm_n512_511);
void __builtin_msa_st_h (v8i16, void *, imm_n1024_1022);
void __builtin_msa_st_w (v4i32, void *, imm_n2048_2044);
void __builtin_msa_st_d (v2i64, void *, imm_n4096_4088);

v16i8 __builtin_msa_subs_s_b (v16i8, v16i8);
v8i16 __builtin_msa_subs_s_h (v8i16, v8i16);
v4i32 __builtin_msa_subs_s_w (v4i32, v4i32);
v2i64 __builtin_msa_subs_s_d (v2i64, v2i64);

v16u8 __builtin_msa_subs_u_b (v16u8, v16u8);
v8u16 __builtin_msa_subs_u_h (v8u16, v8u16);
v4u32 __builtin_msa_subs_u_w (v4u32, v4u32);
v2u64 __builtin_msa_subs_u_d (v2u64, v2u64);

v16u8 __builtin_msa_subsus_u_b (v16u8, v16i8);
v8u16 __builtin_msa_subsus_u_h (v8u16, v8i16);
v4u32 __builtin_msa_subsus_u_w (v4u32, v4i32);
v2u64 __builtin_msa_subsus_u_d (v2u64, v2i64);

v16i8 __builtin_msa_subsuu_s_b (v16u8, v16u8);
v8i16 __builtin_msa_subsuu_s_h (v8u16, v8u16);
v4i32 __builtin_msa_subsuu_s_w (v4u32, v4u32);
v2i64 __builtin_msa_subsuu_s_d (v2u64, v2u64);

v16i8 __builtin_msa_subv_b (v16i8, v16i8);
v8i16 __builtin_msa_subv_h (v8i16, v8i16);
v4i32 __builtin_msa_subv_w (v4i32, v4i32);
v2i64 __builtin_msa_subv_d (v2i64, v2i64);

v16i8 __builtin_msa_subvi_b (v16i8, imm0_31);
v8i16 __builtin_msa_subvi_h (v8i16, imm0_31);
v4i32 __builtin_msa_subvi_w (v4i32, imm0_31);
v2i64 __builtin_msa_subvi_d (v2i64, imm0_31);

v16i8 __builtin_msa_vshf_b (v16i8, v16i8, v16i8);
v8i16 __builtin_msa_vshf_h (v8i16, v8i16, v8i16);
v4i32 __builtin_msa_vshf_w (v4i32, v4i32, v4i32);
v2i64 __builtin_msa_vshf_d (v2i64, v2i64, v2i64);

v16u8 __builtin_msa_xor_v (v16u8, v16u8);

v16u8 __builtin_msa_xori_b (v16u8, imm0_255);
@end smallexample

@node Other MIPS Built-in Functions
@subsection 他のMIPS組み込み関数

GCCは他のMIPS固有の組み込み関数を提供する：

@table @code
@item void __builtin_mips_cache (int @var{op}, const volatile void *@var{addr})
オペランド@var{op}と@var{addr}を持つ@samp{cache}命令を挿入する。GCCは、この関数が利用可能なときにプリプロセッサマクロ@code {___GCC_HAVE_BUILTIN_MIPS_CACHE}を定義する。

@item unsigned int __builtin_mips_get_fcsr (void)
@itemx void __builtin_mips_set_fcsr (unsigned int @var{value})
浮動小数点制御およびステータスレジスタ（FPU制御レジスタ31）の内容を取得および設定する。 これらの関数はハードフロートコードでのみ使用できるが、MIPS16と非MIPS16の両方のコンテキストで呼び出すことができる。

@code{__builtin_mips_set_fcsr}は、GCCが保持していると仮定する条件コード以外のレジスタのビットを変更するために使用できる。
@end table

@node MSP430 Built-in Functions
@subsection MSP430組み込み関数

GCCは、Cで割り込みハンドラを書くのを助ける特別な組み込み関数を提供している。

@table @code
@item __bic_SR_register_on_exit (int @var{mask})
これは、スタックに現在存在するステータスレジスタの保存されたコピーの示されたビットをクリアする。 これは割り込みハンドラ内でのみ機能し、ステータスレジスタへの変更はハンドラが復帰すると有効になる。

@item __bis_SR_register_on_exit (int @var{mask})
これは、スタックに現在存在するステータスレジスタの保存されたコピーに示されたビットをセットする。 これは割り込みハンドラ内でのみ機能し、ステータスレジスタへの変更はハンドラが復帰すると有効になる。

@item __delay_cycles (long long @var{cycles})
これは、完全に@var{cycles}サイクル（0と約17E9の間）かかる命令シーケンスを挿入する。 挿入されたシーケンスは、ジャンプ、ループ、またはno-opを使用する可能性があり、他の命令に干渉することはない。 @var{cycles}はコンパイル時定数でなければならないことに注意せよ。つまり、後で定数に最適化できる変数ではなく、数値を渡す必要がある。 この組み込みによって遅延されるサイクル数は正確である。
@end table

@node NDS32 Built-in Functions
@subsection NDS32組み込み関数

これらの組み込み関数は、NDS32ターゲットで使用できる。

@deftypefn {Built-in Function} void __builtin_nds32_isync (int *@var{addr})
命令ストリームにISYNC命令を挿入する。ここで、@var{addr}はシリアル化の命令アドレスである。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_isb (void)
命令ストリームにISB命令を挿入する。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_nds32_mfsr (int @var{sr})
@var {sr}でマップされたシステムレジスタの内容を返す。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_nds32_mfusr (int @var{usr})
@var{usr}によってマップされるユーザー空間レジスタの内容を返す。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_mtsr (int @var{value}, int @var{sr})
@var{value}を@var{sr}でマッピングされたシステムレジスタに移動する。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_mtusr (int @var{value}, int @var{usr})
@var{value}を@var{usr}によってマップされたユーザースペースレジスタに移動します。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_setgie_en (void)
グローバル割り込みを有効にする。
@end deftypefn

@deftypefn {Built-in Function} void __builtin_nds32_setgie_dis (void)
グローバル割り込みを無効にする。
@end deftypefn

@node picoChip Built-in Functions
@subsection picoChip組み込み関数

GCCは、picoChip命令セットから選択されたマシン命令へのインタフェースを提供する。

@table @code
@item int __builtin_sbc (int @var{value})
符号ビット数。 @var{value}の符号ビットと同じ値を持つ連続するビット数を返す。 結果は先頭の符号ビットから1を引いた数で、@var{value}に冗長符号ビットの数が与えられる。

@item int __builtin_byteswap (int @var{value})
バイトスワップ。 @var{value}の上位バイトと下位バイトを入れ替えた結果を返す。

@item int __builtin_brev (int @var{value})
ビット反転。 @var{value}のビットを反転した結果を返す。 ビット15はビット0とスワップされ、ビット14はビット1とスワップされ、以下同様に続く。

@item int __builtin_adds (int @var{x}, int @var{y})
飽和加算。 @var{x}と@var{y}の加算結果を返し、結果がオーバーフローした場合は32767の値を格納する。

@item int __builtin_subs (int @var{x}, int @var{y})
飽和減算。 @var{x}から@var{y}を減算した結果を返し、結果がオーバーフローした場合は@minus{}32768を格納する。

@item void __builtin_halt (void)
停止。 プロセッサは実行を停止する。 この組み込み関数は、アサーションを実装するのに便利である。

@end table

@node PowerPC Built-in Functions
@subsection PowerPC組み込み関数

以下の組み込み関数は常に使用可能であり、PowerPCターゲットプラットフォームのタイプを確認するために使用できる。

@deftypefn {Built-in Function} void __builtin_cpu_init (void)
この関数は、PowerPCプラットフォームの@code {nop}であり、x86組み込み関数とのAPI互換性を維持するためだけに含まれている。
@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_is (const char *@var{cpuname})
この関数は、ランタイムCPUのタイプが@var{cpuname}の場合は@code{1}の値を返し、それ以外の場合は@code{0}を返す。

@code{__ builtin_cpu_is}関数には、ハードウェア機能ビットをエクスポートするGLIBC 2.23以降が必要である。 @code{__builtin_cpu_supports}組み込み関数が完全にサポートされている場合、GCCはマクロ@code{__BUILTIN_CPU_SUPPORTS__}を定義する。

GLIBC2.23より前に使用するようにGCCを設定した場合、組み込み関数@code{__builtin_cpu_is}は常に0を返し、コンパイラは警告を出す。

次のCPU名を検出できる。

@table @samp
@item power9
IBM POWER9サーバーCPU。
@item power8
IBM POWER8サーバーCPU。
@item power7
IBM POWER7サーバーCPU。
@item power6x
IBM POWER6サーバーCPU。(RAWモード）
@item power6
IBM POWER6サーバーCPU。(アーキテクテッドモード）
@item power5+
IBM POWER5+サーバーCPU。
@item power5
IBM POWER5サーバーCPU。
@item ppc970
IBM 970 サーバーCPU。（すなわち、Apple G5）。
@item power4
IBM POWER4サーバーCPU。
@item ppca2
IBM A2 64ビット組み込みCPU。
@item ppc476
IBM PowerPC 476FP 32ビット組み込みCPU。
@item ppc464
IBM PowerPC 464 32ビット組み込みCPU。
@item ppc440
PowerPC 440 32ビット組み込みCPU。
@item ppc405
PowerPC 405 32ビット組み込みCPU。
@item ppc-cell-be
IBM PowerPC Cell Broadband EngineアーキテクチャCPU。
@end table

ここに例がある：
@smallexample
#ifdef __BUILTIN_CPU_SUPPORTS__
  if (__builtin_cpu_is ("power8"))
    @{
       do_power8 (); // POWER8 specific implementation.
    @}
  else
#endif
    @{
       do_generic (); // Generic implementation.
    @}
@end smallexample
@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_supports (const char *@var{feature})
この関数は、ランタイムCPUがHWCAP機能@var{feature}をサポートしていれば@code{1}の値を返し、それ以外の場合は@code{0}を返す。

@code{__builtin_cpu_supports}関数は、ハードウェア機能ビットをエクスポートするGLIBC 2.23以降が必要である。 @code{__builtin_cpu_supports}組み込み関数が完全にサポートされている場合、GCCはマクロ@code{__BUILTIN_CPU_SUPPORTS__}を定義する。

GLIBC2.23より前に使用するようにGCCを設定した場合、組み込み関数@code{__builtin_cpu_suports}は常に0を返し、コンパイラは警告を出す。

次の機能を検出できる。

@table @samp
@item 4xxmac
4xxCPUは複数の加算器を持っている。
@item altivec
CPUはSIMD/ベクトルユニットを持っている。
@item arch_2_05
CPUはISA 2.05をサポートしている（例えば、POWER6）
@item arch_2_06
CPUはISA 2.06をサポートしている（例えば、POWER7）
@item arch_2_07
CPUはISA 2.07をサポートしている（例えば、POWER8）
@item arch_3_00
CPUはISA 3.0をサポートしている（例えば、POWER9）
@item archpmu
CPUは互換性のあるパフォーマンス監視イベントのセットをサポートしている。
@item booke
CPUは組み込みISAカテゴリーをサポートしている。
@item cellbe
CPUはCELLブロードバンドエンジンをサポートしている。
@item dfp
CPUは10進浮動小数点ユニットを持っている。
@item dscr
CPUはデータストリーム制御レジスタをサポートしている。
@item ebb
CPUはイベントベース分岐をサポートしている。
@item efpdouble
CPUはSPE倍精度浮動小数点ユニットを持っている。
@item efpsingle
CPUはSPE単精度浮動小数点ユニットを持っている。
@item fpu
CPUは浮動小数点ユニットを持っている。
@item htm
CPUはハードウェアトランザクションメモリ命令を持っている。
@item htm-nosc
カーネルはシステムコールが生じたときにハードウェアトランザクションを中止する。
@item ic_snoop
CPUはicacheスヌーピング能力をサポートしている。
@item ieee128
CPUは128ビットIEEE2進浮動小数点命令をサポートしている。
@item isel
CPUは整数選択命令をサポートしている。
@item mmu
CPUはメモリー管理ユニットを持っている。
@item notb
CPUははタイムベースを持っていない（例えば601や403gx）。
@item pa6t
CPUはPA Semi 6T CORE ISAをサポートしている。
@item power4
CPUはISA 2.00をサポートしている（例えば、POWER4）
@item power5
CPUはISA 2.02をサポートしている（例えば、POWER5）
@item power5+
CPUはISA 2.03をサポートしている（例えば、POWER5+）
@item power6x
CPUはISA 2.05拡張オプコードmffgprとmftgprをサポートしている（例えば、POWER6）
@item ppc32
CPUは32ビットモード実行をサポートしている。
@item ppc601
CPUは古いPOWER ISAをサポートしている（例えば、601）
@item ppc64
CPUは64ビットモード実行をサポートしている。
@item ppcle
CPUはアドレス入れ替えを使っているリトルエンディアンモードをサポートしている。
@item smt
CPUは同時マルチスレッドをサポートしている。
@item spe
CPUはシグナル処理拡張ユニットを持っている。
@item tar
CPUはターゲットアドレスレジスタをサポートしている。
@item true_le
CPUは真のリトルエンディアンモードをサポートしている。
@item ucache
CPUは統合I/Dキャッシュを持っている。
@item vcrypto
CPUはベクトル暗号命令をサポートしている。
@item vsx
CPUはベクトルスカラ拡張をサポートしている。
@end table

ここに例がある
@smallexample
#ifdef __BUILTIN_CPU_SUPPORTS__
  if (__builtin_cpu_supports ("fpu"))
    @{
       asm("fadd %0,%1,%2" : "=d"(dst) : "d"(src1), "d"(src2));
    @}
  else
#endif
    @{
       dst = __fadd (src1, src2); // Software FP addition function.
    @}
@end smallexample
@end deftypefn

これらの組み込み関数はPowerPCファミリのプロセッサで利用可能である。
@smallexample
float __builtin_recipdivf (float, float);
float __builtin_rsqrtf (float);
double __builtin_recipdiv (double, double);
double __builtin_rsqrt (double);
uint64_t __builtin_ppc_get_timebase ();
unsigned long __builtin_ppc_mftb ();
double __builtin_unpack_longdouble (long double, int);
long double __builtin_pack_longdouble (double, double);
@end smallexample

@code{vec_rsqrt}、@code{__builtin_rsqrt}、および@code{__builtin_rsqrtf}関数は、逆数sqrt推定命令を使用して逆数sqrt機能を実装するための複数の命令を生成する。

@code{__builtin_recipdiv}関数と@code{__builtin_recipdivf}関数は、逆数推定命令を使用して除算を実装するための複数の命令を生成する。

@code{__builtin_ppc_get_timebase}関数と@code{__builtin_ppc_mftb}関数は、タイムベースレジスタを読み込む命令を生成する。 @code{__builtin_ppc_get_timebase}関数は、複数の命令を生成し、常にタイムベースレジスタの64ビットを返す。@code{__builtin_ppc_mftb}関数は常に1つの命令を生成し、32ビット環境で最上位ワードを投げ捨て、符号なしlongとしてタイムベースレジスタの値を返す。

128ビット浮動小数点（@code{__float128}）値を効率的に使用するために、64ビットPowerPCファミリのプロセッサに追加の組み込み関数が用意されている。

GCCの以前のバージョンでは、IEEE 128ビット浮動小数点用の「q」組み込み関数がサポートされていた。 これらの関数は、これと同等の 'f128'組み込み関数にマップされるようになった。

@smallexample
__builtin_fabsq は __builtin_fabsf128
__builtin_copysignq は __builtin_copysignf128
__builtin_infq は __builtin_inff128
__builtin_huge_valq は __builtin_huge_valf128
__builtin_nanq は __builtin_nanf128
__builtin_nansq は __builtin_nansf128
@end smallexample

次の組み込み関数は、ISA 3.0命令セットを使用するLinux 64ビットシステムで使用できる。

@table @code
@item __float128 __builtin_sqrtf128 (__float128)
128ビットIEEE浮動小数点平方根演算を実行する。
@findex __builtin_sqrtf128

@item __float128 __builtin_fmaf128 (__float128, __float128, __float128)
128ビットIEEE浮動小数点の積和演算を実行する。
@findex __builtin_fmaf128

@item __float128 __builtin_addf128_round_to_odd (__float128, __float128)
丸めモードとしてround to oddを使用して128ビットのIEEE浮動小数点加算を実行する。
@findex __builtin_addf128_round_to_odd

@item __float128 __builtin_subf128_round_to_odd (__float128, __float128)
丸めモードとしてround to oddを使用して128ビットのIEEE浮動小数点減算を実行する。
@findex __builtin_subf128_round_to_odd

@item __float128 __builtin_mulf128_round_to_odd (__float128, __float128)
丸めモードとしてround to oddを使用して128ビットのIEEE浮動小数点乗算を実行する。
@findex __builtin_mulf128_round_to_odd

@item __float128 __builtin_divf128_round_to_odd (__float128, __float128)
丸めモードとしてround to oddを使用して128ビットのIEEE浮動小数点除算を実行する。
@findex __builtin_divf128_round_to_odd

@item __float128 __builtin_sqrtf128_round_to_odd (__float128)
丸めモードとしてround to oddを使用して128ビットのIEEE浮動小数点平方根を実行する。
@findex __builtin_sqrtf128_round_to_odd

@item __float128 __builtin_fmaf128 (__float128, __float128, __float128)
丸めモードとしてround to oddを使用して、128ビットIEEE浮動小数点の積和演算を実行する。
@findex __builtin_fmaf128_round_to_odd

@item double __builtin_truncf128_round_to_odd (__float128)
丸めモードとしてround to oddを使用して、128ビットのIEEE浮動小数点値を@code{double}に変換する。
@findex __builtin_truncf128_round_to_odd
@end table

次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 2.05以降（@option{-mcpu=power6}または@option{-mcmpb}）から使用できる。
@smallexample
unsigned long long __builtin_cmpb (unsigned long long int, unsigned long long int);
unsigned int __builtin_cmpb (unsigned int, unsigned int);
@end smallexample

@code{__builtin_cmpb}関数は、2つの引数の内容をバイト単位で比較し、バイト単位の比較の結果を戻り値として返す。 各バイト比較の場合、戻り値の対応するバイトは、入力バイトが等しい場合は0xffを、入力バイトが等しい場合は0を保持する。 この組み込み関数のいずれかの引数が32ビットより大きい場合、関数呼び出しは、64ビットターゲットでのみ使用可能な@code{unsigned long long int}引数を必要とする形式に展開される。

次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 2.06以降（@option{-mcpu=power7}または@option{-mpopcntd}）から使用できる。
@smallexample
long __builtin_bpermd (long, long);
int __builtin_divwe (int, int);
unsigned int __builtin_divweu (unsigned int, unsigned int);
long __builtin_divde (long, long);
unsigned long __builtin_divdeu (unsigned long, unsigned long);
unsigned int cdtbcd (unsigned int);
unsigned int cbcdtd (unsigned int);
unsigned int addg6s (unsigned int, unsigned int);
void __builtin_rs6000_speculation_barrier (void);
@end smallexample

@code{__builtin_divde}関数と@code{__builtin_divdeu}関数には、ISA 2.06以降をサポートする64ビット環境が必要である。

次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 3.0以降（@option{-mcpu=power9}）から使用できる。
@smallexample
long long __builtin_darn (void);
long long __builtin_darn_raw (void);
int __builtin_darn_32 (void);

unsigned int scalar_extract_exp (double source);
unsigned long long int scalar_extract_exp (__ieee128 source);

unsigned long long int scalar_extract_sig (double source);
unsigned __int128 scalar_extract_sig (__ieee128 source);

double
scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);
double
scalar_insert_exp (double significand, unsigned long long int exponent);

ieee_128
scalar_insert_exp (unsigned __int128 significand, unsigned long long int exponent);
ieee_128
scalar_insert_exp (ieee_128 significand, unsigned long long int exponent);

int scalar_cmp_exp_gt (double arg1, double arg2);
int scalar_cmp_exp_lt (double arg1, double arg2);
int scalar_cmp_exp_eq (double arg1, double arg2);
int scalar_cmp_exp_unordered (double arg1, double arg2);

bool scalar_test_data_class (float source, const int condition);
bool scalar_test_data_class (double source, const int condition);
bool scalar_test_data_class (__ieee128 source, const int condition);

bool scalar_test_neg (float source);
bool scalar_test_neg (double source);
bool scalar_test_neg (__ieee128 source);

int __builtin_byte_in_set (unsigned char u, unsigned long long set);
int __builtin_byte_in_range (unsigned char u, unsigned int range);
int __builtin_byte_in_either_range (unsigned char u, unsigned int ranges);

int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_lt_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_lt_td (unsigned int comparison, _Decimal128 value);

int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_gt_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_gt_td (unsigned int comparison, _Decimal128 value);

int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_eq_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_eq_td (unsigned int comparison, _Decimal128 value);

int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);
int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);
int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);
@end smallexample

@code{__builtin_darn}関数と@code{__builtin_darn_raw}関数には、ISA 3.0以降をサポートする64ビット環境が必要である。@code{__builtin_darn}関数は、64ビットの条件付き乱数を提供する。 @code{__builtin_darn_raw}関数は、64ビットの生の乱数を提供する。 @code{__builtin_darn_32}関数は、32ビットの乱数を提供する。

@code{scalar_extract_exp}関数と@code{scalar_extract_sig}関数には、ISA 3.0以降をサポートする64ビット環境が必要である。@code{scalar_extract_exp}と@code{scalar_extract_sig}組み込み関数は、それぞれの@code{source}引数の仮数部とバイアスされた指数部の値を返す。64ビットの@code{source}引数を指定すると、@code{scalar_extract_sig}によって返される結果には、@code{0x0010000000000000}ビットが設定される。関数の@code{source}引数は正規化された形式である。それ以外の場合、このビットは0に設定される。128ビットの@code{source}引数を指定すると、結果の@code{0x00010000000000000000000000000000}ビットも同様に扱われる。仮数部の符号は、@code{scalar_extract_sig}関数から返された結果には現れない。 @code{double}引数の符号をテストするには、@code{scalar_test_neg}関数を使用する。

@code {scalar_insert_exp}関数には、ISA 3.0以降をサポートする64ビット環境が必要である。64ビットの第1引数を指定すると、@code{scalar_insert_exp}組み込み関数は@code{significand}および@code{exponent}引数の値を組み立てることによって構築された倍精度浮動小数点値を返す。 結果の符号は@code{significand}引数の最上位ビットからコピーされる。 結果の有効成分と指数成分は、それぞれ@code{exponent}引数の最下位11ビットと@code{significand}引数の最下位52ビットで構成される。

128ビットの第1引数を指定すると、@code{scalar_insert_exp}組み込み関数は4倍精度のieee浮動小数点値を返す。 結果の符号ビットは、@code{significand}引数の最上位ビットからコピーされる。結果の有効成分と指数成分は、それぞれ@code{exponent}引数の最下位15ビットと@code{significand}引数の最下位112ビットで構成される。

@code{scalar_cmp_exp_lt}、@code{scalar_cmp_exp_eq}、および@code{scalar_cmp_exp_unordered}組み込み関数は、@code{arg1}が@code{arg2}に対して、より大きい、より小さい、等しい、または比較不能の場合、0以外の値を返す。どちらか一方がNaN（非数）に等しい場合、引数は比較不能である。

@code{scalar_test_data_class}組み込み関数は、@code{condition}変数の値によって有効にされた条件テストのいずれかが真であれば1を返し、そうでなければ0を返す。 @code{condition}引数は、127を超えない値を持つコンパイル時定数でなければならない。@code{condition}引数は、次のような特徴を持つ異なる条件のテストを可能にするビットごとのビットマスクとしてエンコードされる。
@smallexample
0x40    Test for NaN
0x20    Test for +Infinity
0x10    Test for -Infinity
0x08    Test for +Zero
0x04    Test for -Zero
0x02    Test for +Denormal
0x01    Test for -Denormal
@end smallexample

@code{scalar_test_neg}組み込み関数は、@ code{source}引数が負の値を保持する場合は1を返し、それ以外の場合は0を返す。

@code{__builtin_byte_in_set}関数には、ISA 3.0以降をサポートする64ビット環境が必要である。 この関数は、その@code{u}引数が、その64ビット@code{set}引数に含まれる8バイトのいずれかと正確に等しい場合に限り、非ゼロの値を返す。

@code{__builtin_byte_in_range}と@code{__builtin_byte_in_either_range}には、ISA 3.0以降をサポートする環境が必要である。 これらの2つの関数の場合、@code{range}引数は4バイトとしてエンコードされ、@code{hi_1:lo_1:hi_2:lo_2}として編成される。@code{__ builtin_byte_in_range}関数は、@code{u}引数が@code{lo_2}と@code{hi_2}の間の範囲内にある場合にのみ、ゼロ以外の値を返す。@code{__builtin_byte_in_either_range}関数は、その@code{u}引数が@code{lo_1}と@code{hi_1}の間（境界含む）の範囲か@code{lo_2}と@code {hi_2}の間（境界含む）の範囲内の範囲内にある場合に限り、非ゼロを返す。

@code{__builtin_dfp_dtstsfi_lt}関数は、@code{value}引数のsignificant桁数が@code {compare}引数よりも小さい場合にのみ、ゼロ以外の値を返す。 @code{__builtin_dfp_dtstsfi_lt_dd}関数と@code{__builtin_dfp_dtstsfi_lt_td}関数も同様に動作するが、@code{value}引数の型はそれぞれ@code{__ Decimal64}と@code{__ Decimal128}である必要がある。

@code{__builtin_dfp_dtstsfi_gt}関数は、@code{value}引数のsignificant桁数が@code{compare}引数より大きい場合にのみ、ゼロ以外の値を返す。 @code{__ builtin_dfp_dtstsfi_gt_dd}関数と@code{__ builtin_dfp_dtstsfi_gt_td}関数も同様に動作するが、@code{value}引数の型はそれぞれ@code{__Decimal64}と@code{__Decimal128}である必要がある。

@code{__builtin_dfp_dtstsfi_eq}関数は、@code{value}引数のsignificant桁数が@code{compare}引数と等しい場合にのみ、ゼロ以外の値を返す。 @code{__builtin_dfp_dtstsfi_eq_dd}関数と@code{__builtin_dfp_dtstsfi_eq_td}関数も同様に動作するが、@code{value}引数の型はそれぞれ@code{__Decimal64}と@code{__Decimal128}である必要がある。

@code{value}が@code{NaN}のエンコーディングのような@code{value}引数に未定義の有効数字がある場合に限り、@code{__builtin_dfp_dtstsfi_ov}関数はゼロ以外の値を返す。@code{__builtin_dfp_dtstsfi_ov_dd}関数と@code{__builtin_dfp_dtstsfi_ov_td}関数も同様に動作するが、@code{value}引数の型はそれぞれ@code{__Decimal64}と@code{__Decimal128}である必要がある。

次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 3.0以降（@option{-mcpu=power9}）からも利用できる。 これらの文字列関数は、関数のプロトタイプに近い記述をグループ化するために、別々に記述されている。
@smallexample
int vec_all_nez (vector signed char, vector signed char);
int vec_all_nez (vector unsigned char, vector unsigned char);
int vec_all_nez (vector signed short, vector signed short);
int vec_all_nez (vector unsigned short, vector unsigned short);
int vec_all_nez (vector signed int, vector signed int);
int vec_all_nez (vector unsigned int, vector unsigned int);

int vec_any_eqz (vector signed char, vector signed char);
int vec_any_eqz (vector unsigned char, vector unsigned char);
int vec_any_eqz (vector signed short, vector signed short);
int vec_any_eqz (vector unsigned short, vector unsigned short);
int vec_any_eqz (vector signed int, vector signed int);
int vec_any_eqz (vector unsigned int, vector unsigned int);

vector bool char vec_cmpnez (vector signed char arg1, vector signed char arg2);
vector bool char vec_cmpnez (vector unsigned char arg1, vector unsigned char arg2);
vector bool short vec_cmpnez (vector signed short arg1, vector signed short arg2);
vector bool short vec_cmpnez (vector unsigned short arg1, vector unsigned short arg2);
vector bool int vec_cmpnez (vector signed int arg1, vector signed int arg2);
vector bool int vec_cmpnez (vector unsigned int, vector unsigned int);

vector signed char vec_cnttz (vector signed char);
vector unsigned char vec_cnttz (vector unsigned char);
vector signed short vec_cnttz (vector signed short);
vector unsigned short vec_cnttz (vector unsigned short);
vector signed int vec_cnttz (vector signed int);
vector unsigned int vec_cnttz (vector unsigned int);
vector signed long long vec_cnttz (vector signed long long);
vector unsigned long long vec_cnttz (vector unsigned long long);

signed int vec_cntlz_lsbb (vector signed char);
signed int vec_cntlz_lsbb (vector unsigned char);

signed int vec_cnttz_lsbb (vector signed char);
signed int vec_cnttz_lsbb (vector unsigned char);

unsigned int vec_first_match_index (vector signed char, vector signed char);
unsigned int vec_first_match_index (vector unsigned char,
                                    vector unsigned char);
unsigned int vec_first_match_index (vector signed int, vector signed int);
unsigned int vec_first_match_index (vector unsigned int, vector unsigned int);
unsigned int vec_first_match_index (vector signed short, vector signed short);
unsigned int vec_first_match_index (vector unsigned short,
                                    vector unsigned short);
unsigned int vec_first_match_or_eos_index (vector signed char,
                                           vector signed char);
unsigned int vec_first_match_or_eos_index (vector unsigned char,
                                           vector unsigned char);
unsigned int vec_first_match_or_eos_index (vector signed int,
                                           vector signed int);
unsigned int vec_first_match_or_eos_index (vector unsigned int,
                                           vector unsigned int);
unsigned int vec_first_match_or_eos_index (vector signed short,
                                           vector signed short);
unsigned int vec_first_match_or_eos_index (vector unsigned short,
                                           vector unsigned short);
unsigned int vec_first_mismatch_index (vector signed char,
                                       vector signed char);
unsigned int vec_first_mismatch_index (vector unsigned char,
                                       vector unsigned char);
unsigned int vec_first_mismatch_index (vector signed int,
                                       vector signed int);
unsigned int vec_first_mismatch_index (vector unsigned int,
                                       vector unsigned int);
unsigned int vec_first_mismatch_index (vector signed short,
                                       vector signed short);
unsigned int vec_first_mismatch_index (vector unsigned short,
                                       vector unsigned short);
unsigned int vec_first_mismatch_or_eos_index (vector signed char,
                                              vector signed char);
unsigned int vec_first_mismatch_or_eos_index (vector unsigned char,
                                              vector unsigned char);
unsigned int vec_first_mismatch_or_eos_index (vector signed int,
                                              vector signed int);
unsigned int vec_first_mismatch_or_eos_index (vector unsigned int,
                                              vector unsigned int);
unsigned int vec_first_mismatch_or_eos_index (vector signed short,
                                              vector signed short);
unsigned int vec_first_mismatch_or_eos_index (vector unsigned short,
                                              vector unsigned short);

vector unsigned short vec_pack_to_short_fp32 (vector float, vector float);

vector signed char vec_xl_be (signed long long, signed char *);
vector unsigned char vec_xl_be (signed long long, unsigned char *);
vector signed int vec_xl_be (signed long long, signed int *);
vector unsigned int vec_xl_be (signed long long, unsigned int *);
vector signed __int128 vec_xl_be (signed long long, signed __int128 *);
vector unsigned __int128 vec_xl_be (signed long long, unsigned __int128 *);
vector signed long long vec_xl_be (signed long long, signed long long *);
vector unsigned long long vec_xl_be (signed long long, unsigned long long *);
vector signed short vec_xl_be (signed long long, signed short *);
vector unsigned short vec_xl_be (signed long long, unsigned short *);
vector double vec_xl_be (signed long long, double *);
vector float vec_xl_be (signed long long, float *);

vector signed char vec_xl_len (signed char *addr, size_t len);
vector unsigned char vec_xl_len (unsigned char *addr, size_t len);
vector signed int vec_xl_len (signed int *addr, size_t len);
vector unsigned int vec_xl_len (unsigned int *addr, size_t len);
vector signed __int128 vec_xl_len (signed __int128 *addr, size_t len);
vector unsigned __int128 vec_xl_len (unsigned __int128 *addr, size_t len);
vector signed long long vec_xl_len (signed long long *addr, size_t len);
vector unsigned long long vec_xl_len (unsigned long long *addr, size_t len);
vector signed short vec_xl_len (signed short *addr, size_t len);
vector unsigned short vec_xl_len (unsigned short *addr, size_t len);
vector double vec_xl_len (double *addr, size_t len);
vector float vec_xl_len (float *addr, size_t len);

vector unsigned char vec_xl_len_r (unsigned char *addr, size_t len);

void vec_xst_len (vector signed char data, signed char *addr, size_t len);
void vec_xst_len (vector unsigned char data, unsigned char *addr, size_t len);
void vec_xst_len (vector signed int data, signed int *addr, size_t len);
void vec_xst_len (vector unsigned int data, unsigned int *addr, size_t len);
void vec_xst_len (vector unsigned __int128 data, unsigned __int128 *addr, size_t len);
void vec_xst_len (vector signed long long data, signed long long *addr, size_t len);
void vec_xst_len (vector unsigned long long data, unsigned long long *addr, size_t len);
void vec_xst_len (vector signed short data, signed short *addr, size_t len);
void vec_xst_len (vector unsigned short data, unsigned short *addr, size_t len);
void vec_xst_len (vector signed __int128 data, signed __int128 *addr, size_t len);
void vec_xst_len (vector double data, double *addr, size_t len);
void vec_xst_len (vector float data, float *addr, size_t len);

void vec_xst_len_r (vector unsigned char data, unsigned char *addr, size_t len);

signed char vec_xlx (unsigned int index, vector signed char data);
unsigned char vec_xlx (unsigned int index, vector unsigned char data);
signed short vec_xlx (unsigned int index, vector signed short data);
unsigned short vec_xlx (unsigned int index, vector unsigned short data);
signed int vec_xlx (unsigned int index, vector signed int data);
unsigned int vec_xlx (unsigned int index, vector unsigned int data);
float vec_xlx (unsigned int index, vector float data);

signed char vec_xrx (unsigned int index, vector signed char data);
unsigned char vec_xrx (unsigned int index, vector unsigned char data);
signed short vec_xrx (unsigned int index, vector signed short data);
unsigned short vec_xrx (unsigned int index, vector unsigned short data);
signed int vec_xrx (unsigned int index, vector signed int data);
unsigned int vec_xrx (unsigned int index, vector unsigned int data);
float vec_xrx (unsigned int index, vector float data);
@end smallexample

@code{vec_all_nez}、@code{vec_any_eqz}、および@code{vec_cmpnez}は、2つのベクトル引数内の同じ位置にある要素間のペアごとの比較を実行する。@code{vec_all_nez}関数は、すべてのペアごとの比較が等しくなく、どちらかのベクトル引数の要素にゼロが含まれていない場合にのみ、ゼロ以外の値を返す。@code{vec_any_eqz}関数は、少なくとも1つのペアの比較が等しい場合、またはベクトル引数の少なくとも1つの要素にゼロが含まれている場合にのみ、ゼロ以外の値を返す。@code{vec_cmpnez}関数は、2つの引数と同じ型のベクトルを返し、各要素はすべての要素から構成され、入力引数の対応する要素が等しくないか、または対応する要素の少なくとも1つがゼロを含むことを示している。それ以外の場合、返されたベクトルの要素にはすべて0が含まれる。

@code{vec_cntlz_lsbb}関数は、最下位ビットがゼロに等しい連続する先頭バイト要素の数（指定されたベクトル引数内の位置0から始まる）の数を返す。 @code{vec_cnttz_lsbb}関数は、最下位ビットがゼロに等しい連続した後続のバイト要素の数（位置15から始まり、与えられたベクトル引数内で後方に数える）の数を返す。

@code{vec_xl_len}関数と@code{vec_xst_len}関数には、ISA 3.0以降をサポートする64ビット環境が必要である。@code{vec_xl_len}関数は、メモリから可変長ベクトルをロードする。@code{vec_xst_len}関数は可変長ベクトルをメモリに格納する。@code{vec_xl_len}と@code{vec_xst_len}の両方の関数では、@code{addr}引数は、データの転送先または転送元のメモリアドレスを表し、@code{len}引数は、 C式@code{min((len＆0xff), 16)}で計算されるように転送される。この式の値がベクトル要素のサイズの倍数でない場合、この関数の動作は未定義である。基底のコンピュータがビッグエンディアンモードで実行されるように構成されている場合、データ転送によってバイト0が対応するベクトルの@code{(len-1)}に移動する。リトルエンディアンモードでは、データ転送は、対応するベクトルのバイト@code {(16 - len)}を@code{15}に移動する。ロード関数の場合、メモリからロードされていない結果ベクトルのバイトはゼロに設定される。@code{addr}引数の値は、ベクトルの要素サイズの倍数に揃える必要はない。

@code{vec_xlx}関数と@code{vec_xrx}関数は、@code{index}引数で選択された単一要素を@code{data}引数で表されるベクトルから抽出する。 @code{index}引数は、ベクトル要素のサイズに関係なく、常にバイトオフセットを指定する。 @code{vec_xlx}の場合、@code{index}は抽出される要素の最初のバイトのオフセットである。 @code{vec_xrx}の場合、@code{index}は抽出される要素の最後のバイトを表し、ベクトルの右端から測定される。 つまり、抽出される要素の最後のバイトは@code {(15 - index)}の位置にある。@code{index}がベクトル要素のサイズの倍数である必要はない。 しかし、@code{index}に追加されたベクトル要素のサイズが15より大きい場合、返される値の内容は未定義である。

ハードウェア10進浮動小数点（@option{-mhard-dfp}）が利用可能な場合、次の組み込み関数をPowerPCファミリのプロセッサで使用できる。
@smallexample
long long __builtin_dxex (_Decimal64);
long long __builtin_dxexq (_Decimal128);
_Decimal64 __builtin_ddedpd (int, _Decimal64);
_Decimal128 __builtin_ddedpdq (int, _Decimal128);
_Decimal64 __builtin_denbcd (int, _Decimal64);
_Decimal128 __builtin_denbcdq (int, _Decimal128);
_Decimal64 __builtin_diex (long long, _Decimal64);
_Decimal128 _builtin_diexq (long long, _Decimal128);
_Decimal64 __builtin_dscli (_Decimal64, int);
_Decimal128 __builtin_dscliq (_Decimal128, int);
_Decimal64 __builtin_dscri (_Decimal64, int);
_Decimal128 __builtin_dscriq (_Decimal128, int);
unsigned long long __builtin_unpack_dec128 (_Decimal128, int);
_Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);
@end smallexample

ベクタスカラー（vsx）命令セットが使用可能な場合、PowerPCファミリプロセッサでは次の組み込み関数を使用できる。
@smallexample
unsigned long long __builtin_unpack_vector_int128 (vector __int128_t, int);
vector __int128_t __builtin_pack_vector_int128 (unsigned long long,
                                                unsigned long long);
@end smallexample

@node PowerPC AltiVec/VSX Built-in Functions
@subsection PowerPC AltiVec組み込み関数
GCCは、MotorolaのAltiVec Programming Interface Manualに記載されているAltiVecの操作にPowerPCファミリのプロセッサがアクセスするためのインタフェースを提供する。 このインタフェースは、@code{<altivec.h>}と@option{-maltivec}と@option{-mabi=altivec}を使用することで利用可能になる。 インタフェースは、以下のベクトル型をサポートしている。

@smallexample
vector unsigned char
vector signed char
vector bool char

vector unsigned short
vector signed short
vector bool short
vector pixel

vector unsigned int
vector signed int
vector bool int
vector float
@end smallexample

@option {-mvsx}を使用すると、以下の追加のベクトル型が実装される。

@smallexample
vector unsigned long
vector signed long
vector double
@end smallexample

long型は64ビットコード生成でのみ実装され、long型は浮動小数点/整数変換命令でのみ使用される。

GCCのCおよびC++コードからの高水準言語インターフェイスの実装は、Motorolaのドキュメントといくつかの点で異なる。

@itemize @bullet

@item
ベクトル定数は、中括弧内の定数式のリストである。

@item
ベクトル初期化子は、初期化する変数と同じ型のベクトル定数であればキャストは必要ない。

@item
@code{signed}または@code{unsigned}が省略されている場合、ベクタ型の符号の有無は、基本型のデフォルトの符号の有無である。 デフォルトはオペレーティングシステムによって異なるので、可搬性のあるプログラムでは必ず符号の有無を指定する必要がある。

@item
@option {-maltivec}でコンパイルすると、キーワード@code{__vector}、@code{vector}、@code{__pixel}、@code{pixel}、@code{__bool}、および@code{bool}が追加される。 ISO Cをコンパイルするとき、キーワード@code{vector}、@code{pixel}および@code{bool}の状況依存置換が無効になる。 それらを使用するには、代わりに@code{<altivec.h>}を含める必要がある。

@item
GCCでは、ベクタ型の型指定子として@code {typedef}名を使用できる。

@item
Cの場合、オーバーロードされた関数はマクロで実装されているため、次の関数は機能しない。

@smallexample
  vec_add ((vector signed int)@{1, 2, 3, 4@}, foo);
@end smallexample

@noindent
@code {vec_add}はマクロなので、この例のベクトル定数は4つの独立した引数として扱われる。 これを行うには、引数全体をカッコで囲む。
@end itemize

@emph{注意:} @code {<altivec.h>}インタフェースのみがサポートされている。 内部的には、GCCは前述のヘッダーファイルの機能を実現するための組み込み関数を使用するが、サポートされておらず、予告なしに変更されることがある。

GCCはOpenPOWER 64ビットELF V2 ABI仕様に準拠しており、これは@uref{http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html}でみつかる。このドキュメントの付録Aには、準拠したコンパイラによって提供されなければならないベクトルAPIインタフェースがリストされている。 プログラマは、そこに記載されたインタフェースを優先的に使用すべきである。しかし、歴史的に、GCCはベクトル命令へのアクセスのための追加のインタフェースを提供してきた。 以下、これらについて簡単に説明する。

以下のインターフェースは、一般的なAltiVec操作とAltiVec述部でサポートされている。 ジェネリックと特定のオペレーションの間に直接マッピングがある場合、特定のオペレーションも使用できるが、ジェネリック名のみがここに表示される。

@code{const int}として記述されている引数は、その操作に必要な範囲内のリテラル整数値を必要とする。

@smallexample
vector signed char vec_abs (vector signed char);
vector signed short vec_abs (vector signed short);
vector signed int vec_abs (vector signed int);
vector float vec_abs (vector float);

vector signed char vec_abss (vector signed char);
vector signed short vec_abss (vector signed short);
vector signed int vec_abss (vector signed int);

vector signed char vec_add (vector bool char, vector signed char);
vector signed char vec_add (vector signed char, vector bool char);
vector signed char vec_add (vector signed char, vector signed char);
vector unsigned char vec_add (vector bool char, vector unsigned char);
vector unsigned char vec_add (vector unsigned char, vector bool char);
vector unsigned char vec_add (vector unsigned char,
                              vector unsigned char);
vector signed short vec_add (vector bool short, vector signed short);
vector signed short vec_add (vector signed short, vector bool short);
vector signed short vec_add (vector signed short, vector signed short);
vector unsigned short vec_add (vector bool short,
                               vector unsigned short);
vector unsigned short vec_add (vector unsigned short,
                               vector bool short);
vector unsigned short vec_add (vector unsigned short,
                               vector unsigned short);
vector signed int vec_add (vector bool int, vector signed int);
vector signed int vec_add (vector signed int, vector bool int);
vector signed int vec_add (vector signed int, vector signed int);
vector unsigned int vec_add (vector bool int, vector unsigned int);
vector unsigned int vec_add (vector unsigned int, vector bool int);
vector unsigned int vec_add (vector unsigned int, vector unsigned int);
vector float vec_add (vector float, vector float);

vector float vec_vaddfp (vector float, vector float);

vector signed int vec_vadduwm (vector bool int, vector signed int);
vector signed int vec_vadduwm (vector signed int, vector bool int);
vector signed int vec_vadduwm (vector signed int, vector signed int);
vector unsigned int vec_vadduwm (vector bool int, vector unsigned int);
vector unsigned int vec_vadduwm (vector unsigned int, vector bool int);
vector unsigned int vec_vadduwm (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vadduhm (vector bool short,
                                 vector signed short);
vector signed short vec_vadduhm (vector signed short,
                                 vector bool short);
vector signed short vec_vadduhm (vector signed short,
                                 vector signed short);
vector unsigned short vec_vadduhm (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vadduhm (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vadduhm (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vaddubm (vector bool char, vector signed char);
vector signed char vec_vaddubm (vector signed char, vector bool char);
vector signed char vec_vaddubm (vector signed char, vector signed char);
vector unsigned char vec_vaddubm (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vaddubm (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vaddubm (vector unsigned char,
                                  vector unsigned char);

vector unsigned int vec_addc (vector unsigned int, vector unsigned int);

vector unsigned char vec_adds (vector bool char, vector unsigned char);
vector unsigned char vec_adds (vector unsigned char, vector bool char);
vector unsigned char vec_adds (vector unsigned char,
                               vector unsigned char);
vector signed char vec_adds (vector bool char, vector signed char);
vector signed char vec_adds (vector signed char, vector bool char);
vector signed char vec_adds (vector signed char, vector signed char);
vector unsigned short vec_adds (vector bool short,
                                vector unsigned short);
vector unsigned short vec_adds (vector unsigned short,
                                vector bool short);
vector unsigned short vec_adds (vector unsigned short,
                                vector unsigned short);
vector signed short vec_adds (vector bool short, vector signed short);
vector signed short vec_adds (vector signed short, vector bool short);
vector signed short vec_adds (vector signed short, vector signed short);
vector unsigned int vec_adds (vector bool int, vector unsigned int);
vector unsigned int vec_adds (vector unsigned int, vector bool int);
vector unsigned int vec_adds (vector unsigned int, vector unsigned int);
vector signed int vec_adds (vector bool int, vector signed int);
vector signed int vec_adds (vector signed int, vector bool int);
vector signed int vec_adds (vector signed int, vector signed int);

vector signed int vec_vaddsws (vector bool int, vector signed int);
vector signed int vec_vaddsws (vector signed int, vector bool int);
vector signed int vec_vaddsws (vector signed int, vector signed int);

vector unsigned int vec_vadduws (vector bool int, vector unsigned int);
vector unsigned int vec_vadduws (vector unsigned int, vector bool int);
vector unsigned int vec_vadduws (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vaddshs (vector bool short,
                                 vector signed short);
vector signed short vec_vaddshs (vector signed short,
                                 vector bool short);
vector signed short vec_vaddshs (vector signed short,
                                 vector signed short);

vector unsigned short vec_vadduhs (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vadduhs (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vadduhs (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vaddsbs (vector bool char, vector signed char);
vector signed char vec_vaddsbs (vector signed char, vector bool char);
vector signed char vec_vaddsbs (vector signed char, vector signed char);

vector unsigned char vec_vaddubs (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vaddubs (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vaddubs (vector unsigned char,
                                  vector unsigned char);

vector float vec_and (vector float, vector float);
vector float vec_and (vector float, vector bool int);
vector float vec_and (vector bool int, vector float);
vector bool long long vec_and (vector bool long long int,
                               vector bool long long);
vector bool int vec_and (vector bool int, vector bool int);
vector signed int vec_and (vector bool int, vector signed int);
vector signed int vec_and (vector signed int, vector bool int);
vector signed int vec_and (vector signed int, vector signed int);
vector unsigned int vec_and (vector bool int, vector unsigned int);
vector unsigned int vec_and (vector unsigned int, vector bool int);
vector unsigned int vec_and (vector unsigned int, vector unsigned int);
vector bool short vec_and (vector bool short, vector bool short);
vector signed short vec_and (vector bool short, vector signed short);
vector signed short vec_and (vector signed short, vector bool short);
vector signed short vec_and (vector signed short, vector signed short);
vector unsigned short vec_and (vector bool short,
                               vector unsigned short);
vector unsigned short vec_and (vector unsigned short,
                               vector bool short);
vector unsigned short vec_and (vector unsigned short,
                               vector unsigned short);
vector signed char vec_and (vector bool char, vector signed char);
vector bool char vec_and (vector bool char, vector bool char);
vector signed char vec_and (vector signed char, vector bool char);
vector signed char vec_and (vector signed char, vector signed char);
vector unsigned char vec_and (vector bool char, vector unsigned char);
vector unsigned char vec_and (vector unsigned char, vector bool char);
vector unsigned char vec_and (vector unsigned char,
                              vector unsigned char);

vector float vec_andc (vector float, vector float);
vector float vec_andc (vector float, vector bool int);
vector float vec_andc (vector bool int, vector float);
vector bool int vec_andc (vector bool int, vector bool int);
vector signed int vec_andc (vector bool int, vector signed int);
vector signed int vec_andc (vector signed int, vector bool int);
vector signed int vec_andc (vector signed int, vector signed int);
vector unsigned int vec_andc (vector bool int, vector unsigned int);
vector unsigned int vec_andc (vector unsigned int, vector bool int);
vector unsigned int vec_andc (vector unsigned int, vector unsigned int);
vector bool short vec_andc (vector bool short, vector bool short);
vector signed short vec_andc (vector bool short, vector signed short);
vector signed short vec_andc (vector signed short, vector bool short);
vector signed short vec_andc (vector signed short, vector signed short);
vector unsigned short vec_andc (vector bool short,
                                vector unsigned short);
vector unsigned short vec_andc (vector unsigned short,
                                vector bool short);
vector unsigned short vec_andc (vector unsigned short,
                                vector unsigned short);
vector signed char vec_andc (vector bool char, vector signed char);
vector bool char vec_andc (vector bool char, vector bool char);
vector signed char vec_andc (vector signed char, vector bool char);
vector signed char vec_andc (vector signed char, vector signed char);
vector unsigned char vec_andc (vector bool char, vector unsigned char);
vector unsigned char vec_andc (vector unsigned char, vector bool char);
vector unsigned char vec_andc (vector unsigned char,
                               vector unsigned char);

vector unsigned char vec_avg (vector unsigned char,
                              vector unsigned char);
vector signed char vec_avg (vector signed char, vector signed char);
vector unsigned short vec_avg (vector unsigned short,
                               vector unsigned short);
vector signed short vec_avg (vector signed short, vector signed short);
vector unsigned int vec_avg (vector unsigned int, vector unsigned int);
vector signed int vec_avg (vector signed int, vector signed int);

vector signed int vec_vavgsw (vector signed int, vector signed int);

vector unsigned int vec_vavguw (vector unsigned int,
                                vector unsigned int);

vector signed short vec_vavgsh (vector signed short,
                                vector signed short);

vector unsigned short vec_vavguh (vector unsigned short,
                                  vector unsigned short);

vector signed char vec_vavgsb (vector signed char, vector signed char);

vector unsigned char vec_vavgub (vector unsigned char,
                                 vector unsigned char);

vector float vec_copysign (vector float);

vector float vec_ceil (vector float);

vector signed int vec_cmpb (vector float, vector float);

vector bool char vec_cmpeq (vector bool char, vector bool char);
vector bool short vec_cmpeq (vector bool short, vector bool short);
vector bool int vec_cmpeq (vector bool int, vector bool int);
vector bool char vec_cmpeq (vector signed char, vector signed char);
vector bool char vec_cmpeq (vector unsigned char, vector unsigned char);
vector bool short vec_cmpeq (vector signed short, vector signed short);
vector bool short vec_cmpeq (vector unsigned short,
                             vector unsigned short);
vector bool int vec_cmpeq (vector signed int, vector signed int);
vector bool int vec_cmpeq (vector unsigned int, vector unsigned int);
vector bool int vec_cmpeq (vector float, vector float);

vector bool int vec_vcmpeqfp (vector float, vector float);

vector bool int vec_vcmpequw (vector signed int, vector signed int);
vector bool int vec_vcmpequw (vector unsigned int, vector unsigned int);

vector bool short vec_vcmpequh (vector signed short,
                                vector signed short);
vector bool short vec_vcmpequh (vector unsigned short,
                                vector unsigned short);

vector bool char vec_vcmpequb (vector signed char, vector signed char);
vector bool char vec_vcmpequb (vector unsigned char,
                               vector unsigned char);

vector bool int vec_cmpge (vector float, vector float);

vector bool char vec_cmpgt (vector unsigned char, vector unsigned char);
vector bool char vec_cmpgt (vector signed char, vector signed char);
vector bool short vec_cmpgt (vector unsigned short,
                             vector unsigned short);
vector bool short vec_cmpgt (vector signed short, vector signed short);
vector bool int vec_cmpgt (vector unsigned int, vector unsigned int);
vector bool int vec_cmpgt (vector signed int, vector signed int);
vector bool int vec_cmpgt (vector float, vector float);

vector bool int vec_vcmpgtfp (vector float, vector float);

vector bool int vec_vcmpgtsw (vector signed int, vector signed int);

vector bool int vec_vcmpgtuw (vector unsigned int, vector unsigned int);

vector bool short vec_vcmpgtsh (vector signed short,
                                vector signed short);

vector bool short vec_vcmpgtuh (vector unsigned short,
                                vector unsigned short);

vector bool char vec_vcmpgtsb (vector signed char, vector signed char);

vector bool char vec_vcmpgtub (vector unsigned char,
                               vector unsigned char);

vector bool int vec_cmple (vector float, vector float);

vector bool char vec_cmplt (vector unsigned char, vector unsigned char);
vector bool char vec_cmplt (vector signed char, vector signed char);
vector bool short vec_cmplt (vector unsigned short,
                             vector unsigned short);
vector bool short vec_cmplt (vector signed short, vector signed short);
vector bool int vec_cmplt (vector unsigned int, vector unsigned int);
vector bool int vec_cmplt (vector signed int, vector signed int);
vector bool int vec_cmplt (vector float, vector float);

vector float vec_cpsgn (vector float, vector float);

vector float vec_ctf (vector unsigned int, const int);
vector float vec_ctf (vector signed int, const int);
vector double vec_ctf (vector unsigned long, const int);
vector double vec_ctf (vector signed long, const int);

vector float vec_vcfsx (vector signed int, const int);

vector float vec_vcfux (vector unsigned int, const int);

vector signed int vec_cts (vector float, const int);
vector signed long vec_cts (vector double, const int);

vector unsigned int vec_ctu (vector float, const int);
vector unsigned long vec_ctu (vector double, const int);

vector double vec_doublee (vector float);
vector double vec_doublee (vector signed int);
vector double vec_doublee (vector unsigned int);

vector double vec_doubleo (vector float);
vector double vec_doubleo (vector signed int);
vector double vec_doubleo (vector unsigned int);

vector double vec_doubleh (vector float);
vector double vec_doubleh (vector signed int);
vector double vec_doubleh (vector unsigned int);

vector double vec_doublel (vector float);
vector double vec_doublel (vector signed int);
vector double vec_doublel (vector unsigned int);

void vec_dss (const int);

void vec_dssall (void);

void vec_dst (const vector unsigned char *, int, const int);
void vec_dst (const vector signed char *, int, const int);
void vec_dst (const vector bool char *, int, const int);
void vec_dst (const vector unsigned short *, int, const int);
void vec_dst (const vector signed short *, int, const int);
void vec_dst (const vector bool short *, int, const int);
void vec_dst (const vector pixel *, int, const int);
void vec_dst (const vector unsigned int *, int, const int);
void vec_dst (const vector signed int *, int, const int);
void vec_dst (const vector bool int *, int, const int);
void vec_dst (const vector float *, int, const int);
void vec_dst (const unsigned char *, int, const int);
void vec_dst (const signed char *, int, const int);
void vec_dst (const unsigned short *, int, const int);
void vec_dst (const short *, int, const int);
void vec_dst (const unsigned int *, int, const int);
void vec_dst (const int *, int, const int);
void vec_dst (const unsigned long *, int, const int);
void vec_dst (const long *, int, const int);
void vec_dst (const float *, int, const int);

void vec_dstst (const vector unsigned char *, int, const int);
void vec_dstst (const vector signed char *, int, const int);
void vec_dstst (const vector bool char *, int, const int);
void vec_dstst (const vector unsigned short *, int, const int);
void vec_dstst (const vector signed short *, int, const int);
void vec_dstst (const vector bool short *, int, const int);
void vec_dstst (const vector pixel *, int, const int);
void vec_dstst (const vector unsigned int *, int, const int);
void vec_dstst (const vector signed int *, int, const int);
void vec_dstst (const vector bool int *, int, const int);
void vec_dstst (const vector float *, int, const int);
void vec_dstst (const unsigned char *, int, const int);
void vec_dstst (const signed char *, int, const int);
void vec_dstst (const unsigned short *, int, const int);
void vec_dstst (const short *, int, const int);
void vec_dstst (const unsigned int *, int, const int);
void vec_dstst (const int *, int, const int);
void vec_dstst (const unsigned long *, int, const int);
void vec_dstst (const long *, int, const int);
void vec_dstst (const float *, int, const int);

void vec_dststt (const vector unsigned char *, int, const int);
void vec_dststt (const vector signed char *, int, const int);
void vec_dststt (const vector bool char *, int, const int);
void vec_dststt (const vector unsigned short *, int, const int);
void vec_dststt (const vector signed short *, int, const int);
void vec_dststt (const vector bool short *, int, const int);
void vec_dststt (const vector pixel *, int, const int);
void vec_dststt (const vector unsigned int *, int, const int);
void vec_dststt (const vector signed int *, int, const int);
void vec_dststt (const vector bool int *, int, const int);
void vec_dststt (const vector float *, int, const int);
void vec_dststt (const unsigned char *, int, const int);
void vec_dststt (const signed char *, int, const int);
void vec_dststt (const unsigned short *, int, const int);
void vec_dststt (const short *, int, const int);
void vec_dststt (const unsigned int *, int, const int);
void vec_dststt (const int *, int, const int);
void vec_dststt (const unsigned long *, int, const int);
void vec_dststt (const long *, int, const int);
void vec_dststt (const float *, int, const int);

void vec_dstt (const vector unsigned char *, int, const int);
void vec_dstt (const vector signed char *, int, const int);
void vec_dstt (const vector bool char *, int, const int);
void vec_dstt (const vector unsigned short *, int, const int);
void vec_dstt (const vector signed short *, int, const int);
void vec_dstt (const vector bool short *, int, const int);
void vec_dstt (const vector pixel *, int, const int);
void vec_dstt (const vector unsigned int *, int, const int);
void vec_dstt (const vector signed int *, int, const int);
void vec_dstt (const vector bool int *, int, const int);
void vec_dstt (const vector float *, int, const int);
void vec_dstt (const unsigned char *, int, const int);
void vec_dstt (const signed char *, int, const int);
void vec_dstt (const unsigned short *, int, const int);
void vec_dstt (const short *, int, const int);
void vec_dstt (const unsigned int *, int, const int);
void vec_dstt (const int *, int, const int);
void vec_dstt (const unsigned long *, int, const int);
void vec_dstt (const long *, int, const int);
void vec_dstt (const float *, int, const int);

vector float vec_expte (vector float);

vector float vec_floor (vector float);

vector float vec_float (vector signed int);
vector float vec_float (vector unsigned int);

vector float vec_float2 (vector signed long long, vector signed long long);
vector float vec_float2 (vector unsigned long long, vector signed long long);

vector float vec_floate (vector double);
vector float vec_floate (vector signed long long);
vector float vec_floate (vector unsigned long long);

vector float vec_floato (vector double);
vector float vec_floato (vector signed long long);
vector float vec_floato (vector unsigned long long);

vector float vec_ld (int, const vector float *);
vector float vec_ld (int, const float *);
vector bool int vec_ld (int, const vector bool int *);
vector signed int vec_ld (int, const vector signed int *);
vector signed int vec_ld (int, const int *);
vector signed int vec_ld (int, const long *);
vector unsigned int vec_ld (int, const vector unsigned int *);
vector unsigned int vec_ld (int, const unsigned int *);
vector unsigned int vec_ld (int, const unsigned long *);
vector bool short vec_ld (int, const vector bool short *);
vector pixel vec_ld (int, const vector pixel *);
vector signed short vec_ld (int, const vector signed short *);
vector signed short vec_ld (int, const short *);
vector unsigned short vec_ld (int, const vector unsigned short *);
vector unsigned short vec_ld (int, const unsigned short *);
vector bool char vec_ld (int, const vector bool char *);
vector signed char vec_ld (int, const vector signed char *);
vector signed char vec_ld (int, const signed char *);
vector unsigned char vec_ld (int, const vector unsigned char *);
vector unsigned char vec_ld (int, const unsigned char *);

vector signed char vec_lde (int, const signed char *);
vector unsigned char vec_lde (int, const unsigned char *);
vector signed short vec_lde (int, const short *);
vector unsigned short vec_lde (int, const unsigned short *);
vector float vec_lde (int, const float *);
vector signed int vec_lde (int, const int *);
vector unsigned int vec_lde (int, const unsigned int *);
vector signed int vec_lde (int, const long *);
vector unsigned int vec_lde (int, const unsigned long *);

vector float vec_lvewx (int, float *);
vector signed int vec_lvewx (int, int *);
vector unsigned int vec_lvewx (int, unsigned int *);
vector signed int vec_lvewx (int, long *);
vector unsigned int vec_lvewx (int, unsigned long *);

vector signed short vec_lvehx (int, short *);
vector unsigned short vec_lvehx (int, unsigned short *);

vector signed char vec_lvebx (int, char *);
vector unsigned char vec_lvebx (int, unsigned char *);

vector float vec_ldl (int, const vector float *);
vector float vec_ldl (int, const float *);
vector bool int vec_ldl (int, const vector bool int *);
vector signed int vec_ldl (int, const vector signed int *);
vector signed int vec_ldl (int, const int *);
vector signed int vec_ldl (int, const long *);
vector unsigned int vec_ldl (int, const vector unsigned int *);
vector unsigned int vec_ldl (int, const unsigned int *);
vector unsigned int vec_ldl (int, const unsigned long *);
vector bool short vec_ldl (int, const vector bool short *);
vector pixel vec_ldl (int, const vector pixel *);
vector signed short vec_ldl (int, const vector signed short *);
vector signed short vec_ldl (int, const short *);
vector unsigned short vec_ldl (int, const vector unsigned short *);
vector unsigned short vec_ldl (int, const unsigned short *);
vector bool char vec_ldl (int, const vector bool char *);
vector signed char vec_ldl (int, const vector signed char *);
vector signed char vec_ldl (int, const signed char *);
vector unsigned char vec_ldl (int, const vector unsigned char *);
vector unsigned char vec_ldl (int, const unsigned char *);

vector float vec_loge (vector float);

vector unsigned char vec_lvsl (int, const volatile unsigned char *);
vector unsigned char vec_lvsl (int, const volatile signed char *);
vector unsigned char vec_lvsl (int, const volatile unsigned short *);
vector unsigned char vec_lvsl (int, const volatile short *);
vector unsigned char vec_lvsl (int, const volatile unsigned int *);
vector unsigned char vec_lvsl (int, const volatile int *);
vector unsigned char vec_lvsl (int, const volatile unsigned long *);
vector unsigned char vec_lvsl (int, const volatile long *);
vector unsigned char vec_lvsl (int, const volatile float *);

vector unsigned char vec_lvsr (int, const volatile unsigned char *);
vector unsigned char vec_lvsr (int, const volatile signed char *);
vector unsigned char vec_lvsr (int, const volatile unsigned short *);
vector unsigned char vec_lvsr (int, const volatile short *);
vector unsigned char vec_lvsr (int, const volatile unsigned int *);
vector unsigned char vec_lvsr (int, const volatile int *);
vector unsigned char vec_lvsr (int, const volatile unsigned long *);
vector unsigned char vec_lvsr (int, const volatile long *);
vector unsigned char vec_lvsr (int, const volatile float *);

vector float vec_madd (vector float, vector float, vector float);

vector signed short vec_madds (vector signed short,
                               vector signed short,
                               vector signed short);

vector unsigned char vec_max (vector bool char, vector unsigned char);
vector unsigned char vec_max (vector unsigned char, vector bool char);
vector unsigned char vec_max (vector unsigned char,
                              vector unsigned char);
vector signed char vec_max (vector bool char, vector signed char);
vector signed char vec_max (vector signed char, vector bool char);
vector signed char vec_max (vector signed char, vector signed char);
vector unsigned short vec_max (vector bool short,
                               vector unsigned short);
vector unsigned short vec_max (vector unsigned short,
                               vector bool short);
vector unsigned short vec_max (vector unsigned short,
                               vector unsigned short);
vector signed short vec_max (vector bool short, vector signed short);
vector signed short vec_max (vector signed short, vector bool short);
vector signed short vec_max (vector signed short, vector signed short);
vector unsigned int vec_max (vector bool int, vector unsigned int);
vector unsigned int vec_max (vector unsigned int, vector bool int);
vector unsigned int vec_max (vector unsigned int, vector unsigned int);
vector signed int vec_max (vector bool int, vector signed int);
vector signed int vec_max (vector signed int, vector bool int);
vector signed int vec_max (vector signed int, vector signed int);
vector float vec_max (vector float, vector float);

vector float vec_vmaxfp (vector float, vector float);

vector signed int vec_vmaxsw (vector bool int, vector signed int);
vector signed int vec_vmaxsw (vector signed int, vector bool int);
vector signed int vec_vmaxsw (vector signed int, vector signed int);

vector unsigned int vec_vmaxuw (vector bool int, vector unsigned int);
vector unsigned int vec_vmaxuw (vector unsigned int, vector bool int);
vector unsigned int vec_vmaxuw (vector unsigned int,
                                vector unsigned int);

vector signed short vec_vmaxsh (vector bool short, vector signed short);
vector signed short vec_vmaxsh (vector signed short, vector bool short);
vector signed short vec_vmaxsh (vector signed short,
                                vector signed short);

vector unsigned short vec_vmaxuh (vector bool short,
                                  vector unsigned short);
vector unsigned short vec_vmaxuh (vector unsigned short,
                                  vector bool short);
vector unsigned short vec_vmaxuh (vector unsigned short,
                                  vector unsigned short);

vector signed char vec_vmaxsb (vector bool char, vector signed char);
vector signed char vec_vmaxsb (vector signed char, vector bool char);
vector signed char vec_vmaxsb (vector signed char, vector signed char);

vector unsigned char vec_vmaxub (vector bool char,
                                 vector unsigned char);
vector unsigned char vec_vmaxub (vector unsigned char,
                                 vector bool char);
vector unsigned char vec_vmaxub (vector unsigned char,
                                 vector unsigned char);

vector bool char vec_mergeh (vector bool char, vector bool char);
vector signed char vec_mergeh (vector signed char, vector signed char);
vector unsigned char vec_mergeh (vector unsigned char,
                                 vector unsigned char);
vector bool short vec_mergeh (vector bool short, vector bool short);
vector pixel vec_mergeh (vector pixel, vector pixel);
vector signed short vec_mergeh (vector signed short,
                                vector signed short);
vector unsigned short vec_mergeh (vector unsigned short,
                                  vector unsigned short);
vector float vec_mergeh (vector float, vector float);
vector bool int vec_mergeh (vector bool int, vector bool int);
vector signed int vec_mergeh (vector signed int, vector signed int);
vector unsigned int vec_mergeh (vector unsigned int,
                                vector unsigned int);

vector float vec_vmrghw (vector float, vector float);
vector bool int vec_vmrghw (vector bool int, vector bool int);
vector signed int vec_vmrghw (vector signed int, vector signed int);
vector unsigned int vec_vmrghw (vector unsigned int,
                                vector unsigned int);

vector bool short vec_vmrghh (vector bool short, vector bool short);
vector signed short vec_vmrghh (vector signed short,
                                vector signed short);
vector unsigned short vec_vmrghh (vector unsigned short,
                                  vector unsigned short);
vector pixel vec_vmrghh (vector pixel, vector pixel);

vector bool char vec_vmrghb (vector bool char, vector bool char);
vector signed char vec_vmrghb (vector signed char, vector signed char);
vector unsigned char vec_vmrghb (vector unsigned char,
                                 vector unsigned char);

vector bool char vec_mergel (vector bool char, vector bool char);
vector signed char vec_mergel (vector signed char, vector signed char);
vector unsigned char vec_mergel (vector unsigned char,
                                 vector unsigned char);
vector bool short vec_mergel (vector bool short, vector bool short);
vector pixel vec_mergel (vector pixel, vector pixel);
vector signed short vec_mergel (vector signed short,
                                vector signed short);
vector unsigned short vec_mergel (vector unsigned short,
                                  vector unsigned short);
vector float vec_mergel (vector float, vector float);
vector bool int vec_mergel (vector bool int, vector bool int);
vector signed int vec_mergel (vector signed int, vector signed int);
vector unsigned int vec_mergel (vector unsigned int,
                                vector unsigned int);

vector float vec_vmrglw (vector float, vector float);
vector signed int vec_vmrglw (vector signed int, vector signed int);
vector unsigned int vec_vmrglw (vector unsigned int,
                                vector unsigned int);
vector bool int vec_vmrglw (vector bool int, vector bool int);

vector bool short vec_vmrglh (vector bool short, vector bool short);
vector signed short vec_vmrglh (vector signed short,
                                vector signed short);
vector unsigned short vec_vmrglh (vector unsigned short,
                                  vector unsigned short);
vector pixel vec_vmrglh (vector pixel, vector pixel);

vector bool char vec_vmrglb (vector bool char, vector bool char);
vector signed char vec_vmrglb (vector signed char, vector signed char);
vector unsigned char vec_vmrglb (vector unsigned char,
                                 vector unsigned char);

vector unsigned short vec_mfvscr (void);

vector unsigned char vec_min (vector bool char, vector unsigned char);
vector unsigned char vec_min (vector unsigned char, vector bool char);
vector unsigned char vec_min (vector unsigned char,
                              vector unsigned char);
vector signed char vec_min (vector bool char, vector signed char);
vector signed char vec_min (vector signed char, vector bool char);
vector signed char vec_min (vector signed char, vector signed char);
vector unsigned short vec_min (vector bool short,
                               vector unsigned short);
vector unsigned short vec_min (vector unsigned short,
                               vector bool short);
vector unsigned short vec_min (vector unsigned short,
                               vector unsigned short);
vector signed short vec_min (vector bool short, vector signed short);
vector signed short vec_min (vector signed short, vector bool short);
vector signed short vec_min (vector signed short, vector signed short);
vector unsigned int vec_min (vector bool int, vector unsigned int);
vector unsigned int vec_min (vector unsigned int, vector bool int);
vector unsigned int vec_min (vector unsigned int, vector unsigned int);
vector signed int vec_min (vector bool int, vector signed int);
vector signed int vec_min (vector signed int, vector bool int);
vector signed int vec_min (vector signed int, vector signed int);
vector float vec_min (vector float, vector float);

vector float vec_vminfp (vector float, vector float);

vector signed int vec_vminsw (vector bool int, vector signed int);
vector signed int vec_vminsw (vector signed int, vector bool int);
vector signed int vec_vminsw (vector signed int, vector signed int);

vector unsigned int vec_vminuw (vector bool int, vector unsigned int);
vector unsigned int vec_vminuw (vector unsigned int, vector bool int);
vector unsigned int vec_vminuw (vector unsigned int,
                                vector unsigned int);

vector signed short vec_vminsh (vector bool short, vector signed short);
vector signed short vec_vminsh (vector signed short, vector bool short);
vector signed short vec_vminsh (vector signed short,
                                vector signed short);

vector unsigned short vec_vminuh (vector bool short,
                                  vector unsigned short);
vector unsigned short vec_vminuh (vector unsigned short,
                                  vector bool short);
vector unsigned short vec_vminuh (vector unsigned short,
                                  vector unsigned short);

vector signed char vec_vminsb (vector bool char, vector signed char);
vector signed char vec_vminsb (vector signed char, vector bool char);
vector signed char vec_vminsb (vector signed char, vector signed char);

vector unsigned char vec_vminub (vector bool char,
                                 vector unsigned char);
vector unsigned char vec_vminub (vector unsigned char,
                                 vector bool char);
vector unsigned char vec_vminub (vector unsigned char,
                                 vector unsigned char);

vector signed short vec_mladd (vector signed short,
                               vector signed short,
                               vector signed short);
vector signed short vec_mladd (vector signed short,
                               vector unsigned short,
                               vector unsigned short);
vector signed short vec_mladd (vector unsigned short,
                               vector signed short,
                               vector signed short);
vector unsigned short vec_mladd (vector unsigned short,
                                 vector unsigned short,
                                 vector unsigned short);

vector signed short vec_mradds (vector signed short,
                                vector signed short,
                                vector signed short);

vector unsigned int vec_msum (vector unsigned char,
                              vector unsigned char,
                              vector unsigned int);
vector signed int vec_msum (vector signed char,
                            vector unsigned char,
                            vector signed int);
vector unsigned int vec_msum (vector unsigned short,
                              vector unsigned short,
                              vector unsigned int);
vector signed int vec_msum (vector signed short,
                            vector signed short,
                            vector signed int);

vector signed int vec_vmsumshm (vector signed short,
                                vector signed short,
                                vector signed int);

vector unsigned int vec_vmsumuhm (vector unsigned short,
                                  vector unsigned short,
                                  vector unsigned int);

vector signed int vec_vmsummbm (vector signed char,
                                vector unsigned char,
                                vector signed int);

vector unsigned int vec_vmsumubm (vector unsigned char,
                                  vector unsigned char,
                                  vector unsigned int);

vector unsigned int vec_msums (vector unsigned short,
                               vector unsigned short,
                               vector unsigned int);
vector signed int vec_msums (vector signed short,
                             vector signed short,
                             vector signed int);

vector signed int vec_vmsumshs (vector signed short,
                                vector signed short,
                                vector signed int);

vector unsigned int vec_vmsumuhs (vector unsigned short,
                                  vector unsigned short,
                                  vector unsigned int);

void vec_mtvscr (vector signed int);
void vec_mtvscr (vector unsigned int);
void vec_mtvscr (vector bool int);
void vec_mtvscr (vector signed short);
void vec_mtvscr (vector unsigned short);
void vec_mtvscr (vector bool short);
void vec_mtvscr (vector pixel);
void vec_mtvscr (vector signed char);
void vec_mtvscr (vector unsigned char);
void vec_mtvscr (vector bool char);

vector unsigned short vec_mule (vector unsigned char,
                                vector unsigned char);
vector signed short vec_mule (vector signed char,
                              vector signed char);
vector unsigned int vec_mule (vector unsigned short,
                              vector unsigned short);
vector signed int vec_mule (vector signed short, vector signed short);
vector unsigned long long vec_mule (vector unsigned int,
                                    vector unsigned int);
vector signed long long vec_mule (vector signed int,
                                  vector signed int);

vector signed int vec_vmulesh (vector signed short,
                               vector signed short);

vector unsigned int vec_vmuleuh (vector unsigned short,
                                 vector unsigned short);

vector signed short vec_vmulesb (vector signed char,
                                 vector signed char);

vector unsigned short vec_vmuleub (vector unsigned char,
                                  vector unsigned char);

vector unsigned short vec_mulo (vector unsigned char,
                                vector unsigned char);
vector signed short vec_mulo (vector signed char, vector signed char);
vector unsigned int vec_mulo (vector unsigned short,
                              vector unsigned short);
vector signed int vec_mulo (vector signed short, vector signed short);
vector unsigned long long vec_mulo (vector unsigned int,
                                    vector unsigned int);
vector signed long long vec_mulo (vector signed int,
                                  vector signed int);

vector signed int vec_vmulosh (vector signed short,
                               vector signed short);

vector unsigned int vec_vmulouh (vector unsigned short,
                                 vector unsigned short);

vector signed short vec_vmulosb (vector signed char,
                                 vector signed char);

vector unsigned short vec_vmuloub (vector unsigned char,
                                   vector unsigned char);

vector float vec_nmsub (vector float, vector float, vector float);

vector signed char vec_nabs (vector signed char);
vector signed short vec_nabs (vector signed short);
vector signed int vec_nabs (vector signed int);
vector float vec_nabs (vector float);
vector double vec_nabs (vector double);

vector signed char vec_neg (vector signed char);
vector signed short vec_neg (vector signed short);
vector signed int vec_neg (vector signed int);
vector signed long long vec_neg (vector signed long long);
vector float  char vec_neg (vector float);
vector double vec_neg (vector double);

vector float vec_nor (vector float, vector float);
vector signed int vec_nor (vector signed int, vector signed int);
vector unsigned int vec_nor (vector unsigned int, vector unsigned int);
vector bool int vec_nor (vector bool int, vector bool int);
vector signed short vec_nor (vector signed short, vector signed short);
vector unsigned short vec_nor (vector unsigned short,
                               vector unsigned short);
vector bool short vec_nor (vector bool short, vector bool short);
vector signed char vec_nor (vector signed char, vector signed char);
vector unsigned char vec_nor (vector unsigned char,
                              vector unsigned char);
vector bool char vec_nor (vector bool char, vector bool char);

vector float vec_or (vector float, vector float);
vector float vec_or (vector float, vector bool int);
vector float vec_or (vector bool int, vector float);
vector bool int vec_or (vector bool int, vector bool int);
vector signed int vec_or (vector bool int, vector signed int);
vector signed int vec_or (vector signed int, vector bool int);
vector signed int vec_or (vector signed int, vector signed int);
vector unsigned int vec_or (vector bool int, vector unsigned int);
vector unsigned int vec_or (vector unsigned int, vector bool int);
vector unsigned int vec_or (vector unsigned int, vector unsigned int);
vector bool short vec_or (vector bool short, vector bool short);
vector signed short vec_or (vector bool short, vector signed short);
vector signed short vec_or (vector signed short, vector bool short);
vector signed short vec_or (vector signed short, vector signed short);
vector unsigned short vec_or (vector bool short, vector unsigned short);
vector unsigned short vec_or (vector unsigned short, vector bool short);
vector unsigned short vec_or (vector unsigned short,
                              vector unsigned short);
vector signed char vec_or (vector bool char, vector signed char);
vector bool char vec_or (vector bool char, vector bool char);
vector signed char vec_or (vector signed char, vector bool char);
vector signed char vec_or (vector signed char, vector signed char);
vector unsigned char vec_or (vector bool char, vector unsigned char);
vector unsigned char vec_or (vector unsigned char, vector bool char);
vector unsigned char vec_or (vector unsigned char,
                             vector unsigned char);

vector signed char vec_pack (vector signed short, vector signed short);
vector unsigned char vec_pack (vector unsigned short,
                               vector unsigned short);
vector bool char vec_pack (vector bool short, vector bool short);
vector signed short vec_pack (vector signed int, vector signed int);
vector unsigned short vec_pack (vector unsigned int,
                                vector unsigned int);
vector bool short vec_pack (vector bool int, vector bool int);

vector bool short vec_vpkuwum (vector bool int, vector bool int);
vector signed short vec_vpkuwum (vector signed int, vector signed int);
vector unsigned short vec_vpkuwum (vector unsigned int,
                                   vector unsigned int);

vector bool char vec_vpkuhum (vector bool short, vector bool short);
vector signed char vec_vpkuhum (vector signed short,
                                vector signed short);
vector unsigned char vec_vpkuhum (vector unsigned short,
                                  vector unsigned short);

vector pixel vec_packpx (vector unsigned int, vector unsigned int);

vector unsigned char vec_packs (vector unsigned short,
                                vector unsigned short);
vector signed char vec_packs (vector signed short, vector signed short);
vector unsigned short vec_packs (vector unsigned int,
                                 vector unsigned int);
vector signed short vec_packs (vector signed int, vector signed int);

vector signed short vec_vpkswss (vector signed int, vector signed int);

vector unsigned short vec_vpkuwus (vector unsigned int,
                                   vector unsigned int);

vector signed char vec_vpkshss (vector signed short,
                                vector signed short);

vector unsigned char vec_vpkuhus (vector unsigned short,
                                  vector unsigned short);

vector unsigned char vec_packsu (vector unsigned short,
                                 vector unsigned short);
vector unsigned char vec_packsu (vector signed short,
                                 vector signed short);
vector unsigned short vec_packsu (vector unsigned int,
                                  vector unsigned int);
vector unsigned short vec_packsu (vector signed int, vector signed int);

vector unsigned short vec_vpkswus (vector signed int,
                                   vector signed int);

vector unsigned char vec_vpkshus (vector signed short,
                                  vector signed short);

vector float vec_perm (vector float,
                       vector float,
                       vector unsigned char);
vector signed int vec_perm (vector signed int,
                            vector signed int,
                            vector unsigned char);
vector unsigned int vec_perm (vector unsigned int,
                              vector unsigned int,
                              vector unsigned char);
vector bool int vec_perm (vector bool int,
                          vector bool int,
                          vector unsigned char);
vector signed short vec_perm (vector signed short,
                              vector signed short,
                              vector unsigned char);
vector unsigned short vec_perm (vector unsigned short,
                                vector unsigned short,
                                vector unsigned char);
vector bool short vec_perm (vector bool short,
                            vector bool short,
                            vector unsigned char);
vector pixel vec_perm (vector pixel,
                       vector pixel,
                       vector unsigned char);
vector signed char vec_perm (vector signed char,
                             vector signed char,
                             vector unsigned char);
vector unsigned char vec_perm (vector unsigned char,
                               vector unsigned char,
                               vector unsigned char);
vector bool char vec_perm (vector bool char,
                           vector bool char,
                           vector unsigned char);

vector float vec_re (vector float);

vector bool char vec_reve (vector bool char);
vector signed char vec_reve (vector signed char);
vector unsigned char vec_reve (vector unsigned char);
vector bool int vec_reve (vector bool int);
vector signed int vec_reve (vector signed int);
vector unsigned int vec_reve (vector unsigned int);
vector bool long long vec_reve (vector bool long long);
vector signed long long vec_reve (vector signed long long);
vector unsigned long long vec_reve (vector unsigned long long);
vector bool short vec_reve (vector bool short);
vector signed short vec_reve (vector signed short);
vector unsigned short vec_reve (vector unsigned short);

vector signed char vec_rl (vector signed char,
                           vector unsigned char);
vector unsigned char vec_rl (vector unsigned char,
                             vector unsigned char);
vector signed short vec_rl (vector signed short, vector unsigned short);
vector unsigned short vec_rl (vector unsigned short,
                              vector unsigned short);
vector signed int vec_rl (vector signed int, vector unsigned int);
vector unsigned int vec_rl (vector unsigned int, vector unsigned int);

vector signed int vec_vrlw (vector signed int, vector unsigned int);
vector unsigned int vec_vrlw (vector unsigned int, vector unsigned int);

vector signed short vec_vrlh (vector signed short,
                              vector unsigned short);
vector unsigned short vec_vrlh (vector unsigned short,
                                vector unsigned short);

vector signed char vec_vrlb (vector signed char, vector unsigned char);
vector unsigned char vec_vrlb (vector unsigned char,
                               vector unsigned char);

vector float vec_round (vector float);

vector float vec_recip (vector float, vector float);

vector float vec_rsqrt (vector float);

vector float vec_rsqrte (vector float);

vector float vec_sel (vector float, vector float, vector bool int);
vector float vec_sel (vector float, vector float, vector unsigned int);
vector signed int vec_sel (vector signed int,
                           vector signed int,
                           vector bool int);
vector signed int vec_sel (vector signed int,
                           vector signed int,
                           vector unsigned int);
vector unsigned int vec_sel (vector unsigned int,
                             vector unsigned int,
                             vector bool int);
vector unsigned int vec_sel (vector unsigned int,
                             vector unsigned int,
                             vector unsigned int);
vector bool int vec_sel (vector bool int,
                         vector bool int,
                         vector bool int);
vector bool int vec_sel (vector bool int,
                         vector bool int,
                         vector unsigned int);
vector signed short vec_sel (vector signed short,
                             vector signed short,
                             vector bool short);
vector signed short vec_sel (vector signed short,
                             vector signed short,
                             vector unsigned short);
vector unsigned short vec_sel (vector unsigned short,
                               vector unsigned short,
                               vector bool short);
vector unsigned short vec_sel (vector unsigned short,
                               vector unsigned short,
                               vector unsigned short);
vector bool short vec_sel (vector bool short,
                           vector bool short,
                           vector bool short);
vector bool short vec_sel (vector bool short,
                           vector bool short,
                           vector unsigned short);
vector signed char vec_sel (vector signed char,
                            vector signed char,
                            vector bool char);
vector signed char vec_sel (vector signed char,
                            vector signed char,
                            vector unsigned char);
vector unsigned char vec_sel (vector unsigned char,
                              vector unsigned char,
                              vector bool char);
vector unsigned char vec_sel (vector unsigned char,
                              vector unsigned char,
                              vector unsigned char);
vector bool char vec_sel (vector bool char,
                          vector bool char,
                          vector bool char);
vector bool char vec_sel (vector bool char,
                          vector bool char,
                          vector unsigned char);

vector signed long long vec_signed (vector double);
vector signed int vec_signed (vector float);

vector signed int vec_signede (vector double);
vector signed int vec_signedo (vector double);
vector signed int vec_signed2 (vector double, vector double);

vector signed char vec_sl (vector signed char,
                           vector unsigned char);
vector unsigned char vec_sl (vector unsigned char,
                             vector unsigned char);
vector signed short vec_sl (vector signed short, vector unsigned short);
vector unsigned short vec_sl (vector unsigned short,
                              vector unsigned short);
vector signed int vec_sl (vector signed int, vector unsigned int);
vector unsigned int vec_sl (vector unsigned int, vector unsigned int);

vector signed int vec_vslw (vector signed int, vector unsigned int);
vector unsigned int vec_vslw (vector unsigned int, vector unsigned int);

vector signed short vec_vslh (vector signed short,
                              vector unsigned short);
vector unsigned short vec_vslh (vector unsigned short,
                                vector unsigned short);

vector signed char vec_vslb (vector signed char, vector unsigned char);
vector unsigned char vec_vslb (vector unsigned char,
                               vector unsigned char);

vector float vec_sld (vector float, vector float, const int);
vector double vec_sld (vector double, vector double, const int);

vector signed int vec_sld (vector signed int,
                           vector signed int,
                           const int);
vector unsigned int vec_sld (vector unsigned int,
                             vector unsigned int,
                             const int);
vector bool int vec_sld (vector bool int,
                         vector bool int,
                         const int);
vector signed short vec_sld (vector signed short,
                             vector signed short,
                             const int);
vector unsigned short vec_sld (vector unsigned short,
                               vector unsigned short,
                               const int);
vector bool short vec_sld (vector bool short,
                           vector bool short,
                           const int);
vector pixel vec_sld (vector pixel,
                      vector pixel,
                      const int);
vector signed char vec_sld (vector signed char,
                            vector signed char,
                            const int);
vector unsigned char vec_sld (vector unsigned char,
                              vector unsigned char,
                              const int);
vector bool char vec_sld (vector bool char,
                          vector bool char,
                          const int);
vector bool long long int vec_sld (vector bool long long int,
                                   vector bool long long int, const int);
vector long long int vec_sld (vector long long int,
                              vector  long long int, const int);
vector unsigned long long int vec_sld (vector unsigned long long int,
                                       vector unsigned long long int,
                                       const int);

vector signed char vec_sldw (vector signed char,
                             vector signed char,
                             const int);
vector unsigned char vec_sldw (vector unsigned char,
                               vector unsigned char,
                               const int);
vector signed short vec_sldw (vector signed short,
                              vector signed short,
                              const int);
vector unsigned short vec_sldw (vector unsigned short,
                                vector unsigned short,
                                const int);
vector signed int vec_sldw (vector signed int,
                            vector signed int,
                            const int);
vector unsigned int vec_sldw (vector unsigned int,
                              vector unsigned int,
                              const int);
vector signed long long vec_sldw (vector signed long long,
                                  vector signed long long,
                                  const int);
vector unsigned long long vec_sldw (vector unsigned long long,
                                    vector unsigned long long,
                                    const int);

vector signed int vec_sll (vector signed int,
                           vector unsigned int);
vector signed int vec_sll (vector signed int,
                           vector unsigned short);
vector signed int vec_sll (vector signed int,
                           vector unsigned char);
vector unsigned int vec_sll (vector unsigned int,
                             vector unsigned int);
vector unsigned int vec_sll (vector unsigned int,
                             vector unsigned short);
vector unsigned int vec_sll (vector unsigned int,
                             vector unsigned char);
vector bool int vec_sll (vector bool int,
                         vector unsigned int);
vector bool int vec_sll (vector bool int,
                         vector unsigned short);
vector bool int vec_sll (vector bool int,
                         vector unsigned char);
vector signed short vec_sll (vector signed short,
                             vector unsigned int);
vector signed short vec_sll (vector signed short,
                             vector unsigned short);
vector signed short vec_sll (vector signed short,
                             vector unsigned char);
vector unsigned short vec_sll (vector unsigned short,
                               vector unsigned int);
vector unsigned short vec_sll (vector unsigned short,
                               vector unsigned short);
vector unsigned short vec_sll (vector unsigned short,
                               vector unsigned char);
vector long long int vec_sll (vector long long int,
                              vector unsigned char);
vector unsigned long long int vec_sll (vector unsigned long long int,
                                       vector unsigned char);
vector bool short vec_sll (vector bool short, vector unsigned int);
vector bool short vec_sll (vector bool short, vector unsigned short);
vector bool short vec_sll (vector bool short, vector unsigned char);
vector pixel vec_sll (vector pixel, vector unsigned int);
vector pixel vec_sll (vector pixel, vector unsigned short);
vector pixel vec_sll (vector pixel, vector unsigned char);
vector signed char vec_sll (vector signed char, vector unsigned int);
vector signed char vec_sll (vector signed char, vector unsigned short);
vector signed char vec_sll (vector signed char, vector unsigned char);
vector unsigned char vec_sll (vector unsigned char,
                              vector unsigned int);
vector unsigned char vec_sll (vector unsigned char,
                              vector unsigned short);
vector unsigned char vec_sll (vector unsigned char,
                              vector unsigned char);
vector bool char vec_sll (vector bool char, vector unsigned int);
vector bool char vec_sll (vector bool char, vector unsigned short);
vector bool char vec_sll (vector bool char, vector unsigned char);

vector float vec_slo (vector float, vector signed char);
vector float vec_slo (vector float, vector unsigned char);
vector signed int vec_slo (vector signed int, vector signed char);
vector signed int vec_slo (vector signed int, vector unsigned char);
vector unsigned int vec_slo (vector unsigned int, vector signed char);
vector unsigned int vec_slo (vector unsigned int, vector unsigned char);
vector signed short vec_slo (vector signed short, vector signed char);
vector signed short vec_slo (vector signed short, vector unsigned char);
vector unsigned short vec_slo (vector unsigned short,
                               vector signed char);
vector unsigned short vec_slo (vector unsigned short,
                               vector unsigned char);
vector pixel vec_slo (vector pixel, vector signed char);
vector pixel vec_slo (vector pixel, vector unsigned char);
vector signed char vec_slo (vector signed char, vector signed char);
vector signed char vec_slo (vector signed char, vector unsigned char);
vector unsigned char vec_slo (vector unsigned char, vector signed char);
vector unsigned char vec_slo (vector unsigned char,
                              vector unsigned char);
vector signed long long vec_slo (vector signed long long, vector signed char);
vector signed long long vec_slo (vector signed long long, vector unsigned char);
vector unsigned long long vec_slo (vector unsigned long long, vector signed char);
vector unsigned long long vec_slo (vector unsigned long long, vector unsigned char);

vector signed char vec_splat (vector signed char, const int);
vector unsigned char vec_splat (vector unsigned char, const int);
vector bool char vec_splat (vector bool char, const int);
vector signed short vec_splat (vector signed short, const int);
vector unsigned short vec_splat (vector unsigned short, const int);
vector bool short vec_splat (vector bool short, const int);
vector pixel vec_splat (vector pixel, const int);
vector float vec_splat (vector float, const int);
vector signed int vec_splat (vector signed int, const int);
vector unsigned int vec_splat (vector unsigned int, const int);
vector bool int vec_splat (vector bool int, const int);
vector signed long vec_splat (vector signed long, const int);
vector unsigned long vec_splat (vector unsigned long, const int);

vector signed char vec_splats (signed char);
vector unsigned char vec_splats (unsigned char);
vector signed short vec_splats (signed short);
vector unsigned short vec_splats (unsigned short);
vector signed int vec_splats (signed int);
vector unsigned int vec_splats (unsigned int);
vector float vec_splats (float);

vector float vec_vspltw (vector float, const int);
vector signed int vec_vspltw (vector signed int, const int);
vector unsigned int vec_vspltw (vector unsigned int, const int);
vector bool int vec_vspltw (vector bool int, const int);

vector bool short vec_vsplth (vector bool short, const int);
vector signed short vec_vsplth (vector signed short, const int);
vector unsigned short vec_vsplth (vector unsigned short, const int);
vector pixel vec_vsplth (vector pixel, const int);

vector signed char vec_vspltb (vector signed char, const int);
vector unsigned char vec_vspltb (vector unsigned char, const int);
vector bool char vec_vspltb (vector bool char, const int);

vector signed char vec_splat_s8 (const int);

vector signed short vec_splat_s16 (const int);

vector signed int vec_splat_s32 (const int);

vector unsigned char vec_splat_u8 (const int);

vector unsigned short vec_splat_u16 (const int);

vector unsigned int vec_splat_u32 (const int);

vector signed char vec_sr (vector signed char, vector unsigned char);
vector unsigned char vec_sr (vector unsigned char,
                             vector unsigned char);
vector signed short vec_sr (vector signed short,
                            vector unsigned short);
vector unsigned short vec_sr (vector unsigned short,
                              vector unsigned short);
vector signed int vec_sr (vector signed int, vector unsigned int);
vector unsigned int vec_sr (vector unsigned int, vector unsigned int);

vector signed int vec_vsrw (vector signed int, vector unsigned int);
vector unsigned int vec_vsrw (vector unsigned int, vector unsigned int);

vector signed short vec_vsrh (vector signed short,
                              vector unsigned short);
vector unsigned short vec_vsrh (vector unsigned short,
                                vector unsigned short);

vector signed char vec_vsrb (vector signed char, vector unsigned char);
vector unsigned char vec_vsrb (vector unsigned char,
                               vector unsigned char);

vector signed char vec_sra (vector signed char, vector unsigned char);
vector unsigned char vec_sra (vector unsigned char,
                              vector unsigned char);
vector signed short vec_sra (vector signed short,
                             vector unsigned short);
vector unsigned short vec_sra (vector unsigned short,
                               vector unsigned short);
vector signed int vec_sra (vector signed int, vector unsigned int);
vector unsigned int vec_sra (vector unsigned int, vector unsigned int);

vector signed int vec_vsraw (vector signed int, vector unsigned int);
vector unsigned int vec_vsraw (vector unsigned int,
                               vector unsigned int);

vector signed short vec_vsrah (vector signed short,
                               vector unsigned short);
vector unsigned short vec_vsrah (vector unsigned short,
                                 vector unsigned short);

vector signed char vec_vsrab (vector signed char, vector unsigned char);
vector unsigned char vec_vsrab (vector unsigned char,
                                vector unsigned char);

vector signed int vec_srl (vector signed int, vector unsigned int);
vector signed int vec_srl (vector signed int, vector unsigned short);
vector signed int vec_srl (vector signed int, vector unsigned char);
vector unsigned int vec_srl (vector unsigned int, vector unsigned int);
vector unsigned int vec_srl (vector unsigned int,
                             vector unsigned short);
vector unsigned int vec_srl (vector unsigned int, vector unsigned char);
vector bool int vec_srl (vector bool int, vector unsigned int);
vector bool int vec_srl (vector bool int, vector unsigned short);
vector bool int vec_srl (vector bool int, vector unsigned char);
vector signed short vec_srl (vector signed short, vector unsigned int);
vector signed short vec_srl (vector signed short,
                             vector unsigned short);
vector signed short vec_srl (vector signed short, vector unsigned char);
vector unsigned short vec_srl (vector unsigned short,
                               vector unsigned int);
vector unsigned short vec_srl (vector unsigned short,
                               vector unsigned short);
vector unsigned short vec_srl (vector unsigned short,
                               vector unsigned char);
vector long long int vec_srl (vector long long int,
                              vector unsigned char);
vector unsigned long long int vec_srl (vector unsigned long long int,
                                       vector unsigned char);
vector bool short vec_srl (vector bool short, vector unsigned int);
vector bool short vec_srl (vector bool short, vector unsigned short);
vector bool short vec_srl (vector bool short, vector unsigned char);
vector pixel vec_srl (vector pixel, vector unsigned int);
vector pixel vec_srl (vector pixel, vector unsigned short);
vector pixel vec_srl (vector pixel, vector unsigned char);
vector signed char vec_srl (vector signed char, vector unsigned int);
vector signed char vec_srl (vector signed char, vector unsigned short);
vector signed char vec_srl (vector signed char, vector unsigned char);
vector unsigned char vec_srl (vector unsigned char,
                              vector unsigned int);
vector unsigned char vec_srl (vector unsigned char,
                              vector unsigned short);
vector unsigned char vec_srl (vector unsigned char,
                              vector unsigned char);
vector bool char vec_srl (vector bool char, vector unsigned int);
vector bool char vec_srl (vector bool char, vector unsigned short);
vector bool char vec_srl (vector bool char, vector unsigned char);

vector float vec_sro (vector float, vector signed char);
vector float vec_sro (vector float, vector unsigned char);
vector signed int vec_sro (vector signed int, vector signed char);
vector signed int vec_sro (vector signed int, vector unsigned char);
vector unsigned int vec_sro (vector unsigned int, vector signed char);
vector unsigned int vec_sro (vector unsigned int, vector unsigned char);
vector signed short vec_sro (vector signed short, vector signed char);
vector signed short vec_sro (vector signed short, vector unsigned char);
vector unsigned short vec_sro (vector unsigned short,
                               vector signed char);
vector unsigned short vec_sro (vector unsigned short,
                               vector unsigned char);
vector long long int vec_sro (vector long long int,
                              vector char);
vector long long int vec_sro (vector long long int,
                              vector unsigned char);
vector unsigned long long int vec_sro (vector unsigned long long int,
                                       vector char);
vector unsigned long long int vec_sro (vector unsigned long long int,
                                       vector unsigned char);
vector pixel vec_sro (vector pixel, vector signed char);
vector pixel vec_sro (vector pixel, vector unsigned char);
vector signed char vec_sro (vector signed char, vector signed char);
vector signed char vec_sro (vector signed char, vector unsigned char);
vector unsigned char vec_sro (vector unsigned char, vector signed char);
vector unsigned char vec_sro (vector unsigned char,
                              vector unsigned char);

void vec_st (vector float, int, vector float *);
void vec_st (vector float, int, float *);
void vec_st (vector signed int, int, vector signed int *);
void vec_st (vector signed int, int, int *);
void vec_st (vector unsigned int, int, vector unsigned int *);
void vec_st (vector unsigned int, int, unsigned int *);
void vec_st (vector bool int, int, vector bool int *);
void vec_st (vector bool int, int, unsigned int *);
void vec_st (vector bool int, int, int *);
void vec_st (vector signed short, int, vector signed short *);
void vec_st (vector signed short, int, short *);
void vec_st (vector unsigned short, int, vector unsigned short *);
void vec_st (vector unsigned short, int, unsigned short *);
void vec_st (vector bool short, int, vector bool short *);
void vec_st (vector bool short, int, unsigned short *);
void vec_st (vector pixel, int, vector pixel *);
void vec_st (vector pixel, int, unsigned short *);
void vec_st (vector pixel, int, short *);
void vec_st (vector bool short, int, short *);
void vec_st (vector signed char, int, vector signed char *);
void vec_st (vector signed char, int, signed char *);
void vec_st (vector unsigned char, int, vector unsigned char *);
void vec_st (vector unsigned char, int, unsigned char *);
void vec_st (vector bool char, int, vector bool char *);
void vec_st (vector bool char, int, unsigned char *);
void vec_st (vector bool char, int, signed char *);

void vec_ste (vector signed char, int, signed char *);
void vec_ste (vector unsigned char, int, unsigned char *);
void vec_ste (vector bool char, int, signed char *);
void vec_ste (vector bool char, int, unsigned char *);
void vec_ste (vector signed short, int, short *);
void vec_ste (vector unsigned short, int, unsigned short *);
void vec_ste (vector bool short, int, short *);
void vec_ste (vector bool short, int, unsigned short *);
void vec_ste (vector pixel, int, short *);
void vec_ste (vector pixel, int, unsigned short *);
void vec_ste (vector float, int, float *);
void vec_ste (vector signed int, int, int *);
void vec_ste (vector unsigned int, int, unsigned int *);
void vec_ste (vector bool int, int, int *);
void vec_ste (vector bool int, int, unsigned int *);

void vec_stvewx (vector float, int, float *);
void vec_stvewx (vector signed int, int, int *);
void vec_stvewx (vector unsigned int, int, unsigned int *);
void vec_stvewx (vector bool int, int, int *);
void vec_stvewx (vector bool int, int, unsigned int *);

void vec_stvehx (vector signed short, int, short *);
void vec_stvehx (vector unsigned short, int, unsigned short *);
void vec_stvehx (vector bool short, int, short *);
void vec_stvehx (vector bool short, int, unsigned short *);
void vec_stvehx (vector pixel, int, short *);
void vec_stvehx (vector pixel, int, unsigned short *);

void vec_stvebx (vector signed char, int, signed char *);
void vec_stvebx (vector unsigned char, int, unsigned char *);
void vec_stvebx (vector bool char, int, signed char *);
void vec_stvebx (vector bool char, int, unsigned char *);

void vec_stl (vector float, int, vector float *);
void vec_stl (vector float, int, float *);
void vec_stl (vector signed int, int, vector signed int *);
void vec_stl (vector signed int, int, int *);
void vec_stl (vector unsigned int, int, vector unsigned int *);
void vec_stl (vector unsigned int, int, unsigned int *);
void vec_stl (vector bool int, int, vector bool int *);
void vec_stl (vector bool int, int, unsigned int *);
void vec_stl (vector bool int, int, int *);
void vec_stl (vector signed short, int, vector signed short *);
void vec_stl (vector signed short, int, short *);
void vec_stl (vector unsigned short, int, vector unsigned short *);
void vec_stl (vector unsigned short, int, unsigned short *);
void vec_stl (vector bool short, int, vector bool short *);
void vec_stl (vector bool short, int, unsigned short *);
void vec_stl (vector bool short, int, short *);
void vec_stl (vector pixel, int, vector pixel *);
void vec_stl (vector pixel, int, unsigned short *);
void vec_stl (vector pixel, int, short *);
void vec_stl (vector signed char, int, vector signed char *);
void vec_stl (vector signed char, int, signed char *);
void vec_stl (vector unsigned char, int, vector unsigned char *);
void vec_stl (vector unsigned char, int, unsigned char *);
void vec_stl (vector bool char, int, vector bool char *);
void vec_stl (vector bool char, int, unsigned char *);
void vec_stl (vector bool char, int, signed char *);

vector signed char vec_sub (vector bool char, vector signed char);
vector signed char vec_sub (vector signed char, vector bool char);
vector signed char vec_sub (vector signed char, vector signed char);
vector unsigned char vec_sub (vector bool char, vector unsigned char);
vector unsigned char vec_sub (vector unsigned char, vector bool char);
vector unsigned char vec_sub (vector unsigned char,
                              vector unsigned char);
vector signed short vec_sub (vector bool short, vector signed short);
vector signed short vec_sub (vector signed short, vector bool short);
vector signed short vec_sub (vector signed short, vector signed short);
vector unsigned short vec_sub (vector bool short,
                               vector unsigned short);
vector unsigned short vec_sub (vector unsigned short,
                               vector bool short);
vector unsigned short vec_sub (vector unsigned short,
                               vector unsigned short);
vector signed int vec_sub (vector bool int, vector signed int);
vector signed int vec_sub (vector signed int, vector bool int);
vector signed int vec_sub (vector signed int, vector signed int);
vector unsigned int vec_sub (vector bool int, vector unsigned int);
vector unsigned int vec_sub (vector unsigned int, vector bool int);
vector unsigned int vec_sub (vector unsigned int, vector unsigned int);
vector float vec_sub (vector float, vector float);

vector float vec_vsubfp (vector float, vector float);

vector signed int vec_vsubuwm (vector bool int, vector signed int);
vector signed int vec_vsubuwm (vector signed int, vector bool int);
vector signed int vec_vsubuwm (vector signed int, vector signed int);
vector unsigned int vec_vsubuwm (vector bool int, vector unsigned int);
vector unsigned int vec_vsubuwm (vector unsigned int, vector bool int);
vector unsigned int vec_vsubuwm (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vsubuhm (vector bool short,
                                 vector signed short);
vector signed short vec_vsubuhm (vector signed short,
                                 vector bool short);
vector signed short vec_vsubuhm (vector signed short,
                                 vector signed short);
vector unsigned short vec_vsubuhm (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vsubuhm (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vsubuhm (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vsububm (vector bool char, vector signed char);
vector signed char vec_vsububm (vector signed char, vector bool char);
vector signed char vec_vsububm (vector signed char, vector signed char);
vector unsigned char vec_vsububm (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vsububm (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vsububm (vector unsigned char,
                                  vector unsigned char);

vector signed int vec_subc (vector signed int, vector signed int);
vector unsigned int vec_subc (vector unsigned int, vector unsigned int);
vector signed __int128 vec_subc (vector signed __int128,
                                 vector signed __int128);
vector unsigned __int128 vec_subc (vector unsigned __int128,
                                   vector unsigned __int128);

vector signed int vec_sube (vector signed int, vector signed int,
                            vector signed int);
vector unsigned int vec_sube (vector unsigned int, vector unsigned int,
                              vector unsigned int);
vector signed __int128 vec_sube (vector signed __int128,
                                 vector signed __int128,
                                 vector signed __int128);
vector unsigned __int128 vec_sube (vector unsigned __int128,
                                   vector unsigned __int128,
                                   vector unsigned __int128);

vector signed int vec_subec (vector signed int, vector signed int,
                             vector signed int);
vector unsigned int vec_subec (vector unsigned int, vector unsigned int,
                               vector unsigned int);
vector signed __int128 vec_subec (vector signed __int128,
                                  vector signed __int128,
                                  vector signed __int128);
vector unsigned __int128 vec_subec (vector unsigned __int128,
                                    vector unsigned __int128,
                                    vector unsigned __int128);

vector unsigned char vec_subs (vector bool char, vector unsigned char);
vector unsigned char vec_subs (vector unsigned char, vector bool char);
vector unsigned char vec_subs (vector unsigned char,
                               vector unsigned char);
vector signed char vec_subs (vector bool char, vector signed char);
vector signed char vec_subs (vector signed char, vector bool char);
vector signed char vec_subs (vector signed char, vector signed char);
vector unsigned short vec_subs (vector bool short,
                                vector unsigned short);
vector unsigned short vec_subs (vector unsigned short,
                                vector bool short);
vector unsigned short vec_subs (vector unsigned short,
                                vector unsigned short);
vector signed short vec_subs (vector bool short, vector signed short);
vector signed short vec_subs (vector signed short, vector bool short);
vector signed short vec_subs (vector signed short, vector signed short);
vector unsigned int vec_subs (vector bool int, vector unsigned int);
vector unsigned int vec_subs (vector unsigned int, vector bool int);
vector unsigned int vec_subs (vector unsigned int, vector unsigned int);
vector signed int vec_subs (vector bool int, vector signed int);
vector signed int vec_subs (vector signed int, vector bool int);
vector signed int vec_subs (vector signed int, vector signed int);

vector signed int vec_vsubsws (vector bool int, vector signed int);
vector signed int vec_vsubsws (vector signed int, vector bool int);
vector signed int vec_vsubsws (vector signed int, vector signed int);

vector unsigned int vec_vsubuws (vector bool int, vector unsigned int);
vector unsigned int vec_vsubuws (vector unsigned int, vector bool int);
vector unsigned int vec_vsubuws (vector unsigned int,
                                 vector unsigned int);

vector signed short vec_vsubshs (vector bool short,
                                 vector signed short);
vector signed short vec_vsubshs (vector signed short,
                                 vector bool short);
vector signed short vec_vsubshs (vector signed short,
                                 vector signed short);

vector unsigned short vec_vsubuhs (vector bool short,
                                   vector unsigned short);
vector unsigned short vec_vsubuhs (vector unsigned short,
                                   vector bool short);
vector unsigned short vec_vsubuhs (vector unsigned short,
                                   vector unsigned short);

vector signed char vec_vsubsbs (vector bool char, vector signed char);
vector signed char vec_vsubsbs (vector signed char, vector bool char);
vector signed char vec_vsubsbs (vector signed char, vector signed char);

vector unsigned char vec_vsububs (vector bool char,
                                  vector unsigned char);
vector unsigned char vec_vsububs (vector unsigned char,
                                  vector bool char);
vector unsigned char vec_vsububs (vector unsigned char,
                                  vector unsigned char);

vector unsigned int vec_sum4s (vector unsigned char,
                               vector unsigned int);
vector signed int vec_sum4s (vector signed char, vector signed int);
vector signed int vec_sum4s (vector signed short, vector signed int);

vector signed int vec_vsum4shs (vector signed short, vector signed int);

vector signed int vec_vsum4sbs (vector signed char, vector signed int);

vector unsigned int vec_vsum4ubs (vector unsigned char,
                                  vector unsigned int);

vector signed int vec_sum2s (vector signed int, vector signed int);

vector signed int vec_sums (vector signed int, vector signed int);

vector float vec_trunc (vector float);

vector signed long long vec_unsigned (vector double);
vector signed int vec_unsigned (vector float);

vector signed int vec_unsignede (vector double);
vector signed int vec_unsignedo (vector double);
vector signed int vec_unsigned2 (vector double, vector double);

vector signed short vec_unpackh (vector signed char);
vector bool short vec_unpackh (vector bool char);
vector signed int vec_unpackh (vector signed short);
vector bool int vec_unpackh (vector bool short);
vector unsigned int vec_unpackh (vector pixel);
vector double vec_unpackh (vector float);

vector bool int vec_vupkhsh (vector bool short);
vector signed int vec_vupkhsh (vector signed short);

vector unsigned int vec_vupkhpx (vector pixel);

vector bool short vec_vupkhsb (vector bool char);
vector signed short vec_vupkhsb (vector signed char);

vector signed short vec_unpackl (vector signed char);
vector bool short vec_unpackl (vector bool char);
vector unsigned int vec_unpackl (vector pixel);
vector signed int vec_unpackl (vector signed short);
vector bool int vec_unpackl (vector bool short);
vector double vec_unpackl (vector float);

vector unsigned int vec_vupklpx (vector pixel);

vector bool int vec_vupklsh (vector bool short);
vector signed int vec_vupklsh (vector signed short);

vector bool short vec_vupklsb (vector bool char);
vector signed short vec_vupklsb (vector signed char);

vector float vec_xor (vector float, vector float);
vector float vec_xor (vector float, vector bool int);
vector float vec_xor (vector bool int, vector float);
vector bool int vec_xor (vector bool int, vector bool int);
vector signed int vec_xor (vector bool int, vector signed int);
vector signed int vec_xor (vector signed int, vector bool int);
vector signed int vec_xor (vector signed int, vector signed int);
vector unsigned int vec_xor (vector bool int, vector unsigned int);
vector unsigned int vec_xor (vector unsigned int, vector bool int);
vector unsigned int vec_xor (vector unsigned int, vector unsigned int);
vector bool short vec_xor (vector bool short, vector bool short);
vector signed short vec_xor (vector bool short, vector signed short);
vector signed short vec_xor (vector signed short, vector bool short);
vector signed short vec_xor (vector signed short, vector signed short);
vector unsigned short vec_xor (vector bool short,
                               vector unsigned short);
vector unsigned short vec_xor (vector unsigned short,
                               vector bool short);
vector unsigned short vec_xor (vector unsigned short,
                               vector unsigned short);
vector signed char vec_xor (vector bool char, vector signed char);
vector bool char vec_xor (vector bool char, vector bool char);
vector signed char vec_xor (vector signed char, vector bool char);
vector signed char vec_xor (vector signed char, vector signed char);
vector unsigned char vec_xor (vector bool char, vector unsigned char);
vector unsigned char vec_xor (vector unsigned char, vector bool char);
vector unsigned char vec_xor (vector unsigned char,
                              vector unsigned char);

int vec_all_eq (vector signed char, vector bool char);
int vec_all_eq (vector signed char, vector signed char);
int vec_all_eq (vector unsigned char, vector bool char);
int vec_all_eq (vector unsigned char, vector unsigned char);
int vec_all_eq (vector bool char, vector bool char);
int vec_all_eq (vector bool char, vector unsigned char);
int vec_all_eq (vector bool char, vector signed char);
int vec_all_eq (vector signed short, vector bool short);
int vec_all_eq (vector signed short, vector signed short);
int vec_all_eq (vector unsigned short, vector bool short);
int vec_all_eq (vector unsigned short, vector unsigned short);
int vec_all_eq (vector bool short, vector bool short);
int vec_all_eq (vector bool short, vector unsigned short);
int vec_all_eq (vector bool short, vector signed short);
int vec_all_eq (vector pixel, vector pixel);
int vec_all_eq (vector signed int, vector bool int);
int vec_all_eq (vector signed int, vector signed int);
int vec_all_eq (vector unsigned int, vector bool int);
int vec_all_eq (vector unsigned int, vector unsigned int);
int vec_all_eq (vector bool int, vector bool int);
int vec_all_eq (vector bool int, vector unsigned int);
int vec_all_eq (vector bool int, vector signed int);
int vec_all_eq (vector float, vector float);

int vec_all_ge (vector bool char, vector unsigned char);
int vec_all_ge (vector unsigned char, vector bool char);
int vec_all_ge (vector unsigned char, vector unsigned char);
int vec_all_ge (vector bool char, vector signed char);
int vec_all_ge (vector signed char, vector bool char);
int vec_all_ge (vector signed char, vector signed char);
int vec_all_ge (vector bool short, vector unsigned short);
int vec_all_ge (vector unsigned short, vector bool short);
int vec_all_ge (vector unsigned short, vector unsigned short);
int vec_all_ge (vector signed short, vector signed short);
int vec_all_ge (vector bool short, vector signed short);
int vec_all_ge (vector signed short, vector bool short);
int vec_all_ge (vector bool int, vector unsigned int);
int vec_all_ge (vector unsigned int, vector bool int);
int vec_all_ge (vector unsigned int, vector unsigned int);
int vec_all_ge (vector bool int, vector signed int);
int vec_all_ge (vector signed int, vector bool int);
int vec_all_ge (vector signed int, vector signed int);
int vec_all_ge (vector float, vector float);

int vec_all_gt (vector bool char, vector unsigned char);
int vec_all_gt (vector unsigned char, vector bool char);
int vec_all_gt (vector unsigned char, vector unsigned char);
int vec_all_gt (vector bool char, vector signed char);
int vec_all_gt (vector signed char, vector bool char);
int vec_all_gt (vector signed char, vector signed char);
int vec_all_gt (vector bool short, vector unsigned short);
int vec_all_gt (vector unsigned short, vector bool short);
int vec_all_gt (vector unsigned short, vector unsigned short);
int vec_all_gt (vector bool short, vector signed short);
int vec_all_gt (vector signed short, vector bool short);
int vec_all_gt (vector signed short, vector signed short);
int vec_all_gt (vector bool int, vector unsigned int);
int vec_all_gt (vector unsigned int, vector bool int);
int vec_all_gt (vector unsigned int, vector unsigned int);
int vec_all_gt (vector bool int, vector signed int);
int vec_all_gt (vector signed int, vector bool int);
int vec_all_gt (vector signed int, vector signed int);
int vec_all_gt (vector float, vector float);

int vec_all_in (vector float, vector float);

int vec_all_le (vector bool char, vector unsigned char);
int vec_all_le (vector unsigned char, vector bool char);
int vec_all_le (vector unsigned char, vector unsigned char);
int vec_all_le (vector bool char, vector signed char);
int vec_all_le (vector signed char, vector bool char);
int vec_all_le (vector signed char, vector signed char);
int vec_all_le (vector bool short, vector unsigned short);
int vec_all_le (vector unsigned short, vector bool short);
int vec_all_le (vector unsigned short, vector unsigned short);
int vec_all_le (vector bool short, vector signed short);
int vec_all_le (vector signed short, vector bool short);
int vec_all_le (vector signed short, vector signed short);
int vec_all_le (vector bool int, vector unsigned int);
int vec_all_le (vector unsigned int, vector bool int);
int vec_all_le (vector unsigned int, vector unsigned int);
int vec_all_le (vector bool int, vector signed int);
int vec_all_le (vector signed int, vector bool int);
int vec_all_le (vector signed int, vector signed int);
int vec_all_le (vector float, vector float);

int vec_all_lt (vector bool char, vector unsigned char);
int vec_all_lt (vector unsigned char, vector bool char);
int vec_all_lt (vector unsigned char, vector unsigned char);
int vec_all_lt (vector bool char, vector signed char);
int vec_all_lt (vector signed char, vector bool char);
int vec_all_lt (vector signed char, vector signed char);
int vec_all_lt (vector bool short, vector unsigned short);
int vec_all_lt (vector unsigned short, vector bool short);
int vec_all_lt (vector unsigned short, vector unsigned short);
int vec_all_lt (vector bool short, vector signed short);
int vec_all_lt (vector signed short, vector bool short);
int vec_all_lt (vector signed short, vector signed short);
int vec_all_lt (vector bool int, vector unsigned int);
int vec_all_lt (vector unsigned int, vector bool int);
int vec_all_lt (vector unsigned int, vector unsigned int);
int vec_all_lt (vector bool int, vector signed int);
int vec_all_lt (vector signed int, vector bool int);
int vec_all_lt (vector signed int, vector signed int);
int vec_all_lt (vector float, vector float);

int vec_all_nan (vector float);

int vec_all_ne (vector signed char, vector bool char);
int vec_all_ne (vector signed char, vector signed char);
int vec_all_ne (vector unsigned char, vector bool char);
int vec_all_ne (vector unsigned char, vector unsigned char);
int vec_all_ne (vector bool char, vector bool char);
int vec_all_ne (vector bool char, vector unsigned char);
int vec_all_ne (vector bool char, vector signed char);
int vec_all_ne (vector signed short, vector bool short);
int vec_all_ne (vector signed short, vector signed short);
int vec_all_ne (vector unsigned short, vector bool short);
int vec_all_ne (vector unsigned short, vector unsigned short);
int vec_all_ne (vector bool short, vector bool short);
int vec_all_ne (vector bool short, vector unsigned short);
int vec_all_ne (vector bool short, vector signed short);
int vec_all_ne (vector pixel, vector pixel);
int vec_all_ne (vector signed int, vector bool int);
int vec_all_ne (vector signed int, vector signed int);
int vec_all_ne (vector unsigned int, vector bool int);
int vec_all_ne (vector unsigned int, vector unsigned int);
int vec_all_ne (vector bool int, vector bool int);
int vec_all_ne (vector bool int, vector unsigned int);
int vec_all_ne (vector bool int, vector signed int);
int vec_all_ne (vector float, vector float);

int vec_all_nge (vector float, vector float);

int vec_all_ngt (vector float, vector float);

int vec_all_nle (vector float, vector float);

int vec_all_nlt (vector float, vector float);

int vec_all_numeric (vector float);

int vec_any_eq (vector signed char, vector bool char);
int vec_any_eq (vector signed char, vector signed char);
int vec_any_eq (vector unsigned char, vector bool char);
int vec_any_eq (vector unsigned char, vector unsigned char);
int vec_any_eq (vector bool char, vector bool char);
int vec_any_eq (vector bool char, vector unsigned char);
int vec_any_eq (vector bool char, vector signed char);
int vec_any_eq (vector signed short, vector bool short);
int vec_any_eq (vector signed short, vector signed short);
int vec_any_eq (vector unsigned short, vector bool short);
int vec_any_eq (vector unsigned short, vector unsigned short);
int vec_any_eq (vector bool short, vector bool short);
int vec_any_eq (vector bool short, vector unsigned short);
int vec_any_eq (vector bool short, vector signed short);
int vec_any_eq (vector pixel, vector pixel);
int vec_any_eq (vector signed int, vector bool int);
int vec_any_eq (vector signed int, vector signed int);
int vec_any_eq (vector unsigned int, vector bool int);
int vec_any_eq (vector unsigned int, vector unsigned int);
int vec_any_eq (vector bool int, vector bool int);
int vec_any_eq (vector bool int, vector unsigned int);
int vec_any_eq (vector bool int, vector signed int);
int vec_any_eq (vector float, vector float);

int vec_any_ge (vector signed char, vector bool char);
int vec_any_ge (vector unsigned char, vector bool char);
int vec_any_ge (vector unsigned char, vector unsigned char);
int vec_any_ge (vector signed char, vector signed char);
int vec_any_ge (vector bool char, vector unsigned char);
int vec_any_ge (vector bool char, vector signed char);
int vec_any_ge (vector unsigned short, vector bool short);
int vec_any_ge (vector unsigned short, vector unsigned short);
int vec_any_ge (vector signed short, vector signed short);
int vec_any_ge (vector signed short, vector bool short);
int vec_any_ge (vector bool short, vector unsigned short);
int vec_any_ge (vector bool short, vector signed short);
int vec_any_ge (vector signed int, vector bool int);
int vec_any_ge (vector unsigned int, vector bool int);
int vec_any_ge (vector unsigned int, vector unsigned int);
int vec_any_ge (vector signed int, vector signed int);
int vec_any_ge (vector bool int, vector unsigned int);
int vec_any_ge (vector bool int, vector signed int);
int vec_any_ge (vector float, vector float);

int vec_any_gt (vector bool char, vector unsigned char);
int vec_any_gt (vector unsigned char, vector bool char);
int vec_any_gt (vector unsigned char, vector unsigned char);
int vec_any_gt (vector bool char, vector signed char);
int vec_any_gt (vector signed char, vector bool char);
int vec_any_gt (vector signed char, vector signed char);
int vec_any_gt (vector bool short, vector unsigned short);
int vec_any_gt (vector unsigned short, vector bool short);
int vec_any_gt (vector unsigned short, vector unsigned short);
int vec_any_gt (vector bool short, vector signed short);
int vec_any_gt (vector signed short, vector bool short);
int vec_any_gt (vector signed short, vector signed short);
int vec_any_gt (vector bool int, vector unsigned int);
int vec_any_gt (vector unsigned int, vector bool int);
int vec_any_gt (vector unsigned int, vector unsigned int);
int vec_any_gt (vector bool int, vector signed int);
int vec_any_gt (vector signed int, vector bool int);
int vec_any_gt (vector signed int, vector signed int);
int vec_any_gt (vector float, vector float);

int vec_any_le (vector bool char, vector unsigned char);
int vec_any_le (vector unsigned char, vector bool char);
int vec_any_le (vector unsigned char, vector unsigned char);
int vec_any_le (vector bool char, vector signed char);
int vec_any_le (vector signed char, vector bool char);
int vec_any_le (vector signed char, vector signed char);
int vec_any_le (vector bool short, vector unsigned short);
int vec_any_le (vector unsigned short, vector bool short);
int vec_any_le (vector unsigned short, vector unsigned short);
int vec_any_le (vector bool short, vector signed short);
int vec_any_le (vector signed short, vector bool short);
int vec_any_le (vector signed short, vector signed short);
int vec_any_le (vector bool int, vector unsigned int);
int vec_any_le (vector unsigned int, vector bool int);
int vec_any_le (vector unsigned int, vector unsigned int);
int vec_any_le (vector bool int, vector signed int);
int vec_any_le (vector signed int, vector bool int);
int vec_any_le (vector signed int, vector signed int);
int vec_any_le (vector float, vector float);

int vec_any_lt (vector bool char, vector unsigned char);
int vec_any_lt (vector unsigned char, vector bool char);
int vec_any_lt (vector unsigned char, vector unsigned char);
int vec_any_lt (vector bool char, vector signed char);
int vec_any_lt (vector signed char, vector bool char);
int vec_any_lt (vector signed char, vector signed char);
int vec_any_lt (vector bool short, vector unsigned short);
int vec_any_lt (vector unsigned short, vector bool short);
int vec_any_lt (vector unsigned short, vector unsigned short);
int vec_any_lt (vector bool short, vector signed short);
int vec_any_lt (vector signed short, vector bool short);
int vec_any_lt (vector signed short, vector signed short);
int vec_any_lt (vector bool int, vector unsigned int);
int vec_any_lt (vector unsigned int, vector bool int);
int vec_any_lt (vector unsigned int, vector unsigned int);
int vec_any_lt (vector bool int, vector signed int);
int vec_any_lt (vector signed int, vector bool int);
int vec_any_lt (vector signed int, vector signed int);
int vec_any_lt (vector float, vector float);

int vec_any_nan (vector float);

int vec_any_ne (vector signed char, vector bool char);
int vec_any_ne (vector signed char, vector signed char);
int vec_any_ne (vector unsigned char, vector bool char);
int vec_any_ne (vector unsigned char, vector unsigned char);
int vec_any_ne (vector bool char, vector bool char);
int vec_any_ne (vector bool char, vector unsigned char);
int vec_any_ne (vector bool char, vector signed char);
int vec_any_ne (vector signed short, vector bool short);
int vec_any_ne (vector signed short, vector signed short);
int vec_any_ne (vector unsigned short, vector bool short);
int vec_any_ne (vector unsigned short, vector unsigned short);
int vec_any_ne (vector bool short, vector bool short);
int vec_any_ne (vector bool short, vector unsigned short);
int vec_any_ne (vector bool short, vector signed short);
int vec_any_ne (vector pixel, vector pixel);
int vec_any_ne (vector signed int, vector bool int);
int vec_any_ne (vector signed int, vector signed int);
int vec_any_ne (vector unsigned int, vector bool int);
int vec_any_ne (vector unsigned int, vector unsigned int);
int vec_any_ne (vector bool int, vector bool int);
int vec_any_ne (vector bool int, vector unsigned int);
int vec_any_ne (vector bool int, vector signed int);
int vec_any_ne (vector float, vector float);

int vec_any_nge (vector float, vector float);

int vec_any_ngt (vector float, vector float);

int vec_any_nle (vector float, vector float);

int vec_any_nlt (vector float, vector float);

int vec_any_numeric (vector float);

int vec_any_out (vector float, vector float);
@end smallexample

ベクトル/スカラー（VSX）命令セットが使用可能な場合、次の追加機能を使用できる。

@smallexample
vector double vec_abs (vector double);
vector double vec_add (vector double, vector double);
vector double vec_and (vector double, vector double);
vector double vec_and (vector double, vector bool long);
vector double vec_and (vector bool long, vector double);
vector long vec_and (vector long, vector long);
vector long vec_and (vector long, vector bool long);
vector long vec_and (vector bool long, vector long);
vector unsigned long vec_and (vector unsigned long, vector unsigned long);
vector unsigned long vec_and (vector unsigned long, vector bool long);
vector unsigned long vec_and (vector bool long, vector unsigned long);
vector double vec_andc (vector double, vector double);
vector double vec_andc (vector double, vector bool long);
vector double vec_andc (vector bool long, vector double);
vector long vec_andc (vector long, vector long);
vector long vec_andc (vector long, vector bool long);
vector long vec_andc (vector bool long, vector long);
vector unsigned long vec_andc (vector unsigned long, vector unsigned long);
vector unsigned long vec_andc (vector unsigned long, vector bool long);
vector unsigned long vec_andc (vector bool long, vector unsigned long);
vector double vec_ceil (vector double);
vector bool long vec_cmpeq (vector double, vector double);
vector bool long vec_cmpge (vector double, vector double);
vector bool long vec_cmpgt (vector double, vector double);
vector bool long vec_cmple (vector double, vector double);
vector bool long vec_cmplt (vector double, vector double);
vector double vec_cpsgn (vector double, vector double);
vector float vec_div (vector float, vector float);
vector double vec_div (vector double, vector double);
vector long vec_div (vector long, vector long);
vector unsigned long vec_div (vector unsigned long, vector unsigned long);
vector double vec_floor (vector double);
vector __int128 vec_ld (int, const vector __int128 *);
vector unsigned __int128 vec_ld (int, const vector unsigned __int128 *);
vector __int128 vec_ld (int, const __int128 *);
vector unsigned __int128 vec_ld (int, const unsigned __int128 *);
vector double vec_ld (int, const vector double *);
vector double vec_ld (int, const double *);
vector double vec_ldl (int, const vector double *);
vector double vec_ldl (int, const double *);
vector unsigned char vec_lvsl (int, const volatile double *);
vector unsigned char vec_lvsr (int, const volatile double *);
vector double vec_madd (vector double, vector double, vector double);
vector double vec_max (vector double, vector double);
vector signed long vec_mergeh (vector signed long, vector signed long);
vector signed long vec_mergeh (vector signed long, vector bool long);
vector signed long vec_mergeh (vector bool long, vector signed long);
vector unsigned long vec_mergeh (vector unsigned long, vector unsigned long);
vector unsigned long vec_mergeh (vector unsigned long, vector bool long);
vector unsigned long vec_mergeh (vector bool long, vector unsigned long);
vector signed long vec_mergel (vector signed long, vector signed long);
vector signed long vec_mergel (vector signed long, vector bool long);
vector signed long vec_mergel (vector bool long, vector signed long);
vector unsigned long vec_mergel (vector unsigned long, vector unsigned long);
vector unsigned long vec_mergel (vector unsigned long, vector bool long);
vector unsigned long vec_mergel (vector bool long, vector unsigned long);
vector double vec_min (vector double, vector double);
vector float vec_msub (vector float, vector float, vector float);
vector double vec_msub (vector double, vector double, vector double);
vector float vec_mul (vector float, vector float);
vector double vec_mul (vector double, vector double);
vector long vec_mul (vector long, vector long);
vector unsigned long vec_mul (vector unsigned long, vector unsigned long);
vector float vec_nearbyint (vector float);
vector double vec_nearbyint (vector double);
vector float vec_nmadd (vector float, vector float, vector float);
vector double vec_nmadd (vector double, vector double, vector double);
vector double vec_nmsub (vector double, vector double, vector double);
vector double vec_nor (vector double, vector double);
vector long vec_nor (vector long, vector long);
vector long vec_nor (vector long, vector bool long);
vector long vec_nor (vector bool long, vector long);
vector unsigned long vec_nor (vector unsigned long, vector unsigned long);
vector unsigned long vec_nor (vector unsigned long, vector bool long);
vector unsigned long vec_nor (vector bool long, vector unsigned long);
vector double vec_or (vector double, vector double);
vector double vec_or (vector double, vector bool long);
vector double vec_or (vector bool long, vector double);
vector long vec_or (vector long, vector long);
vector long vec_or (vector long, vector bool long);
vector long vec_or (vector bool long, vector long);
vector unsigned long vec_or (vector unsigned long, vector unsigned long);
vector unsigned long vec_or (vector unsigned long, vector bool long);
vector unsigned long vec_or (vector bool long, vector unsigned long);
vector double vec_perm (vector double, vector double, vector unsigned char);
vector long vec_perm (vector long, vector long, vector unsigned char);
vector unsigned long vec_perm (vector unsigned long, vector unsigned long,
                               vector unsigned char);
vector bool char vec_permxor (vector bool char, vector bool char,
                              vector bool char);
vector unsigned char vec_permxor (vector signed char, vector signed char,
                                  vector signed char);
vector unsigned char vec_permxor (vector unsigned char, vector unsigned char,
                                  vector unsigned char);
vector double vec_rint (vector double);
vector double vec_recip (vector double, vector double);
vector double vec_rsqrt (vector double);
vector double vec_rsqrte (vector double);
vector double vec_sel (vector double, vector double, vector bool long);
vector double vec_sel (vector double, vector double, vector unsigned long);
vector long vec_sel (vector long, vector long, vector long);
vector long vec_sel (vector long, vector long, vector unsigned long);
vector long vec_sel (vector long, vector long, vector bool long);
vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                              vector long);
vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                              vector unsigned long);
vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                              vector bool long);
vector double vec_splats (double);
vector signed long vec_splats (signed long);
vector unsigned long vec_splats (unsigned long);
vector float vec_sqrt (vector float);
vector double vec_sqrt (vector double);
void vec_st (vector double, int, vector double *);
void vec_st (vector double, int, double *);
vector double vec_sub (vector double, vector double);
vector double vec_trunc (vector double);
vector double vec_xl (int, vector double *);
vector double vec_xl (int, double *);
vector long long vec_xl (int, vector long long *);
vector long long vec_xl (int, long long *);
vector unsigned long long vec_xl (int, vector unsigned long long *);
vector unsigned long long vec_xl (int, unsigned long long *);
vector float vec_xl (int, vector float *);
vector float vec_xl (int, float *);
vector int vec_xl (int, vector int *);
vector int vec_xl (int, int *);
vector unsigned int vec_xl (int, vector unsigned int *);
vector unsigned int vec_xl (int, unsigned int *);
vector double vec_xor (vector double, vector double);
vector double vec_xor (vector double, vector bool long);
vector double vec_xor (vector bool long, vector double);
vector long vec_xor (vector long, vector long);
vector long vec_xor (vector long, vector bool long);
vector long vec_xor (vector bool long, vector long);
vector unsigned long vec_xor (vector unsigned long, vector unsigned long);
vector unsigned long vec_xor (vector unsigned long, vector bool long);
vector unsigned long vec_xor (vector bool long, vector unsigned long);
void vec_xst (vector double, int, vector double *);
void vec_xst (vector double, int, double *);
void vec_xst (vector long long, int, vector long long *);
void vec_xst (vector long long, int, long long *);
void vec_xst (vector unsigned long long, int, vector unsigned long long *);
void vec_xst (vector unsigned long long, int, unsigned long long *);
void vec_xst (vector float, int, vector float *);
void vec_xst (vector float, int, float *);
void vec_xst (vector int, int, vector int *);
void vec_xst (vector int, int, int *);
void vec_xst (vector unsigned int, int, vector unsigned int *);
void vec_xst (vector unsigned int, int, unsigned int *);
int vec_all_eq (vector double, vector double);
int vec_all_ge (vector double, vector double);
int vec_all_gt (vector double, vector double);
int vec_all_le (vector double, vector double);
int vec_all_lt (vector double, vector double);
int vec_all_nan (vector double);
int vec_all_ne (vector double, vector double);
int vec_all_nge (vector double, vector double);
int vec_all_ngt (vector double, vector double);
int vec_all_nle (vector double, vector double);
int vec_all_nlt (vector double, vector double);
int vec_all_numeric (vector double);
int vec_any_eq (vector double, vector double);
int vec_any_ge (vector double, vector double);
int vec_any_gt (vector double, vector double);
int vec_any_le (vector double, vector double);
int vec_any_lt (vector double, vector double);
int vec_any_nan (vector double);
int vec_any_ne (vector double, vector double);
int vec_any_nge (vector double, vector double);
int vec_any_ngt (vector double, vector double);
int vec_any_nle (vector double, vector double);
int vec_any_nlt (vector double, vector double);
int vec_any_numeric (vector double);

vector double vec_vsx_ld (int, const vector double *);
vector double vec_vsx_ld (int, const double *);
vector float vec_vsx_ld (int, const vector float *);
vector float vec_vsx_ld (int, const float *);
vector bool int vec_vsx_ld (int, const vector bool int *);
vector signed int vec_vsx_ld (int, const vector signed int *);
vector signed int vec_vsx_ld (int, const int *);
vector signed int vec_vsx_ld (int, const long *);
vector unsigned int vec_vsx_ld (int, const vector unsigned int *);
vector unsigned int vec_vsx_ld (int, const unsigned int *);
vector unsigned int vec_vsx_ld (int, const unsigned long *);
vector bool short vec_vsx_ld (int, const vector bool short *);
vector pixel vec_vsx_ld (int, const vector pixel *);
vector signed short vec_vsx_ld (int, const vector signed short *);
vector signed short vec_vsx_ld (int, const short *);
vector unsigned short vec_vsx_ld (int, const vector unsigned short *);
vector unsigned short vec_vsx_ld (int, const unsigned short *);
vector bool char vec_vsx_ld (int, const vector bool char *);
vector signed char vec_vsx_ld (int, const vector signed char *);
vector signed char vec_vsx_ld (int, const signed char *);
vector unsigned char vec_vsx_ld (int, const vector unsigned char *);
vector unsigned char vec_vsx_ld (int, const unsigned char *);

void vec_vsx_st (vector double, int, vector double *);
void vec_vsx_st (vector double, int, double *);
void vec_vsx_st (vector float, int, vector float *);
void vec_vsx_st (vector float, int, float *);
void vec_vsx_st (vector signed int, int, vector signed int *);
void vec_vsx_st (vector signed int, int, int *);
void vec_vsx_st (vector unsigned int, int, vector unsigned int *);
void vec_vsx_st (vector unsigned int, int, unsigned int *);
void vec_vsx_st (vector bool int, int, vector bool int *);
void vec_vsx_st (vector bool int, int, unsigned int *);
void vec_vsx_st (vector bool int, int, int *);
void vec_vsx_st (vector signed short, int, vector signed short *);
void vec_vsx_st (vector signed short, int, short *);
void vec_vsx_st (vector unsigned short, int, vector unsigned short *);
void vec_vsx_st (vector unsigned short, int, unsigned short *);
void vec_vsx_st (vector bool short, int, vector bool short *);
void vec_vsx_st (vector bool short, int, unsigned short *);
void vec_vsx_st (vector pixel, int, vector pixel *);
void vec_vsx_st (vector pixel, int, unsigned short *);
void vec_vsx_st (vector pixel, int, short *);
void vec_vsx_st (vector bool short, int, short *);
void vec_vsx_st (vector signed char, int, vector signed char *);
void vec_vsx_st (vector signed char, int, signed char *);
void vec_vsx_st (vector unsigned char, int, vector unsigned char *);
void vec_vsx_st (vector unsigned char, int, unsigned char *);
void vec_vsx_st (vector bool char, int, vector bool char *);
void vec_vsx_st (vector bool char, int, unsigned char *);
void vec_vsx_st (vector bool char, int, signed char *);

vector double vec_xxpermdi (vector double, vector double, const int);
vector float vec_xxpermdi (vector float, vector float, const int);
vector long long vec_xxpermdi (vector long long, vector long long, const int);
vector unsigned long long vec_xxpermdi (vector unsigned long long,
                                        vector unsigned long long, const int);
vector int vec_xxpermdi (vector int, vector int, const int);
vector unsigned int vec_xxpermdi (vector unsigned int,
                                  vector unsigned int, const int);
vector short vec_xxpermdi (vector short, vector short, const int);
vector unsigned short vec_xxpermdi (vector unsigned short,
                                    vector unsigned short, const int);
vector signed char vec_xxpermdi (vector signed char, vector signed char,
                                 const int);
vector unsigned char vec_xxpermdi (vector unsigned char,
                                   vector unsigned char, const int);

vector double vec_xxsldi (vector double, vector double, int);
vector float vec_xxsldi (vector float, vector float, int);
vector long long vec_xxsldi (vector long long, vector long long, int);
vector unsigned long long vec_xxsldi (vector unsigned long long,
                                      vector unsigned long long, int);
vector int vec_xxsldi (vector int, vector int, int);
vector unsigned int vec_xxsldi (vector unsigned int, vector unsigned int, int);
vector short vec_xxsldi (vector short, vector short, int);
vector unsigned short vec_xxsldi (vector unsigned short,
                                  vector unsigned short, int);
vector signed char vec_xxsldi (vector signed char, vector signed char, int);
vector unsigned char vec_xxsldi (vector unsigned char,
                                 vector unsigned char, int);
@end smallexample

@samp{vec_ld}と@samp{vec_st}組み込み関数は、VSX命令セットが利用可能であっても常にAltiVec @samp{LVX}命令と@samp{STVX}命令を生成することに注意せよ。 @samp{vec_vsx_ld}および@samp{vec_vsx_st}組み込み関数は、常にVSX @samp{LXVD2X}、@samp{LXVW4X}、@samp{STXVD2X}、および@samp{STXVW4X}命令を生成する。

ベクトル/スカラー（power8ベクトル）命令セットへのISA 2.07の追加が利用可能な場合、以下の追加機能が32ビットターゲットと64ビットターゲットの両方で利用可能である。 64ビットのターゲットでは、@var{vector long long}の代わりに@var {vector long}、@var{vector bool long long}の代わりに@var{vector bool long}、@ var{vector unsigned long long}の代わりに@var{vector unsigned long}を使うことができる。

@smallexample
vector long long vec_abs (vector long long);

vector long long vec_add (vector long long, vector long long);
vector unsigned long long vec_add (vector unsigned long long,
                                   vector unsigned long long);

int vec_all_eq (vector long long, vector long long);
int vec_all_eq (vector unsigned long long, vector unsigned long long);
int vec_all_ge (vector long long, vector long long);
int vec_all_ge (vector unsigned long long, vector unsigned long long);
int vec_all_gt (vector long long, vector long long);
int vec_all_gt (vector unsigned long long, vector unsigned long long);
int vec_all_le (vector long long, vector long long);
int vec_all_le (vector unsigned long long, vector unsigned long long);
int vec_all_lt (vector long long, vector long long);
int vec_all_lt (vector unsigned long long, vector unsigned long long);
int vec_all_ne (vector long long, vector long long);
int vec_all_ne (vector unsigned long long, vector unsigned long long);

int vec_any_eq (vector long long, vector long long);
int vec_any_eq (vector unsigned long long, vector unsigned long long);
int vec_any_ge (vector long long, vector long long);
int vec_any_ge (vector unsigned long long, vector unsigned long long);
int vec_any_gt (vector long long, vector long long);
int vec_any_gt (vector unsigned long long, vector unsigned long long);
int vec_any_le (vector long long, vector long long);
int vec_any_le (vector unsigned long long, vector unsigned long long);
int vec_any_lt (vector long long, vector long long);
int vec_any_lt (vector unsigned long long, vector unsigned long long);
int vec_any_ne (vector long long, vector long long);
int vec_any_ne (vector unsigned long long, vector unsigned long long);

vector bool long long vec_cmpeq (vector bool long long, vector bool long long);

vector long long vec_eqv (vector long long, vector long long);
vector long long vec_eqv (vector bool long long, vector long long);
vector long long vec_eqv (vector long long, vector bool long long);
vector unsigned long long vec_eqv (vector unsigned long long,
                                   vector unsigned long long);
vector unsigned long long vec_eqv (vector bool long long,
                                   vector unsigned long long);
vector unsigned long long vec_eqv (vector unsigned long long,
                                   vector bool long long);
vector int vec_eqv (vector int, vector int);
vector int vec_eqv (vector bool int, vector int);
vector int vec_eqv (vector int, vector bool int);
vector unsigned int vec_eqv (vector unsigned int, vector unsigned int);
vector unsigned int vec_eqv (vector bool unsigned int,
                             vector unsigned int);
vector unsigned int vec_eqv (vector unsigned int,
                             vector bool unsigned int);
vector short vec_eqv (vector short, vector short);
vector short vec_eqv (vector bool short, vector short);
vector short vec_eqv (vector short, vector bool short);
vector unsigned short vec_eqv (vector unsigned short, vector unsigned short);
vector unsigned short vec_eqv (vector bool unsigned short,
                               vector unsigned short);
vector unsigned short vec_eqv (vector unsigned short,
                               vector bool unsigned short);
vector signed char vec_eqv (vector signed char, vector signed char);
vector signed char vec_eqv (vector bool signed char, vector signed char);
vector signed char vec_eqv (vector signed char, vector bool signed char);
vector unsigned char vec_eqv (vector unsigned char, vector unsigned char);
vector unsigned char vec_eqv (vector bool unsigned char, vector unsigned char);
vector unsigned char vec_eqv (vector unsigned char, vector bool unsigned char);

vector long long vec_max (vector long long, vector long long);
vector unsigned long long vec_max (vector unsigned long long,
                                   vector unsigned long long);

vector signed int vec_mergee (vector signed int, vector signed int);
vector unsigned int vec_mergee (vector unsigned int, vector unsigned int);
vector bool int vec_mergee (vector bool int, vector bool int);

vector signed int vec_mergeo (vector signed int, vector signed int);
vector unsigned int vec_mergeo (vector unsigned int, vector unsigned int);
vector bool int vec_mergeo (vector bool int, vector bool int);

vector long long vec_min (vector long long, vector long long);
vector unsigned long long vec_min (vector unsigned long long,
                                   vector unsigned long long);

vector signed long long vec_nabs (vector signed long long);

vector long long vec_nand (vector long long, vector long long);
vector long long vec_nand (vector bool long long, vector long long);
vector long long vec_nand (vector long long, vector bool long long);
vector unsigned long long vec_nand (vector unsigned long long,
                                    vector unsigned long long);
vector unsigned long long vec_nand (vector bool long long,
                                   vector unsigned long long);
vector unsigned long long vec_nand (vector unsigned long long,
                                    vector bool long long);
vector int vec_nand (vector int, vector int);
vector int vec_nand (vector bool int, vector int);
vector int vec_nand (vector int, vector bool int);
vector unsigned int vec_nand (vector unsigned int, vector unsigned int);
vector unsigned int vec_nand (vector bool unsigned int,
                              vector unsigned int);
vector unsigned int vec_nand (vector unsigned int,
                              vector bool unsigned int);
vector short vec_nand (vector short, vector short);
vector short vec_nand (vector bool short, vector short);
vector short vec_nand (vector short, vector bool short);
vector unsigned short vec_nand (vector unsigned short, vector unsigned short);
vector unsigned short vec_nand (vector bool unsigned short,
                                vector unsigned short);
vector unsigned short vec_nand (vector unsigned short,
                                vector bool unsigned short);
vector signed char vec_nand (vector signed char, vector signed char);
vector signed char vec_nand (vector bool signed char, vector signed char);
vector signed char vec_nand (vector signed char, vector bool signed char);
vector unsigned char vec_nand (vector unsigned char, vector unsigned char);
vector unsigned char vec_nand (vector bool unsigned char, vector unsigned char);
vector unsigned char vec_nand (vector unsigned char, vector bool unsigned char);

vector long long vec_orc (vector long long, vector long long);
vector long long vec_orc (vector bool long long, vector long long);
vector long long vec_orc (vector long long, vector bool long long);
vector unsigned long long vec_orc (vector unsigned long long,
                                   vector unsigned long long);
vector unsigned long long vec_orc (vector bool long long,
                                   vector unsigned long long);
vector unsigned long long vec_orc (vector unsigned long long,
                                   vector bool long long);
vector int vec_orc (vector int, vector int);
vector int vec_orc (vector bool int, vector int);
vector int vec_orc (vector int, vector bool int);
vector unsigned int vec_orc (vector unsigned int, vector unsigned int);
vector unsigned int vec_orc (vector bool unsigned int,
                             vector unsigned int);
vector unsigned int vec_orc (vector unsigned int,
                             vector bool unsigned int);
vector short vec_orc (vector short, vector short);
vector short vec_orc (vector bool short, vector short);
vector short vec_orc (vector short, vector bool short);
vector unsigned short vec_orc (vector unsigned short, vector unsigned short);
vector unsigned short vec_orc (vector bool unsigned short,
                               vector unsigned short);
vector unsigned short vec_orc (vector unsigned short,
                               vector bool unsigned short);
vector signed char vec_orc (vector signed char, vector signed char);
vector signed char vec_orc (vector bool signed char, vector signed char);
vector signed char vec_orc (vector signed char, vector bool signed char);
vector unsigned char vec_orc (vector unsigned char, vector unsigned char);
vector unsigned char vec_orc (vector bool unsigned char, vector unsigned char);
vector unsigned char vec_orc (vector unsigned char, vector bool unsigned char);

vector int vec_pack (vector long long, vector long long);
vector unsigned int vec_pack (vector unsigned long long,
                              vector unsigned long long);
vector bool int vec_pack (vector bool long long, vector bool long long);
vector float vec_pack (vector double, vector double);

vector int vec_packs (vector long long, vector long long);
vector unsigned int vec_packs (vector unsigned long long,
                               vector unsigned long long);

test_vsi_packsu_vssi_vssi (vector signed short x,

vector unsigned char vec_packsu (vector signed short, vector signed short )
vector unsigned char vec_packsu (vector unsigned short, vector unsigned short )
vector unsigned short int vec_packsu (vector signed int, vector signed int);
vector unsigned short int vec_packsu (vector unsigned int,
                                      vector unsigned int);
vector unsigned int vec_packsu (vector long long, vector long long);
vector unsigned int vec_packsu (vector unsigned long long,
                                vector unsigned long long);
vector unsigned int vec_packsu (vector signed long long,
                                vector signed long long);

vector unsigned char vec_popcnt (vector signed char);
vector unsigned char vec_popcnt (vector unsigned char);
vector unsigned short vec_popcnt (vector signed short);
vector unsigned short vec_popcnt (vector unsigned short);
vector unsigned int vec_popcnt (vector signed int);
vector unsigned int vec_popcnt (vector unsigned int);
vector unsigned long long vec_popcnt (vector signed long long);
vector unsigned long long vec_popcnt (vector unsigned long long);

vector long long vec_rl (vector long long,
                         vector unsigned long long);
vector long long vec_rl (vector unsigned long long,
                         vector unsigned long long);

vector long long vec_sl (vector long long, vector unsigned long long);
vector long long vec_sl (vector unsigned long long,
                         vector unsigned long long);

vector long long vec_sr (vector long long, vector unsigned long long);
vector unsigned long long char vec_sr (vector unsigned long long,
                                       vector unsigned long long);

vector long long vec_sra (vector long long, vector unsigned long long);
vector unsigned long long vec_sra (vector unsigned long long,
                                   vector unsigned long long);

vector long long vec_sub (vector long long, vector long long);
vector unsigned long long vec_sub (vector unsigned long long,
                                   vector unsigned long long);

vector long long vec_unpackh (vector int);
vector unsigned long long vec_unpackh (vector unsigned int);

vector long long vec_unpackl (vector int);
vector unsigned long long vec_unpackl (vector unsigned int);

vector long long vec_vaddudm (vector long long, vector long long);
vector long long vec_vaddudm (vector bool long long, vector long long);
vector long long vec_vaddudm (vector long long, vector bool long long);
vector unsigned long long vec_vaddudm (vector unsigned long long,
                                       vector unsigned long long);
vector unsigned long long vec_vaddudm (vector bool unsigned long long,
                                       vector unsigned long long);
vector unsigned long long vec_vaddudm (vector unsigned long long,
                                       vector bool unsigned long long);

vector long long vec_vbpermq (vector signed char, vector signed char);
vector long long vec_vbpermq (vector unsigned char, vector unsigned char);

vector unsigned char vec_bperm (vector unsigned char, vector unsigned char);
vector unsigned char vec_bperm (vector unsigned long long,
                                vector unsigned char);
vector unsigned long long vec_bperm (vector unsigned __int128,
                                     vector unsigned char);

vector long long vec_cntlz (vector long long);
vector unsigned long long vec_cntlz (vector unsigned long long);
vector int vec_cntlz (vector int);
vector unsigned int vec_cntlz (vector int);
vector short vec_cntlz (vector short);
vector unsigned short vec_cntlz (vector unsigned short);
vector signed char vec_cntlz (vector signed char);
vector unsigned char vec_cntlz (vector unsigned char);

vector long long vec_vclz (vector long long);
vector unsigned long long vec_vclz (vector unsigned long long);
vector int vec_vclz (vector int);
vector unsigned int vec_vclz (vector int);
vector short vec_vclz (vector short);
vector unsigned short vec_vclz (vector unsigned short);
vector signed char vec_vclz (vector signed char);
vector unsigned char vec_vclz (vector unsigned char);

vector signed char vec_vclzb (vector signed char);
vector unsigned char vec_vclzb (vector unsigned char);

vector long long vec_vclzd (vector long long);
vector unsigned long long vec_vclzd (vector unsigned long long);

vector short vec_vclzh (vector short);
vector unsigned short vec_vclzh (vector unsigned short);

vector int vec_vclzw (vector int);
vector unsigned int vec_vclzw (vector int);

vector signed char vec_vgbbd (vector signed char);
vector unsigned char vec_vgbbd (vector unsigned char);

vector long long vec_vmaxsd (vector long long, vector long long);

vector unsigned long long vec_vmaxud (vector unsigned long long,
                                      unsigned vector long long);

vector long long vec_vminsd (vector long long, vector long long);

vector unsigned long long vec_vminud (vector long long,
                                      vector long long);

vector int vec_vpksdss (vector long long, vector long long);
vector unsigned int vec_vpksdss (vector long long, vector long long);

vector unsigned int vec_vpkudus (vector unsigned long long,
                                 vector unsigned long long);

vector int vec_vpkudum (vector long long, vector long long);
vector unsigned int vec_vpkudum (vector unsigned long long,
                                 vector unsigned long long);
vector bool int vec_vpkudum (vector bool long long, vector bool long long);

vector long long vec_vpopcnt (vector long long);
vector unsigned long long vec_vpopcnt (vector unsigned long long);
vector int vec_vpopcnt (vector int);
vector unsigned int vec_vpopcnt (vector int);
vector short vec_vpopcnt (vector short);
vector unsigned short vec_vpopcnt (vector unsigned short);
vector signed char vec_vpopcnt (vector signed char);
vector unsigned char vec_vpopcnt (vector unsigned char);

vector signed char vec_vpopcntb (vector signed char);
vector unsigned char vec_vpopcntb (vector unsigned char);

vector long long vec_vpopcntd (vector long long);
vector unsigned long long vec_vpopcntd (vector unsigned long long);

vector short vec_vpopcnth (vector short);
vector unsigned short vec_vpopcnth (vector unsigned short);

vector int vec_vpopcntw (vector int);
vector unsigned int vec_vpopcntw (vector int);

vector long long vec_vrld (vector long long, vector unsigned long long);
vector unsigned long long vec_vrld (vector unsigned long long,
                                    vector unsigned long long);

vector long long vec_vsld (vector long long, vector unsigned long long);
vector long long vec_vsld (vector unsigned long long,
                           vector unsigned long long);

vector long long vec_vsrad (vector long long, vector unsigned long long);
vector unsigned long long vec_vsrad (vector unsigned long long,
                                     vector unsigned long long);

vector long long vec_vsrd (vector long long, vector unsigned long long);
vector unsigned long long char vec_vsrd (vector unsigned long long,
                                         vector unsigned long long);

vector long long vec_vsubudm (vector long long, vector long long);
vector long long vec_vsubudm (vector bool long long, vector long long);
vector long long vec_vsubudm (vector long long, vector bool long long);
vector unsigned long long vec_vsubudm (vector unsigned long long,
                                       vector unsigned long long);
vector unsigned long long vec_vsubudm (vector bool long long,
                                       vector unsigned long long);
vector unsigned long long vec_vsubudm (vector unsigned long long,
                                       vector bool long long);

vector long long vec_vupkhsw (vector int);
vector unsigned long long vec_vupkhsw (vector unsigned int);

vector long long vec_vupklsw (vector int);
vector unsigned long long vec_vupklsw (vector int);
@end smallexample

ベクトル/スカラー（power8ベクトル）命令セットへのISA 2.07の追加が利用可能である場合、以下の追加機能が64ビットターゲットに対して利用可能である。 これらの組み込み関数を使用するために、新しいベクトル型（@var{vector __int128_t}と@var{vector __uint128_t}）を使用して、@var{__ int128_t}型と@var{__ uint128_t}型を保持できる。

法線ベクトル抽出とセット操作は@var{vector __int128_t}型と@var{vector __int128_t}型で動作するが、インデックス値は0でなければならない。

@smallexample
vector __int128_t vec_vaddcuq (vector __int128_t, vector __int128_t);
vector __uint128_t vec_vaddcuq (vector __uint128_t, vector __uint128_t);

vector __int128_t vec_vadduqm (vector __int128_t, vector __int128_t);
vector __uint128_t vec_vadduqm (vector __uint128_t, vector __uint128_t);

vector __int128_t vec_vaddecuq (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vaddecuq (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vaddeuqm (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vaddeuqm (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vsubecuq (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vsubecuq (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vsubeuqm (vector __int128_t, vector __int128_t,
                                vector __int128_t);
vector __uint128_t vec_vsubeuqm (vector __uint128_t, vector __uint128_t,
                                 vector __uint128_t);

vector __int128_t vec_vsubcuq (vector __int128_t, vector __int128_t);
vector __uint128_t vec_vsubcuq (vector __uint128_t, vector __uint128_t);

__int128_t vec_vsubuqm (__int128_t, __int128_t);
__uint128_t vec_vsubuqm (__uint128_t, __uint128_t);

vector __int128_t __builtin_bcdadd (vector __int128_t, vector __int128_t);
int __builtin_bcdadd_lt (vector __int128_t, vector __int128_t);
int __builtin_bcdadd_eq (vector __int128_t, vector __int128_t);
int __builtin_bcdadd_gt (vector __int128_t, vector __int128_t);
int __builtin_bcdadd_ov (vector __int128_t, vector __int128_t);
vector __int128_t bcdsub (vector __int128_t, vector __int128_t);
int __builtin_bcdsub_lt (vector __int128_t, vector __int128_t);
int __builtin_bcdsub_eq (vector __int128_t, vector __int128_t);
int __builtin_bcdsub_gt (vector __int128_t, vector __int128_t);
int __builtin_bcdsub_ov (vector __int128_t, vector __int128_t);
@end smallexample

ISA 3.0命令セットの追加（@option {-mcpu = power9}）が利用可能な場合、

@smallexample
vector unsigned long long vec_bperm (vector unsigned long long,
                                     vector unsigned char);

vector bool char vec_cmpne (vector bool char, vector bool char);
vector bool char vec_cmpne (vector signed char, vector signed char);
vector bool char vec_cmpne (vector unsigned char, vector unsigned char);
vector bool int vec_cmpne (vector bool int, vector bool int);
vector bool int vec_cmpne (vector signed int, vector signed int);
vector bool int vec_cmpne (vector unsigned int, vector unsigned int);
vector bool long long vec_cmpne (vector bool long long, vector bool long long);
vector bool long long vec_cmpne (vector signed long long,
                                 vector signed long long);
vector bool long long vec_cmpne (vector unsigned long long,
                                 vector unsigned long long);
vector bool short vec_cmpne (vector bool short, vector bool short);
vector bool short vec_cmpne (vector signed short, vector signed short);
vector bool short vec_cmpne (vector unsigned short, vector unsigned short);
vector bool long long vec_cmpne (vector double, vector double);
vector bool int vec_cmpne (vector float, vector float);

vector float vec_extract_fp32_from_shorth (vector unsigned short);
vector float vec_extract_fp32_from_shortl (vector unsigned short);

vector long long vec_vctz (vector long long);
vector unsigned long long vec_vctz (vector unsigned long long);
vector int vec_vctz (vector int);
vector unsigned int vec_vctz (vector int);
vector short vec_vctz (vector short);
vector unsigned short vec_vctz (vector unsigned short);
vector signed char vec_vctz (vector signed char);
vector unsigned char vec_vctz (vector unsigned char);

vector signed char vec_vctzb (vector signed char);
vector unsigned char vec_vctzb (vector unsigned char);

vector long long vec_vctzd (vector long long);
vector unsigned long long vec_vctzd (vector unsigned long long);

vector short vec_vctzh (vector short);
vector unsigned short vec_vctzh (vector unsigned short);

vector int vec_vctzw (vector int);
vector unsigned int vec_vctzw (vector int);

vector unsigned long long vec_extract4b (vector unsigned char, const int);

vector unsigned char vec_insert4b (vector signed int, vector unsigned char,
                                   const int);
vector unsigned char vec_insert4b (vector unsigned int, vector unsigned char,
                                   const int);

vector unsigned int vec_parity_lsbb (vector signed int);
vector unsigned int vec_parity_lsbb (vector unsigned int);
vector unsigned __int128 vec_parity_lsbb (vector signed __int128);
vector unsigned __int128 vec_parity_lsbb (vector unsigned __int128);
vector unsigned long long vec_parity_lsbb (vector signed long long);
vector unsigned long long vec_parity_lsbb (vector unsigned long long);

vector int vec_vprtyb (vector int);
vector unsigned int vec_vprtyb (vector unsigned int);
vector long long vec_vprtyb (vector long long);
vector unsigned long long vec_vprtyb (vector unsigned long long);

vector int vec_vprtybw (vector int);
vector unsigned int vec_vprtybw (vector unsigned int);

vector long long vec_vprtybd (vector long long);
vector unsigned long long vec_vprtybd (vector unsigned long long);
@end smallexample

64ビットのターゲットでは、ISA 3.0の追加（@option{-mcpu=power9}）が利用可能な場合：

@smallexample
vector long vec_vprtyb (vector long);
vector unsigned long vec_vprtyb (vector unsigned long);
vector __int128_t vec_vprtyb (vector __int128_t);
vector __uint128_t vec_vprtyb (vector __uint128_t);

vector long vec_vprtybd (vector long);
vector unsigned long vec_vprtybd (vector unsigned long);

vector __int128_t vec_vprtybq (vector __int128_t);
vector __uint128_t vec_vprtybd (vector __uint128_t);
@end smallexample

次の組み込みベクトル関数は、PowerPCファミリのプロセッサでは、ISA 3.0以降（@option{-mcpu=power9}）から使用できる。
@smallexample
__vector unsigned char
vec_slv (__vector unsigned char src, __vector unsigned char shift_distance);
__vector unsigned char
vec_srv (__vector unsigned char src, __vector unsigned char shift_distance);
@end smallexample

@code{vec_slv}関数と@code{vec_srv}関数は、@code{src}引数と@code{shift_distance}引数のすべてのバイトに対して並列に動作する。 @code{vec_slv}の振る舞いは、要素0〜15が@code{src}配列の要素と同じで、要素16が0に等しい17の符号なし文字@code{slv_array}の一時的な配列が存在するかのようにである。@code{vec_slv}関数から返される結果は、Cの式@code{0xff & (*((unsigned short *)(slv_array + i)) << (0x07 & shift_distance[i]))}を使用して要素@code {i}が計算され、この結果の値が@code {unsigned char}型に変換された16の符号なし文字の@code{__vector}である。
@code {vec_srv}の振る舞いは、要素0が0で、要素1から16までが@code{src}の要素0から15に等しい17の符号なし文字の一時的な配列@code{srv_array}のようである。@code{vec_srv}関数から返される結果は、C式@code{0xff & (*((unsigned short *)(srv_array + i)) >> (0x07 & shift_distance[i]))}を使用して要素@code{i}が計算され、この結果値が@code{unsigned char}型に変換された16の符号なし文字の@code{__vector}である。

次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 3.0以降（@option{-mcpu=power9}）から使用できる。
@smallexample
__vector unsigned char
vec_absd (__vector unsigned char arg1, __vector unsigned char arg2);
__vector unsigned short
vec_absd (__vector unsigned short arg1, __vector unsigned short arg2);
__vector unsigned int
vec_absd (__vector unsigned int arg1, __vector unsigned int arg2);

__vector unsigned char
vec_absdb (__vector unsigned char arg1, __vector unsigned char arg2);
__vector unsigned short
vec_absdh (__vector unsigned short arg1, __vector unsigned short arg2);
__vector unsigned int
vec_absdw (__vector unsigned int arg1, __vector unsigned int arg2);
@end smallexample
@code{vec_absd}、@code{vec_absdh}、@code{vec_absdh}、および@code{vec_absdw}組み込み関数はそれぞれ、2つのベクトル引数に供給されるベクトル要素のペアの絶対差を計算し、絶対差をベクトル結果の対応する要素に配置する。
次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 3.0以降（@option{-mcpu=power9}）から使用できる。
@smallexample
__vector unsigned int
vec_extract_exp (__vector float source);
__vector unsigned long long int
vec_extract_exp (__vector double source);

__vector unsigned int
vec_extract_sig (__vector float source);
__vector unsigned long long int
vec_extract_sig (__vector double source);

__vector float
vec_insert_exp (__vector unsigned int significands,
                __vector unsigned int exponents);
__vector float
vec_insert_exp (__vector unsigned float significands,
                __vector unsigned int exponents);
__vector double
vec_insert_exp (__vector unsigned long long int significands,
                __vector unsigned long long int exponents);
__vector double
vec_insert_exp (__vector unsigned double significands,
                __vector unsigned long long int exponents);

__vector bool int vec_test_data_class (__vector float source,
                                       const int condition);
__vector bool long long int vec_test_data_class (__vector double source,
                                                 const int condition);
@end smallexample

@code{vec_extract_sig}と@code{vec_extract_exp}組み込み関数は、それぞれの@code{source}引数の有効数字とバイアスされた指数値を表すベクトルを返す。関数の@code{source}引数が@code{float}型のときに返される各ベクトル要素の@code{vec_extract_sig}によって返される結果ベクトル内では、対応する浮動小数点値は正規化された形式である。それ以外の場合、このビットは0に設定される。@code{source}引数が@code{double}型の場合、結果ベクタの各要素内の@code{0x10000000000000}ビットは同じ規則に従って設定される。仮数部の符号は、@code{vec_extract_sig}関数から返された結果には現れない。 符号ビットを抽出するには、第2引数ベクトルのすべての符号ビットが、その第1引数ベクトルの対応する要素からコピーされた符号ビットで上書きされる新しいベクトルを返す@code{vec_cpsgn}関数を使用する。 第2引数ベクトルの他の（符号のない）ビットはすべて変更されずに結果ベクトルにコピーされる。

@code{vec_insert_exp}組み込み関数は、@code{significands}引数と@code{exponents}引数の値を返されたベクトルの対応する要素に組み立てることによって構築された単精度または倍精度浮動小数点値のベクトルを返す。結果の各要素の符号は、@code{significands}引数内の対応するエントリの最上位ビットからコピーされる。@code{significands}引数の関連するビットは、整数型と浮動小数点型の両方で同じであることに注意せよ。結果の各要素の有効成分と指数成分は、対応する@code{significands}要素の最下位ビットと対応する@code{exponents}要素の最下位ビットで構成される。

@code{vec_test_data_class}組み込み関数は、@code{condition}引数で選択された条件の@code{source}ベクトルをテストした結果を表すベクトルを返す。 @code{condition}引数は、127を超えない値を持つコンパイル時定数でなければならない。@code{condition}引数は、次のような特徴を持つ異なる条件のテストを可能にするビットごとのビットマスクとしてエンコードされる。
@smallexample
0x40    Test for NaN
0x20    Test for +Infinity
0x10    Test for -Infinity
0x08    Test for +Zero
0x04    Test for -Zero
0x02    Test for +Denormal
0x01    Test for -Denormal
@end smallexample

有効なテスト条件のいずれかが真である場合、結果ベクトルの対応するエントリは-1である。 それ以外の場合（有効なテスト条件はすべて偽である場合）、結果ベクトルの対応するエントリは0になる。

次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 3.0以降（@option{-mcpu=power9}）から使用できる。
@smallexample
vector unsigned int vec_rlmi (vector unsigned int, vector unsigned int,
                              vector unsigned int);
vector unsigned long long vec_rlmi (vector unsigned long long,
                                    vector unsigned long long,
                                    vector unsigned long long);
vector unsigned int vec_rlnm (vector unsigned int, vector unsigned int,
                              vector unsigned int);
vector unsigned long long vec_rlnm (vector unsigned long long,
                                    vector unsigned long long,
                                    vector unsigned long long);
vector unsigned int vec_vrlnm (vector unsigned int, vector unsigned int);
vector unsigned long long vec_vrlnm (vector unsigned long long,
                                     vector unsigned long long);
@end smallexample

@code{vec_rlmi}の結果は、最初の引数ベクトルの各要素を左に回転し、マスクの下にそれを第2引数ベクトルに挿入することによって得られる。 3番目の引数ベクトルには、ビット11:15で始まるマスク、ビット19:23でのマスク終了、および各要素のビット27:31でのシフトカウントが含まれている。

@code{vec_rlnm}の結果は、最初の引数ベクトルの各要素を左に回転し、2番目と3番目の引数ベクトルで指定されたマスクとANDをとることで得られる。 第2引数ベクトルには、下位バイトの各要素のシフトカウントが格納される。 3番目の引数ベクトルには、順番のバイトの各要素のマスク終了点が含まれ、マスクは次の上位バイトで開始する。

@code{vec_vrlnm}の結果は、最初の引数ベクトルの各要素を左に回転し、マスクとANDをとることで得られる。 第2引数ベクトルは、ビット11:15で始まるマスクと、ビット19:23におけるマスクの終わりと、各要素のビット27:31でのシフト・カウントとを含む。

次の組み込み関数は、PowerPCファミリのプロセッサで、ISA 3.0以降（@option{-mcpu=power9}）から使用できる。
@smallexample
vector signed bool char vec_revb (vector signed char);
vector signed char vec_revb (vector signed char);
vector unsigned char vec_revb (vector unsigned char);
vector bool short vec_revb (vector bool short);
vector short vec_revb (vector short);
vector unsigned short vec_revb (vector unsigned short);
vector bool int vec_revb (vector bool int);
vector int vec_revb (vector int);
vector unsigned int vec_revb (vector unsigned int);
vector float vec_revb (vector float);
vector bool long long vec_revb (vector bool long long);
vector long long vec_revb (vector long long);
vector unsigned long long vec_revb (vector unsigned long long);
vector double vec_revb (vector double);
@end smallexample

64ビットのターゲットでは、ISA 3.0の追加（@option{-mcpu=power9}）が利用可能な場合：
@smallexample
vector long vec_revb (vector long);
vector unsigned long vec_revb (vector unsigned long);
vector __int128_t vec_revb (vector __int128_t);
vector __uint128_t vec_revb (vector __uint128_t);
@end smallexample

@code{vec_revb}組込み関数は、要素単位でバイトを逆転させる。 @code{vector unsigned char}のベクタまたは@code{vector signed char}は、ワード全体のバイトを反転する。

暗号化命令が有効な場合（@option{-mcrypto}または@option{-mcpu=power8}）、以下の組み込み関数が有効になる。

@smallexample
vector unsigned long long __builtin_crypto_vsbox (vector unsigned long long);

vector unsigned long long __builtin_crypto_vcipher (vector unsigned long long,
                                                    vector unsigned long long);

vector unsigned long long __builtin_crypto_vcipherlast
                                     (vector unsigned long long,
                                      vector unsigned long long);

vector unsigned long long __builtin_crypto_vncipher (vector unsigned long long,
                                                     vector unsigned long long);

vector unsigned long long __builtin_crypto_vncipherlast
                                     (vector unsigned long long,
                                      vector unsigned long long);

vector unsigned char __builtin_crypto_vpermxor (vector unsigned char,
                                                vector unsigned char,
                                                vector unsigned char);

vector unsigned short __builtin_crypto_vpermxor (vector unsigned short,
                                                 vector unsigned short,
                                                 vector unsigned short);

vector unsigned int __builtin_crypto_vpermxor (vector unsigned int,
                                               vector unsigned int,
                                               vector unsigned int);

vector unsigned long long __builtin_crypto_vpermxor (vector unsigned long long,
                                                     vector unsigned long long,
                                                     vector unsigned long long);

vector unsigned char __builtin_crypto_vpmsumb (vector unsigned char,
                                               vector unsigned char);

vector unsigned short __builtin_crypto_vpmsumb (vector unsigned short,
                                                vector unsigned short);

vector unsigned int __builtin_crypto_vpmsumb (vector unsigned int,
                                              vector unsigned int);

vector unsigned long long __builtin_crypto_vpmsumb (vector unsigned long long,
                                                    vector unsigned long long);

vector unsigned long long __builtin_crypto_vshasigmad
                               (vector unsigned long long, int, int);

vector unsigned int __builtin_crypto_vshasigmaw (vector unsigned int,
                                                 int, int);
@end smallexample

@var{__builtin_crypto_vshasigmad}と@var{__builtin_crypto_vshasigmaw}の2番目の引数は、0または1の定数でなければならない。これらの組み込み関数の3番目の引数は、0から15の範囲の定数でなければならない。

ISA 3.0命令セットの追加が有効な場合（@option{-mcpu=power9}）、以下の追加機能が32ビットと64ビットのターゲットで使用できる。

@smallexample
vector short vec_xl (int, vector short *);
vector short vec_xl (int, short *);
vector unsigned short vec_xl (int, vector unsigned short *);
vector unsigned short vec_xl (int, unsigned short *);
vector char vec_xl (int, vector char *);
vector char vec_xl (int, char *);
vector unsigned char vec_xl (int, vector unsigned char *);
vector unsigned char vec_xl (int, unsigned char *);

void vec_xst (vector short, int, vector short *);
void vec_xst (vector short, int, short *);
void vec_xst (vector unsigned short, int, vector unsigned short *);
void vec_xst (vector unsigned short, int, unsigned short *);
void vec_xst (vector char, int, vector char *);
void vec_xst (vector char, int, char *);
void vec_xst (vector unsigned char, int, vector unsigned char *);
void vec_xst (vector unsigned char, int, unsigned char *);
@end smallexample

@node PowerPC Hardware Transactional Memory Built-in Functions
@subsection PowerPCハードウェアトランザクションメモリー組み込み関数
GCCは、PowerPCファミリのプロセッサ（POWER8など）の一部で利用可能なハードウェアトランザクションメモリ（HTM）命令にアクセスするための2つのインタフェースを提供している。 2つのインタフェースは、PowerPC特有の組み込み関数と、PowerPCとS / 390の間で共通のインライン関数で構成されたより高レベルのインタフェースで構成された低レベルのインタフェースになっている。

@subsubsection PowerPC HTM低レベル組み込み関数

CPUが「power8」以降の@option{-mhtm}または@option{-mcpu=CPU}で、以下の低レベル組み込み関数を利用できる。 それらはすべて、名前の一部である機械命令を生成する。

HTMの組み込み関数（@code{__builtin_tbegin}を除く）は、関連するハードウェア命令によって設定された4ビットの条件レジスタの値をすべて返す。 ヘッダーファイル@code{htmintrin.h}は、戻り値を解読するために使用できるマクロを定義している。 @code{__builtin_tbegin}組み込み関数は、トランザクションが正常に開始されたかどうかに応じて、単純な真または偽の値を返す。 組み込み関数の引数は、組み込みハードウェア命令のオペランドの型と順序に正確に一致するが、組み込み関数の@code{__builtin_tcheck}は入力引数をとらない。各命令のオペランドの説明については、ISAのマニュアルを参照せよ。

@smallexample
unsigned int __builtin_tbegin (unsigned int)
unsigned int __builtin_tend (unsigned int)

unsigned int __builtin_tabort (unsigned int)
unsigned int __builtin_tabortdc (unsigned int, unsigned int, unsigned int)
unsigned int __builtin_tabortdci (unsigned int, unsigned int, int)
unsigned int __builtin_tabortwc (unsigned int, unsigned int, unsigned int)
unsigned int __builtin_tabortwci (unsigned int, unsigned int, int)

unsigned int __builtin_tcheck (void)
unsigned int __builtin_treclaim (unsigned int)
unsigned int __builtin_trechkpt (void)
unsigned int __builtin_tsr (unsigned int)
@end smallexample

上記のHTM組み込み関数に加えて、HTM命令のいくつかの一般的な拡張ニーモニックの組み込み関数を追加した。

@smallexample
unsigned int __builtin_tendall (void)
unsigned int __builtin_tresume (void)
unsigned int __builtin_tsuspend (void)
@end smallexample

上記のHTM組み込み関数のセマンティクスは、クリティカルセクションで使用されるロックセマンティクスを模倣する必要があることに注意せよ。新しいトランザクションの作成や中断されたトランザクションの再起動に使用される組み込み関数は、セマンティクスのようなロック取得を持つ必要がある一方、トランザクションを終了または中断する組み込み関数はセマンティクスのようにロックを解放する必要がある。具体的には、これはC++11で指定されたロックセマンティクスを模倣する必要がある。ロック取得は、0を返す__atomic_exchange_n(&globallock,1,__ATOMIC_ACQUIRE)の実行と同じであり、ロック解除は、すべてのトランザクションで使用される暗黙の実装定義のロックである、グローバルロックが__atomic_store(&globallock,0,__ATOMIC_RELEASE)の実行の場合と同じである。組み込み関数に関連するHTM命令は、本質的に、必要な正しい取得と解放のハードウェア障壁を提供する。 しかし、コンパイラは、セマンティクスに違反するような方法で、組み込み関数間でロードとストアを移動することも禁止されなければならない。 これは、関連付けられたHTM命令にメモリバリアを追加することによって達成されている（これは、取得セマンティクスとリリースセマンティクスを提供する控えめなアプローチである）。以前のバージョンのコンパイラは、HTM命令をメモリバリアとして扱わなった。 現在のコンパイラがHTM命令をメモリバリアとして扱うかどうかを判断するために使用できる@code{__ TM_FENCE__}マクロが追加された。 これにより、古いバージョンのコンパイラを使用しているときに、コードにメモリバリアを明示的に追加することができる。

HTM固有の専用レジスタにアクセスするには、次の組み込み関数セットを使用できる。

@smallexample
unsigned long __builtin_get_texasr (void)
unsigned long __builtin_get_texasru (void)
unsigned long __builtin_get_tfhar (void)
unsigned long __builtin_get_tfiar (void)

void __builtin_set_texasr (unsigned long);
void __builtin_set_texasru (unsigned long);
void __builtin_set_tfhar (unsigned long);
void __builtin_set_tfiar (unsigned long);
@end smallexample

これらの低レベル組み込み関数の使用例は次のようになる。

@smallexample
#include <htmintrin.h>

int num_retries = 10;

while (1)
  @{
    if (__builtin_tbegin (0))
      @{
        /* Transaction State Initiated.  */
        if (is_locked (lock))
          __builtin_tabort (0);
        ... transaction code...
        __builtin_tend (0);
        break;
      @}
    else
      @{
        /* Transaction State Failed.  Use locks if the transaction
           failure is "persistent" or we've tried too many times.  */
        if (num_retries-- <= 0
            || _TEXASRU_FAILURE_PERSISTENT (__builtin_get_texasru ()))
          @{
            acquire_lock (lock);
            ... non transactional fallback path...
            release_lock (lock);
            break;
          @}
      @}
  @}
@end smallexample

@code{CR0}に格納されているMachine Status Register（MSR）の2ビットTransaction Stateフィールドの値を返す最後の組み込み関数が1つ追加された。

@smallexample
unsigned long __builtin_ttest (void)
@end smallexample

この組み込み関数を使用して、次のコード例を使用して現在のトランザクション状態を判断できる。

@smallexample
#include <htmintrin.h>

unsigned char tx_state = _HTM_STATE (__builtin_ttest ());

if (tx_state == _HTM_TRANSACTIONAL)
  @{
    /* Code to use in transactional state.  */
  @}
else if (tx_state == _HTM_NONTRANSACTIONAL)
  @{
    /* Code to use in non-transactional state.  */
  @}
else if (tx_state == _HTM_SUSPENDED)
  @{
    /* Code to use in transaction suspended state.  */
  @}
@end smallexample

@subsubsection PowerPC HTM高レベルインライン関数

次の高レベルHTMインタフェースは、@code{<htmxlintrin.h>}をインクロードして、@option{-mhtm}またはCPUが「power8」以降の@option{-mcpu=CPU}を使用することで利用可能になる。 このインタフェースはPowerPCとS/390の間で共通であり、ユーザーはいずれかのシステムでコンパイルして実行できる1つのHTMソース実装を記述できる。

@smallexample
long __TM_simple_begin (void)
long __TM_begin (void* const TM_buff)
long __TM_end (void)
void __TM_abort (void)
void __TM_named_abort (unsigned char const code)
void __TM_resume (void)
void __TM_suspend (void)

long __TM_is_user_abort (void* const TM_buff)
long __TM_is_named_user_abort (void* const TM_buff, unsigned char *code)
long __TM_is_illegal (void* const TM_buff)
long __TM_is_footprint_exceeded (void* const TM_buff)
long __TM_nesting_depth (void* const TM_buff)
long __TM_is_nested_too_deep(void* const TM_buff)
long __TM_is_conflict(void* const TM_buff)
long __TM_is_failure_persistent(void* const TM_buff)
long __TM_failure_address(void* const TM_buff)
long long __TM_failure_code(void* const TM_buff)
@end smallexample

これらの共通のHTMインライン関数セットを使用して、PowerPCまたはS / 390のいずれかで動作する前のセクションで、より移植性の高いHTMの例を作成することができる。

@smallexample
#include <htmxlintrin.h>

int num_retries = 10;
TM_buff_type TM_buff;

while (1)
  @{
    if (__TM_begin (TM_buff) == _HTM_TBEGIN_STARTED)
      @{
        /* Transaction State Initiated.  */
        if (is_locked (lock))
          __TM_abort ();
        ... transaction code...
        __TM_end ();
        break;
      @}
    else
      @{
        /* Transaction State Failed.  Use locks if the transaction
           failure is "persistent" or we've tried too many times.  */
        if (num_retries-- <= 0
            || __TM_is_failure_persistent (TM_buff))
          @{
            acquire_lock (lock);
            ... non transactional fallback path...
            release_lock (lock);
            break;
          @}
      @}
  @}
@end smallexample

@node PowerPC Atomic Memory Operation Functions
@subsection PowerPCアトミックメモリー操作関数
PowerPCのISA 3.0は、新しいアトミックメモリ操作（amo）命令を追加した。 GCCは、64ビット環境でこれらの命令をサポートしている。 すべての関数はインクルードファイル@code{amo.h}で宣言されている。

サポートしている関数は：

@smallexample
#include <amo.h>

uint32_t amo_lwat_add (uint32_t *, uint32_t);
uint32_t amo_lwat_xor (uint32_t *, uint32_t);
uint32_t amo_lwat_ior (uint32_t *, uint32_t);
uint32_t amo_lwat_and (uint32_t *, uint32_t);
uint32_t amo_lwat_umax (uint32_t *, uint32_t);
uint32_t amo_lwat_umin (uint32_t *, uint32_t);
uint32_t amo_lwat_swap (uint32_t *, uint32_t);

int32_t amo_lwat_sadd (int32_t *, int32_t);
int32_t amo_lwat_smax (int32_t *, int32_t);
int32_t amo_lwat_smin (int32_t *, int32_t);
int32_t amo_lwat_sswap (int32_t *, int32_t);

uint64_t amo_ldat_add (uint64_t *, uint64_t);
uint64_t amo_ldat_xor (uint64_t *, uint64_t);
uint64_t amo_ldat_ior (uint64_t *, uint64_t);
uint64_t amo_ldat_and (uint64_t *, uint64_t);
uint64_t amo_ldat_umax (uint64_t *, uint64_t);
uint64_t amo_ldat_umin (uint64_t *, uint64_t);
uint64_t amo_ldat_swap (uint64_t *, uint64_t);

int64_t amo_ldat_sadd (int64_t *, int64_t);
int64_t amo_ldat_smax (int64_t *, int64_t);
int64_t amo_ldat_smin (int64_t *, int64_t);
int64_t amo_ldat_sswap (int64_t *, int64_t);

void amo_stwat_add (uint32_t *, uint32_t);
void amo_stwat_xor (uint32_t *, uint32_t);
void amo_stwat_ior (uint32_t *, uint32_t);
void amo_stwat_and (uint32_t *, uint32_t);
void amo_stwat_umax (uint32_t *, uint32_t);
void amo_stwat_umin (uint32_t *, uint32_t);

void amo_stwat_sadd (int32_t *, int32_t);
void amo_stwat_smax (int32_t *, int32_t);
void amo_stwat_smin (int32_t *, int32_t);

void amo_stdat_add (uint64_t *, uint64_t);
void amo_stdat_xor (uint64_t *, uint64_t);
void amo_stdat_ior (uint64_t *, uint64_t);
void amo_stdat_and (uint64_t *, uint64_t);
void amo_stdat_umax (uint64_t *, uint64_t);
void amo_stdat_umin (uint64_t *, uint64_t);

void amo_stdat_sadd (int64_t *, int64_t);
void amo_stdat_smax (int64_t *, int64_t);
void amo_stdat_smin (int64_t *, int64_t);
@end smallexample

@node RX Built-in Functions
@subsection RX組み込み関数
GCCは、組み込み関数を使用してCプログラミング言語で表現できないRX命令の一部をサポートしている。 次の機能がサポートされている。

@deftypefn {Built-in Function}  void __builtin_rx_brk (void)
@code {brk}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_clrpsw (int)
@code{clrpsw}マシン命令を生成し、プロセッサステータスワードの指定されたビットをクリアする。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_int (int)
@code {int}マシン命令を生成して、指定された値の割り込みを生成する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_machi (int, int)
@code{machi}マシン命令を生成して、2つの引数の上位16ビットに累算器を乗算した結果を加算する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_maclo (int, int)
@code{maclo}マシン命令を生成して、2つの引数の下位16ビットに累算器を乗算した結果を加算する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mulhi (int, int)
@code{mulhi}マシン命令を生成して、2つの引数の上位16ビットに累算器を乗算した結果を格納する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mullo (int, int)
@code {mullo}マシン命令を生成して、2つの引数の下位16ビットに累算器を掛けた結果を置く。
@end deftypefn

@deftypefn {Built-in Function}  int  __builtin_rx_mvfachi (void)
@code {mvfachi}マシン命令を生成し、アキュムレータの上位32ビットを読み込む。
@end deftypefn

@deftypefn {Built-in Function}  int  __builtin_rx_mvfacmi (void)
@code {mvfacmi}マシン命令を生成し、アキュムレータの中央の32ビットを読み込む。
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_rx_mvfc (int)
@code{mvfc}マシン命令を生成し、引数に指定された制御レジスタを読み取り、その値を返す。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtachi (int)
アキュムレータの上位32ビットを設定する@code{mvtachi}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtaclo (int)
@code {mvtaclo}マシン命令を生成し、アキュムレータの下位32ビットを設定する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtc (int reg, int val)
制御レジスタ番号@code{reg}を@code{val}に設定する@code{mvtc}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_mvtipl (int)
@code{mvtipl}マシン命令を生成し、割り込みの優先順位を設定する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_racw (int)
指定されたモードに従ってアキュムレータを丸める@code{racw}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_rx_revw (int)
ビット0-7が現在ビット8~15を占めその逆も同様であり、ビット16~23がビット24~31を占め、その逆もまた同様であるようにするように、引数のバイトをスワップする@code{revw}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_rmpa (void)
繰り返しの乗算と累算のシーケンスを開始する@code{rmpa}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_round (float)
浮動小数点ステータスワードレジスタに設定されている現在の丸めモードに従って丸められた浮動小数点引数を返す@code{round}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  int __builtin_rx_sat (int)
引数の飽和値を返す@code{sat}マシン命令を生成する。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_setpsw (int)
@code{setpsw}マシン命令を生成し、プロセッサステータスワードの指定されたビットをセットする。
@end deftypefn

@deftypefn {Built-in Function}  void __builtin_rx_wait (void)
@code {wait}マシン命令を生成する。
@end deftypefn

@node S/390 System z Built-in Functions
@subsection S/390 System z Built-in Functions
@deftypefn {Built-in Function} int __builtin_tbegin (void*)
Generates the @code{tbegin} machine instruction starting a
non-constrained hardware transaction.  If the parameter is non-NULL the
memory area is used to store the transaction diagnostic buffer and
will be passed as first operand to @code{tbegin}.  This buffer can be
defined using the @code{struct __htm_tdb} C struct defined in
@code{htmintrin.h} and must reside on a double-word boundary.  The
second tbegin operand is set to @code{0xff0c}. This enables
save/restore of all GPRs and disables aborts for FPR and AR
manipulations inside the transaction body.  The condition code set by
the tbegin instruction is returned as integer value.  The tbegin
instruction by definition overwrites the content of all FPRs.  The
compiler will generate code which saves and restores the FPRs.  For
soft-float code it is recommended to used the @code{*_nofloat}
variant.  In order to prevent a TDB from being written it is required
to pass a constant zero value as parameter.  Passing a zero value
through a variable is not sufficient.  Although modifications of
access registers inside the transaction will not trigger an
transaction abort it is not supported to actually modify them.  Access
registers do not get saved when entering a transaction. They will have
undefined state when reaching the abort code.
@end deftypefn

Macros for the possible return codes of tbegin are defined in the
@code{htmintrin.h} header file:

@table @code
@item _HTM_TBEGIN_STARTED
@code{tbegin} has been executed as part of normal processing.  The
transaction body is supposed to be executed.
@item _HTM_TBEGIN_INDETERMINATE
The transaction was aborted due to an indeterminate condition which
might be persistent.
@item _HTM_TBEGIN_TRANSIENT
The transaction aborted due to a transient failure.  The transaction
should be re-executed in that case.
@item _HTM_TBEGIN_PERSISTENT
The transaction aborted due to a persistent failure.  Re-execution
under same circumstances will not be productive.
@end table

@defmac _HTM_FIRST_USER_ABORT_CODE
The @code{_HTM_FIRST_USER_ABORT_CODE} defined in @code{htmintrin.h}
specifies the first abort code which can be used for
@code{__builtin_tabort}.  Values below this threshold are reserved for
machine use.
@end defmac

@deftp {Data type} {struct __htm_tdb}
The @code{struct __htm_tdb} defined in @code{htmintrin.h} describes
the structure of the transaction diagnostic block as specified in the
Principles of Operation manual chapter 5-91.
@end deftp

@deftypefn {Built-in Function} int __builtin_tbegin_nofloat (void*)
Same as @code{__builtin_tbegin} but without FPR saves and restores.
Using this variant in code making use of FPRs will leave the FPRs in
undefined state when entering the transaction abort handler code.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tbegin_retry (void*, int)
In addition to @code{__builtin_tbegin} a loop for transient failures
is generated.  If tbegin returns a condition code of 2 the transaction
will be retried as often as specified in the second argument.  The
perform processor assist instruction is used to tell the CPU about the
number of fails so far.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tbegin_retry_nofloat (void*, int)
Same as @code{__builtin_tbegin_retry} but without FPR saves and
restores.  Using this variant in code making use of FPRs will leave
the FPRs in undefined state when entering the transaction abort
handler code.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_tbeginc (void)
Generates the @code{tbeginc} machine instruction starting a constrained
hardware transaction.  The second operand is set to @code{0xff08}.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tend (void)
Generates the @code{tend} machine instruction finishing a transaction
and making the changes visible to other threads.  The condition code
generated by tend is returned as integer value.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_tabort (int)
Generates the @code{tabort} machine instruction with the specified
abort code.  Abort codes from 0 through 255 are reserved and will
result in an error message.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_tx_assist (int)
Generates the @code{ppa rX,rY,1} machine instruction.  Where the
integer parameter is loaded into rX and a value of zero is loaded into
rY.  The integer parameter specifies the number of times the
transaction repeatedly aborted.
@end deftypefn

@deftypefn {Built-in Function} int __builtin_tx_nesting_depth (void)
Generates the @code{etnd} machine instruction.  The current nesting
depth is returned as integer value.  For a nesting depth of 0 the code
is not executed as part of an transaction.
@end deftypefn

@deftypefn {Built-in Function} void __builtin_non_tx_store (uint64_t *, uint64_t)

Generates the @code{ntstg} machine instruction.  The second argument
is written to the first arguments location.  The store operation will
not be rolled-back in case of an transaction abort.
@end deftypefn

@node SH Built-in Functions
@subsection SH Built-in Functions
The following built-in functions are supported on the SH1, SH2, SH3 and SH4
families of processors:

@deftypefn {Built-in Function} {void} __builtin_set_thread_pointer (void *@var{ptr})
Sets the @samp{GBR} register to the specified value @var{ptr}.  This is usually
used by system code that manages threads and execution contexts.  The compiler
normally does not generate code that modifies the contents of @samp{GBR} and
thus the value is preserved across function calls.  Changing the @samp{GBR}
value in user code must be done with caution, since the compiler might use
@samp{GBR} in order to access thread local variables.

@end deftypefn

@deftypefn {Built-in Function} {void *} __builtin_thread_pointer (void)
Returns the value that is currently set in the @samp{GBR} register.
Memory loads and stores that use the thread pointer as a base address are
turned into @samp{GBR} based displacement loads and stores, if possible.
For example:
@smallexample
struct my_tcb
@{
   int a, b, c, d, e;
@};

int get_tcb_value (void)
@{
  // Generate @samp{mov.l @@(8,gbr),r0} instruction
  return ((my_tcb*)__builtin_thread_pointer ())->c;
@}

@end smallexample
@end deftypefn

@deftypefn {Built-in Function} {unsigned int} __builtin_sh_get_fpscr (void)
Returns the value that is currently set in the @samp{FPSCR} register.
@end deftypefn

@deftypefn {Built-in Function} {void} __builtin_sh_set_fpscr (unsigned int @var{val})
Sets the @samp{FPSCR} register to the specified value @var{val}, while
preserving the current values of the FR, SZ and PR bits.
@end deftypefn

@node SPARC VIS Built-in Functions
@subsection SPARC VIS Built-in Functions

GCC supports SIMD operations on the SPARC using both the generic vector
extensions (@pxref{Vector Extensions}) as well as built-in functions for
the SPARC Visual Instruction Set (VIS).  When you use the @option{-mvis}
switch, the VIS extension is exposed as the following built-in functions:

@smallexample
typedef int v1si __attribute__ ((vector_size (4)));
typedef int v2si __attribute__ ((vector_size (8)));
typedef short v4hi __attribute__ ((vector_size (8)));
typedef short v2hi __attribute__ ((vector_size (4)));
typedef unsigned char v8qi __attribute__ ((vector_size (8)));
typedef unsigned char v4qi __attribute__ ((vector_size (4)));

void __builtin_vis_write_gsr (int64_t);
int64_t __builtin_vis_read_gsr (void);

void * __builtin_vis_alignaddr (void *, long);
void * __builtin_vis_alignaddrl (void *, long);
int64_t __builtin_vis_faligndatadi (int64_t, int64_t);
v2si __builtin_vis_faligndatav2si (v2si, v2si);
v4hi __builtin_vis_faligndatav4hi (v4si, v4si);
v8qi __builtin_vis_faligndatav8qi (v8qi, v8qi);

v4hi __builtin_vis_fexpand (v4qi);

v4hi __builtin_vis_fmul8x16 (v4qi, v4hi);
v4hi __builtin_vis_fmul8x16au (v4qi, v2hi);
v4hi __builtin_vis_fmul8x16al (v4qi, v2hi);
v4hi __builtin_vis_fmul8sux16 (v8qi, v4hi);
v4hi __builtin_vis_fmul8ulx16 (v8qi, v4hi);
v2si __builtin_vis_fmuld8sux16 (v4qi, v2hi);
v2si __builtin_vis_fmuld8ulx16 (v4qi, v2hi);

v4qi __builtin_vis_fpack16 (v4hi);
v8qi __builtin_vis_fpack32 (v2si, v8qi);
v2hi __builtin_vis_fpackfix (v2si);
v8qi __builtin_vis_fpmerge (v4qi, v4qi);

int64_t __builtin_vis_pdist (v8qi, v8qi, int64_t);

long __builtin_vis_edge8 (void *, void *);
long __builtin_vis_edge8l (void *, void *);
long __builtin_vis_edge16 (void *, void *);
long __builtin_vis_edge16l (void *, void *);
long __builtin_vis_edge32 (void *, void *);
long __builtin_vis_edge32l (void *, void *);

long __builtin_vis_fcmple16 (v4hi, v4hi);
long __builtin_vis_fcmple32 (v2si, v2si);
long __builtin_vis_fcmpne16 (v4hi, v4hi);
long __builtin_vis_fcmpne32 (v2si, v2si);
long __builtin_vis_fcmpgt16 (v4hi, v4hi);
long __builtin_vis_fcmpgt32 (v2si, v2si);
long __builtin_vis_fcmpeq16 (v4hi, v4hi);
long __builtin_vis_fcmpeq32 (v2si, v2si);

v4hi __builtin_vis_fpadd16 (v4hi, v4hi);
v2hi __builtin_vis_fpadd16s (v2hi, v2hi);
v2si __builtin_vis_fpadd32 (v2si, v2si);
v1si __builtin_vis_fpadd32s (v1si, v1si);
v4hi __builtin_vis_fpsub16 (v4hi, v4hi);
v2hi __builtin_vis_fpsub16s (v2hi, v2hi);
v2si __builtin_vis_fpsub32 (v2si, v2si);
v1si __builtin_vis_fpsub32s (v1si, v1si);

long __builtin_vis_array8 (long, long);
long __builtin_vis_array16 (long, long);
long __builtin_vis_array32 (long, long);
@end smallexample

When you use the @option{-mvis2} switch, the VIS version 2.0 built-in
functions also become available:

@smallexample
long __builtin_vis_bmask (long, long);
int64_t __builtin_vis_bshuffledi (int64_t, int64_t);
v2si __builtin_vis_bshufflev2si (v2si, v2si);
v4hi __builtin_vis_bshufflev2si (v4hi, v4hi);
v8qi __builtin_vis_bshufflev2si (v8qi, v8qi);

long __builtin_vis_edge8n (void *, void *);
long __builtin_vis_edge8ln (void *, void *);
long __builtin_vis_edge16n (void *, void *);
long __builtin_vis_edge16ln (void *, void *);
long __builtin_vis_edge32n (void *, void *);
long __builtin_vis_edge32ln (void *, void *);
@end smallexample

When you use the @option{-mvis3} switch, the VIS version 3.0 built-in
functions also become available:

@smallexample
void __builtin_vis_cmask8 (long);
void __builtin_vis_cmask16 (long);
void __builtin_vis_cmask32 (long);

v4hi __builtin_vis_fchksm16 (v4hi, v4hi);

v4hi __builtin_vis_fsll16 (v4hi, v4hi);
v4hi __builtin_vis_fslas16 (v4hi, v4hi);
v4hi __builtin_vis_fsrl16 (v4hi, v4hi);
v4hi __builtin_vis_fsra16 (v4hi, v4hi);
v2si __builtin_vis_fsll16 (v2si, v2si);
v2si __builtin_vis_fslas16 (v2si, v2si);
v2si __builtin_vis_fsrl16 (v2si, v2si);
v2si __builtin_vis_fsra16 (v2si, v2si);

long __builtin_vis_pdistn (v8qi, v8qi);

v4hi __builtin_vis_fmean16 (v4hi, v4hi);

int64_t __builtin_vis_fpadd64 (int64_t, int64_t);
int64_t __builtin_vis_fpsub64 (int64_t, int64_t);

v4hi __builtin_vis_fpadds16 (v4hi, v4hi);
v2hi __builtin_vis_fpadds16s (v2hi, v2hi);
v4hi __builtin_vis_fpsubs16 (v4hi, v4hi);
v2hi __builtin_vis_fpsubs16s (v2hi, v2hi);
v2si __builtin_vis_fpadds32 (v2si, v2si);
v1si __builtin_vis_fpadds32s (v1si, v1si);
v2si __builtin_vis_fpsubs32 (v2si, v2si);
v1si __builtin_vis_fpsubs32s (v1si, v1si);

long __builtin_vis_fucmple8 (v8qi, v8qi);
long __builtin_vis_fucmpne8 (v8qi, v8qi);
long __builtin_vis_fucmpgt8 (v8qi, v8qi);
long __builtin_vis_fucmpeq8 (v8qi, v8qi);

float __builtin_vis_fhadds (float, float);
double __builtin_vis_fhaddd (double, double);
float __builtin_vis_fhsubs (float, float);
double __builtin_vis_fhsubd (double, double);
float __builtin_vis_fnhadds (float, float);
double __builtin_vis_fnhaddd (double, double);

int64_t __builtin_vis_umulxhi (int64_t, int64_t);
int64_t __builtin_vis_xmulx (int64_t, int64_t);
int64_t __builtin_vis_xmulxhi (int64_t, int64_t);
@end smallexample

When you use the @option{-mvis4} switch, the VIS version 4.0 built-in
functions also become available:

@smallexample
v8qi __builtin_vis_fpadd8 (v8qi, v8qi);
v8qi __builtin_vis_fpadds8 (v8qi, v8qi);
v8qi __builtin_vis_fpaddus8 (v8qi, v8qi);
v4hi __builtin_vis_fpaddus16 (v4hi, v4hi);

v8qi __builtin_vis_fpsub8 (v8qi, v8qi);
v8qi __builtin_vis_fpsubs8 (v8qi, v8qi);
v8qi __builtin_vis_fpsubus8 (v8qi, v8qi);
v4hi __builtin_vis_fpsubus16 (v4hi, v4hi);

long __builtin_vis_fpcmple8 (v8qi, v8qi);
long __builtin_vis_fpcmpgt8 (v8qi, v8qi);
long __builtin_vis_fpcmpule16 (v4hi, v4hi);
long __builtin_vis_fpcmpugt16 (v4hi, v4hi);
long __builtin_vis_fpcmpule32 (v2si, v2si);
long __builtin_vis_fpcmpugt32 (v2si, v2si);

v8qi __builtin_vis_fpmax8 (v8qi, v8qi);
v4hi __builtin_vis_fpmax16 (v4hi, v4hi);
v2si __builtin_vis_fpmax32 (v2si, v2si);

v8qi __builtin_vis_fpmaxu8 (v8qi, v8qi);
v4hi __builtin_vis_fpmaxu16 (v4hi, v4hi);
v2si __builtin_vis_fpmaxu32 (v2si, v2si);


v8qi __builtin_vis_fpmin8 (v8qi, v8qi);
v4hi __builtin_vis_fpmin16 (v4hi, v4hi);
v2si __builtin_vis_fpmin32 (v2si, v2si);

v8qi __builtin_vis_fpminu8 (v8qi, v8qi);
v4hi __builtin_vis_fpminu16 (v4hi, v4hi);
v2si __builtin_vis_fpminu32 (v2si, v2si);
@end smallexample

When you use the @option{-mvis4b} switch, the VIS version 4.0B
built-in functions also become available:

@smallexample
v8qi __builtin_vis_dictunpack8 (double, int);
v4hi __builtin_vis_dictunpack16 (double, int);
v2si __builtin_vis_dictunpack32 (double, int);

long __builtin_vis_fpcmple8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpgt8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpeq8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpne8shl (v8qi, v8qi, int);

long __builtin_vis_fpcmple16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpgt16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpeq16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpne16shl (v4hi, v4hi, int);

long __builtin_vis_fpcmple32shl (v2si, v2si, int);
long __builtin_vis_fpcmpgt32shl (v2si, v2si, int);
long __builtin_vis_fpcmpeq32shl (v2si, v2si, int);
long __builtin_vis_fpcmpne32shl (v2si, v2si, int);

long __builtin_vis_fpcmpule8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpugt8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpule16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpugt16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpule32shl (v2si, v2si, int);
long __builtin_vis_fpcmpugt32shl (v2si, v2si, int);

long __builtin_vis_fpcmpde8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpde16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpde32shl (v2si, v2si, int);

long __builtin_vis_fpcmpur8shl (v8qi, v8qi, int);
long __builtin_vis_fpcmpur16shl (v4hi, v4hi, int);
long __builtin_vis_fpcmpur32shl (v2si, v2si, int);
@end smallexample

@node SPU Built-in Functions
@subsection SPU Built-in Functions

GCC provides extensions for the SPU processor as described in the
Sony/Toshiba/IBM SPU Language Extensions Specification.  GCC's
implementation differs in several ways.

@itemize @bullet

@item
The optional extension of specifying vector constants in parentheses is
not supported.

@item
A vector initializer requires no cast if the vector constant is of the
same type as the variable it is initializing.

@item
If @code{signed} or @code{unsigned} is omitted, the signedness of the
vector type is the default signedness of the base type.  The default
varies depending on the operating system, so a portable program should
always specify the signedness.

@item
By default, the keyword @code{__vector} is added. The macro
@code{vector} is defined in @code{<spu_intrinsics.h>} and can be
undefined.

@item
GCC allows using a @code{typedef} name as the type specifier for a
vector type.

@item
For C, overloaded functions are implemented with macros so the following
does not work:

@smallexample
  spu_add ((vector signed int)@{1, 2, 3, 4@}, foo);
@end smallexample

@noindent
Since @code{spu_add} is a macro, the vector constant in the example
is treated as four separate arguments.  Wrap the entire argument in
parentheses for this to work.

@item
The extended version of @code{__builtin_expect} is not supported.

@end itemize

@emph{Note:} Only the interface described in the aforementioned
specification is supported. Internally, GCC uses built-in functions to
implement the required functionality, but these are not supported and
are subject to change without notice.

@node TI C6X Built-in Functions
@subsection TI C6X Built-in Functions

GCC provides intrinsics to access certain instructions of the TI C6X
processors.  These intrinsics, listed below, are available after
inclusion of the @code{c6x_intrinsics.h} header file.  They map directly
to C6X instructions.

@smallexample

int _sadd (int, int)
int _ssub (int, int)
int _sadd2 (int, int)
int _ssub2 (int, int)
long long _mpy2 (int, int)
long long _smpy2 (int, int)
int _add4 (int, int)
int _sub4 (int, int)
int _saddu4 (int, int)

int _smpy (int, int)
int _smpyh (int, int)
int _smpyhl (int, int)
int _smpylh (int, int)

int _sshl (int, int)
int _subc (int, int)

int _avg2 (int, int)
int _avgu4 (int, int)

int _clrr (int, int)
int _extr (int, int)
int _extru (int, int)
int _abs (int)
int _abs2 (int)

@end smallexample

@node TILE-Gx Built-in Functions
@subsection TILE-Gx Built-in Functions

GCC provides intrinsics to access every instruction of the TILE-Gx
processor.  The intrinsics are of the form:

@smallexample

unsigned long long __insn_@var{op} (...)

@end smallexample

Where @var{op} is the name of the instruction.  Refer to the ISA manual
for the complete list of instructions.

GCC also provides intrinsics to directly access the network registers.
The intrinsics are:

@smallexample

unsigned long long __tile_idn0_receive (void)
unsigned long long __tile_idn1_receive (void)
unsigned long long __tile_udn0_receive (void)
unsigned long long __tile_udn1_receive (void)
unsigned long long __tile_udn2_receive (void)
unsigned long long __tile_udn3_receive (void)
void __tile_idn_send (unsigned long long)
void __tile_udn_send (unsigned long long)

@end smallexample

The intrinsic @code{void __tile_network_barrier (void)} is used to
guarantee that no network operations before it are reordered with
those after it.

@node TILEPro Built-in Functions
@subsection TILEPro Built-in Functions

GCC provides intrinsics to access every instruction of the TILEPro
processor.  The intrinsics are of the form:

@smallexample

unsigned __insn_@var{op} (...)

@end smallexample

@noindent
where @var{op} is the name of the instruction.  Refer to the ISA manual
for the complete list of instructions.

GCC also provides intrinsics to directly access the network registers.
The intrinsics are:

@smallexample

unsigned __tile_idn0_receive (void)
unsigned __tile_idn1_receive (void)
unsigned __tile_sn_receive (void)
unsigned __tile_udn0_receive (void)
unsigned __tile_udn1_receive (void)
unsigned __tile_udn2_receive (void)
unsigned __tile_udn3_receive (void)
void __tile_idn_send (unsigned)
void __tile_sn_send (unsigned)
void __tile_udn_send (unsigned)

@end smallexample

The intrinsic @code{void __tile_network_barrier (void)} is used to
guarantee that no network operations before it are reordered with
those after it.

@node x86 Built-in Functions
@subsection x86 Built-in Functions

These built-in functions are available for the x86-32 and x86-64 family
of computers, depending on the command-line switches used.

If you specify command-line switches such as @option{-msse},
the compiler could use the extended instruction sets even if the built-ins
are not used explicitly in the program.  For this reason, applications
that perform run-time CPU detection must compile separate files for each
supported architecture, using the appropriate flags.  In particular,
the file containing the CPU detection code should be compiled without
these options.

The following machine modes are available for use with MMX built-in functions
(@pxref{Vector Extensions}): @code{V2SI} for a vector of two 32-bit integers,
@code{V4HI} for a vector of four 16-bit integers, and @code{V8QI} for a
vector of eight 8-bit integers.  Some of the built-in functions operate on
MMX registers as a whole 64-bit entity, these use @code{V1DI} as their mode.

If 3DNow!@: extensions are enabled, @code{V2SF} is used as a mode for a vector
of two 32-bit floating-point values.

If SSE extensions are enabled, @code{V4SF} is used for a vector of four 32-bit
floating-point values.  Some instructions use a vector of four 32-bit
integers, these use @code{V4SI}.  Finally, some instructions operate on an
entire vector register, interpreting it as a 128-bit integer, these use mode
@code{TI}.

The x86-32 and x86-64 family of processors use additional built-in
functions for efficient use of @code{TF} (@code{__float128}) 128-bit
floating point and @code{TC} 128-bit complex floating-point values.

The following floating-point built-in functions are always available.  All
of them implement the function that is part of the name.

@smallexample
__float128 __builtin_fabsq (__float128)
__float128 __builtin_copysignq (__float128, __float128)
@end smallexample

The following built-in functions are always available.

@table @code
@item __float128 __builtin_infq (void)
Similar to @code{__builtin_inf}, except the return type is @code{__float128}.
@findex __builtin_infq

@item __float128 __builtin_huge_valq (void)
Similar to @code{__builtin_huge_val}, except the return type is @code{__float128}.
@findex __builtin_huge_valq

@item __float128 __builtin_nanq (void)
Similar to @code{__builtin_nan}, except the return type is @code{__float128}.
@findex __builtin_nanq

@item __float128 __builtin_nansq (void)
Similar to @code{__builtin_nans}, except the return type is @code{__float128}.
@findex __builtin_nansq
@end table

The following built-in function is always available.

@table @code
@item void __builtin_ia32_pause (void)
Generates the @code{pause} machine instruction with a compiler memory
barrier.
@end table

The following built-in functions are always available and can be used to
check the target platform type.

@deftypefn {Built-in Function} void __builtin_cpu_init (void)
This function runs the CPU detection code to check the type of CPU and the
features supported.  This built-in function needs to be invoked along with the built-in functions
to check CPU type and features, @code{__builtin_cpu_is} and
@code{__builtin_cpu_supports}, only when used in a function that is
executed before any constructors are called.  The CPU detection code is
automatically executed in a very high priority constructor.

For example, this function has to be used in @code{ifunc} resolvers that
check for CPU type using the built-in functions @code{__builtin_cpu_is}
and @code{__builtin_cpu_supports}, or in constructors on targets that
don't support constructor priority.
@smallexample

static void (*resolve_memcpy (void)) (void)
@{
  // ifunc resolvers fire before constructors, explicitly call the init
  // function.
  __builtin_cpu_init ();
  if (__builtin_cpu_supports ("ssse3"))
    return ssse3_memcpy; // super fast memcpy with ssse3 instructions.
  else
    return default_memcpy;
@}

void *memcpy (void *, const void *, size_t)
     __attribute__ ((ifunc ("resolve_memcpy")));
@end smallexample

@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_is (const char *@var{cpuname})
This function returns a positive integer if the run-time CPU
is of type @var{cpuname}
and returns @code{0} otherwise. The following CPU names can be detected:

@table @samp
@item intel
Intel CPU.

@item atom
Intel Atom CPU.

@item core2
Intel Core 2 CPU.

@item corei7
Intel Core i7 CPU.

@item nehalem
Intel Core i7 Nehalem CPU.

@item westmere
Intel Core i7 Westmere CPU.

@item sandybridge
Intel Core i7 Sandy Bridge CPU.

@item amd
AMD CPU.

@item amdfam10h
AMD Family 10h CPU.

@item barcelona
AMD Family 10h Barcelona CPU.

@item shanghai
AMD Family 10h Shanghai CPU.

@item istanbul
AMD Family 10h Istanbul CPU.

@item btver1
AMD Family 14h CPU.

@item amdfam15h
AMD Family 15h CPU.

@item bdver1
AMD Family 15h Bulldozer version 1.

@item bdver2
AMD Family 15h Bulldozer version 2.

@item bdver3
AMD Family 15h Bulldozer version 3.

@item bdver4
AMD Family 15h Bulldozer version 4.

@item btver2
AMD Family 16h CPU.

@item amdfam17h
AMD Family 17h CPU.

@item znver1
AMD Family 17h Zen version 1.
@end table

Here is an example:
@smallexample
if (__builtin_cpu_is ("corei7"))
  @{
     do_corei7 (); // Core i7 specific implementation.
  @}
else
  @{
     do_generic (); // Generic implementation.
  @}
@end smallexample
@end deftypefn

@deftypefn {Built-in Function} int __builtin_cpu_supports (const char *@var{feature})
This function returns a positive integer if the run-time CPU
supports @var{feature}
and returns @code{0} otherwise. The following features can be detected:

@table @samp
@item cmov
CMOV instruction.
@item mmx
MMX instructions.
@item popcnt
POPCNT instruction.
@item sse
SSE instructions.
@item sse2
SSE2 instructions.
@item sse3
SSE3 instructions.
@item ssse3
SSSE3 instructions.
@item sse4.1
SSE4.1 instructions.
@item sse4.2
SSE4.2 instructions.
@item avx
AVX instructions.
@item avx2
AVX2 instructions.
@item avx512f
AVX512F instructions.
@end table

Here is an example:
@smallexample
if (__builtin_cpu_supports ("popcnt"))
  @{
     asm("popcnt %1,%0" : "=r"(count) : "rm"(n) : "cc");
  @}
else
  @{
     count = generic_countbits (n); //generic implementation.
  @}
@end smallexample
@end deftypefn


The following built-in functions are made available by @option{-mmmx}.
All of them generate the machine instruction that is part of the name.

@smallexample
v8qi __builtin_ia32_paddb (v8qi, v8qi)
v4hi __builtin_ia32_paddw (v4hi, v4hi)
v2si __builtin_ia32_paddd (v2si, v2si)
v8qi __builtin_ia32_psubb (v8qi, v8qi)
v4hi __builtin_ia32_psubw (v4hi, v4hi)
v2si __builtin_ia32_psubd (v2si, v2si)
v8qi __builtin_ia32_paddsb (v8qi, v8qi)
v4hi __builtin_ia32_paddsw (v4hi, v4hi)
v8qi __builtin_ia32_psubsb (v8qi, v8qi)
v4hi __builtin_ia32_psubsw (v4hi, v4hi)
v8qi __builtin_ia32_paddusb (v8qi, v8qi)
v4hi __builtin_ia32_paddusw (v4hi, v4hi)
v8qi __builtin_ia32_psubusb (v8qi, v8qi)
v4hi __builtin_ia32_psubusw (v4hi, v4hi)
v4hi __builtin_ia32_pmullw (v4hi, v4hi)
v4hi __builtin_ia32_pmulhw (v4hi, v4hi)
di __builtin_ia32_pand (di, di)
di __builtin_ia32_pandn (di,di)
di __builtin_ia32_por (di, di)
di __builtin_ia32_pxor (di, di)
v8qi __builtin_ia32_pcmpeqb (v8qi, v8qi)
v4hi __builtin_ia32_pcmpeqw (v4hi, v4hi)
v2si __builtin_ia32_pcmpeqd (v2si, v2si)
v8qi __builtin_ia32_pcmpgtb (v8qi, v8qi)
v4hi __builtin_ia32_pcmpgtw (v4hi, v4hi)
v2si __builtin_ia32_pcmpgtd (v2si, v2si)
v8qi __builtin_ia32_punpckhbw (v8qi, v8qi)
v4hi __builtin_ia32_punpckhwd (v4hi, v4hi)
v2si __builtin_ia32_punpckhdq (v2si, v2si)
v8qi __builtin_ia32_punpcklbw (v8qi, v8qi)
v4hi __builtin_ia32_punpcklwd (v4hi, v4hi)
v2si __builtin_ia32_punpckldq (v2si, v2si)
v8qi __builtin_ia32_packsswb (v4hi, v4hi)
v4hi __builtin_ia32_packssdw (v2si, v2si)
v8qi __builtin_ia32_packuswb (v4hi, v4hi)

v4hi __builtin_ia32_psllw (v4hi, v4hi)
v2si __builtin_ia32_pslld (v2si, v2si)
v1di __builtin_ia32_psllq (v1di, v1di)
v4hi __builtin_ia32_psrlw (v4hi, v4hi)
v2si __builtin_ia32_psrld (v2si, v2si)
v1di __builtin_ia32_psrlq (v1di, v1di)
v4hi __builtin_ia32_psraw (v4hi, v4hi)
v2si __builtin_ia32_psrad (v2si, v2si)
v4hi __builtin_ia32_psllwi (v4hi, int)
v2si __builtin_ia32_pslldi (v2si, int)
v1di __builtin_ia32_psllqi (v1di, int)
v4hi __builtin_ia32_psrlwi (v4hi, int)
v2si __builtin_ia32_psrldi (v2si, int)
v1di __builtin_ia32_psrlqi (v1di, int)
v4hi __builtin_ia32_psrawi (v4hi, int)
v2si __builtin_ia32_psradi (v2si, int)

@end smallexample

The following built-in functions are made available either with
@option{-msse}, or with @option{-m3dnowa}.  All of them generate
the machine instruction that is part of the name.

@smallexample
v4hi __builtin_ia32_pmulhuw (v4hi, v4hi)
v8qi __builtin_ia32_pavgb (v8qi, v8qi)
v4hi __builtin_ia32_pavgw (v4hi, v4hi)
v1di __builtin_ia32_psadbw (v8qi, v8qi)
v8qi __builtin_ia32_pmaxub (v8qi, v8qi)
v4hi __builtin_ia32_pmaxsw (v4hi, v4hi)
v8qi __builtin_ia32_pminub (v8qi, v8qi)
v4hi __builtin_ia32_pminsw (v4hi, v4hi)
int __builtin_ia32_pmovmskb (v8qi)
void __builtin_ia32_maskmovq (v8qi, v8qi, char *)
void __builtin_ia32_movntq (di *, di)
void __builtin_ia32_sfence (void)
@end smallexample

The following built-in functions are available when @option{-msse} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
int __builtin_ia32_comieq (v4sf, v4sf)
int __builtin_ia32_comineq (v4sf, v4sf)
int __builtin_ia32_comilt (v4sf, v4sf)
int __builtin_ia32_comile (v4sf, v4sf)
int __builtin_ia32_comigt (v4sf, v4sf)
int __builtin_ia32_comige (v4sf, v4sf)
int __builtin_ia32_ucomieq (v4sf, v4sf)
int __builtin_ia32_ucomineq (v4sf, v4sf)
int __builtin_ia32_ucomilt (v4sf, v4sf)
int __builtin_ia32_ucomile (v4sf, v4sf)
int __builtin_ia32_ucomigt (v4sf, v4sf)
int __builtin_ia32_ucomige (v4sf, v4sf)
v4sf __builtin_ia32_addps (v4sf, v4sf)
v4sf __builtin_ia32_subps (v4sf, v4sf)
v4sf __builtin_ia32_mulps (v4sf, v4sf)
v4sf __builtin_ia32_divps (v4sf, v4sf)
v4sf __builtin_ia32_addss (v4sf, v4sf)
v4sf __builtin_ia32_subss (v4sf, v4sf)
v4sf __builtin_ia32_mulss (v4sf, v4sf)
v4sf __builtin_ia32_divss (v4sf, v4sf)
v4sf __builtin_ia32_cmpeqps (v4sf, v4sf)
v4sf __builtin_ia32_cmpltps (v4sf, v4sf)
v4sf __builtin_ia32_cmpleps (v4sf, v4sf)
v4sf __builtin_ia32_cmpgtps (v4sf, v4sf)
v4sf __builtin_ia32_cmpgeps (v4sf, v4sf)
v4sf __builtin_ia32_cmpunordps (v4sf, v4sf)
v4sf __builtin_ia32_cmpneqps (v4sf, v4sf)
v4sf __builtin_ia32_cmpnltps (v4sf, v4sf)
v4sf __builtin_ia32_cmpnleps (v4sf, v4sf)
v4sf __builtin_ia32_cmpngtps (v4sf, v4sf)
v4sf __builtin_ia32_cmpngeps (v4sf, v4sf)
v4sf __builtin_ia32_cmpordps (v4sf, v4sf)
v4sf __builtin_ia32_cmpeqss (v4sf, v4sf)
v4sf __builtin_ia32_cmpltss (v4sf, v4sf)
v4sf __builtin_ia32_cmpless (v4sf, v4sf)
v4sf __builtin_ia32_cmpunordss (v4sf, v4sf)
v4sf __builtin_ia32_cmpneqss (v4sf, v4sf)
v4sf __builtin_ia32_cmpnltss (v4sf, v4sf)
v4sf __builtin_ia32_cmpnless (v4sf, v4sf)
v4sf __builtin_ia32_cmpordss (v4sf, v4sf)
v4sf __builtin_ia32_maxps (v4sf, v4sf)
v4sf __builtin_ia32_maxss (v4sf, v4sf)
v4sf __builtin_ia32_minps (v4sf, v4sf)
v4sf __builtin_ia32_minss (v4sf, v4sf)
v4sf __builtin_ia32_andps (v4sf, v4sf)
v4sf __builtin_ia32_andnps (v4sf, v4sf)
v4sf __builtin_ia32_orps (v4sf, v4sf)
v4sf __builtin_ia32_xorps (v4sf, v4sf)
v4sf __builtin_ia32_movss (v4sf, v4sf)
v4sf __builtin_ia32_movhlps (v4sf, v4sf)
v4sf __builtin_ia32_movlhps (v4sf, v4sf)
v4sf __builtin_ia32_unpckhps (v4sf, v4sf)
v4sf __builtin_ia32_unpcklps (v4sf, v4sf)
v4sf __builtin_ia32_cvtpi2ps (v4sf, v2si)
v4sf __builtin_ia32_cvtsi2ss (v4sf, int)
v2si __builtin_ia32_cvtps2pi (v4sf)
int __builtin_ia32_cvtss2si (v4sf)
v2si __builtin_ia32_cvttps2pi (v4sf)
int __builtin_ia32_cvttss2si (v4sf)
v4sf __builtin_ia32_rcpps (v4sf)
v4sf __builtin_ia32_rsqrtps (v4sf)
v4sf __builtin_ia32_sqrtps (v4sf)
v4sf __builtin_ia32_rcpss (v4sf)
v4sf __builtin_ia32_rsqrtss (v4sf)
v4sf __builtin_ia32_sqrtss (v4sf)
v4sf __builtin_ia32_shufps (v4sf, v4sf, int)
void __builtin_ia32_movntps (float *, v4sf)
int __builtin_ia32_movmskps (v4sf)
@end smallexample

The following built-in functions are available when @option{-msse} is used.

@table @code
@item v4sf __builtin_ia32_loadups (float *)
Generates the @code{movups} machine instruction as a load from memory.
@item void __builtin_ia32_storeups (float *, v4sf)
Generates the @code{movups} machine instruction as a store to memory.
@item v4sf __builtin_ia32_loadss (float *)
Generates the @code{movss} machine instruction as a load from memory.
@item v4sf __builtin_ia32_loadhps (v4sf, const v2sf *)
Generates the @code{movhps} machine instruction as a load from memory.
@item v4sf __builtin_ia32_loadlps (v4sf, const v2sf *)
Generates the @code{movlps} machine instruction as a load from memory
@item void __builtin_ia32_storehps (v2sf *, v4sf)
Generates the @code{movhps} machine instruction as a store to memory.
@item void __builtin_ia32_storelps (v2sf *, v4sf)
Generates the @code{movlps} machine instruction as a store to memory.
@end table

The following built-in functions are available when @option{-msse2} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
int __builtin_ia32_comisdeq (v2df, v2df)
int __builtin_ia32_comisdlt (v2df, v2df)
int __builtin_ia32_comisdle (v2df, v2df)
int __builtin_ia32_comisdgt (v2df, v2df)
int __builtin_ia32_comisdge (v2df, v2df)
int __builtin_ia32_comisdneq (v2df, v2df)
int __builtin_ia32_ucomisdeq (v2df, v2df)
int __builtin_ia32_ucomisdlt (v2df, v2df)
int __builtin_ia32_ucomisdle (v2df, v2df)
int __builtin_ia32_ucomisdgt (v2df, v2df)
int __builtin_ia32_ucomisdge (v2df, v2df)
int __builtin_ia32_ucomisdneq (v2df, v2df)
v2df __builtin_ia32_cmpeqpd (v2df, v2df)
v2df __builtin_ia32_cmpltpd (v2df, v2df)
v2df __builtin_ia32_cmplepd (v2df, v2df)
v2df __builtin_ia32_cmpgtpd (v2df, v2df)
v2df __builtin_ia32_cmpgepd (v2df, v2df)
v2df __builtin_ia32_cmpunordpd (v2df, v2df)
v2df __builtin_ia32_cmpneqpd (v2df, v2df)
v2df __builtin_ia32_cmpnltpd (v2df, v2df)
v2df __builtin_ia32_cmpnlepd (v2df, v2df)
v2df __builtin_ia32_cmpngtpd (v2df, v2df)
v2df __builtin_ia32_cmpngepd (v2df, v2df)
v2df __builtin_ia32_cmpordpd (v2df, v2df)
v2df __builtin_ia32_cmpeqsd (v2df, v2df)
v2df __builtin_ia32_cmpltsd (v2df, v2df)
v2df __builtin_ia32_cmplesd (v2df, v2df)
v2df __builtin_ia32_cmpunordsd (v2df, v2df)
v2df __builtin_ia32_cmpneqsd (v2df, v2df)
v2df __builtin_ia32_cmpnltsd (v2df, v2df)
v2df __builtin_ia32_cmpnlesd (v2df, v2df)
v2df __builtin_ia32_cmpordsd (v2df, v2df)
v2di __builtin_ia32_paddq (v2di, v2di)
v2di __builtin_ia32_psubq (v2di, v2di)
v2df __builtin_ia32_addpd (v2df, v2df)
v2df __builtin_ia32_subpd (v2df, v2df)
v2df __builtin_ia32_mulpd (v2df, v2df)
v2df __builtin_ia32_divpd (v2df, v2df)
v2df __builtin_ia32_addsd (v2df, v2df)
v2df __builtin_ia32_subsd (v2df, v2df)
v2df __builtin_ia32_mulsd (v2df, v2df)
v2df __builtin_ia32_divsd (v2df, v2df)
v2df __builtin_ia32_minpd (v2df, v2df)
v2df __builtin_ia32_maxpd (v2df, v2df)
v2df __builtin_ia32_minsd (v2df, v2df)
v2df __builtin_ia32_maxsd (v2df, v2df)
v2df __builtin_ia32_andpd (v2df, v2df)
v2df __builtin_ia32_andnpd (v2df, v2df)
v2df __builtin_ia32_orpd (v2df, v2df)
v2df __builtin_ia32_xorpd (v2df, v2df)
v2df __builtin_ia32_movsd (v2df, v2df)
v2df __builtin_ia32_unpckhpd (v2df, v2df)
v2df __builtin_ia32_unpcklpd (v2df, v2df)
v16qi __builtin_ia32_paddb128 (v16qi, v16qi)
v8hi __builtin_ia32_paddw128 (v8hi, v8hi)
v4si __builtin_ia32_paddd128 (v4si, v4si)
v2di __builtin_ia32_paddq128 (v2di, v2di)
v16qi __builtin_ia32_psubb128 (v16qi, v16qi)
v8hi __builtin_ia32_psubw128 (v8hi, v8hi)
v4si __builtin_ia32_psubd128 (v4si, v4si)
v2di __builtin_ia32_psubq128 (v2di, v2di)
v8hi __builtin_ia32_pmullw128 (v8hi, v8hi)
v8hi __builtin_ia32_pmulhw128 (v8hi, v8hi)
v2di __builtin_ia32_pand128 (v2di, v2di)
v2di __builtin_ia32_pandn128 (v2di, v2di)
v2di __builtin_ia32_por128 (v2di, v2di)
v2di __builtin_ia32_pxor128 (v2di, v2di)
v16qi __builtin_ia32_pavgb128 (v16qi, v16qi)
v8hi __builtin_ia32_pavgw128 (v8hi, v8hi)
v16qi __builtin_ia32_pcmpeqb128 (v16qi, v16qi)
v8hi __builtin_ia32_pcmpeqw128 (v8hi, v8hi)
v4si __builtin_ia32_pcmpeqd128 (v4si, v4si)
v16qi __builtin_ia32_pcmpgtb128 (v16qi, v16qi)
v8hi __builtin_ia32_pcmpgtw128 (v8hi, v8hi)
v4si __builtin_ia32_pcmpgtd128 (v4si, v4si)
v16qi __builtin_ia32_pmaxub128 (v16qi, v16qi)
v8hi __builtin_ia32_pmaxsw128 (v8hi, v8hi)
v16qi __builtin_ia32_pminub128 (v16qi, v16qi)
v8hi __builtin_ia32_pminsw128 (v8hi, v8hi)
v16qi __builtin_ia32_punpckhbw128 (v16qi, v16qi)
v8hi __builtin_ia32_punpckhwd128 (v8hi, v8hi)
v4si __builtin_ia32_punpckhdq128 (v4si, v4si)
v2di __builtin_ia32_punpckhqdq128 (v2di, v2di)
v16qi __builtin_ia32_punpcklbw128 (v16qi, v16qi)
v8hi __builtin_ia32_punpcklwd128 (v8hi, v8hi)
v4si __builtin_ia32_punpckldq128 (v4si, v4si)
v2di __builtin_ia32_punpcklqdq128 (v2di, v2di)
v16qi __builtin_ia32_packsswb128 (v8hi, v8hi)
v8hi __builtin_ia32_packssdw128 (v4si, v4si)
v16qi __builtin_ia32_packuswb128 (v8hi, v8hi)
v8hi __builtin_ia32_pmulhuw128 (v8hi, v8hi)
void __builtin_ia32_maskmovdqu (v16qi, v16qi)
v2df __builtin_ia32_loadupd (double *)
void __builtin_ia32_storeupd (double *, v2df)
v2df __builtin_ia32_loadhpd (v2df, double const *)
v2df __builtin_ia32_loadlpd (v2df, double const *)
int __builtin_ia32_movmskpd (v2df)
int __builtin_ia32_pmovmskb128 (v16qi)
void __builtin_ia32_movnti (int *, int)
void __builtin_ia32_movnti64 (long long int *, long long int)
void __builtin_ia32_movntpd (double *, v2df)
void __builtin_ia32_movntdq (v2df *, v2df)
v4si __builtin_ia32_pshufd (v4si, int)
v8hi __builtin_ia32_pshuflw (v8hi, int)
v8hi __builtin_ia32_pshufhw (v8hi, int)
v2di __builtin_ia32_psadbw128 (v16qi, v16qi)
v2df __builtin_ia32_sqrtpd (v2df)
v2df __builtin_ia32_sqrtsd (v2df)
v2df __builtin_ia32_shufpd (v2df, v2df, int)
v2df __builtin_ia32_cvtdq2pd (v4si)
v4sf __builtin_ia32_cvtdq2ps (v4si)
v4si __builtin_ia32_cvtpd2dq (v2df)
v2si __builtin_ia32_cvtpd2pi (v2df)
v4sf __builtin_ia32_cvtpd2ps (v2df)
v4si __builtin_ia32_cvttpd2dq (v2df)
v2si __builtin_ia32_cvttpd2pi (v2df)
v2df __builtin_ia32_cvtpi2pd (v2si)
int __builtin_ia32_cvtsd2si (v2df)
int __builtin_ia32_cvttsd2si (v2df)
long long __builtin_ia32_cvtsd2si64 (v2df)
long long __builtin_ia32_cvttsd2si64 (v2df)
v4si __builtin_ia32_cvtps2dq (v4sf)
v2df __builtin_ia32_cvtps2pd (v4sf)
v4si __builtin_ia32_cvttps2dq (v4sf)
v2df __builtin_ia32_cvtsi2sd (v2df, int)
v2df __builtin_ia32_cvtsi642sd (v2df, long long)
v4sf __builtin_ia32_cvtsd2ss (v4sf, v2df)
v2df __builtin_ia32_cvtss2sd (v2df, v4sf)
void __builtin_ia32_clflush (const void *)
void __builtin_ia32_lfence (void)
void __builtin_ia32_mfence (void)
v16qi __builtin_ia32_loaddqu (const char *)
void __builtin_ia32_storedqu (char *, v16qi)
v1di __builtin_ia32_pmuludq (v2si, v2si)
v2di __builtin_ia32_pmuludq128 (v4si, v4si)
v8hi __builtin_ia32_psllw128 (v8hi, v8hi)
v4si __builtin_ia32_pslld128 (v4si, v4si)
v2di __builtin_ia32_psllq128 (v2di, v2di)
v8hi __builtin_ia32_psrlw128 (v8hi, v8hi)
v4si __builtin_ia32_psrld128 (v4si, v4si)
v2di __builtin_ia32_psrlq128 (v2di, v2di)
v8hi __builtin_ia32_psraw128 (v8hi, v8hi)
v4si __builtin_ia32_psrad128 (v4si, v4si)
v2di __builtin_ia32_pslldqi128 (v2di, int)
v8hi __builtin_ia32_psllwi128 (v8hi, int)
v4si __builtin_ia32_pslldi128 (v4si, int)
v2di __builtin_ia32_psllqi128 (v2di, int)
v2di __builtin_ia32_psrldqi128 (v2di, int)
v8hi __builtin_ia32_psrlwi128 (v8hi, int)
v4si __builtin_ia32_psrldi128 (v4si, int)
v2di __builtin_ia32_psrlqi128 (v2di, int)
v8hi __builtin_ia32_psrawi128 (v8hi, int)
v4si __builtin_ia32_psradi128 (v4si, int)
v4si __builtin_ia32_pmaddwd128 (v8hi, v8hi)
v2di __builtin_ia32_movq128 (v2di)
@end smallexample

The following built-in functions are available when @option{-msse3} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2df __builtin_ia32_addsubpd (v2df, v2df)
v4sf __builtin_ia32_addsubps (v4sf, v4sf)
v2df __builtin_ia32_haddpd (v2df, v2df)
v4sf __builtin_ia32_haddps (v4sf, v4sf)
v2df __builtin_ia32_hsubpd (v2df, v2df)
v4sf __builtin_ia32_hsubps (v4sf, v4sf)
v16qi __builtin_ia32_lddqu (char const *)
void __builtin_ia32_monitor (void *, unsigned int, unsigned int)
v4sf __builtin_ia32_movshdup (v4sf)
v4sf __builtin_ia32_movsldup (v4sf)
void __builtin_ia32_mwait (unsigned int, unsigned int)
@end smallexample

The following built-in functions are available when @option{-mssse3} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2si __builtin_ia32_phaddd (v2si, v2si)
v4hi __builtin_ia32_phaddw (v4hi, v4hi)
v4hi __builtin_ia32_phaddsw (v4hi, v4hi)
v2si __builtin_ia32_phsubd (v2si, v2si)
v4hi __builtin_ia32_phsubw (v4hi, v4hi)
v4hi __builtin_ia32_phsubsw (v4hi, v4hi)
v4hi __builtin_ia32_pmaddubsw (v8qi, v8qi)
v4hi __builtin_ia32_pmulhrsw (v4hi, v4hi)
v8qi __builtin_ia32_pshufb (v8qi, v8qi)
v8qi __builtin_ia32_psignb (v8qi, v8qi)
v2si __builtin_ia32_psignd (v2si, v2si)
v4hi __builtin_ia32_psignw (v4hi, v4hi)
v1di __builtin_ia32_palignr (v1di, v1di, int)
v8qi __builtin_ia32_pabsb (v8qi)
v2si __builtin_ia32_pabsd (v2si)
v4hi __builtin_ia32_pabsw (v4hi)
@end smallexample

The following built-in functions are available when @option{-mssse3} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v4si __builtin_ia32_phaddd128 (v4si, v4si)
v8hi __builtin_ia32_phaddw128 (v8hi, v8hi)
v8hi __builtin_ia32_phaddsw128 (v8hi, v8hi)
v4si __builtin_ia32_phsubd128 (v4si, v4si)
v8hi __builtin_ia32_phsubw128 (v8hi, v8hi)
v8hi __builtin_ia32_phsubsw128 (v8hi, v8hi)
v8hi __builtin_ia32_pmaddubsw128 (v16qi, v16qi)
v8hi __builtin_ia32_pmulhrsw128 (v8hi, v8hi)
v16qi __builtin_ia32_pshufb128 (v16qi, v16qi)
v16qi __builtin_ia32_psignb128 (v16qi, v16qi)
v4si __builtin_ia32_psignd128 (v4si, v4si)
v8hi __builtin_ia32_psignw128 (v8hi, v8hi)
v2di __builtin_ia32_palignr128 (v2di, v2di, int)
v16qi __builtin_ia32_pabsb128 (v16qi)
v4si __builtin_ia32_pabsd128 (v4si)
v8hi __builtin_ia32_pabsw128 (v8hi)
@end smallexample

The following built-in functions are available when @option{-msse4.1} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
v2df __builtin_ia32_blendpd (v2df, v2df, const int)
v4sf __builtin_ia32_blendps (v4sf, v4sf, const int)
v2df __builtin_ia32_blendvpd (v2df, v2df, v2df)
v4sf __builtin_ia32_blendvps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_dppd (v2df, v2df, const int)
v4sf __builtin_ia32_dpps (v4sf, v4sf, const int)
v4sf __builtin_ia32_insertps128 (v4sf, v4sf, const int)
v2di __builtin_ia32_movntdqa (v2di *);
v16qi __builtin_ia32_mpsadbw128 (v16qi, v16qi, const int)
v8hi __builtin_ia32_packusdw128 (v4si, v4si)
v16qi __builtin_ia32_pblendvb128 (v16qi, v16qi, v16qi)
v8hi __builtin_ia32_pblendw128 (v8hi, v8hi, const int)
v2di __builtin_ia32_pcmpeqq (v2di, v2di)
v8hi __builtin_ia32_phminposuw128 (v8hi)
v16qi __builtin_ia32_pmaxsb128 (v16qi, v16qi)
v4si __builtin_ia32_pmaxsd128 (v4si, v4si)
v4si __builtin_ia32_pmaxud128 (v4si, v4si)
v8hi __builtin_ia32_pmaxuw128 (v8hi, v8hi)
v16qi __builtin_ia32_pminsb128 (v16qi, v16qi)
v4si __builtin_ia32_pminsd128 (v4si, v4si)
v4si __builtin_ia32_pminud128 (v4si, v4si)
v8hi __builtin_ia32_pminuw128 (v8hi, v8hi)
v4si __builtin_ia32_pmovsxbd128 (v16qi)
v2di __builtin_ia32_pmovsxbq128 (v16qi)
v8hi __builtin_ia32_pmovsxbw128 (v16qi)
v2di __builtin_ia32_pmovsxdq128 (v4si)
v4si __builtin_ia32_pmovsxwd128 (v8hi)
v2di __builtin_ia32_pmovsxwq128 (v8hi)
v4si __builtin_ia32_pmovzxbd128 (v16qi)
v2di __builtin_ia32_pmovzxbq128 (v16qi)
v8hi __builtin_ia32_pmovzxbw128 (v16qi)
v2di __builtin_ia32_pmovzxdq128 (v4si)
v4si __builtin_ia32_pmovzxwd128 (v8hi)
v2di __builtin_ia32_pmovzxwq128 (v8hi)
v2di __builtin_ia32_pmuldq128 (v4si, v4si)
v4si __builtin_ia32_pmulld128 (v4si, v4si)
int __builtin_ia32_ptestc128 (v2di, v2di)
int __builtin_ia32_ptestnzc128 (v2di, v2di)
int __builtin_ia32_ptestz128 (v2di, v2di)
v2df __builtin_ia32_roundpd (v2df, const int)
v4sf __builtin_ia32_roundps (v4sf, const int)
v2df __builtin_ia32_roundsd (v2df, v2df, const int)
v4sf __builtin_ia32_roundss (v4sf, v4sf, const int)
@end smallexample

The following built-in functions are available when @option{-msse4.1} is
used.

@table @code
@item v4sf __builtin_ia32_vec_set_v4sf (v4sf, float, const int)
Generates the @code{insertps} machine instruction.
@item int __builtin_ia32_vec_ext_v16qi (v16qi, const int)
Generates the @code{pextrb} machine instruction.
@item v16qi __builtin_ia32_vec_set_v16qi (v16qi, int, const int)
Generates the @code{pinsrb} machine instruction.
@item v4si __builtin_ia32_vec_set_v4si (v4si, int, const int)
Generates the @code{pinsrd} machine instruction.
@item v2di __builtin_ia32_vec_set_v2di (v2di, long long, const int)
Generates the @code{pinsrq} machine instruction in 64bit mode.
@end table

The following built-in functions are changed to generate new SSE4.1
instructions when @option{-msse4.1} is used.

@table @code
@item float __builtin_ia32_vec_ext_v4sf (v4sf, const int)
Generates the @code{extractps} machine instruction.
@item int __builtin_ia32_vec_ext_v4si (v4si, const int)
Generates the @code{pextrd} machine instruction.
@item long long __builtin_ia32_vec_ext_v2di (v2di, const int)
Generates the @code{pextrq} machine instruction in 64bit mode.
@end table

The following built-in functions are available when @option{-msse4.2} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
v16qi __builtin_ia32_pcmpestrm128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestri128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestria128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestric128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestrio128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestris128 (v16qi, int, v16qi, int, const int)
int __builtin_ia32_pcmpestriz128 (v16qi, int, v16qi, int, const int)
v16qi __builtin_ia32_pcmpistrm128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistri128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistria128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistric128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistrio128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistris128 (v16qi, v16qi, const int)
int __builtin_ia32_pcmpistriz128 (v16qi, v16qi, const int)
v2di __builtin_ia32_pcmpgtq (v2di, v2di)
@end smallexample

The following built-in functions are available when @option{-msse4.2} is
used.

@table @code
@item unsigned int __builtin_ia32_crc32qi (unsigned int, unsigned char)
Generates the @code{crc32b} machine instruction.
@item unsigned int __builtin_ia32_crc32hi (unsigned int, unsigned short)
Generates the @code{crc32w} machine instruction.
@item unsigned int __builtin_ia32_crc32si (unsigned int, unsigned int)
Generates the @code{crc32l} machine instruction.
@item unsigned long long __builtin_ia32_crc32di (unsigned long long, unsigned long long)
Generates the @code{crc32q} machine instruction.
@end table

The following built-in functions are changed to generate new SSE4.2
instructions when @option{-msse4.2} is used.

@table @code
@item int __builtin_popcount (unsigned int)
Generates the @code{popcntl} machine instruction.
@item int __builtin_popcountl (unsigned long)
Generates the @code{popcntl} or @code{popcntq} machine instruction,
depending on the size of @code{unsigned long}.
@item int __builtin_popcountll (unsigned long long)
Generates the @code{popcntq} machine instruction.
@end table

The following built-in functions are available when @option{-mavx} is
used. All of them generate the machine instruction that is part of the
name.

@smallexample
v4df __builtin_ia32_addpd256 (v4df,v4df)
v8sf __builtin_ia32_addps256 (v8sf,v8sf)
v4df __builtin_ia32_addsubpd256 (v4df,v4df)
v8sf __builtin_ia32_addsubps256 (v8sf,v8sf)
v4df __builtin_ia32_andnpd256 (v4df,v4df)
v8sf __builtin_ia32_andnps256 (v8sf,v8sf)
v4df __builtin_ia32_andpd256 (v4df,v4df)
v8sf __builtin_ia32_andps256 (v8sf,v8sf)
v4df __builtin_ia32_blendpd256 (v4df,v4df,int)
v8sf __builtin_ia32_blendps256 (v8sf,v8sf,int)
v4df __builtin_ia32_blendvpd256 (v4df,v4df,v4df)
v8sf __builtin_ia32_blendvps256 (v8sf,v8sf,v8sf)
v2df __builtin_ia32_cmppd (v2df,v2df,int)
v4df __builtin_ia32_cmppd256 (v4df,v4df,int)
v4sf __builtin_ia32_cmpps (v4sf,v4sf,int)
v8sf __builtin_ia32_cmpps256 (v8sf,v8sf,int)
v2df __builtin_ia32_cmpsd (v2df,v2df,int)
v4sf __builtin_ia32_cmpss (v4sf,v4sf,int)
v4df __builtin_ia32_cvtdq2pd256 (v4si)
v8sf __builtin_ia32_cvtdq2ps256 (v8si)
v4si __builtin_ia32_cvtpd2dq256 (v4df)
v4sf __builtin_ia32_cvtpd2ps256 (v4df)
v8si __builtin_ia32_cvtps2dq256 (v8sf)
v4df __builtin_ia32_cvtps2pd256 (v4sf)
v4si __builtin_ia32_cvttpd2dq256 (v4df)
v8si __builtin_ia32_cvttps2dq256 (v8sf)
v4df __builtin_ia32_divpd256 (v4df,v4df)
v8sf __builtin_ia32_divps256 (v8sf,v8sf)
v8sf __builtin_ia32_dpps256 (v8sf,v8sf,int)
v4df __builtin_ia32_haddpd256 (v4df,v4df)
v8sf __builtin_ia32_haddps256 (v8sf,v8sf)
v4df __builtin_ia32_hsubpd256 (v4df,v4df)
v8sf __builtin_ia32_hsubps256 (v8sf,v8sf)
v32qi __builtin_ia32_lddqu256 (pcchar)
v32qi __builtin_ia32_loaddqu256 (pcchar)
v4df __builtin_ia32_loadupd256 (pcdouble)
v8sf __builtin_ia32_loadups256 (pcfloat)
v2df __builtin_ia32_maskloadpd (pcv2df,v2df)
v4df __builtin_ia32_maskloadpd256 (pcv4df,v4df)
v4sf __builtin_ia32_maskloadps (pcv4sf,v4sf)
v8sf __builtin_ia32_maskloadps256 (pcv8sf,v8sf)
void __builtin_ia32_maskstorepd (pv2df,v2df,v2df)
void __builtin_ia32_maskstorepd256 (pv4df,v4df,v4df)
void __builtin_ia32_maskstoreps (pv4sf,v4sf,v4sf)
void __builtin_ia32_maskstoreps256 (pv8sf,v8sf,v8sf)
v4df __builtin_ia32_maxpd256 (v4df,v4df)
v8sf __builtin_ia32_maxps256 (v8sf,v8sf)
v4df __builtin_ia32_minpd256 (v4df,v4df)
v8sf __builtin_ia32_minps256 (v8sf,v8sf)
v4df __builtin_ia32_movddup256 (v4df)
int __builtin_ia32_movmskpd256 (v4df)
int __builtin_ia32_movmskps256 (v8sf)
v8sf __builtin_ia32_movshdup256 (v8sf)
v8sf __builtin_ia32_movsldup256 (v8sf)
v4df __builtin_ia32_mulpd256 (v4df,v4df)
v8sf __builtin_ia32_mulps256 (v8sf,v8sf)
v4df __builtin_ia32_orpd256 (v4df,v4df)
v8sf __builtin_ia32_orps256 (v8sf,v8sf)
v2df __builtin_ia32_pd_pd256 (v4df)
v4df __builtin_ia32_pd256_pd (v2df)
v4sf __builtin_ia32_ps_ps256 (v8sf)
v8sf __builtin_ia32_ps256_ps (v4sf)
int __builtin_ia32_ptestc256 (v4di,v4di,ptest)
int __builtin_ia32_ptestnzc256 (v4di,v4di,ptest)
int __builtin_ia32_ptestz256 (v4di,v4di,ptest)
v8sf __builtin_ia32_rcpps256 (v8sf)
v4df __builtin_ia32_roundpd256 (v4df,int)
v8sf __builtin_ia32_roundps256 (v8sf,int)
v8sf __builtin_ia32_rsqrtps_nr256 (v8sf)
v8sf __builtin_ia32_rsqrtps256 (v8sf)
v4df __builtin_ia32_shufpd256 (v4df,v4df,int)
v8sf __builtin_ia32_shufps256 (v8sf,v8sf,int)
v4si __builtin_ia32_si_si256 (v8si)
v8si __builtin_ia32_si256_si (v4si)
v4df __builtin_ia32_sqrtpd256 (v4df)
v8sf __builtin_ia32_sqrtps_nr256 (v8sf)
v8sf __builtin_ia32_sqrtps256 (v8sf)
void __builtin_ia32_storedqu256 (pchar,v32qi)
void __builtin_ia32_storeupd256 (pdouble,v4df)
void __builtin_ia32_storeups256 (pfloat,v8sf)
v4df __builtin_ia32_subpd256 (v4df,v4df)
v8sf __builtin_ia32_subps256 (v8sf,v8sf)
v4df __builtin_ia32_unpckhpd256 (v4df,v4df)
v8sf __builtin_ia32_unpckhps256 (v8sf,v8sf)
v4df __builtin_ia32_unpcklpd256 (v4df,v4df)
v8sf __builtin_ia32_unpcklps256 (v8sf,v8sf)
v4df __builtin_ia32_vbroadcastf128_pd256 (pcv2df)
v8sf __builtin_ia32_vbroadcastf128_ps256 (pcv4sf)
v4df __builtin_ia32_vbroadcastsd256 (pcdouble)
v4sf __builtin_ia32_vbroadcastss (pcfloat)
v8sf __builtin_ia32_vbroadcastss256 (pcfloat)
v2df __builtin_ia32_vextractf128_pd256 (v4df,int)
v4sf __builtin_ia32_vextractf128_ps256 (v8sf,int)
v4si __builtin_ia32_vextractf128_si256 (v8si,int)
v4df __builtin_ia32_vinsertf128_pd256 (v4df,v2df,int)
v8sf __builtin_ia32_vinsertf128_ps256 (v8sf,v4sf,int)
v8si __builtin_ia32_vinsertf128_si256 (v8si,v4si,int)
v4df __builtin_ia32_vperm2f128_pd256 (v4df,v4df,int)
v8sf __builtin_ia32_vperm2f128_ps256 (v8sf,v8sf,int)
v8si __builtin_ia32_vperm2f128_si256 (v8si,v8si,int)
v2df __builtin_ia32_vpermil2pd (v2df,v2df,v2di,int)
v4df __builtin_ia32_vpermil2pd256 (v4df,v4df,v4di,int)
v4sf __builtin_ia32_vpermil2ps (v4sf,v4sf,v4si,int)
v8sf __builtin_ia32_vpermil2ps256 (v8sf,v8sf,v8si,int)
v2df __builtin_ia32_vpermilpd (v2df,int)
v4df __builtin_ia32_vpermilpd256 (v4df,int)
v4sf __builtin_ia32_vpermilps (v4sf,int)
v8sf __builtin_ia32_vpermilps256 (v8sf,int)
v2df __builtin_ia32_vpermilvarpd (v2df,v2di)
v4df __builtin_ia32_vpermilvarpd256 (v4df,v4di)
v4sf __builtin_ia32_vpermilvarps (v4sf,v4si)
v8sf __builtin_ia32_vpermilvarps256 (v8sf,v8si)
int __builtin_ia32_vtestcpd (v2df,v2df,ptest)
int __builtin_ia32_vtestcpd256 (v4df,v4df,ptest)
int __builtin_ia32_vtestcps (v4sf,v4sf,ptest)
int __builtin_ia32_vtestcps256 (v8sf,v8sf,ptest)
int __builtin_ia32_vtestnzcpd (v2df,v2df,ptest)
int __builtin_ia32_vtestnzcpd256 (v4df,v4df,ptest)
int __builtin_ia32_vtestnzcps (v4sf,v4sf,ptest)
int __builtin_ia32_vtestnzcps256 (v8sf,v8sf,ptest)
int __builtin_ia32_vtestzpd (v2df,v2df,ptest)
int __builtin_ia32_vtestzpd256 (v4df,v4df,ptest)
int __builtin_ia32_vtestzps (v4sf,v4sf,ptest)
int __builtin_ia32_vtestzps256 (v8sf,v8sf,ptest)
void __builtin_ia32_vzeroall (void)
void __builtin_ia32_vzeroupper (void)
v4df __builtin_ia32_xorpd256 (v4df,v4df)
v8sf __builtin_ia32_xorps256 (v8sf,v8sf)
@end smallexample

The following built-in functions are available when @option{-mavx2} is
used. All of them generate the machine instruction that is part of the
name.

@smallexample
v32qi __builtin_ia32_mpsadbw256 (v32qi,v32qi,int)
v32qi __builtin_ia32_pabsb256 (v32qi)
v16hi __builtin_ia32_pabsw256 (v16hi)
v8si __builtin_ia32_pabsd256 (v8si)
v16hi __builtin_ia32_packssdw256 (v8si,v8si)
v32qi __builtin_ia32_packsswb256 (v16hi,v16hi)
v16hi __builtin_ia32_packusdw256 (v8si,v8si)
v32qi __builtin_ia32_packuswb256 (v16hi,v16hi)
v32qi __builtin_ia32_paddb256 (v32qi,v32qi)
v16hi __builtin_ia32_paddw256 (v16hi,v16hi)
v8si __builtin_ia32_paddd256 (v8si,v8si)
v4di __builtin_ia32_paddq256 (v4di,v4di)
v32qi __builtin_ia32_paddsb256 (v32qi,v32qi)
v16hi __builtin_ia32_paddsw256 (v16hi,v16hi)
v32qi __builtin_ia32_paddusb256 (v32qi,v32qi)
v16hi __builtin_ia32_paddusw256 (v16hi,v16hi)
v4di __builtin_ia32_palignr256 (v4di,v4di,int)
v4di __builtin_ia32_andsi256 (v4di,v4di)
v4di __builtin_ia32_andnotsi256 (v4di,v4di)
v32qi __builtin_ia32_pavgb256 (v32qi,v32qi)
v16hi __builtin_ia32_pavgw256 (v16hi,v16hi)
v32qi __builtin_ia32_pblendvb256 (v32qi,v32qi,v32qi)
v16hi __builtin_ia32_pblendw256 (v16hi,v16hi,int)
v32qi __builtin_ia32_pcmpeqb256 (v32qi,v32qi)
v16hi __builtin_ia32_pcmpeqw256 (v16hi,v16hi)
v8si __builtin_ia32_pcmpeqd256 (c8si,v8si)
v4di __builtin_ia32_pcmpeqq256 (v4di,v4di)
v32qi __builtin_ia32_pcmpgtb256 (v32qi,v32qi)
v16hi __builtin_ia32_pcmpgtw256 (16hi,v16hi)
v8si __builtin_ia32_pcmpgtd256 (v8si,v8si)
v4di __builtin_ia32_pcmpgtq256 (v4di,v4di)
v16hi __builtin_ia32_phaddw256 (v16hi,v16hi)
v8si __builtin_ia32_phaddd256 (v8si,v8si)
v16hi __builtin_ia32_phaddsw256 (v16hi,v16hi)
v16hi __builtin_ia32_phsubw256 (v16hi,v16hi)
v8si __builtin_ia32_phsubd256 (v8si,v8si)
v16hi __builtin_ia32_phsubsw256 (v16hi,v16hi)
v32qi __builtin_ia32_pmaddubsw256 (v32qi,v32qi)
v16hi __builtin_ia32_pmaddwd256 (v16hi,v16hi)
v32qi __builtin_ia32_pmaxsb256 (v32qi,v32qi)
v16hi __builtin_ia32_pmaxsw256 (v16hi,v16hi)
v8si __builtin_ia32_pmaxsd256 (v8si,v8si)
v32qi __builtin_ia32_pmaxub256 (v32qi,v32qi)
v16hi __builtin_ia32_pmaxuw256 (v16hi,v16hi)
v8si __builtin_ia32_pmaxud256 (v8si,v8si)
v32qi __builtin_ia32_pminsb256 (v32qi,v32qi)
v16hi __builtin_ia32_pminsw256 (v16hi,v16hi)
v8si __builtin_ia32_pminsd256 (v8si,v8si)
v32qi __builtin_ia32_pminub256 (v32qi,v32qi)
v16hi __builtin_ia32_pminuw256 (v16hi,v16hi)
v8si __builtin_ia32_pminud256 (v8si,v8si)
int __builtin_ia32_pmovmskb256 (v32qi)
v16hi __builtin_ia32_pmovsxbw256 (v16qi)
v8si __builtin_ia32_pmovsxbd256 (v16qi)
v4di __builtin_ia32_pmovsxbq256 (v16qi)
v8si __builtin_ia32_pmovsxwd256 (v8hi)
v4di __builtin_ia32_pmovsxwq256 (v8hi)
v4di __builtin_ia32_pmovsxdq256 (v4si)
v16hi __builtin_ia32_pmovzxbw256 (v16qi)
v8si __builtin_ia32_pmovzxbd256 (v16qi)
v4di __builtin_ia32_pmovzxbq256 (v16qi)
v8si __builtin_ia32_pmovzxwd256 (v8hi)
v4di __builtin_ia32_pmovzxwq256 (v8hi)
v4di __builtin_ia32_pmovzxdq256 (v4si)
v4di __builtin_ia32_pmuldq256 (v8si,v8si)
v16hi __builtin_ia32_pmulhrsw256 (v16hi, v16hi)
v16hi __builtin_ia32_pmulhuw256 (v16hi,v16hi)
v16hi __builtin_ia32_pmulhw256 (v16hi,v16hi)
v16hi __builtin_ia32_pmullw256 (v16hi,v16hi)
v8si __builtin_ia32_pmulld256 (v8si,v8si)
v4di __builtin_ia32_pmuludq256 (v8si,v8si)
v4di __builtin_ia32_por256 (v4di,v4di)
v16hi __builtin_ia32_psadbw256 (v32qi,v32qi)
v32qi __builtin_ia32_pshufb256 (v32qi,v32qi)
v8si __builtin_ia32_pshufd256 (v8si,int)
v16hi __builtin_ia32_pshufhw256 (v16hi,int)
v16hi __builtin_ia32_pshuflw256 (v16hi,int)
v32qi __builtin_ia32_psignb256 (v32qi,v32qi)
v16hi __builtin_ia32_psignw256 (v16hi,v16hi)
v8si __builtin_ia32_psignd256 (v8si,v8si)
v4di __builtin_ia32_pslldqi256 (v4di,int)
v16hi __builtin_ia32_psllwi256 (16hi,int)
v16hi __builtin_ia32_psllw256(v16hi,v8hi)
v8si __builtin_ia32_pslldi256 (v8si,int)
v8si __builtin_ia32_pslld256(v8si,v4si)
v4di __builtin_ia32_psllqi256 (v4di,int)
v4di __builtin_ia32_psllq256(v4di,v2di)
v16hi __builtin_ia32_psrawi256 (v16hi,int)
v16hi __builtin_ia32_psraw256 (v16hi,v8hi)
v8si __builtin_ia32_psradi256 (v8si,int)
v8si __builtin_ia32_psrad256 (v8si,v4si)
v4di __builtin_ia32_psrldqi256 (v4di, int)
v16hi __builtin_ia32_psrlwi256 (v16hi,int)
v16hi __builtin_ia32_psrlw256 (v16hi,v8hi)
v8si __builtin_ia32_psrldi256 (v8si,int)
v8si __builtin_ia32_psrld256 (v8si,v4si)
v4di __builtin_ia32_psrlqi256 (v4di,int)
v4di __builtin_ia32_psrlq256(v4di,v2di)
v32qi __builtin_ia32_psubb256 (v32qi,v32qi)
v32hi __builtin_ia32_psubw256 (v16hi,v16hi)
v8si __builtin_ia32_psubd256 (v8si,v8si)
v4di __builtin_ia32_psubq256 (v4di,v4di)
v32qi __builtin_ia32_psubsb256 (v32qi,v32qi)
v16hi __builtin_ia32_psubsw256 (v16hi,v16hi)
v32qi __builtin_ia32_psubusb256 (v32qi,v32qi)
v16hi __builtin_ia32_psubusw256 (v16hi,v16hi)
v32qi __builtin_ia32_punpckhbw256 (v32qi,v32qi)
v16hi __builtin_ia32_punpckhwd256 (v16hi,v16hi)
v8si __builtin_ia32_punpckhdq256 (v8si,v8si)
v4di __builtin_ia32_punpckhqdq256 (v4di,v4di)
v32qi __builtin_ia32_punpcklbw256 (v32qi,v32qi)
v16hi __builtin_ia32_punpcklwd256 (v16hi,v16hi)
v8si __builtin_ia32_punpckldq256 (v8si,v8si)
v4di __builtin_ia32_punpcklqdq256 (v4di,v4di)
v4di __builtin_ia32_pxor256 (v4di,v4di)
v4di __builtin_ia32_movntdqa256 (pv4di)
v4sf __builtin_ia32_vbroadcastss_ps (v4sf)
v8sf __builtin_ia32_vbroadcastss_ps256 (v4sf)
v4df __builtin_ia32_vbroadcastsd_pd256 (v2df)
v4di __builtin_ia32_vbroadcastsi256 (v2di)
v4si __builtin_ia32_pblendd128 (v4si,v4si)
v8si __builtin_ia32_pblendd256 (v8si,v8si)
v32qi __builtin_ia32_pbroadcastb256 (v16qi)
v16hi __builtin_ia32_pbroadcastw256 (v8hi)
v8si __builtin_ia32_pbroadcastd256 (v4si)
v4di __builtin_ia32_pbroadcastq256 (v2di)
v16qi __builtin_ia32_pbroadcastb128 (v16qi)
v8hi __builtin_ia32_pbroadcastw128 (v8hi)
v4si __builtin_ia32_pbroadcastd128 (v4si)
v2di __builtin_ia32_pbroadcastq128 (v2di)
v8si __builtin_ia32_permvarsi256 (v8si,v8si)
v4df __builtin_ia32_permdf256 (v4df,int)
v8sf __builtin_ia32_permvarsf256 (v8sf,v8sf)
v4di __builtin_ia32_permdi256 (v4di,int)
v4di __builtin_ia32_permti256 (v4di,v4di,int)
v4di __builtin_ia32_extract128i256 (v4di,int)
v4di __builtin_ia32_insert128i256 (v4di,v2di,int)
v8si __builtin_ia32_maskloadd256 (pcv8si,v8si)
v4di __builtin_ia32_maskloadq256 (pcv4di,v4di)
v4si __builtin_ia32_maskloadd (pcv4si,v4si)
v2di __builtin_ia32_maskloadq (pcv2di,v2di)
void __builtin_ia32_maskstored256 (pv8si,v8si,v8si)
void __builtin_ia32_maskstoreq256 (pv4di,v4di,v4di)
void __builtin_ia32_maskstored (pv4si,v4si,v4si)
void __builtin_ia32_maskstoreq (pv2di,v2di,v2di)
v8si __builtin_ia32_psllv8si (v8si,v8si)
v4si __builtin_ia32_psllv4si (v4si,v4si)
v4di __builtin_ia32_psllv4di (v4di,v4di)
v2di __builtin_ia32_psllv2di (v2di,v2di)
v8si __builtin_ia32_psrav8si (v8si,v8si)
v4si __builtin_ia32_psrav4si (v4si,v4si)
v8si __builtin_ia32_psrlv8si (v8si,v8si)
v4si __builtin_ia32_psrlv4si (v4si,v4si)
v4di __builtin_ia32_psrlv4di (v4di,v4di)
v2di __builtin_ia32_psrlv2di (v2di,v2di)
v2df __builtin_ia32_gathersiv2df (v2df, pcdouble,v4si,v2df,int)
v4df __builtin_ia32_gathersiv4df (v4df, pcdouble,v4si,v4df,int)
v2df __builtin_ia32_gatherdiv2df (v2df, pcdouble,v2di,v2df,int)
v4df __builtin_ia32_gatherdiv4df (v4df, pcdouble,v4di,v4df,int)
v4sf __builtin_ia32_gathersiv4sf (v4sf, pcfloat,v4si,v4sf,int)
v8sf __builtin_ia32_gathersiv8sf (v8sf, pcfloat,v8si,v8sf,int)
v4sf __builtin_ia32_gatherdiv4sf (v4sf, pcfloat,v2di,v4sf,int)
v4sf __builtin_ia32_gatherdiv4sf256 (v4sf, pcfloat,v4di,v4sf,int)
v2di __builtin_ia32_gathersiv2di (v2di, pcint64,v4si,v2di,int)
v4di __builtin_ia32_gathersiv4di (v4di, pcint64,v4si,v4di,int)
v2di __builtin_ia32_gatherdiv2di (v2di, pcint64,v2di,v2di,int)
v4di __builtin_ia32_gatherdiv4di (v4di, pcint64,v4di,v4di,int)
v4si __builtin_ia32_gathersiv4si (v4si, pcint,v4si,v4si,int)
v8si __builtin_ia32_gathersiv8si (v8si, pcint,v8si,v8si,int)
v4si __builtin_ia32_gatherdiv4si (v4si, pcint,v2di,v4si,int)
v4si __builtin_ia32_gatherdiv4si256 (v4si, pcint,v4di,v4si,int)
@end smallexample

The following built-in functions are available when @option{-maes} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
v2di __builtin_ia32_aesenc128 (v2di, v2di)
v2di __builtin_ia32_aesenclast128 (v2di, v2di)
v2di __builtin_ia32_aesdec128 (v2di, v2di)
v2di __builtin_ia32_aesdeclast128 (v2di, v2di)
v2di __builtin_ia32_aeskeygenassist128 (v2di, const int)
v2di __builtin_ia32_aesimc128 (v2di)
@end smallexample

The following built-in function is available when @option{-mpclmul} is
used.

@table @code
@item v2di __builtin_ia32_pclmulqdq128 (v2di, v2di, const int)
Generates the @code{pclmulqdq} machine instruction.
@end table

The following built-in function is available when @option{-mfsgsbase} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
unsigned int __builtin_ia32_rdfsbase32 (void)
unsigned long long __builtin_ia32_rdfsbase64 (void)
unsigned int __builtin_ia32_rdgsbase32 (void)
unsigned long long __builtin_ia32_rdgsbase64 (void)
void _writefsbase_u32 (unsigned int)
void _writefsbase_u64 (unsigned long long)
void _writegsbase_u32 (unsigned int)
void _writegsbase_u64 (unsigned long long)
@end smallexample

The following built-in function is available when @option{-mrdrnd} is
used.  All of them generate the machine instruction that is part of the
name.

@smallexample
unsigned int __builtin_ia32_rdrand16_step (unsigned short *)
unsigned int __builtin_ia32_rdrand32_step (unsigned int *)
unsigned int __builtin_ia32_rdrand64_step (unsigned long long *)
@end smallexample

The following built-in functions are available when @option{-msse4a} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
void __builtin_ia32_movntsd (double *, v2df)
void __builtin_ia32_movntss (float *, v4sf)
v2di __builtin_ia32_extrq  (v2di, v16qi)
v2di __builtin_ia32_extrqi (v2di, const unsigned int, const unsigned int)
v2di __builtin_ia32_insertq (v2di, v2di)
v2di __builtin_ia32_insertqi (v2di, v2di, const unsigned int, const unsigned int)
@end smallexample

The following built-in functions are available when @option{-mxop} is used.
@smallexample
v2df __builtin_ia32_vfrczpd (v2df)
v4sf __builtin_ia32_vfrczps (v4sf)
v2df __builtin_ia32_vfrczsd (v2df)
v4sf __builtin_ia32_vfrczss (v4sf)
v4df __builtin_ia32_vfrczpd256 (v4df)
v8sf __builtin_ia32_vfrczps256 (v8sf)
v2di __builtin_ia32_vpcmov (v2di, v2di, v2di)
v2di __builtin_ia32_vpcmov_v2di (v2di, v2di, v2di)
v4si __builtin_ia32_vpcmov_v4si (v4si, v4si, v4si)
v8hi __builtin_ia32_vpcmov_v8hi (v8hi, v8hi, v8hi)
v16qi __builtin_ia32_vpcmov_v16qi (v16qi, v16qi, v16qi)
v2df __builtin_ia32_vpcmov_v2df (v2df, v2df, v2df)
v4sf __builtin_ia32_vpcmov_v4sf (v4sf, v4sf, v4sf)
v4di __builtin_ia32_vpcmov_v4di256 (v4di, v4di, v4di)
v8si __builtin_ia32_vpcmov_v8si256 (v8si, v8si, v8si)
v16hi __builtin_ia32_vpcmov_v16hi256 (v16hi, v16hi, v16hi)
v32qi __builtin_ia32_vpcmov_v32qi256 (v32qi, v32qi, v32qi)
v4df __builtin_ia32_vpcmov_v4df256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vpcmov_v8sf256 (v8sf, v8sf, v8sf)
v16qi __builtin_ia32_vpcomeqb (v16qi, v16qi)
v8hi __builtin_ia32_vpcomeqw (v8hi, v8hi)
v4si __builtin_ia32_vpcomeqd (v4si, v4si)
v2di __builtin_ia32_vpcomeqq (v2di, v2di)
v16qi __builtin_ia32_vpcomequb (v16qi, v16qi)
v4si __builtin_ia32_vpcomequd (v4si, v4si)
v2di __builtin_ia32_vpcomequq (v2di, v2di)
v8hi __builtin_ia32_vpcomequw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomeqw (v8hi, v8hi)
v16qi __builtin_ia32_vpcomfalseb (v16qi, v16qi)
v4si __builtin_ia32_vpcomfalsed (v4si, v4si)
v2di __builtin_ia32_vpcomfalseq (v2di, v2di)
v16qi __builtin_ia32_vpcomfalseub (v16qi, v16qi)
v4si __builtin_ia32_vpcomfalseud (v4si, v4si)
v2di __builtin_ia32_vpcomfalseuq (v2di, v2di)
v8hi __builtin_ia32_vpcomfalseuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomfalsew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomgeb (v16qi, v16qi)
v4si __builtin_ia32_vpcomged (v4si, v4si)
v2di __builtin_ia32_vpcomgeq (v2di, v2di)
v16qi __builtin_ia32_vpcomgeub (v16qi, v16qi)
v4si __builtin_ia32_vpcomgeud (v4si, v4si)
v2di __builtin_ia32_vpcomgeuq (v2di, v2di)
v8hi __builtin_ia32_vpcomgeuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomgew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomgtb (v16qi, v16qi)
v4si __builtin_ia32_vpcomgtd (v4si, v4si)
v2di __builtin_ia32_vpcomgtq (v2di, v2di)
v16qi __builtin_ia32_vpcomgtub (v16qi, v16qi)
v4si __builtin_ia32_vpcomgtud (v4si, v4si)
v2di __builtin_ia32_vpcomgtuq (v2di, v2di)
v8hi __builtin_ia32_vpcomgtuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomgtw (v8hi, v8hi)
v16qi __builtin_ia32_vpcomleb (v16qi, v16qi)
v4si __builtin_ia32_vpcomled (v4si, v4si)
v2di __builtin_ia32_vpcomleq (v2di, v2di)
v16qi __builtin_ia32_vpcomleub (v16qi, v16qi)
v4si __builtin_ia32_vpcomleud (v4si, v4si)
v2di __builtin_ia32_vpcomleuq (v2di, v2di)
v8hi __builtin_ia32_vpcomleuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomlew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomltb (v16qi, v16qi)
v4si __builtin_ia32_vpcomltd (v4si, v4si)
v2di __builtin_ia32_vpcomltq (v2di, v2di)
v16qi __builtin_ia32_vpcomltub (v16qi, v16qi)
v4si __builtin_ia32_vpcomltud (v4si, v4si)
v2di __builtin_ia32_vpcomltuq (v2di, v2di)
v8hi __builtin_ia32_vpcomltuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomltw (v8hi, v8hi)
v16qi __builtin_ia32_vpcomneb (v16qi, v16qi)
v4si __builtin_ia32_vpcomned (v4si, v4si)
v2di __builtin_ia32_vpcomneq (v2di, v2di)
v16qi __builtin_ia32_vpcomneub (v16qi, v16qi)
v4si __builtin_ia32_vpcomneud (v4si, v4si)
v2di __builtin_ia32_vpcomneuq (v2di, v2di)
v8hi __builtin_ia32_vpcomneuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomnew (v8hi, v8hi)
v16qi __builtin_ia32_vpcomtrueb (v16qi, v16qi)
v4si __builtin_ia32_vpcomtrued (v4si, v4si)
v2di __builtin_ia32_vpcomtrueq (v2di, v2di)
v16qi __builtin_ia32_vpcomtrueub (v16qi, v16qi)
v4si __builtin_ia32_vpcomtrueud (v4si, v4si)
v2di __builtin_ia32_vpcomtrueuq (v2di, v2di)
v8hi __builtin_ia32_vpcomtrueuw (v8hi, v8hi)
v8hi __builtin_ia32_vpcomtruew (v8hi, v8hi)
v4si __builtin_ia32_vphaddbd (v16qi)
v2di __builtin_ia32_vphaddbq (v16qi)
v8hi __builtin_ia32_vphaddbw (v16qi)
v2di __builtin_ia32_vphadddq (v4si)
v4si __builtin_ia32_vphaddubd (v16qi)
v2di __builtin_ia32_vphaddubq (v16qi)
v8hi __builtin_ia32_vphaddubw (v16qi)
v2di __builtin_ia32_vphaddudq (v4si)
v4si __builtin_ia32_vphadduwd (v8hi)
v2di __builtin_ia32_vphadduwq (v8hi)
v4si __builtin_ia32_vphaddwd (v8hi)
v2di __builtin_ia32_vphaddwq (v8hi)
v8hi __builtin_ia32_vphsubbw (v16qi)
v2di __builtin_ia32_vphsubdq (v4si)
v4si __builtin_ia32_vphsubwd (v8hi)
v4si __builtin_ia32_vpmacsdd (v4si, v4si, v4si)
v2di __builtin_ia32_vpmacsdqh (v4si, v4si, v2di)
v2di __builtin_ia32_vpmacsdql (v4si, v4si, v2di)
v4si __builtin_ia32_vpmacssdd (v4si, v4si, v4si)
v2di __builtin_ia32_vpmacssdqh (v4si, v4si, v2di)
v2di __builtin_ia32_vpmacssdql (v4si, v4si, v2di)
v4si __builtin_ia32_vpmacsswd (v8hi, v8hi, v4si)
v8hi __builtin_ia32_vpmacssww (v8hi, v8hi, v8hi)
v4si __builtin_ia32_vpmacswd (v8hi, v8hi, v4si)
v8hi __builtin_ia32_vpmacsww (v8hi, v8hi, v8hi)
v4si __builtin_ia32_vpmadcsswd (v8hi, v8hi, v4si)
v4si __builtin_ia32_vpmadcswd (v8hi, v8hi, v4si)
v16qi __builtin_ia32_vpperm (v16qi, v16qi, v16qi)
v16qi __builtin_ia32_vprotb (v16qi, v16qi)
v4si __builtin_ia32_vprotd (v4si, v4si)
v2di __builtin_ia32_vprotq (v2di, v2di)
v8hi __builtin_ia32_vprotw (v8hi, v8hi)
v16qi __builtin_ia32_vpshab (v16qi, v16qi)
v4si __builtin_ia32_vpshad (v4si, v4si)
v2di __builtin_ia32_vpshaq (v2di, v2di)
v8hi __builtin_ia32_vpshaw (v8hi, v8hi)
v16qi __builtin_ia32_vpshlb (v16qi, v16qi)
v4si __builtin_ia32_vpshld (v4si, v4si)
v2di __builtin_ia32_vpshlq (v2di, v2di)
v8hi __builtin_ia32_vpshlw (v8hi, v8hi)
@end smallexample

The following built-in functions are available when @option{-mfma4} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2df __builtin_ia32_vfmaddpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmaddps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmaddsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmaddss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmsubpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmsubps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmsubsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmsubss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmaddpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmaddps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmaddsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmaddss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmsubpd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmsubps (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfnmsubsd (v2df, v2df, v2df)
v4sf __builtin_ia32_vfnmsubss (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmaddsubpd  (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmaddsubps  (v4sf, v4sf, v4sf)
v2df __builtin_ia32_vfmsubaddpd  (v2df, v2df, v2df)
v4sf __builtin_ia32_vfmsubaddps  (v4sf, v4sf, v4sf)
v4df __builtin_ia32_vfmaddpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmaddps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfmsubpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmsubps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfnmaddpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfnmaddps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfnmsubpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfnmsubps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfmaddsubpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmaddsubps256 (v8sf, v8sf, v8sf)
v4df __builtin_ia32_vfmsubaddpd256 (v4df, v4df, v4df)
v8sf __builtin_ia32_vfmsubaddps256 (v8sf, v8sf, v8sf)

@end smallexample

The following built-in functions are available when @option{-mlwp} is used.

@smallexample
void __builtin_ia32_llwpcb16 (void *);
void __builtin_ia32_llwpcb32 (void *);
void __builtin_ia32_llwpcb64 (void *);
void * __builtin_ia32_llwpcb16 (void);
void * __builtin_ia32_llwpcb32 (void);
void * __builtin_ia32_llwpcb64 (void);
void __builtin_ia32_lwpval16 (unsigned short, unsigned int, unsigned short)
void __builtin_ia32_lwpval32 (unsigned int, unsigned int, unsigned int)
void __builtin_ia32_lwpval64 (unsigned __int64, unsigned int, unsigned int)
unsigned char __builtin_ia32_lwpins16 (unsigned short, unsigned int, unsigned short)
unsigned char __builtin_ia32_lwpins32 (unsigned int, unsigned int, unsigned int)
unsigned char __builtin_ia32_lwpins64 (unsigned __int64, unsigned int, unsigned int)
@end smallexample

The following built-in functions are available when @option{-mbmi} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
unsigned int __builtin_ia32_bextr_u32(unsigned int, unsigned int);
unsigned long long __builtin_ia32_bextr_u64 (unsigned long long, unsigned long long);
@end smallexample

The following built-in functions are available when @option{-mbmi2} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
unsigned int _bzhi_u32 (unsigned int, unsigned int)
unsigned int _pdep_u32 (unsigned int, unsigned int)
unsigned int _pext_u32 (unsigned int, unsigned int)
unsigned long long _bzhi_u64 (unsigned long long, unsigned long long)
unsigned long long _pdep_u64 (unsigned long long, unsigned long long)
unsigned long long _pext_u64 (unsigned long long, unsigned long long)
@end smallexample

The following built-in functions are available when @option{-mlzcnt} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
unsigned short __builtin_ia32_lzcnt_u16(unsigned short);
unsigned int __builtin_ia32_lzcnt_u32(unsigned int);
unsigned long long __builtin_ia32_lzcnt_u64 (unsigned long long);
@end smallexample

The following built-in functions are available when @option{-mfxsr} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_fxsave (void *)
void __builtin_ia32_fxrstor (void *)
void __builtin_ia32_fxsave64 (void *)
void __builtin_ia32_fxrstor64 (void *)
@end smallexample

The following built-in functions are available when @option{-mxsave} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_xsave (void *, long long)
void __builtin_ia32_xrstor (void *, long long)
void __builtin_ia32_xsave64 (void *, long long)
void __builtin_ia32_xrstor64 (void *, long long)
@end smallexample

The following built-in functions are available when @option{-mxsaveopt} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_xsaveopt (void *, long long)
void __builtin_ia32_xsaveopt64 (void *, long long)
@end smallexample

The following built-in functions are available when @option{-mtbm} is used.
Both of them generate the immediate form of the bextr machine instruction.
@smallexample
unsigned int __builtin_ia32_bextri_u32 (unsigned int,
                                        const unsigned int);
unsigned long long __builtin_ia32_bextri_u64 (unsigned long long,
                                              const unsigned long long);
@end smallexample


The following built-in functions are available when @option{-m3dnow} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
void __builtin_ia32_femms (void)
v8qi __builtin_ia32_pavgusb (v8qi, v8qi)
v2si __builtin_ia32_pf2id (v2sf)
v2sf __builtin_ia32_pfacc (v2sf, v2sf)
v2sf __builtin_ia32_pfadd (v2sf, v2sf)
v2si __builtin_ia32_pfcmpeq (v2sf, v2sf)
v2si __builtin_ia32_pfcmpge (v2sf, v2sf)
v2si __builtin_ia32_pfcmpgt (v2sf, v2sf)
v2sf __builtin_ia32_pfmax (v2sf, v2sf)
v2sf __builtin_ia32_pfmin (v2sf, v2sf)
v2sf __builtin_ia32_pfmul (v2sf, v2sf)
v2sf __builtin_ia32_pfrcp (v2sf)
v2sf __builtin_ia32_pfrcpit1 (v2sf, v2sf)
v2sf __builtin_ia32_pfrcpit2 (v2sf, v2sf)
v2sf __builtin_ia32_pfrsqrt (v2sf)
v2sf __builtin_ia32_pfsub (v2sf, v2sf)
v2sf __builtin_ia32_pfsubr (v2sf, v2sf)
v2sf __builtin_ia32_pi2fd (v2si)
v4hi __builtin_ia32_pmulhrw (v4hi, v4hi)
@end smallexample

The following built-in functions are available when @option{-m3dnowa} is used.
All of them generate the machine instruction that is part of the name.

@smallexample
v2si __builtin_ia32_pf2iw (v2sf)
v2sf __builtin_ia32_pfnacc (v2sf, v2sf)
v2sf __builtin_ia32_pfpnacc (v2sf, v2sf)
v2sf __builtin_ia32_pi2fw (v2si)
v2sf __builtin_ia32_pswapdsf (v2sf)
v2si __builtin_ia32_pswapdsi (v2si)
@end smallexample

The following built-in functions are available when @option{-mrtm} is used
They are used for restricted transactional memory. These are the internal
low level functions. Normally the functions in 
@ref{x86 transactional memory intrinsics} should be used instead.

@smallexample
int __builtin_ia32_xbegin ()
void __builtin_ia32_xend ()
void __builtin_ia32_xabort (status)
int __builtin_ia32_xtest ()
@end smallexample

The following built-in functions are available when @option{-mmwaitx} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_ia32_monitorx (void *, unsigned int, unsigned int)
void __builtin_ia32_mwaitx (unsigned int, unsigned int, unsigned int)
@end smallexample

The following built-in functions are available when @option{-mclzero} is used.
All of them generate the machine instruction that is part of the name.
@smallexample
void __builtin_i32_clzero (void *)
@end smallexample

The following built-in functions are available when @option{-mpku} is used.
They generate reads and writes to PKRU.
@smallexample
void __builtin_ia32_wrpkru (unsigned int)
unsigned int __builtin_ia32_rdpkru ()
@end smallexample

The following built-in functions are available when @option{-mcet} or
@option{-mshstk} option is used.  They support shadow stack
machine instructions from Intel Control-flow Enforcement Technology (CET).
Each built-in function generates the  machine instruction that is part
of the function's name.  These are the internal low-level functions.
Normally the functions in @ref{x86 control-flow protection intrinsics}
should be used instead.

@smallexample
unsigned int __builtin_ia32_rdsspd (void)
unsigned long long __builtin_ia32_rdsspq (void)
void __builtin_ia32_incsspd (unsigned int)
void __builtin_ia32_incsspq (unsigned long long)
void __builtin_ia32_saveprevssp(void);
void __builtin_ia32_rstorssp(void *);
void __builtin_ia32_wrssd(unsigned int, void *);
void __builtin_ia32_wrssq(unsigned long long, void *);
void __builtin_ia32_wrussd(unsigned int, void *);
void __builtin_ia32_wrussq(unsigned long long, void *);
void __builtin_ia32_setssbsy(void);
void __builtin_ia32_clrssbsy(void *);
@end smallexample

@node x86 transactional memory intrinsics
@subsection x86 Transactional Memory Intrinsics

These hardware transactional memory intrinsics for x86 allow you to use
memory transactions with RTM (Restricted Transactional Memory).
This support is enabled with the @option{-mrtm} option.
For using HLE (Hardware Lock Elision) see 
@ref{x86 specific memory model extensions for transactional memory} instead.

A memory transaction commits all changes to memory in an atomic way,
as visible to other threads. If the transaction fails it is rolled back
and all side effects discarded.

Generally there is no guarantee that a memory transaction ever succeeds
and suitable fallback code always needs to be supplied.

@deftypefn {RTM Function} {unsigned} _xbegin ()
Start a RTM (Restricted Transactional Memory) transaction. 
Returns @code{_XBEGIN_STARTED} when the transaction
started successfully (note this is not 0, so the constant has to be 
explicitly tested).  

If the transaction aborts, all side effects
are undone and an abort code encoded as a bit mask is returned.
The following macros are defined:

@table @code
@item _XABORT_EXPLICIT
Transaction was explicitly aborted with @code{_xabort}.  The parameter passed
to @code{_xabort} is available with @code{_XABORT_CODE(status)}.
@item _XABORT_RETRY
Transaction retry is possible.
@item _XABORT_CONFLICT
Transaction abort due to a memory conflict with another thread.
@item _XABORT_CAPACITY
Transaction abort due to the transaction using too much memory.
@item _XABORT_DEBUG
Transaction abort due to a debug trap.
@item _XABORT_NESTED
Transaction abort in an inner nested transaction.
@end table

There is no guarantee
any transaction ever succeeds, so there always needs to be a valid
fallback path.
@end deftypefn

@deftypefn {RTM Function} {void} _xend ()
Commit the current transaction. When no transaction is active this faults.
All memory side effects of the transaction become visible
to other threads in an atomic manner.
@end deftypefn

@deftypefn {RTM Function} {int} _xtest ()
Return a nonzero value if a transaction is currently active, otherwise 0.
@end deftypefn

@deftypefn {RTM Function} {void} _xabort (status)
Abort the current transaction. When no transaction is active this is a no-op.
The @var{status} is an 8-bit constant; its value is encoded in the return 
value from @code{_xbegin}.
@end deftypefn

Here is an example showing handling for @code{_XABORT_RETRY}
and a fallback path for other failures:

@smallexample
#include <immintrin.h>

int n_tries, max_tries;
unsigned status = _XABORT_EXPLICIT;
...

for (n_tries = 0; n_tries < max_tries; n_tries++) 
  @{
    status = _xbegin ();
    if (status == _XBEGIN_STARTED || !(status & _XABORT_RETRY))
      break;
  @}
if (status == _XBEGIN_STARTED) 
  @{
    ... transaction code...
    _xend ();
  @} 
else 
  @{
    ... non-transactional fallback path...
  @}
@end smallexample

@noindent
Note that, in most cases, the transactional and non-transactional code
must synchronize together to ensure consistency.

@node x86 control-flow protection intrinsics
@subsection x86 Control-Flow Protection Intrinsics

@deftypefn {CET Function} {ret_type} _get_ssp (void)
Get the current value of shadow stack pointer if shadow stack support
from Intel CET is enabled in the hardware or @code{0} otherwise.
The @code{ret_type} is @code{unsigned long long} for 64-bit targets 
and @code{unsigned int} for 32-bit targets.
@end deftypefn

@deftypefn {CET Function} void _inc_ssp (unsigned int)
Increment the current shadow stack pointer by the size specified by the
function argument.  The argument is masked to a byte value for security
reasons, so to increment by more than 255 bytes you must call the function
multiple times.
@end deftypefn

The shadow stack unwind code looks like:

@smallexample
#include <immintrin.h>

/* Unwind the shadow stack for EH.  */
#define _Unwind_Frames_Extra(x)       \
  do                                  \
    @{                                \
      _Unwind_Word ssp = _get_ssp (); \
      if (ssp != 0)                   \
        @{                            \
          _Unwind_Word tmp = (x);     \
          while (tmp > 255)           \
            @{                        \
              _inc_ssp (tmp);         \
              tmp -= 255;             \
            @}                        \
          _inc_ssp (tmp);             \
        @}                            \
    @}                                \
    while (0)
@end smallexample

@noindent
This code runs unconditionally on all 64-bit processors.  For 32-bit
processors the code runs on those that support multi-byte NOP instructions.

@node Target Format Checks
@section Format Checks Specific to Particular Target Machines

For some target machines, GCC supports additional options to the
format attribute
(@pxref{Function Attributes,,Declaring Attributes of Functions}).

@menu
* Solaris Format Checks::
* Darwin Format Checks::
@end menu

@node Solaris Format Checks
@subsection Solaris Format Checks

Solaris targets support the @code{cmn_err} (or @code{__cmn_err__}) format
check.  @code{cmn_err} accepts a subset of the standard @code{printf}
conversions, and the two-argument @code{%b} conversion for displaying
bit-fields.  See the Solaris man page for @code{cmn_err} for more information.

@node Darwin Format Checks
@subsection Darwin Format Checks

Darwin targets support the @code{CFString} (or @code{__CFString__}) in the format
attribute context.  Declarations made with such attribution are parsed for correct syntax
and format argument types.  However, parsing of the format string itself is currently undefined
and is not carried out by this version of the compiler.

Additionally, @code{CFStringRefs} (defined by the @code{CoreFoundation} headers) may
also be used as format arguments.  Note that the relevant headers are only likely to be
available on Darwin (OSX) installations.  On such installations, the XCode and system
documentation provide descriptions of @code{CFString}, @code{CFStringRefs} and
associated functions.

@node Pragmas
@section Pragmas Accepted by GCC
@cindex pragmas
@cindex @code{#pragma}

GCC supports several types of pragmas, primarily in order to compile
code originally written for other compilers.  Note that in general
we do not recommend the use of pragmas; @xref{Function Attributes},
for further explanation.

@menu
* AArch64 Pragmas::
* ARM Pragmas::
* M32C Pragmas::
* MeP Pragmas::
* RS/6000 and PowerPC Pragmas::
* S/390 Pragmas::
* Darwin Pragmas::
* Solaris Pragmas::
* Symbol-Renaming Pragmas::
* Structure-Layout Pragmas::
* Weak Pragmas::
* Diagnostic Pragmas::
* Visibility Pragmas::
* Push/Pop Macro Pragmas::
* Function Specific Option Pragmas::
* Loop-Specific Pragmas::
@end menu

@node AArch64 Pragmas
@subsection AArch64 Pragmas

The pragmas defined by the AArch64 target correspond to the AArch64
target function attributes.  They can be specified as below:
@smallexample
#pragma GCC target("string")
@end smallexample

where @code{@var{string}} can be any string accepted as an AArch64 target
attribute.  @xref{AArch64 Function Attributes}, for more details
on the permissible values of @code{string}.

@node ARM Pragmas
@subsection ARM Pragmas

The ARM target defines pragmas for controlling the default addition of
@code{long_call} and @code{short_call} attributes to functions.
@xref{Function Attributes}, for information about the effects of these
attributes.

@table @code
@item long_calls
@cindex pragma, long_calls
Set all subsequent functions to have the @code{long_call} attribute.

@item no_long_calls
@cindex pragma, no_long_calls
Set all subsequent functions to have the @code{short_call} attribute.

@item long_calls_off
@cindex pragma, long_calls_off
Do not affect the @code{long_call} or @code{short_call} attributes of
subsequent functions.
@end table

@node M32C Pragmas
@subsection M32C Pragmas

@table @code
@item GCC memregs @var{number}
@cindex pragma, memregs
Overrides the command-line option @code{-memregs=} for the current
file.  Use with care!  This pragma must be before any function in the
file, and mixing different memregs values in different objects may
make them incompatible.  This pragma is useful when a
performance-critical function uses a memreg for temporary values,
as it may allow you to reduce the number of memregs used.

@item ADDRESS @var{name} @var{address}
@cindex pragma, address
For any declared symbols matching @var{name}, this does three things
to that symbol: it forces the symbol to be located at the given
address (a number), it forces the symbol to be volatile, and it
changes the symbol's scope to be static.  This pragma exists for
compatibility with other compilers, but note that the common
@code{1234H} numeric syntax is not supported (use @code{0x1234}
instead).  Example:

@smallexample
#pragma ADDRESS port3 0x103
char port3;
@end smallexample

@end table

@node MeP Pragmas
@subsection MeP Pragmas

@table @code

@item custom io_volatile (on|off)
@cindex pragma, custom io_volatile
Overrides the command-line option @code{-mio-volatile} for the current
file.  Note that for compatibility with future GCC releases, this
option should only be used once before any @code{io} variables in each
file.

@item GCC coprocessor available @var{registers}
@cindex pragma, coprocessor available
Specifies which coprocessor registers are available to the register
allocator.  @var{registers} may be a single register, register range
separated by ellipses, or comma-separated list of those.  Example:

@smallexample
#pragma GCC coprocessor available $c0...$c10, $c28
@end smallexample

@item GCC coprocessor call_saved @var{registers}
@cindex pragma, coprocessor call_saved
Specifies which coprocessor registers are to be saved and restored by
any function using them.  @var{registers} may be a single register,
register range separated by ellipses, or comma-separated list of
those.  Example:

@smallexample
#pragma GCC coprocessor call_saved $c4...$c6, $c31
@end smallexample

@item GCC coprocessor subclass '(A|B|C|D)' = @var{registers}
@cindex pragma, coprocessor subclass
Creates and defines a register class.  These register classes can be
used by inline @code{asm} constructs.  @var{registers} may be a single
register, register range separated by ellipses, or comma-separated
list of those.  Example:

@smallexample
#pragma GCC coprocessor subclass 'B' = $c2, $c4, $c6

asm ("cpfoo %0" : "=B" (x));
@end smallexample

@item GCC disinterrupt @var{name} , @var{name} @dots{}
@cindex pragma, disinterrupt
For the named functions, the compiler adds code to disable interrupts
for the duration of those functions.  If any functions so named 
are not encountered in the source, a warning is emitted that the pragma is
not used.  Examples:

@smallexample
#pragma disinterrupt foo
#pragma disinterrupt bar, grill
int foo () @{ @dots{} @}
@end smallexample

@item GCC call @var{name} , @var{name} @dots{}
@cindex pragma, call
For the named functions, the compiler always uses a register-indirect
call model when calling the named functions.  Examples:

@smallexample
extern int foo ();
#pragma call foo
@end smallexample

@end table

@node RS/6000 and PowerPC Pragmas
@subsection RS/6000 and PowerPC Pragmas

The RS/6000 and PowerPC targets define one pragma for controlling
whether or not the @code{longcall} attribute is added to function
declarations by default.  This pragma overrides the @option{-mlongcall}
option, but not the @code{longcall} and @code{shortcall} attributes.
@xref{RS/6000 and PowerPC Options}, for more information about when long
calls are and are not necessary.

@table @code
@item longcall (1)
@cindex pragma, longcall
Apply the @code{longcall} attribute to all subsequent function
declarations.

@item longcall (0)
Do not apply the @code{longcall} attribute to subsequent function
declarations.
@end table

@c Describe h8300 pragmas here.
@c Describe sh pragmas here.
@c Describe v850 pragmas here.

@node S/390 Pragmas
@subsection S/390 Pragmas

The pragmas defined by the S/390 target correspond to the S/390
target function attributes and some the additional options:

@table @samp
@item zvector
@itemx no-zvector
@end table

Note that options of the pragma, unlike options of the target
attribute, do change the value of preprocessor macros like
@code{__VEC__}.  They can be specified as below:

@smallexample
#pragma GCC target("string[,string]...")
#pragma GCC target("string"[,"string"]...)
@end smallexample

@node Darwin Pragmas
@subsection Darwin Pragmas

The following pragmas are available for all architectures running the
Darwin operating system.  These are useful for compatibility with other
Mac OS compilers.

@table @code
@item mark @var{tokens}@dots{}
@cindex pragma, mark
This pragma is accepted, but has no effect.

@item options align=@var{alignment}
@cindex pragma, options align
This pragma sets the alignment of fields in structures.  The values of
@var{alignment} may be @code{mac68k}, to emulate m68k alignment, or
@code{power}, to emulate PowerPC alignment.  Uses of this pragma nest
properly; to restore the previous setting, use @code{reset} for the
@var{alignment}.

@item segment @var{tokens}@dots{}
@cindex pragma, segment
This pragma is accepted, but has no effect.

@item unused (@var{var} [, @var{var}]@dots{})
@cindex pragma, unused
This pragma declares variables to be possibly unused.  GCC does not
produce warnings for the listed variables.  The effect is similar to
that of the @code{unused} attribute, except that this pragma may appear
anywhere within the variables' scopes.
@end table

@node Solaris Pragmas
@subsection Solaris Pragmas

The Solaris target supports @code{#pragma redefine_extname}
(@pxref{Symbol-Renaming Pragmas}).  It also supports additional
@code{#pragma} directives for compatibility with the system compiler.

@table @code
@item align @var{alignment} (@var{variable} [, @var{variable}]...)
@cindex pragma, align

Increase the minimum alignment of each @var{variable} to @var{alignment}.
This is the same as GCC's @code{aligned} attribute @pxref{Variable
Attributes}).  Macro expansion occurs on the arguments to this pragma
when compiling C and Objective-C@.  It does not currently occur when
compiling C++, but this is a bug which may be fixed in a future
release.

@item fini (@var{function} [, @var{function}]...)
@cindex pragma, fini

This pragma causes each listed @var{function} to be called after
main, or during shared module unloading, by adding a call to the
@code{.fini} section.

@item init (@var{function} [, @var{function}]...)
@cindex pragma, init

This pragma causes each listed @var{function} to be called during
initialization (before @code{main}) or during shared module loading, by
adding a call to the @code{.init} section.

@end table

@node Symbol-Renaming Pragmas
@subsection Symbol-Renaming Pragmas

GCC supports a @code{#pragma} directive that changes the name used in
assembly for a given declaration. While this pragma is supported on all
platforms, it is intended primarily to provide compatibility with the
Solaris system headers. This effect can also be achieved using the asm
labels extension (@pxref{Asm Labels}).

@table @code
@item redefine_extname @var{oldname} @var{newname}
@cindex pragma, redefine_extname

This pragma gives the C function @var{oldname} the assembly symbol
@var{newname}.  The preprocessor macro @code{__PRAGMA_REDEFINE_EXTNAME}
is defined if this pragma is available (currently on all platforms).
@end table

This pragma and the asm labels extension interact in a complicated
manner.  Here are some corner cases you may want to be aware of:

@enumerate
@item This pragma silently applies only to declarations with external
linkage.  Asm labels do not have this restriction.

@item In C++, this pragma silently applies only to declarations with
``C'' linkage.  Again, asm labels do not have this restriction.

@item If either of the ways of changing the assembly name of a
declaration are applied to a declaration whose assembly name has
already been determined (either by a previous use of one of these
features, or because the compiler needed the assembly name in order to
generate code), and the new name is different, a warning issues and
the name does not change.

@item The @var{oldname} used by @code{#pragma redefine_extname} is
always the C-language name.
@end enumerate

@node Structure-Layout Pragmas
@subsection Structure-Layout Pragmas

For compatibility with Microsoft Windows compilers, GCC supports a
set of @code{#pragma} directives that change the maximum alignment of
members of structures (other than zero-width bit-fields), unions, and
classes subsequently defined. The @var{n} value below always is required
to be a small power of two and specifies the new alignment in bytes.

@enumerate
@item @code{#pragma pack(@var{n})} simply sets the new alignment.
@item @code{#pragma pack()} sets the alignment to the one that was in
effect when compilation started (see also command-line option
@option{-fpack-struct[=@var{n}]} @pxref{Code Gen Options}).
@item @code{#pragma pack(push[,@var{n}])} pushes the current alignment
setting on an internal stack and then optionally sets the new alignment.
@item @code{#pragma pack(pop)} restores the alignment setting to the one
saved at the top of the internal stack (and removes that stack entry).
Note that @code{#pragma pack([@var{n}])} does not influence this internal
stack; thus it is possible to have @code{#pragma pack(push)} followed by
multiple @code{#pragma pack(@var{n})} instances and finalized by a single
@code{#pragma pack(pop)}.
@end enumerate

Some targets, e.g.@: x86 and PowerPC, support the @code{#pragma ms_struct}
directive which lays out structures and unions subsequently defined as the
documented @code{__attribute__ ((ms_struct))}.

@enumerate
@item @code{#pragma ms_struct on} turns on the Microsoft layout.
@item @code{#pragma ms_struct off} turns off the Microsoft layout.
@item @code{#pragma ms_struct reset} goes back to the default layout.
@end enumerate

Most targets also support the @code{#pragma scalar_storage_order} directive
which lays out structures and unions subsequently defined as the documented
@code{__attribute__ ((scalar_storage_order))}.

@enumerate
@item @code{#pragma scalar_storage_order big-endian} sets the storage order
of the scalar fields to big-endian.
@item @code{#pragma scalar_storage_order little-endian} sets the storage order
of the scalar fields to little-endian.
@item @code{#pragma scalar_storage_order default} goes back to the endianness
that was in effect when compilation started (see also command-line option
@option{-fsso-struct=@var{endianness}} @pxref{C Dialect Options}).
@end enumerate

@node Weak Pragmas
@subsection Weak Pragmas

For compatibility with SVR4, GCC supports a set of @code{#pragma}
directives for declaring symbols to be weak, and defining weak
aliases.

@table @code
@item #pragma weak @var{symbol}
@cindex pragma, weak
This pragma declares @var{symbol} to be weak, as if the declaration
had the attribute of the same name.  The pragma may appear before
or after the declaration of @var{symbol}.  It is not an error for
@var{symbol} to never be defined at all.

@item #pragma weak @var{symbol1} = @var{symbol2}
This pragma declares @var{symbol1} to be a weak alias of @var{symbol2}.
It is an error if @var{symbol2} is not defined in the current
translation unit.
@end table

@node Diagnostic Pragmas
@subsection Diagnostic Pragmas

GCC allows the user to selectively enable or disable certain types of
diagnostics, and change the kind of the diagnostic.  For example, a
project's policy might require that all sources compile with
@option{-Werror} but certain files might have exceptions allowing
specific types of warnings.  Or, a project might selectively enable
diagnostics and treat them as errors depending on which preprocessor
macros are defined.

@table @code
@item #pragma GCC diagnostic @var{kind} @var{option}
@cindex pragma, diagnostic

Modifies the disposition of a diagnostic.  Note that not all
diagnostics are modifiable; at the moment only warnings (normally
controlled by @samp{-W@dots{}}) can be controlled, and not all of them.
Use @option{-fdiagnostics-show-option} to determine which diagnostics
are controllable and which option controls them.

@var{kind} is @samp{error} to treat this diagnostic as an error,
@samp{warning} to treat it like a warning (even if @option{-Werror} is
in effect), or @samp{ignored} if the diagnostic is to be ignored.
@var{option} is a double quoted string that matches the command-line
option.

@smallexample
#pragma GCC diagnostic warning "-Wformat"
#pragma GCC diagnostic error "-Wformat"
#pragma GCC diagnostic ignored "-Wformat"
@end smallexample

Note that these pragmas override any command-line options.  GCC keeps
track of the location of each pragma, and issues diagnostics according
to the state as of that point in the source file.  Thus, pragmas occurring
after a line do not affect diagnostics caused by that line.

@item #pragma GCC diagnostic push
@itemx #pragma GCC diagnostic pop

Causes GCC to remember the state of the diagnostics as of each
@code{push}, and restore to that point at each @code{pop}.  If a
@code{pop} has no matching @code{push}, the command-line options are
restored.

@smallexample
#pragma GCC diagnostic error "-Wuninitialized"
  foo(a);                       /* error is given for this one */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
  foo(b);                       /* no diagnostic for this one */
#pragma GCC diagnostic pop
  foo(c);                       /* error is given for this one */
#pragma GCC diagnostic pop
  foo(d);                       /* depends on command-line options */
@end smallexample

@end table

GCC also offers a simple mechanism for printing messages during
compilation.

@table @code
@item #pragma message @var{string}
@cindex pragma, diagnostic

Prints @var{string} as a compiler message on compilation.  The message
is informational only, and is neither a compilation warning nor an error.

@smallexample
#pragma message "Compiling " __FILE__ "..."
@end smallexample

@var{string} may be parenthesized, and is printed with location
information.  For example,

@smallexample
#define DO_PRAGMA(x) _Pragma (#x)
#define TODO(x) DO_PRAGMA(message ("TODO - " #x))

TODO(Remember to fix this)
@end smallexample

@noindent
prints @samp{/tmp/file.c:4: note: #pragma message:
TODO - Remember to fix this}.

@end table

@node Visibility Pragmas
@subsection Visibility Pragmas

@table @code
@item #pragma GCC visibility push(@var{visibility})
@itemx #pragma GCC visibility pop
@cindex pragma, visibility

This pragma allows the user to set the visibility for multiple
declarations without having to give each a visibility attribute
(@pxref{Function Attributes}).

In C++, @samp{#pragma GCC visibility} affects only namespace-scope
declarations.  Class members and template specializations are not
affected; if you want to override the visibility for a particular
member or instantiation, you must use an attribute.

@end table


@node Push/Pop Macro Pragmas
@subsection Push/Pop Macro Pragmas

For compatibility with Microsoft Windows compilers, GCC supports
@samp{#pragma push_macro(@var{"macro_name"})}
and @samp{#pragma pop_macro(@var{"macro_name"})}.

@table @code
@item #pragma push_macro(@var{"macro_name"})
@cindex pragma, push_macro
This pragma saves the value of the macro named as @var{macro_name} to
the top of the stack for this macro.

@item #pragma pop_macro(@var{"macro_name"})
@cindex pragma, pop_macro
This pragma sets the value of the macro named as @var{macro_name} to
the value on top of the stack for this macro. If the stack for
@var{macro_name} is empty, the value of the macro remains unchanged.
@end table

For example:

@smallexample
#define X  1
#pragma push_macro("X")
#undef X
#define X -1
#pragma pop_macro("X")
int x [X];
@end smallexample

@noindent
In this example, the definition of X as 1 is saved by @code{#pragma
push_macro} and restored by @code{#pragma pop_macro}.

@node Function Specific Option Pragmas
@subsection Function Specific Option Pragmas

@table @code
@item #pragma GCC target (@var{"string"}...)
@cindex pragma GCC target

This pragma allows you to set target specific options for functions
defined later in the source file.  One or more strings can be
specified.  Each function that is defined after this point is as
if @code{attribute((target("STRING")))} was specified for that
function.  The parenthesis around the options is optional.
@xref{Function Attributes}, for more information about the
@code{target} attribute and the attribute syntax.

The @code{#pragma GCC target} pragma is presently implemented for
x86, ARM, AArch64, PowerPC, S/390, and Nios II targets only.

@item #pragma GCC optimize (@var{"string"}...)
@cindex pragma GCC optimize

This pragma allows you to set global optimization options for functions
defined later in the source file.  One or more strings can be
specified.  Each function that is defined after this point is as
if @code{attribute((optimize("STRING")))} was specified for that
function.  The parenthesis around the options is optional.
@xref{Function Attributes}, for more information about the
@code{optimize} attribute and the attribute syntax.

@item #pragma GCC push_options
@itemx #pragma GCC pop_options
@cindex pragma GCC push_options
@cindex pragma GCC pop_options

These pragmas maintain a stack of the current target and optimization
options.  It is intended for include files where you temporarily want
to switch to using a different @samp{#pragma GCC target} or
@samp{#pragma GCC optimize} and then to pop back to the previous
options.

@item #pragma GCC reset_options
@cindex pragma GCC reset_options

This pragma clears the current @code{#pragma GCC target} and
@code{#pragma GCC optimize} to use the default switches as specified
on the command line.

@end table

@node Loop-Specific Pragmas
@subsection Loop-Specific Pragmas

@table @code
@item #pragma GCC ivdep
@cindex pragma GCC ivdep

With this pragma, the programmer asserts that there are no loop-carried
dependencies which would prevent consecutive iterations of
the following loop from executing concurrently with SIMD
(single instruction multiple data) instructions.

For example, the compiler can only unconditionally vectorize the following
loop with the pragma:

@smallexample
void foo (int n, int *a, int *b, int *c)
@{
  int i, j;
#pragma GCC ivdep
  for (i = 0; i < n; ++i)
    a[i] = b[i] + c[i];
@}
@end smallexample

@noindent
In this example, using the @code{restrict} qualifier had the same
effect. In the following example, that would not be possible. Assume
@math{k < -m} or @math{k >= m}. Only with the pragma, the compiler knows
that it can unconditionally vectorize the following loop:

@smallexample
void ignore_vec_dep (int *a, int k, int c, int m)
@{
#pragma GCC ivdep
  for (int i = 0; i < m; i++)
    a[i] = a[i + k] * c;
@}
@end smallexample

@item #pragma GCC unroll @var{n}
@cindex pragma GCC unroll @var{n}

You can use this pragma to control how many times a loop should be unrolled.
It must be placed immediately before a @code{for}, @code{while} or @code{do}
loop or a @code{#pragma GCC ivdep}, and applies only to the loop that follows.
@var{n} is an integer constant expression specifying the unrolling factor.
The values of @math{0} and @math{1} block any unrolling of the loop.

@end table

@node Unnamed Fields
@section Unnamed Structure and Union Fields
@cindex @code{struct}
@cindex @code{union}

As permitted by ISO C11 and for compatibility with other compilers,
GCC allows you to define
a structure or union that contains, as fields, structures and unions
without names.  For example:

@smallexample
struct @{
  int a;
  union @{
    int b;
    float c;
  @};
  int d;
@} foo;
@end smallexample

@noindent
In this example, you are able to access members of the unnamed
union with code like @samp{foo.b}.  Note that only unnamed structs and
unions are allowed, you may not have, for example, an unnamed
@code{int}.

You must never create such structures that cause ambiguous field definitions.
For example, in this structure:

@smallexample
struct @{
  int a;
  struct @{
    int a;
  @};
@} foo;
@end smallexample

@noindent
it is ambiguous which @code{a} is being referred to with @samp{foo.a}.
The compiler gives errors for such constructs.

@opindex fms-extensions
Unless @option{-fms-extensions} is used, the unnamed field must be a
structure or union definition without a tag (for example, @samp{struct
@{ int a; @};}).  If @option{-fms-extensions} is used, the field may
also be a definition with a tag such as @samp{struct foo @{ int a;
@};}, a reference to a previously defined structure or union such as
@samp{struct foo;}, or a reference to a @code{typedef} name for a
previously defined structure or union type.

@opindex fplan9-extensions
The option @option{-fplan9-extensions} enables
@option{-fms-extensions} as well as two other extensions.  First, a
pointer to a structure is automatically converted to a pointer to an
anonymous field for assignments and function calls.  For example:

@smallexample
struct s1 @{ int a; @};
struct s2 @{ struct s1; @};
extern void f1 (struct s1 *);
void f2 (struct s2 *p) @{ f1 (p); @}
@end smallexample

@noindent
In the call to @code{f1} inside @code{f2}, the pointer @code{p} is
converted into a pointer to the anonymous field.

Second, when the type of an anonymous field is a @code{typedef} for a
@code{struct} or @code{union}, code may refer to the field using the
name of the @code{typedef}.

@smallexample
typedef struct @{ int a; @} s1;
struct s2 @{ s1; @};
s1 f1 (struct s2 *p) @{ return p->s1; @}
@end smallexample

These usages are only permitted when they are not ambiguous.

@node Thread-Local
@section Thread-Local Storage
@cindex Thread-Local Storage
@cindex @acronym{TLS}
@cindex @code{__thread}

Thread-local storage (@acronym{TLS}) is a mechanism by which variables
are allocated such that there is one instance of the variable per extant
thread.  The runtime model GCC uses to implement this originates
in the IA-64 processor-specific ABI, but has since been migrated
to other processors as well.  It requires significant support from
the linker (@command{ld}), dynamic linker (@command{ld.so}), and
system libraries (@file{libc.so} and @file{libpthread.so}), so it
is not available everywhere.

At the user level, the extension is visible with a new storage
class keyword: @code{__thread}.  For example:

@smallexample
__thread int i;
extern __thread struct state s;
static __thread char *p;
@end smallexample

The @code{__thread} specifier may be used alone, with the @code{extern}
or @code{static} specifiers, but with no other storage class specifier.
When used with @code{extern} or @code{static}, @code{__thread} must appear
immediately after the other storage class specifier.

The @code{__thread} specifier may be applied to any global, file-scoped
static, function-scoped static, or static data member of a class.  It may
not be applied to block-scoped automatic or non-static data member.

When the address-of operator is applied to a thread-local variable, it is
evaluated at run time and returns the address of the current thread's
instance of that variable.  An address so obtained may be used by any
thread.  When a thread terminates, any pointers to thread-local variables
in that thread become invalid.

No static initialization may refer to the address of a thread-local variable.

In C++, if an initializer is present for a thread-local variable, it must
be a @var{constant-expression}, as defined in 5.19.2 of the ANSI/ISO C++
standard.

See @uref{https://www.akkadia.org/drepper/tls.pdf,
ELF Handling For Thread-Local Storage} for a detailed explanation of
the four thread-local storage addressing models, and how the runtime
is expected to function.

@menu
* C99 Thread-Local Edits::
* C++98 Thread-Local Edits::
@end menu

@node C99 Thread-Local Edits
@subsection ISO/IEC 9899:1999 Edits for Thread-Local Storage

The following are a set of changes to ISO/IEC 9899:1999 (aka C99)
that document the exact semantics of the language extension.

@itemize @bullet
@item
@cite{5.1.2  Execution environments}

Add new text after paragraph 1

@quotation
Within either execution environment, a @dfn{thread} is a flow of
control within a program.  It is implementation defined whether
or not there may be more than one thread associated with a program.
It is implementation defined how threads beyond the first are
created, the name and type of the function called at thread
startup, and how threads may be terminated.  However, objects
with thread storage duration shall be initialized before thread
startup.
@end quotation

@item
@cite{6.2.4  Storage durations of objects}

Add new text before paragraph 3

@quotation
An object whose identifier is declared with the storage-class
specifier @w{@code{__thread}} has @dfn{thread storage duration}.
Its lifetime is the entire execution of the thread, and its
stored value is initialized only once, prior to thread startup.
@end quotation

@item
@cite{6.4.1  Keywords}

Add @code{__thread}.

@item
@cite{6.7.1  Storage-class specifiers}

Add @code{__thread} to the list of storage class specifiers in
paragraph 1.

Change paragraph 2 to

@quotation
With the exception of @code{__thread}, at most one storage-class
specifier may be given [@dots{}].  The @code{__thread} specifier may
be used alone, or immediately following @code{extern} or
@code{static}.
@end quotation

Add new text after paragraph 6

@quotation
The declaration of an identifier for a variable that has
block scope that specifies @code{__thread} shall also
specify either @code{extern} or @code{static}.

The @code{__thread} specifier shall be used only with
variables.
@end quotation
@end itemize

@node C++98 Thread-Local Edits
@subsection ISO/IEC 14882:1998 Edits for Thread-Local Storage

The following are a set of changes to ISO/IEC 14882:1998 (aka C++98)
that document the exact semantics of the language extension.

@itemize @bullet
@item
@b{[intro.execution]}

New text after paragraph 4

@quotation
A @dfn{thread} is a flow of control within the abstract machine.
It is implementation defined whether or not there may be more than
one thread.
@end quotation

New text after paragraph 7

@quotation
It is unspecified whether additional action must be taken to
ensure when and whether side effects are visible to other threads.
@end quotation

@item
@b{[lex.key]}

Add @code{__thread}.

@item
@b{[basic.start.main]}

Add after paragraph 5

@quotation
The thread that begins execution at the @code{main} function is called
the @dfn{main thread}.  It is implementation defined how functions
beginning threads other than the main thread are designated or typed.
A function so designated, as well as the @code{main} function, is called
a @dfn{thread startup function}.  It is implementation defined what
happens if a thread startup function returns.  It is implementation
defined what happens to other threads when any thread calls @code{exit}.
@end quotation

@item
@b{[basic.start.init]}

Add after paragraph 4

@quotation
The storage for an object of thread storage duration shall be
statically initialized before the first statement of the thread startup
function.  An object of thread storage duration shall not require
dynamic initialization.
@end quotation

@item
@b{[basic.start.term]}

Add after paragraph 3

@quotation
The type of an object with thread storage duration shall not have a
non-trivial destructor, nor shall it be an array type whose elements
(directly or indirectly) have non-trivial destructors.
@end quotation

@item
@b{[basic.stc]}

Add ``thread storage duration'' to the list in paragraph 1.

Change paragraph 2

@quotation
Thread, static, and automatic storage durations are associated with
objects introduced by declarations [@dots{}].
@end quotation

Add @code{__thread} to the list of specifiers in paragraph 3.

@item
@b{[basic.stc.thread]}

New section before @b{[basic.stc.static]}

@quotation
The keyword @code{__thread} applied to a non-local object gives the
object thread storage duration.

A local variable or class data member declared both @code{static}
and @code{__thread} gives the variable or member thread storage
duration.
@end quotation

@item
@b{[basic.stc.static]}

Change paragraph 1

@quotation
All objects that have neither thread storage duration, dynamic
storage duration nor are local [@dots{}].
@end quotation

@item
@b{[dcl.stc]}

Add @code{__thread} to the list in paragraph 1.

Change paragraph 1

@quotation
With the exception of @code{__thread}, at most one
@var{storage-class-specifier} shall appear in a given
@var{decl-specifier-seq}.  The @code{__thread} specifier may
be used alone, or immediately following the @code{extern} or
@code{static} specifiers.  [@dots{}]
@end quotation

Add after paragraph 5

@quotation
The @code{__thread} specifier can be applied only to the names of objects
and to anonymous unions.
@end quotation

@item
@b{[class.mem]}

Add after paragraph 6

@quotation
Non-@code{static} members shall not be @code{__thread}.
@end quotation
@end itemize

@node Binary constants
@section Binary Constants using the @samp{0b} Prefix
@cindex Binary constants using the @samp{0b} prefix

Integer constants can be written as binary constants, consisting of a
sequence of @samp{0} and @samp{1} digits, prefixed by @samp{0b} or
@samp{0B}.  This is particularly useful in environments that operate a
lot on the bit level (like microcontrollers).

The following statements are identical:

@smallexample
i =       42;
i =     0x2a;
i =      052;
i = 0b101010;
@end smallexample

The type of these constants follows the same rules as for octal or
hexadecimal integer constants, so suffixes like @samp{L} or @samp{UL}
can be applied.

@node C++ Extensions
@chapter Extensions to the C++ Language
@cindex extensions, C++ language
@cindex C++ language extensions

The GNU compiler provides these extensions to the C++ language (and you
can also use most of the C language extensions in your C++ programs).  If you
want to write code that checks whether these features are available, you can
test for the GNU compiler the same way as for C programs: check for a
predefined macro @code{__GNUC__}.  You can also use @code{__GNUG__} to
test specifically for GNU C++ (@pxref{Common Predefined Macros,,
Predefined Macros,cpp,The GNU C Preprocessor}).

@menu
* C++ Volatiles::       What constitutes an access to a volatile object.
* Restricted Pointers:: C99 restricted pointers and references.
* Vague Linkage::       Where G++ puts inlines, vtables and such.
* C++ Interface::       You can use a single C++ header file for both
                        declarations and definitions.
* Template Instantiation:: Methods for ensuring that exactly one copy of
                        each needed template instantiation is emitted.
* Bound member functions:: You can extract a function pointer to the
                        method denoted by a @samp{->*} or @samp{.*} expression.
* C++ Attributes::      Variable, function, and type attributes for C++ only.
* Function Multiversioning::   Declaring multiple function versions.
* Type Traits::         Compiler support for type traits.
* C++ Concepts::        Improved support for generic programming.
* Deprecated Features:: Things will disappear from G++.
* Backwards Compatibility:: Compatibilities with earlier definitions of C++.
@end menu

@node C++ Volatiles
@section When is a Volatile C++ Object Accessed?
@cindex accessing volatiles
@cindex volatile read
@cindex volatile write
@cindex volatile access

The C++ standard differs from the C standard in its treatment of
volatile objects.  It fails to specify what constitutes a volatile
access, except to say that C++ should behave in a similar manner to C
with respect to volatiles, where possible.  However, the different
lvalueness of expressions between C and C++ complicate the behavior.
G++ behaves the same as GCC for volatile access, @xref{C
Extensions,,Volatiles}, for a description of GCC's behavior.

The C and C++ language specifications differ when an object is
accessed in a void context:

@smallexample
volatile int *src = @var{somevalue};
*src;
@end smallexample

The C++ standard specifies that such expressions do not undergo lvalue
to rvalue conversion, and that the type of the dereferenced object may
be incomplete.  The C++ standard does not specify explicitly that it
is lvalue to rvalue conversion that is responsible for causing an
access.  There is reason to believe that it is, because otherwise
certain simple expressions become undefined.  However, because it
would surprise most programmers, G++ treats dereferencing a pointer to
volatile object of complete type as GCC would do for an equivalent
type in C@.  When the object has incomplete type, G++ issues a
warning; if you wish to force an error, you must force a conversion to
rvalue with, for instance, a static cast.

When using a reference to volatile, G++ does not treat equivalent
expressions as accesses to volatiles, but instead issues a warning that
no volatile is accessed.  The rationale for this is that otherwise it
becomes difficult to determine where volatile access occur, and not
possible to ignore the return value from functions returning volatile
references.  Again, if you wish to force a read, cast the reference to
an rvalue.

G++ implements the same behavior as GCC does when assigning to a
volatile object---there is no reread of the assigned-to object, the
assigned rvalue is reused.  Note that in C++ assignment expressions
are lvalues, and if used as an lvalue, the volatile object is
referred to.  For instance, @var{vref} refers to @var{vobj}, as
expected, in the following example:

@smallexample
volatile int vobj;
volatile int &vref = vobj = @var{something};
@end smallexample

@node Restricted Pointers
@section Restricting Pointer Aliasing
@cindex restricted pointers
@cindex restricted references
@cindex restricted this pointer

As with the C front end, G++ understands the C99 feature of restricted pointers,
specified with the @code{__restrict__}, or @code{__restrict} type
qualifier.  Because you cannot compile C++ by specifying the @option{-std=c99}
language flag, @code{restrict} is not a keyword in C++.

In addition to allowing restricted pointers, you can specify restricted
references, which indicate that the reference is not aliased in the local
context.

@smallexample
void fn (int *__restrict__ rptr, int &__restrict__ rref)
@{
  /* @r{@dots{}} */
@}
@end smallexample

@noindent
In the body of @code{fn}, @var{rptr} points to an unaliased integer and
@var{rref} refers to a (different) unaliased integer.

You may also specify whether a member function's @var{this} pointer is
unaliased by using @code{__restrict__} as a member function qualifier.

@smallexample
void T::fn () __restrict__
@{
  /* @r{@dots{}} */
@}
@end smallexample

@noindent
Within the body of @code{T::fn}, @var{this} has the effective
definition @code{T *__restrict__ const this}.  Notice that the
interpretation of a @code{__restrict__} member function qualifier is
different to that of @code{const} or @code{volatile} qualifier, in that it
is applied to the pointer rather than the object.  This is consistent with
other compilers that implement restricted pointers.

As with all outermost parameter qualifiers, @code{__restrict__} is
ignored in function definition matching.  This means you only need to
specify @code{__restrict__} in a function definition, rather than
in a function prototype as well.

@node Vague Linkage
@section Vague Linkage
@cindex vague linkage

There are several constructs in C++ that require space in the object
file but are not clearly tied to a single translation unit.  We say that
these constructs have ``vague linkage''.  Typically such constructs are
emitted wherever they are needed, though sometimes we can be more
clever.

@table @asis
@item Inline Functions
Inline functions are typically defined in a header file which can be
included in many different compilations.  Hopefully they can usually be
inlined, but sometimes an out-of-line copy is necessary, if the address
of the function is taken or if inlining fails.  In general, we emit an
out-of-line copy in all translation units where one is needed.  As an
exception, we only emit inline virtual functions with the vtable, since
it always requires a copy.

Local static variables and string constants used in an inline function
are also considered to have vague linkage, since they must be shared
between all inlined and out-of-line instances of the function.

@item VTables
@cindex vtable
C++ virtual functions are implemented in most compilers using a lookup
table, known as a vtable.  The vtable contains pointers to the virtual
functions provided by a class, and each object of the class contains a
pointer to its vtable (or vtables, in some multiple-inheritance
situations).  If the class declares any non-inline, non-pure virtual
functions, the first one is chosen as the ``key method'' for the class,
and the vtable is only emitted in the translation unit where the key
method is defined.

@emph{Note:} If the chosen key method is later defined as inline, the
vtable is still emitted in every translation unit that defines it.
Make sure that any inline virtuals are declared inline in the class
body, even if they are not defined there.

@item @code{type_info} objects
@cindex @code{type_info}
@cindex RTTI
C++ requires information about types to be written out in order to
implement @samp{dynamic_cast}, @samp{typeid} and exception handling.
For polymorphic classes (classes with virtual functions), the @samp{type_info}
object is written out along with the vtable so that @samp{dynamic_cast}
can determine the dynamic type of a class object at run time.  For all
other types, we write out the @samp{type_info} object when it is used: when
applying @samp{typeid} to an expression, throwing an object, or
referring to a type in a catch clause or exception specification.

@item Template Instantiations
Most everything in this section also applies to template instantiations,
but there are other options as well.
@xref{Template Instantiation,,Where's the Template?}.

@end table

When used with GNU ld version 2.8 or later on an ELF system such as
GNU/Linux or Solaris 2, or on Microsoft Windows, duplicate copies of
these constructs will be discarded at link time.  This is known as
COMDAT support.

On targets that don't support COMDAT, but do support weak symbols, GCC
uses them.  This way one copy overrides all the others, but
the unused copies still take up space in the executable.

For targets that do not support either COMDAT or weak symbols,
most entities with vague linkage are emitted as local symbols to
avoid duplicate definition errors from the linker.  This does not happen
for local statics in inlines, however, as having multiple copies
almost certainly breaks things.

@xref{C++ Interface,,Declarations and Definitions in One Header}, for
another way to control placement of these constructs.

@node C++ Interface
@section C++ Interface and Implementation Pragmas

@cindex interface and implementation headers, C++
@cindex C++ interface and implementation headers
@cindex pragmas, interface and implementation

@code{#pragma interface} and @code{#pragma implementation} provide the
user with a way of explicitly directing the compiler to emit entities
with vague linkage (and debugging information) in a particular
translation unit.

@emph{Note:} These @code{#pragma}s have been superceded as of GCC 2.7.2
by COMDAT support and the ``key method'' heuristic
mentioned in @ref{Vague Linkage}.  Using them can actually cause your
program to grow due to unnecessary out-of-line copies of inline
functions.

@table @code
@item #pragma interface
@itemx #pragma interface "@var{subdir}/@var{objects}.h"
@kindex #pragma interface
Use this directive in @emph{header files} that define object classes, to save
space in most of the object files that use those classes.  Normally,
local copies of certain information (backup copies of inline member
functions, debugging information, and the internal tables that implement
virtual functions) must be kept in each object file that includes class
definitions.  You can use this pragma to avoid such duplication.  When a
header file containing @samp{#pragma interface} is included in a
compilation, this auxiliary information is not generated (unless
the main input source file itself uses @samp{#pragma implementation}).
Instead, the object files contain references to be resolved at link
time.

The second form of this directive is useful for the case where you have
multiple headers with the same name in different directories.  If you
use this form, you must specify the same string to @samp{#pragma
implementation}.

@item #pragma implementation
@itemx #pragma implementation "@var{objects}.h"
@kindex #pragma implementation
Use this pragma in a @emph{main input file}, when you want full output from
included header files to be generated (and made globally visible).  The
included header file, in turn, should use @samp{#pragma interface}.
Backup copies of inline member functions, debugging information, and the
internal tables used to implement virtual functions are all generated in
implementation files.

@cindex implied @code{#pragma implementation}
@cindex @code{#pragma implementation}, implied
@cindex naming convention, implementation headers
If you use @samp{#pragma implementation} with no argument, it applies to
an include file with the same basename@footnote{A file's @dfn{basename}
is the name stripped of all leading path information and of trailing
suffixes, such as @samp{.h} or @samp{.C} or @samp{.cc}.} as your source
file.  For example, in @file{allclass.cc}, giving just
@samp{#pragma implementation}
by itself is equivalent to @samp{#pragma implementation "allclass.h"}.

Use the string argument if you want a single implementation file to
include code from multiple header files.  (You must also use
@samp{#include} to include the header file; @samp{#pragma
implementation} only specifies how to use the file---it doesn't actually
include it.)

There is no way to split up the contents of a single header file into
multiple implementation files.
@end table

@cindex inlining and C++ pragmas
@cindex C++ pragmas, effect on inlining
@cindex pragmas in C++, effect on inlining
@samp{#pragma implementation} and @samp{#pragma interface} also have an
effect on function inlining.

If you define a class in a header file marked with @samp{#pragma
interface}, the effect on an inline function defined in that class is
similar to an explicit @code{extern} declaration---the compiler emits
no code at all to define an independent version of the function.  Its
definition is used only for inlining with its callers.

@opindex fno-implement-inlines
Conversely, when you include the same header file in a main source file
that declares it as @samp{#pragma implementation}, the compiler emits
code for the function itself; this defines a version of the function
that can be found via pointers (or by callers compiled without
inlining).  If all calls to the function can be inlined, you can avoid
emitting the function by compiling with @option{-fno-implement-inlines}.
If any calls are not inlined, you will get linker errors.

@node Template Instantiation
@section Where's the Template?
@cindex template instantiation

C++ templates were the first language feature to require more
intelligence from the environment than was traditionally found on a UNIX
system.  Somehow the compiler and linker have to make sure that each
template instance occurs exactly once in the executable if it is needed,
and not at all otherwise.  There are two basic approaches to this
problem, which are referred to as the Borland model and the Cfront model.

@table @asis
@item Borland model
Borland C++ solved the template instantiation problem by adding the code
equivalent of common blocks to their linker; the compiler emits template
instances in each translation unit that uses them, and the linker
collapses them together.  The advantage of this model is that the linker
only has to consider the object files themselves; there is no external
complexity to worry about.  The disadvantage is that compilation time
is increased because the template code is being compiled repeatedly.
Code written for this model tends to include definitions of all
templates in the header file, since they must be seen to be
instantiated.

@item Cfront model
The AT&T C++ translator, Cfront, solved the template instantiation
problem by creating the notion of a template repository, an
automatically maintained place where template instances are stored.  A
more modern version of the repository works as follows: As individual
object files are built, the compiler places any template definitions and
instantiations encountered in the repository.  At link time, the link
wrapper adds in the objects in the repository and compiles any needed
instances that were not previously emitted.  The advantages of this
model are more optimal compilation speed and the ability to use the
system linker; to implement the Borland model a compiler vendor also
needs to replace the linker.  The disadvantages are vastly increased
complexity, and thus potential for error; for some code this can be
just as transparent, but in practice it can been very difficult to build
multiple programs in one directory and one program in multiple
directories.  Code written for this model tends to separate definitions
of non-inline member templates into a separate file, which should be
compiled separately.
@end table

G++ implements the Borland model on targets where the linker supports it,
including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows.
Otherwise G++ implements neither automatic model.

You have the following options for dealing with template instantiations:

@enumerate
@item
Do nothing.  Code written for the Borland model works fine, but
each translation unit contains instances of each of the templates it
uses.  The duplicate instances will be discarded by the linker, but in
a large program, this can lead to an unacceptable amount of code
duplication in object files or shared libraries.

Duplicate instances of a template can be avoided by defining an explicit
instantiation in one object file, and preventing the compiler from doing
implicit instantiations in any other object files by using an explicit
instantiation declaration, using the @code{extern template} syntax:

@smallexample
extern template int max (int, int);
@end smallexample

This syntax is defined in the C++ 2011 standard, but has been supported by
G++ and other compilers since well before 2011.

Explicit instantiations can be used for the largest or most frequently
duplicated instances, without having to know exactly which other instances
are used in the rest of the program.  You can scatter the explicit
instantiations throughout your program, perhaps putting them in the
translation units where the instances are used or the translation units
that define the templates themselves; you can put all of the explicit
instantiations you need into one big file; or you can create small files
like

@smallexample
#include "Foo.h"
#include "Foo.cc"

template class Foo<int>;
template ostream& operator <<
                (ostream&, const Foo<int>&);
@end smallexample

@noindent
for each of the instances you need, and create a template instantiation
library from those.

This is the simplest option, but also offers flexibility and
fine-grained control when necessary. It is also the most portable
alternative and programs using this approach will work with most modern
compilers.

@item
@opindex frepo
Compile your template-using code with @option{-frepo}.  The compiler
generates files with the extension @samp{.rpo} listing all of the
template instantiations used in the corresponding object files that
could be instantiated there; the link wrapper, @samp{collect2},
then updates the @samp{.rpo} files to tell the compiler where to place
those instantiations and rebuild any affected object files.  The
link-time overhead is negligible after the first pass, as the compiler
continues to place the instantiations in the same files.

This can be a suitable option for application code written for the Borland
model, as it usually just works.  Code written for the Cfront model 
needs to be modified so that the template definitions are available at
one or more points of instantiation; usually this is as simple as adding
@code{#include <tmethods.cc>} to the end of each template header.

For library code, if you want the library to provide all of the template
instantiations it needs, just try to link all of its object files
together; the link will fail, but cause the instantiations to be
generated as a side effect.  Be warned, however, that this may cause
conflicts if multiple libraries try to provide the same instantiations.
For greater control, use explicit instantiation as described in the next
option.

@item
@opindex fno-implicit-templates
Compile your code with @option{-fno-implicit-templates} to disable the
implicit generation of template instances, and explicitly instantiate
all the ones you use.  This approach requires more knowledge of exactly
which instances you need than do the others, but it's less
mysterious and allows greater control if you want to ensure that only
the intended instances are used.

If you are using Cfront-model code, you can probably get away with not
using @option{-fno-implicit-templates} when compiling files that don't
@samp{#include} the member template definitions.

If you use one big file to do the instantiations, you may want to
compile it without @option{-fno-implicit-templates} so you get all of the
instances required by your explicit instantiations (but not by any
other files) without having to specify them as well.

In addition to forward declaration of explicit instantiations
(with @code{extern}), G++ has extended the template instantiation
syntax to support instantiation of the compiler support data for a
template class (i.e.@: the vtable) without instantiating any of its
members (with @code{inline}), and instantiation of only the static data
members of a template class, without the support data or member
functions (with @code{static}):

@smallexample
inline template class Foo<int>;
static template class Foo<int>;
@end smallexample
@end enumerate

@node Bound member functions
@section Extracting the Function Pointer from a Bound Pointer to Member Function
@cindex pmf
@cindex pointer to member function
@cindex bound pointer to member function

In C++, pointer to member functions (PMFs) are implemented using a wide
pointer of sorts to handle all the possible call mechanisms; the PMF
needs to store information about how to adjust the @samp{this} pointer,
and if the function pointed to is virtual, where to find the vtable, and
where in the vtable to look for the member function.  If you are using
PMFs in an inner loop, you should really reconsider that decision.  If
that is not an option, you can extract the pointer to the function that
would be called for a given object/PMF pair and call it directly inside
the inner loop, to save a bit of time.

Note that you still pay the penalty for the call through a
function pointer; on most modern architectures, such a call defeats the
branch prediction features of the CPU@.  This is also true of normal
virtual function calls.

The syntax for this extension is

@smallexample
extern A a;
extern int (A::*fp)();
typedef int (*fptr)(A *);

fptr p = (fptr)(a.*fp);
@end smallexample

For PMF constants (i.e.@: expressions of the form @samp{&Klasse::Member}),
no object is needed to obtain the address of the function.  They can be
converted to function pointers directly:

@smallexample
fptr p1 = (fptr)(&A::foo);
@end smallexample

@opindex Wno-pmf-conversions
You must specify @option{-Wno-pmf-conversions} to use this extension.

@node C++ Attributes
@section C++-Specific Variable, Function, and Type Attributes

Some attributes only make sense for C++ programs.

@table @code
@item abi_tag ("@var{tag}", ...)
@cindex @code{abi_tag} function attribute
@cindex @code{abi_tag} variable attribute
@cindex @code{abi_tag} type attribute
The @code{abi_tag} attribute can be applied to a function, variable, or class
declaration.  It modifies the mangled name of the entity to
incorporate the tag name, in order to distinguish the function or
class from an earlier version with a different ABI; perhaps the class
has changed size, or the function has a different return type that is
not encoded in the mangled name.

The attribute can also be applied to an inline namespace, but does not
affect the mangled name of the namespace; in this case it is only used
for @option{-Wabi-tag} warnings and automatic tagging of functions and
variables.  Tagging inline namespaces is generally preferable to
tagging individual declarations, but the latter is sometimes
necessary, such as when only certain members of a class need to be
tagged.

The argument can be a list of strings of arbitrary length.  The
strings are sorted on output, so the order of the list is
unimportant.

A redeclaration of an entity must not add new ABI tags,
since doing so would change the mangled name.

The ABI tags apply to a name, so all instantiations and
specializations of a template have the same tags.  The attribute will
be ignored if applied to an explicit specialization or instantiation.

The @option{-Wabi-tag} flag enables a warning about a class which does
not have all the ABI tags used by its subobjects and virtual functions; for users with code
that needs to coexist with an earlier ABI, using this option can help
to find all affected types that need to be tagged.

When a type involving an ABI tag is used as the type of a variable or
return type of a function where that tag is not already present in the
signature of the function, the tag is automatically applied to the
variable or function.  @option{-Wabi-tag} also warns about this
situation; this warning can be avoided by explicitly tagging the
variable or function or moving it into a tagged inline namespace.

@item init_priority (@var{priority})
@cindex @code{init_priority} variable attribute

In Standard C++, objects defined at namespace scope are guaranteed to be
initialized in an order in strict accordance with that of their definitions
@emph{in a given translation unit}.  No guarantee is made for initializations
across translation units.  However, GNU C++ allows users to control the
order of initialization of objects defined at namespace scope with the
@code{init_priority} attribute by specifying a relative @var{priority},
a constant integral expression currently bounded between 101 and 65535
inclusive.  Lower numbers indicate a higher priority.

In the following example, @code{A} would normally be created before
@code{B}, but the @code{init_priority} attribute reverses that order:

@smallexample
Some_Class  A  __attribute__ ((init_priority (2000)));
Some_Class  B  __attribute__ ((init_priority (543)));
@end smallexample

@noindent
Note that the particular values of @var{priority} do not matter; only their
relative ordering.

@item warn_unused
@cindex @code{warn_unused} type attribute

For C++ types with non-trivial constructors and/or destructors it is
impossible for the compiler to determine whether a variable of this
type is truly unused if it is not referenced. This type attribute
informs the compiler that variables of this type should be warned
about if they appear to be unused, just like variables of fundamental
types.

This attribute is appropriate for types which just represent a value,
such as @code{std::string}; it is not appropriate for types which
control a resource, such as @code{std::lock_guard}.

This attribute is also accepted in C, but it is unnecessary because C
does not have constructors or destructors.

@end table

@node Function Multiversioning
@section Function Multiversioning
@cindex function versions

With the GNU C++ front end, for x86 targets, you may specify multiple
versions of a function, where each function is specialized for a
specific target feature.  At runtime, the appropriate version of the
function is automatically executed depending on the characteristics of
the execution platform.  Here is an example.

@smallexample
__attribute__ ((target ("default")))
int foo ()
@{
  // The default version of foo.
  return 0;
@}

__attribute__ ((target ("sse4.2")))
int foo ()
@{
  // foo version for SSE4.2
  return 1;
@}

__attribute__ ((target ("arch=atom")))
int foo ()
@{
  // foo version for the Intel ATOM processor
  return 2;
@}

__attribute__ ((target ("arch=amdfam10")))
int foo ()
@{
  // foo version for the AMD Family 0x10 processors.
  return 3;
@}

int main ()
@{
  int (*p)() = &foo;
  assert ((*p) () == foo ());
  return 0;
@}
@end smallexample

In the above example, four versions of function foo are created. The
first version of foo with the target attribute "default" is the default
version.  This version gets executed when no other target specific
version qualifies for execution on a particular platform. A new version
of foo is created by using the same function signature but with a
different target string.  Function foo is called or a pointer to it is
taken just like a regular function.  GCC takes care of doing the
dispatching to call the right version at runtime.  Refer to the
@uref{http://gcc.gnu.org/wiki/FunctionMultiVersioning, GCC wiki on
Function Multiversioning} for more details.

@node Type Traits
@section Type Traits

The C++ front end implements syntactic extensions that allow
compile-time determination of 
various characteristics of a type (or of a
pair of types).

@table @code
@item __has_nothrow_assign (type)
If @code{type} is const qualified or is a reference type then the trait is
false.  Otherwise if @code{__has_trivial_assign (type)} is true then the trait
is true, else if @code{type} is a cv class or union type with copy assignment
operators that are known not to throw an exception then the trait is true,
else it is false.  Requires: @code{type} shall be a complete type,
(possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_nothrow_copy (type)
If @code{__has_trivial_copy (type)} is true then the trait is true, else if
@code{type} is a cv class or union type with copy constructors that
are known not to throw an exception then the trait is true, else it is false.
Requires: @code{type} shall be a complete type, (possibly cv-qualified)
@code{void}, or an array of unknown bound.

@item __has_nothrow_constructor (type)
If @code{__has_trivial_constructor (type)} is true then the trait is
true, else if @code{type} is a cv class or union type (or array
thereof) with a default constructor that is known not to throw an
exception then the trait is true, else it is false.  Requires:
@code{type} shall be a complete type, (possibly cv-qualified)
@code{void}, or an array of unknown bound.

@item __has_trivial_assign (type)
If @code{type} is const qualified or is a reference type then the trait is
false.  Otherwise if @code{__is_pod (type)} is true then the trait is
true, else if @code{type} is a cv class or union type with a trivial
copy assignment ([class.copy]) then the trait is true, else it is
false.  Requires: @code{type} shall be a complete type, (possibly
cv-qualified) @code{void}, or an array of unknown bound.

@item __has_trivial_copy (type)
If @code{__is_pod (type)} is true or @code{type} is a reference type
then the trait is true, else if @code{type} is a cv class or union type
with a trivial copy constructor ([class.copy]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_trivial_constructor (type)
If @code{__is_pod (type)} is true then the trait is true, else if
@code{type} is a cv class or union type (or array thereof) with a
trivial default constructor ([class.ctor]) then the trait is true,
else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_trivial_destructor (type)
If @code{__is_pod (type)} is true or @code{type} is a reference type then
the trait is true, else if @code{type} is a cv class or union type (or
array thereof) with a trivial destructor ([class.dtor]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __has_virtual_destructor (type)
If @code{type} is a class type with a virtual destructor
([class.dtor]) then the trait is true, else it is false.  Requires:
@code{type} shall be a complete type, (possibly cv-qualified)
@code{void}, or an array of unknown bound.

@item __is_abstract (type)
If @code{type} is an abstract class ([class.abstract]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_base_of (base_type, derived_type)
If @code{base_type} is a base class of @code{derived_type}
([class.derived]) then the trait is true, otherwise it is false.
Top-level cv qualifications of @code{base_type} and
@code{derived_type} are ignored.  For the purposes of this trait, a
class type is considered is own base.  Requires: if @code{__is_class
(base_type)} and @code{__is_class (derived_type)} are true and
@code{base_type} and @code{derived_type} are not the same type
(disregarding cv-qualifiers), @code{derived_type} shall be a complete
type.  A diagnostic is produced if this requirement is not met.

@item __is_class (type)
If @code{type} is a cv class type, and not a union type
([basic.compound]) the trait is true, else it is false.

@item __is_empty (type)
If @code{__is_class (type)} is false then the trait is false.
Otherwise @code{type} is considered empty if and only if: @code{type}
has no non-static data members, or all non-static data members, if
any, are bit-fields of length 0, and @code{type} has no virtual
members, and @code{type} has no virtual base classes, and @code{type}
has no base classes @code{base_type} for which
@code{__is_empty (base_type)} is false.  Requires: @code{type} shall
be a complete type, (possibly cv-qualified) @code{void}, or an array
of unknown bound.

@item __is_enum (type)
If @code{type} is a cv enumeration type ([basic.compound]) the trait is
true, else it is false.

@item __is_literal_type (type)
If @code{type} is a literal type ([basic.types]) the trait is
true, else it is false.  Requires: @code{type} shall be a complete type,
(possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_pod (type)
If @code{type} is a cv POD type ([basic.types]) then the trait is true,
else it is false.  Requires: @code{type} shall be a complete type,
(possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_polymorphic (type)
If @code{type} is a polymorphic class ([class.virtual]) then the trait
is true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_standard_layout (type)
If @code{type} is a standard-layout type ([basic.types]) the trait is
true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_trivial (type)
If @code{type} is a trivial type ([basic.types]) the trait is
true, else it is false.  Requires: @code{type} shall be a complete
type, (possibly cv-qualified) @code{void}, or an array of unknown bound.

@item __is_union (type)
If @code{type} is a cv union type ([basic.compound]) the trait is
true, else it is false.

@item __underlying_type (type)
The underlying type of @code{type}.  Requires: @code{type} shall be
an enumeration type ([dcl.enum]).

@item __integer_pack (length)
When used as the pattern of a pack expansion within a template
definition, expands to a template argument pack containing integers
from @code{0} to @code{length-1}.  This is provided for efficient
implementation of @code{std::make_integer_sequence}.

@end table


@node C++ Concepts
@section C++ Concepts

C++ concepts provide much-improved support for generic programming. In
particular, they allow the specification of constraints on template arguments.
The constraints are used to extend the usual overloading and partial
specialization capabilities of the language, allowing generic data structures
and algorithms to be ``refined'' based on their properties rather than their
type names.

The following keywords are reserved for concepts.

@table @code
@item assumes
States an expression as an assumption, and if possible, verifies that the
assumption is valid. For example, @code{assume(n > 0)}.

@item axiom
Introduces an axiom definition. Axioms introduce requirements on values.

@item forall
Introduces a universally quantified object in an axiom. For example,
@code{forall (int n) n + 0 == n}).

@item concept
Introduces a concept definition. Concepts are sets of syntactic and semantic
requirements on types and their values.

@item requires
Introduces constraints on template arguments or requirements for a member
function of a class template.

@end table

The front end also exposes a number of internal mechanism that can be used
to simplify the writing of type traits. Note that some of these traits are
likely to be removed in the future.

@table @code
@item __is_same (type1, type2)
A binary type trait: true whenever the type arguments are the same.

@end table


@node Deprecated Features
@section Deprecated Features

In the past, the GNU C++ compiler was extended to experiment with new
features, at a time when the C++ language was still evolving.  Now that
the C++ standard is complete, some of those features are superseded by
superior alternatives.  Using the old features might cause a warning in
some cases that the feature will be dropped in the future.  In other
cases, the feature might be gone already.

While the list below is not exhaustive, it documents some of the options
that are now deprecated or have been removed:

@table @code

@item -fno-for-scope
@itemx -ffriend-injection
These two options provide compatibility with pre-standard C++.
@xref{Backwards Compatibility}.

@end table

G++ allows a virtual function returning @samp{void *} to be overridden
by one returning a different pointer type.  This extension to the
covariant return type rules is now deprecated and will be removed from a
future version.

The use of default arguments in function pointers, function typedefs
and other places where they are not permitted by the standard is
deprecated and will be removed from a future version of G++.

G++ allows floating-point literals to appear in integral constant expressions,
e.g.@: @samp{ enum E @{ e = int(2.2 * 3.7) @} }
This extension is deprecated and will be removed from a future version.

G++ allows static data members of const floating-point type to be declared
with an initializer in a class definition. The standard only allows
initializers for static members of const integral types and const
enumeration types so this extension has been deprecated and will be removed
from a future version.

G++ allows attributes to follow a parenthesized direct initializer,
e.g.@: @samp{ int f (0) __attribute__ ((something)); } This extension
has been ignored since G++ 3.3 and is deprecated.

G++ allows anonymous structs and unions to have members that are not
public non-static data members (i.e.@: fields).  These extensions are
deprecated.

@node Backwards Compatibility
@section Backwards Compatibility
@cindex Backwards Compatibility
@cindex ARM [Annotated C++ Reference Manual]

Now that there is a definitive ISO standard C++, G++ has a specification
to adhere to.  The C++ language evolved over time, and features that
used to be acceptable in previous drafts of the standard, such as the ARM
[Annotated C++ Reference Manual], are no longer accepted.  In order to allow
compilation of C++ written to such drafts, G++ contains some backwards
compatibilities.  @emph{All such backwards compatibility features are
liable to disappear in future versions of G++.} They should be considered
deprecated.   @xref{Deprecated Features}.

@table @code
@item For scope
If a variable is declared at for scope, it used to remain in scope
until the end of the scope that contained the for statement (rather
than just within the for scope).  The deprecated
@option{-fno-for-scope} option enables this non-standard behavior.
Without the option, G++ retains this, but issues a warning, if such a
variable is accessed outside the for scope.

The behavior is deprecated, only available with @option{-std=c++98}
@option{-std=gnu++98} languages and you must use the
@option{-fpermissive} option to enable it.  The behavior will be
removed.

@item Friend Injection
The @option{-ffriend-injection} option makes injected friends visible
to regular name lookup, unlike standard C++.  This option is
deprecated and will be removed.

@item Implicit C language
Old C system header files did not contain an @code{extern "C" @{@dots{}@}}
scope to set the language.  On such systems, all header files are
implicitly scoped inside a C language scope.  Also, an empty prototype
@code{()} is treated as an unspecified number of arguments, rather
than no arguments, as C++ demands.
@end table

@c  LocalWords:  emph deftypefn builtin ARCv2EM SIMD builtins msimd
@c  LocalWords:  typedef v4si v8hi DMA dma vdiwr vdowr
