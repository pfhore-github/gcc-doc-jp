@c Copyright (C) 2001-2017 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node C Implementation
@chapter Cの実装定義の振る舞い
@cindex implementation-defined behavior, C language

ISO Cの適合する実装は、「実装定義」と呼ばれる各分野における行動の選択肢を文書化することを要求している。ISO / IEC 9899：1990、ISO/IEC 9899：1999およびISO/IEC 9899：2011規格のセクション番号とともに、このようなすべての領域を以下に示す。一部の領域は、標準の1つのバージョンでのみ実装定義されている。

いくつかの選択肢は、GCCが従うプラットフォーム（標準の文字エンコーディングを含む）のために外部で決定されたABIに依存する。 これらは「ABIによって決定される」と以下にリストされている。@xref{Compatibility, , Binary Compatibility}, と@uref{http://gcc.gnu.org/readings.html}。いくつかの選択肢は、プリプロセッサのマニュアルに記載されている。
@xref{Implementation-defined behavior, , Implementation-defined behavior, cpp, The C Preprocessor}.  ライブラリとオペレーティングシステム（または自立環境用にコンパイルするときは他の環境）によって選択されるものもある。 詳細については、そのドキュメントを参照せよ。

@menu
* 翻訳実装::
* 環境実装::
* 識別子実装::
* 文字実装::
* 整数実装::
* 浮動小数点実装::
* 配列とポインタの実装::
* ヒントの実装::
* Structures unions enumerations and bit-fields implementation::
* Qualifiers implementation::
* Declarators implementation::
* Statements implementation::
* Preprocessing directives implementation::
* Library functions implementation::
* Architecture implementation::
* Locale-specific behavior implementation::
@end menu

@node 翻訳実装
@section 翻訳

@itemize @bullet
@item
@cite{診断の特定方法 (C90 3.7, C99 と C11 3.10, C90, C99 と C11 5.1.1.3)。}

診断は、GCCによってすべてstderrに送信された出力で構成される。

@item
@cite{改行以外の空白以外の空白文字列が、翻訳フェーズ3で1つの空白文字で保持されているか置き換えられているかどうか (C90, C99 と C11 5.1.1.2)。}

@xref{Implementation-defined behavior, , Implementation-defined
behavior, cpp, The C Preprocessor}

@end itemize

@node 環境実装
@section 環境

これらのポイントのほとんどの動作は、Cライブラリの実装に依存しており、GCC自体では定義されていない。

@itemize @bullet
@item
@cite{翻訳フェーズ1で物理ソースファイルのマルチバイト文字とソースキャラクタセットとの間のマッピング (C90, C99 と C11 5.1.1.2).}

@xref{Implementation-defined behavior, , Implementation-defined
behavior, cpp, The C Preprocessor}

@end itemize

@node 識別子実装
@section 識別子

@itemize @bullet
@item
@cite{どの追加のマルチバイト文字が識別子に現れ、ユニバーサル文字名に対応するか (C99 と C11 6.4.2)。}

@xref{Implementation-defined behavior, , Implementation-defined
behavior, cpp, The C Preprocessor}

@item
@cite{識別子の有効な初期文字の数
(C90 6.1.2, C90, C99 と C11 5.2.4.1, C99 と C11 6.4.2)。}

内部名の場合、すべての文字が有効である。 外部名の場合、重要な文字の数はリンカーによって定義される。 ほぼすべてのターゲットで、すべての文字が有効である。

@item
@cite{外部リンケージを持つ識別子で大文字と小文字の区別が有効であるかどうか (C90 6.1.2).}

これはリンカーのプロパティである。 C99とC11では、外部リンクを持つ識別子で大文字と小文字の区別が常に有効であり、このプロパティのないシステムはGCCではサポートされていない。

@end itemize

@node 文字実装
@section 文字

@itemize @bullet
@item
@cite{バイトのビット数 (C90 3.4, C99 と C11 3.6)。}

ABIによって決定される。

@item
@cite{実行文字集合のメンバの数 (C90, C99 と C11 5.2.1)。}

ABIによって決定される。

@item
@cite{各標準アルファベットエスケープシーケンスに対して生成された実行文字セットのメンバの一意の値。 (C90, C99 と C11 5.2.2).}

ABIによって決定される。

@item
@cite{基本実行文字セットのメンバー以外の文字が格納されている@code {char}オブジェクトの値
(C90 6.1.2.5, C99 と C11 6.2.5。}

ABIによって決定される。

@item
@cite{@code {signed char}または@code {unsigned char}のどちらが「素の」@code{char}と同じ範囲、表現、動作を持つか(C90 6.1.2.5, C90 6.2.1.1, C99 と C11 6.2.5, C99 と C11 6.3.1.1)。}

@opindex fsigned-char
@opindex funsigned-char
ABIによって決定される。 オプション@option {-funsigned-char}と@option {-fsigned-char}はデフォルトを変更する。 @xref{C Dialect Options, ,Options Controlling C Dialect}

@item
@cite{ソース文字セット（文字定数と文字列リテラル）のメンバーの実行文字セットのメンバーへのマッピング (C90 6.1.3.4, C99 と C11 6.4.4.4, C90, C99 と C11 5.1.1.2)。}

ABIによって決定される。

@item
@cite{複数の文字を含む、またはシングルバイトの実行文字にマップされない文字またはエスケープシーケンスを含む整数文字定数の値 (C90 6.1.3.4, C99 と C11 6.4.4.4)。}

@xref{Implementation-defined behavior, , Implementation-defined behavior, cpp, The C Preprocessor}

@item
@cite{複数のマルチバイト文字を含むワイド文字定数、または拡張実行文字セットの複数のメンバーにマップする単一マルチバイト文字、または拡張実行文字セットで表されていないマルチバイト文字またはエスケープシーケンスを含むワイド文字定数の値 (C90 6.1.3.4, C99 と C11 6.4.4.4)。}

@xref{Implementation-defined behavior, , Implementation-defined behavior, cpp, The C Preprocessor}

@item
@cite{拡張実行文字セットのメンバーにマップされる単一のマルチバイト文字からなるワイド文字定数を対応するワイド文字コードに変換するために使用される現在のロケール (C90 6.1.3.4, C99 と C11 6.4.4.4).}

@xref{Implementation-defined behavior, , Implementation-defined
behavior, cpp, The C Preprocessor}

@item
@cite{異なる接頭辞のワイド文字列リテラルトークンを連結することができるかどうか、もしそうであれば、結果として生じるマルチバイト文字シーケンスの処理 (C11 6.4.5)。}

そのようなトークンは連結することはできない。

@item
@cite{ワイド文字列リテラルを対応するワイド文字コードに変換するために使用される現在のロケール (C90 6.1.4, C99 と C11 6.4.5)。}

@xref{Implementation-defined behavior, , Implementation-defined
behavior, cpp, The C Preprocessor}.

@item
@cite{実行文字セットで表されていないマルチバイト文字またはエスケープシーケンスを含む文字列リテラルの値 (C90 6.1.4, C99 と C11 6.4.5)。}

@xref{Implementation-defined behavior, , Implementation-defined
behavior, cpp, The C Preprocessor}

@item
@cite{対応する標準エンコーディングマクロ(@code{__STDC_ISO_10646__}, @code{__STDC_UTF_16__}, or
@code{__STDC_UTF_32__})が定義されていないときの@code{wchar_t}、@code{char16_t}、および@code{char32_t}のいずれかのエンコーディング (C11 6.10.8.2).}

@xref{Implementation-defined behavior, , Implementation-defined behavior, cpp, The C Preprocessor}.  @code {char16_t}と@code {char32_t}リテラルは、それぞれ常にUTF-16とUTF-32でエンコードされる。

@end itemize

@node 整数実装
@section 整数

@itemize @bullet
@item
@cite{実装に存在するすべての拡張整数型 (C99とC11 6.2.5)。}

GCCは拡張整数型をサポートしていない。
@c The __mode__ attribute might create types of precisions not
@c otherwise supported, but the syntax isn't right for use everywhere
@c the standard type names might be used.  Predefined typedefs should
@c be used if any extended integer types are to be defined.  The
@c __int128_t and __uint128_t typedefs are not extended integer types
@c as they are generally longer than the ABI-specified intmax_t.

@item
@cite{符号付き整数型が符号と大きさで表現されるのか、2の補数なのか、または1の補数を使用して表現されるかどうか、および異常値がトラップ表現か通常値かどうか。 (C99 と C11 6.2.6.2)。}

GCCは2の補数の整数型のみをサポートし、すべてのビットパターンは通常の値である。

@item
@cite{同じ精度を持つ別の拡張整数型に関連する拡張整数型のランク (C99 と C11 6.3.1.1)。}

GCCは拡張整数型をサポートしていない。
@c If it did, there would only be one of each precision and signedness.

@item
@cite{その型のオブジェクトで値を表現できないときに、整数を符号付き整数型に変換した結果、またはそれによって生成されたシグナル (C90 6.2.1.2, C99 と C11 6.3.1.3)。}

幅@math{N}の型に変換する場合、値は@math{2^N}で割ったあまりである。 シグナルは発生しない。

@item
@cite{符号付き整数のビット演算の結果 (C90 6.3, C99 と C11 6.5)。}

ビット演算子は、符号ビットと値ビットの両方を含む値の表現に作用する。符号ビットは、最大値のビットのすぐ上にあるとみなされる。 符号付き@samp{>>}は符号拡張で負の数に作用する。

C言語への拡張として、GCCはC99とC11で与えられた自由度を使用して、符号付き@samp{<<}の特定の側面を未定義として扱わない。しかし、@option{-fsanitize=shift}（および@option{-fsanitize=undefined}）は、このようなケースを診断する。 定数値が必要な場合も診断される。

@item
@cite{整数除算の余りの符号 (C90 6.3.5)。}

GCCは、除算の結果がゼロに向かって切り捨てられるというC99とC11の要件に常に従う。

@end itemize

@node 浮動小数点実装
@section 浮動小数点

@itemize @bullet
@item
@cite{浮動小数点演算と、浮動小数点結果を返す@code{<math.h>}および@code{<complex.h>}のライブラリ関数の精度 (C90, C99 と C11 5.2.4.2.2)。}

精度は不明である。

@item
@cite{@code{FLT_ROUNDS}の非標準値によって特徴付けられる丸め動作(C90, C99 と C11 5.2.4.2.2)。}

GCCにはそのような値はない。

@item
@cite{@code{FLT_EVAL_METHOD}の非標準の負の値によって特徴付けられる評価方法 (C99 と C11 5.2.4.2.2)。}

GCCにはそのような値はない。

@item
@cite{整数が、元の値を正確に表現できない浮動小数点数に変換された場合の丸めの方向 (C90 6.2.1.3, C99 と C11 6.3.1.4)。}

C99付録Fに従う。

@item
@cite{浮動小数点数をより小さい浮動小数点数に変換する場合の丸めの方向 (C90 6.2.1.4, C99 と C11 6.3.1.5)。}

C99付録Fに従う。

@item
@cite{最も近い表現可能な値、または最も近い表現可能な値に直に隣接するより大きなまたはより小さな表現可能な値が、ある浮動定数に対してどのように選択されるか (C90 6.1.3.1, C99 と C11 6.4.4.2)。}

C99付録Fに従う。

@item
@cite{@code {FP_CONTRACT}プラグマで許可されていない浮動式が収縮するかどうか (C99 と C11 6.5)。}

式は、@option{-ffp-contract=fast}、@option{-funsafe-math-optimizations}または@option{-ffast-math}が使用されている場合にのみ、現在のところ収縮する。これは変更されることがある。

@item
@cite{@code {FENV_ACCESS}プラグマのデフォルトの状態 (C99 と C11 7.6.1)。}

このプラグマは実装されていないが、デフォルトは@option{-frounding-math}が使われていない限りは「オフ」であり、使われている場合は「オン」である。

@item
@cite{追加の浮動小数点例外、丸めモード、環境、および分類、およびそれらのマクロ名(C99 と C11 7.6, C99 と C11 7.12)。}

これはCライブラリの実装に依存し、GCC自体では定義されていない。

@item
@cite{@code{FP_CONTRACT}プラグマのデフォルトの状態 (C99 と C11 7.12.2)。}

このプラグマは実装されていない。 式は、@option{-ffp-contract = fast}、@option{-funsafe-math-optimizations}または@option{-ffast-math}が使用されている場合にのみ、現在のところ収縮する。これは変更されることがある。

@item
@cite{丸められた結果が実際にIEC 60559準拠の実装における数学的結果と等しい場合に、「不正確な」浮動小数点例外を発生させることができるかどうか (C99 F.9)。}

これはCライブラリの実装に依存し、GCC自体では定義されていない。

@item
@cite{結果が小さいが、IEC 60559準拠の実装では不正確ではない場合に、「アンダーフロー」（および「不正確」）浮動小数点例外を発生させることができるかどうか (C99 F.9)。}

これはCライブラリの実装に依存し、GCC自体では定義されていない。

@end itemize

@node 配列とポインタの実装
@section 配列とポインタ

@itemize @bullet
@item
@cite{ポインタを整数に変換した結果、またはその逆の結果 (C90 6.3.4, C99 と C11 6.3.2.3)。}

ポインタ表現が整数型より大きい場合、ポインタから整数へのキャストは最上位ビットを破棄し、ポインタ表現が整数型よりも小さい場合は符号拡張し@footnote{GCCの将来のバージョンは、ゼロ拡張するか、ターゲット定義の@code{ptr_extend}パターンを使用するかもしれない。 符号拡張に頼ってはならない。}、そうでない場合はビットは変更されない。

@c ??? We've always claimed that pointers were unsigned entities.
@c Shouldn't we therefore be doing zero-extension?  If so, the bug
@c is in convert_to_integer, where we call type_for_size and request
@c a signed integral type.  On the other hand, it might be most useful
@c for the target if we extend according to POINTERS_EXTEND_UNSIGNED.

整数からポインタへのキャストは、ポインタ表現が整数型よりも小さい場合は最上位ビットを破棄し、ポインタ表現が整数型より大きい場合は整数型の符号長に従って拡張する。そうでなければビットは変更されない。

ポインタから整数へのキャストと再び戻るとき、結果のポインタは元のポインタと同じオブジェクトを参照する必要がある。そうでない場合、動作は未定義である。 つまり、C99とC11 6.5.6/8で宣言されているポインタ算術の未定義の振る舞いを避けるために、整数算術を使用することはできない。

@item
@cite{同じ配列の要素への2つのポインタを減算した結果のサイズ (C90 6.3.6, C99 と C11 6.5.6)。}

値は標準で指定されているとおりであり、型はABIによって決定されます。

@end itemize

@node ヒントの実装
@section ヒント

@itemize @bullet
@item
@cite{@code{register}ストレージクラス指定子を使用して提案された提案が有効である範囲 (C90 6.5.1, C99 と C11 6.7.1)。}

@code {register}指定子は、以下の方法でのみコード生成に影響する。

@itemize @bullet
@item
レジスタ変数拡張の一部として使用する場合、@ref{Explicit Register Variables}参照。

@item
@option{-O0}を使用すると、コンパイラは@code{register}ストレージクラス指定子を持たないすべての変数に別個のスタックメモリを割り当てる。 @code{register}が指定されている場合、変数はコードが示すよりも寿命が短く、決してメモリに置かれないことがある。

@item
あるまれなx86ターゲットでは、@code{setjmp}はすべての状況でレジスタを保存しない。 そのような場合、GCCは@code{register}と表示されていない限り、レジスタに変数を割り当てない。

@end itemize

@item
@cite{インライン関数指定子を使用した提案の有効範囲(C99 と C11 6.7.4).}

@option{-fno-inline}オプションが使用されている場合や、@option{-O0}が使用されている場合、GCCは関数をインライン化しない。 そうしないと、GCCはいろいろな理由で関数をインライン化できないことがある。 @option{-Winline}オプションを使用して、関数がインライン化されていないかどうかとその理由を判断できる。

@end itemize

@node Structures unions enumerations and bit-fields implementation
@section Structures, Unions, Enumerations, and Bit-Fields

@itemize @bullet
@item
@cite{A member of a union object is accessed using a member of a
different type (C90 6.3.2.3).}

The relevant bytes of the representation of the object are treated as
an object of the type used for the access.  @xref{Type-punning}.  This
may be a trap representation.

@item
@cite{Whether a ``plain'' @code{int} bit-field is treated as a
@code{signed int} bit-field or as an @code{unsigned int} bit-field
(C90 6.5.2, C90 6.5.2.1, C99 and C11 6.7.2, C99 and C11 6.7.2.1).}

@opindex funsigned-bitfields
By default it is treated as @code{signed int} but this may be changed
by the @option{-funsigned-bitfields} option.

@item
@cite{Allowable bit-field types other than @code{_Bool}, @code{signed int},
and @code{unsigned int} (C99 and C11 6.7.2.1).}

Other integer types, such as @code{long int}, and enumerated types are
permitted even in strictly conforming mode.

@item
@cite{Whether atomic types are permitted for bit-fields (C11 6.7.2.1).}

Atomic types are not permitted for bit-fields.

@item
@cite{Whether a bit-field can straddle a storage-unit boundary (C90
6.5.2.1, C99 and C11 6.7.2.1).}

Determined by ABI@.

@item
@cite{The order of allocation of bit-fields within a unit (C90
6.5.2.1, C99 and C11 6.7.2.1).}

Determined by ABI@.

@item
@cite{The alignment of non-bit-field members of structures (C90
6.5.2.1, C99 and C11 6.7.2.1).}

Determined by ABI@.

@item
@cite{The integer type compatible with each enumerated type (C90
6.5.2.2, C99 and C11 6.7.2.2).}

@opindex fshort-enums
Normally, the type is @code{unsigned int} if there are no negative
values in the enumeration, otherwise @code{int}.  If
@option{-fshort-enums} is specified, then if there are negative values
it is the first of @code{signed char}, @code{short} and @code{int}
that can represent all the values, otherwise it is the first of
@code{unsigned char}, @code{unsigned short} and @code{unsigned int}
that can represent all the values.
@c On a few unusual targets with 64-bit int, this doesn't agree with
@c the code and one of the types accessed via mode attributes (which
@c are not currently considered extended integer types) may be used.
@c If these types are made extended integer types, it would still be
@c the case that -fshort-enums stops the implementation from
@c conforming to C90 on those targets.

On some targets, @option{-fshort-enums} is the default; this is
determined by the ABI@.

@end itemize

@node Qualifiers implementation
@section Qualifiers

@itemize @bullet
@item
@cite{What constitutes an access to an object that has volatile-qualified
type (C90 6.5.3, C99 and C11 6.7.3).}

Such an object is normally accessed by pointers and used for accessing
hardware.  In most expressions, it is intuitively obvious what is a read
and what is a write.  For example

@smallexample
volatile int *dst = @var{somevalue};
volatile int *src = @var{someothervalue};
*dst = *src;
@end smallexample

@noindent
will cause a read of the volatile object pointed to by @var{src} and store the
value into the volatile object pointed to by @var{dst}.  There is no
guarantee that these reads and writes are atomic, especially for objects
larger than @code{int}.

However, if the volatile storage is not being modified, and the value of
the volatile storage is not used, then the situation is less obvious.
For example

@smallexample
volatile int *src = @var{somevalue};
*src;
@end smallexample

According to the C standard, such an expression is an rvalue whose type
is the unqualified version of its original type, i.e. @code{int}.  Whether
GCC interprets this as a read of the volatile object being pointed to or
only as a request to evaluate the expression for its side-effects depends
on this type.

If it is a scalar type, or on most targets an aggregate type whose only
member object is of a scalar type, or a union type whose member objects
are of scalar types, the expression is interpreted by GCC as a read of
the volatile object; in the other cases, the expression is only evaluated
for its side-effects.

@end itemize

@node Declarators implementation
@section Declarators

@itemize @bullet
@item
@cite{The maximum number of declarators that may modify an arithmetic,
structure or union type (C90 6.5.4).}

GCC is only limited by available memory.

@end itemize

@node Statements implementation
@section Statements

@itemize @bullet
@item
@cite{The maximum number of @code{case} values in a @code{switch}
statement (C90 6.6.4.2).}

GCC is only limited by available memory.

@end itemize

@node Preprocessing directives implementation
@section Preprocessing Directives

@xref{Implementation-defined behavior, , Implementation-defined
behavior, cpp, The C Preprocessor}, for details of these aspects of
implementation-defined behavior.

@itemize @bullet
@item
@cite{The locations within @code{#pragma} directives where header name
preprocessing tokens are recognized (C11 6.4, C11 6.4.7).}

@item
@cite{How sequences in both forms of header names are mapped to headers
or external source file names (C90 6.1.7, C99 and C11 6.4.7).}

@item
@cite{Whether the value of a character constant in a constant expression
that controls conditional inclusion matches the value of the same character
constant in the execution character set (C90 6.8.1, C99 and C11 6.10.1).}

@item
@cite{Whether the value of a single-character character constant in a
constant expression that controls conditional inclusion may have a
negative value (C90 6.8.1, C99 and C11 6.10.1).}

@item
@cite{The places that are searched for an included @samp{<>} delimited
header, and how the places are specified or the header is
identified (C90 6.8.2, C99 and C11 6.10.2).}

@item
@cite{How the named source file is searched for in an included @samp{""}
delimited header (C90 6.8.2, C99 and C11 6.10.2).}

@item
@cite{The method by which preprocessing tokens (possibly resulting from
macro expansion) in a @code{#include} directive are combined into a header
name (C90 6.8.2, C99 and C11 6.10.2).}

@item
@cite{The nesting limit for @code{#include} processing (C90 6.8.2, C99
and C11 6.10.2).}

@item
@cite{Whether the @samp{#} operator inserts a @samp{\} character before
the @samp{\} character that begins a universal character name in a
character constant or string literal (C99 and C11 6.10.3.2).}

@item
@cite{The behavior on each recognized non-@code{STDC #pragma}
directive (C90 6.8.6, C99 and C11 6.10.6).}

@xref{Pragmas, , Pragmas, cpp, The C Preprocessor}, for details of
pragmas accepted by GCC on all targets.  @xref{Pragmas, , Pragmas
Accepted by GCC}, for details of target-specific pragmas.

@item
@cite{The definitions for @code{__DATE__} and @code{__TIME__} when
respectively, the date and time of translation are not available (C90
6.8.8, C99 6.10.8, C11 6.10.8.1).}

@end itemize

@node Library functions implementation
@section Library Functions

The behavior of most of these points are dependent on the implementation
of the C library, and are not defined by GCC itself.

@itemize @bullet
@item
@cite{The null pointer constant to which the macro @code{NULL} expands
(C90 7.1.6, C99 7.17, C11 7.19).}

In @code{<stddef.h>}, @code{NULL} expands to @code{((void *)0)}.  GCC
does not provide the other headers which define @code{NULL} and some
library implementations may use other definitions in those headers.

@end itemize

@node Architecture implementation
@section Architecture

@itemize @bullet
@item
@cite{The values or expressions assigned to the macros specified in the
headers @code{<float.h>}, @code{<limits.h>}, and @code{<stdint.h>}
(C90, C99 and C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).}

Determined by ABI@.

@item
@cite{The result of attempting to indirectly access an object with
automatic or thread storage duration from a thread other than the one
with which it is associated (C11 6.2.4).}

Such accesses are supported, subject to the same requirements for
synchronization for concurrent accesses as for concurrent accesses to
any object.

@item
@cite{The number, order, and encoding of bytes in any object
(when not explicitly specified in this International Standard) (C99
and C11 6.2.6.1).}

Determined by ABI@.

@item
@cite{Whether any extended alignments are supported and the contexts
in which they are supported (C11 6.2.8).}

Extended alignments up to @math{2^{28}} (bytes) are supported for
objects of automatic storage duration.  Alignments supported for
objects of static and thread storage duration are determined by the
ABI.

@item
@cite{Valid alignment values other than those returned by an _Alignof
expression for fundamental types, if any (C11 6.2.8).}

Valid alignments are powers of 2 up to and including @math{2^{28}}.

@item
@cite{The value of the result of the @code{sizeof} and @code{_Alignof}
operators (C90 6.3.3.4, C99 and C11 6.5.3.4).}

Determined by ABI@.

@end itemize

@node Locale-specific behavior implementation
@section Locale-Specific Behavior

The behavior of these points are dependent on the implementation
of the C library, and are not defined by GCC itself.
