\input texinfo-ja @c -*- texinfo -*-
@setfilename cpp.info
@settitle The C Preprocessor
@documentlanguage jp
@documentencoding UTF-8
@setchapternewpage off
@c @smallbook
@c @cropmarks
@c @finalout

@include gcc-common.texi

@copying
@c man begin COPYRIGHT
Copyright @copyright{} 1987-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation.  A copy of
the license is included in the
@c man end
section entitled ``GNU Free Documentation License''.
@ignore
@c man begin COPYRIGHT
man page gfdl(7).
@c man end
@end ignore

@c man begin COPYRIGHT
This manual contains no Invariant Sections.  The Front-Cover Texts are
(a) (see below), and the Back-Cover Texts are (b) (see below).

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.
@c man end
@end copying

@c Create a separate index for command line options.
@defcodeindex op
@syncodeindex vr op

@c Used in cppopts.texi and cppenv.texi.
@set cppmanual

@ifinfo
@dircategory Software development
@direntry
* Cpp: (cpp).                  The GNU C preprocessor.
@end direntry
@end ifinfo

@titlepage
@title The C Preprocessor
@versionsubtitle
@author Richard M. Stallman, Zachary Weinberg
@page
@c There is a fill at the bottom of the page, so we need a filll to
@c override it.
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents
@page

@ifnottex
@node Top
@top
Cプリプロセッサは、コンパイルされる前に、C、C ++、およびObjective-Cプログラムを変換するために使用されるマクロ言語を実装する。 それはまた、それ自身で役に立つかもしれない。

@menu
* Overview::
* Header Files::
* Macros::
* Conditionals::
* Diagnostics::
* Line Control::
* Pragmas::
* Other Directives::
* Preprocessor Output::
* Traditional Mode::
* Implementation Details::
* Invocation::
* Environment Variables::
* GNU Free Documentation License::
* Index of Directives::
* Option Index::
* Concept Index::

@detailmenu
 --- The Detailed Node Listing ---

概略

* Character sets::
* Initial processing::
* Tokenization::
* The preprocessing language::

ヘッダファイル

* Include Syntax::
* Include Operation::
* Search Path::
* Once-Only Headers::
* Alternatives to Wrapper #ifndef::
* Computed Includes::
* Wrapper Headers::
* System Headers::

マクロ

* Object-like Macros::
* Function-like Macros::
* Macro Arguments::
* Stringizing::
* Concatenation::
* Variadic Macros::
* Predefined Macros::
* Undefining and Redefining Macros::
* Directives Within Macro Arguments::
* Macro Pitfalls::

定義済みマクロ

* Standard Predefined Macros::
* Common Predefined Macros::
* System-specific Predefined Macros::
* C++ Named Operators::

マクロの落とし穴

* Misnesting::
* Operator Precedence Problems::
* Swallowing the Semicolon::
* Duplication of Side Effects::
* Self-Referential Macros::
* Argument Prescan::
* Newlines in Arguments::

条件

* Conditional Uses::
* Conditional Syntax::
* Deleted Code::

条件の構文

* Ifdef::
* If::
* Defined::
* Else::
* Elif::

条件の詳細

* Implementation-defined behavior::
* Implementation limits::
* Obsolete Features::

時代遅れの機能

* Obsolete Features::

@end detailmenu
@end menu

@insertcopying
@end ifnottex

@node Overview
@chapter Overview
@c man begin DESCRIPTION
@dfn{cpp}と呼ばれることが多いCプリプロセッサは、コンパイル前にプログラムを変換するためにCコンパイラによって自動的に使用される@dfn{macro processor}（マクロプロセッサ）である。 @dfn{macros}を定義することができるので、これはマクロプロセッサと呼ばれる。これは長い後続の略語である。

Cプリプロセッサは、C、C++、およびObjective-Cソースコードでのみ使用されることを意図している。 これまでは一般的なテキストプロセッサとして濫用されてきた。それはCの字句規則に従わない入力を詰まらせる。 たとえば、アポストロフィは文字定数の先頭と解釈され、エラーが発生する。 また、C-ファミリー言語にとって重要ではない入力の特性を保持することはできない。 Makefileがプリプロセスされていると、すべてのハードタブが削除され、Makefileは機能しない。

そうは言っても、C言語以外のものでcppを使うことはできる。他のAlgol風プログラミング言語はしばしば安全である（Pascal、Adaなど）。 @option{-traditional-cpp}モードは、より多くの空白を保存するが、そうでなければより許容する。 ネイティブ言語コメントの代わりにCまたはC++スタイルのコメントを記述し、マクロをシンプルに保つことで、多くの問題を回避できる。

可能であれば、あなたが書いている言語に合わせたプリプロセッサを使うべきである。現代版のGNUアセンブラにはマクロ機能がある。 ほとんどの高水準プログラミング言語は、独自の条件付きコンパイルおよびインクルードメカニズムを備えている。 それ以外の場合は、GNU M4などの一般的なテキストプロセッサを試すこと。

Cプリプロセッサは、いくつかの詳細が異なる。 このマニュアルでは、ISO標準Cの機能の小さなスーパーセットを提供するGNU Cプリプロセッサについて説明する。デフォルトモードでは、GNU Cプリプロセッサは標準で必要とされるいくつかのことを行わない。 これらは、これまで使用されていたことはめったにない機能であり、期待していないプログラムの意味に驚くような変化を引き起こす可能性がある。 厳密なISO標準Cを取得するには、次のようにあなたが望む標準のバージョンに応じて@option{-std=c90}、@option{-std=c99}、@option{-std=c11}または@option{-std=c17}オプションを使用する必要がある。すべての必須診断を取得するには、@option{-pedantic}も使用する必要がある。@xref{Invocation}.

このマニュアルでは、ISOプリプロセッサの動作について説明する。 相違点を最小限に抑えるために、ISOプリプロセッサの動作が従来のセマンティクスと競合しない場合、従来のプリプロセッサは同じように動作する必要がある。 存在する様々な相違点については、@ref{Traditional Mode}の節で詳しく説明する。

わかりやすくするために、特に明記しない限り、このマニュアルの@samp{CPP}はGNU CPPを参照する。
@c man end

@menu
* Character sets::
* Initial processing::
* Tokenization::
* The preprocessing language::
@end menu

@node Character sets
@section 文字集合

Cおよび関連する言語でのソースコードの文字セット処理はかなり複雑である。 C標準では2つの文字セットについて説明しているが、実際には少なくとも4つある。

CPPに入力されたファイルは、まったくどんな文字セットである可能性もある。 CPPの最初のアクションは、行境界を探す前に、ファイルを内部処理に使用する文字セットに変換することである。 そのセットは、C標準が@dfn{source}文字セットと呼ぶものである。それはUnicodeとも呼ばれるISO 10646と同形でなければならない。 CPPはUnicodeのUTF-8エンコーディングを使用する。

入力ファイルの文字セットは、@option{-finput-charset=}オプションを使用して指定する。

すべてのプリプロセス作業（このマニュアルの残りの部分）は、ソースキャラクタセットで実行される。 @option{-E}オプションを使用してプリプロセッサからのテキスト出力を要求すると、UTF-8になる。

プリプロセスが完了した後、文字列定数と文字定数は再び@dfn{execution}文字セットに変換される。この文字セットはユーザーの制御下にある。デフォルトはUTF-8で、ソース文字セットと一致する。ワイド文字列と文字定数には独自の文字セットがあり、標準では特に呼び出されない。再び、それはユーザの制御下にある。デフォルトはUTF-16またはUTF-32のいずれかで、ターゲットマシンのバイト順序でターゲットの@code {wchar_t}タイプに適合する。@footnote{UTF-16はワイド文字セットのC標準の要件を満たしていないが、16ビットの@code {wchar_t}の選択は、いくつかのシステムABIに託されているので、これを修正することはできない。} 8進および16進エスケープシーケンスは変換されない。 @t{'\x12'}は、現在選択されている実行文字セットに関係なく、値0x12を持つ。他のすべてのエスケープは、エスケープされていない文字のように、それらが表すソース文字セットの文字に置き換えられ、実行文字セットに変換される。

識別子では、ASCII範囲外の文字は@samp{\u}と@samp{\U}エスケープでしか指定できず、直接使用することはできない。 @option{-std=c90}のようなオプションで厳密なISO C90準拠が指定されている場合、または@option{-fno-extended-identifiers}が使用されている場合、これらのエスケープは識別子では許可されない。

@node Initial processing
@section 初期処理

プリプロセッサは、その入力に対して一連のテキスト変換を実行する。 これらは他のすべての処理の前に行われる。 概念的には、これらは厳密な順序で行われ、ファイル全体が次の変換が始まる前に各変換を通じて実行される。 パフォーマンス上の理由から、CPPは実際にそれらを一度にすべて実行する。 これらの変換は、C標準で記述されている最初の3つの「翻訳の段階」にほぼ対応している。

@enumerate
@item
@cindex line endings
入力ファイルはメモリに読み込まれ、行に分割される。

異なるシステムでは、行の終わりを示すために異なる規則が使用される。 GCCは、@kbd{LF}、@ kbd{@w{CR LF}}と@kbd{CR}のASCII制御シーケンスを行末マーカーとして受け入れる。 これらはUnix、DOS、VMS、そして古典的なMac OS（OSXの前）で使われている標準的なシーケンスである。 したがって、これらのシステムのいずれかで書かれたソースコードを別のものに安全にコピーし、変換せずに使用することができる。 （ネットワークファイルシステムを共有する異なる規則を持つコンピュータ上で編集されたときに起こるように、ファイルが1つの規則を一貫して使用しない場合、GCCは現在の行番号のトラックを失う可能性がある）。

入力ファイルの最後の行に行末マーカーがない場合、ファイルの終わりは暗黙的に改行とみなされる。 Cの標準では、この状態は未定義の動作を引き起こすので、GCCは警告メッセージを出力する。

@item
@cindex trigraphs
@anchor{trigraphs}トライグラフを有効にすると、対応する単一の文字に置き換えられる。 デフォルトでは、GCCはトライグラフを無視するが、@option{-std}オプションで厳密に準拠したモードを要求した場合、または@option{-trigraphs}オプションを指定した場合は変換される。

これらは9の3文字のシーケンスで、すべてが@samp{??}で始まり、ISO Cで単一文字を表すように定義されている。 それらはCの句読点のいくつかが欠けている古いシステムではCを使うためのものである。 たとえば、@samp{??/}は@samp{\}を表す。したがって、@t{'??/n'}は改行の文字定数である。

トライグラフは普及してなく、多くのコンパイラが誤って実装している。 移植可能なコードは、変換されたか無視されたトリグラフに依存するべきではない。@option{-Wtrigraphs}を使うと、変換されたプログラムの意味をトリグラフが変えることがあるときにGCCが警告する。 @xref{Wtrigraphs}。

文字列定数では、一連の疑問符が疑問符の間にバックスラッシュを挿入するか、または文字列リテラル連結を使用して文字列リテラルを分離することによって、一連の疑問符がトリグラフと混同されるのを防ぐことができる。 @t["(??\?)"]は@samp{(???)}ではなく@samp{(???)}という文字列である。伝統的なCコンパイラはこれらのイディオムを認識しない。

9つのトライグラフとそれらの置換は、

@smallexample
トライグラフ:       ??(  ??)  ??<  ??>  ??=  ??/  ??'  ??!  ??-
置換:                        [    ]    @{    @}    #    \    ^    |    ~
@end smallexample

@item
@cindex continued lines
@cindex backslash-newline
継続された行は1つの長い行にマージされる。

継続行はバックスラッシュ@samp{\}で終わる行である。 バックスラッシュが削除され、次の行が現在の行と結合される。 スペースは挿入されないので、単語の途中であってもどこでも行を分割できる。 （一般に、空白でのみ行を分割する方が読みやすくなる。）

継続行の末尾にあるバックスラッシュは、通常、@dfn{backslash-newline}（バックスラッシュ・改行）と呼ばれる。

バックスラッシュと行末の間に空白がある場合でも、それは継続行である。 しかし、これは通常編集ミスの結果であり、多くのコンパイラは継続行として受け付けないので、GCCはそれについて警告する。

@item
@cindex comments
@cindex line comments
@cindex block comments
すべてのコメントは1つのスペースで置き換えられる。

コメントには2種類ある。 @dfn{Block comments}（ブロックコメント）は@samp{/*}で始まり、次の@samp{*/}まで続く。 ブロックコメントは入れ子にならない：

@smallexample
/* @r{this is} /* @r{one comment} */ @r{text outside comment}
@end smallexample

@dfn{Line comments}（行コメント）は@samp{//}で始まり、現在の行の最後まで続く。 行コメントも入れ子にならないが、いずれにせよ同じ場所で終わるので問題はない。

@smallexample
// @r{this is} // @r{one comment}
@r{text outside comment}
@end smallexample
@end enumerate

ブロックコメントの中に行コメントを入れることは安全であり、逆もまた同様である。

@smallexample
@group
/* @r{block comment}
   // @r{contains line comment}
   @r{yet more comment}
 */ @r{outside comment}

// @r{line comment} /* @r{contains block comment} */
@end group
@end smallexample

しかし、行コメントでブロックコメントの一端をコメントアウトすることに注意せよ。

@smallexample
@group
 // @r{l.c.}  /* @r{block comment begins}
    @r{oops! this isn't a comment anymore} */
@end group
@end smallexample

コメントは文字列リテラル内では認識されない。 @t{@w{"/ * blah * /"}}は空文字列ではなく、文字列定数@samp{@w{/ * blah * /}}である。

行コメントは1989年版のC標準には含まれていないが、GCCでは拡張機能として認識されている。 C++および1999年版のC標準では、これらは言語の公式な部分である。

これらの変換は他のすべての処理の前に行われるので、バックスラッシュ改行を使って機械的に行を分割することができる。 行末をコメントアウトすることができる。 バックスラッシュ改行で次の行に行コメントを続けることができる。 @samp{/*}、@samp{*/}、および@samp{//}をバックスラッシュ改行で複数の行に分割することさえできる。 例えば：

@smallexample
@group
/\
*
*/ # /*
*/ defi\
ne FO\
O 10\
20
@end group
@end smallexample

@noindent
は@code{@w{#define FOO 1020}}と同等である。 これらのすべてのトリックは非常に混乱させるので、読みやすいコードでは使用すべきではない。

行末のバックスラッシュがバックスラッシュ改行として解釈されないようにする方法はない。 しかし、これは正しいプログラムには影響しない。

@node Tokenization
@section トークン化

@cindex tokens
@cindex preprocessing tokens
テキスト変換が終了すると、入力ファイルは@dfn{preprocessing tokens}（プリプロセストークン）のシーケンスに変換される。 これらは主にCコンパイラで使用される構文トークンに対応するが、いくつかの違いがある。 空白はトークンを区切る。 それはそれ自身がいかなる種類のトークンでもない。 トークンは空白で区切る必要はないんが、しばしばあいまいさを避ける必要がある。

1つ以上の可能なトークン化を有する一連の文字に直面するとき、プリプロセッサは貪欲である。 左から順に、各トークンをできるだけ大きくしてから次のトークンに移る。 たとえば、@code{a+++++b}は@code{@w{a ++ + ++ b}}ではなく、@code{@w{a ++ +++ b}}と解釈される。 後者のトークン化は有効なCプログラムの一部であり、前者のトークン化は不可能であったにもかかわらず。

入力ファイルがトークンに分割されると、@samp{##}プリプロセス演算子を使用してトークンを貼り付けるときを除いて、トークンの境界は決して変更されない。 @xref{Concatenation}。 例えば、

@smallexample
@group
#define foo() bar
foo()baz
     @expansion{} bar baz
@emph{not}
     @expansion{} barbaz
@end group
@end smallexample

コンパイラはプリプロセッサの出力を再トークン化しない。 各プリプロセストークンは1つのコンパイラー・トークンになる。

@cindex identifiers
プリプロセストークンは、識別子、プリプロセス番号、文字列リテラル、句読子などの5つの広いクラスに分類される。 @dfn{識別子}は、Cの識別子と同じである。文字またはアンダースコアで始まる、文字や数字、またはアンダースコアの任意のシーケンス。Cのキーワードはプリプロセッサにとって意味がない。 それらは通常の識別子である。 たとえば、名前がキーワードであるマクロを定義することができる。 プリプロセスキーワードとみなせる唯一の識別子は@code{defined}である。  @xref{Defined}.

これは、Cプリプロセッサを使用する他の言語にも当てはまる。 しかし、C++のキーワードのいくつかは、プリプロセッサでも意味を持つ。 @xref{C++ Named Operators}.

1999年のC標準では、識別子には、実装の裁量で（アクセント付きのラテン文字、ギリシャ文字、中国語の表意文字など）、「基本的なソース文字セット」の一部ではない文字を含めることができる。 これは、拡張文字セット、または@samp{\u}と@samp{\U}エスケープシーケンスで行うことができる。 GCCは@samp{\u}と@samp{\U}形式の文字しか受け付けない。

拡張として、GCCは@samp{$}を文字として扱う。 これは、システム定義関数やオブジェクト名で@samp{$}がよく使用されるVMSなどのシステムとの互換性のためである。 @samp{$}は厳密に準拠したモードの文字ではなく、@option{-$}オプションを指定した場合には使用できない。@xref{Invocation}.

@cindex numbers
@cindex preprocessing numbers
@dfn{プリプロセス数}はかなり奇妙な定義をしている。 このカテゴリには、Cで期待されるすべての通常の整数と浮動小数点定数が含まれるが、最初は数として認識されない数多くのものも含まれる。 正式には、プリプロセス数は任意のピリオド、必要な10進数で始まり、文字、数字、下線、ピリオド、および指数の任意のシーケンスで続行される。 指数は、2文字のシーケンス@samp{e+}、@samp{e-}、@samp{E+}、@samp{E-}、@samp{p+}、@samp{p-}、@samp{P+}、および@samp{P-}である。 （@samp{p}または@samp{P}で始まる指数は、16進浮動小数点定数に使用される）。

この珍しい定義の目的は、プリプロセッサを完全な数値定数から分離することである。 字句的に有効な浮動小数点数と無効な浮動小数点数を区別する必要はなく、それは複雑である。 この定義では、識別子を任意の位置に分割し、ちょうど2つのトークンを取得し、@samp{##}演算子と一緒に貼り付けることもできる。

プリプロセスしている数字によってプログラムが誤って解釈される可能性がある。 たとえば、@code{0xE+12}は有効な数値定数に変換されないプリプロセス番号なので、構文エラーである。あなたが意図しているかもしれない@code{@w{0xE + 12}}を意味するものではない。

@cindex string literals
@cindex string constants
@cindex character constants
@cindex header file names
@c the @: prevents makeinfo from turning '' into ".
@dfn{String literal}は文字列定数、文字定数、ヘッダファイル名（@samp{#include}の引数）である。@footnote{C標準では@dfn{string literal}という用語を使って、@dfn{string constants}を呼び出すものだけを参照している。}文字列定数と文字定数は簡単である。@t{"@dots{}"}か@t{'@dots{}'}である。 どちらの場合でも、埋め込み引用符はバックスラッシュでエスケープする必要がありる。@t{'\'@:'}は@samp {'}の文字定数である。 文字定数の長さに制限はないが、複数の文字を含む文字定数の値は実装定義である。 @xref{Implementation Details}.

ヘッダーファイル名は、文字列定数のように見えるが、@t{"@dots{}"}か、かわりに山カッコで書かれている。 どちらの場合でも、バックスラッシュは普通の文字である。 閉じクォートや角括弧をエスケープする方法はない。 プリプロセッサは、使用するフォームに応じて異なる場所でヘッダファイルを探す。@xref{Include Operation}.

文字列リテラルは、行末を越えてはならない。 継続行を使用するか、文字列定数連結を使用する。

@cindex punctuators
@cindex digraphs
@cindex alternative tokens
@dfn{句読点}は、CやC ++にとって意味のある句読点の通常のビットである。 ASCIIの句読点文字のうち3つを除くすべてがCの句読点である。 例外は@samp{@@}、@samp{$}、@samp{`}である。 さらに、2文字と3文字の演算子はすべて句読点である。 C++標準が@dfn{alternative tokens}と呼ぶ6つの@dfn{digraphs}もある。これは単に他の句読点を綴る代わりの方法である。 これは時代遅れのシステムでの句読点の欠落を回避するための2番目の試みである。 それは、trigraphsとは異なり、否定的な副作用はないが、多くの地面をカバーしていない。二重グラフとそれに対応する通常の句読点は次のとおりである。

@smallexample
Digraph:        <%  %>  <:  :>  %:  %:%:
Punctuator:      @{   @}   [   ]   #    ##
@end smallexample

@cindex other tokens
他の単一の文字は「その他」とみなされる。 unmolestedプリプロセッサの出力に渡されます。 Cコンパイラは「他の」トークンを含むソースコードをほぼ確実に拒否する。 ASCIIでは、他の文字は@samp{@@}、@samp{$}、@samp{`}、NUL以外の制御文字（全ビット0）のみである。 （通常、@samp{$}は文字と見なされることに注意せよ。）上位ビットがセットされたすべての文字（数値範囲0x7F - 0xFF）も現在の実装では 「その他」である。 これは、国際文字セットの適切なサポートがGCCに追加されたときに変更される。

NULは、その外観が偶発的である可能性が高く、ユーザが見えない（多くの端末がNULを全く表示しない）可能性が高いため、特別なケースである。 コメント内では、他の文字と同じようにNULも暗黙のうちに無視される。 実行中のテキストでは、NULは空白と見なされる。 たとえば、これらの2つのディレクティブは同じ意味を持つ。

@smallexample
#define X^@@1
#define X 1
@end smallexample

@noindent
（@samp{^@@}はASCII NULである。） 文字列定数または文字定数内では、NULは保持される。 後者の2つのケースでは、プリプロセッサは警告メッセージを出力する。

@node The preprocessing language
@section プリプロセス言語
@cindex directives
@cindex preprocessing directives
@cindex directive line
@cindex directive name

トークン化の後、トークンのストリームは単純にコンパイラのパーサに直接渡されるかもしれない。 しかし、@dfn{プリプロセス言語}に何らかの操作が含まれていると、それが最初に変換される。 この段階は、標準の「翻訳フェーズ4 」にほぼ対応していて、ほとんどの人がプリプロセッサの仕事と考えるものである。

プリプロセス言語は、実行される@dfn{ディレクティブ}と展開される@dfn{マクロ}で構成される。 主な機能は次のとおりである。

@itemize @bullet
@item
ヘッダーファイルのインクルード。 これらは、プログラムに置換可能な宣言ファイルである。

@item
マクロ展開。 @dfn{マクロ}は、Cコードの任意のフラグメントの略語を定義することができる。 プリプロセッサは、マクロ全体をプログラム全体の定義に置き換える。 一部のマクロは自動的に定義される。

@item
条件付きコンパイル。 さまざまな条件に従ってプログラムの一部を含めるか除外することができる。

@item
行制御。 プログラムを使用してソースファイルを中間ファイルに結合または再編成してコンパイルした場合は、行制御を使用して、元のソース行がどこから来たのかをコンパイラに知らせることができる

@item
診断。 コンパイル時に問題を検出し、エラーまたは警告を出すことができる。
@end itemize

いくつか、あまり有用でない機能がいくつかある。

定義済みマクロの展開を除いて、これらの操作はすべて@dfn{プリプロセスディレクティブ}でトリガされる。 プリプロセス指令は@samp{#}で始まるプログラム内の行である。 @samp{＃}の前後に空白を入れることができる。 @samp{＃}には識別子@dfn{指令名}が続く。 それは実行する操作を指定する。 ディレクティブは通常@samp{#@var{name}}と呼ばれ、@var{name}はディレクティブ名である。 たとえば、@samp{#define}はマクロを定義するディレクティブである。

ディレクティブを開始する@samp{#}は、マクロ展開から始めることはできない。 また、ディレクティブ名はマクロ展開されない。 したがって、@code{foo}が@code{define}に展開されるマクロとして定義されていても、@samp{#foo}を有効なプリプロセス指令にはしない。

有効なディレクティブ名のセットは固定されている。 プログラムは新しいプリプロセス指令を定義することはできない。

命令の中には引数が必要なものがある。 これらはディレクティブ行の残りの部分を構成し、空白でディレクティブ名と区切らなければならない。 たとえば、@samp{#define}の後ろにマクロ名とマクロの展開を続けなければならない。

プリプロセスディレクティブは複数の行を覆うことはできない。 しかし、行は、バックスラッシュ改行、または行末を越えるブロックコメントによって継続される。 いずれの場合も、ディレクティブが処理されると、継続はすでに1行目とマージされて1つの長い行になる。

@node Header Files
@chapter ヘッダファイル

@cindex header file
ヘッダファイルは、複数のソースファイル間で共有されるC宣言とマクロ定義（@pxref{Macros}）を含むファイルである。Cプリプロセスディレクティブ@samp{#include}で、それを@dfn{インクルードする}ことによってプログラム内でヘッダファイルを使うように要求する。

ヘッダーファイルには2つの目的がある。

@itemize @bullet
@item
@cindex system header files
システムヘッダファイルは、オペレーティングシステムの各部へのインタフェースを宣言する。 システムコールとライブラリを呼び出すために必要な定義と宣言を提供するために、これらをプログラムに含める。

@item
独自のヘッダファイルには、プログラムのソースファイル間のインタフェースの宣言が含まれている。 関連する宣言とマクロ定義のグループがある場合、そのすべてまたは大部分が複数の異なるソースファイルで必要になるたびに、そのためのヘッダーファイルを作成するのはいい考えである。
@end itemize

ヘッダーファイルを含めると、ヘッダーファイルを必要とする各ソースファイルにコピーするのと同じ結果が得られる。 そのようなコピーは時間がかかり、エラーを起こしやすい。 ヘッダーファイルでは、関連する宣言が1つの場所にのみ現れる。 変更が必要な場合は、1か所で変更することができ、ヘッダーファイルを含むプログラムは、次回の再コンパイル時に新しいバージョンを自動的に使用する。 ヘッダーファイルは、すべてのコピーを見つけて変更する労力と、1つのコピーが見つからないとプログラム内で矛盾が生じるというリスクを排除する。

Cでは、通常、@file{.h}で終わるヘッダファイル名を与えるのが一般的である。 ヘッダーファイル名には、英字、数字、ダッシュ、アンダースコアのみを使用し、ドットは最大１つしか使用ないのが最も移植性が高い。

@menu
* Include Syntax::
* Include Operation::
* Search Path::
* Once-Only Headers::
* Alternatives to Wrapper #ifndef::
* Computed Includes::
* Wrapper Headers::
* System Headers::
@end menu

@node Include Syntax
@section Include構文

@findex #include
ユーザーとシステムの両方のヘッダーファイルは、@samp{#include}というプリプロセスディレクティブを使用してインクルードされる。 それには2つの変種がある：

@table @code
@item #include <@var{file}>
この変形は、システムヘッダファイルに使用される。 システムディレクトリの標準リストで@var{file}という名前のファイルを検索する。 @option{-I}オプション（@pxref{Invocation}）を使用して、このリストにディレクトリを追加することができる。

@item #include "@var{file}"
この変種はあなた自身のプログラムのヘッダファイルに使われる。 現在のファイルを含むディレクトリの最初の@var{file}という名前のファイルを検索し、その後、引用符のディレクトリで@code{<var {file}>}のディレクトリと同じディレクトリを検索する。 @option{-iquote}オプションを使用して、ディレクトリを引用符のディレクトリの先頭に追加することができる。
@end table

@samp{#include}の引数は、引用符または山括弧で区切られていても、コメントが認識されず、マクロ名が展開されないという文字定数のように動作する。 したがって、@code{@w{#include <x/*y>}}は、@file{x/*y}というシステムヘッダファイルのインクルードを指定する。

しかし、バックスラッシュが@var{file}の中で発生すると、エスケープ文字ではなく普通のテキスト文字とみなされる。 Cの文字列定数に適した文字エスケープシーケンスは処理されない。 したがって、@code{@w{#include "x¥n¥¥y"}}は3つのバックスラッシュを含むファイル名を指定する。 （システムによっては、@samp{\}をパス名の区切りとして解釈するものがある。 これらのすべては同じ方法で@samp{/}も解釈する。 @samp {/}だけを使うのが最も移植性がある。）

ファイル名の後に（コメント以外の）行に何かがあると、エラーである。

@node Include Operation
@section Include操作

@samp{#include}ディレクティブは、指定されたファイルを入力としてスキャンしてから、現在のファイルの残りの部分を続行するようにCプリプロセッサに指示して動作する。 プリプロセッサからの出力には、すでに生成された出力と、インクルードされたファイルからの出力と、@samp{#include}ディレクティブの後のテキストからの出力が続く。 たとえば、次のようにヘッダファイル@file {header.h}がある場合、

@smallexample
char *test (void);
@end smallexample

@noindent
このようなヘッダファイルを使用する@file{program.c}と呼ばれる以下のメインプログラムは、

@smallexample
int x;
#include "header.h"

int
main (void)
@{
  puts (test ());
@}
@end smallexample

@noindent
コンパイラは@file {program.c}が以下を読んだ場合と同じトークンストリームを見るだろう。

@smallexample
int x;
char *test (void);

int
main (void)
@{
  puts (test ());
@}
@end smallexample

インクルードされたファイルは、宣言とマクロ定義に限定されない。 それらは典型的な用途にすぎない。 Cプログラムのフラグメントは、別のファイルからインクルードすることができる。 インクルードファイルには、インクルードファイルで終わるステートメントの先頭、インクルードファイルで開始されたステートメントの末尾まで含めることもできる。 ただし、インクルードされたファイルは完全なトークンで構成する必要がある。 インクルードファイルの最後で閉じられていないコメントと文字列リテラルは無効である。 エラーリカバリの場合、ファイルの最後に終了するとみなされる。

混乱を避けるために、ヘッダーファイルに完全な構文単位（関数の宣言や定義、型宣言など）しか含まれていない方が良いだろう。

@samp{#include}ディレクティブに続く行は、インクルードされたファイルに最終改行がない場合でも、Cプリプロセッサによって常に別の行として扱われる。

@node Search Path
@section 検索パス

デフォルトでは、プリプロセッサは、ディレクティブ@code{@w{#include "@var{file}"}}のクオート形式によってインクルードされたヘッダファイルでは、まず現在のファイルのディレクトリに対して探し、次にあらかじめ設定された標準システムディレクトリのリスト内を探す。たとえば、@file{/usr/include/sys/stat.h}に@code{@w{#include "types.h"}}が含まれている場合、GCCは最初に@file{/usr/include/sys}を探し、それからいつもの検索パスを探す。

角括弧の形式の@code{@w{#include <@var {file}>}}の場合、プリプロセッサのデフォルト動作は標準のシステムディレクトリだけである。 正確な検索ディレクトリのリストは、ターゲットシステム、GCCの設定方法、およびインストール先によって異なる。 @option{-v}オプションを使用してCPPを呼び出すことによって、CPPのデフォルトの検索ディレクトリリストを見つけることができる。 例えば、

@smallexample
cpp -v /dev/null -o /dev/null
@end smallexample

検索パスに追加のディレクトリを追加するために使用できるいくつかのコマンドラインオプションがある。 最も一般的に使用されるオプションは@option{-I @var{dir}}である。これにより、@var{dir}が現在のディレクトリ（ディレクティブの見積もり形式）の後ろで標準システムディレクトリより先に検索される。 コマンドラインで複数の@option{-I}オプションを指定できる。この場合、ディレクトリは左から右の順に検索される。

@samp{#include}ディレクティブの引用符と角括弧の形式の検索パスを個別に制御する必要がある場合は、@option{-I}の代わりに@option{-iquote}や@option{-isystem}オプションを使うことができる。 これらのオプションの詳細な説明だけでなく、それほど一般的ではない他のものについては、@xref{Invocation}を参照せよ。

プリプロセッサがヘッダファイルを検索する場所に影響を与える@option{-I}などのコマンドラインで他のオプションを指定した場合、@option{-v}オプションで表示されるディレクトリリストは、プリプロセッサで使用されている実際の検索パスを反映する。

プリプロセッサがデフォルトのシステムヘッダディレクトリを@option{-nostdinc}オプションで検索しないようにすることもできる。 これは、標準Cライブラリ機能を使用しないオペレーティングシステムカーネルまたはその他のプログラムをコンパイルする場合や、標準Cライブラリ自体をコンパイルする場合に便利である。

@node Once-Only Headers
@section 一度だけのヘッダ
@cindex repeated inclusion
@cindex including just once
@cindex wrapper @code{#ifndef}

ヘッダーファイルが2回インクルードされた場合、コンパイラはその内容を2回処理する。 これは、コンパイラーが同じ構造定義を2回見た場合など、エラーを引き起こす可能性が非常に高くなる。 たとえそれがなくても、確かに時間を無駄にするだろう。

これを防ぐ標準的な方法は、ファイルの実内容全体を次のように条件付きで囲むことである。

@smallexample
@group
/* File foo.  */
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN

@var{the entire file}

#endif /* !FILE_FOO_SEEN */
@end group
@end smallexample

この構造体は一般に@dfn{wrapper #ifndef}と呼ばれる。 @code{FILE_FOO_SEEN}が定義されているため、ヘッダーが再び含まれると、条件はfalseになる。 プリプロセッサはファイルの内容全体をスキップし、コンパイラはそれを2度見ることはない。

CPPはさらに最適化する。 ヘッダファイルにラッパー@samp{#ifndef}があるときを覚えている。 後続の@samp{#include}がそのヘッダを指定し、@samp{#ifndef}のマクロがまだ定義されている場合、わざわざファイルを再スキャンしない。

コメントはラッパーの外に置くことができる。それらはこの最適化を妨げない。

@cindex controlling macro
@cindex guard macro
@code{FILE_FOO_SEEN}マクロは@dfn{制御マクロ}または@dfn{ガードマクロ}と呼ばれる。 ユーザーヘッダーファイルでは、マクロ名は@samp{_}で始めるべきではない。 システムヘッダファイルでは、ユーザプログラムとの衝突を避けるために@samp{__}で始まる必要がある。 どのような種類のヘッダーファイルでも、他のヘッダーファイルとの競合を避けるために、マクロ名にはファイルの名前と追加のテキストが含まれている必要がある。

@node Alternatives to Wrapper #ifndef
@section ラッパ#ifndefの代替

CPPは、ヘッダーファイルを1回だけ読み取る必要があることを示す2つの方法をさらにサポートしている。 どちらもラッパー@samp {#ifndef}と同じ移植性はない。新しいプログラムでは使用しないことを推奨する。Objective-Cでは@samp{#import}が標準的な方法である。

@findex #import
CPPは@samp{#include}のファイルを多くて1回だけインクルードする@samp{#import}と呼ばれる亜種をサポートしている。 @samp{#include}の代わりに@samp{#import}を使用すると、複数のコンテンツが含まれないようにするヘッダファイル内に条件文は必要ない。 @samp{#import}はObjective-Cでは標準だが、CおよびC ++では廃止予定の拡張と見なされる。

@samp{#import}はうまく設計された機能ではない。 ヘッダーファイルのユーザーは、ヘッダーファイルを1回だけ含める必要があることを知る必要がある。 ヘッダーファイルの実装者がファイルを書き込むほうが、ユーザーがこれを知る必要はないので好ましい。 ラッパー@samp{#ifndef}を使用すると、この目標を達成できる。

現在の実装では、@samp {#import}を1回使用すると、@samp{#import}または@samp{#include}のいずれかによって、ファイルが再び読み取られることがなくなる。これに頼るべきではない。 同じヘッダファイルを参照するために@samp{#import}と@samp{#include}の両方を使用してはならない。

@samp{#pragma once}ディレクティブを使用する、ヘッダーファイルが2回以上含まれないようにするもう1つの方法がある。 ヘッダファイルをスキャンするときに@samp{#pragma once}が見つかった場合、そのファイルが何であれ再読されなくなる。

@samp{#pragma once}は@samp {#import}のような問題はないが、すべてのプリプロセッサでは認識されないので、移植可能なプログラムではそれに頼ることはできない。

@node Computed Includes
@section 計算インクルード
@cindex computed includes
@cindex macros in include

場合によっては、プログラムに組み込むいくつかの異なるヘッダーファイルの1つを選択する必要がある。 たとえば、さまざまな種類のオペレーティングシステムで使用される構成パラメータを指定する場合がある。 一連の条件付きでこれを行うことができるが、

@smallexample
#if SYSTEM_1
# include "system_1.h"
#elif SYSTEM_2
# include "system_2.h"
#elif SYSTEM_3
@dots{}
#endif
@end smallexample

それは急速に退屈になる。 代わりに、プリプロセッサはヘッダー名にマクロを使用する機能を提供する。 これは@dfn{計算インクルード}と呼ばれる。 @samp{#include}の直接引数としてヘッダ名を書くのではなく、その代わりにマクロ名を入れるだけである：

@smallexample
#define SYSTEM_H "system_1.h"
@dots{}
#include SYSTEM_H
@end smallexample

@noindent
@code {SYSTEM_H}は展開され、プリプロセッサは@samp{#include}が元のように書かれているかのように@file{system_1.h}を探す。 @code{SYSTEM_H}はMakefileによって@option{-D}オプションで定義できる。

マクロを定義するときは注意が必要である。 @samp{#define}はテキストではなくトークンを保存する。 プリプロセッサはマクロが@samp{#include}の引数として使われることを知る方法がないので、ヘッダ名ではなく普通のトークンを生成する。 文字列定数に十分近い二重引用符を使用するなら、これが問題になることはまずない。 ただし、角カッコを使用すると、問題が発生する可能性がある。

計算インクルードの構文は、実際には上記より少し一般的である。 @samp{#include}の後の最初の空白以外の文字が@samp{"}や@samp{<}でない場合、実行中のテキストのように行全体がマクロ展開される。

行が単一の文字列定数に展開される場合、その文字列定数の内容はインクルードされるファイルになる。 CPPは埋め込み引用符の文字列を再検査しないが、文字列のバックスラッシュエスケープも処理しない。 したがって、

@smallexample
#define HEADER "a\"b"
#include HEADER
@end smallexample

@noindent
は@file{a\"b}という名前のファイルを探す。CPPは二重引用符の規則に従ってファイルを検索する。

@samp{<}トークンで始まり、@samp{>}トークンを含むトークンストリームに展開すると、@samp{<}と最初の@samp {>}のトークンが含まれるファイル名の形式へと結合される。 トークン間の任意の空白は、単一のスペースに縮小される。 最初の@samp{<}の後のスペースはすべて保持されるが、閉じる@samp{>}の前のスペースは無視される。 CPPは、角括弧の規則に従ってファイルを検索する。

どちらの場合も、ファイル名の後に行にトークンがあると、エラーが発生し、ディレクティブは処理されない。 展開の結果が2つの予想される形式のいずれとも一致しない場合は、エラーである。

これらのルールは、C標準に従った実装定義の動作である。 異なるコンパイラが計算されたインクルードを異なる方法で解釈するリスクを最小限に抑えるため、文字列定数に展開されるオブジェクトのようなマクロを1つだけ使用することを推奨する。 これにより、あなたのプログラムを読んでいる人の混乱も最小限に抑えられる。

@node Wrapper Headers
@section ラッパヘッダ
@cindex wrapper headers
@cindex overriding a header file
@findex #include_next

場合によっては、システム提供のヘッダーファイルの内容を直接編集せずに調整する必要があることもある。 GCCの@command{fixincludes}操作ではこれが実行される。 これを行う1つの方法は、同じ名前の新しいヘッダーファイルを作成し、元のヘッダーの前の検索パスに挿入することである。 古いヘッダーを完全に置き換えることができれば、うまく動作する。 しかし、新しいヘッダーの古いヘッダーを参照したい場合はどうすればよいだろうか？

古いヘッダに単に@samp{#include}を含めることはできない。 それは最初から始まり、あなたの新しいヘッダーを再び見つける。 ヘッダーが複数のインクルード（@pxref{Once-Only Headers}）から保護されていない場合、無限に再帰的に発生し、致命的なエラーが発生する。

あなたは絶対パス名で古いヘッダーを含めることができる：
@smallexample
#include "/usr/include/old-header.h"
@end smallexample
@noindent
これは機能しますが、きれいではない。 システムヘッダーが移動した場合は、新しいヘッダーを編集して一致させる必要がある。

Cの標準でこの問題を解決する方法はないが、GNU拡張@samp{#include_next}を使用することができる。それは、「この名前の@emph{次の}ファイル」を意味する。このディレクティブは、指定されたファイルを検索する以外は@samp{#include}のように動作する。現在のファイルが見つかったディレクトリのヘッダファイルディレクトリ@emph{後で}検索を開始する。

@option{-I/usr/local/include}を指定し、検索するディレクトリのリストに@file{/usr/include}も含まれているとする。 両方のディレクトリに@file{signal.h}が含まれているとする。 普通の@code{@w{#include <signal.h>}}は、@file{/usr/local/include}以下のファイルを探す。 そのファイルに@code{@w{#include_next <signal.h>}}が含まれていれば、そのディレクトリの後ろで検索を開始し、@file{/usr/include}にあるファイルを探す。

@samp{#include_next}は@code{<@var{file}>}と@code{"@var{file}"}のインクルードを区別せず、指定したファイルが現在のファイルと同じ名前をしていしたかどうかもチェックしない。 現在のファイルが見つかったディレクトリの後ろにある検索パスのディレクトリから始まる、名前の付いたファイルを探す。

@samp{#include_next}を使用すると、大きな混乱を招く可能性がある。 他の方法がない場合にのみ使用することを推奨する。 特に、特定のプログラムに属するヘッダーでは使用すべきではない。 @command{fixincludes}の行に沿って大域的な修正を行う場合にのみ使用すること。

@node System Headers
@section システムヘッダ
@cindex system header files

オペレーティングシステムやランタイムライブラリへのインタフェースを宣言するヘッダファイルは、しばしば厳密に準拠したC言語で記述することはできない。したがって、GCCは@dfn{システムヘッダ}の特別な扱いにあるコードを提供する。 @samp{#warning}（@pxref{Diagnostics}）によって生成された警告以外のすべての警告は、GCCがシステムヘッダを処理している間は表示されない。 システムヘッダに定義されたマクロは、どこに展開されているかにかかわらず、いくつかの警告の影響を受けない。 この免責は、システムヘッダーで定義されたマクロのコードのために、警告が誤検出を多く生成することが判明した場合、アドホックベースで付与される。

通常、特定のディレクトリにあるヘッダーだけがシステムヘッダーと見なされる。これらのディレクトリは、GCCのコンパイル時に決定される。しかし、通常のヘッダーをシステムヘッダーにする2つの方法がある。

@itemize @bullet
@item
@option{-isystem}および@option {-idirafter}コマンドラインオプションを使用して検索パスに追加されたディレクトリにあるヘッダファイルは、診断目的でシステムヘッダとして扱われる。

@item
@findex #pragma GCC system_header
@code{@w{#pragma GCC system_header}}の指示文もある。これはGCCに現在のインクルードファイルの残りの部分をシステムヘッダと、見つかった場所に関係なく解釈する。 ファイル内の@samp{#pragma}より前にあるコードは影響を受けない。 @code{@w{#pragma GCC system_header}}はプライマリソースファイルには影響しない。
@end itemize

@node Macros
@chapter マクロ

@dfn{マクロ}は名前を与えられたコードの断片である。 名前が使用されるたびに、マクロの内容に置き換えられる。 マクロには2種類ある。それらは、使用されるときのように見えるかが主に異なる。 @dfn{オブジェクト風}マクロはデータオブジェクトに似ているが、@dfn{関数風}マクロは関数呼び出しに似ている。

有効な識別子は、Cキーワードであっても、マクロとして定義することができる。 プリプロセッサはキーワードについて何も知らない。これは、@code{const}のようなキーワードを理解できない古いコンパイラから隠す場合に便利である。 ただし、プリプロセッサ演算子@code{defined}（@pxref{Defined}）はマクロとして決して定義することはできず、C ++をコンパイルするときにはC++の名前付き演算子（@pxref{C ++ Named Operators}）はマクロにはならない。

@menu
* Object-like Macros::
* Function-like Macros::
* Macro Arguments::
* Stringizing::
* Concatenation::
* Variadic Macros::
* Predefined Macros::
* Undefining and Redefining Macros::
* Directives Within Macro Arguments::
* Macro Pitfalls::
@end menu

@node Object-like Macros
@section オブジェクト風マクロ
@cindex object-like macro
@cindex symbolic constants
@cindex manifest constants

@dfn{オブジェクト風マクロ}はコードフラグメントに置き換えられる単純な識別子である。 それはそれを使用するコードのデータオブジェクトのように見えるので、オブジェクト風と呼ばれる。 これらは最も一般的には、数値定数に記号名を付けるために使用される。

@findex #define
マクロは@samp{#define}ディレクティブで作成する。 @samp{#define}の後ろにはマクロの名前が続き、次に略語の元であるはずのトークンシーケンスが来て、それはマクロの@dfn{本体}、@dfn{展開}や@dfn{置換リスト}などとして参照される。 例えば、

@smallexample
#define BUFFER_SIZE 1024
@end smallexample

@noindent
はトークン@code{1024}の略語として@code{BUFFER_SIZE}という名前のマクロを定義する。 この@samp{#define}ディレクティブの後のどこかに、以下の形のCステートメントが来たら

@smallexample
foo = (char *) malloc (BUFFER_SIZE);
@end smallexample

@noindent
Cプリプロセッサはマクロ@code{BUFFER_SIZE}を認識して@dfn{展開}する。 Cコンパイラは、以下のように書いたのと同じトークンを見るだろう。

@smallexample
foo = (char *) malloc (1024);
@end smallexample

慣例により、マクロ名は大文字で書かれている。 どの名前がマクロであるかを一目で確認することができるので、プログラムを読みやすくなる。

マクロの本体は@samp{#define}行の最後で終わる。 必要に応じて、バックスラッシュ改行を使用して複数の行に定義を続けることができる。 ただし、マクロを展開すると、すべて1行に出力される。 例えば、

@smallexample
#define NUMBERS 1, \
                2, \
                3
int x[] = @{ NUMBERS @};
     @expansion{} int x[] = @{ 1, 2, 3 @};
@end smallexample

@noindent
これの最も一般的な目に見える結果は、エラーメッセージの驚くべき行番号である。

有効なプリプロセストークンに分解されるならば、マクロ本体に何が入ることができるかに制限はない。 括弧はバランスを取る必要はなく、本体は有効なCコードに似る必要はない。 （そうでなければ、マクロを使用するとCコンパイラからエラーメッセージが出る可能性がある）。

Cプリプロセッサは、プログラムを順番にスキャンする。 マクロ定義は、作成した場所で有効になる。 したがって、Cプリプロセッサへの次の入力は

@smallexample
foo = X;
#define X 4
bar = X;
@end smallexample

@noindent
以下を生成する。

@smallexample
foo = X;
bar = 4;
@end smallexample

プリプロセッサがマクロ名を展開すると、そのマクロの展開がマクロの呼び出しを置き換え、次に展開されてより多くのマクロが展開される。 例えば、

@smallexample
@group
#define TABLESIZE BUFSIZE
#define BUFSIZE 1024
TABLESIZE
     @expansion{} BUFSIZE
     @expansion{} 1024
@end group
@end smallexample

@noindent
@code{TABLESIZE}は最初に展開されて@code{BUFSIZE}を生成し、そのマクロは最後の結果である@code{1024}を生成するように展開される。

@code{TABLESIZE}が定義されたときに、@code{BUFSIZE}が定義されていないことに注意せよ。 @code{TABLESIZE}の@samp{#define}は、指定した展開（この場合は@code{BUFSIZE}）をそのまま使用し、マクロ名が含まれているかどうかをチェックしない。 あなたが@code{TABLESIZE}を@emph{使った}ときだけ、その拡張の結果がより多くのマクロ名のためにスキャンされる。

これは、ソースファイルのある時点で@code{BUFSIZE}の定義を変更すると違いがある。 表示されているように定義された@code{TABLESIZE}は、現在有効な@code{BUFSIZE}の定義を使用して常に展開されます：

@smallexample
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
@end smallexample

@noindent
@code{TABLESIZE}は（2段階で）@code{37}に展開される。

マクロの展開に直接または中間のマクロを使用して自分の名前が含まれている場合は、さらにマクロの展開を調べるときには再び展開されまない。 これにより、無限の再帰が防止される。詳細は@xref{Self-Referential Macros}を参照せよ。

@node Function-like Macros
@section 関数風マクロ
@cindex function-like macros

関数呼び出しのように見えるマクロを定義することもできる。 これらは@dfn{関数風マクロ}と呼ばれる。 関数風マクロを定義するには、同じ@samp{#define}疑似命令を使用するが、マクロ名の直後に括弧を入れる。 例えば、

@smallexample
#define lang_init()  c_init()
lang_init()
     @expansion{} c_init()
@end smallexample

関数風マクロは、その名前の後ろに一対のカッコがある場合にのみ展開される。 名前だけを書くと、それは放置される。 これは、関数と同じ名前のマクロがあり、その関数を時々使用したいときに便利である。

@smallexample
extern void foo(void);
#define foo() /* @r{optimized inline version} */
@dots{}
  foo();
  funcptr = foo;
@end smallexample

ここで@code{foo()}の呼び出しはマクロを使用するが、関数ポインタは実関数のアドレスを取得する。 マクロを展開していたら、構文エラーが発生するだろう。

マクロ定義内のマクロ名とかっこの間にスペースを入れると、関数風マクロは定義されず、オブジェクト風マクロが定義される。そのマクロ展開はカッコで始まる。

@smallexample
#define lang_init ()    c_init()
lang_init()
     @expansion{} () c_init()()
@end smallexample

この展開の括弧の最初の2つのペアはマクロから来ている。 3番目はマクロ呼び出しの元々だったペアである。 @code{lang_init}はオブジェクト風マクロなので、それらの括弧は消費しない。

@node Macro Arguments
@section マクロ引数
@cindex arguments
@cindex macros with arguments
@cindex arguments in macro definitions

関数風マクロは、真の関数と同様に@dfn{引数}をとることができる。 引数を使用するマクロを定義するには、@dfn{パラメータ}をマクロ定義の中のカッコの間に挿入する。 パラメータは、オプションで空白を含むカンマで区切られた有効なC識別子でなければならない。

引数を取るマクロを呼び出すには、マクロ名の後ろに括弧内にコンマで区切られた@dfn{実際の引数}のリストを書く。 マクロの呼び出しは、単一の論理行に限定する必要はない。ソースファイル内の行数を自由に変更できる。 引数の数は、マクロ定義内のパラメータの数と一致する必要がある。 マクロが展開されると、本体の各パラメータの使用は、対応する引数のトークンに置き換えられる。 （マクロ本体ですべてのパラメータを使用する必要はない）。

たとえば、多くのCプログラムで定義されているように、2つの数値の最小値を計算するマクロと、いくつかの用途がある。

@smallexample
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
  x = min(a, b);          @expansion{}  x = ((a) < (b) ? (a) : (b));
  y = min(1, 2);          @expansion{}  y = ((1) < (2) ? (1) : (2));
  z = min(a + 28, *p);    @expansion{}  z = ((a + 28) < (*p) ? (a + 28) : (*p));
@end smallexample

@noindent
（この小さな例では、マクロ引数のいくつかの危険性を既に知ることができる。詳細は@xref{Macro Pitfalls}を参照せよ）。

各引数の先頭と末尾の空白は削除され、引数のトークン間の空白はすべて1つの空白に縮小される。 各引数の中のカッコは均衡していなければならない。 そのようなカッコ内のカンマは引数を終了しない。 ただし、角括弧または中括弧がバランスする必要はなく、カンマで引数を区切ることも防がない。 したがって、

@smallexample
macro (array[x = y, x + 1])
@end smallexample

@noindent
は@code{array[x = y}と@code{x + 1]}の2つの引数を@code{macro}に渡す。 引数として@code{array[x = y, x + 1]}を指定したい場合は、等価のCコードである@code{array[(x = y, x + 1)]}と書くことができる。

マクロへのすべての引数は、マクロ本体に代入される前に完全にマクロ展開される。 置換後、引数を含むマクロが展開されるように、テキスト全体が再度スキャンされる。 このルールは奇妙に見えるかもしれないが、注意深く設計されているので、関数呼び出しが実際にマクロ呼び出しであるかどうかを心配する必要はない。しかし、あなたはあまりにも賢くなろうとすると、困ってしまうことがある。 詳細は@xref{Argument Prescan}を参照せよ。

例えば、@code{min (min (a, b), c)}は最初に

@smallexample
  min (((a) < (b) ? (a) : (b)), (c))
@end smallexample

@noindent
へと展開され、それから以下のように展開される

@smallexample
@group
((((a) < (b) ? (a) : (b))) < (c)
 ? (((a) < (b) ? (a) : (b)))
 : (c))
@end group
@end smallexample

@noindent
（分かりやすくするため、ここに示した改行は実際には生成されない）。

@cindex empty macro arguments
マクロ引数は空のままにすることができる。 これはプリプロセッサのエラーではない（ただし、多くのマクロは無効なコードに展開される）。引数を完全に省略することはできない。 マクロが2つの引数を取る場合は、その引数リストの最上位に1つのカンマが正確になければならない。 @code{min}を使ったいくつかのばかげた例がある：

@smallexample
min(, b)        @expansion{} ((   ) < (b) ? (   ) : (b))
min(a, )        @expansion{} ((a  ) < ( ) ? (a  ) : ( ))
min(,)          @expansion{} ((   ) < ( ) ? (   ) : ( ))
min((,),)       @expansion{} (((,)) < ( ) ? ((,)) : ( ))

min()      @error{} macro "min" requires 2 arguments, but only 1 given
min(,,)    @error{} macro "min" passed 3 arguments, but takes just 2
@end smallexample

空白はプリプロセストークンではないので、マクロ@code{foo}が1つの引数を取る場合、@code{@w{foo ()}}と@code{@w{foo ( )}}は空の引数を与える。 以前のGNUプリプロセッサの実装とドキュメントは、この時点では間違っていた。空の引数が必要な場合には、単一の引数を取る関数型マクロがスペースを渡すことを主張していた。

文字列リテラル内に現れるマクロパラメータは、対応する実際の引数に置き換えられない。

@smallexample
#define foo(x) x, "x"
foo(bar)        @expansion{} bar, "x"
@end smallexample

@node Stringizing
@section 文字列化
@cindex stringizing
@cindex @samp{#} operator

場合によっては、マクロ引数を文字列定数に変換することができる。 パラメータは文字列定数内では置き換えられないが、代わりに@samp{#}プリプロセス演算子を使用することができる。 @samp{＃}の後ろにマクロパラメータを使用すると、プリプロセッサはそれを実際の引数のリテラルテキストに置き換え、文字列定数に変換する。 通常のパラメータ置換とは異なり、引数は最初にマクロ展開されない。 これは@dfn{文字列化}と呼ばれる。

引数を周囲のテキストと組み合わせて、それをすべて一緒に文字列化する方法はない。 代わりに、一連の隣接する文字列定数と文字列化された引数を書くことができる。 プリプロセッサは文字列化された引数を文字列定数に置き換える。 次に、Cコンパイラは、隣接するすべての文字列定数を1つの長い文字列に結合する。

文字列化を使用するマクロ定義の例を次に示す。

@smallexample
@group
#define WARN_IF(EXP) \
do @{ if (EXP) \
        fprintf (stderr, "Warning: " #EXP "\n"); @} \
while (0)
WARN_IF (x == 0);
     @expansion{} do @{ if (x == 0)
           fprintf (stderr, "Warning: " "x == 0" "\n"); @} while (0);
@end group
@end smallexample

@noindent
@code{EXP}の引数は、現状の@code{if}文に一度代入され、一度文字列化されて@code{fprintf}の引数に代入される。 @code{x}がマクロの場合、@code{if}文で展開されるが、文字列には展開されない。

@code{do}と@code{while(0)}は、@code{WARN_IF}をCプログラマが望んでいるであろう関数と似せるように、@code{WARN_IF (@var{arg});}と書くことを可能にするための厄介なものである。 @ref{Swallowing the Semicolon}を参照せよ。

Cでの文字列化は、フラグメントの前後に二重引用符を入れること以上のことである。 プリプロセッサは、適切な内容の有効なC文字列定数を得るために、埋め込み文字列定数を囲む引用符と、文字列定数と文字定数の中のすべてのバックスラッシュをバックスラッシュでエスケープする。 したがって、@code{@w{p = "foo\n";}}の文字列化は@t{@w{"p = \"foo\\n\";"}}になる。 しかし、文字列や文字定数の中にいないバックスラッシュは複製されない。@samp{\n}自体は@t{"\n"}に文字列化される。

文字列化されたテキストの先頭と末尾のすべての空白は無視される。 テキストの途中の空白のシーケンスは、文字列化された結果の単一のスペースに変換される。 コメントは、文字列化が起こるずっと前に空白文字に置き換えられているので、文字列化されたテキストには表示されない。

マクロ引数を文字定数に変換する方法はない。

マクロ引数の展開結果を文字列化する場合は、2つのレベルのマクロを使用する必要がある。

@smallexample
#define xstr(s) str(s)
#define str(s) #s
#define foo 4
str (foo)
     @expansion{} "foo"
xstr (foo)
     @expansion{} xstr (4)
     @expansion{} str (4)
     @expansion{} "4"
@end smallexample

@code{s}は@code{str}で使用されているときには文字列化されているため、最初にマクロ展開されない。 しかし、@code{s}は@code{xstr}の普通の引数なので、@code{xstr}自体が展開される前に完全にマクロ展開される（@pxref{Argument Prescan}）。 したがって、@code{str}がその引数に到達するまでには、すでにマクロ展開されている。

@node Concatenation
@section 連結
@cindex concatenation
@cindex token pasting
@cindex token concatenation
@cindex @samp{##} operator

マクロを展開しながら2つのトークンを1つにマージすると便利なことがよくある。 これは@dfn{トークン貼り付け}または@dfn{トークン連結}と呼ばれる。 @samp{##}プリプロセス演算子は、トークン貼り付けを実行する。 マクロが展開されると、各@samp{##}演算子の両側にある2つのトークンが1つのトークンに結合され、@samp{##}と2つの元のトークンがマクロ展開に置き換えられる。 通常、どちらも識別子である。さもなければ一方は識別子になり、もう一方はプリプロセス番号になる。 ペーストすると、より長い識別子が作成される。これは唯一の有効なケースではない。 2つの数字（または@code{1.5}や@code{e3}などの数字と名前）を数字に連結することもできる。 また、@code{+=}のような複数文字の演算子は、トークンの貼り付けによって形成することができる。

ただし、一緒に有効なトークンを構成しない2つのトークンを貼り付けることはできない。 たとえば、@code{x}をどちらの順序でも@code{+}に連結することはできない。 試行すると、プリプロセッサは警告を出して2つのトークンを発行する。 トークン間に空白を入れるかどうかは不定である。 複雑なマクロで@samp {##}を不必要に使用するのはよくあることである。 この警告が表示された場合は、単に@samp{##}を削除することができる。

@samp{##}で結合されたトークンはどちらもマクロ本体から来る可能性があるが、最初のトークンとして書き込むこともできる。 トークンの貼り付けは、トークンの一方または両方がマクロ引数から来た場合に最も便利である。 @samp{##}の隣にあるトークンのいずれかがパラメータ名である場合、@samp{##}が実行される前にその実際の引数に置き換えられる。 文字列化の場合と同様に、実際の引数は最初にマクロ展開されない。 引数が空の場合、@samp{##}は効果がない。

Cプリプロセッサは、マクロが考慮される前にコメントを空白に変換することに注意せよ。 したがって、@samp{/}と@samp {*}を連結してコメントを作成することはできない。 @samp{##}とそのオペランドの間に、コメントを含めてたくさんの空白を入れることができる。また、連結する引数にコメントを入れることができる。 しかし、@samp{##}がマクロ本体のどちらかの端に現れるとエラーになる。

名前付きコマンドを解釈するCプログラムを考える。 おそらく、次のように宣言された構造体の配列のようなコマンドの表が必要である。

@smallexample
@group
struct command
@{
  char *name;
  void (*function) (void);
@};
@end group

@group
struct command commands[] =
@{
  @{ "quit", quit_command @},
  @{ "help", help_command @},
  @dots{}
@};
@end group
@end smallexample

各コマンド名を文字列定数に1回、関数名に1回ずつ指定する必要はない。 コマンドの名前を引数とするマクロは、これを不要にすることができる。 文字列定数は文字列で作成でき、関数名は引数を@samp{_command}で連結して作成できる。 ここでそれが行われるやり方である：

@smallexample
#define COMMAND(NAME)  @{ #NAME, NAME ## _command @}

struct command commands[] =
@{
  COMMAND (quit),
  COMMAND (help),
  @dots{}
@};
@end smallexample

@node Variadic Macros
@section 可変長マクロ
@cindex variable number of arguments
@cindex macros with variable arguments
@cindex variadic macros

マクロは関数のように可変長の引数を受け入れるように宣言することができる。 マクロを定義する構文は、関数の構文に似ている。 次に例を示す。

@smallexample
#define eprintf(@dots{}) fprintf (stderr, __VA_ARGS__)
@end smallexample

この種のマクロは@dfn{可変長}と呼ばれる。 マクロが呼び出されると、最後に指定された引数（このマクロではなし）の後の引数リストのすべてのトークンは、カンマを含めて@dfn{可変引数}になる。 この一連のトークンは、マクロ本体の識別子@code{@w{__VA_ARGS__}}をどこにでも置き換える。 したがって、私たちはこのように展開する：

@smallexample
eprintf ("%s:%d: ", input_file, lineno)
     @expansion{}  fprintf (stderr, "%s:%d: ", input_file, lineno)
@end smallexample

可変引数は、通常の引数と同様に、マクロ展開に挿入される前に完全にマクロ展開される。 @samp{#}と@samp{##}演算子を使用して可変引数を文字列化するか、先頭または末尾のトークンを別のトークンに貼り付けることができる。 （しかし、@samp{##}の重要な特別なケースについては以下を参照せよ）。

マクロが複雑な場合は、@code{@w{__VA_ARGS__}}よりも可変引数の方がわかりやすい名前が必要な場合がある。 CPPはこれを拡張として許可する。 @samp{@dots{}}の直前に引数名を書くことができる。 その名前は可変引数に使用される。 上記の@code{eprintf}マクロをこの拡張で次のように書くことができる。

@smallexample
#define eprintf(args@dots{}) fprintf (stderr, args)
@end smallexample

@noindent
同じマクロで@code{@w{__VA_ARGS__}}とこの拡張を使うことはできない。

可変引数マクロで可変引数だけでなく名前付き引数もを持つことができる。 代わりに以下のように@code {eprintf}を定義することができる：

@smallexample
#define eprintf(format, @dots{}) fprintf (stderr, format, __VA_ARGS__)
@end smallexample

@noindent
この定式化はよりわかりやすいように見えるが、歴史的には柔軟性がより少なかった。書式文字列の後に少なくとも1つの引数を指定する必要があった。 標準Cでは、名前付き引数と可変引数を区切るカンマを省略できなかった。 （この制限はC++2aで解消されていて、GNU Cには存在しなかったことに注意せよ;下記参照）。

さらに、可変引数を空のままにしておくと、書式文字列の後に余分なカンマがあるため、構文エラーが発生する。

@smallexample
eprintf("success!\n", );
     @expansion{} fprintf(stderr, "success!\n", );
@end smallexample

これはC++2aで修正されていて、GNU CPPにもこの問題に対処する拡張機能がある。

まず、GNU CPPとC++2aで始まるC++では、可変引数を完全に空にしておくことができる：

@smallexample
eprintf ("success!\n")
     @expansion{} fprintf(stderr, "success!\n", );
@end smallexample

@noindent
次に、C++2aは@code{@w{__VA_OPT__}}関数マクロを導入した。 このマクロは、可変長マクロの定義にのみ現れる。 変数の引数にトークンがある場合、@code{@w{__VA_OPT__}}の呼び出しは引数に展開される。 可変引数にトークンがない場合、@code{@w{__VA_OPT__}}は何も展開しない：

@smallexample
#define eprintf(format, @dots{}) \
  fprintf (stderr, format __VA_OPT__(,) __VA_ARGS__)
@end smallexample

@code{@w{__VA_OPT__}}は、GNU CとGNU C++でも利用できる。

歴史的に、GNU CPPには、後続のカンマを扱うための別の拡張もあった。@samp{##}トークンペースト演算子は、コンマと可変引数の間に置かれたときに特別な意味を持つ。 @code{@w{__VA_OPT__}}の導入にもかかわらず、この拡張機能は下位互換性のためにGNU CPPでサポートされている。 こう書くなら

@smallexample
#define eprintf(format, @dots{}) fprintf (stderr, format, ##__VA_ARGS__)
@end smallexample

@noindent
そして@code{eprintf}マクロが使用されているときに可変引数が指定されていない場合、@samp{##}の前のコンマは削除される。 空の引数を渡すなら起こ@emph{らず}、@samp{##}の前のトークンがカンマ以外の場合も起こらない。

@smallexample
eprintf ("success!\n")
     @expansion{} fprintf(stderr, "success!\n");
@end smallexample

@noindent
上記の説明は、引数が空の引数か欠けている引数かを区別しようとする意味がないので、唯一のマクロパラメータが可変の引数パラメータである場合についてはあいまいである。 CPPは特定のC標準に準拠している場合はカンマを保持する。 それ以外の場合は、標準への拡張子としてカンマが削除される。

Cの標準では、識別子@code{@w{__ VA_ARGS__}}が現れる唯一の場所は可変長マクロの置換リストにあることを要求している。 マクロ名、マクロ引数名、または別の種類のマクロ内で使用することはできない。 オープンテキストでも禁止されているかもしれない。 標準はあいまいである。 定義された目的以外には使用しないことを推奨する。

同様に、C ++は可変長マクロの置換リストの外のどこにでも@code{@w {__ VA_OPT__}}を禁じる。

可変長マクロは、C99のC言語の標準部分になった。 GNU CPPはこれまで、@samp{@dots {}}や@code{@w{__ VA_ARGS__}}ではなく、名前の変更可能な引数（@samp{args @dots{}}）をサポートしていた。

@node Predefined Macros
@section 定義済みマクロ

@cindex predefined macros
いくつかのオブジェクト風マクロがあらかじめ定義されている。 定義を提供せずにそれらを使用する。 標準、共通、システム固有の3つのクラスに分類される。

C++には、名前付き演算子の4つ目のカテゴリがある。 定義済みマクロのように動作するが、マクロを定義解除することはできない。

@menu
* Standard Predefined Macros::
* Common Predefined Macros::
* System-specific Predefined Macros::
* C++ Named Operators::
@end menu

@node Standard Predefined Macros
@subsection 標準の定義済みマクロ
@cindex standard predefined macros.

標準の定義済みマクロは、関連する言語標準によって指定されているため、これらの標準を実装するすべてのコンパイラで使用できる。 古いコンパイラはそれらのすべてを提供するわけではない。 それらの名前はすべて二重のアンダースコアで始まる。

@table @code
@item __FILE__
このマクロは、Cの文字列定数の形で現在の入力ファイルの名前に展開される。 これは、プリプロセッサが@samp{#include}で指定された短い名前ではなく、入力ファイル名の引数としてファイルを開いたパスである。 たとえば、このマクロの拡張子は@code{"/usr/local/include/myheader.h"}である。

@item __LINE__
このマクロは、現在の入力行番号に10進整数定数の形式で展開される。 定義済みマクロと呼ばれているが、新しい定義のソースコードごとに「定義」が変わるので、かなり奇妙なマクロである。
@end table

@code{__FILE__}と@code{__LINE__}は、プログラムによって検出された不一致を報告するエラーメッセージを生成するのに便利である。 メッセージは、矛盾が検出されたソース行を示すことができる。 例えば、

@smallexample
fprintf (stderr, "Internal error: "
                 "negative string length "
                 "%d at %s, line %d.",
         length, __FILE__, __LINE__);
@end smallexample

@samp{#include}ディレクティブはインクルードされたファイルに対応するように@code{__FILE__}と@code {__LINE__}の展開を変更する。 そのファイルの最後に@samp{#include}ディレクティブを含む入力ファイルで処理が再開されると、@code{__FILE__}と@code{__LINE__}の展開が@samp{#include}の前に戻される。（しかし@code{__ LINE__}は@samp {#include}の後の行に処理が移るにつれて1だけインクリメントされる）。

@samp{#line}ディレクティブは@code{__LINE__}を変更し、@code{__ FILE__}も変更する可能性がある。@xref{Line Control}。

C99は@code{__func__}を導入し、GCCは@code{__FUNCTION__}を長年提供している。 どちらも現在の関数の名前を含む文字列である（わずかな意味の違いがある; GCCのマニュアルを参照せよ）。 どちらもマクロではない。 プリプロセッサは現在の関数の名前を知らない。 しかし、@code{__ FILE__}や@code {__ LINE__}と組み合わせて使うと便利である。

@table @code

@item __DATE__
このマクロは、プリプロセッサが実行されている日付を表す文字列定数に展開される。 文字列定数は11文字を含み、@code{@w{"Feb 12 1996"}}のように見える。 月の日が10未満の場合は、左側のスペースが埋められる。

GCCが現在の日付を判断できない場合、警告メッセージが表示され（コンパイルごとに1回）、@code{__DATE__}は{@w{"??? ?? ????"}}に展開される。

@item __TIME__
このマクロは、プリプロセッサが実行されている時間を表す文字列定数に展開される。 文字列定数は8文字を含み、@code{"23:59:01"}のように見える。

GCCが現在の時刻を判断できない場合、警告メッセージ（コンパイルごとに1回）が出力され、@code{__TIME__}は@code{"??:??:??"}に展開される。

@item __STDC__
通常の操作では、このマクロは定数1に展開され、このコンパイラがISO標準Cに準拠していることを示す。 GCC以外のコンパイラでGNU CPPを使用する場合、これは必ずしも真実ではない。 ただし、@option{-traditional-cpp}オプションを使用しない限り、プリプロセッサは常に標準に準拠している。

このマクロは、@option {-traditional-cpp}オプションが使用されている場合は定義されていない。

一部のホストでは、システムコンパイラは@code{__ STDC__}が通常0である別の規則を使用するが、ユーザーがC標準に厳密に準拠していると指定した場合は1になる。 CPPはシステムのヘッダファイルを処理する際にホスト規約に従うが、ユーザファイルの処理時には@code{__STDC__}は常に1である。これは問題を引き起こすと報告されている。 たとえば、Solarisの一部のバージョンでは、@code{__ STDC__}が未定義または1であると予想されるX Windowsヘッダを提供している。 @xref{Invocation}.

@item __STDC_VERSION__
このマクロは、@code{@var{yyyy}@var{mm}L}という形式の長い整数定数であるC標準のバージョン番号に展開される。ここで、@var{yyyy}と@var{mm}は標準バージョンの年と月である。 これは、コンパイラが準拠しているC標準のバージョンを示している。 @code{__STDC__}と同様、GCCでGNU CPPを使用していない限り、実装全体では必ずしも正確ではない。

値@code{199409L}は、1994年に修正された1989 C標準を意味し、現在のデフォルトである。 値@code{199901L}は1999年のC標準の改訂を意味する。 値@code{201112L}はC標準の2011改訂版を表している。 値@code{201710L}は、C標準の2017改訂版を表す（欠陥の修正以外では2011年版と同じである）。

このマクロは、@option{-traditional-cpp}オプションが使用されている場合、またはC++またはObjective-Cのコンパイル時には定義されない。

@item __STDC_HOSTED__
コンパイラのターゲットが@dfn{ホスト環境}の場合、このマクロは値1で定義される。 ホスト環境には、標準Cライブラリの完全な機能がある。

@item __cplusplus
このマクロは、C++コンパイラが使用されているときに定義される。 @code{__ cplusplus}を使用して、ヘッダがCコンパイラとC++コンパイラのどちらによってコンパイルされているかどうかをテストすることができる。 このマクロは、バージョン番号に展開される点で@code{__STDC_VERSION__}に似ている。 選択された言語標準に応じて、マクロの値は、1998 C++標準の場合は@code{199711L}、2011 C++標準の場合は@code{201103L}、2014 C++標準の場合は@code{201402L}、2017 C++標準の場合は@code{201703L }、または@option {-std=c++2a}および@option{-std=gnu++2a}で有効になっている実験的言語の場合は、@code{201703L}より厳密に大きい不特定の値である。

@item __OBJC__
Objective-Cコンパイラが使用されている場合、このマクロは値1で定義される。 @code{__OBJC__}を使用して、ヘッダがCコンパイラとObjective-Cコンパイラのどちらによってコンパイルされているかどうかをテストすることができる。

@item __ASSEMBLER__
このマクロは、アセンブリ言語をプリプロセスするときに値1で定義される。

@end table

@node Common Predefined Macros
@subsection 共通定義済みマクロ
@cindex common predefined macros

一般的に定義されているマクロはGNU Cの拡張である。 それらは、GNU CまたはGNU Fortranを使用しているマシンまたはオペレーティングシステムに関係なく、同じ意味で使用できる。 それらの名前はすべて二重のアンダースコアで始まる。

@table @code

@item __COUNTER__
このマクロは0から始まる連続整数値に展開される。これは@code{##}演算子と組み合わせて、一意の識別子を生成する便利な手段を提供する。 @code{__ COUNTER__}がそれを使用するプリコンパイルされたヘッダをインクルードする前に展開されないように注意する必要がある。 そうしないと、プリコンパイルされたヘッダーは使用されない。

@item __GFORTRAN__
GNU Fortranコンパイラはこれを定義している。

@item __GNUC__
@itemx __GNUC_MINOR__
@itemx __GNUC_PATCHLEVEL__
これらのマクロは、Cプリプロセッサを使用するすべてのGNUコンパイラ、C、C++、Objective-C、Fortranで定義されている。 それらの値は、整数定数として、コンパイラのメジャーバージョン、マイナーバージョン、およびパッチレベルである。 たとえば、GCCのバージョン@var{x}.@var{y}.@ var{z}は@code{__GNUC__}を@var{x}に、@code{__GNUC_MINOR__}を@var{y}に、@code{__GNUC_PATCHLEVEL__}を@var {z}に変換する。 これらのマクロは、プリプロセッサを直接呼び出す場合にも定義される。

あなたのプログラムがGCCかGNU Cの方言を受け入れると主張するGCC以外のコンパイラによってコンパイルされているかどうかを知る必要がある場合は、単に@code{__GNUC__}をテストできる。 特定のバージョンに依存するコードを記述する必要がある場合は、さらに注意する必要がある。 マイナーバージョンを増やすたびに、パッチレベルはゼロにリセットされる。 メジャーバージョンを増やすたびに、マイナーバージョンとパッチレベルがリセットされる。 条件付きマクロで直接使用する場合は、次のように記述する必要がある。

@smallexample
/* @r{Test for GCC > 3.2.0} */
#if __GNUC__ > 3 || \
    (__GNUC__ == 3 && (__GNUC_MINOR__ > 2 || \
                       (__GNUC_MINOR__ == 2 && \
                        __GNUC_PATCHLEVEL__ > 0))
@end smallexample

@noindent
もう1つのアプローチは、あらかじめ定義されたマクロを使用して1つの数値を計算し、それをしきい値と比較することである。

@smallexample
#define GCC_VERSION (__GNUC__ * 10000 \
                     + __GNUC_MINOR__ * 100 \
                     + __GNUC_PATCHLEVEL__)
@dots{}
/* @r{Test for GCC > 3.2.0} */
#if GCC_VERSION > 30200
@end smallexample

@noindent
多くの人がこのフォームを理解しやすくしている。

@item __GNUG__
GNU C++コンパイラはこれを定義している。 これをテストすることは、@code{@w{(__GNUC__ && __cplusplus)}}をテストするのと同じである。

@item __STRICT_ANSI__
GCCが呼び出されたときに、@option{-ansi}スイッチ、またはISO CまたはISO C++のいくつかのバージョンに厳密に準拠している@option{-std}スイッチが指定されている場合にのみ、このマクロが定義される。 @samp{1}と定義されている。 このマクロは、主にGNU libcのヘッダファイルに標準Cで定義されている定義のみを使用するように指示する。

@item __BASE_FILE__
このマクロは、Cの文字列定数の形式でメイン入力ファイルの名前に展開される。 これは、プリプロセッサまたはCコンパイラのコマンドラインで指定されたソースファイルである。

@item __INCLUDE_LEVEL__
このマクロは、インクルードファイルのネストの深さを表す10進整数定数に展開される。 このマクロの値は、@samp{#include}指令ごとにインクリメントされ、インクルードされているファイルの最後にデクリメントされる。 コマンドラインで指定されたベースファイル内の値0から開始する。

@item __ELF__
このマクロは、ターゲットがELFオブジェクト形式を使用する場合に定義される。

@item __VERSION__
このマクロは、使用中のコンパイラのバージョンを示す文字列定数に展開される。 値が特定の形式を持つ内容であるち頼るべきではないが、少なくともリリース番号を含れているだろう。

@item __OPTIMIZE__
@itemx __OPTIMIZE_SIZE__
@itemx __NO_INLINE__
これらのマクロは、コンパイルモードを表している。 @code{__OPTIMIZE__}はすべての最適化コンパイルで定義されている。 @code{__OPTIMIZE_SIZE__}は、コンパイラが速度ではなくサイズを最適化する場合に定義される。 @code{__NO_INLINE__}は、呼び出し元に関数がインライン化されない場合（最適化されていない場合、または@option{-fno-inline}によってインライン展開が特に無効になっている場合）に定義される。

これらのマクロは、特定のGNUヘッダファイルに、システムライブラリ関数のマクロまたはインライン関数を使って最適化された定義を提供する。 これらのマクロは、プログラムが定義されているかどうかにかかわらず同じ効果で実行されることを確認しない限り、使用するべきではない。 定義されている場合、その値は1である。

@item __GNUC_GNU_INLINE__
GCCは、@code{inline}と宣言された関数がGCCの伝統的なgnu90モードで扱われるなら、このマクロを定義する。 オブジェクトファイルには、@code{extern}や@code{static}を使わずに、@code{inline}で宣言されたすべての関数の外部で定義された定義が含まれる。 @code{extern inline}と宣言された関数の定義は含まれない。

@item __GNUC_STDC_INLINE__
GCCは、@code{inline}と宣言された関数がISO C99以降の規格に従って処理される場合、このマクロを定義する。 オブジェクトファイルには、@code{extern inline}と宣言されたすべての関数の外部から見える定義が含まれる。 @code{extern}なしで@code{inline}と宣言された関数の定義は含まれない。

このマクロが定義されている場合、GCCは常にgnu90の動作を得るための@code{gnu_inline}関数属性をサポートしている。

@item __CHAR_UNSIGNED__
GCCは、データ型@code{char}がターゲットマシン上で符号なしである場合に限り、このマクロを定義する。 これは、標準のヘッダファイル@file{limits.h}を正しく動作させるために存在する。 このマクロは自分で使用するべきではない。 代わりに、@file{limits.h}で定義された標準マクロを参照すること。

@item __WCHAR_UNSIGNED__
@code{__ CHAR_UNSIGNED__}のように、このマクロはデータ型@code{wchar_t}が符号なしで、フロントエンドがC++モードの場合にのみ定義される。

@item __REGISTER_PREFIX__
このマクロは、このターゲットのアセンブリ言語でCPUレジスタ名に適用される接頭辞である単一のトークン（文字列定数ではない）に展開される。 これを使用して、複数の環境で使用可能なアセンブリを記述できる。 たとえば、@code{m68k-aout}環境では何も展開されないが、@code{m68k-coff}環境では単一の@samp{％}に展開される。

@item __USER_LABEL_PREFIX__
このマクロは、アセンブリ内のユーザーラベル（Cコードから見えるシンボル）に適用されるプレフィックスである単一のトークンに展開される。 たとえば、@code{m68k-aout}環境では@samp {_}に展開されるが、@code{m68k-coff}環境では何も展開されない。

このマクロは、@option{-f(no-)underscores}が使用されていても正しい定義を持つが、この接頭辞を調整するターゲット固有のオプションが使用されていると正しくない（例えば：OSF/rose @option{-mno-underscores}オプション）。

@item __SIZE_TYPE__
@itemx __PTRDIFF_TYPE__
@itemx __WCHAR_TYPE__
@itemx __WINT_TYPE__
@itemx __INTMAX_TYPE__
@itemx __UINTMAX_TYPE__
@itemx __SIG_ATOMIC_TYPE__
@itemx __INT8_TYPE__
@itemx __INT16_TYPE__
@itemx __INT32_TYPE__
@itemx __INT64_TYPE__
@itemx __UINT8_TYPE__
@itemx __UINT16_TYPE__
@itemx __UINT32_TYPE__
@itemx __UINT64_TYPE__
@itemx __INT_LEAST8_TYPE__
@itemx __INT_LEAST16_TYPE__
@itemx __INT_LEAST32_TYPE__
@itemx __INT_LEAST64_TYPE__
@itemx __UINT_LEAST8_TYPE__
@itemx __UINT_LEAST16_TYPE__
@itemx __UINT_LEAST32_TYPE__
@itemx __UINT_LEAST64_TYPE__
@itemx __INT_FAST8_TYPE__
@itemx __INT_FAST16_TYPE__
@itemx __INT_FAST32_TYPE__
@itemx __INT_FAST64_TYPE__
@itemx __UINT_FAST8_TYPE__
@itemx __UINT_FAST16_TYPE__
@itemx __UINT_FAST32_TYPE__
@itemx __UINT_FAST64_TYPE__
@itemx __INTPTR_TYPE__
@itemx __UINTPTR_TYPE__
これらのマクロは、それぞれ
These macros are defined to the correct underlying types for the
@code{size_t}, @code{ptrdiff_t}, @code{wchar_t}, @code{wint_t},
@code{intmax_t}, @code{uintmax_t}, @code{sig_atomic_t}, @code{int8_t},
@code{int16_t}, @code{int32_t}, @code{int64_t}, @code{uint8_t},
@code{uint16_t}, @code{uint32_t}, @code{uint64_t},
@code{int_least8_t}, @code{int_least16_t}, @code{int_least32_t},
@code{int_least64_t}, @code{uint_least8_t}, @code{uint_least16_t},
@code{uint_least32_t}, @code{uint_least64_t}, @code{int_fast8_t},
@code{int_fast16_t}, @code{int_fast32_t}, @code{int_fast64_t},
@code{uint_fast8_t}, @code{uint_fast16_t}, @code{uint_fast32_t},
@code{uint_fast64_t}, @code{intptr_t}, @code{uintptr_t}のtypedefの正しい基本タイプに定義されている。@file{stddef.h}、@file{stdint.h}、@file{wchar.h}の標準ヘッダファイルを正しく動作させるために存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを組み込み、typedefを使用すること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __CHAR_BIT__
@code{char}データ型の表現に使用されるビット数で定義される。 数値制限が与えられた標準ヘッダーを正しく動作させるために存在する。 このマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。

@item __SCHAR_MAX__
@itemx __WCHAR_MAX__
@itemx __SHRT_MAX__
@itemx __INT_MAX__
@itemx __LONG_MAX__
@itemx __LONG_LONG_MAX__
@itemx __WINT_MAX__
@itemx __SIZE_MAX__
@itemx __PTRDIFF_MAX__
@itemx __INTMAX_MAX__
@itemx __UINTMAX_MAX__
@itemx __SIG_ATOMIC_MAX__
@itemx __INT8_MAX__
@itemx __INT16_MAX__
@itemx __INT32_MAX__
@itemx __INT64_MAX__
@itemx __UINT8_MAX__
@itemx __UINT16_MAX__
@itemx __UINT32_MAX__
@itemx __UINT64_MAX__
@itemx __INT_LEAST8_MAX__
@itemx __INT_LEAST16_MAX__
@itemx __INT_LEAST32_MAX__
@itemx __INT_LEAST64_MAX__
@itemx __UINT_LEAST8_MAX__
@itemx __UINT_LEAST16_MAX__
@itemx __UINT_LEAST32_MAX__
@itemx __UINT_LEAST64_MAX__
@itemx __INT_FAST8_MAX__
@itemx __INT_FAST16_MAX__
@itemx __INT_FAST32_MAX__
@itemx __INT_FAST64_MAX__
@itemx __UINT_FAST8_MAX__
@itemx __UINT_FAST16_MAX__
@itemx __UINT_FAST32_MAX__
@itemx __UINT_FAST64_MAX__
@itemx __INTPTR_MAX__
@itemx __UINTPTR_MAX__
@itemx __WCHAR_MIN__
@itemx __WINT_MIN__
@itemx __SIG_ATOMIC_MIN__
@code{signed char}, @code{wchar_t}, @code{signed short},
@code{signed int}, @code{signed long}, @code{signed long long},
@code{wint_t}, @code{size_t}, @code{ptrdiff_t},
@code{intmax_t}, @code{uintmax_t}, @code{sig_atomic_t}, @code{int8_t},
@code{int16_t}, @code{int32_t}, @code{int64_t}, @code{uint8_t},
@code{uint16_t}, @code{uint32_t}, @code{uint64_t},
@code{int_least8_t}, @code{int_least16_t}, @code{int_least32_t},
@code{int_least64_t}, @code{uint_least8_t}, @code{uint_least16_t},
@code{uint_least32_t}, @code{uint_least64_t}, @code{int_fast8_t},
@code{int_fast16_t}, @code{int_fast32_t}, @code{int_fast64_t},
@code{uint_fast8_t}, @code{uint_fast16_t}, @code{uint_fast32_t},
@code{uint_fast64_t}, @code{intptr_t}, @code{uintptr_t}の型の最大値と、@code{wchar_t}, @code{wint_t}, 
@code {sig_atomic_t}の最大値と最小値にそれぞれ定義されている。 数値制限が与えられた標準ヘッダを正しく動作させるために存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __INT8_C
@itemx __INT16_C
@itemx __INT32_C
@itemx __INT64_C
@itemx __UINT8_C
@itemx __UINT16_C
@itemx __UINT32_C
@itemx __UINT64_C
@itemx __INTMAX_C
@itemx __UINTMAX_C
先行する@code{__}のない同じ名前の標準の@file{stdint.h}マクロの実装に定義されている。 それらは、そのヘッダーの実装が正しく動作するように存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __SCHAR_WIDTH__
@itemx __SHRT_WIDTH__
@itemx __INT_WIDTH__
@itemx __LONG_WIDTH__
@itemx __LONG_LONG_WIDTH__
@itemx __PTRDIFF_WIDTH__
@itemx __SIG_ATOMIC_WIDTH__
@itemx __SIZE_WIDTH__
@itemx __WCHAR_WIDTH__
@itemx __WINT_WIDTH__
@itemx __INT_LEAST8_WIDTH__
@itemx __INT_LEAST16_WIDTH__
@itemx __INT_LEAST32_WIDTH__
@itemx __INT_LEAST64_WIDTH__
@itemx __INT_FAST8_WIDTH__
@itemx __INT_FAST16_WIDTH__
@itemx __INT_FAST32_WIDTH__
@itemx __INT_FAST64_WIDTH__
@itemx __INTPTR_WIDTH__
@itemx __INTMAX_WIDTH__
対応する型のビット幅に定義される。 @file{limits.h}と@file{stdint.h}の実装を正しく動作させるために存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __SIZEOF_INT__
@itemx __SIZEOF_LONG__
@itemx __SIZEOF_LONG_LONG__
@itemx __SIZEOF_SHORT__
@itemx __SIZEOF_POINTER__
@itemx __SIZEOF_FLOAT__
@itemx __SIZEOF_DOUBLE__
@itemx __SIZEOF_LONG_DOUBLE__
@itemx __SIZEOF_SIZE_T__
@itemx __SIZEOF_WCHAR_T__
@itemx __SIZEOF_WINT_T__
@itemx __SIZEOF_PTRDIFF_T__
C標準データ型のバイト数を定義する。 @code{int},
@code{long}, @code{long long}, @code{short}, @code{void *}, @code{float},
@code{double}, @code{long double}, @code{size_t}, @code{wchar_t}, @code{wint_t}, @code{ptrdiff_t}.

@item __BYTE_ORDER__
@itemx __ORDER_LITTLE_ENDIAN__
@itemx __ORDER_BIG_ENDIAN__
@itemx __ORDER_PDP_ENDIAN_
@code{__BYTE_ORDER__}は、メモリ内のマルチバイトおよびマルチワード量のレイアウトを反映するために、@code{__ORDER_LITTLE_ENDIAN__}、@code{__ORDER_BIG_ENDIAN__}、または@code{__ORDER_PDP_ENDIAN__}のいずれかの値に定義されている。 @code{__BYTE_ORDER__}が@code{__ORDER_LITTLE_ENDIAN__}または@code{__ORDER_BIG_ENDIAN__}と等しい場合、マルチバイト数とマルチワード数は同じように配置される。最下位アドレスのバイト（ワード）は、量の最下位バイトまたは最上位バイト（ワード）である。@code {__ BYTE_ORDER__}が@code {__ ORDER_PDP_ENDIAN__}の場合、16ビットワードのバイトはリトルエンディアン形式で配置され、32ビットの16ビットサブワードはビッグエンディアン形式で配置される。

次のようなテストのためにこれらのマクロを使うべきである：

@smallexample
/* @r{Test for a little-endian machine} */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
@end smallexample

@item __FLOAT_WORD_ORDER__
@code{__FLOAT_WORD_ORDER__}は、マルチワード浮動小数点数のワードのレイアウトを反映するために、@code{__ORDER_LITTLE_ENDIAN__}または@code{__ORDER_BIG_ENDIAN__}の値の1つに定義されている。

@item __DEPRECATED
このマクロは、廃止予定の構造が有効になっていることを警告するC++ソースファイルをコンパイルするときに、値1で定義される。 これらの警告はデフォルトで有効になっているが、@option{-Wno-deprecated}で無効にすることができる。

@item __EXCEPTIONS
このマクロは、例外を有効にしてC ++ソースファイルをコンパイルするときに、値1で定義される。 ファイルをコンパイルするときに@option{-fno-exceptions}を使用すると、このマクロは定義されない。

@item __GXX_RTTI
このマクロは、ランタイム・タイプ識別を有効にしてC ++ソース・ファイルをコンパイルするときに、値1で定義される。 ファイルをコンパイルするときに@option{-fno-rtti}を使用すると、このマクロは定義されない。

@item __USING_SJLJ_EXCEPTIONS__
コンパイラが例外処理のために@code{setjmp}と@code{longjmp}に基づく古い機構を使用する場合、このマクロは値1で定義される。

@item __GXX_EXPERIMENTAL_CXX0X__
このマクロは、オプション@option{-std=c++0x}または@option{-std=gnu++0x}を使用してC ++ソースファイルをコンパイルするときに定義される。 これは、C++0xに含まれる可能性のある機能が利用可能であることを示している。 これらの機能は実験的なものであり、GCCの将来のバージョンで変更されるか、または削除される可能性があることに注意せよ。

@item __GXX_WEAK__
このマクロは、C++ソースファイルをコンパイルするときに定義される。 コンパイラが弱いシンボル、COMDATセクション、または他の同様の手法を使用して、複数の翻訳単位で定義された「曖昧なリンケージ」でシンボルを崩壊させる場合、値は1である。 コンパイラがそのようなシンボルを崩壊させない場合、このマクロは値0で定義される。一般に、ユーザコードはこのマクロを使用する必要はない。 このマクロの目的は、G++で提供されるC ++ランタイムライブラリの実装を容易にすることである。

@item __NEXT_RUNTIME__
Objective-CでNeXTランタイム（@option{-fnext-runtime}のように）が使用されている場合、このマクロは値1で定義される。 GNUランタイムが使用されている場合、このマクロは定義されていないため、このマクロを使用してどのランタイム（NeXTまたはGNU）が使用されているかを判断できる。

@item __LP64__
@itemx _LP64
これらのマクロは、コンパイルが@code{long int}とポインタが両方とも64ビットを使用し、@code{int}が32ビットを使用するターゲット用である場合にのみ、値1で定義される。

@item __SSP__
このマクロは、@option {-fstack-protector}が使用されているときに値1で定義される。

@item __SSP_ALL__
このマクロは、@option{-fstack-protector-all}が使用されているときに値2で定義される。

@item __SSP_STRONG__
このマクロは、@option{-fstack-protector-strong}が使用されているときに値3で定義される。

@item __SSP_EXPLICIT__
このマクロは、@option {-fstack-protector-explicit}が使用されているときに値4で定義される。

@item __SANITIZE_ADDRESS__
このマクロは、@option{-fsanitize = address}または@option{-fsanitize = kernel-address}が使用されているときに値1で定義される。

@item __SANITIZE_THREAD__
このマクロは、@option {-fsanitize = thread}が使用されているときに値1で定義される。

@item __TIMESTAMP__
このマクロは、現在のソースファイルの最終変更日時を表す文字列定数に展開される。 文字列定数には、省略された週、月、日、hh:mm:ss形式の時刻、年含まれ、@code{@w{"Sun Sep 16 01:03:52 1973"}}のようになる。 月の日が10未満の場合は、左側のスペースが埋められる。

GCCが現在の日付を判断できない場合、警告メッセージ（コンパイルごとに1回）が出力され、@code {__ TIMESTAMP__}は@code{@w{"??? ??? ?? ??:??:?? ????"}}に展開される。

@item __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16
これらのマクロは、ターゲットプロセッサがオペランド1,2,4,8または16バイトのアトミック比較およびスワップ操作をそれぞれサポートする場合に定義される。

@item __GCC_HAVE_DWARF2_CFI_ASM
このマクロは、コンパイラがDWARF CFIディレクティブをアセンブラに発行しているときに定義される。 これが定義されている場合、インラインアセンブリで同じディレクティブを発行することができる。

@item __FP_FAST_FMA
@itemx __FP_FAST_FMAF
@itemx __FP_FAST_FMAL
バックエンドが@code{fma}、@code{fmaf}、@code{fmal}組み込み関数をサポートしている場合、これらのマクロは値1で定義され、インクルードファイル@file{math.h} 1999 C標準との互換性のために、@code{FP_FAST_FMA}、@code{FP_FAST_FMAF}、および@code{FP_FAST_FMAL}マクロが定義されている。

@item __FP_FAST_FMAF16
@itemx __FP_FAST_FMAF32
@itemx __FP_FAST_FMAF64
@itemx __FP_FAST_FMAF128
@itemx __FP_FAST_FMAF32X
@itemx __FP_FAST_FMAF64X
@itemx __FP_FAST_FMAF128X
これらのマクロは、バックエンドがISO/ IEC TS 18661-3：2015で定義されている追加の@code{_Float@var{n}}型と@code{_Float@var{n}x}型を使用して@code{fma}関数をサポートする場合、値1で定義される。 インクルードファイル@file {math.h}は、ユーザーが@file{math.h}をインクルードする前に@code{__STDC_WANT_IEC_60559_TYPES_EXT__}を定義した場合、@code{FP_FAST_FMAF@var{n}}マクロと@code{FP_FAST_FMAF@var{n}x}マクロが定義されうる。

@item __GCC_IEC_559
このマクロは、IEEE 754（IEC 60559）浮動小数点演算のサポートレベルを示すために定義されている。 それは非負の整数値に展開される。 0の場合、コンパイラの設定とコマンドラインオプションの組み合わせは、C99およびC11 Annex Fで定義されている@code{float}および@code {double}のIEEE 754算術をサポートするものではないことを示している（たとえば、 標準の丸めモードと例外がサポートされていないか、またはIEEE 754セマンティクスと競合する最適化が有効になっているなそ）。 1の場合、IEEE 754の算術演算がサポートされることを示している。 これは、関連するすべての言語機能がGCCによってサポートされていることを意味するものではない。 2以上の場合、IEEE 754-2008のサポートを追加的に示している（特に、シグナリングNaNを静かにするためのバイナリエンコーディングはIEEE 754-2008で指定されている）。.

このマクロは、C99およびC11が標準のプラグマによって制御されることを許可する最適化を制御するコマンドラインオプションのデフォルト状態を示していない。これらの標準では、特定のデフォルト状態は必要ない。 最適化がシグナリングNaNセマンティクス（そのマクロは@code{__SUPPORT_SNAN__}）を尊重するかどうかを示すものではない。 10進浮動小数点、またはIEEE 754のbinary16およびbinary128型のサポートを示すものではない。

@item __GCC_IEC_559_COMPLEX
このマクロは、C99およびC11 Annex Gで定義されている複素数のIEEE 754（IEC 60559）浮動小数点演算のサポートレベルを示すために定義されている。負ではない整数値に展開される。 0の場合は、コンパイラの設定とコマンドラインオプションの組み合わせがAnnex Gの要件をサポートするものではないことを示す（たとえば、@option{-fcx-limited-range}が使用されたため）。 1以上の場合は、これらの要件をサポートすることを意図していることを示している。 これは、関連するすべての言語機能がGCCによってサポートされていることを意味するものではない。

@item __NO_MATH_ERRNO__
このマクロは、@option {-fno-math-errno}が使用されている場合、または@option{-ffast-math}のような別のオプションによって、またはデフォルトで有効になっている場合に定義される。
@end table

@node System-specific Predefined Macros
@subsection システム固有の定義済みマクロ

@cindex system-specific predefined macros
@cindex predefined macros, system-specific
@cindex reserved namespace

Cプリプロセッサは通常、どのタイプのシステムとマシンが使用されているかを示すいくつかのマクロを事前に定義している。 それらは明らかにGCCによってサポートされている各ターゲットで異なる。 このマニュアルでは、すべてのシステムとマシンで使用されている名前を出すことはできないが、@command{cpp -dM}を使ってそれらのすべてを見ることができる。 @xref{Invocation}。 システム固有の定義済みマクロはすべて定数値に展開されるため、@samp{#ifdef}または@samp{#if}のいずれかを使用してテストできる。

C標準では、すべてのシステム固有のマクロが@dfn{予約済み名前空間}の一部であることが必要である。 2つのアンダースコア、またはアンダースコアと大文字で始まるすべての名前は、コンパイラとライブラリが望むように使用するために予約されている。 しかし、歴史的にシステム特有のマクロは特別な接頭辞を持たない名前を持っていた。 たとえば、Unixシステムで@code{unix}が定義されているのが一般的である。 このようなすべてのマクロでは、GCCは最初と最後に2つのアンダースコアが追加された並列マクロを提供しる。 @code{unix}が定義されている場合、@code{__unix__}も定義される。 二つ以上のアンダースコアはない。 @code{_mips}のパラレルは@code{__mips__}である。

厳密な適合を要求する@option{-ansi}オプションまたは@option{-std}オプションがコンパイラに渡されると、予約された名前空間外のすべてのシステム固有の事前定義されたマクロは抑制される。 予約された名前空間内の並列マクロは定義されたままである。

予約された名前空間の外にあるすべての定義済みマクロを少しずつ段階的に削除している。 新しいプログラムでは決して使用すべきでない。古いコードを見つけたら、いつでも並列マクロを使用するように修正することを推奨する。 予約済みの名前空間にあるシステム固有のマクロを使用することも推奨はしない。 長期的には、@command{autoconf}のようなツールを使って、必要な機能を具体的にチェックする方が良いだろう。

@node C++ Named Operators
@subsection C++名前付き演算子
@cindex named operators
@cindex C++ named operators
@cindex @file{iso646.h}

C++には、11個のキーワードがある。これらのキーワードは、通常、句読点で書かれた演算子の代わりのスペルである。 これらのキーワードは、プリプロセッサでも同様に扱われる。 それらは@samp{#if}の演算子として機能し、マクロまたは中毒として定義することはできない。 Cでは、@file{iso646.h}をインクルードすることによって、それらのキーワードがC++の意味を持つことを要求できる。 そのヘッダーは、それぞれを適切な句読点に展開する通常のオブジェクトのようなマクロとして定義する。

これらは、名前付き演算子と対応する句読点である。

@multitable {Named Operator} {Punctuator}
@item Named Operator @tab Punctuator
@item @code{and}    @tab @code{&&}
@item @code{and_eq} @tab @code{&=}
@item @code{bitand} @tab @code{&}
@item @code{bitor}  @tab @code{|}
@item @code{compl}  @tab @code{~}
@item @code{not}    @tab @code{!}
@item @code{not_eq} @tab @code{!=}
@item @code{or}     @tab @code{||}
@item @code{or_eq}  @tab @code{|=}
@item @code{xor}    @tab @code{^}
@item @code{xor_eq} @tab @code{^=}
@end multitable

@node Undefining and Redefining Macros
@section マクロの未定義化と再定義
@cindex undefining macros
@cindex redefining macros
@findex #undef

マクロが有用でなくなるならば、マクロは@samp{#undef}ディレクティブで@dfn{未定義}になることができる。 @samp{#undef}は単一の引数、つまり未定義のマクロの名前をとる。 マクロが関数的なものであっても、裸のマクロ名を使用する。 マクロ名の後に行に何かが現れるとエラーになる。 名前がマクロでない場合、@samp{#undef}は効果がない。

@smallexample
#define FOO 4
x = FOO;        @expansion{} x = 4;
#undef FOO
x = FOO;        @expansion{} x = FOO;
@end smallexample

マクロが定義されていない場合、その識別子は後続の@samp{#define}ディレクティブによってマクロとして@dfn{再定義}することができる。 新しい定義は、古い定義と似ている必要はない。

しかし、現在マクロである識別子が再定義された場合、新しい定義は古いものと@dfn{実質的に同じ}でなければならない。 次の場合、2つのマクロ定義は事実上同じである：
@itemize @bullet
@item 両方がマクロの同じ型である（オブジェクト風か関数風か）
@item 置換リストのすべてのトークンは同じである。
@item パラメータがあるならば、それらが同じである。
@item 空白は両方の同じ場所に表示される。 しかし、必ずしも同じ量の空白である必要はない。 コメントは空白として数えることを思い出すこと。
@end itemize

@noindent
これらの定義は事実上同じである：
@smallexample
#define FOUR (2 + 2)
#define FOUR         (2    +    2)
#define FOUR (2 /* @r{two} */ + 2)
@end smallexample
@noindent
しかし以下は違う：
@smallexample
#define FOUR (2 + 2)
#define FOUR ( 2+2 )
#define FOUR (2 * 2)
#define FOUR(score,and,seven,years,ago) (2 + 2)
@end smallexample

既存のマクロと実質的に同じではない定義でマクロが再定義された場合、プリプロセッサは警告を発行して新しい定義を使用するようにマクロを変更する。 新しい定義が事実上同じ場合、再定義は暗黙のうちに無視されます。 これは、例えば、2つの異なるヘッダが共通のマクロを定義することを可能にする。 プリプロセッサは、定義が一致しない場合にのみ文句を言う。

@node Directives Within Macro Arguments
@section マクロ引数内のディレクティブ
@cindex macro arguments and directives

場合によっては、マクロの引数内でプリプロセッサディレクティブを使用すると便利である。 CおよびC++標準では、これらの場合の動作が定義されていないと宣言している。 GNU CPPは、関数風マクロ呼び出しは存在しないときのディレクティブを処理したのとまったく同じ方法でマクロ引数内の任意のディレクティブを処理する。

マクロの呼び出し内でそのマクロが再定義された場合、新しい定義は引数の展開前に有効になるが、元の定義は引き続き引数の置換に使用される。 病理学的な例がある：

@smallexample
#define f(x) x x
f (1
#undef f
#define f 2
f)
@end smallexample

@noindent
は上で説明したような意味で以下に展開される

@smallexample
1 2 1 2
@end smallexample

@noindent

@node Macro Pitfalls
@section マクロの落とし穴
@cindex problems with macros
@cindex pitfalls of macros

このセクションでは、マクロとマクロ展開に適用される特別な規則をいくつか説明し、注意が必要な反直感的な結果がある特定のケースを指摘する。

@menu
* Misnesting::
* Operator Precedence Problems::
* Swallowing the Semicolon::
* Duplication of Side Effects::
* Self-Referential Macros::
* Argument Prescan::
* Newlines in Arguments::
@end menu

@node Misnesting
@subsection ネストの非対応

引数を指定してマクロを呼び出すと、引数はマクロ本体に代入され、残りの入力ファイルとともに結果がチェックされ、より多くのマクロ呼び出しが行われる。 部分的にマクロ本体から来て、引数から部分的に来るマクロ呼び出しを一緒にまとめることは可能である。 例えば、

@smallexample
#define twice(x) (2*(x))
#define call_with_1(x) x(1)
call_with_1 (twice)
     @expansion{} twice(1)
     @expansion{} (2*(1))
@end smallexample

マクロ定義にはバランスのとれた括弧が必要ではない。 アンバランスな括弧をマクロ本体に書き込むことで、マクロ本体内で始まり、その外側で終わるマクロ呼び出しを作成することができる。 例えば、

@smallexample
#define strange(file) fprintf (file, "%s %d",
@dots{}
strange(stderr) p, 35)
     @expansion{} fprintf (stderr, "%s %d", p, 35)
@end smallexample

マクロ呼び出しをまとめる機能は便利だが、マクロ本体でアンバランスな開きカッコを使用するのは混乱するだけなので、避けるべきである。

@node Operator Precedence Problems
@subsection 演算子の優先順位の問題
@cindex parentheses in macro bodies

上に示したマクロ定義の例の大部分で、マクロ引数名のそれぞれにはカッコが付いていたことにきついたかもしれない。 さらに、通常、もう1組のカッコがマクロ定義全体を囲む。これがマクロを書くのが最善の方法である。

次のようにマクロを定義したとすると、

@smallexample
#define ceil_div(x, y) (x + y - 1) / y
@end smallexample

@noindent
この目的は除算をしてから切り上げることである。 （この操作の1つの用途は、特定の数の@code{char}オブジェクトを保持するために必要な@code{int}オブジェクトの数を計算することである）。次に、以下のように使われると

@smallexample
a = ceil_div (b & c, sizeof (int));
     @expansion{} a = (b & c + sizeof (int) - 1) / sizeof (int);
@end smallexample

@noindent
これは意図したことをしない。 Cの演算子優先ルールは、これと同じになる：

@smallexample
a = (b & (c + sizeof (int) - 1)) / sizeof (int);
@end smallexample

@noindent
私たちが欲しいのはこれである：

@smallexample
a = ((b & c) + sizeof (int) - 1)) / sizeof (int);
@end smallexample

@noindent
マクロを次のように定義すると

@smallexample
#define ceil_div(x, y) ((x) + (y) - 1) / (y)
@end smallexample

@noindent
望んだ結果を得る。

意図しないグループ分けが別の方法で起こる可能性がある。 @code{sizeof ceil_div(1,2)}を考える。 これは、@code{ceil_div(1, 2)}の型のサイズを計算するC式のようにみえるが、実際それは非常に異なるものを意味している。 ここにそれがどう展開するかがある：

@smallexample
sizeof ((1) + (2) - 1) / (2)
@end smallexample

@noindent
これは整数の大きさをとり、2で割ったものである。 優先順位のルールは、内部にあることを意図したときに除算を@code {sizeof}の外に置いている。

マクロ定義全体のかっこは、このような問題を防ぐ。 ここでは、これが@code{ceil_div}を定義するための推奨される方法である：

@smallexample
#define ceil_div(x, y) (((x) + (y) - 1) / (y))
@end smallexample

@node Swallowing the Semicolon
@subsection セミコロンをのみこむ
@cindex semicolons (after macro calls)

しばしば、複合文に展開されるマクロを定義することが望まれる。 たとえば、次のマクロを考えてみる。空白文字をまたいだポインタ（引数@code{p}はどこにあるのかを示す）を進める。

@smallexample
#define SKIP_SPACES(p, limit)  \
@{ char *lim = (limit);         \
  while (p < lim) @{            \
    if (*p++ != ' ') @{         \
      p--; break; @}@}@}
@end smallexample

@noindent
ここで、バックスラッシュ・改行は、マクロ定義を分割するために使用される。マクロ定義は、マクロ定義の一部ではない場合にそのようなコードがレイアウトされる方法に似ているように、単一の論理行でなければならない。

このマクロの呼び出しは、@code{SKIP_SPACES(p、lim)}となる。 厳密に言えば、呼び出しは複合ステートメントに展開される。複合ステートメントは、セミコロンを終了する必要がない完全なステートメントである。 しかし、関数呼び出しのように見えるので、関数呼び出しのように使うことができ、後で@code{SKIP_SPACES(p、lim);}のようにセミコロンを書くと混乱が最小限に抑えられる。

これは、セミコロンが実際にはヌルステートメントであるため、@code{else}ステートメントの前に問題を引き起こす可能性がある。こう書いたとする。

@smallexample
if (*p != 0)
  SKIP_SPACES (p, lim);
else @dots{}
@end smallexample

@noindent
@code{if}条件と@code{else}の間に2つのステートメント---複合ステートメントとヌルステートメント---が存在すると、無効なCコードになる。

マクロの定義@code{SKIP_SPACES}は、この問題を解決するために@code{do @dots{} while}ステートメントを使用して変更することができる。 方法は次のとおりである。

@smallexample
#define SKIP_SPACES(p, limit)     \
do @{ char *lim = (limit);         \
     while (p < lim) @{            \
       if (*p++ != ' ') @{         \
         p--; break; @}@}@}          \
while (0)
@end smallexample

今、@code{SKIP_SPACES(p、lim);}は以下のように展開される

@smallexample
do @{@dots{}@} while (0);
@end smallexample

@noindent
これは1つのステートメントである。 ループは正確に1回実行される。 ほとんどのコンパイラはそれのための特別なコードを生成しない。

@node Duplication of Side Effects
@subsection 副作用の重複

@cindex side effects (in macro arguments)
@cindex unsafe macros
多くのCプログラムは、以下のように、「最小」のマクロ@code{min}を定義している。

@smallexample
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
@end smallexample

ここに示すように、このマクロに副作用を含む引数を使用すると、

@smallexample
next = min (x + y, foo (z));
@end smallexample

@noindent
次のように展開される。

@smallexample
next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));
@end smallexample

@noindent
ここで@code{X}は@code{x + y}に、@code{Y}は@code{foo(z)}に置き換えられている。

関数@code{foo}はプログラム中に現れている文の中で一度だけ使われるが、式@code{foo(z)}はマクロ展開に2回代入されている。 その結果、文が実行されるときに@code{foo}が2回呼び出されることがある。 副作用がある場合や、計算に時間がかかる場合、結果は意図したとおりではない可能性がある。 @code{min}は@dfn{安全でない}マクロである。

この問題に対する最良の解決策は、@code{foo(z)}の値を1回だけ計算する方法で@code{min}を定義することである。 C言語はこれを行う標準的な方法を提供していないが、次のようにGNU拡張で行うことができる：
follows:

@smallexample
#define min(X, Y)                \
(@{ typeof (X) x_ = (X);          \
   typeof (Y) y_ = (Y);          \
   (x_ < y_) ? x_ : y_; @})
@end smallexample

@samp{(@{ @dots{} @})}表記法は、式として機能する複合文を生成する。 その値は最後のステートメントの値である。 これにより、ローカル変数を定義し、各引数を1つに割り当てることができる。 ローカル変数は名前の後にアンダースコアを付けて、より広いスコープの識別子との衝突のリスクを低減する（これを完全に避けることは不可能である）。 各引数は正確に1回だけ評価される。

GNU C拡張機能を使用したくない場合は、唯一の解決法はマクロ@code{min}を@emph{使用する}ときに注意することである。 たとえば、@code{foo(z)}の値を計算し、変数に保存し、その変数を@code{min}に使用することができる。

@smallexample
@group
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
@dots{}
@{
  int tem = foo (z);
  next = min (x + y, tem);
@}
@end group
@end smallexample

@noindent
（ここでは、@code{foo}が@code{int}型を返すと仮定する）。

@node Self-Referential Macros
@subsection 自己参照マクロ
@cindex self-reference

@dfn {self-referential}マクロはその名前がその定義に現れるものである。 すべてのマクロ定義が、より多くのマクロを置き換えるために再スキャンされることを思い出すこと。 自己参照がマクロの使用と見なされた場合、マクロ参照は無限に展開される。 これを防ぐために、自己参照はマクロ呼び出しと見なされない。 プリプロセッサの出力にそのまま渡される。 例を考える：

@smallexample
#define foo (4 + foo)
@end smallexample

@noindent
ここで@code{foo}はプログラム内の変数でもある。

通常の規則に従って、@code{foo}への各参照は@code {(4 + foo)}に展開される。 これは再スキャンされ、@code{(4 +(4 + foo))}に展開される。 コンピュータがメモリ不足になるまで続く。

自己参照ルールは、このプロセスを@code {(4 + foo)}で1ステップ後に短縮する。 したがって、このマクロ定義は、@code{foo}が参照されているところで、プログラムに4を@code{foo}の値に追加させる有用な効果がある。

ほとんどの場合、この機能を利用することは悪い考えである。 @code{foo}が変数であると見なすプログラムを読んでいる人は、マクロであるとは思わないだろう。 読者はプログラム中の識別子@code{foo}を見つけ、その値は変数@code{foo}の値であるべきだと思うが、実際には値は4大きい。

自己参照の一般的で有用な使用法の1つは、マクロ自身を展開するマクロを作成することである。このように書くならば

@smallexample
#define EPERM EPERM
@end smallexample

@noindent
マクロ@code{EPERM}は@code{EPERM}に展開される。 効果的には、実行中のテキストで使用されるときはいつでもプリプロセッサによって単独で残される。 それは@samp{#ifdef}ができるマクロであると言うことができる。 数値定数を@code{enum}で定義したいが、@samp{#ifdef}を各定数に対して真にしたい場合は、これを行うかもしれない。

マクロ@code{x}がマクロ@code{y}を使用するように展開し、@code{y}の展開がマクロ@code{x}を参照する場合、それは@code{x}の@dfn{間接自己参照}である。 この場合でも@code {x}は展開されない。 したがって、もし我々が

@smallexample
#define x (4 + y)
#define y (2 * x)
@end smallexample

@noindent
と書くならば、@code{x}と@code{y}は以下のように展開される。

@smallexample
@group
x    @expansion{} (4 + y)
     @expansion{} (4 + (2 * x))

y    @expansion{} (2 * x)
     @expansion{} (2 * (4 + y))
@end group
@end smallexample

@noindent
各マクロは、他のマクロの定義に現れたときに展開されるが、それ自身の定義に間接的に現れるときは展開されない。

@node Argument Prescan
@subsection 引数の前スキャン
@cindex expansion of arguments
@cindex macro argument expansion
@cindex prescan of macro arguments

マクロ引数は、マクロボディに代入される前に完全にマクロ展開されるが、他のトークンで文字列化されたり貼り付けられたりしている場合を除く。 置換後、置換された引数を含むマクロ本体全体が再度走査され、マクロが展開される。 その結果、引数はマクロ呼び出しを展開するために@emph{二度}スキャンされる。

ほとんどの場合、これは効果がない。 引数にマクロ呼び出しが含まれている場合、引数は最初のスキャン時に展開される。 したがって、結果にはマクロ呼び出しが含まれないため、2回目のスキャンではマクロ呼び出しは変更されない。 引数が前スキャンなしで与えられたように置換された場合、残りの1回のスキャンで同じマクロ呼び出しが検出され、同じ結果が得られる。

他のマクロの引数に自己参照マクロ（@pxref {Self-Referential Macros}）を使用すると、二重スキャンで結果が変わることが予想されるかもしれない。自己参照マクロは最初のスキャンで一度展開され、 2回目のスキャンでは2回目である。 しかし、これは起こることではない。 最初のスキャンで展開されない自己参照は、2番目のスキャンでも展開されないようにマークされる。

「もし違いがないならば、なぜ前スキャンについて述べるのか？それをスキップしてプリプロセッサを速くしないのはなぜか？」と考えるかもしれない。 答えは、前スキャンが3つの特殊なケースで違いを生むことである。

@itemize @bullet
@item
マクロへの入れ子の呼び出し。

@dfn{入れ子の}マクロの呼び出しは、マクロの引数にそのマクロへの呼び出しが含まれている場合に発生する。 たとえば、@code{f}が1つの引数を必要とするマクロである場合、@code{f(f(1))}は@code{f}への呼び出しのネストされたペアである。 望ましい展開は、@code{f(1)}を展開し、それを@code{f}の定義に置き換えることによって行われる。前スキャンによって予想される結果を生じる。 前スキャンがなければ、@code{f(1)}自体が引数として代入され、@code{f}の内部使用は間接的な自己参照としてメインスキャン中に現れ、展開されない。

@item
文字列化または連結する他のマクロを呼び出すマクロ。

引数が文字列化または連結されている場合、前スキャンは発生しない。 @emph{マクロ}を展開し、そのマクロ展開を文字列化または連結したい場合は、あるマクロが文字列化または連結を行う別のマクロを呼び出すようにする。 たとえば、もし

@smallexample
#define AFTERX(x) X_ ## x
#define XAFTERX(x) AFTERX(x)
#define TABLESIZE 1024
#define BUFSIZE TABLESIZE
@end smallexample

ならば、@code{AFTERX(BUFSIZE)}は@code{X_BUFSIZE}へと展開され、@code{XAFTERX(BUFSIZE)}は@code{X_1024}へと展開される。 (@code{X_TABLESIZE}へは展開されない。前スキャンは常に完全な展開を行う。）

@item
引数に使用されるマクロで、その拡張には守られていないコンマが含まれる。

これにより、2番目のスキャンで展開されたマクロが間違った数の引数で呼び出される可能性がある。 次に例を示す。

@smallexample
#define foo  a,b
#define bar(x) lose(x)
#define lose(x) (1 + (x))
@end smallexample

@code{bar(foo)}を@code{(1 +(foo))}に変えて、@code{(1+(a,b))}に変えたいだろう。 代わりに@code{bar(foo)}は@code{lose(a,b)}に展開され、@code{lose}には1つの引数が必要なのでエラーが発生する。 この場合、問題は、算術演算の誤ったネスティングを防ぐために使用されるべきである同じカッコで簡単に解決される。

@smallexample
#define foo (a,b)
@exdent or
#define bar(x) lose((x))
@end smallexample

余分な括弧の組は、@code {foo}の定義中のコンマが引数の区切りとして解釈されないようにする。

@end itemize

@node Newlines in Arguments
@subsection 引数での改行
@cindex newlines in macro arguments

関数に似たマクロの呼び出しは、多くの論理行にまたがる可能性がある。 しかし、現在の実装では、展開全体が1行になる。 したがって、コンパイラーまたはデバッガーによって発行される行番号は、呼び出しを開始した行を参照する。これは、問題の原因となっている引き数を含む行とは異なる場合がある。

これを説明する例を次に示す。

@smallexample
#define ignore_second_arg(a,b,c) a; c

ignore_second_arg (foo (),
                   ignored (),
                   syntax error);
@end smallexample

@noindent
トークン@code{syntax error}によって引き起こされた構文エラーは、問題のコードが5行目から来ていても、3行--- ignore_second_argの行---を引用するエラーメッセージになる。

私たちはこれをバグとみなし、近い将来に修正しようとしている。

@node Conditionals
@chapter 条件
@cindex conditionals

@dfn{条件}は、プリプロセッサに、コンパイラに渡される最後のトークンストリームにコードの塊を含めるかどうかを選択するよう指示する指令である。 プリプロセッサ条件は、算術式、名前がマクロとして定義されているか、特別な@code{defined}演算子を使って同時に両方をテストすることができる。

Cプリプロセッサの条件式は、Cの@code {if}文といくつかの点で似ているが、その違いを理解することが重要である。 @code{if}文の条件は、プログラムの実行中にテストされる。 その目的は、動作中のデータに応じて、実行の度に動作が異なるようにすることである。プリプロセス条件付きディレクティブの条件は、プログラムのコンパイル時にテストされる。 その目的は、コンパイル時の状況に応じて異なるコードをプログラムに含めることである。

しかしながら、その区別はあまり明確ではない。 現代のコンパイラは、プログラムがコンパイルされたとき、条件が実行時に変化しないことがわかっているときに@code{if}文をテストし、決して実行できないコードを排除することがよくある。 あなたがこれを行うためにあなたのコンパイラを頼りにすることができるなら、（マクロによって決まる）一定の条件で@code{if}文を使うと、あなたのプログラムは読みやすくなる。 もちろん、型定義やその他のプリプロセスディレクティブではなく、コードを除外するためにのみ使用することができる。コードが使用されないときに構文的に有効なままであれば、これを実行できる。

@menu
* Conditional Uses::
* Conditional Syntax::
* Deleted Code::
@end menu

@node Conditional Uses
@section 条件の使用

条件を使用する一般的な理由は3つある。

@itemize @bullet
@item
実行するマシンまたはオペレーティングシステムに応じて、プログラムが異なるコードを使用する必要がある。 場合によっては、あるオペレーティングシステムのコードが別のオペレーティングシステムで誤っている可能性がある。 たとえば、他のシステム上に存在しないデータ型や定数を参照している可能性がある。 この場合、無効なコードの実行を避けるだけでは十分ではない。 その存在は、コンパイラにプログラムを拒否させる原因になる。プリプロセス条件では、有効でないときに問題のコードを効果的にプログラムから切り出すことができる。

@item
同じソースファイルを2つの異なるプログラムにコンパイルすることができる。片方のバージョンでは、時間のかかる中間データの整合性チェックを行い、デバッグのためにそれらのデータの値を表示させ、もう片方はしないかもしれない。

@item
条件が常に偽である条件は、プログラムからコードを除外するが、将来の参照用にコメントの一種として保持するための1つの方法である。
@end itemize

システム固有のロジックや複雑なデバッグフックを必要としない単純なプログラムでは、一般にプリプロセス条件を使用する必要はない。

@node Conditional Syntax
@section 条件の構文

@findex #if
Cプリプロセッサの条件式は@dfn {条件付き命令}で始まる： @samp{#if}, @samp{#ifdef}及び@samp{#ifndef}。

@menu
* Ifdef::
* If::
* Defined::
* Else::
* Elif::
@end menu

@node Ifdef
@subsection Ifdef
@findex #ifdef
@findex #endif

条件の最も簡単な種類は

@smallexample
@group
#ifdef @var{MACRO}

@var{controlled text}

#endif /* @var{MACRO} */
@end group
@end smallexample

@cindex conditional group
このブロックは@dfn{条件付きグループ}と呼ばれる。 @var{controlled text}は、@ var{MACRO}が定義されている場合にのみプリプロセッサの出力にインクルードされる。 @var{MACRO}が定義されていれば条件付きの@dfn{成功}、そうでなければ@dfn{失敗}と言うことにする。

条件文の中の@var{controlled text}は、プリプロセス指令を含むことができる。 条件で成功した場合にのみ実行される。 条件付きグループを他の条件付きグループ内にネストすることはできるが、完全にネストする必要がある。 言い換えると、@samp{#endif}は常に最も近い@samp{#ifdef}（または@samp{#ifndef}または@samp{#if}）と一致する。 また、条件付きグループをあるファイルで開始し、別のファイルで終了することはできない。

条件が満たされなくても、内部の@var{controlled text}は初期の変換とトークン化によって実行される。 したがって、すべてが字句的に有効なCでなければならない。 これが問題となる唯一の方法は、通常、失敗する条件付きグループ内のすべてのコメントと文字列リテラルを適切に終了する必要があることである。

@samp{#endif}に続くコメントは必須ではないが、多くの@var{controlled text}がある場合は、@samp{#endif}を対応する@samp{#ifdef}に一致させるために役立つ。古いプログラムでは@samp{#endif}の直後に@var{MACRO}を置くことがある。 これはC標準に準拠しない無効なコードである。 CPPはそれを警告で受け付ける。 それは@samp{#endif}が一致する@samp{#ifndef}には決して影響しない。

@findex #ifndef
時には、マクロが定義されて@emph{いない}ならば、いくつかのコードを使いたいと思うことがある。 @samp{#ifdef}の代わりに@samp{#ifndef}を書くことでこれを行うことができる。 @samp{#ifndef}の一般的な使い方は、ヘッダファイルが最初にインクルードされたときだけコードをインクルードすることである。 @xref{Once-Only Headers}。

マクロ定義は、いくつかの理由でコンパイルごとに異なる場合がある。 ここにいくつかのサンプルがある。

@itemize @bullet
@item
いくつかのマクロは、各種類のマシン（@pxref{System-specific Predefined Macros}）であらかじめ定義されている。 これにより、特定のマシンに対して特別にチューニングされたコードを提供することができる。

@item
システムヘッダファイルは、実装する機能に関連付けられた、より多くのマクロを定義する。 これらのマクロを条件付きでテストして、実装されていないマシンでシステム機能を使用しないようにすることができる。

@item
マクロを定義するには、プログラムをコンパイルするときに@option{-D}と@option{-U}コマンドラインオプションを使用する。 同じソースファイルを2つの異なるプログラムにコンパイルするには、マクロ名を選択してどのプログラムを指定するか、このマクロが定義されているかどうかをテストするための条件文を作成し、コマンドラインオプションを使用してマクロの状態を制御し、おそらくMakefileに設定されている。@xref{Invocation}。

@item
あなたのプログラムには、プログラムのコンパイル時に調整される特別なヘッダファイル（しばしば@file{config.h}と呼ばれる）があるかもしれない。 システムの機能とプログラムの望ましい機能に応じて、マクロを定義したり、定義しなかったりすることができる。 調整は、@command{autoconf}のようなツールで自動化することも、手動で行うこともできる。
@end itemize

@node If
@subsection If

@samp {#if}ディレクティブを使うと、単純に1つのマクロの存在ではなく、算術式の値をテストできる。 構文は次のとおりである。

@smallexample
@group
#if @var{expression}

@var{controlled text}

#endif /* @var{expression} */
@end group
@end smallexample

@var{expression}は整数型のC式であり、厳格な制限がある。 それは以下を含んで良い。

@itemize @bullet
@item
整数定数。

@item
通常のコードで解釈される文字定数

@item
加算、減算、乗算、除算、ビット操作、シフト、比較と論理操作(@code{&&}と@code{||})の演算子。最後の2つは通常の標準Cの短絡規則に従う。

@item
マクロ。 式のすべてのマクロは、式の値が実際に計算される前に展開される。

@item
マクロが@samp{#if}の真ん中に定義されているかどうかをチェックできる@code{defined}演算子の使用。

@item
マクロではない識別子。すべてがゼロであるとみなされる。 これにより、定義されているMACROが常にゼロ以外の値を持つことがわかっている場合、@code{@w{#ifdef MACRO}}ではなく@code{@w{#if MACRO}}と書くことができる。 関数呼び出しのかっこなしで使用される関数のようなマクロもゼロとして扱われる。

状況によっては、このショートカットは望ましくない。 @option{-Wundef}オプションは、@samp{#if}のマクロではない識別子に遭遇するたびにGCCに警告を出させる。
@end itemize

プリプロセッサは言語の型について何も知らない。 したがって、@code{sizeof}演算子は@samp{#if}で認識されず、どちらも@code{enum}定数もそうである。 それらはマクロではなく、ゼロで置き換えられた識別子として扱われる。 @code{sizeof}の場合、これは式が無効になる可能性がある。

プリプロセッサは@var{expression}の値を計算する。 コンパイラに知られている最も広い整数型のすべての計算を実行する。 GCCでサポートされているほとんどのマシンでは64ビットである。 これは、定数式の値を計算するためにコンパイラが使用するのと同じルールではなく、結果が異なる場合がある。 値がゼロ以外になると、@samp{#if}は成功し、@var{controlled text}が含まれる。 それ以外の場合はスキップされる。

@node Defined
@subsection Defined

@cindex @code{defined}
特定の名前がマクロとして定義されているかどうかをテストするために、@code{defined}という特別な演算子が@samp{#if}と@samp{#elif}の式で使用されている。 @var{name}がプログラムの現在の点でマクロとして定義されている場合、@code{defined @var{name}}と@code {defined(@var{name})}はどちらも値が1の式であり、そうでなければ0である。 したがって、@code{@w{#if defined MACRO}}は@code{@w{#ifdef MACRO}}とまったく同じである。

一度に複数のマクロをテストしたいときに便利である。 例えば、

@smallexample
#if defined (__vax__) || defined (__ns16000__)
@end smallexample

@noindent
は@code{__ vax__}または@code{__ ns16000__}のいずれかの名前がマクロとして定義されていると成功する。

このように書かれた条件式：

@smallexample
#if defined BUFSIZE && BUFSIZE >= 1024
@end smallexample

@noindent
は@code{BUFSIZE> = 1024}に単純化することができる。なぜなら、@code{BUFSIZE}が定義されていないと、値がゼロであると解釈されるからである。

マクロ展開の結果として@code{defined}演算子が現れた場合、Cの標準では動作は未定義であると言う。 GNU cppはそれを本物の@code{defined}演算子として扱い、通常の評価をする。 コマンドラインオプション@option{-Wpedantic}を使用する場合は、他のコンパイラがこれを別々に処理する可能性があるため、コードがこの機能を使用する場所を警告する。 警告は@option{-Wextra}によっても有効になり、@option{-Wexpansion-to-defined}で個別に有効にすることもできる。

@node Else
@subsection Else

@findex #else
@samp{#else}疑似命令は、条件に失敗した場合に使用される代替テキストを提供するために条件に追加することができる。 これは次のようになる。

@smallexample
@group
#if @var{expression}
@var{text-if-true}
#else /* Not @var{expression} */
@var{text-if-false}
#endif /* Not @var{expression} */
@end group
@end smallexample

@noindent
@var{expression}が0でない場合、@var{text-if-true}がインクルードされ、@var{text-if-false}はスキップされる。 @var{expression}が0の場合、逆のことが起こる。

@samp{#else}は@samp{#ifdef}と@samp{#ifndef}でも使用することができる。

@node Elif
@subsection Elif

@findex #elif
ネストされた条件文の1つの一般的なケースは、2つ以上の可能な選択肢をチェックするために使用される。 たとえば、

@smallexample
#if X == 1
@dots{}
#else /* X != 1 */
#if X == 2
@dots{}
#else /* X != 2 */
@dots{}
#endif /* X != 2 */
#endif /* X != 1 */
@end smallexample

別の条件付きディレクティブ@samp{#elif}では、これを以下のように省略することができる。

@smallexample
#if X == 1
@dots{}
#elif X == 2
@dots{}
#else /* X != 2 and X != 1*/
@dots{}
#endif /* X != 2 and X != 1*/
@end smallexample

@samp{#elif}は「else if」'の略である。 @samp{#else}と同様に、条件付きグループの途中で細分化される。 独自の@samp{#endif}は必要ない。 @samp{#if}と同様に、@samp{#elif}ディレクティブにはテスト対象の式が含まれている。 @samp{#elif}に続くテキストは、元の@samp{#if}条件が失敗し、@samp{#elif}条件が成功した場合にのみ処理される。

複数の@samp{#elif}を同じ条件グループに入れることができる。 @samp{#elif}の後のテキストは、元の@samp{#if}とそれ以前のすべての@samp{#elif}ディレクティブが失敗した後に@samp{#elif}条件が成功した場合にのみ処理される。

@samp{#else}は任意の数の@samp{#elif}ディレクティブの後で使用できるが、@samp{#elif}は@samp{#else}の後に来てはならない。

@node Deleted Code
@section 削除されたコード
@cindex commenting out code

プログラムの一部を置き換えたり削除したりして、後で参照できるように古いコードを保存したい場合は、単にコメントアウトすることはできない。 ブロックコメントは入れ子にならないので、古いコードの最初のコメントはコメントアウトを終了する。 考えられる結果は、構文エラーの氾濫である。

この問題を回避する1つの方法は、常に偽の条件を代わりに使用することである。 たとえば、削除されたコードの前に@code{#if 0}を置き、その後に@code{#endif}を置く。 これは、オフになっているコードに条件文が含まれていても機能するが、それらが条件文全体でなければならない。（@samp{#if}と@samp{#endif}でバランスが取れている）

代わりに@code{#ifdef notdef}を使用する人もいる。 @code{notdef}が誤ってマクロとして定義されている可能性があり、条件付きで成功する可能性があるため、これは危険である。 @code{#if 0}は失敗したとみなすことができる。

Cコードではないコメントに@code {#if 0}を使用してはならない。 代わりに実際のコメントを使用すること。 @code{#if 0}の内部は、完全なトークンで構成されていなければならない。 特に、一重引用符はバランスをとる必要がある。 コメントにはアンバランスな一重引用符（英語ではアポストロフィとして知られている）が含まれていることがよくある。 これらは@code{#if 0}を混乱させる。 @samp{/*}は混乱しない。

@node Diagnostics
@chapter 診断
@cindex diagnostic
@cindex reporting errors
@cindex reporting warnings

@findex #error
@samp{#error}命令は、プリプロセッサに致命的エラーを報告させる。 @samp{#error}に続く行の残りの部分を形成するトークンは、エラーメッセージとして使用される。

プログラムが正しくサポートしていないことを知っているパラメータの組み合わせを検出する条件の中で@samp{#error}を使用する。 たとえば、プログラムがVAX上で正しく実行されないことがわかっている場合は、

@smallexample
@group
#ifdef __vax__
#error "Won't work on VAXen.  See comments at get_last_object."
#endif
@end group
@end smallexample

一貫性のある方法でインストールで設定する必要のあるいくつかの設定パラメータがある場合は、条件を使用して矛盾を検出し、@samp{#error}で報告できる。 例えば、

@smallexample
#if !defined(FOO) && defined(BAR)
#error "BAR requires FOO."
#endif
@end smallexample

@findex #warning
@samp{#warning}命令は@samp{#error}に似ているが、プリプロセッサに警告を出して前処理を続行させる。 @samp{#warning}に続くトークンは、警告メッセージとして使用される。

廃止されたヘッダファイルで@samp{#warning}を使用し、その代わりに使用されるヘッダファイルにユーザを誘導するメッセージを表示することができる。

@samp{#error}も@samp{#warning}も引数をマクロ展開しない。 内部空白シーケンスはそれぞれ1つのスペースに置き換えられる。 行は完全なトークンで構成されていなければならない。 これらのディレクティブの引数を単一の文字列定数にすることが最も賢明である。 これにより、アポストロフィなどの問題が回避される。

@node Line Control
@chapter 行制御
@cindex line control

Cプリプロセッサは、各トークンがどこから来たかをソースコード内の場所をCコンパイラに通知する。 現在のところ、これはファイル名と行番号である。 マクロ展開の結果として得られるすべてのトークンは、最も外側のマクロが使用されたソースファイルの行に現れたと報告される。 私たちは将来、より正確になるつもりである。

@command{bison}パーサジェネレータのようなソースコードを生成するプログラムを書く場合、プリプロセッサの現在のファイル名と行番号の概念を手動で調整することができる。 @command{bison}の出力の一部は最初から生成され、他の部分は標準パーサーファイルから生成される。 残りは@command{bison}の入力からそのままコピーされる。 コンパイラエラーメッセージとシンボリックデバッガが@code{bison}の入力ファイルを参照できるようにしたいとする。

@findex #line
@command{bison}やそのようなプログラムは、@samp{#line}指示文を出力ファイルに書き込むことでこれを手配できる。 @samp{#line}は、現在のプリプロセッサ入力ファイルの後続入力の元の行番号とソースファイル名を指定する指令である。 @samp{#line}には3つのバリエーションがある：

@table @code
@item #line @var{linenum}
@var{linenum}は、負でない10進整数定数である。これは、次の入力行について報告される行番号を指定する。 後続の行は、@var{linenum}から数えられる。

@item #line @var{linenum} @var{filename}
@var{linenum}は最初の形式と同じで、同じ効果がある。 さらに、@var{filename}は文字列定数である。 次の行とそれに続くすべての行は、別の行がそれを変更するまで、指定されたファイルから来たと報告される。 @var{filename}は、文字列定数の通常の規則に従って解釈される。バックスラッシュエスケープが解釈される。 これは@samp{#include}とは異なる。

@item #line @var{anything else}
@var {anything else}は展開されたマクロ呼び出しをチェックする。 結果は、上記の2つの形式のいずれかと一致する必要がある。
@end table

@samp{#line}ディレクティブは、あらかじめ定義された@code{__FILE__}マクロと@code{__LINE__}マクロの結果を変更する。@xref{Standard Predefined Macros}。 @samp{#include}の現在のファイルを含むディレクトリの考え方には何の影響もない。

@node Pragmas
@chapter プラグマ

@samp{#pragma}ディレクティブは、言語自体で伝えられるものを超えて、コンパイラに追加情報を提供するためのC標準で指定された方法である。 C標準で指定されているこのディレクティブの形式（一般に@dfn{プラグマ}と呼ばれる）には@code {STDC}という接頭辞が付く。 Cコンパイラは、好きな意味を他のプラグマに自由に付けることができる。 すべてのGNU定義のサポートされているプラグマには@code{GCC}という接頭辞が付いている。

@cindex @code{_Pragma}
C99は@code{@w{_Pragma}}演算子を導入した。 この機能は、@samp{#pragma}の大きな問題に対処する。ディレクティブなので、マクロ展開の結果として生成することはできない。 @code{@w{_Pragma}}は、@ code{sizeof}や@code{defined}とよく似た演算子で、マクロに埋め込むことができる。

構文は@code{@w{_Pragma(@var{string-literal})}}である。@var{string-literal}は通常の文字列リテラルまたはワイド文字の文字列リテラルのどちらでもよい。 すべての@samp{\\}を単一の@samp{\}と置き換え、すべての@samp{\"}を@samp{"}に置き換えることによって、それは非文字列化される。 結果は@samp{#pragma}ディレクティブの右側に現れたかのように処理される。例えば、

@smallexample
_Pragma ("GCC dependency \"parse.y\"")
@end smallexample

@noindent
は@code{#pragma GCC dependency "parse.y"}と同じ効果がある。 マクロを使用して同じ効果を達成することもできる。

@smallexample
#define DO_PRAGMA(x) _Pragma (#x)
DO_PRAGMA (GCC dependency "parse.y")
@end smallexample

標準では、@code{_Pragma}演算子がどこに現れるかは不明である。 プリプロセッサは@samp{#if}のような前処理条件ディレクティブ内でプリプロセッサを受け付けない。 安全のためには、おそらく@samp{#define}以外のディレクティブを避けて、それを独自の行に置くのが最良である。

このマニュアルでは、プリプロセッサそのものに意味のあるプラグマについて説明する。 他のプラグマは、CまたはC++コンパイラとって意味がある。 それらはGCCマニュアルに記載されている。

GCCプラグインは独自のプラグマを提供することがある。

@ftable @code
@item #pragma GCC dependency
@code{#pragma GCC dependency}では、現在のファイルと別のファイルの相対日付を調べることができる。 他のファイルが現在のファイルより新しい場合、警告が発行される。 これは、現在のファイルが他のファイルから派生し、再生成する必要がある場合に便利である。 他のファイルは、通常のインクルード検索パスを使用して検索される。 オプションの末尾のテキストを使用して、警告メッセージの詳細を指定できる。

@smallexample
#pragma GCC dependency "parse.y"
#pragma GCC dependency "/usr/include/time.h" rerun fixincludes
@end smallexample

@item #pragma GCC poison
場合によっては、あなたのプログラムから完全に削除したい識別子がある。これを強制するために、このプラグマで識別子を@dfn{有害化}することができる。 @code{#pragma GCC poison}の後には、毒の識別子のリストが続く。 これらの識別子のいずれかがディレクティブの後にソースのどこに現れても、それはハードエラーである。 例えば、

@smallexample
#pragma GCC poison printf sprintf fprintf
sprintf(some_string, "hello");
@end smallexample

@noindent
はエラーを発する。

有害化された識別子が、識別子が有害化される前に定義されたマクロの展開の一部として表示される場合、エラーは発生し@emph{ない}。 これにより、識別子を使用するマクロを定義しているシステムヘッダについて心配することなく、識別子に害を与えることができる。

例えば

@smallexample
#define strrchr rindex
#pragma GCC poison rindex
strrchr(some_string, 'h');
@end smallexample

@noindent
はエラーを発しない。

@item #pragma GCC system_header
このプラグマは引数をとらない。 現在のファイルの残りのコードは、あたかもシステムヘッダから来たものとして扱われる。
@xref{System Headers}.

@item #pragma GCC warning
@itemx #pragma GCC error
@code{#pragma GCC warning "message"}は、プリプロセッサに@samp{message}というテキストで警告診断を発行させる。 プラグマに含まれるメッセージは、単一の文字列リテラルでなければならない。 同様に、@code{#pragma GCC error "message"}はエラーメッセージを出す。 @samp{#warning}および@samp{#error}ディレクティブとは異なり、これらのプラグマは@samp{_Pragma}を使用してプリプロセッサマクロに埋め込むことができる。

@end ftable

@node Other Directives
@chapter Other Directives

@findex #ident
@findex #sccs
The @samp{#ident} directive takes one argument, a string constant.  On
some systems, that string constant is copied into a special segment of
the object file.  On other systems, the directive is ignored.  The
@samp{#sccs} directive is a synonym for @samp{#ident}.

These directives are not part of the C standard, but they are not
official GNU extensions either.  What historical information we have
been able to find, suggests they originated with System V@.

@cindex null directive
The @dfn{null directive} consists of a @samp{#} followed by a newline,
with only whitespace (including comments) in between.  A null directive
is understood as a preprocessing directive but has no effect on the
preprocessor output.  The primary significance of the existence of the
null directive is that an input line consisting of just a @samp{#} will
produce no output, rather than a line of output containing just a
@samp{#}.  Supposedly some old C programs contain such lines.

@node Preprocessor Output
@chapter Preprocessor Output

When the C preprocessor is used with the C, C++, or Objective-C
compilers, it is integrated into the compiler and communicates a stream
of binary tokens directly to the compiler's parser.  However, it can
also be used in the more conventional standalone mode, where it produces
textual output.
@c FIXME: Document the library interface.

@cindex output format
The output from the C preprocessor looks much like the input, except
that all preprocessing directive lines have been replaced with blank
lines and all comments with spaces.  Long runs of blank lines are
discarded.

The ISO standard specifies that it is implementation defined whether a
preprocessor preserves whitespace between tokens, or replaces it with
e.g.@: a single space.  In GNU CPP, whitespace between tokens is collapsed
to become a single space, with the exception that the first token on a
non-directive line is preceded with sufficient spaces that it appears in
the same column in the preprocessed output that it appeared in the
original source file.  This is so the output is easy to read.
CPP does not insert any
whitespace where there was none in the original source, except where
necessary to prevent an accidental token paste.

@cindex linemarkers
Source file name and line number information is conveyed by lines
of the form

@smallexample
# @var{linenum} @var{filename} @var{flags}
@end smallexample

@noindent
These are called @dfn{linemarkers}.  They are inserted as needed into
the output (but never within a string or character constant).  They mean
that the following line originated in file @var{filename} at line
@var{linenum}.  @var{filename} will never contain any non-printing
characters; they are replaced with octal escape sequences.

After the file name comes zero or more flags, which are @samp{1},
@samp{2}, @samp{3}, or @samp{4}.  If there are multiple flags, spaces
separate them.  Here is what the flags mean:

@table @samp
@item 1
This indicates the start of a new file.
@item 2
This indicates returning to a file (after having included another file).
@item 3
This indicates that the following text comes from a system header file,
so certain warnings should be suppressed.
@item 4
This indicates that the following text should be treated as being
wrapped in an implicit @code{extern "C"} block.
@c maybe cross reference NO_IMPLICIT_EXTERN_C
@end table

As an extension, the preprocessor accepts linemarkers in non-assembler
input files.  They are treated like the corresponding @samp{#line}
directive, (@pxref{Line Control}), except that trailing flags are
permitted, and are interpreted with the meanings described above.  If
multiple flags are given, they must be in ascending order.

Some directives may be duplicated in the output of the preprocessor.
These are @samp{#ident} (always), @samp{#pragma} (only if the
preprocessor does not handle the pragma itself), and @samp{#define} and
@samp{#undef} (with certain debugging options).  If this happens, the
@samp{#} of the directive will always be in the first column, and there
will be no space between the @samp{#} and the directive name.  If macro
expansion happens to generate tokens which might be mistaken for a
duplicated directive, a space will be inserted between the @samp{#} and
the directive name.

@node Traditional Mode
@chapter Traditional Mode

Traditional (pre-standard) C preprocessing is rather different from
the preprocessing specified by the standard.  When the preprocessor 
is invoked with the 
@option{-traditional-cpp} option, it attempts to emulate a traditional
preprocessor.  

This mode is not useful for compiling C code with GCC, 
but is intended for use with non-C preprocessing applications.  Thus
traditional mode semantics are supported only when invoking
the preprocessor explicitly, and not in the compiler front ends.

The implementation does not correspond precisely to the behavior of
early pre-standard versions of GCC, nor to any true traditional preprocessor.
After all, inconsistencies among traditional implementations were a
major motivation for C standardization.  However, we intend that it
should be compatible with true traditional preprocessors in all ways
that actually matter.

@menu
* Traditional lexical analysis::
* Traditional macros::
* Traditional miscellany::
* Traditional warnings::
@end menu

@node Traditional lexical analysis
@section Traditional lexical analysis

The traditional preprocessor does not decompose its input into tokens
the same way a standards-conforming preprocessor does.  The input is
simply treated as a stream of text with minimal internal form.

This implementation does not treat trigraphs (@pxref{trigraphs})
specially since they were an invention of the standards committee.  It
handles arbitrarily-positioned escaped newlines properly and splices
the lines as you would expect; many traditional preprocessors did not
do this.

The form of horizontal whitespace in the input file is preserved in
the output.  In particular, hard tabs remain hard tabs.  This can be
useful if, for example, you are preprocessing a Makefile.

Traditional CPP only recognizes C-style block comments, and treats the
@samp{/*} sequence as introducing a comment only if it lies outside
quoted text.  Quoted text is introduced by the usual single and double
quotes, and also by an initial @samp{<} in a @code{#include}
directive.

Traditionally, comments are completely removed and are not replaced
with a space.  Since a traditional compiler does its own tokenization
of the output of the preprocessor, this means that comments can
effectively be used as token paste operators.  However, comments
behave like separators for text handled by the preprocessor itself,
since it doesn't re-lex its input.  For example, in

@smallexample
#if foo/**/bar
@end smallexample

@noindent
@samp{foo} and @samp{bar} are distinct identifiers and expanded
separately if they happen to be macros.  In other words, this
directive is equivalent to

@smallexample
#if foo bar
@end smallexample

@noindent
rather than

@smallexample
#if foobar
@end smallexample

Generally speaking, in traditional mode an opening quote need not have
a matching closing quote.  In particular, a macro may be defined with
replacement text that contains an unmatched quote.  Of course, if you
attempt to compile preprocessed output containing an unmatched quote
you will get a syntax error.

However, all preprocessing directives other than @code{#define}
require matching quotes.  For example:

@smallexample
#define m This macro's fine and has an unmatched quote
"/* This is not a comment.  */
/* @r{This is a comment.  The following #include directive
   is ill-formed.}  */
#include <stdio.h
@end smallexample

Just as for the ISO preprocessor, what would be a closing quote can be
escaped with a backslash to prevent the quoted text from closing.

@node Traditional macros
@section Traditional macros

The major difference between traditional and ISO macros is that the
former expand to text rather than to a token sequence.  CPP removes
all leading and trailing horizontal whitespace from a macro's
replacement text before storing it, but preserves the form of internal
whitespace.

One consequence is that it is legitimate for the replacement text to
contain an unmatched quote (@pxref{Traditional lexical analysis}).  An
unclosed string or character constant continues into the text
following the macro call.  Similarly, the text at the end of a macro's
expansion can run together with the text after the macro invocation to
produce a single token.

Normally comments are removed from the replacement text after the
macro is expanded, but if the @option{-CC} option is passed on the
command-line comments are preserved.  (In fact, the current
implementation removes comments even before saving the macro
replacement text, but it careful to do it in such a way that the
observed effect is identical even in the function-like macro case.)

The ISO stringizing operator @samp{#} and token paste operator
@samp{##} have no special meaning.  As explained later, an effect
similar to these operators can be obtained in a different way.  Macro
names that are embedded in quotes, either from the main file or after
macro replacement, do not expand.

CPP replaces an unquoted object-like macro name with its replacement
text, and then rescans it for further macros to replace.  Unlike
standard macro expansion, traditional macro expansion has no provision
to prevent recursion.  If an object-like macro appears unquoted in its
replacement text, it will be replaced again during the rescan pass,
and so on @emph{ad infinitum}.  GCC detects when it is expanding
recursive macros, emits an error message, and continues after the
offending macro invocation.

@smallexample
#define PLUS +
#define INC(x) PLUS+x
INC(foo);
     @expansion{} ++foo;
@end smallexample

Function-like macros are similar in form but quite different in
behavior to their ISO counterparts.  Their arguments are contained
within parentheses, are comma-separated, and can cross physical lines.
Commas within nested parentheses are not treated as argument
separators.  Similarly, a quote in an argument cannot be left
unclosed; a following comma or parenthesis that comes before the
closing quote is treated like any other character.  There is no
facility for handling variadic macros.

This implementation removes all comments from macro arguments, unless
the @option{-C} option is given.  The form of all other horizontal
whitespace in arguments is preserved, including leading and trailing
whitespace.  In particular

@smallexample
f( )
@end smallexample

@noindent
is treated as an invocation of the macro @samp{f} with a single
argument consisting of a single space.  If you want to invoke a
function-like macro that takes no arguments, you must not leave any
whitespace between the parentheses.

If a macro argument crosses a new line, the new line is replaced with
a space when forming the argument.  If the previous line contained an
unterminated quote, the following line inherits the quoted state.

Traditional preprocessors replace parameters in the replacement text
with their arguments regardless of whether the parameters are within
quotes or not.  This provides a way to stringize arguments.  For
example

@smallexample
#define str(x) "x"
str(/* @r{A comment} */some text )
     @expansion{} "some text "
@end smallexample

@noindent
Note that the comment is removed, but that the trailing space is
preserved.  Here is an example of using a comment to effect token
pasting.

@smallexample
#define suffix(x) foo_/**/x
suffix(bar)
     @expansion{} foo_bar
@end smallexample

@node Traditional miscellany
@section Traditional miscellany

Here are some things to be aware of when using the traditional
preprocessor.

@itemize @bullet
@item
Preprocessing directives are recognized only when their leading
@samp{#} appears in the first column.  There can be no whitespace
between the beginning of the line and the @samp{#}, but whitespace can
follow the @samp{#}.

@item
A true traditional C preprocessor does not recognize @samp{#error} or
@samp{#pragma}, and may not recognize @samp{#elif}.  CPP supports all
the directives in traditional mode that it supports in ISO mode,
including extensions, with the exception that the effects of
@samp{#pragma GCC poison} are undefined.

@item
__STDC__ is not defined.

@item
If you use digraphs the behavior is undefined.

@item
If a line that looks like a directive appears within macro arguments,
the behavior is undefined.

@end itemize

@node Traditional warnings
@section Traditional warnings
You can request warnings about features that did not exist, or worked
differently, in traditional C with the @option{-Wtraditional} option.
GCC does not warn about features of ISO C which you must use when you
are using a conforming compiler, such as the @samp{#} and @samp{##}
operators.

Presently @option{-Wtraditional} warns about:

@itemize @bullet
@item
Macro parameters that appear within string literals in the macro body.
In traditional C macro replacement takes place within string literals,
but does not in ISO C@.

@item
In traditional C, some preprocessor directives did not exist.
Traditional preprocessors would only consider a line to be a directive
if the @samp{#} appeared in column 1 on the line.  Therefore
@option{-Wtraditional} warns about directives that traditional C
understands but would ignore because the @samp{#} does not appear as the
first character on the line.  It also suggests you hide directives like
@samp{#pragma} not understood by traditional C by indenting them.  Some
traditional implementations would not recognize @samp{#elif}, so it
suggests avoiding it altogether.

@item
A function-like macro that appears without an argument list.  In some
traditional preprocessors this was an error.  In ISO C it merely means
that the macro is not expanded.

@item
The unary plus operator.  This did not exist in traditional C@.

@item
The @samp{U} and @samp{LL} integer constant suffixes, which were not
available in traditional C@.  (Traditional C does support the @samp{L}
suffix for simple long integer constants.)  You are not warned about
uses of these suffixes in macros defined in system headers.  For
instance, @code{UINT_MAX} may well be defined as @code{4294967295U}, but
you will not be warned if you use @code{UINT_MAX}.

You can usually avoid the warning, and the related warning about
constants which are so large that they are unsigned, by writing the
integer constant in question in hexadecimal, with no U suffix.  Take
care, though, because this gives the wrong result in exotic cases.
@end itemize

@node Implementation Details
@chapter Implementation Details

Here we document details of how the preprocessor's implementation
affects its user-visible behavior.  You should try to avoid undue
reliance on behavior described here, as it is possible that it will
change subtly in future implementations.

Also documented here are obsolete features still supported by CPP@.

@menu
* Implementation-defined behavior::
* Implementation limits::
* Obsolete Features::
@end menu

@node Implementation-defined behavior
@section Implementation-defined behavior
@cindex implementation-defined behavior

This is how CPP behaves in all the cases which the C standard
describes as @dfn{implementation-defined}.  This term means that the
implementation is free to do what it likes, but must document its choice
and stick to it.
@c FIXME: Check the C++ standard for more implementation-defined stuff.

@itemize @bullet
@need 1000
@item The mapping of physical source file multi-byte characters to the
execution character set.

The input character set can be specified using the
@option{-finput-charset} option, while the execution character set may
be controlled using the @option{-fexec-charset} and
@option{-fwide-exec-charset} options.

@item Identifier characters.
@anchor{Identifier characters}

The C and C++ standards allow identifiers to be composed of @samp{_}
and the alphanumeric characters.  C++ also allows universal character
names.  C99 and later C standards permit both universal character
names and implementation-defined characters.

GCC allows the @samp{$} character in identifiers as an extension for
most targets.  This is true regardless of the @option{std=} switch,
since this extension cannot conflict with standards-conforming
programs.  When preprocessing assembler, however, dollars are not
identifier characters by default.

Currently the targets that by default do not permit @samp{$} are AVR,
IP2K, MMIX, MIPS Irix 3, ARM aout, and PowerPC targets for the AIX
operating system.

You can override the default with @option{-fdollars-in-identifiers} or
@option{fno-dollars-in-identifiers}.  @xref{fdollars-in-identifiers}.

@item Non-empty sequences of whitespace characters.

In textual output, each whitespace sequence is collapsed to a single
space.  For aesthetic reasons, the first token on each non-directive
line of output is preceded with sufficient spaces that it appears in the
same column as it did in the original source file.

@item The numeric value of character constants in preprocessor expressions.

The preprocessor and compiler interpret character constants in the
same way; i.e.@: escape sequences such as @samp{\a} are given the
values they would have on the target machine.

The compiler evaluates a multi-character character constant a character
at a time, shifting the previous value left by the number of bits per
target character, and then or-ing in the bit-pattern of the new
character truncated to the width of a target character.  The final
bit-pattern is given type @code{int}, and is therefore signed,
regardless of whether single characters are signed or not.
If there are more
characters in the constant than would fit in the target @code{int} the
compiler issues a warning, and the excess leading characters are
ignored.

For example, @code{'ab'} for a target with an 8-bit @code{char} would be
interpreted as @w{@samp{(int) ((unsigned char) 'a' * 256 + (unsigned char)
'b')}}, and @code{'\234a'} as @w{@samp{(int) ((unsigned char) '\234' *
256 + (unsigned char) 'a')}}.

@item Source file inclusion.

For a discussion on how the preprocessor locates header files,
@ref{Include Operation}.

@item Interpretation of the filename resulting from a macro-expanded
@samp{#include} directive.

@xref{Computed Includes}.

@item Treatment of a @samp{#pragma} directive that after macro-expansion
results in a standard pragma.

No macro expansion occurs on any @samp{#pragma} directive line, so the
question does not arise.

Note that GCC does not yet implement any of the standard
pragmas.

@end itemize

@node Implementation limits
@section Implementation limits
@cindex implementation limits

CPP has a small number of internal limits.  This section lists the
limits which the C standard requires to be no lower than some minimum,
and all the others known.  It is intended that there should be as few limits
as possible.  If you encounter an undocumented or inconvenient limit,
please report that as a bug.  @xref{Bugs, , Reporting Bugs, gcc, Using
the GNU Compiler Collection (GCC)}.

Where we say something is limited @dfn{only by available memory}, that
means that internal data structures impose no intrinsic limit, and space
is allocated with @code{malloc} or equivalent.  The actual limit will
therefore depend on many things, such as the size of other things
allocated by the compiler at the same time, the amount of memory
consumed by other processes on the same computer, etc.

@itemize @bullet

@item Nesting levels of @samp{#include} files.

We impose an arbitrary limit of 200 levels, to avoid runaway recursion.
The standard requires at least 15 levels.

@item Nesting levels of conditional inclusion.

The C standard mandates this be at least 63.  CPP is limited only by
available memory.

@item Levels of parenthesized expressions within a full expression.

The C standard requires this to be at least 63.  In preprocessor
conditional expressions, it is limited only by available memory.

@item Significant initial characters in an identifier or macro name.

The preprocessor treats all characters as significant.  The C standard
requires only that the first 63 be significant.

@item Number of macros simultaneously defined in a single translation unit.

The standard requires at least 4095 be possible.  CPP is limited only
by available memory.

@item Number of parameters in a macro definition and arguments in a macro call.

We allow @code{USHRT_MAX}, which is no smaller than 65,535.  The minimum
required by the standard is 127.

@item Number of characters on a logical source line.

The C standard requires a minimum of 4096 be permitted.  CPP places
no limits on this, but you may get incorrect column numbers reported in
diagnostics for lines longer than 65,535 characters.

@item Maximum size of a source file.

The standard does not specify any lower limit on the maximum size of a
source file.  GNU cpp maps files into memory, so it is limited by the
available address space.  This is generally at least two gigabytes.
Depending on the operating system, the size of physical memory may or
may not be a limitation.

@end itemize

@node Obsolete Features
@section Obsolete Features

CPP has some features which are present mainly for compatibility with
older programs.  We discourage their use in new code.  In some cases,
we plan to remove the feature in a future version of GCC@.

@subsection Assertions
@cindex assertions

@dfn{Assertions} are a deprecated alternative to macros in writing
conditionals to test what sort of computer or system the compiled
program will run on.  Assertions are usually predefined, but you can
define them with preprocessing directives or command-line options.

Assertions were intended to provide a more systematic way to describe
the compiler's target system and we added them for compatibility with
existing compilers.  In practice they are just as unpredictable as the
system-specific predefined macros.  In addition, they are not part of
any standard, and only a few compilers support them.
Therefore, the use of assertions is @strong{less} portable than the use
of system-specific predefined macros.  We recommend you do not use them at
all.

@cindex predicates
An assertion looks like this:

@smallexample
#@var{predicate} (@var{answer})
@end smallexample

@noindent
@var{predicate} must be a single identifier.  @var{answer} can be any
sequence of tokens; all characters are significant except for leading
and trailing whitespace, and differences in internal whitespace
sequences are ignored.  (This is similar to the rules governing macro
redefinition.)  Thus, @code{(x + y)} is different from @code{(x+y)} but
equivalent to @code{@w{( x + y )}}.  Parentheses do not nest inside an
answer.

@cindex testing predicates
To test an assertion, you write it in an @samp{#if}.  For example, this
conditional succeeds if either @code{vax} or @code{ns16000} has been
asserted as an answer for @code{machine}.

@smallexample
#if #machine (vax) || #machine (ns16000)
@end smallexample

@noindent
You can test whether @emph{any} answer is asserted for a predicate by
omitting the answer in the conditional:

@smallexample
#if #machine
@end smallexample

@findex #assert
Assertions are made with the @samp{#assert} directive.  Its sole
argument is the assertion to make, without the leading @samp{#} that
identifies assertions in conditionals.

@smallexample
#assert @var{predicate} (@var{answer})
@end smallexample

@noindent
You may make several assertions with the same predicate and different
answers.  Subsequent assertions do not override previous ones for the
same predicate.  All the answers for any given predicate are
simultaneously true.

@cindex assertions, canceling
@findex #unassert
Assertions can be canceled with the @samp{#unassert} directive.  It
has the same syntax as @samp{#assert}.  In that form it cancels only the
answer which was specified on the @samp{#unassert} line; other answers
for that predicate remain true.  You can cancel an entire predicate by
leaving out the answer:

@smallexample
#unassert @var{predicate}
@end smallexample

@noindent
In either form, if no such assertion has been made, @samp{#unassert} has
no effect.

You can also make or cancel assertions using command-line options.
@xref{Invocation}.

@node Invocation
@chapter Invocation
@cindex invocation
@cindex command line

Most often when you use the C preprocessor you do not have to invoke it
explicitly: the C compiler does so automatically.  However, the
preprocessor is sometimes useful on its own.  You can invoke the 
preprocessor either with the @command{cpp} command, or via @command{gcc -E}.
In GCC, the preprocessor is actually integrated with the compiler
rather than a separate program, and both of these commands invoke
GCC and tell it to stop after the preprocessing phase.

The @command{cpp} options listed here are also accepted by
@command{gcc} and have the same meaning.  Likewise the @command{cpp}
command accepts all the usual @command{gcc} driver options, although those
pertaining to compilation phases after preprocessing are ignored.

Only options specific to preprocessing behavior are documented here.
Refer to the GCC manual for full documentation of other driver options.

@ignore
@c man begin SYNOPSIS
cpp [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
    [@option{-I}@var{dir}@dots{}] [@option{-iquote}@var{dir}@dots{}]
    [@option{-M}|@option{-MM}] [@option{-MG}] [@option{-MF} @var{filename}]
    [@option{-MP}] [@option{-MQ} @var{target}@dots{}]
    [@option{-MT} @var{target}@dots{}]
    @var{infile} [[@option{-o}] @var{outfile}]

Only the most useful options are given above; see below for a more
complete list of preprocessor-specific options.  
In addition, @command{cpp} accepts most @command{gcc} driver options, which
are not listed here.  Refer to the GCC documentation for details.
@c man end
@c man begin SEEALSO
gpl(7), gfdl(7), fsf-funding(7),
gcc(1), and the Info entries for @file{cpp} and @file{gcc}.
@c man end
@end ignore

@c man begin OPTIONS
The @command{cpp} command expects two file names as arguments, @var{infile} and
@var{outfile}.  The preprocessor reads @var{infile} together with any
other files it specifies with @samp{#include}.  All the output generated
by the combined input files is written in @var{outfile}.

Either @var{infile} or @var{outfile} may be @option{-}, which as
@var{infile} means to read from standard input and as @var{outfile}
means to write to standard output.  If either file is omitted, it
means the same as if @option{-} had been specified for that file.
You can also use the @option{-o @var{outfile}} option to specify the 
output file.

Unless otherwise noted, or the option ends in @samp{=}, all options
which take an argument may have that argument appear either immediately
after the option, or with a space between option and argument:
@option{-Ifoo} and @option{-I foo} have the same effect.

@cindex grouping options
@cindex options, grouping
Many options have multi-letter names; therefore multiple single-letter
options may @emph{not} be grouped: @option{-dM} is very different from
@w{@samp{-d -M}}.

@cindex options

@table @gcctabopt
@include cppopts.texi
@include cppdiropts.texi
@include cppwarnopts.texi
@end table
@c man end

@node Environment Variables
@chapter Environment Variables
@cindex environment variables
@c man begin ENVIRONMENT

This section describes the environment variables that affect how CPP
operates.  You can use them to specify directories or prefixes to use
when searching for include files, or to control dependency output.

Note that you can also specify places to search using options such as
@option{-I}, and control dependency output with options like
@option{-M} (@pxref{Invocation}).  These take precedence over
environment variables, which in turn take precedence over the
configuration of GCC@.

@include cppenv.texi
@c man end

@page
@include fdl.texi

@page
@node Index of Directives
@unnumbered Index of Directives
@printindex fn

@node Option Index
@unnumbered Option Index
@noindent
CPP's command-line options and environment variables are indexed here
without any initial @samp{-} or @samp{--}.
@printindex op

@page
@node Concept Index
@unnumbered Concept Index
@printindex cp

@bye
