\input texinfo-ja @c -*- texinfo -*-
@setfilename cpp.info
@settitle The C Preprocessor
@documentlanguage jp
@documentencoding UTF-8
@setchapternewpage off
@c @smallbook
@c @cropmarks
@c @finalout

@include gcc-common.texi

@copying
@c man begin COPYRIGHT
Copyright @copyright{} 1987-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation.  A copy of
the license is included in the
@c man end
section entitled ``GNU Free Documentation License''.
@ignore
@c man begin COPYRIGHT
man page gfdl(7).
@c man end
@end ignore

@c man begin COPYRIGHT
This manual contains no Invariant Sections.  The Front-Cover Texts are
(a) (see below), and the Back-Cover Texts are (b) (see below).

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.
@c man end
@end copying

@c Create a separate index for command line options.
@defcodeindex op
@syncodeindex vr op

@c Used in cppopts.texi and cppenv.texi.
@set cppmanual

@ifinfo
@dircategory Software development
@direntry
* Cpp: (cpp).                  The GNU C preprocessor.
@end direntry
@end ifinfo

@titlepage
@title The C Preprocessor
@versionsubtitle
@author Richard M. Stallman, Zachary Weinberg
@page
@c There is a fill at the bottom of the page, so we need a filll to
@c override it.
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents
@page

@ifnottex
@node Top
@top
Cプリプロセッサは、コンパイルされる前に、C、C ++、およびObjective-Cプログラムを変換するために使用されるマクロ言語を実装する。 それはまた、それ自身で役に立つかもしれない。

@menu
* Overview::
* Header Files::
* Macros::
* Conditionals::
* Diagnostics::
* Line Control::
* Pragmas::
* Other Directives::
* Preprocessor Output::
* Traditional Mode::
* Implementation Details::
* Invocation::
* Environment Variables::
* GNU Free Documentation License::
* Index of Directives::
* Option Index::
* Concept Index::

@detailmenu
 --- The Detailed Node Listing ---

概略

* Character sets::
* Initial processing::
* Tokenization::
* The preprocessing language::

ヘッダファイル

* Include Syntax::
* Include Operation::
* Search Path::
* Once-Only Headers::
* Alternatives to Wrapper #ifndef::
* Computed Includes::
* Wrapper Headers::
* System Headers::

マクロ

* Object-like Macros::
* Function-like Macros::
* Macro Arguments::
* Stringizing::
* Concatenation::
* Variadic Macros::
* Predefined Macros::
* Undefining and Redefining Macros::
* Directives Within Macro Arguments::
* Macro Pitfalls::

定義済みマクロ

* Standard Predefined Macros::
* Common Predefined Macros::
* System-specific Predefined Macros::
* C++ Named Operators::

マクロの落とし穴

* Misnesting::
* Operator Precedence Problems::
* Swallowing the Semicolon::
* Duplication of Side Effects::
* Self-Referential Macros::
* Argument Prescan::
* Newlines in Arguments::

条件

* Conditional Uses::
* Conditional Syntax::
* Deleted Code::

条件の構文

* Ifdef::
* If::
* Defined::
* Else::
* Elif::

条件の詳細

* Implementation-defined behavior::
* Implementation limits::
* Obsolete Features::

時代遅れの機能

* Obsolete Features::

@end detailmenu
@end menu

@insertcopying
@end ifnottex

@node Overview
@chapter Overview
@c man begin DESCRIPTION
@dfn{cpp}と呼ばれることが多いCプリプロセッサは、コンパイル前にプログラムを変換するためにCコンパイラによって自動的に使用される@dfn{macro processor}（マクロプロセッサ）である。 @dfn{macros}を定義することができるので、これはマクロプロセッサと呼ばれる。これは長い後続の略語である。

Cプリプロセッサは、C、C++、およびObjective-Cソースコードでのみ使用されることを意図している。 これまでは一般的なテキストプロセッサとして濫用されてきた。それはCの字句規則に従わない入力を詰まらせる。 たとえば、アポストロフィは文字定数の先頭と解釈され、エラーが発生する。 また、C-ファミリー言語にとって重要ではない入力の特性を保持することはできない。 Makefileがプリプロセスされていると、すべてのハードタブが削除され、Makefileは機能しない。

そうは言っても、C言語以外のものでcppを使うことはできる。他のAlgol風プログラミング言語はしばしば安全である（Pascal、Adaなど）。 @option{-traditional-cpp}モードは、より多くの空白を保存するが、そうでなければより許容する。 ネイティブ言語コメントの代わりにCまたはC++スタイルのコメントを記述し、マクロをシンプルに保つことで、多くの問題を回避できる。

可能であれば、あなたが書いている言語に合わせたプリプロセッサを使うべきである。現代版のGNUアセンブラにはマクロ機能がある。 ほとんどの高水準プログラミング言語は、独自の条件付きコンパイルおよびインクルードメカニズムを備えている。 それ以外の場合は、GNU M4などの一般的なテキストプロセッサを試すこと。

Cプリプロセッサは、いくつかの詳細が異なる。 このマニュアルでは、ISO標準Cの機能の小さなスーパーセットを提供するGNU Cプリプロセッサについて説明する。デフォルトモードでは、GNU Cプリプロセッサは標準で必要とされるいくつかのことを行わない。 これらは、これまで使用されていたことはめったにない機能であり、期待していないプログラムの意味に驚くような変化を引き起こす可能性がある。 厳密なISO標準Cを取得するには、次のようにあなたが望む標準のバージョンに応じて@option{-std=c90}、@option{-std=c99}、@option{-std=c11}または@option{-std=c17}オプションを使用する必要がある。すべての必須診断を取得するには、@option{-pedantic}も使用する必要がある。@xref{Invocation}.

このマニュアルでは、ISOプリプロセッサの動作について説明する。 相違点を最小限に抑えるために、ISOプリプロセッサの動作が従来のセマンティクスと競合しない場合、従来のプリプロセッサは同じように動作する必要がある。 存在する様々な相違点については、@ref{Traditional Mode}の節で詳しく説明する。

わかりやすくするために、特に明記しない限り、このマニュアルの@samp{CPP}はGNU CPPを参照する。
@c man end

@menu
* Character sets::
* Initial processing::
* Tokenization::
* The preprocessing language::
@end menu

@node Character sets
@section 文字集合

Cおよび関連する言語でのソースコードの文字セット処理はかなり複雑である。 C標準では2つの文字セットについて説明しているが、実際には少なくとも4つある。

CPPに入力されたファイルは、まったくどんな文字セットである可能性もある。 CPPの最初のアクションは、行境界を探す前に、ファイルを内部処理に使用する文字セットに変換することである。 そのセットは、C標準が@dfn{source}文字セットと呼ぶものである。それはUnicodeとも呼ばれるISO 10646と同形でなければならない。 CPPはUnicodeのUTF-8エンコーディングを使用する。

入力ファイルの文字セットは、@option{-finput-charset=}オプションを使用して指定する。

すべてのプリプロセス作業（このマニュアルの残りの部分）は、ソースキャラクタセットで実行される。 @option{-E}オプションを使用してプリプロセッサからのテキスト出力を要求すると、UTF-8になる。

プリプロセスが完了した後、文字列定数と文字定数は再び@dfn{execution}文字セットに変換される。この文字セットはユーザーの制御下にある。デフォルトはUTF-8で、ソース文字セットと一致する。ワイド文字列と文字定数には独自の文字セットがあり、標準では特に呼び出されない。再び、それはユーザの制御下にある。デフォルトはUTF-16またはUTF-32のいずれかで、ターゲットマシンのバイト順序でターゲットの@code {wchar_t}タイプに適合する。@footnote{UTF-16はワイド文字セットのC標準の要件を満たしていないが、16ビットの@code {wchar_t}の選択は、いくつかのシステムABIに託されているので、これを修正することはできない。} 8進および16進エスケープシーケンスは変換されない。 @t{'\x12'}は、現在選択されている実行文字セットに関係なく、値0x12を持つ。他のすべてのエスケープは、エスケープされていない文字のように、それらが表すソース文字セットの文字に置き換えられ、実行文字セットに変換される。

識別子では、ASCII範囲外の文字は@samp{\u}と@samp{\U}エスケープでしか指定できず、直接使用することはできない。 @option{-std=c90}のようなオプションで厳密なISO C90準拠が指定されている場合、または@option{-fno-extended-identifiers}が使用されている場合、これらのエスケープは識別子では許可されない。

@node Initial processing
@section 初期処理

プリプロセッサは、その入力に対して一連のテキスト変換を実行する。 これらは他のすべての処理の前に行われる。 概念的には、これらは厳密な順序で行われ、ファイル全体が次の変換が始まる前に各変換を通じて実行される。 パフォーマンス上の理由から、CPPは実際にそれらを一度にすべて実行する。 これらの変換は、C標準で記述されている最初の3つの「翻訳の段階」にほぼ対応している。

@enumerate
@item
@cindex line endings
入力ファイルはメモリに読み込まれ、行に分割される。

異なるシステムでは、行の終わりを示すために異なる規則が使用される。 GCCは、@kbd{LF}、@ kbd{@w{CR LF}}と@kbd{CR}のASCII制御シーケンスを行末マーカーとして受け入れる。 これらはUnix、DOS、VMS、そして古典的なMac OS（OSXの前）で使われている標準的なシーケンスである。 したがって、これらのシステムのいずれかで書かれたソースコードを別のものに安全にコピーし、変換せずに使用することができる。 （ネットワークファイルシステムを共有する異なる規則を持つコンピュータ上で編集されたときに起こるように、ファイルが1つの規則を一貫して使用しない場合、GCCは現在の行番号のトラックを失う可能性がある）。

入力ファイルの最後の行に行末マーカーがない場合、ファイルの終わりは暗黙的に改行とみなされる。 Cの標準では、この状態は未定義の動作を引き起こすので、GCCは警告メッセージを出力する。

@item
@cindex trigraphs
@anchor{trigraphs}トライグラフを有効にすると、対応する単一の文字に置き換えられる。 デフォルトでは、GCCはトライグラフを無視するが、@option{-std}オプションで厳密に準拠したモードを要求した場合、または@option{-trigraphs}オプションを指定した場合は変換される。

これらは9の3文字のシーケンスで、すべてが@samp{??}で始まり、ISO Cで単一文字を表すように定義されている。 それらはCの句読点のいくつかが欠けている古いシステムではCを使うためのものである。 たとえば、@samp{??/}は@samp{\}を表す。したがって、@t{'??/n'}は改行の文字定数である。

トライグラフは普及してなく、多くのコンパイラが誤って実装している。 移植可能なコードは、変換されたか無視されたトリグラフに依存するべきではない。@option{-Wtrigraphs}を使うと、変換されたプログラムの意味をトリグラフが変えることがあるときにGCCが警告する。 @xref{Wtrigraphs}。

文字列定数では、一連の疑問符が疑問符の間にバックスラッシュを挿入するか、または文字列リテラル連結を使用して文字列リテラルを分離することによって、一連の疑問符がトリグラフと混同されるのを防ぐことができる。 @t["(??\?)"]は@samp{(???)}ではなく@samp{(???)}という文字列である。伝統的なCコンパイラはこれらのイディオムを認識しない。

9つのトライグラフとそれらの置換は、

@smallexample
トライグラフ:       ??(  ??)  ??<  ??>  ??=  ??/  ??'  ??!  ??-
置換:                        [    ]    @{    @}    #    \    ^    |    ~
@end smallexample

@item
@cindex continued lines
@cindex backslash-newline
継続された行は1つの長い行にマージされる。

継続行はバックスラッシュ@samp{\}で終わる行である。 バックスラッシュが削除され、次の行が現在の行と結合される。 スペースは挿入されないので、単語の途中であってもどこでも行を分割できる。 （一般に、空白でのみ行を分割する方が読みやすくなる。）

継続行の末尾にあるバックスラッシュは、通常、@dfn{backslash-newline}（バックスラッシュ・改行）と呼ばれる。

バックスラッシュと行末の間に空白がある場合でも、それは継続行である。 しかし、これは通常編集ミスの結果であり、多くのコンパイラは継続行として受け付けないので、GCCはそれについて警告する。

@item
@cindex comments
@cindex line comments
@cindex block comments
すべてのコメントは1つのスペースで置き換えられる。

コメントには2種類ある。 @dfn{Block comments}（ブロックコメント）は@samp{/*}で始まり、次の@samp{*/}まで続く。 ブロックコメントは入れ子にならない：

@smallexample
/* @r{this is} /* @r{one comment} */ @r{text outside comment}
@end smallexample

@dfn{Line comments}（行コメント）は@samp{//}で始まり、現在の行の最後まで続く。 行コメントも入れ子にならないが、いずれにせよ同じ場所で終わるので問題はない。

@smallexample
// @r{this is} // @r{one comment}
@r{text outside comment}
@end smallexample
@end enumerate

ブロックコメントの中に行コメントを入れることは安全であり、逆もまた同様である。

@smallexample
@group
/* @r{block comment}
   // @r{contains line comment}
   @r{yet more comment}
 */ @r{outside comment}

// @r{line comment} /* @r{contains block comment} */
@end group
@end smallexample

しかし、行コメントでブロックコメントの一端をコメントアウトすることに注意せよ。

@smallexample
@group
 // @r{l.c.}  /* @r{block comment begins}
    @r{oops! this isn't a comment anymore} */
@end group
@end smallexample

コメントは文字列リテラル内では認識されない。 @t{@w{"/ * blah * /"}}は空文字列ではなく、文字列定数@samp{@w{/ * blah * /}}である。

行コメントは1989年版のC標準には含まれていないが、GCCでは拡張機能として認識されている。 C++および1999年版のC標準では、これらは言語の公式な部分である。

これらの変換は他のすべての処理の前に行われるので、バックスラッシュ改行を使って機械的に行を分割することができる。 行末をコメントアウトすることができる。 バックスラッシュ改行で次の行に行コメントを続けることができる。 @samp{/*}、@samp{*/}、および@samp{//}をバックスラッシュ改行で複数の行に分割することさえできる。 例えば：

@smallexample
@group
/\
*
*/ # /*
*/ defi\
ne FO\
O 10\
20
@end group
@end smallexample

@noindent
は@code{@w{#define FOO 1020}}と同等である。 これらのすべてのトリックは非常に混乱させるので、読みやすいコードでは使用すべきではない。

行末のバックスラッシュがバックスラッシュ改行として解釈されないようにする方法はない。 しかし、これは正しいプログラムには影響しない。

@node Tokenization
@section トークン化

@cindex tokens
@cindex preprocessing tokens
テキスト変換が終了すると、入力ファイルは@dfn{preprocessing tokens}（プリプロセストークン）のシーケンスに変換される。 これらは主にCコンパイラで使用される構文トークンに対応するが、いくつかの違いがある。 空白はトークンを区切る。 それはそれ自身がいかなる種類のトークンでもない。 トークンは空白で区切る必要はないんが、しばしばあいまいさを避ける必要がある。

1つ以上の可能なトークン化を有する一連の文字に直面するとき、プリプロセッサは貪欲である。 左から順に、各トークンをできるだけ大きくしてから次のトークンに移る。 たとえば、@code{a+++++b}は@code{@w{a ++ + ++ b}}ではなく、@code{@w{a ++ +++ b}}と解釈される。 後者のトークン化は有効なCプログラムの一部であり、前者のトークン化は不可能であったにもかかわらず。

入力ファイルがトークンに分割されると、@samp{##}プリプロセス演算子を使用してトークンを貼り付けるときを除いて、トークンの境界は決して変更されない。 @xref{Concatenation}。 例えば、

@smallexample
@group
#define foo() bar
foo()baz
     @expansion{} bar baz
@emph{not}
     @expansion{} barbaz
@end group
@end smallexample

コンパイラはプリプロセッサの出力を再トークン化しない。 各プリプロセストークンは1つのコンパイラー・トークンになる。

@cindex identifiers
プリプロセストークンは、識別子、プリプロセス番号、文字列リテラル、句読子などの5つの広いクラスに分類される。 @dfn{識別子}は、Cの識別子と同じである。文字またはアンダースコアで始まる、文字や数字、またはアンダースコアの任意のシーケンス。Cのキーワードはプリプロセッサにとって意味がない。 それらは通常の識別子である。 たとえば、名前がキーワードであるマクロを定義することができる。 プリプロセスキーワードとみなせる唯一の識別子は@code{defined}である。  @xref{Defined}.

これは、Cプリプロセッサを使用する他の言語にも当てはまる。 しかし、C++のキーワードのいくつかは、プリプロセッサでも意味を持つ。 @xref{C++ Named Operators}.

1999年のC標準では、識別子には、実装の裁量で（アクセント付きのラテン文字、ギリシャ文字、中国語の表意文字など）、「基本的なソース文字セット」の一部ではない文字を含めることができる。 これは、拡張文字セット、または@samp{\u}と@samp{\U}エスケープシーケンスで行うことができる。 GCCは@samp{\u}と@samp{\U}形式の文字しか受け付けない。

拡張として、GCCは@samp{$}を文字として扱う。 これは、システム定義関数やオブジェクト名で@samp{$}がよく使用されるVMSなどのシステムとの互換性のためである。 @samp{$}は厳密に準拠したモードの文字ではなく、@option{-$}オプションを指定した場合には使用できない。@xref{Invocation}.

@cindex numbers
@cindex preprocessing numbers
@dfn{プリプロセス数}はかなり奇妙な定義をしている。 このカテゴリには、Cで期待されるすべての通常の整数と浮動小数点定数が含まれるが、最初は数として認識されない数多くのものも含まれる。 正式には、プリプロセス数は任意のピリオド、必要な10進数で始まり、文字、数字、下線、ピリオド、および指数の任意のシーケンスで続行される。 指数は、2文字のシーケンス@samp{e+}、@samp{e-}、@samp{E+}、@samp{E-}、@samp{p+}、@samp{p-}、@samp{P+}、および@samp{P-}である。 （@samp{p}または@samp{P}で始まる指数は、16進浮動小数点定数に使用される）。

この珍しい定義の目的は、プリプロセッサを完全な数値定数から分離することである。 字句的に有効な浮動小数点数と無効な浮動小数点数を区別する必要はなく、それは複雑である。 この定義では、識別子を任意の位置に分割し、ちょうど2つのトークンを取得し、@samp{##}演算子と一緒に貼り付けることもできる。

プリプロセスしている数字によってプログラムが誤って解釈される可能性がある。 たとえば、@code{0xE+12}は有効な数値定数に変換されないプリプロセス番号なので、構文エラーである。あなたが意図しているかもしれない@code{@w{0xE + 12}}を意味するものではない。

@cindex string literals
@cindex string constants
@cindex character constants
@cindex header file names
@c the @: prevents makeinfo from turning '' into ".
@dfn{String literal}は文字列定数、文字定数、ヘッダファイル名（@samp{#include}の引数）である。@footnote{C標準では@dfn{string literal}という用語を使って、@dfn{string constants}を呼び出すものだけを参照している。}文字列定数と文字定数は簡単である。@t{"@dots{}"}か@t{'@dots{}'}である。 どちらの場合でも、埋め込み引用符はバックスラッシュでエスケープする必要がありる。@t{'\'@:'}は@samp {'}の文字定数である。 文字定数の長さに制限はないが、複数の文字を含む文字定数の値は実装定義である。 @xref{Implementation Details}.

ヘッダーファイル名は、文字列定数のように見えるが、@t{"@dots{}"}か、かわりに山カッコで書かれている。 どちらの場合でも、バックスラッシュは普通の文字である。 閉じクォートや角括弧をエスケープする方法はない。 プリプロセッサは、使用するフォームに応じて異なる場所でヘッダファイルを探す。@xref{Include Operation}.

文字列リテラルは、行末を越えてはならない。 継続行を使用するか、文字列定数連結を使用する。

@cindex punctuators
@cindex digraphs
@cindex alternative tokens
@dfn{句読点}は、CやC ++にとって意味のある句読点の通常のビットである。 ASCIIの句読点文字のうち3つを除くすべてがCの句読点である。 例外は@samp{@@}、@samp{$}、@samp{`}である。 さらに、2文字と3文字の演算子はすべて句読点である。 C++標準が@dfn{alternative tokens}と呼ぶ6つの@dfn{digraphs}もある。これは単に他の句読点を綴る代わりの方法である。 これは時代遅れのシステムでの句読点の欠落を回避するための2番目の試みである。 それは、trigraphsとは異なり、否定的な副作用はないが、多くの地面をカバーしていない。二重グラフとそれに対応する通常の句読点は次のとおりである。

@smallexample
Digraph:        <%  %>  <:  :>  %:  %:%:
Punctuator:      @{   @}   [   ]   #    ##
@end smallexample

@cindex other tokens
他の単一の文字は「その他」とみなされる。 unmolestedプリプロセッサの出力に渡されます。 Cコンパイラは「他の」トークンを含むソースコードをほぼ確実に拒否する。 ASCIIでは、他の文字は@samp{@@}、@samp{$}、@samp{`}、NUL以外の制御文字（全ビット0）のみである。 （通常、@samp{$}は文字と見なされることに注意せよ。）上位ビットがセットされたすべての文字（数値範囲0x7F - 0xFF）も現在の実装では 「その他」である。 これは、国際文字セットの適切なサポートがGCCに追加されたときに変更される。

NULは、その外観が偶発的である可能性が高く、ユーザが見えない（多くの端末がNULを全く表示しない）可能性が高いため、特別なケースである。 コメント内では、他の文字と同じようにNULも暗黙のうちに無視される。 実行中のテキストでは、NULは空白と見なされる。 たとえば、これらの2つのディレクティブは同じ意味を持つ。

@smallexample
#define X^@@1
#define X 1
@end smallexample

@noindent
（@samp{^@@}はASCII NULである。） 文字列定数または文字定数内では、NULは保持される。 後者の2つのケースでは、プリプロセッサは警告メッセージを出力する。

@node The preprocessing language
@section プリプロセス言語
@cindex directives
@cindex preprocessing directives
@cindex directive line
@cindex directive name

トークン化の後、トークンのストリームは単純にコンパイラのパーサに直接渡されるかもしれない。 しかし、@dfn{プリプロセス言語}に何らかの操作が含まれていると、それが最初に変換される。 この段階は、標準の「翻訳フェーズ4 」にほぼ対応していて、ほとんどの人がプリプロセッサの仕事と考えるものである。

プリプロセス言語は、実行される@dfn{ディレクティブ}と展開される@dfn{マクロ}で構成される。 主な機能は次のとおりである。

@itemize @bullet
@item
ヘッダーファイルのインクルード。 これらは、プログラムに置換可能な宣言ファイルである。

@item
マクロ展開。 @dfn{マクロ}は、Cコードの任意のフラグメントの略語を定義することができる。 プリプロセッサは、マクロ全体をプログラム全体の定義に置き換える。 一部のマクロは自動的に定義される。

@item
条件付きコンパイル。 さまざまな条件に従ってプログラムの一部を含めるか除外することができる。

@item
行制御。 プログラムを使用してソースファイルを中間ファイルに結合または再編成してコンパイルした場合は、行制御を使用して、元のソース行がどこから来たのかをコンパイラに知らせることができる

@item
診断。 コンパイル時に問題を検出し、エラーまたは警告を出すことができる。
@end itemize

いくつか、あまり有用でない機能がいくつかある。

定義済みマクロの展開を除いて、これらの操作はすべて@dfn{プリプロセスディレクティブ}でトリガされる。 プリプロセス指令は@samp{#}で始まるプログラム内の行である。 @samp{＃}の前後に空白を入れることができる。 @samp{＃}には識別子@dfn{指令名}が続く。 それは実行する操作を指定する。 ディレクティブは通常@samp{#@var{name}}と呼ばれ、@var{name}はディレクティブ名である。 たとえば、@samp{#define}はマクロを定義するディレクティブである。

ディレクティブを開始する@samp{#}は、マクロ展開から始めることはできない。 また、ディレクティブ名はマクロ展開されない。 したがって、@code{foo}が@code{define}に展開されるマクロとして定義されていても、@samp{#foo}を有効なプリプロセス指令にはしない。

有効なディレクティブ名のセットは固定されている。 プログラムは新しいプリプロセス指令を定義することはできない。

命令の中には引数が必要なものがある。 これらはディレクティブ行の残りの部分を構成し、空白でディレクティブ名と区切らなければならない。 たとえば、@samp{#define}の後ろにマクロ名とマクロの展開を続けなければならない。

プリプロセスディレクティブは複数の行を覆うことはできない。 しかし、行は、バックスラッシュ改行、または行末を越えるブロックコメントによって継続される。 いずれの場合も、ディレクティブが処理されると、継続はすでに1行目とマージされて1つの長い行になる。

@node Header Files
@chapter ヘッダファイル

@cindex header file
ヘッダファイルは、複数のソースファイル間で共有されるC宣言とマクロ定義（@pxref{Macros}）を含むファイルである。Cプリプロセスディレクティブ@samp{#include}で、それを@dfn{インクルードする}ことによってプログラム内でヘッダファイルを使うように要求する。

ヘッダーファイルには2つの目的がある。

@itemize @bullet
@item
@cindex system header files
システムヘッダファイルは、オペレーティングシステムの各部へのインタフェースを宣言する。 システムコールとライブラリを呼び出すために必要な定義と宣言を提供するために、これらをプログラムに含める。

@item
独自のヘッダファイルには、プログラムのソースファイル間のインタフェースの宣言が含まれている。 関連する宣言とマクロ定義のグループがある場合、そのすべてまたは大部分が複数の異なるソースファイルで必要になるたびに、そのためのヘッダーファイルを作成するのはいい考えである。
@end itemize

ヘッダーファイルを含めると、ヘッダーファイルを必要とする各ソースファイルにコピーするのと同じ結果が得られる。 そのようなコピーは時間がかかり、エラーを起こしやすい。 ヘッダーファイルでは、関連する宣言が1つの場所にのみ現れる。 変更が必要な場合は、1か所で変更することができ、ヘッダーファイルを含むプログラムは、次回の再コンパイル時に新しいバージョンを自動的に使用する。 ヘッダーファイルは、すべてのコピーを見つけて変更する労力と、1つのコピーが見つからないとプログラム内で矛盾が生じるというリスクを排除する。

Cでは、通常、@file{.h}で終わるヘッダファイル名を与えるのが一般的である。 ヘッダーファイル名には、英字、数字、ダッシュ、アンダースコアのみを使用し、ドットは最大１つしか使用ないのが最も移植性が高い。

@menu
* Include Syntax::
* Include Operation::
* Search Path::
* Once-Only Headers::
* Alternatives to Wrapper #ifndef::
* Computed Includes::
* Wrapper Headers::
* System Headers::
@end menu

@node Include Syntax
@section Include構文

@findex #include
ユーザーとシステムの両方のヘッダーファイルは、@samp{#include}というプリプロセスディレクティブを使用してインクルードされる。 それには2つの変種がある：

@table @code
@item #include <@var{file}>
この変形は、システムヘッダファイルに使用される。 システムディレクトリの標準リストで@var{file}という名前のファイルを検索する。 @option{-I}オプション（@pxref{Invocation}）を使用して、このリストにディレクトリを追加することができる。

@item #include "@var{file}"
この変種はあなた自身のプログラムのヘッダファイルに使われる。 現在のファイルを含むディレクトリの最初の@var{file}という名前のファイルを検索し、その後、引用符のディレクトリで@code{<var {file}>}のディレクトリと同じディレクトリを検索する。 @option{-iquote}オプションを使用して、ディレクトリを引用符のディレクトリの先頭に追加することができる。
@end table

@samp{#include}の引数は、引用符または山括弧で区切られていても、コメントが認識されず、マクロ名が展開されないという文字定数のように動作する。 したがって、@code{@w{#include <x/*y>}}は、@file{x/*y}というシステムヘッダファイルのインクルードを指定する。

しかし、バックスラッシュが@var{file}の中で発生すると、エスケープ文字ではなく普通のテキスト文字とみなされる。 Cの文字列定数に適した文字エスケープシーケンスは処理されない。 したがって、@code{@w{#include "x¥n¥¥y"}}は3つのバックスラッシュを含むファイル名を指定する。 （システムによっては、@samp{\}をパス名の区切りとして解釈するものがある。 これらのすべては同じ方法で@samp{/}も解釈する。 @samp {/}だけを使うのが最も移植性がある。）

ファイル名の後に（コメント以外の）行に何かがあると、エラーである。

@node Include Operation
@section Include操作

@samp{#include}ディレクティブは、指定されたファイルを入力としてスキャンしてから、現在のファイルの残りの部分を続行するようにCプリプロセッサに指示して動作する。 プリプロセッサからの出力には、すでに生成された出力と、インクルードされたファイルからの出力と、@samp{#include}ディレクティブの後のテキストからの出力が続く。 たとえば、次のようにヘッダファイル@file {header.h}がある場合、

@smallexample
char *test (void);
@end smallexample

@noindent
このようなヘッダファイルを使用する@file{program.c}と呼ばれる以下のメインプログラムは、

@smallexample
int x;
#include "header.h"

int
main (void)
@{
  puts (test ());
@}
@end smallexample

@noindent
コンパイラは@file {program.c}が以下を読んだ場合と同じトークンストリームを見るだろう。

@smallexample
int x;
char *test (void);

int
main (void)
@{
  puts (test ());
@}
@end smallexample

インクルードされたファイルは、宣言とマクロ定義に限定されない。 それらは典型的な用途にすぎない。 Cプログラムのフラグメントは、別のファイルからインクルードすることができる。 インクルードファイルには、インクルードファイルで終わるステートメントの先頭、インクルードファイルで開始されたステートメントの末尾まで含めることもできる。 ただし、インクルードされたファイルは完全なトークンで構成する必要がある。 インクルードファイルの最後で閉じられていないコメントと文字列リテラルは無効である。 エラーリカバリの場合、ファイルの最後に終了するとみなされる。

混乱を避けるために、ヘッダーファイルに完全な構文単位（関数の宣言や定義、型宣言など）しか含まれていない方が良いだろう。

@samp{#include}ディレクティブに続く行は、インクルードされたファイルに最終改行がない場合でも、Cプリプロセッサによって常に別の行として扱われる。

@node Search Path
@section 検索パス

デフォルトでは、プリプロセッサは、ディレクティブ@code{@w{#include "@var{file}"}}のクオート形式によってインクルードされたヘッダファイルでは、まず現在のファイルのディレクトリに対して探し、次にあらかじめ設定された標準システムディレクトリのリスト内を探す。たとえば、@file{/usr/include/sys/stat.h}に@code{@w{#include "types.h"}}が含まれている場合、GCCは最初に@file{/usr/include/sys}を探し、それからいつもの検索パスを探す。

角括弧の形式の@code{@w{#include <@var {file}>}}の場合、プリプロセッサのデフォルト動作は標準のシステムディレクトリだけである。 正確な検索ディレクトリのリストは、ターゲットシステム、GCCの設定方法、およびインストール先によって異なる。 @option{-v}オプションを使用してCPPを呼び出すことによって、CPPのデフォルトの検索ディレクトリリストを見つけることができる。 例えば、

@smallexample
cpp -v /dev/null -o /dev/null
@end smallexample

検索パスに追加のディレクトリを追加するために使用できるいくつかのコマンドラインオプションがある。 最も一般的に使用されるオプションは@option{-I @var{dir}}である。これにより、@var{dir}が現在のディレクトリ（ディレクティブの見積もり形式）の後ろで標準システムディレクトリより先に検索される。 コマンドラインで複数の@option{-I}オプションを指定できる。この場合、ディレクトリは左から右の順に検索される。

@samp{#include}ディレクティブの引用符と角括弧の形式の検索パスを個別に制御する必要がある場合は、@option{-I}の代わりに@option{-iquote}や@option{-isystem}オプションを使うことができる。 これらのオプションの詳細な説明だけでなく、それほど一般的ではない他のものについては、@xref{Invocation}を参照せよ。

プリプロセッサがヘッダファイルを検索する場所に影響を与える@option{-I}などのコマンドラインで他のオプションを指定した場合、@option{-v}オプションで表示されるディレクトリリストは、プリプロセッサで使用されている実際の検索パスを反映する。

プリプロセッサがデフォルトのシステムヘッダディレクトリを@option{-nostdinc}オプションで検索しないようにすることもできる。 これは、標準Cライブラリ機能を使用しないオペレーティングシステムカーネルまたはその他のプログラムをコンパイルする場合や、標準Cライブラリ自体をコンパイルする場合に便利である。

@node Once-Only Headers
@section 一度だけのヘッダ
@cindex repeated inclusion
@cindex including just once
@cindex wrapper @code{#ifndef}

ヘッダーファイルが2回インクルードされた場合、コンパイラはその内容を2回処理する。 これは、コンパイラーが同じ構造定義を2回見た場合など、エラーを引き起こす可能性が非常に高くなる。 たとえそれがなくても、確かに時間を無駄にするだろう。

これを防ぐ標準的な方法は、ファイルの実内容全体を次のように条件付きで囲むことである。

@smallexample
@group
/* File foo.  */
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN

@var{the entire file}

#endif /* !FILE_FOO_SEEN */
@end group
@end smallexample

この構造体は一般に@dfn{wrapper #ifndef}と呼ばれる。 @code{FILE_FOO_SEEN}が定義されているため、ヘッダーが再び含まれると、条件はfalseになる。 プリプロセッサはファイルの内容全体をスキップし、コンパイラはそれを2度見ることはない。

CPPはさらに最適化する。 ヘッダファイルにラッパー@samp{#ifndef}があるときを覚えている。 後続の@samp{#include}がそのヘッダを指定し、@samp{#ifndef}のマクロがまだ定義されている場合、わざわざファイルを再スキャンしない。

コメントはラッパーの外に置くことができる。それらはこの最適化を妨げない。

@cindex controlling macro
@cindex guard macro
@code{FILE_FOO_SEEN}マクロは@dfn{制御マクロ}または@dfn{ガードマクロ}と呼ばれる。 ユーザーヘッダーファイルでは、マクロ名は@samp{_}で始めるべきではない。 システムヘッダファイルでは、ユーザプログラムとの衝突を避けるために@samp{__}で始まる必要がある。 どのような種類のヘッダーファイルでも、他のヘッダーファイルとの競合を避けるために、マクロ名にはファイルの名前と追加のテキストが含まれている必要がある。

@node Alternatives to Wrapper #ifndef
@section ラッパ#ifndefの代替

CPPは、ヘッダーファイルを1回だけ読み取る必要があることを示す2つの方法をさらにサポートしている。 どちらもラッパー@samp {#ifndef}と同じ移植性はない。新しいプログラムでは使用しないことを推奨する。Objective-Cでは@samp{#import}が標準的な方法である。

@findex #import
CPPは@samp{#include}のファイルを多くて1回だけインクルードする@samp{#import}と呼ばれる亜種をサポートしている。 @samp{#include}の代わりに@samp{#import}を使用すると、複数のコンテンツが含まれないようにするヘッダファイル内に条件文は必要ない。 @samp{#import}はObjective-Cでは標準だが、CおよびC ++では廃止予定の拡張と見なされる。

@samp{#import}はうまく設計された機能ではない。 ヘッダーファイルのユーザーは、ヘッダーファイルを1回だけ含める必要があることを知る必要がある。 ヘッダーファイルの実装者がファイルを書き込むほうが、ユーザーがこれを知る必要はないので好ましい。 ラッパー@samp{#ifndef}を使用すると、この目標を達成できる。

現在の実装では、@samp {#import}を1回使用すると、@samp{#import}または@samp{#include}のいずれかによって、ファイルが再び読み取られることがなくなる。これに頼るべきではない。 同じヘッダファイルを参照するために@samp{#import}と@samp{#include}の両方を使用してはならない。

@samp{#pragma once}ディレクティブを使用する、ヘッダーファイルが2回以上含まれないようにするもう1つの方法がある。 ヘッダファイルをスキャンするときに@samp{#pragma once}が見つかった場合、そのファイルが何であれ再読されなくなる。

@samp{#pragma once}は@samp {#import}のような問題はないが、すべてのプリプロセッサでは認識されないので、移植可能なプログラムではそれに頼ることはできない。

@node Computed Includes
@section 計算インクルード
@cindex computed includes
@cindex macros in include

場合によっては、プログラムに組み込むいくつかの異なるヘッダーファイルの1つを選択する必要がある。 たとえば、さまざまな種類のオペレーティングシステムで使用される構成パラメータを指定する場合がある。 一連の条件付きでこれを行うことができるが、

@smallexample
#if SYSTEM_1
# include "system_1.h"
#elif SYSTEM_2
# include "system_2.h"
#elif SYSTEM_3
@dots{}
#endif
@end smallexample

それは急速に退屈になる。 代わりに、プリプロセッサはヘッダー名にマクロを使用する機能を提供する。 これは@dfn{計算インクルード}と呼ばれる。 @samp{#include}の直接引数としてヘッダ名を書くのではなく、その代わりにマクロ名を入れるだけである：

@smallexample
#define SYSTEM_H "system_1.h"
@dots{}
#include SYSTEM_H
@end smallexample

@noindent
@code {SYSTEM_H}は展開され、プリプロセッサは@samp{#include}が元のように書かれているかのように@file{system_1.h}を探す。 @code{SYSTEM_H}はMakefileによって@option{-D}オプションで定義できる。

マクロを定義するときは注意が必要である。 @samp{#define}はテキストではなくトークンを保存する。 プリプロセッサはマクロが@samp{#include}の引数として使われることを知る方法がないので、ヘッダ名ではなく普通のトークンを生成する。 文字列定数に十分近い二重引用符を使用するなら、これが問題になることはまずない。 ただし、角カッコを使用すると、問題が発生する可能性がある。

計算インクルードの構文は、実際には上記より少し一般的である。 @samp{#include}の後の最初の空白以外の文字が@samp{"}や@samp{<}でない場合、実行中のテキストのように行全体がマクロ展開される。

行が単一の文字列定数に展開される場合、その文字列定数の内容はインクルードされるファイルになる。 CPPは埋め込み引用符の文字列を再検査しないが、文字列のバックスラッシュエスケープも処理しない。 したがって、

@smallexample
#define HEADER "a\"b"
#include HEADER
@end smallexample

@noindent
は@file{a\"b}という名前のファイルを探す。CPPは二重引用符の規則に従ってファイルを検索する。

@samp{<}トークンで始まり、@samp{>}トークンを含むトークンストリームに展開すると、@samp{<}と最初の@samp {>}のトークンが含まれるファイル名の形式へと結合される。 トークン間の任意の空白は、単一のスペースに縮小される。 最初の@samp{<}の後のスペースはすべて保持されるが、閉じる@samp{>}の前のスペースは無視される。 CPPは、角括弧の規則に従ってファイルを検索する。

どちらの場合も、ファイル名の後に行にトークンがあると、エラーが発生し、ディレクティブは処理されない。 展開の結果が2つの予想される形式のいずれとも一致しない場合は、エラーである。

これらのルールは、C標準に従った実装定義の動作である。 異なるコンパイラが計算されたインクルードを異なる方法で解釈するリスクを最小限に抑えるため、文字列定数に展開されるオブジェクトのようなマクロを1つだけ使用することを推奨する。 これにより、あなたのプログラムを読んでいる人の混乱も最小限に抑えられる。

@node Wrapper Headers
@section ラッパヘッダ
@cindex wrapper headers
@cindex overriding a header file
@findex #include_next

場合によっては、システム提供のヘッダーファイルの内容を直接編集せずに調整する必要があることもある。 GCCの@command{fixincludes}操作ではこれが実行される。 これを行う1つの方法は、同じ名前の新しいヘッダーファイルを作成し、元のヘッダーの前の検索パスに挿入することである。 古いヘッダーを完全に置き換えることができれば、うまく動作する。 しかし、新しいヘッダーの古いヘッダーを参照したい場合はどうすればよいだろうか？

古いヘッダに単に@samp{#include}を含めることはできない。 それは最初から始まり、あなたの新しいヘッダーを再び見つける。 ヘッダーが複数のインクルード（@pxref{Once-Only Headers}）から保護されていない場合、無限に再帰的に発生し、致命的なエラーが発生する。

あなたは絶対パス名で古いヘッダーを含めることができる：
@smallexample
#include "/usr/include/old-header.h"
@end smallexample
@noindent
これは機能しますが、きれいではない。 システムヘッダーが移動した場合は、新しいヘッダーを編集して一致させる必要がある。

Cの標準でこの問題を解決する方法はないが、GNU拡張@samp{#include_next}を使用することができる。それは、「この名前の@emph{次の}ファイル」を意味する。このディレクティブは、指定されたファイルを検索する以外は@samp{#include}のように動作する。現在のファイルが見つかったディレクトリのヘッダファイルディレクトリ@emph{後で}検索を開始する。

@option{-I/usr/local/include}を指定し、検索するディレクトリのリストに@file{/usr/include}も含まれているとする。 両方のディレクトリに@file{signal.h}が含まれているとする。 普通の@code{@w{#include <signal.h>}}は、@file{/usr/local/include}以下のファイルを探す。 そのファイルに@code{@w{#include_next <signal.h>}}が含まれていれば、そのディレクトリの後ろで検索を開始し、@file{/usr/include}にあるファイルを探す。

@samp{#include_next}は@code{<@var{file}>}と@code{"@var{file}"}のインクルードを区別せず、指定したファイルが現在のファイルと同じ名前をしていしたかどうかもチェックしない。 現在のファイルが見つかったディレクトリの後ろにある検索パスのディレクトリから始まる、名前の付いたファイルを探す。

@samp{#include_next}を使用すると、大きな混乱を招く可能性がある。 他の方法がない場合にのみ使用することを推奨する。 特に、特定のプログラムに属するヘッダーでは使用すべきではない。 @command{fixincludes}の行に沿って大域的な修正を行う場合にのみ使用すること。

@node System Headers
@section システムヘッダ
@cindex system header files

オペレーティングシステムやランタイムライブラリへのインタフェースを宣言するヘッダファイルは、しばしば厳密に準拠したC言語で記述することはできない。したがって、GCCは@dfn{システムヘッダ}の特別な扱いにあるコードを提供する。 @samp{#warning}（@pxref{Diagnostics}）によって生成された警告以外のすべての警告は、GCCがシステムヘッダを処理している間は表示されない。 システムヘッダに定義されたマクロは、どこに展開されているかにかかわらず、いくつかの警告の影響を受けない。 この免責は、システムヘッダーで定義されたマクロのコードのために、警告が誤検出を多く生成することが判明した場合、アドホックベースで付与される。

通常、特定のディレクトリにあるヘッダーだけがシステムヘッダーと見なされる。これらのディレクトリは、GCCのコンパイル時に決定される。しかし、通常のヘッダーをシステムヘッダーにする2つの方法がある。

@itemize @bullet
@item
@option{-isystem}および@option {-idirafter}コマンドラインオプションを使用して検索パスに追加されたディレクトリにあるヘッダファイルは、診断目的でシステムヘッダとして扱われる。

@item
@findex #pragma GCC system_header
@code{@w{#pragma GCC system_header}}の指示文もある。これはGCCに現在のインクルードファイルの残りの部分をシステムヘッダと、見つかった場所に関係なく解釈する。 ファイル内の@samp{#pragma}より前にあるコードは影響を受けない。 @code{@w{#pragma GCC system_header}}はプライマリソースファイルには影響しない。
@end itemize

@node Macros
@chapter マクロ

@dfn{マクロ}は名前を与えられたコードの断片である。 名前が使用されるたびに、マクロの内容に置き換えられる。 マクロには2種類ある。それらは、使用されるときのように見えるかが主に異なる。 @dfn{オブジェクト風}マクロはデータオブジェクトに似ているが、@dfn{関数風}マクロは関数呼び出しに似ている。

有効な識別子は、Cキーワードであっても、マクロとして定義することができる。 プリプロセッサはキーワードについて何も知らない。これは、@code{const}のようなキーワードを理解できない古いコンパイラから隠す場合に便利である。 ただし、プリプロセッサ演算子@code{defined}（@pxref{Defined}）はマクロとして決して定義することはできず、C ++をコンパイルするときにはC++の名前付き演算子（@pxref{C ++ Named Operators}）はマクロにはならない。

@menu
* Object-like Macros::
* Function-like Macros::
* Macro Arguments::
* Stringizing::
* Concatenation::
* Variadic Macros::
* Predefined Macros::
* Undefining and Redefining Macros::
* Directives Within Macro Arguments::
* Macro Pitfalls::
@end menu

@node Object-like Macros
@section オブジェクト風マクロ
@cindex object-like macro
@cindex symbolic constants
@cindex manifest constants

@dfn{オブジェクト風マクロ}はコードフラグメントに置き換えられる単純な識別子である。 それはそれを使用するコードのデータオブジェクトのように見えるので、オブジェクト風と呼ばれる。 これらは最も一般的には、数値定数に記号名を付けるために使用される。

@findex #define
マクロは@samp{#define}ディレクティブで作成する。 @samp{#define}の後ろにはマクロの名前が続き、次に略語の元であるはずのトークンシーケンスが来て、それはマクロの@dfn{本体}、@dfn{展開}や@dfn{置換リスト}などとして参照される。 例えば、

@smallexample
#define BUFFER_SIZE 1024
@end smallexample

@noindent
はトークン@code{1024}の略語として@code{BUFFER_SIZE}という名前のマクロを定義する。 この@samp{#define}ディレクティブの後のどこかに、以下の形のCステートメントが来たら

@smallexample
foo = (char *) malloc (BUFFER_SIZE);
@end smallexample

@noindent
Cプリプロセッサはマクロ@code{BUFFER_SIZE}を認識して@dfn{展開}する。 Cコンパイラは、以下のように書いたのと同じトークンを見るだろう。

@smallexample
foo = (char *) malloc (1024);
@end smallexample

慣例により、マクロ名は大文字で書かれている。 どの名前がマクロであるかを一目で確認することができるので、プログラムを読みやすくなる。

マクロの本体は@samp{#define}行の最後で終わる。 必要に応じて、バックスラッシュ改行を使用して複数の行に定義を続けることができる。 ただし、マクロを展開すると、すべて1行に出力される。 例えば、

@smallexample
#define NUMBERS 1, \
                2, \
                3
int x[] = @{ NUMBERS @};
     @expansion{} int x[] = @{ 1, 2, 3 @};
@end smallexample

@noindent
これの最も一般的な目に見える結果は、エラーメッセージの驚くべき行番号である。

有効なプリプロセストークンに分解されるならば、マクロ本体に何が入ることができるかに制限はない。 括弧はバランスを取る必要はなく、本体は有効なCコードに似る必要はない。 （そうでなければ、マクロを使用するとCコンパイラからエラーメッセージが出る可能性がある）。

Cプリプロセッサは、プログラムを順番にスキャンする。 マクロ定義は、作成した場所で有効になる。 したがって、Cプリプロセッサへの次の入力は

@smallexample
foo = X;
#define X 4
bar = X;
@end smallexample

@noindent
以下を生成する。

@smallexample
foo = X;
bar = 4;
@end smallexample

プリプロセッサがマクロ名を展開すると、そのマクロの展開がマクロの呼び出しを置き換え、次に展開されてより多くのマクロが展開される。 例えば、

@smallexample
@group
#define TABLESIZE BUFSIZE
#define BUFSIZE 1024
TABLESIZE
     @expansion{} BUFSIZE
     @expansion{} 1024
@end group
@end smallexample

@noindent
@code{TABLESIZE}は最初に展開されて@code{BUFSIZE}を生成し、そのマクロは最後の結果である@code{1024}を生成するように展開される。

@code{TABLESIZE}が定義されたときに、@code{BUFSIZE}が定義されていないことに注意せよ。 @code{TABLESIZE}の@samp{#define}は、指定した展開（この場合は@code{BUFSIZE}）をそのまま使用し、マクロ名が含まれているかどうかをチェックしない。 あなたが@code{TABLESIZE}を@emph{使った}ときだけ、その拡張の結果がより多くのマクロ名のためにスキャンされる。

これは、ソースファイルのある時点で@code{BUFSIZE}の定義を変更すると違いがある。 表示されているように定義された@code{TABLESIZE}は、現在有効な@code{BUFSIZE}の定義を使用して常に展開されます：

@smallexample
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
@end smallexample

@noindent
@code{TABLESIZE}は（2段階で）@code{37}に展開される。

マクロの展開に直接または中間のマクロを使用して自分の名前が含まれている場合は、さらにマクロの展開を調べるときには再び展開されまない。 これにより、無限の再帰が防止される。詳細は@xref{Self-Referential Macros}を参照せよ。

@node Function-like Macros
@section 関数風マクロ
@cindex function-like macros

関数呼び出しのように見えるマクロを定義することもできる。 これらは@dfn{関数風マクロ}と呼ばれる。 関数風マクロを定義するには、同じ@samp{#define}疑似命令を使用するが、マクロ名の直後に括弧を入れる。 例えば、

@smallexample
#define lang_init()  c_init()
lang_init()
     @expansion{} c_init()
@end smallexample

関数風マクロは、その名前の後ろに一対のカッコがある場合にのみ展開される。 名前だけを書くと、それは放置される。 これは、関数と同じ名前のマクロがあり、その関数を時々使用したいときに便利である。

@smallexample
extern void foo(void);
#define foo() /* @r{optimized inline version} */
@dots{}
  foo();
  funcptr = foo;
@end smallexample

ここで@code{foo()}の呼び出しはマクロを使用するが、関数ポインタは実関数のアドレスを取得する。 マクロを展開していたら、構文エラーが発生するだろう。

マクロ定義内のマクロ名とかっこの間にスペースを入れると、関数風マクロは定義されず、オブジェクト風マクロが定義される。そのマクロ展開はカッコで始まる。

@smallexample
#define lang_init ()    c_init()
lang_init()
     @expansion{} () c_init()()
@end smallexample

この展開の括弧の最初の2つのペアはマクロから来ている。 3番目はマクロ呼び出しの元々だったペアである。 @code{lang_init}はオブジェクト風マクロなので、それらの括弧は消費しない。

@node Macro Arguments
@section マクロ引数
@cindex arguments
@cindex macros with arguments
@cindex arguments in macro definitions

関数風マクロは、真の関数と同様に@dfn{引数}をとることができる。 引数を使用するマクロを定義するには、@dfn{パラメータ}をマクロ定義の中のカッコの間に挿入する。 パラメータは、オプションで空白を含むカンマで区切られた有効なC識別子でなければならない。

引数を取るマクロを呼び出すには、マクロ名の後ろに括弧内にコンマで区切られた@dfn{実際の引数}のリストを書く。 マクロの呼び出しは、単一の論理行に限定する必要はない。ソースファイル内の行数を自由に変更できる。 引数の数は、マクロ定義内のパラメータの数と一致する必要がある。 マクロが展開されると、本体の各パラメータの使用は、対応する引数のトークンに置き換えられる。 （マクロ本体ですべてのパラメータを使用する必要はない）。

たとえば、多くのCプログラムで定義されているように、2つの数値の最小値を計算するマクロと、いくつかの用途がある。

@smallexample
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
  x = min(a, b);          @expansion{}  x = ((a) < (b) ? (a) : (b));
  y = min(1, 2);          @expansion{}  y = ((1) < (2) ? (1) : (2));
  z = min(a + 28, *p);    @expansion{}  z = ((a + 28) < (*p) ? (a + 28) : (*p));
@end smallexample

@noindent
（この小さな例では、マクロ引数のいくつかの危険性を既に知ることができる。詳細は@xref{Macro Pitfalls}を参照せよ）。

各引数の先頭と末尾の空白は削除され、引数のトークン間の空白はすべて1つの空白に縮小される。 各引数の中のカッコは均衡していなければならない。 そのようなカッコ内のカンマは引数を終了しない。 ただし、角括弧または中括弧がバランスする必要はなく、カンマで引数を区切ることも防がない。 したがって、

@smallexample
macro (array[x = y, x + 1])
@end smallexample

@noindent
は@code{array[x = y}と@code{x + 1]}の2つの引数を@code{macro}に渡す。 引数として@code{array[x = y, x + 1]}を指定したい場合は、等価のCコードである@code{array[(x = y, x + 1)]}と書くことができる。

マクロへのすべての引数は、マクロ本体に代入される前に完全にマクロ展開される。 置換後、引数を含むマクロが展開されるように、テキスト全体が再度スキャンされる。 このルールは奇妙に見えるかもしれないが、注意深く設計されているので、関数呼び出しが実際にマクロ呼び出しであるかどうかを心配する必要はない。しかし、あなたはあまりにも賢くなろうとすると、困ってしまうことがある。 詳細は@xref{Argument Prescan}を参照せよ。

例えば、@code{min (min (a, b), c)}は最初に

@smallexample
  min (((a) < (b) ? (a) : (b)), (c))
@end smallexample

@noindent
へと展開され、それから以下のように展開される

@smallexample
@group
((((a) < (b) ? (a) : (b))) < (c)
 ? (((a) < (b) ? (a) : (b)))
 : (c))
@end group
@end smallexample

@noindent
（分かりやすくするため、ここに示した改行は実際には生成されない）。

@cindex empty macro arguments
マクロ引数は空のままにすることができる。 これはプリプロセッサのエラーではない（ただし、多くのマクロは無効なコードに展開される）。引数を完全に省略することはできない。 マクロが2つの引数を取る場合は、その引数リストの最上位に1つのカンマが正確になければならない。 @code{min}を使ったいくつかのばかげた例がある：

@smallexample
min(, b)        @expansion{} ((   ) < (b) ? (   ) : (b))
min(a, )        @expansion{} ((a  ) < ( ) ? (a  ) : ( ))
min(,)          @expansion{} ((   ) < ( ) ? (   ) : ( ))
min((,),)       @expansion{} (((,)) < ( ) ? ((,)) : ( ))

min()      @error{} macro "min" requires 2 arguments, but only 1 given
min(,,)    @error{} macro "min" passed 3 arguments, but takes just 2
@end smallexample

空白はプリプロセストークンではないので、マクロ@code{foo}が1つの引数を取る場合、@code{@w{foo ()}}と@code{@w{foo ( )}}は空の引数を与える。 以前のGNUプリプロセッサの実装とドキュメントは、この時点では間違っていた。空の引数が必要な場合には、単一の引数を取る関数型マクロがスペースを渡すことを主張していた。

文字列リテラル内に現れるマクロパラメータは、対応する実際の引数に置き換えられない。

@smallexample
#define foo(x) x, "x"
foo(bar)        @expansion{} bar, "x"
@end smallexample

@node Stringizing
@section 文字列化
@cindex stringizing
@cindex @samp{#} operator

場合によっては、マクロ引数を文字列定数に変換することができる。 パラメータは文字列定数内では置き換えられないが、代わりに@samp{#}プリプロセス演算子を使用することができる。 @samp{＃}の後ろにマクロパラメータを使用すると、プリプロセッサはそれを実際の引数のリテラルテキストに置き換え、文字列定数に変換する。 通常のパラメータ置換とは異なり、引数は最初にマクロ展開されない。 これは@dfn{文字列化}と呼ばれる。

引数を周囲のテキストと組み合わせて、それをすべて一緒に文字列化する方法はない。 代わりに、一連の隣接する文字列定数と文字列化された引数を書くことができる。 プリプロセッサは文字列化された引数を文字列定数に置き換える。 次に、Cコンパイラは、隣接するすべての文字列定数を1つの長い文字列に結合する。

文字列化を使用するマクロ定義の例を次に示す。

@smallexample
@group
#define WARN_IF(EXP) \
do @{ if (EXP) \
        fprintf (stderr, "Warning: " #EXP "\n"); @} \
while (0)
WARN_IF (x == 0);
     @expansion{} do @{ if (x == 0)
           fprintf (stderr, "Warning: " "x == 0" "\n"); @} while (0);
@end group
@end smallexample

@noindent
@code{EXP}の引数は、現状の@code{if}文に一度代入され、一度文字列化されて@code{fprintf}の引数に代入される。 @code{x}がマクロの場合、@code{if}文で展開されるが、文字列には展開されない。

@code{do}と@code{while(0)}は、@code{WARN_IF}をCプログラマが望んでいるであろう関数と似せるように、@code{WARN_IF (@var{arg});}と書くことを可能にするための厄介なものである。 @ref{Swallowing the Semicolon}を参照せよ。

Cでの文字列化は、フラグメントの前後に二重引用符を入れること以上のことである。 プリプロセッサは、適切な内容の有効なC文字列定数を得るために、埋め込み文字列定数を囲む引用符と、文字列定数と文字定数の中のすべてのバックスラッシュをバックスラッシュでエスケープする。 したがって、@code{@w{p = "foo\n";}}の文字列化は@t{@w{"p = \"foo\\n\";"}}になる。 しかし、文字列や文字定数の中にいないバックスラッシュは複製されない。@samp{\n}自体は@t{"\n"}に文字列化される。

文字列化されたテキストの先頭と末尾のすべての空白は無視される。 テキストの途中の空白のシーケンスは、文字列化された結果の単一のスペースに変換される。 コメントは、文字列化が起こるずっと前に空白文字に置き換えられているので、文字列化されたテキストには表示されない。

マクロ引数を文字定数に変換する方法はない。

マクロ引数の展開結果を文字列化する場合は、2つのレベルのマクロを使用する必要がある。

@smallexample
#define xstr(s) str(s)
#define str(s) #s
#define foo 4
str (foo)
     @expansion{} "foo"
xstr (foo)
     @expansion{} xstr (4)
     @expansion{} str (4)
     @expansion{} "4"
@end smallexample

@code{s}は@code{str}で使用されているときには文字列化されているため、最初にマクロ展開されない。 しかし、@code{s}は@code{xstr}の普通の引数なので、@code{xstr}自体が展開される前に完全にマクロ展開される（@pxref{Argument Prescan}）。 したがって、@code{str}がその引数に到達するまでには、すでにマクロ展開されている。

@node Concatenation
@section 連結
@cindex concatenation
@cindex token pasting
@cindex token concatenation
@cindex @samp{##} operator

マクロを展開しながら2つのトークンを1つにマージすると便利なことがよくある。 これは@dfn{トークン貼り付け}または@dfn{トークン連結}と呼ばれる。 @samp{##}プリプロセス演算子は、トークン貼り付けを実行する。 マクロが展開されると、各@samp{##}演算子の両側にある2つのトークンが1つのトークンに結合され、@samp{##}と2つの元のトークンがマクロ展開に置き換えられる。 通常、どちらも識別子である。さもなければ一方は識別子になり、もう一方はプリプロセス番号になる。 ペーストすると、より長い識別子が作成される。これは唯一の有効なケースではない。 2つの数字（または@code{1.5}や@code{e3}などの数字と名前）を数字に連結することもできる。 また、@code{+=}のような複数文字の演算子は、トークンの貼り付けによって形成することができる。

ただし、一緒に有効なトークンを構成しない2つのトークンを貼り付けることはできない。 たとえば、@code{x}をどちらの順序でも@code{+}に連結することはできない。 試行すると、プリプロセッサは警告を出して2つのトークンを発行する。 トークン間に空白を入れるかどうかは不定である。 複雑なマクロで@samp {##}を不必要に使用するのはよくあることである。 この警告が表示された場合は、単に@samp{##}を削除することができる。

@samp{##}で結合されたトークンはどちらもマクロ本体から来る可能性があるが、最初のトークンとして書き込むこともできる。 トークンの貼り付けは、トークンの一方または両方がマクロ引数から来た場合に最も便利である。 @samp{##}の隣にあるトークンのいずれかがパラメータ名である場合、@samp{##}が実行される前にその実際の引数に置き換えられる。 文字列化の場合と同様に、実際の引数は最初にマクロ展開されない。 引数が空の場合、@samp{##}は効果がない。

Cプリプロセッサは、マクロが考慮される前にコメントを空白に変換することに注意せよ。 したがって、@samp{/}と@samp {*}を連結してコメントを作成することはできない。 @samp{##}とそのオペランドの間に、コメントを含めてたくさんの空白を入れることができる。また、連結する引数にコメントを入れることができる。 しかし、@samp{##}がマクロ本体のどちらかの端に現れるとエラーになる。

名前付きコマンドを解釈するCプログラムを考える。 おそらく、次のように宣言された構造体の配列のようなコマンドの表が必要である。

@smallexample
@group
struct command
@{
  char *name;
  void (*function) (void);
@};
@end group

@group
struct command commands[] =
@{
  @{ "quit", quit_command @},
  @{ "help", help_command @},
  @dots{}
@};
@end group
@end smallexample

各コマンド名を文字列定数に1回、関数名に1回ずつ指定する必要はない。 コマンドの名前を引数とするマクロは、これを不要にすることができる。 文字列定数は文字列で作成でき、関数名は引数を@samp{_command}で連結して作成できる。 ここでそれが行われるやり方である：

@smallexample
#define COMMAND(NAME)  @{ #NAME, NAME ## _command @}

struct command commands[] =
@{
  COMMAND (quit),
  COMMAND (help),
  @dots{}
@};
@end smallexample

@node Variadic Macros
@section 可変長マクロ
@cindex variable number of arguments
@cindex macros with variable arguments
@cindex variadic macros

マクロは関数のように可変長の引数を受け入れるように宣言することができる。 マクロを定義する構文は、関数の構文に似ている。 次に例を示す。

@smallexample
#define eprintf(@dots{}) fprintf (stderr, __VA_ARGS__)
@end smallexample

この種のマクロは@dfn{可変長}と呼ばれる。 マクロが呼び出されると、最後に指定された引数（このマクロではなし）の後の引数リストのすべてのトークンは、カンマを含めて@dfn{可変引数}になる。 この一連のトークンは、マクロ本体の識別子@code{@w{__VA_ARGS__}}をどこにでも置き換える。 したがって、私たちはこのように展開する：

@smallexample
eprintf ("%s:%d: ", input_file, lineno)
     @expansion{}  fprintf (stderr, "%s:%d: ", input_file, lineno)
@end smallexample

可変引数は、通常の引数と同様に、マクロ展開に挿入される前に完全にマクロ展開される。 @samp{#}と@samp{##}演算子を使用して可変引数を文字列化するか、先頭または末尾のトークンを別のトークンに貼り付けることができる。 （しかし、@samp{##}の重要な特別なケースについては以下を参照せよ）。

マクロが複雑な場合は、@code{@w{__VA_ARGS__}}よりも可変引数の方がわかりやすい名前が必要な場合がある。 CPPはこれを拡張として許可する。 @samp{@dots{}}の直前に引数名を書くことができる。 その名前は可変引数に使用される。 上記の@code{eprintf}マクロをこの拡張で次のように書くことができる。

@smallexample
#define eprintf(args@dots{}) fprintf (stderr, args)
@end smallexample

@noindent
同じマクロで@code{@w{__VA_ARGS__}}とこの拡張を使うことはできない。

可変引数マクロで可変引数だけでなく名前付き引数もを持つことができる。 代わりに以下のように@code {eprintf}を定義することができる：

@smallexample
#define eprintf(format, @dots{}) fprintf (stderr, format, __VA_ARGS__)
@end smallexample

@noindent
この定式化はよりわかりやすいように見えるが、歴史的には柔軟性がより少なかった。書式文字列の後に少なくとも1つの引数を指定する必要があった。 標準Cでは、名前付き引数と可変引数を区切るカンマを省略できなかった。 （この制限はC++2aで解消されていて、GNU Cには存在しなかったことに注意せよ;下記参照）。

さらに、可変引数を空のままにしておくと、書式文字列の後に余分なカンマがあるため、構文エラーが発生する。

@smallexample
eprintf("success!\n", );
     @expansion{} fprintf(stderr, "success!\n", );
@end smallexample

これはC++2aで修正されていて、GNU CPPにもこの問題に対処する拡張機能がある。

まず、GNU CPPとC++2aで始まるC++では、可変引数を完全に空にしておくことができる：

@smallexample
eprintf ("success!\n")
     @expansion{} fprintf(stderr, "success!\n", );
@end smallexample

@noindent
次に、C++2aは@code{@w{__VA_OPT__}}関数マクロを導入した。 このマクロは、可変長マクロの定義にのみ現れる。 変数の引数にトークンがある場合、@code{@w{__VA_OPT__}}の呼び出しは引数に展開される。 可変引数にトークンがない場合、@code{@w{__VA_OPT__}}は何も展開しない：

@smallexample
#define eprintf(format, @dots{}) \
  fprintf (stderr, format __VA_OPT__(,) __VA_ARGS__)
@end smallexample

@code{@w{__VA_OPT__}}は、GNU CとGNU C++でも利用できる。

歴史的に、GNU CPPには、後続のカンマを扱うための別の拡張もあった。@samp{##}トークンペースト演算子は、コンマと可変引数の間に置かれたときに特別な意味を持つ。 @code{@w{__VA_OPT__}}の導入にもかかわらず、この拡張機能は下位互換性のためにGNU CPPでサポートされている。 こう書くなら

@smallexample
#define eprintf(format, @dots{}) fprintf (stderr, format, ##__VA_ARGS__)
@end smallexample

@noindent
そして@code{eprintf}マクロが使用されているときに可変引数が指定されていない場合、@samp{##}の前のコンマは削除される。 空の引数を渡すなら起こ@emph{らず}、@samp{##}の前のトークンがカンマ以外の場合も起こらない。

@smallexample
eprintf ("success!\n")
     @expansion{} fprintf(stderr, "success!\n");
@end smallexample

@noindent
上記の説明は、引数が空の引数か欠けている引数かを区別しようとする意味がないので、唯一のマクロパラメータが可変の引数パラメータである場合についてはあいまいである。 CPPは特定のC標準に準拠している場合はカンマを保持する。 それ以外の場合は、標準への拡張子としてカンマが削除される。

Cの標準では、識別子@code{@w{__ VA_ARGS__}}が現れる唯一の場所は可変長マクロの置換リストにあることを要求している。 マクロ名、マクロ引数名、または別の種類のマクロ内で使用することはできない。 オープンテキストでも禁止されているかもしれない。 標準はあいまいである。 定義された目的以外には使用しないことを推奨する。

同様に、C ++は可変長マクロの置換リストの外のどこにでも@code{@w {__ VA_OPT__}}を禁じる。

可変長マクロは、C99のC言語の標準部分になった。 GNU CPPはこれまで、@samp{@dots {}}や@code{@w{__ VA_ARGS__}}ではなく、名前の変更可能な引数（@samp{args @dots{}}）をサポートしていた。

@node Predefined Macros
@section 定義済みマクロ

@cindex predefined macros
いくつかのオブジェクト風マクロがあらかじめ定義されている。 定義を提供せずにそれらを使用する。 標準、共通、システム固有の3つのクラスに分類される。

C++には、名前付き演算子の4つ目のカテゴリがある。 定義済みマクロのように動作するが、マクロを定義解除することはできない。

@menu
* Standard Predefined Macros::
* Common Predefined Macros::
* System-specific Predefined Macros::
* C++ Named Operators::
@end menu

@node Standard Predefined Macros
@subsection 標準の定義済みマクロ
@cindex standard predefined macros.

標準の定義済みマクロは、関連する言語標準によって指定されているため、これらの標準を実装するすべてのコンパイラで使用できる。 古いコンパイラはそれらのすべてを提供するわけではない。 それらの名前はすべて二重のアンダースコアで始まる。

@table @code
@item __FILE__
このマクロは、Cの文字列定数の形で現在の入力ファイルの名前に展開される。 これは、プリプロセッサが@samp{#include}で指定された短い名前ではなく、入力ファイル名の引数としてファイルを開いたパスである。 たとえば、このマクロの拡張子は@code{"/usr/local/include/myheader.h"}である。

@item __LINE__
このマクロは、現在の入力行番号に10進整数定数の形式で展開される。 定義済みマクロと呼ばれているが、新しい定義のソースコードごとに「定義」が変わるので、かなり奇妙なマクロである。
@end table

@code{__FILE__}と@code{__LINE__}は、プログラムによって検出された不一致を報告するエラーメッセージを生成するのに便利である。 メッセージは、矛盾が検出されたソース行を示すことができる。 例えば、

@smallexample
fprintf (stderr, "Internal error: "
                 "negative string length "
                 "%d at %s, line %d.",
         length, __FILE__, __LINE__);
@end smallexample

@samp{#include}ディレクティブはインクルードされたファイルに対応するように@code{__FILE__}と@code {__LINE__}の展開を変更する。 そのファイルの最後に@samp{#include}ディレクティブを含む入力ファイルで処理が再開されると、@code{__FILE__}と@code{__LINE__}の展開が@samp{#include}の前に戻される。（しかし@code{__ LINE__}は@samp {#include}の後の行に処理が移るにつれて1だけインクリメントされる）。

@samp{#line}ディレクティブは@code{__LINE__}を変更し、@code{__ FILE__}も変更する可能性がある。@xref{Line Control}。

C99は@code{__func__}を導入し、GCCは@code{__FUNCTION__}を長年提供している。 どちらも現在の関数の名前を含む文字列である（わずかな意味の違いがある; GCCのマニュアルを参照せよ）。 どちらもマクロではない。 プリプロセッサは現在の関数の名前を知らない。 しかし、@code{__ FILE__}や@code {__ LINE__}と組み合わせて使うと便利である。

@table @code

@item __DATE__
このマクロは、プリプロセッサが実行されている日付を表す文字列定数に展開される。 文字列定数は11文字を含み、@code{@w{"Feb 12 1996"}}のように見える。 月の日が10未満の場合は、左側のスペースが埋められる。

GCCが現在の日付を判断できない場合、警告メッセージが表示され（コンパイルごとに1回）、@code{__DATE__}は{@w{"??? ?? ????"}}に展開される。

@item __TIME__
このマクロは、プリプロセッサが実行されている時間を表す文字列定数に展開される。 文字列定数は8文字を含み、@code{"23:59:01"}のように見える。

GCCが現在の時刻を判断できない場合、警告メッセージ（コンパイルごとに1回）が出力され、@code{__TIME__}は@code{"??:??:??"}に展開される。

@item __STDC__
通常の操作では、このマクロは定数1に展開され、このコンパイラがISO標準Cに準拠していることを示す。 GCC以外のコンパイラでGNU CPPを使用する場合、これは必ずしも真実ではない。 ただし、@option{-traditional-cpp}オプションを使用しない限り、プリプロセッサは常に標準に準拠している。

このマクロは、@option {-traditional-cpp}オプションが使用されている場合は定義されていない。

一部のホストでは、システムコンパイラは@code{__ STDC__}が通常0である別の規則を使用するが、ユーザーがC標準に厳密に準拠していると指定した場合は1になる。 CPPはシステムのヘッダファイルを処理する際にホスト規約に従うが、ユーザファイルの処理時には@code{__STDC__}は常に1である。これは問題を引き起こすと報告されている。 たとえば、Solarisの一部のバージョンでは、@code{__ STDC__}が未定義または1であると予想されるX Windowsヘッダを提供している。 @xref{Invocation}.

@item __STDC_VERSION__
このマクロは、@code{@var{yyyy}@var{mm}L}という形式の長い整数定数であるC標準のバージョン番号に展開される。ここで、@var{yyyy}と@var{mm}は標準バージョンの年と月である。 これは、コンパイラが準拠しているC標準のバージョンを示している。 @code{__STDC__}と同様、GCCでGNU CPPを使用していない限り、実装全体では必ずしも正確ではない。

値@code{199409L}は、1994年に修正された1989 C標準を意味し、現在のデフォルトである。 値@code{199901L}は1999年のC標準の改訂を意味する。 値@code{201112L}はC標準の2011改訂版を表している。 値@code{201710L}は、C標準の2017改訂版を表す（欠陥の修正以外では2011年版と同じである）。

このマクロは、@option{-traditional-cpp}オプションが使用されている場合、またはC++またはObjective-Cのコンパイル時には定義されない。

@item __STDC_HOSTED__
コンパイラのターゲットが@dfn{ホスト環境}の場合、このマクロは値1で定義される。 ホスト環境には、標準Cライブラリの完全な機能がある。

@item __cplusplus
このマクロは、C++コンパイラが使用されているときに定義される。 @code{__ cplusplus}を使用して、ヘッダがCコンパイラとC++コンパイラのどちらによってコンパイルされているかどうかをテストすることができる。 このマクロは、バージョン番号に展開される点で@code{__STDC_VERSION__}に似ている。 選択された言語標準に応じて、マクロの値は、1998 C++標準の場合は@code{199711L}、2011 C++標準の場合は@code{201103L}、2014 C++標準の場合は@code{201402L}、2017 C++標準の場合は@code{201703L }、または@option {-std=c++2a}および@option{-std=gnu++2a}で有効になっている実験的言語の場合は、@code{201703L}より厳密に大きい不特定の値である。

@item __OBJC__
Objective-Cコンパイラが使用されている場合、このマクロは値1で定義される。 @code{__OBJC__}を使用して、ヘッダがCコンパイラとObjective-Cコンパイラのどちらによってコンパイルされているかどうかをテストすることができる。

@item __ASSEMBLER__
このマクロは、アセンブリ言語をプリプロセスするときに値1で定義される。

@end table

@node Common Predefined Macros
@subsection 共通定義済みマクロ
@cindex common predefined macros

一般的に定義されているマクロはGNU Cの拡張である。 それらは、GNU CまたはGNU Fortranを使用しているマシンまたはオペレーティングシステムに関係なく、同じ意味で使用できる。 それらの名前はすべて二重のアンダースコアで始まる。

@table @code

@item __COUNTER__
このマクロは0から始まる連続整数値に展開される。これは@code{##}演算子と組み合わせて、一意の識別子を生成する便利な手段を提供する。 @code{__ COUNTER__}がそれを使用するプリコンパイルされたヘッダをインクルードする前に展開されないように注意する必要がある。 そうしないと、プリコンパイルされたヘッダーは使用されない。

@item __GFORTRAN__
GNU Fortranコンパイラはこれを定義している。

@item __GNUC__
@itemx __GNUC_MINOR__
@itemx __GNUC_PATCHLEVEL__
これらのマクロは、Cプリプロセッサを使用するすべてのGNUコンパイラ、C、C++、Objective-C、Fortranで定義されている。 それらの値は、整数定数として、コンパイラのメジャーバージョン、マイナーバージョン、およびパッチレベルである。 たとえば、GCCのバージョン@var{x}.@var{y}.@ var{z}は@code{__GNUC__}を@var{x}に、@code{__GNUC_MINOR__}を@var{y}に、@code{__GNUC_PATCHLEVEL__}を@var {z}に変換する。 これらのマクロは、プリプロセッサを直接呼び出す場合にも定義される。

あなたのプログラムがGCCかGNU Cの方言を受け入れると主張するGCC以外のコンパイラによってコンパイルされているかどうかを知る必要がある場合は、単に@code{__GNUC__}をテストできる。 特定のバージョンに依存するコードを記述する必要がある場合は、さらに注意する必要がある。 マイナーバージョンを増やすたびに、パッチレベルはゼロにリセットされる。 メジャーバージョンを増やすたびに、マイナーバージョンとパッチレベルがリセットされる。 条件付きマクロで直接使用する場合は、次のように記述する必要がある。

@smallexample
/* @r{Test for GCC > 3.2.0} */
#if __GNUC__ > 3 || \
    (__GNUC__ == 3 && (__GNUC_MINOR__ > 2 || \
                       (__GNUC_MINOR__ == 2 && \
                        __GNUC_PATCHLEVEL__ > 0))
@end smallexample

@noindent
もう1つのアプローチは、あらかじめ定義されたマクロを使用して1つの数値を計算し、それをしきい値と比較することである。

@smallexample
#define GCC_VERSION (__GNUC__ * 10000 \
                     + __GNUC_MINOR__ * 100 \
                     + __GNUC_PATCHLEVEL__)
@dots{}
/* @r{Test for GCC > 3.2.0} */
#if GCC_VERSION > 30200
@end smallexample

@noindent
多くの人がこのフォームを理解しやすくしている。

@item __GNUG__
GNU C++コンパイラはこれを定義している。 これをテストすることは、@code{@w{(__GNUC__ && __cplusplus)}}をテストするのと同じである。

@item __STRICT_ANSI__
GCCが呼び出されたときに、@option{-ansi}スイッチ、またはISO CまたはISO C++のいくつかのバージョンに厳密に準拠している@option{-std}スイッチが指定されている場合にのみ、このマクロが定義される。 @samp{1}と定義されている。 このマクロは、主にGNU libcのヘッダファイルに標準Cで定義されている定義のみを使用するように指示する。

@item __BASE_FILE__
このマクロは、Cの文字列定数の形式でメイン入力ファイルの名前に展開される。 これは、プリプロセッサまたはCコンパイラのコマンドラインで指定されたソースファイルである。

@item __INCLUDE_LEVEL__
このマクロは、インクルードファイルのネストの深さを表す10進整数定数に展開される。 このマクロの値は、@samp{#include}指令ごとにインクリメントされ、インクルードされているファイルの最後にデクリメントされる。 コマンドラインで指定されたベースファイル内の値0から開始する。

@item __ELF__
このマクロは、ターゲットがELFオブジェクト形式を使用する場合に定義される。

@item __VERSION__
このマクロは、使用中のコンパイラのバージョンを示す文字列定数に展開される。 値が特定の形式を持つ内容であるち頼るべきではないが、少なくともリリース番号を含れているだろう。

@item __OPTIMIZE__
@itemx __OPTIMIZE_SIZE__
@itemx __NO_INLINE__
これらのマクロは、コンパイルモードを表している。 @code{__OPTIMIZE__}はすべての最適化コンパイルで定義されている。 @code{__OPTIMIZE_SIZE__}は、コンパイラが速度ではなくサイズを最適化する場合に定義される。 @code{__NO_INLINE__}は、呼び出し元に関数がインライン化されない場合（最適化されていない場合、または@option{-fno-inline}によってインライン展開が特に無効になっている場合）に定義される。

これらのマクロは、特定のGNUヘッダファイルに、システムライブラリ関数のマクロまたはインライン関数を使って最適化された定義を提供する。 これらのマクロは、プログラムが定義されているかどうかにかかわらず同じ効果で実行されることを確認しない限り、使用するべきではない。 定義されている場合、その値は1である。

@item __GNUC_GNU_INLINE__
GCCは、@code{inline}と宣言された関数がGCCの伝統的なgnu90モードで扱われるなら、このマクロを定義する。 オブジェクトファイルには、@code{extern}や@code{static}を使わずに、@code{inline}で宣言されたすべての関数の外部で定義された定義が含まれる。 @code{extern inline}と宣言された関数の定義は含まれない。

@item __GNUC_STDC_INLINE__
GCCは、@code{inline}と宣言された関数がISO C99以降の規格に従って処理される場合、このマクロを定義する。 オブジェクトファイルには、@code{extern inline}と宣言されたすべての関数の外部から見える定義が含まれる。 @code{extern}なしで@code{inline}と宣言された関数の定義は含まれない。

このマクロが定義されている場合、GCCは常にgnu90の動作を得るための@code{gnu_inline}関数属性をサポートしている。

@item __CHAR_UNSIGNED__
GCCは、データ型@code{char}がターゲットマシン上で符号なしである場合に限り、このマクロを定義する。 これは、標準のヘッダファイル@file{limits.h}を正しく動作させるために存在する。 このマクロは自分で使用するべきではない。 代わりに、@file{limits.h}で定義された標準マクロを参照すること。

@item __WCHAR_UNSIGNED__
@code{__ CHAR_UNSIGNED__}のように、このマクロはデータ型@code{wchar_t}が符号なしで、フロントエンドがC++モードの場合にのみ定義される。

@item __REGISTER_PREFIX__
このマクロは、このターゲットのアセンブリ言語でCPUレジスタ名に適用される接頭辞である単一のトークン（文字列定数ではない）に展開される。 これを使用して、複数の環境で使用可能なアセンブリを記述できる。 たとえば、@code{m68k-aout}環境では何も展開されないが、@code{m68k-coff}環境では単一の@samp{％}に展開される。

@item __USER_LABEL_PREFIX__
このマクロは、アセンブリ内のユーザーラベル（Cコードから見えるシンボル）に適用されるプレフィックスである単一のトークンに展開される。 たとえば、@code{m68k-aout}環境では@samp {_}に展開されるが、@code{m68k-coff}環境では何も展開されない。

このマクロは、@option{-f(no-)underscores}が使用されていても正しい定義を持つが、この接頭辞を調整するターゲット固有のオプションが使用されていると正しくない（例えば：OSF/rose @option{-mno-underscores}オプション）。

@item __SIZE_TYPE__
@itemx __PTRDIFF_TYPE__
@itemx __WCHAR_TYPE__
@itemx __WINT_TYPE__
@itemx __INTMAX_TYPE__
@itemx __UINTMAX_TYPE__
@itemx __SIG_ATOMIC_TYPE__
@itemx __INT8_TYPE__
@itemx __INT16_TYPE__
@itemx __INT32_TYPE__
@itemx __INT64_TYPE__
@itemx __UINT8_TYPE__
@itemx __UINT16_TYPE__
@itemx __UINT32_TYPE__
@itemx __UINT64_TYPE__
@itemx __INT_LEAST8_TYPE__
@itemx __INT_LEAST16_TYPE__
@itemx __INT_LEAST32_TYPE__
@itemx __INT_LEAST64_TYPE__
@itemx __UINT_LEAST8_TYPE__
@itemx __UINT_LEAST16_TYPE__
@itemx __UINT_LEAST32_TYPE__
@itemx __UINT_LEAST64_TYPE__
@itemx __INT_FAST8_TYPE__
@itemx __INT_FAST16_TYPE__
@itemx __INT_FAST32_TYPE__
@itemx __INT_FAST64_TYPE__
@itemx __UINT_FAST8_TYPE__
@itemx __UINT_FAST16_TYPE__
@itemx __UINT_FAST32_TYPE__
@itemx __UINT_FAST64_TYPE__
@itemx __INTPTR_TYPE__
@itemx __UINTPTR_TYPE__
これらのマクロは、それぞれ
These macros are defined to the correct underlying types for the
@code{size_t}, @code{ptrdiff_t}, @code{wchar_t}, @code{wint_t},
@code{intmax_t}, @code{uintmax_t}, @code{sig_atomic_t}, @code{int8_t},
@code{int16_t}, @code{int32_t}, @code{int64_t}, @code{uint8_t},
@code{uint16_t}, @code{uint32_t}, @code{uint64_t},
@code{int_least8_t}, @code{int_least16_t}, @code{int_least32_t},
@code{int_least64_t}, @code{uint_least8_t}, @code{uint_least16_t},
@code{uint_least32_t}, @code{uint_least64_t}, @code{int_fast8_t},
@code{int_fast16_t}, @code{int_fast32_t}, @code{int_fast64_t},
@code{uint_fast8_t}, @code{uint_fast16_t}, @code{uint_fast32_t},
@code{uint_fast64_t}, @code{intptr_t}, @code{uintptr_t}のtypedefの正しい基本タイプに定義されている。@file{stddef.h}、@file{stdint.h}、@file{wchar.h}の標準ヘッダファイルを正しく動作させるために存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを組み込み、typedefを使用すること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __CHAR_BIT__
@code{char}データ型の表現に使用されるビット数で定義される。 数値制限が与えられた標準ヘッダーを正しく動作させるために存在する。 このマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。

@item __SCHAR_MAX__
@itemx __WCHAR_MAX__
@itemx __SHRT_MAX__
@itemx __INT_MAX__
@itemx __LONG_MAX__
@itemx __LONG_LONG_MAX__
@itemx __WINT_MAX__
@itemx __SIZE_MAX__
@itemx __PTRDIFF_MAX__
@itemx __INTMAX_MAX__
@itemx __UINTMAX_MAX__
@itemx __SIG_ATOMIC_MAX__
@itemx __INT8_MAX__
@itemx __INT16_MAX__
@itemx __INT32_MAX__
@itemx __INT64_MAX__
@itemx __UINT8_MAX__
@itemx __UINT16_MAX__
@itemx __UINT32_MAX__
@itemx __UINT64_MAX__
@itemx __INT_LEAST8_MAX__
@itemx __INT_LEAST16_MAX__
@itemx __INT_LEAST32_MAX__
@itemx __INT_LEAST64_MAX__
@itemx __UINT_LEAST8_MAX__
@itemx __UINT_LEAST16_MAX__
@itemx __UINT_LEAST32_MAX__
@itemx __UINT_LEAST64_MAX__
@itemx __INT_FAST8_MAX__
@itemx __INT_FAST16_MAX__
@itemx __INT_FAST32_MAX__
@itemx __INT_FAST64_MAX__
@itemx __UINT_FAST8_MAX__
@itemx __UINT_FAST16_MAX__
@itemx __UINT_FAST32_MAX__
@itemx __UINT_FAST64_MAX__
@itemx __INTPTR_MAX__
@itemx __UINTPTR_MAX__
@itemx __WCHAR_MIN__
@itemx __WINT_MIN__
@itemx __SIG_ATOMIC_MIN__
@code{signed char}, @code{wchar_t}, @code{signed short},
@code{signed int}, @code{signed long}, @code{signed long long},
@code{wint_t}, @code{size_t}, @code{ptrdiff_t},
@code{intmax_t}, @code{uintmax_t}, @code{sig_atomic_t}, @code{int8_t},
@code{int16_t}, @code{int32_t}, @code{int64_t}, @code{uint8_t},
@code{uint16_t}, @code{uint32_t}, @code{uint64_t},
@code{int_least8_t}, @code{int_least16_t}, @code{int_least32_t},
@code{int_least64_t}, @code{uint_least8_t}, @code{uint_least16_t},
@code{uint_least32_t}, @code{uint_least64_t}, @code{int_fast8_t},
@code{int_fast16_t}, @code{int_fast32_t}, @code{int_fast64_t},
@code{uint_fast8_t}, @code{uint_fast16_t}, @code{uint_fast32_t},
@code{uint_fast64_t}, @code{intptr_t}, @code{uintptr_t}の型の最大値と、@code{wchar_t}, @code{wint_t}, 
@code {sig_atomic_t}の最大値と最小値にそれぞれ定義されている。 数値制限が与えられた標準ヘッダを正しく動作させるために存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __INT8_C
@itemx __INT16_C
@itemx __INT32_C
@itemx __INT64_C
@itemx __UINT8_C
@itemx __UINT16_C
@itemx __UINT32_C
@itemx __UINT64_C
@itemx __INTMAX_C
@itemx __UINTMAX_C
先行する@code{__}のない同じ名前の標準の@file{stdint.h}マクロの実装に定義されている。 それらは、そのヘッダーの実装が正しく動作するように存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __SCHAR_WIDTH__
@itemx __SHRT_WIDTH__
@itemx __INT_WIDTH__
@itemx __LONG_WIDTH__
@itemx __LONG_LONG_WIDTH__
@itemx __PTRDIFF_WIDTH__
@itemx __SIG_ATOMIC_WIDTH__
@itemx __SIZE_WIDTH__
@itemx __WCHAR_WIDTH__
@itemx __WINT_WIDTH__
@itemx __INT_LEAST8_WIDTH__
@itemx __INT_LEAST16_WIDTH__
@itemx __INT_LEAST32_WIDTH__
@itemx __INT_LEAST64_WIDTH__
@itemx __INT_FAST8_WIDTH__
@itemx __INT_FAST16_WIDTH__
@itemx __INT_FAST32_WIDTH__
@itemx __INT_FAST64_WIDTH__
@itemx __INTPTR_WIDTH__
@itemx __INTMAX_WIDTH__
対応する型のビット幅に定義される。 @file{limits.h}と@file{stdint.h}の実装を正しく動作させるために存在する。 これらのマクロは直接使用するべきではない。 代わりに、適切なヘッダーを含めること。 GCCがこれらのシステムで@file{stdint.h}ヘッダーを提供しない場合、これらのマクロの一部は特定のシステムで定義されないことがある。

@item __SIZEOF_INT__
@itemx __SIZEOF_LONG__
@itemx __SIZEOF_LONG_LONG__
@itemx __SIZEOF_SHORT__
@itemx __SIZEOF_POINTER__
@itemx __SIZEOF_FLOAT__
@itemx __SIZEOF_DOUBLE__
@itemx __SIZEOF_LONG_DOUBLE__
@itemx __SIZEOF_SIZE_T__
@itemx __SIZEOF_WCHAR_T__
@itemx __SIZEOF_WINT_T__
@itemx __SIZEOF_PTRDIFF_T__
C標準データ型のバイト数を定義する。 @code{int},
@code{long}, @code{long long}, @code{short}, @code{void *}, @code{float},
@code{double}, @code{long double}, @code{size_t}, @code{wchar_t}, @code{wint_t}, @code{ptrdiff_t}.

@item __BYTE_ORDER__
@itemx __ORDER_LITTLE_ENDIAN__
@itemx __ORDER_BIG_ENDIAN__
@itemx __ORDER_PDP_ENDIAN_
@code{__BYTE_ORDER__}は、メモリ内のマルチバイトおよびマルチワード量のレイアウトを反映するために、@code{__ORDER_LITTLE_ENDIAN__}、@code{__ORDER_BIG_ENDIAN__}、または@code{__ORDER_PDP_ENDIAN__}のいずれかの値に定義されている。 @code{__BYTE_ORDER__}が@code{__ORDER_LITTLE_ENDIAN__}または@code{__ORDER_BIG_ENDIAN__}と等しい場合、マルチバイト数とマルチワード数は同じように配置される。最下位アドレスのバイト（ワード）は、量の最下位バイトまたは最上位バイト（ワード）である。@code {__ BYTE_ORDER__}が@code {__ ORDER_PDP_ENDIAN__}の場合、16ビットワードのバイトはリトルエンディアン形式で配置され、32ビットの16ビットサブワードはビッグエンディアン形式で配置される。

次のようなテストのためにこれらのマクロを使うべきである：

@smallexample
/* @r{Test for a little-endian machine} */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
@end smallexample

@item __FLOAT_WORD_ORDER__
@code{__FLOAT_WORD_ORDER__}は、マルチワード浮動小数点数のワードのレイアウトを反映するために、@code{__ORDER_LITTLE_ENDIAN__}または@code{__ORDER_BIG_ENDIAN__}の値の1つに定義されている。

@item __DEPRECATED
このマクロは、廃止予定の構造が有効になっていることを警告するC++ソースファイルをコンパイルするときに、値1で定義される。 これらの警告はデフォルトで有効になっているが、@option{-Wno-deprecated}で無効にすることができる。

@item __EXCEPTIONS
このマクロは、例外を有効にしてC ++ソースファイルをコンパイルするときに、値1で定義される。 ファイルをコンパイルするときに@option{-fno-exceptions}を使用すると、このマクロは定義されない。

@item __GXX_RTTI
このマクロは、ランタイム・タイプ識別を有効にしてC ++ソース・ファイルをコンパイルするときに、値1で定義される。 ファイルをコンパイルするときに@option{-fno-rtti}を使用すると、このマクロは定義されない。

@item __USING_SJLJ_EXCEPTIONS__
コンパイラが例外処理のために@code{setjmp}と@code{longjmp}に基づく古い機構を使用する場合、このマクロは値1で定義される。

@item __GXX_EXPERIMENTAL_CXX0X__
このマクロは、オプション@option{-std=c++0x}または@option{-std=gnu++0x}を使用してC ++ソースファイルをコンパイルするときに定義される。 これは、C++0xに含まれる可能性のある機能が利用可能であることを示している。 これらの機能は実験的なものであり、GCCの将来のバージョンで変更されるか、または削除される可能性があることに注意せよ。

@item __GXX_WEAK__
このマクロは、C++ソースファイルをコンパイルするときに定義される。 コンパイラが弱いシンボル、COMDATセクション、または他の同様の手法を使用して、複数の翻訳単位で定義された「曖昧なリンケージ」でシンボルを崩壊させる場合、値は1である。 コンパイラがそのようなシンボルを崩壊させない場合、このマクロは値0で定義される。一般に、ユーザコードはこのマクロを使用する必要はない。 このマクロの目的は、G++で提供されるC ++ランタイムライブラリの実装を容易にすることである。

@item __NEXT_RUNTIME__
Objective-CでNeXTランタイム（@option{-fnext-runtime}のように）が使用されている場合、このマクロは値1で定義される。 GNUランタイムが使用されている場合、このマクロは定義されていないため、このマクロを使用してどのランタイム（NeXTまたはGNU）が使用されているかを判断できる。

@item __LP64__
@itemx _LP64
これらのマクロは、コンパイルが@code{long int}とポインタが両方とも64ビットを使用し、@code{int}が32ビットを使用するターゲット用である場合にのみ、値1で定義される。

@item __SSP__
このマクロは、@option {-fstack-protector}が使用されているときに値1で定義される。

@item __SSP_ALL__
このマクロは、@option{-fstack-protector-all}が使用されているときに値2で定義される。

@item __SSP_STRONG__
このマクロは、@option{-fstack-protector-strong}が使用されているときに値3で定義される。

@item __SSP_EXPLICIT__
このマクロは、@option {-fstack-protector-explicit}が使用されているときに値4で定義される。

@item __SANITIZE_ADDRESS__
このマクロは、@option{-fsanitize = address}または@option{-fsanitize = kernel-address}が使用されているときに値1で定義される。

@item __SANITIZE_THREAD__
このマクロは、@option {-fsanitize = thread}が使用されているときに値1で定義される。

@item __TIMESTAMP__
このマクロは、現在のソースファイルの最終変更日時を表す文字列定数に展開される。 文字列定数には、省略された週、月、日、hh:mm:ss形式の時刻、年含まれ、@code{@w{"Sun Sep 16 01:03:52 1973"}}のようになる。 月の日が10未満の場合は、左側のスペースが埋められる。

GCCが現在の日付を判断できない場合、警告メッセージ（コンパイルごとに1回）が出力され、@code {__ TIMESTAMP__}は@code{@w{"??? ??? ?? ??:??:?? ????"}}に展開される。

@item __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
@itemx __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16
これらのマクロは、ターゲットプロセッサがオペランド1,2,4,8または16バイトのアトミック比較およびスワップ操作をそれぞれサポートする場合に定義される。

@item __GCC_HAVE_DWARF2_CFI_ASM
このマクロは、コンパイラがDWARF CFIディレクティブをアセンブラに発行しているときに定義される。 これが定義されている場合、インラインアセンブリで同じディレクティブを発行することができる。

@item __FP_FAST_FMA
@itemx __FP_FAST_FMAF
@itemx __FP_FAST_FMAL
バックエンドが@code{fma}、@code{fmaf}、@code{fmal}組み込み関数をサポートしている場合、これらのマクロは値1で定義され、インクルードファイル@file{math.h} 1999 C標準との互換性のために、@code{FP_FAST_FMA}、@code{FP_FAST_FMAF}、および@code{FP_FAST_FMAL}マクロが定義されている。

@item __FP_FAST_FMAF16
@itemx __FP_FAST_FMAF32
@itemx __FP_FAST_FMAF64
@itemx __FP_FAST_FMAF128
@itemx __FP_FAST_FMAF32X
@itemx __FP_FAST_FMAF64X
@itemx __FP_FAST_FMAF128X
これらのマクロは、バックエンドがISO/ IEC TS 18661-3：2015で定義されている追加の@code{_Float@var{n}}型と@code{_Float@var{n}x}型を使用して@code{fma}関数をサポートする場合、値1で定義される。 インクルードファイル@file {math.h}は、ユーザーが@file{math.h}をインクルードする前に@code{__STDC_WANT_IEC_60559_TYPES_EXT__}を定義した場合、@code{FP_FAST_FMAF@var{n}}マクロと@code{FP_FAST_FMAF@var{n}x}マクロが定義されうる。

@item __GCC_IEC_559
このマクロは、IEEE 754（IEC 60559）浮動小数点演算のサポートレベルを示すために定義されている。 それは非負の整数値に展開される。 0の場合、コンパイラの設定とコマンドラインオプションの組み合わせは、C99およびC11 Annex Fで定義されている@code{float}および@code {double}のIEEE 754算術をサポートするものではないことを示している（たとえば、 標準の丸めモードと例外がサポートされていないか、またはIEEE 754セマンティクスと競合する最適化が有効になっているなそ）。 1の場合、IEEE 754の算術演算がサポートされることを示している。 これは、関連するすべての言語機能がGCCによってサポートされていることを意味するものではない。 2以上の場合、IEEE 754-2008のサポートを追加的に示している（特に、シグナリングNaNを静かにするためのバイナリエンコーディングはIEEE 754-2008で指定されている）。.

このマクロは、C99およびC11が標準のプラグマによって制御されることを許可する最適化を制御するコマンドラインオプションのデフォルト状態を示していない。これらの標準では、特定のデフォルト状態は必要ない。 最適化がシグナリングNaNセマンティクス（そのマクロは@code{__SUPPORT_SNAN__}）を尊重するかどうかを示すものではない。 10進浮動小数点、またはIEEE 754のbinary16およびbinary128型のサポートを示すものではない。

@item __GCC_IEC_559_COMPLEX
このマクロは、C99およびC11 Annex Gで定義されている複素数のIEEE 754（IEC 60559）浮動小数点演算のサポートレベルを示すために定義されている。負ではない整数値に展開される。 0の場合は、コンパイラの設定とコマンドラインオプションの組み合わせがAnnex Gの要件をサポートするものではないことを示す（たとえば、@option{-fcx-limited-range}が使用されたため）。 1以上の場合は、これらの要件をサポートすることを意図していることを示している。 これは、関連するすべての言語機能がGCCによってサポートされていることを意味するものではない。

@item __NO_MATH_ERRNO__
このマクロは、@option {-fno-math-errno}が使用されている場合、または@option{-ffast-math}のような別のオプションによって、またはデフォルトで有効になっている場合に定義される。
@end table

@node System-specific Predefined Macros
@subsection システム固有の定義済みマクロ

@cindex system-specific predefined macros
@cindex predefined macros, system-specific
@cindex reserved namespace

Cプリプロセッサは通常、どのタイプのシステムとマシンが使用されているかを示すいくつかのマクロを事前に定義している。 それらは明らかにGCCによってサポートされている各ターゲットで異なる。 このマニュアルでは、すべてのシステムとマシンで使用されている名前を出すことはできないが、@command{cpp -dM}を使ってそれらのすべてを見ることができる。 @xref{Invocation}。 システム固有の定義済みマクロはすべて定数値に展開されるため、@samp{#ifdef}または@samp{#if}のいずれかを使用してテストできる。

C標準では、すべてのシステム固有のマクロが@dfn{予約済み名前空間}の一部であることが必要である。 2つのアンダースコア、またはアンダースコアと大文字で始まるすべての名前は、コンパイラとライブラリが望むように使用するために予約されている。 しかし、歴史的にシステム特有のマクロは特別な接頭辞を持たない名前を持っていた。 たとえば、Unixシステムで@code{unix}が定義されているのが一般的である。 このようなすべてのマクロでは、GCCは最初と最後に2つのアンダースコアが追加された並列マクロを提供しる。 @code{unix}が定義されている場合、@code{__unix__}も定義される。 二つ以上のアンダースコアはない。 @code{_mips}のパラレルは@code{__mips__}である。

厳密な適合を要求する@option{-ansi}オプションまたは@option{-std}オプションがコンパイラに渡されると、予約された名前空間外のすべてのシステム固有の事前定義されたマクロは抑制される。 予約された名前空間内の並列マクロは定義されたままである。

予約された名前空間の外にあるすべての定義済みマクロを少しずつ段階的に削除している。 新しいプログラムでは決して使用すべきでない。古いコードを見つけたら、いつでも並列マクロを使用するように修正することを推奨する。 予約済みの名前空間にあるシステム固有のマクロを使用することも推奨はしない。 長期的には、@command{autoconf}のようなツールを使って、必要な機能を具体的にチェックする方が良いだろう。

@node C++ Named Operators
@subsection C++名前付き演算子
@cindex named operators
@cindex C++ named operators
@cindex @file{iso646.h}

C++には、11個のキーワードがある。これらのキーワードは、通常、句読点で書かれた演算子の代わりのスペルである。 これらのキーワードは、プリプロセッサでも同様に扱われる。 それらは@samp{#if}の演算子として機能し、マクロまたは中毒として定義することはできない。 Cでは、@file{iso646.h}をインクルードすることによって、それらのキーワードがC++の意味を持つことを要求できる。 そのヘッダーは、それぞれを適切な句読点に展開する通常のオブジェクトのようなマクロとして定義する。

これらは、名前付き演算子と対応する句読点である。

@multitable {Named Operator} {Punctuator}
@item Named Operator @tab Punctuator
@item @code{and}    @tab @code{&&}
@item @code{and_eq} @tab @code{&=}
@item @code{bitand} @tab @code{&}
@item @code{bitor}  @tab @code{|}
@item @code{compl}  @tab @code{~}
@item @code{not}    @tab @code{!}
@item @code{not_eq} @tab @code{!=}
@item @code{or}     @tab @code{||}
@item @code{or_eq}  @tab @code{|=}
@item @code{xor}    @tab @code{^}
@item @code{xor_eq} @tab @code{^=}
@end multitable

@node Undefining and Redefining Macros
@section マクロの未定義化と再定義
@cindex undefining macros
@cindex redefining macros
@findex #undef

マクロが有用でなくなるならば、マクロは@samp{#undef}ディレクティブで@dfn{未定義}になることができる。 @samp{#undef}は単一の引数、つまり未定義のマクロの名前をとる。 マクロが関数的なものであっても、裸のマクロ名を使用する。 マクロ名の後に行に何かが現れるとエラーになる。 名前がマクロでない場合、@samp{#undef}は効果がない。

@smallexample
#define FOO 4
x = FOO;        @expansion{} x = 4;
#undef FOO
x = FOO;        @expansion{} x = FOO;
@end smallexample

マクロが定義されていない場合、その識別子は後続の@samp{#define}ディレクティブによってマクロとして@dfn{再定義}することができる。 新しい定義は、古い定義と似ている必要はない。

しかし、現在マクロである識別子が再定義された場合、新しい定義は古いものと@dfn{実質的に同じ}でなければならない。 次の場合、2つのマクロ定義は事実上同じである：
@itemize @bullet
@item 両方がマクロの同じ型である（オブジェクト風か関数風か）
@item 置換リストのすべてのトークンは同じである。
@item パラメータがあるならば、それらが同じである。
@item 空白は両方の同じ場所に表示される。 しかし、必ずしも同じ量の空白である必要はない。 コメントは空白として数えることを思い出すこと。
@end itemize

@noindent
これらの定義は事実上同じである：
@smallexample
#define FOUR (2 + 2)
#define FOUR         (2    +    2)
#define FOUR (2 /* @r{two} */ + 2)
@end smallexample
@noindent
しかし以下は違う：
@smallexample
#define FOUR (2 + 2)
#define FOUR ( 2+2 )
#define FOUR (2 * 2)
#define FOUR(score,and,seven,years,ago) (2 + 2)
@end smallexample

既存のマクロと実質的に同じではない定義でマクロが再定義された場合、プリプロセッサは警告を発行して新しい定義を使用するようにマクロを変更する。 新しい定義が事実上同じ場合、再定義は暗黙のうちに無視されます。 これは、例えば、2つの異なるヘッダが共通のマクロを定義することを可能にする。 プリプロセッサは、定義が一致しない場合にのみ文句を言う。

@node Directives Within Macro Arguments
@section マクロ引数内のディレクティブ
@cindex macro arguments and directives

場合によっては、マクロの引数内でプリプロセッサディレクティブを使用すると便利である。 CおよびC++標準では、これらの場合の動作が定義されていないと宣言している。 GNU CPPは、関数風マクロ呼び出しは存在しないときのディレクティブを処理したのとまったく同じ方法でマクロ引数内の任意のディレクティブを処理する。

マクロの呼び出し内でそのマクロが再定義された場合、新しい定義は引数の展開前に有効になるが、元の定義は引き続き引数の置換に使用される。 病理学的な例がある：

@smallexample
#define f(x) x x
f (1
#undef f
#define f 2
f)
@end smallexample

@noindent
は上で説明したような意味で以下に展開される

@smallexample
1 2 1 2
@end smallexample

@noindent

@node Macro Pitfalls
@section マクロの落とし穴
@cindex problems with macros
@cindex pitfalls of macros

このセクションでは、マクロとマクロ展開に適用される特別な規則をいくつか説明し、注意が必要な反直感的な結果がある特定のケースを指摘する。

@menu
* Misnesting::
* Operator Precedence Problems::
* Swallowing the Semicolon::
* Duplication of Side Effects::
* Self-Referential Macros::
* Argument Prescan::
* Newlines in Arguments::
@end menu

@node Misnesting
@subsection ネストの非対応

引数を指定してマクロを呼び出すと、引数はマクロ本体に代入され、残りの入力ファイルとともに結果がチェックされ、より多くのマクロ呼び出しが行われる。 部分的にマクロ本体から来て、引数から部分的に来るマクロ呼び出しを一緒にまとめることは可能である。 例えば、

@smallexample
#define twice(x) (2*(x))
#define call_with_1(x) x(1)
call_with_1 (twice)
     @expansion{} twice(1)
     @expansion{} (2*(1))
@end smallexample

マクロ定義にはバランスのとれた括弧が必要ではない。 アンバランスな括弧をマクロ本体に書き込むことで、マクロ本体内で始まり、その外側で終わるマクロ呼び出しを作成することができる。 例えば、

@smallexample
#define strange(file) fprintf (file, "%s %d",
@dots{}
strange(stderr) p, 35)
     @expansion{} fprintf (stderr, "%s %d", p, 35)
@end smallexample

マクロ呼び出しをまとめる機能は便利だが、マクロ本体でアンバランスな開きカッコを使用するのは混乱するだけなので、避けるべきである。

@node Operator Precedence Problems
@subsection 演算子の優先順位の問題
@cindex parentheses in macro bodies

上に示したマクロ定義の例の大部分で、マクロ引数名のそれぞれにはカッコが付いていたことにきついたかもしれない。 さらに、通常、もう1組のカッコがマクロ定義全体を囲む。これがマクロを書くのが最善の方法である。

次のようにマクロを定義したとすると、

@smallexample
#define ceil_div(x, y) (x + y - 1) / y
@end smallexample

@noindent
この目的は除算をしてから切り上げることである。 （この操作の1つの用途は、特定の数の@code{char}オブジェクトを保持するために必要な@code{int}オブジェクトの数を計算することである）。次に、以下のように使われると

@smallexample
a = ceil_div (b & c, sizeof (int));
     @expansion{} a = (b & c + sizeof (int) - 1) / sizeof (int);
@end smallexample

@noindent
これは意図したことをしない。 Cの演算子優先ルールは、これと同じになる：

@smallexample
a = (b & (c + sizeof (int) - 1)) / sizeof (int);
@end smallexample

@noindent
私たちが欲しいのはこれである：

@smallexample
a = ((b & c) + sizeof (int) - 1)) / sizeof (int);
@end smallexample

@noindent
マクロを次のように定義すると

@smallexample
#define ceil_div(x, y) ((x) + (y) - 1) / (y)
@end smallexample

@noindent
望んだ結果を得る。

意図しないグループ分けが別の方法で起こる可能性がある。 @code{sizeof ceil_div(1,2)}を考える。 これは、@code{ceil_div(1, 2)}の型のサイズを計算するC式のようにみえるが、実際それは非常に異なるものを意味している。 ここにそれがどう展開するかがある：

@smallexample
sizeof ((1) + (2) - 1) / (2)
@end smallexample

@noindent
これは整数の大きさをとり、2で割ったものである。 優先順位のルールは、内部にあることを意図したときに除算を@code {sizeof}の外に置いている。

マクロ定義全体のかっこは、このような問題を防ぐ。 ここでは、これが@code{ceil_div}を定義するための推奨される方法である：

@smallexample
#define ceil_div(x, y) (((x) + (y) - 1) / (y))
@end smallexample

@node Swallowing the Semicolon
@subsection セミコロンをのみこむ
@cindex semicolons (after macro calls)

しばしば、複合文に展開されるマクロを定義することが望まれる。 たとえば、次のマクロを考えてみる。空白文字をまたいだポインタ（引数@code{p}はどこにあるのかを示す）を進める。

@smallexample
#define SKIP_SPACES(p, limit)  \
@{ char *lim = (limit);         \
  while (p < lim) @{            \
    if (*p++ != ' ') @{         \
      p--; break; @}@}@}
@end smallexample

@noindent
ここで、バックスラッシュ・改行は、マクロ定義を分割するために使用される。マクロ定義は、マクロ定義の一部ではない場合にそのようなコードがレイアウトされる方法に似ているように、単一の論理行でなければならない。

このマクロの呼び出しは、@code{SKIP_SPACES(p、lim)}となる。 厳密に言えば、呼び出しは複合ステートメントに展開される。複合ステートメントは、セミコロンを終了する必要がない完全なステートメントである。 しかし、関数呼び出しのように見えるので、関数呼び出しのように使うことができ、後で@code{SKIP_SPACES(p、lim);}のようにセミコロンを書くと混乱が最小限に抑えられる。

これは、セミコロンが実際にはヌルステートメントであるため、@code{else}ステートメントの前に問題を引き起こす可能性がある。こう書いたとする。

@smallexample
if (*p != 0)
  SKIP_SPACES (p, lim);
else @dots{}
@end smallexample

@noindent
@code{if}条件と@code{else}の間に2つのステートメント---複合ステートメントとヌルステートメント---が存在すると、無効なCコードになる。

マクロの定義@code{SKIP_SPACES}は、この問題を解決するために@code{do @dots{} while}ステートメントを使用して変更することができる。 方法は次のとおりである。

@smallexample
#define SKIP_SPACES(p, limit)     \
do @{ char *lim = (limit);         \
     while (p < lim) @{            \
       if (*p++ != ' ') @{         \
         p--; break; @}@}@}          \
while (0)
@end smallexample

今、@code{SKIP_SPACES(p、lim);}は以下のように展開される

@smallexample
do @{@dots{}@} while (0);
@end smallexample

@noindent
これは1つのステートメントである。 ループは正確に1回実行される。 ほとんどのコンパイラはそれのための特別なコードを生成しない。

@node Duplication of Side Effects
@subsection 副作用の重複

@cindex side effects (in macro arguments)
@cindex unsafe macros
多くのCプログラムは、以下のように、「最小」のマクロ@code{min}を定義している。

@smallexample
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
@end smallexample

ここに示すように、このマクロに副作用を含む引数を使用すると、

@smallexample
next = min (x + y, foo (z));
@end smallexample

@noindent
次のように展開される。

@smallexample
next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));
@end smallexample

@noindent
ここで@code{X}は@code{x + y}に、@code{Y}は@code{foo(z)}に置き換えられている。

関数@code{foo}はプログラム中に現れている文の中で一度だけ使われるが、式@code{foo(z)}はマクロ展開に2回代入されている。 その結果、文が実行されるときに@code{foo}が2回呼び出されることがある。 副作用がある場合や、計算に時間がかかる場合、結果は意図したとおりではない可能性がある。 @code{min}は@dfn{安全でない}マクロである。

この問題に対する最良の解決策は、@code{foo(z)}の値を1回だけ計算する方法で@code{min}を定義することである。 C言語はこれを行う標準的な方法を提供していないが、次のようにGNU拡張で行うことができる：
follows:

@smallexample
#define min(X, Y)                \
(@{ typeof (X) x_ = (X);          \
   typeof (Y) y_ = (Y);          \
   (x_ < y_) ? x_ : y_; @})
@end smallexample

@samp{(@{ @dots{} @})}表記法は、式として機能する複合文を生成する。 その値は最後のステートメントの値である。 これにより、ローカル変数を定義し、各引数を1つに割り当てることができる。 ローカル変数は名前の後にアンダースコアを付けて、より広いスコープの識別子との衝突のリスクを低減する（これを完全に避けることは不可能である）。 各引数は正確に1回だけ評価される。

GNU C拡張機能を使用したくない場合は、唯一の解決法はマクロ@code{min}を@emph{使用する}ときに注意することである。 たとえば、@code{foo(z)}の値を計算し、変数に保存し、その変数を@code{min}に使用することができる。

@smallexample
@group
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
@dots{}
@{
  int tem = foo (z);
  next = min (x + y, tem);
@}
@end group
@end smallexample

@noindent
（ここでは、@code{foo}が@code{int}型を返すと仮定する）。

@node Self-Referential Macros
@subsection 自己参照マクロ
@cindex self-reference

@dfn {self-referential}マクロはその名前がその定義に現れるものである。 すべてのマクロ定義が、より多くのマクロを置き換えるために再スキャンされることを思い出すこと。 自己参照がマクロの使用と見なされた場合、マクロ参照は無限に展開される。 これを防ぐために、自己参照はマクロ呼び出しと見なされない。 プリプロセッサの出力にそのまま渡される。 例を考える：

@smallexample
#define foo (4 + foo)
@end smallexample

@noindent
ここで@code{foo}はプログラム内の変数でもある。

通常の規則に従って、@code{foo}への各参照は@code {(4 + foo)}に展開される。 これは再スキャンされ、@code{(4 +(4 + foo))}に展開される。 コンピュータがメモリ不足になるまで続く。

自己参照ルールは、このプロセスを@code {(4 + foo)}で1ステップ後に短縮する。 したがって、このマクロ定義は、@code{foo}が参照されているところで、プログラムに4を@code{foo}の値に追加させる有用な効果がある。

ほとんどの場合、この機能を利用することは悪い考えである。 @code{foo}が変数であると見なすプログラムを読んでいる人は、マクロであるとは思わないだろう。 読者はプログラム中の識別子@code{foo}を見つけ、その値は変数@code{foo}の値であるべきだと思うが、実際には値は4大きい。

自己参照の一般的で有用な使用法の1つは、マクロ自身を展開するマクロを作成することである。このように書くならば

@smallexample
#define EPERM EPERM
@end smallexample

@noindent
マクロ@code{EPERM}は@code{EPERM}に展開される。 効果的には、実行中のテキストで使用されるときはいつでもプリプロセッサによって単独で残される。 それは@samp{#ifdef}ができるマクロであると言うことができる。 数値定数を@code{enum}で定義したいが、@samp{#ifdef}を各定数に対して真にしたい場合は、これを行うかもしれない。

マクロ@code{x}がマクロ@code{y}を使用するように展開し、@code{y}の展開がマクロ@code{x}を参照する場合、それは@code{x}の@dfn{間接自己参照}である。 この場合でも@code {x}は展開されない。 したがって、もし我々が

@smallexample
#define x (4 + y)
#define y (2 * x)
@end smallexample

@noindent
と書くならば、@code{x}と@code{y}は以下のように展開される。

@smallexample
@group
x    @expansion{} (4 + y)
     @expansion{} (4 + (2 * x))

y    @expansion{} (2 * x)
     @expansion{} (2 * (4 + y))
@end group
@end smallexample

@noindent
各マクロは、他のマクロの定義に現れたときに展開されるが、それ自身の定義に間接的に現れるときは展開されない。

@node Argument Prescan
@subsection 引数の前スキャン
@cindex expansion of arguments
@cindex macro argument expansion
@cindex prescan of macro arguments

マクロ引数は、マクロボディに代入される前に完全にマクロ展開されるが、他のトークンで文字列化されたり貼り付けられたりしている場合を除く。 置換後、置換された引数を含むマクロ本体全体が再度走査され、マクロが展開される。 その結果、引数はマクロ呼び出しを展開するために@emph{二度}スキャンされる。

ほとんどの場合、これは効果がない。 引数にマクロ呼び出しが含まれている場合、引数は最初のスキャン時に展開される。 したがって、結果にはマクロ呼び出しが含まれないため、2回目のスキャンではマクロ呼び出しは変更されない。 引数が前スキャンなしで与えられたように置換された場合、残りの1回のスキャンで同じマクロ呼び出しが検出され、同じ結果が得られる。

他のマクロの引数に自己参照マクロ（@pxref {Self-Referential Macros}）を使用すると、二重スキャンで結果が変わることが予想されるかもしれない。自己参照マクロは最初のスキャンで一度展開され、 2回目のスキャンでは2回目である。 しかし、これは起こることではない。 最初のスキャンで展開されない自己参照は、2番目のスキャンでも展開されないようにマークされる。

「もし違いがないならば、なぜ前スキャンについて述べるのか？それをスキップしてプリプロセッサを速くしないのはなぜか？」と考えるかもしれない。 答えは、前スキャンが3つの特殊なケースで違いを生むことである。

@itemize @bullet
@item
マクロへの入れ子の呼び出し。

@dfn{入れ子の}マクロの呼び出しは、マクロの引数にそのマクロへの呼び出しが含まれている場合に発生する。 たとえば、@code{f}が1つの引数を必要とするマクロである場合、@code{f(f(1))}は@code{f}への呼び出しのネストされたペアである。 望ましい展開は、@code{f(1)}を展開し、それを@code{f}の定義に置き換えることによって行われる。前スキャンによって予想される結果を生じる。 前スキャンがなければ、@code{f(1)}自体が引数として代入され、@code{f}の内部使用は間接的な自己参照としてメインスキャン中に現れ、展開されない。

@item
文字列化または連結する他のマクロを呼び出すマクロ。

引数が文字列化または連結されている場合、前スキャンは発生しない。 @emph{マクロ}を展開し、そのマクロ展開を文字列化または連結したい場合は、あるマクロが文字列化または連結を行う別のマクロを呼び出すようにする。 たとえば、もし

@smallexample
#define AFTERX(x) X_ ## x
#define XAFTERX(x) AFTERX(x)
#define TABLESIZE 1024
#define BUFSIZE TABLESIZE
@end smallexample

ならば、@code{AFTERX(BUFSIZE)}は@code{X_BUFSIZE}へと展開され、@code{XAFTERX(BUFSIZE)}は@code{X_1024}へと展開される。 (@code{X_TABLESIZE}へは展開されない。前スキャンは常に完全な展開を行う。）

@item
引数に使用されるマクロで、その拡張には守られていないコンマが含まれる。

これにより、2番目のスキャンで展開されたマクロが間違った数の引数で呼び出される可能性がある。 次に例を示す。

@smallexample
#define foo  a,b
#define bar(x) lose(x)
#define lose(x) (1 + (x))
@end smallexample

@code{bar(foo)}を@code{(1 +(foo))}に変えて、@code{(1+(a,b))}に変えたいだろう。 代わりに@code{bar(foo)}は@code{lose(a,b)}に展開され、@code{lose}には1つの引数が必要なのでエラーが発生する。 この場合、問題は、算術演算の誤ったネスティングを防ぐために使用されるべきである同じカッコで簡単に解決される。

@smallexample
#define foo (a,b)
@exdent or
#define bar(x) lose((x))
@end smallexample

余分な括弧の組は、@code {foo}の定義中のコンマが引数の区切りとして解釈されないようにする。

@end itemize

@node Newlines in Arguments
@subsection 引数での改行
@cindex newlines in macro arguments

関数に似たマクロの呼び出しは、多くの論理行にまたがる可能性がある。 しかし、現在の実装では、展開全体が1行になる。 したがって、コンパイラーまたはデバッガーによって発行される行番号は、呼び出しを開始した行を参照する。これは、問題の原因となっている引き数を含む行とは異なる場合がある。

これを説明する例を次に示す。

@smallexample
#define ignore_second_arg(a,b,c) a; c

ignore_second_arg (foo (),
                   ignored (),
                   syntax error);
@end smallexample

@noindent
トークン@code{syntax error}によって引き起こされた構文エラーは、問題のコードが5行目から来ていても、3行--- ignore_second_argの行---を引用するエラーメッセージになる。

私たちはこれをバグとみなし、近い将来に修正しようとしている。

@node Conditionals
@chapter 条件
@cindex conditionals

@dfn{条件}は、プリプロセッサに、コンパイラに渡される最後のトークンストリームにコードの塊を含めるかどうかを選択するよう指示する指令である。 プリプロセッサ条件は、算術式、名前がマクロとして定義されているか、特別な@code{defined}演算子を使って同時に両方をテストすることができる。

Cプリプロセッサの条件式は、Cの@code {if}文といくつかの点で似ているが、その違いを理解することが重要である。 @code{if}文の条件は、プログラムの実行中にテストされる。 その目的は、動作中のデータに応じて、実行の度に動作が異なるようにすることである。プリプロセス条件付きディレクティブの条件は、プログラムのコンパイル時にテストされる。 その目的は、コンパイル時の状況に応じて異なるコードをプログラムに含めることである。

しかしながら、その区別はあまり明確ではない。 現代のコンパイラは、プログラムがコンパイルされたとき、条件が実行時に変化しないことがわかっているときに@code{if}文をテストし、決して実行できないコードを排除することがよくある。 あなたがこれを行うためにあなたのコンパイラを頼りにすることができるなら、（マクロによって決まる）一定の条件で@code{if}文を使うと、あなたのプログラムは読みやすくなる。 もちろん、型定義やその他のプリプロセスディレクティブではなく、コードを除外するためにのみ使用することができる。コードが使用されないときに構文的に有効なままであれば、これを実行できる。

@menu
* Conditional Uses::
* Conditional Syntax::
* Deleted Code::
@end menu

@node Conditional Uses
@section 条件の使用

条件を使用する一般的な理由は3つある。

@itemize @bullet
@item
実行するマシンまたはオペレーティングシステムに応じて、プログラムが異なるコードを使用する必要がある。 場合によっては、あるオペレーティングシステムのコードが別のオペレーティングシステムで誤っている可能性がある。 たとえば、他のシステム上に存在しないデータ型や定数を参照している可能性がある。 この場合、無効なコードの実行を避けるだけでは十分ではない。 その存在は、コンパイラにプログラムを拒否させる原因になる。プリプロセス条件では、有効でないときに問題のコードを効果的にプログラムから切り出すことができる。

@item
同じソースファイルを2つの異なるプログラムにコンパイルすることができる。片方のバージョンでは、時間のかかる中間データの整合性チェックを行い、デバッグのためにそれらのデータの値を表示させ、もう片方はしないかもしれない。

@item
条件が常に偽である条件は、プログラムからコードを除外するが、将来の参照用にコメントの一種として保持するための1つの方法である。
@end itemize

システム固有のロジックや複雑なデバッグフックを必要としない単純なプログラムでは、一般にプリプロセス条件を使用する必要はない。

@node Conditional Syntax
@section 条件の構文

@findex #if
Cプリプロセッサの条件式は@dfn {条件付き命令}で始まる： @samp{#if}, @samp{#ifdef}及び@samp{#ifndef}。

@menu
* Ifdef::
* If::
* Defined::
* Else::
* Elif::
@end menu

@node Ifdef
@subsection Ifdef
@findex #ifdef
@findex #endif

条件の最も簡単な種類は

@smallexample
@group
#ifdef @var{MACRO}

@var{controlled text}

#endif /* @var{MACRO} */
@end group
@end smallexample

@cindex conditional group
このブロックは@dfn{条件付きグループ}と呼ばれる。 @var{controlled text}は、@ var{MACRO}が定義されている場合にのみプリプロセッサの出力にインクルードされる。 @var{MACRO}が定義されていれば条件付きの@dfn{成功}、そうでなければ@dfn{失敗}と言うことにする。

条件文の中の@var{controlled text}は、プリプロセス指令を含むことができる。 条件で成功した場合にのみ実行される。 条件付きグループを他の条件付きグループ内にネストすることはできるが、完全にネストする必要がある。 言い換えると、@samp{#endif}は常に最も近い@samp{#ifdef}（または@samp{#ifndef}または@samp{#if}）と一致する。 また、条件付きグループをあるファイルで開始し、別のファイルで終了することはできない。

条件が満たされなくても、内部の@var{controlled text}は初期の変換とトークン化によって実行される。 したがって、すべてが字句的に有効なCでなければならない。 これが問題となる唯一の方法は、通常、失敗する条件付きグループ内のすべてのコメントと文字列リテラルを適切に終了する必要があることである。

@samp{#endif}に続くコメントは必須ではないが、多くの@var{controlled text}がある場合は、@samp{#endif}を対応する@samp{#ifdef}に一致させるために役立つ。古いプログラムでは@samp{#endif}の直後に@var{MACRO}を置くことがある。 これはC標準に準拠しない無効なコードである。 CPPはそれを警告で受け付ける。 それは@samp{#endif}が一致する@samp{#ifndef}には決して影響しない。

@findex #ifndef
時には、マクロが定義されて@emph{いない}ならば、いくつかのコードを使いたいと思うことがある。 @samp{#ifdef}の代わりに@samp{#ifndef}を書くことでこれを行うことができる。 @samp{#ifndef}の一般的な使い方は、ヘッダファイルが最初にインクルードされたときだけコードをインクルードすることである。 @xref{Once-Only Headers}。

マクロ定義は、いくつかの理由でコンパイルごとに異なる場合がある。 ここにいくつかのサンプルがある。

@itemize @bullet
@item
いくつかのマクロは、各種類のマシン（@pxref{System-specific Predefined Macros}）であらかじめ定義されている。 これにより、特定のマシンに対して特別にチューニングされたコードを提供することができる。

@item
システムヘッダファイルは、実装する機能に関連付けられた、より多くのマクロを定義する。 これらのマクロを条件付きでテストして、実装されていないマシンでシステム機能を使用しないようにすることができる。

@item
マクロを定義するには、プログラムをコンパイルするときに@option{-D}と@option{-U}コマンドラインオプションを使用する。 同じソースファイルを2つの異なるプログラムにコンパイルするには、マクロ名を選択してどのプログラムを指定するか、このマクロが定義されているかどうかをテストするための条件文を作成し、コマンドラインオプションを使用してマクロの状態を制御し、おそらくMakefileに設定されている。@xref{Invocation}。

@item
あなたのプログラムには、プログラムのコンパイル時に調整される特別なヘッダファイル（しばしば@file{config.h}と呼ばれる）があるかもしれない。 システムの機能とプログラムの望ましい機能に応じて、マクロを定義したり、定義しなかったりすることができる。 調整は、@command{autoconf}のようなツールで自動化することも、手動で行うこともできる。
@end itemize

@node If
@subsection If

@samp {#if}ディレクティブを使うと、単純に1つのマクロの存在ではなく、算術式の値をテストできる。 構文は次のとおりである。

@smallexample
@group
#if @var{expression}

@var{controlled text}

#endif /* @var{expression} */
@end group
@end smallexample

@var{expression}は整数型のC式であり、厳格な制限がある。 それは以下を含んで良い。

@itemize @bullet
@item
整数定数。

@item
通常のコードで解釈される文字定数

@item
加算、減算、乗算、除算、ビット操作、シフト、比較と論理操作(@code{&&}と@code{||})の演算子。最後の2つは通常の標準Cの短絡規則に従う。

@item
マクロ。 式のすべてのマクロは、式の値が実際に計算される前に展開される。

@item
マクロが@samp{#if}の真ん中に定義されているかどうかをチェックできる@code{defined}演算子の使用。

@item
マクロではない識別子。すべてがゼロであるとみなされる。 これにより、定義されているMACROが常にゼロ以外の値を持つことがわかっている場合、@code{@w{#ifdef MACRO}}ではなく@code{@w{#if MACRO}}と書くことができる。 関数呼び出しのかっこなしで使用される関数のようなマクロもゼロとして扱われる。

状況によっては、このショートカットは望ましくない。 @option{-Wundef}オプションは、@samp{#if}のマクロではない識別子に遭遇するたびにGCCに警告を出させる。
@end itemize

プリプロセッサは言語の型について何も知らない。 したがって、@code{sizeof}演算子は@samp{#if}で認識されず、どちらも@code{enum}定数もそうである。 それらはマクロではなく、ゼロで置き換えられた識別子として扱われる。 @code{sizeof}の場合、これは式が無効になる可能性がある。

プリプロセッサは@var{expression}の値を計算する。 コンパイラに知られている最も広い整数型のすべての計算を実行する。 GCCでサポートされているほとんどのマシンでは64ビットである。 これは、定数式の値を計算するためにコンパイラが使用するのと同じルールではなく、結果が異なる場合がある。 値がゼロ以外になると、@samp{#if}は成功し、@var{controlled text}が含まれる。 それ以外の場合はスキップされる。

@node Defined
@subsection Defined

@cindex @code{defined}
特定の名前がマクロとして定義されているかどうかをテストするために、@code{defined}という特別な演算子が@samp{#if}と@samp{#elif}の式で使用されている。 @var{name}がプログラムの現在の点でマクロとして定義されている場合、@code{defined @var{name}}と@code {defined(@var{name})}はどちらも値が1の式であり、そうでなければ0である。 したがって、@code{@w{#if defined MACRO}}は@code{@w{#ifdef MACRO}}とまったく同じである。

一度に複数のマクロをテストしたいときに便利である。 例えば、

@smallexample
#if defined (__vax__) || defined (__ns16000__)
@end smallexample

@noindent
は@code{__ vax__}または@code{__ ns16000__}のいずれかの名前がマクロとして定義されていると成功する。

このように書かれた条件式：

@smallexample
#if defined BUFSIZE && BUFSIZE >= 1024
@end smallexample

@noindent
は@code{BUFSIZE> = 1024}に単純化することができる。なぜなら、@code{BUFSIZE}が定義されていないと、値がゼロであると解釈されるからである。

マクロ展開の結果として@code{defined}演算子が現れた場合、Cの標準では動作は未定義であると言う。 GNU cppはそれを本物の@code{defined}演算子として扱い、通常の評価をする。 コマンドラインオプション@option{-Wpedantic}を使用する場合は、他のコンパイラがこれを別々に処理する可能性があるため、コードがこの機能を使用する場所を警告する。 警告は@option{-Wextra}によっても有効になり、@option{-Wexpansion-to-defined}で個別に有効にすることもできる。

@node Else
@subsection Else

@findex #else
@samp{#else}疑似命令は、条件に失敗した場合に使用される代替テキストを提供するために条件に追加することができる。 これは次のようになる。

@smallexample
@group
#if @var{expression}
@var{text-if-true}
#else /* Not @var{expression} */
@var{text-if-false}
#endif /* Not @var{expression} */
@end group
@end smallexample

@noindent
@var{expression}が0でない場合、@var{text-if-true}がインクルードされ、@var{text-if-false}はスキップされる。 @var{expression}が0の場合、逆のことが起こる。

@samp{#else}は@samp{#ifdef}と@samp{#ifndef}でも使用することができる。

@node Elif
@subsection Elif

@findex #elif
ネストされた条件文の1つの一般的なケースは、2つ以上の可能な選択肢をチェックするために使用される。 たとえば、

@smallexample
#if X == 1
@dots{}
#else /* X != 1 */
#if X == 2
@dots{}
#else /* X != 2 */
@dots{}
#endif /* X != 2 */
#endif /* X != 1 */
@end smallexample

別の条件付きディレクティブ@samp{#elif}では、これを以下のように省略することができる。

@smallexample
#if X == 1
@dots{}
#elif X == 2
@dots{}
#else /* X != 2 and X != 1*/
@dots{}
#endif /* X != 2 and X != 1*/
@end smallexample

@samp{#elif}は「else if」'の略である。 @samp{#else}と同様に、条件付きグループの途中で細分化される。 独自の@samp{#endif}は必要ない。 @samp{#if}と同様に、@samp{#elif}ディレクティブにはテスト対象の式が含まれている。 @samp{#elif}に続くテキストは、元の@samp{#if}条件が失敗し、@samp{#elif}条件が成功した場合にのみ処理される。

複数の@samp{#elif}を同じ条件グループに入れることができる。 @samp{#elif}の後のテキストは、元の@samp{#if}とそれ以前のすべての@samp{#elif}ディレクティブが失敗した後に@samp{#elif}条件が成功した場合にのみ処理される。

@samp{#else}は任意の数の@samp{#elif}ディレクティブの後で使用できるが、@samp{#elif}は@samp{#else}の後に来てはならない。

@node Deleted Code
@section 削除されたコード
@cindex commenting out code

プログラムの一部を置き換えたり削除したりして、後で参照できるように古いコードを保存したい場合は、単にコメントアウトすることはできない。 ブロックコメントは入れ子にならないので、古いコードの最初のコメントはコメントアウトを終了する。 考えられる結果は、構文エラーの氾濫である。

この問題を回避する1つの方法は、常に偽の条件を代わりに使用することである。 たとえば、削除されたコードの前に@code{#if 0}を置き、その後に@code{#endif}を置く。 これは、オフになっているコードに条件文が含まれていても機能するが、それらが条件文全体でなければならない。（@samp{#if}と@samp{#endif}でバランスが取れている）

代わりに@code{#ifdef notdef}を使用する人もいる。 @code{notdef}が誤ってマクロとして定義されている可能性があり、条件付きで成功する可能性があるため、これは危険である。 @code{#if 0}は失敗したとみなすことができる。

Cコードではないコメントに@code {#if 0}を使用してはならない。 代わりに実際のコメントを使用すること。 @code{#if 0}の内部は、完全なトークンで構成されていなければならない。 特に、一重引用符はバランスをとる必要がある。 コメントにはアンバランスな一重引用符（英語ではアポストロフィとして知られている）が含まれていることがよくある。 これらは@code{#if 0}を混乱させる。 @samp{/*}は混乱しない。

@node Diagnostics
@chapter 診断
@cindex diagnostic
@cindex reporting errors
@cindex reporting warnings

@findex #error
@samp{#error}命令は、プリプロセッサに致命的エラーを報告させる。 @samp{#error}に続く行の残りの部分を形成するトークンは、エラーメッセージとして使用される。

プログラムが正しくサポートしていないことを知っているパラメータの組み合わせを検出する条件の中で@samp{#error}を使用する。 たとえば、プログラムがVAX上で正しく実行されないことがわかっている場合は、

@smallexample
@group
#ifdef __vax__
#error "Won't work on VAXen.  See comments at get_last_object."
#endif
@end group
@end smallexample

一貫性のある方法でインストールで設定する必要のあるいくつかの設定パラメータがある場合は、条件を使用して矛盾を検出し、@samp{#error}で報告できる。 例えば、

@smallexample
#if !defined(FOO) && defined(BAR)
#error "BAR requires FOO."
#endif
@end smallexample

@findex #warning
@samp{#warning}命令は@samp{#error}に似ているが、プリプロセッサに警告を出して前処理を続行させる。 @samp{#warning}に続くトークンは、警告メッセージとして使用される。

廃止されたヘッダファイルで@samp{#warning}を使用し、その代わりに使用されるヘッダファイルにユーザを誘導するメッセージを表示することができる。

@samp{#error}も@samp{#warning}も引数をマクロ展開しない。 内部空白シーケンスはそれぞれ1つのスペースに置き換えられる。 行は完全なトークンで構成されていなければならない。 これらのディレクティブの引数を単一の文字列定数にすることが最も賢明である。 これにより、アポストロフィなどの問題が回避される。

@node Line Control
@chapter 行制御
@cindex line control

Cプリプロセッサは、各トークンがどこから来たかをソースコード内の場所をCコンパイラに通知する。 現在のところ、これはファイル名と行番号である。 マクロ展開の結果として得られるすべてのトークンは、最も外側のマクロが使用されたソースファイルの行に現れたと報告される。 私たちは将来、より正確になるつもりである。

@command{bison}パーサジェネレータのようなソースコードを生成するプログラムを書く場合、プリプロセッサの現在のファイル名と行番号の概念を手動で調整することができる。 @command{bison}の出力の一部は最初から生成され、他の部分は標準パーサーファイルから生成される。 残りは@command{bison}の入力からそのままコピーされる。 コンパイラエラーメッセージとシンボリックデバッガが@code{bison}の入力ファイルを参照できるようにしたいとする。

@findex #line
@command{bison}やそのようなプログラムは、@samp{#line}指示文を出力ファイルに書き込むことでこれを手配できる。 @samp{#line}は、現在のプリプロセッサ入力ファイルの後続入力の元の行番号とソースファイル名を指定する指令である。 @samp{#line}には3つのバリエーションがある：

@table @code
@item #line @var{linenum}
@var{linenum}は、負でない10進整数定数である。これは、次の入力行について報告される行番号を指定する。 後続の行は、@var{linenum}から数えられる。

@item #line @var{linenum} @var{filename}
@var{linenum}は最初の形式と同じで、同じ効果がある。 さらに、@var{filename}は文字列定数である。 次の行とそれに続くすべての行は、別の行がそれを変更するまで、指定されたファイルから来たと報告される。 @var{filename}は、文字列定数の通常の規則に従って解釈される。バックスラッシュエスケープが解釈される。 これは@samp{#include}とは異なる。

@item #line @var{anything else}
@var {anything else}は展開されたマクロ呼び出しをチェックする。 結果は、上記の2つの形式のいずれかと一致する必要がある。
@end table

@samp{#line}ディレクティブは、あらかじめ定義された@code{__FILE__}マクロと@code{__LINE__}マクロの結果を変更する。@xref{Standard Predefined Macros}。 @samp{#include}の現在のファイルを含むディレクトリの考え方には何の影響もない。

@node Pragmas
@chapter プラグマ

@samp{#pragma}ディレクティブは、言語自体で伝えられるものを超えて、コンパイラに追加情報を提供するためのC標準で指定された方法である。 C標準で指定されているこのディレクティブの形式（一般に@dfn{プラグマ}と呼ばれる）には@code {STDC}という接頭辞が付く。 Cコンパイラは、好きな意味を他のプラグマに自由に付けることができる。 すべてのGNU定義のサポートされているプラグマには@code{GCC}という接頭辞が付いている。

@cindex @code{_Pragma}
C99は@code{@w{_Pragma}}演算子を導入した。 この機能は、@samp{#pragma}の大きな問題に対処する。ディレクティブなので、マクロ展開の結果として生成することはできない。 @code{@w{_Pragma}}は、@ code{sizeof}や@code{defined}とよく似た演算子で、マクロに埋め込むことができる。

構文は@code{@w{_Pragma(@var{string-literal})}}である。@var{string-literal}は通常の文字列リテラルまたはワイド文字の文字列リテラルのどちらでもよい。 すべての@samp{\\}を単一の@samp{\}と置き換え、すべての@samp{\"}を@samp{"}に置き換えることによって、それは非文字列化される。 結果は@samp{#pragma}ディレクティブの右側に現れたかのように処理される。例えば、

@smallexample
_Pragma ("GCC dependency \"parse.y\"")
@end smallexample

@noindent
は@code{#pragma GCC dependency "parse.y"}と同じ効果がある。 マクロを使用して同じ効果を達成することもできる。

@smallexample
#define DO_PRAGMA(x) _Pragma (#x)
DO_PRAGMA (GCC dependency "parse.y")
@end smallexample

標準では、@code{_Pragma}演算子がどこに現れるかは不明である。 プリプロセッサは@samp{#if}のような前処理条件ディレクティブ内でプリプロセッサを受け付けない。 安全のためには、おそらく@samp{#define}以外のディレクティブを避けて、それを独自の行に置くのが最良である。

このマニュアルでは、プリプロセッサそのものに意味のあるプラグマについて説明する。 他のプラグマは、CまたはC++コンパイラとって意味がある。 それらはGCCマニュアルに記載されている。

GCCプラグインは独自のプラグマを提供することがある。

@ftable @code
@item #pragma GCC dependency
@code{#pragma GCC dependency}では、現在のファイルと別のファイルの相対日付を調べることができる。 他のファイルが現在のファイルより新しい場合、警告が発行される。 これは、現在のファイルが他のファイルから派生し、再生成する必要がある場合に便利である。 他のファイルは、通常のインクルード検索パスを使用して検索される。 オプションの末尾のテキストを使用して、警告メッセージの詳細を指定できる。

@smallexample
#pragma GCC dependency "parse.y"
#pragma GCC dependency "/usr/include/time.h" rerun fixincludes
@end smallexample

@item #pragma GCC poison
場合によっては、あなたのプログラムから完全に削除したい識別子がある。これを強制するために、このプラグマで識別子を@dfn{有害化}することができる。 @code{#pragma GCC poison}の後には、毒の識別子のリストが続く。 これらの識別子のいずれかがディレクティブの後にソースのどこに現れても、それはハードエラーである。 例えば、

@smallexample
#pragma GCC poison printf sprintf fprintf
sprintf(some_string, "hello");
@end smallexample

@noindent
はエラーを発する。

有害化された識別子が、識別子が有害化される前に定義されたマクロの展開の一部として表示される場合、エラーは発生し@emph{ない}。 これにより、識別子を使用するマクロを定義しているシステムヘッダについて心配することなく、識別子に害を与えることができる。

例えば

@smallexample
#define strrchr rindex
#pragma GCC poison rindex
strrchr(some_string, 'h');
@end smallexample

@noindent
はエラーを発しない。

@item #pragma GCC system_header
このプラグマは引数をとらない。 現在のファイルの残りのコードは、あたかもシステムヘッダから来たものとして扱われる。
@xref{System Headers}.

@item #pragma GCC warning
@itemx #pragma GCC error
@code{#pragma GCC warning "message"}は、プリプロセッサに@samp{message}というテキストで警告診断を発行させる。 プラグマに含まれるメッセージは、単一の文字列リテラルでなければならない。 同様に、@code{#pragma GCC error "message"}はエラーメッセージを出す。 @samp{#warning}および@samp{#error}ディレクティブとは異なり、これらのプラグマは@samp{_Pragma}を使用してプリプロセッサマクロに埋め込むことができる。

@end ftable

@node Other Directives
@chapter 他のディレクティブ

@findex #ident
@findex #sccs
@samp{#ident}ディレクティブは1つの引数、文字列定数をとる。 一部のシステムでは、その文字列定数がオブジェクトファイルの特別なセグメントにコピーされる。 他のシステムでは、このディレクティブは無視される。 @samp{#sccs}ディレクティブは@samp{#ident}の同義語である。

これらの指令はC標準の一部ではないが、公式のGNU拡張でもない。 私たちが発見した歴史的な情報は、System Vの起源であることを示唆している。

@cindex null directive
@dfn{nullディレクティブ}は、@samp{＃}の後に改行が続き、その間に空白（コメントを含む）のみが含まれている。 nullディレクティブは前処理ディレクティブと解釈されるが、プリプロセッサ出力には影響しない。 nullディレクティブが存在する主な意味は、単に@samp{＃}からなる入力行では、@samp{＃}を含む出力行ではなく、出力が生成されないことである。 おそらく古いCプログラムにはこのような行が含まれている。

@node Preprocessor Output
@chapter プリプロセッサの出力

CプリプロセッサをC、C++、またはObjective-Cコンパイラとともに使用すると、コンパイラに統合され、バイナリトークンのストリームを直接コンパイラのパーサーに伝える。 ただし、より一般的なスタンドアロンモード（テキスト出力を生成する）で使用することもできる。
@c FIXME: Document the library interface.

@cindex output format
Cプリプロセッサからの出力は入力とよく似ているが、すべての前処理ディレクティブ行が空白行で、すべてのコメントがスペースで置き換えられている。 長い行の空白行は破棄される。

ISO標準は、プリプロセッサがトークン間の空白を保存するか、それを例えば単一のスペースで置き換えるかを実装が定義することを指定する。 GNU CPPでは、非指向性の行の最初のトークンの前に、非ディレクティブ行の最初のトークンの前には、元のソースファイルに現れた前処理された出力の同じ列に表示される十分なスペースがあることを除いて、トークン間の空白が折りたたまれて単一のスペースになる。 これは、出力が読みやすくなるようにするためである。 CPPは、偶発的なトークンペーストを防止するために必要な場合を除いて、元のソースに何もなかった空白を挿入しない。

@cindex linemarkers
ソースファイル名と行番号情報は以下の形式の行で伝えられる。

@smallexample
# @var{linenum} @var{filename} @var{flags}
@end smallexample

@noindent
これらは@dfn{行マーカー}と呼ばれる。 これらは、必要に応じて出力に挿入される（ただし、文字列定数または文字定数内には挿入されない）。 これは、次の行が@var{linenum}行のファイル@var{filename}に由来することを意味する。 @var{filename}には印刷されない文字は含まれない。 それらは8進エスケープシーケンスに置き換えられる。

ファイル名の後に@samp{1}、@samp{2}、@samp{3}、@samp{4}のフラグが0個以上ある場合。 複数のフラグがある場合は、スペースで区切られる。 フラグの意味は次のとおりである。

@table @samp
@item 1
これは、新しいファイルの開始を示す。
@item 2
これは、ファイルに戻ったことを示す（別のファイルを組み込んだ後）。
@item 3
これは、次のテキストがシステムヘッダファイルから来ることを示しているため、特定の警告を抑制する必要がある。
@item 4
これは、次のテキストが暗黙の@code{extern "C"}ブロックで囲まれているものとして扱われるべきであることを示す。
@c maybe cross reference NO_IMPLICIT_EXTERN_C
@end table

拡張として、プリプロセッサは、アセンブラ以外の入力ファイルで行マーカを受け入れる。 それらは対応する@samp{#line}指令（@pxref{Line Control}）のように扱われるが、末尾のフラグが許され、上記の意味で解釈される。 複数のフラグが指定されている場合は、昇順でなければならない。

プリプロセッサの出力には、いくつかの指令が重複することがある。 これらは@samp{#ident}（常に）、@samp{#pragma}（プリプロセッサがプラグマ自体を処理しない場合のみ）、@samp{#define}および@samp{#undef}（特定のデバッグオプション ）。 この場合、ディレクティブの@samp{#}は常に最初のカラムにあり、@samp{＃}とディレクティブ名の間にスペースはない。 重複したディレクティブと誤っている可能性のあるトークンをマクロ展開すると、@samp{＃}とディレクティブ名の間にスペースが挿入される。

@node Traditional Mode
@chapter 従来モード

従来の（標準前の）Cプリプロセスは、標準で指定されたプリプロセスとはかなり異なる。 プリプロセッサを@option{-traditional-cpp}オプションで起動すると、プリプロセッサは従来のプリプロセッサをエミュレートしようとする。

このモードは、GCCを使用してCコードをコンパイルするのには便利ではないが、非Cプリプロセスアプリケーションでの使用を意図している。 したがって、従来のモードセマンティクスは、プリプロセッサを明示的に呼び出すときにのみサポートされ、コンパイラフロントエンドではサポートされない。

この実装は、GCCの早期プレスタンダードバージョンの動作や真の従来のプリプロセッサの動作に正確には対応していない。 結局のところ、従来の実装間の不一致がCの標準化の大きな動機となっていた。 しかし、実際に重要なすべての点で、真の従来のプリプロセッサと互換性があるはずである。

@menu
* Traditional lexical analysis::
* Traditional macros::
* Traditional miscellany::
* Traditional warnings::
@end menu

@node Traditional lexical analysis
@section 従来の字句解析

従来のプリプロセッサは、標準準拠のプリプロセッサと同じようには入力をトークンに分解しない。 入力は、内部形式が最小のテキストストリームとして扱われる。

この実装では、トリグラフ（@pxref {trigraphs}）は、標準委員会の発明であるために特別に取り扱っていない。 任意に配置されたエスケープされた改行を適切に処理し、期待通りに行をスプライスする。 多くの従来のプリプロセッサはこれをしなかった。

入力ファイル内の水平空白の形式は、出力に保存される。 特に、硬いタブは硬いタブのままである。 これは、たとえば、Makefileをプリプロセスしている場合などに便利である。

従来のCPPはCスタイルのブロックコメントだけを認識し、@samp{/*}シーケンスは引用されたテキストの外にある場合にのみコメントを挿入するものとして扱う。 クォートされたテキストは、通常の一重引用符と二重引用符、および@code{#include}ディレクティブの最初の@samp{<}によって導入される。

従来は、コメントは完全に削除され、スペースで置き換えられない。 従来のコンパイラはプリプロセッサの出力を独自のトークン化しているため、トークンペースト演算子としてコメントを効果的に使用できる。 ただし、コメントはプリプロセッサ自体が扱うテキストの区切り文字のように振る舞う。なぜなら、コメントは入力を再解析しないからである。 たとえば、

@smallexample
#if foo/**/bar
@end smallexample

@noindent
は@samp{foo}と@samp{bar}は別個の識別子であり、マクロである場合は別々に展開される。 言い換えれば、この指令は

@smallexample
#if foo bar
@end smallexample

@noindent
と等価であって、以下ではない

@smallexample
#if foobar
@end smallexample

一般的に言えば、従来モードでは、開始クォートには一致する終了クォートを付ける必要はない。 特に、不一致の引用を含む置換テキストでマクロを定義することができる。 もちろん、一致しない引用符を含むプリプロセスされた出力をコンパイルしようとすると、構文エラーが発生する。

しかし、@ code {#define}以外のすべての前処理ディレクティブは、引用符を一致させる必要がある。 例えば：

@smallexample
#define m This macro's fine and has an unmatched quote
"/* This is not a comment.  */
/* @r{This is a comment.  The following #include directive
   is ill-formed.}  */
#include <stdio.h
@end smallexample

ISOプリプロセッサの場合と同様に、引用符で囲まれたテキストを閉じるのを防ぐために、引用符となるものをバックスラッシュでエスケープすることができる。

@node Traditional macros
@section 従来のマクロ

従来のマクロとISOマクロの主な違いは、前者がトークンシーケンスではなくテキストに展開されることである。 CPPは、格納する前に、マクロの置換テキストから前後の水平空白をすべて削除するが、内部空白の形式は保持する。

1つの結果は、置換テキストが不一致の引用符を含むことが正当であることである（@pxref{Traditional lexical analysis}）。 閉じられていない文字列または文字定数は、マクロ呼び出しの後のテキストに続く。 同様に、マクロの展開の最後にあるテキストは、マクロ呼び出しの後のテキストと共に実行され、単一のトークンを生成することができる。

マクロが展開された後は、通常、コメントは置換テキストから削除されるが、@option{-CC}オプションが渡された場合、コマンドラインコメントは保持される。 （現行の実装では、マクロ置換テキストを保存する前にコメントを削除しているが、関数のようなマクロの場合でも、観察された効果が同じであるように注意せよ）。

ISO文字列化演算子@samp{＃}とトークンペースト演算子@samp{##}は特別な意味を持たない。 後述するように、これらの演算子と同様の効果を別の方法で得ることができる。 メインファイルからまたはマクロ置換後に引用符で埋め込まれたマクロ名は展開されない。

CPPは、引用符で囲まれていないオブジェクトのようなマクロ名をその置換テキストに置き換え、それを再スキャンして置き換えるマクロを探す。 標準のマクロ展開とは異なり、従来のマクロ展開では再帰を防ぐ手段はない。 オブジェクトのようなマクロが置換テキストに引用符で囲まれていないように見える場合は、再スキャンパス中に再度置換され、@emph{無限に}置換される。 GCCは、再帰マクロを展開しているときにそれを検出し、エラーメッセージを出し、問題のあるマクロ呼び出しのあとで処理を続行する。

@smallexample
#define PLUS +
#define INC(x) PLUS+x
INC(foo);
     @expansion{} ++foo;
@end smallexample

関数風マクロは、形式は似ているが、ISOの動作とはまったく異なる。 それらの引数はカッコで囲まれ、カンマで区切られ、物理的な行を横切ることができる。 ネストしたカッコ内のカンマは、引数の区切りとして扱われない。 同様に、引数の引用符は閉じられないままにすることはできない。 閉じ引用符の前に来る次のカンマまたは括弧は、他の文字と同様に扱われる。 可変マクロを扱う機能はない。

@option{-C}オプションが指定されていない限り、この実装はマクロ引数からすべてのコメントを削除する。 引数の中の他のすべての水平空白の形式は、先頭と末尾の空白を含めて保持される。 特に

@smallexample
f( )
@end smallexample

@noindent
は単一の空白を含む引数での@samp{f}マクロの呼び出しとして処理される。 引数をとらない関数のようなマクロを呼び出す場合は、かっこの間に空白を入れてはいけない。

マクロ引数が新しい行と交差する場合、新しい行は引数を形成するときにスペースで置き換えられる。 前の行に終わりのない引用符が含まれていた場合、次の行は引用された状態を継承する。

従来のプリプロセッサは、パラメータが引用符で囲まれているかどうかにかかわらず、置換テキストのパラメータを引数で置き換える。 これは、引数を文字列化する方法を提供する。 例えば

@smallexample
#define str(x) "x"
str(/* @r{A comment} */some text )
     @expansion{} "some text "
@end smallexample

@noindent
コメントは削除されるが、末尾のスペースは保持される。 トークンの貼り付けを行うためにコメントを使用する例を次に示す。

@smallexample
#define suffix(x) foo_/**/x
suffix(bar)
     @expansion{} foo_bar
@end smallexample

@node Traditional miscellany
@section 従来の寄せ集め

従来のプリプロセッサを使用する際に注意すべき点がいくつかある。

@itemize @bullet
@item
プリプロセスディレクティブは、先頭の@samp{＃}が最初の列に表示されている場合にのみ認識される。 行の先頭と@samp{＃}の間には空白は入れられないが、@samp{＃}の後に置くことはできる。

@item
真の従来のCプリプロセッサは@samp{#error}や@samp{#pragma}を認識せず、@ samp{#elif}を認識しないかもしれない。 CPPは、@samp{#pragma GCC poison}の効果が定義されていないことを除いて、拡張を含む、ISOモードでサポートされている従来のモードのすべてのディレクティブをサポートしている。

@item
__STDC__は定義されていない、

@item
ダイグラフを使用する場合、その動作は未定義である。

@item
ディレクティブのように見える行がマクロ引数内に現れた場合の動作は未定義である。

@end itemize

@node Traditional warnings
@section 従来の警告
従来のCでは、@option{-Wtraditional}オプションを使用して、存在しなかった機能や別の方法で動作していた機能に関する警告を要求できる。 GCCは、@samp{＃}や@samp{##}のようなコンパイラを使用しているときに使用しなければならないISO Cの機能について警告しない。

現在のところ、@ option{-Wtraditional}は次のことについて警告している：

@itemize @bullet
@item
マクロ本体の文字列リテラル内に現れるマクロパラメーター。 従来のCでは、マクロ置換は文字列リテラル内で行われるが、ISO Cでは行われない。

@item
従来のCでは、いくつかのプリプロセッサディレクティブが存在しなかった。 従来のプリプロセッサは、@samp{＃}がその行の第1列に現れた場合にのみ、その行を指令とみなす。 したがって、@option{-Wtraditional}は従来のCが理解できるが、@samp{＃}が行の最初の文字として表示されないので無視するディレクティブについて警告する。 @samp{#pragma}のようなディレクティブは、従来のCでインデントされても理解できないことを示唆している。 従来の実装の中には@samp{#elif}を認識しないものもあるので、それを避けることを推奨する。

@item
引数リストなしで表示される関数のようなマクロ。 一部の従来のプリプロセッサでは、これがエラーだった。 ISO Cでは、単にマクロが展開されていないことを意味する。

@item
単項プラス演算子。 これは従来のCには存在しなかった。

@item
@samp{U}と@samp{LL}の整数定数の接尾辞は、従来のCでは利用できなかった。 （従来のCは、単純なlong整数定数の@samp{L}接尾辞はサポートしている。）システムヘッダーで定義されているマクロでは、これらの接尾辞の使用について警告は表示されない。 例えば、@code{UINT_MAX}は@code{4294967295U}として定義されているかもしれないが、@code{UINT_MAX}を使用しても警告されない。

問題の整数定数を16進数でU接尾辞をつけずに書くことによって、通常は警告とそれに付随していないほど大きな定数に関する警告を避けることができる。 しかし、これはエキゾチックな場合に間違った結果をもたらすので注意すること。
@end itemize

@node Implementation Details
@chapter 実装の詳細

ここでは、プリプロセッサの実装がユーザに見える動作にどのように影響するかについて詳しく説明する。 将来の実装で微妙に変化する可能性があるため、ここで説明した動作に過度の依存を避けるべきである。

また、CPPでサポートされている旧式の機能もここに記載されている。

@menu
* Implementation-defined behavior::
* Implementation limits::
* Obsolete Features::
@end menu

@node Implementation-defined behavior
@section 実装定義の振る舞い
@cindex implementation-defined behavior

これは、CPPが@dfn{実装定義}と記述しているすべてのケースでCPPがどのように動作するかを示している。 この用語は、実装が好きなことを自由に行うことできるが、その選択肢を文書化してそれに固執する必要がありことを意味する。
@c FIXME: Check the C++ standard for more implementation-defined stuff.

@itemize @bullet
@need 1000
@item 物理的なソースファイルのマルチバイト文字の実行文字セットへのマッピング。

入力文字セットは@option{-finput-charset}オプションを使用して指定でき、実行文字セットは@option{-fexec-charset}および@option{-fwide-exec-charset}オプションを使用して制御できる。

@item 識別子文字
@anchor{Identifier characters}

CおよびC++標準では、識別子を@samp{_}と英数字で構成することができる。 C++では、ユニバーサル文字の名前も使用できる。 C99以降のC標準では、普遍的な文字名と実装定義文字の両方が許可されている。

GCCでは、識別子内の@samp{$}文字をほとんどのターゲットの拡張として使用できる。 これは、@option{std =}スイッチに関係なく、この拡張が標準準拠のプログラムと競合しないので当てはまる。 ただし、アセンブラをプリプロセスする場合、ドルはデフォルトで識別子文字ではない。

現在、デフォルトで@samp{$}を許可しないターゲットは、AVR、IP2K、MMIX、MIPS Irix 3、ARM aout、およびAIXオペレーティングシステムのPowerPCターゲットである。

デフォルトは、@option{-fdollars-in-identifiers}または@option{fno-dollars-in-identifiers}で上書きできる。 @xref{fdollars-in-identifiers}

@item 空白文字の空でない列

テキスト出力では、各空白シーケンスは1つのスペースに縮小される。 審美的な理由から、出力の各非指示行の最初のトークンの前には、元のソースファイルと同じ列に表示される十分なスペースがある。

@item プリプロセッサ式の文字定数の数値。

プリプロセッサとコンパイラは同じ方法で文字定数を解釈する。 すなわち、@samp{\a}のようなエスケープシーケンスには、ターゲットマシン上での値が与えられる。

コンパイラは、一度に複数文字の文字定数を評価し、前の値をターゲット文字あたりのビット数だけシフトしてから、新しい文字のビットパターンをターゲット文字の幅に合わせて論理和を取る。 最終的なビットパターンは@code{int}型で与えられる。したがって、単一の文字が符号ありかどうかにかかわらず、符号ありになる。 定数の中にターゲットの@code{int}よりも多くの文字があると、コンパイラは警告を出し、余分な先頭の文字は無視される。

例えば、8ビットの@code{char}を持つターゲットの@code{'ab'}は@w{@samp{(int) ((unsigned char) 'a' * 256 + (unsigned char)'b')}}となり、@code{'\234a'}は@w{@samp{(int) ((unsigned char) '\234' * 256 + (unsigned char) 'a')}}に変換される。
@item ソースファイル挿入

プリプロセッサがヘッダファイルをどのように配置するかについては、@ref{Include Operation}.

@item マクロ展開された@samp {#include}ディレクティブの結果としてのファイル名の解釈。

@xref{Computed Includes}.

@item マクロ展開が標準プラグマを生じた後の@samp{#pargma}の扱い

どんな@samp{#pragma}指令行でもマクロ展開が起こらないので、問題は発生しない。

GCCはまだ標準プラグマを実装していないことに注意せよ。

@end itemize

@node Implementation limits
@section 実装の制限
@cindex implementation limits

CPPには少数の内部制限がある。 このセクションでは、C標準が最小限以上になることを要求する制限と、その他すべての既知の制限をリストしている。 可能な限りの制限は少なくすべきである。 文書化されていないまたは不都合な制限に遭遇した場合は、バグとして報告してください。 @xref{Bugs, , Reporting Bugs, gcc, Using the GNU Compiler Collection (GCC)}.

何かが@dfn{利用可能なメモリのみで制限されている}と言うと、内部データ構造は本質的な制限を課さず、スペースは@code{malloc}か同等のもので割り当てられる。 したがって、実際の制限は、コンパイラによって同時に割り当てられる他のもののサイズ、同じコンピュータ上の他のプロセスによって消費されるメモリ量など、多くのものに依存する。

@itemize @bullet

@item @samp{#include}ファイルのネストレベル。

暴走の再帰を避けるために、200レベルの任意の制限を課している。 標準は少なくとも15レベルが必要である。

@item 条件インクルードのネストレベル

C標準はこれを少なくとも63にすることを要求している。CPPは利用可能なメモリによってのみ制限される。

@item 完全な式の中のカッコで囲まれた式のレベル。

C標準ではこれを少なくとも63にする必要がある。プリプロセッサの条件式では、使用可能なメモリによってのみ制限される。

@item 識別子またはマクロ名に重要な初期文字。

プリプロセッサはすべての文字を重要なものとして扱う。 C標準では、最初の63文字だけが重要であることが必要である。

@item 1つの翻訳単位で同時に定義されたマクロの数。

標準では、少なくとも4095を可能にする必要がある。 CPPは利用可能なメモリによってのみ制限される。

@item マクロ定義のパラメータ数とマクロ呼び出しの引数

65,535以上の@code {USHRT_MAX}を許可する。 標準で要求される最小値は127である。

@item 論理ソース行の文字数。

Cの標準では、最低4096を許可する必要がある。 CPPはこれに制限を設けていないが、65,535文字を超える行の診断で不正な列番号が報告されることがある。

@item ソースファイルの最大サイズ。

標準では、ソースファイルの最大サイズの下限は指定されていない。 GNU cppはファイルをメモリにマップするので、使用可能なアドレス空間によって制限される。 これは一般に少なくとも2ギガバイトである。 オペレーティングシステムによっては、物理メモリのサイズが制限される場合もあれば、制限されない場合もある。

@end itemize

@node Obsolete Features
@section 廃止された機能

CPPには、主に古いプログラムとの互換性のために存在するいくつかの機能がある。 新しいコードでの使用は推奨しない。 場合によっては、GCCの将来のバージョンでこの機能を削除する予定である。

@subsection アサーション
@cindex assertions

@dfn{アサーション}は、コンパイルされたプログラムがどのような種類のコンピュータやシステムを実行するのかをテストするために、条件文を書く際に推奨されないマクロである。 アサーションは通常は事前定義されているが、プリプロセスディレクティブまたはコマンドラインオプションを使用してアサーションを定義できる。

アサーションは、コンパイラのターゲットシステムをより体系的に説明するためのもので、既存のコンパイラとの互換性のために追加した。 実際には、システム固有の定義済みマクロほど予測できない。 さらに、それらは標準の一部ではなく、ほんのわずかのコンパイラでサポートされている。 したがって、アサーションの使用は、システム固有の定義済みマクロの使用よりも移植性が@strong{低く}なる。 それらはまったく使用しないことを推奨する。

@cindex predicates
アサーションはこのようになる

@smallexample
#@var{predicate} (@var{answer})
@end smallexample

@noindent
@var{predicate}は単一の識別子でなければならない。 @var{answer}にはトークンの任意のシーケンスを指定できる。 先頭と末尾の空白を除いてすべての文字が重要であり、内部の空白シーケンスの違いは無視される。 （これはマクロの再定義を支配する規則に似ている）。したがって、@code{(x + y)}は@code{(x+y)}と異なりますが、@code{@w{( x + y )}}と同じである。 括弧は答えの中に入れ子にならない。

@cindex testing predicates
アサーションをテストするには、@samp{#if}に記述する。 たとえば、@code{vax}または@code{ns16000}のいずれかが@code{machine}の答えとしてアサートされている場合、この条件は成功する。

@smallexample
#if #machine (vax) || #machine (ns16000)
@end smallexample

@noindent
@emph{任意}の答えが述語に対してアサートされているかどうかは、条件付きで答えを省略することでテストできる。

@smallexample
#if #machine
@end smallexample

@findex #assert
アサーションは@samp{#assert}ディレクティブで行う。 その唯一の引数は、アサーションを条件付きのアサーションを識別する先頭の@samp{＃}なしにする。

@smallexample
#assert @var{predicate} (@var{answer})
@end smallexample

@noindent
同じ述語と異なる答えでいくつかのアサーションを作ることができる。 後続のアサーションは、同じ述語の前のアサーションを上書きしない。 与えられた述語のすべての回答は同時に真である。

@cindex assertions, canceling
@findex #unassert
アサーションは@samp{#unassert}ディレクティブで取り消すことができる。 @samp{#assert}と同じ構文である。 この形式では、@samp{#unassert}行で指定された回答のみが取り消される。 その述語に対する他の答えは真である。 答えを残して、述部全体を取り消すことができる。

@smallexample
#unassert @var{predicate}
@end smallexample

@noindent
どちらの形式でも、そのようなアサーションが作成されていない場合、@samp{#unassert}は効果がない。

また、コマンドラインオプションを使用してアサーションを作成または取り消すこともできる。
@xref{Invocation}.

@node Invocation
@chapter 呼び出し
@cindex invocation
@cindex command line

ほとんどの場合、Cプリプロセッサを使用するときは、明示的に呼び出す必要はない。Cコンパイラは自動的にそうする。 ただし、プリプロセッサは単独では便利なことがある。 プリプロセッサを起動するには、@command{cpp}コマンドまたは@command{gcc -E}コマンドを使用する。 GCCでは、プリプロセッサは実際には別のプログラムではなくコンパイラと統合されており、これらのコマンドは両方ともGCCを呼び出し、前処理フェーズ後に停止するよう指示する。

ここにリストされている@command{cpp}オプションは@command{gcc}でも受け入れられ、同じ意味を持つ。 同様に、@command{cpp}コマンドは通常の@command{gcc}ドライバオプションをすべて受け付けるが、前処理後のコンパイルフェーズに関するものは無視される。

プリプロセスの振る舞いに固有のオプションのみがここに記述されている。 その他のドライバオプションの詳細については、GCCのマニュアルを参照せよ。

@ignore
@c man begin SYNOPSIS
cpp [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
    [@option{-I}@var{dir}@dots{}] [@option{-iquote}@var{dir}@dots{}]
    [@option{-M}|@option{-MM}] [@option{-MG}] [@option{-MF} @var{filename}]
    [@option{-MP}] [@option{-MQ} @var{target}@dots{}]
    [@option{-MT} @var{target}@dots{}]
    @var{infile} [[@option{-o}] @var{outfile}]

上で最も有用なオプションだけが与えられている。 プリプロセッサ固有のオプションの完全なリストについては、以下を参照せよ。 さらに、@command{cpp}はほとんどの@command{gcc}ドライバオプションを受け入れるが、ここには記載されていない。 詳細については、GCCのドキュメントを参照せよ。
@c man end
@c man begin SEEALSO
gpl(7)、gfdl(7)、fsf-funding(7)、
gcc(1)及び、@file{cpp}と@file{gcc}のInfo項目
@c man end
@end ignore

@c man begin OPTIONS
@command{cpp}コマンドは、引数として2つのファイル名@var{infile}と@var{outfile}を想定している。 プリプロセッサは@var {infile}を@samp{#include}で指定した他のファイルと一緒に読み込む。 結合された入力ファイルによって生成されたすべての出力は、@var{outfile}に書き込まれる。

@var{infile}または@var{outfile}は、@option{-}にすることができ、@var{infile}は標準入力からの読み込みを意味し、@var{outfile}は標準出力への書き出しを意味する。 いずれかのファイルが省略されている場合は、そのファイルに@option{-}が指定されているのと同じ意味である。 @option{-o @var{outfile}}オプションを使用して出力ファイルを指定することもできる。

特に明記しているか、オプションが@samp{=}で終わっているのでなければ、引数をとるすべてのオプションは、その引数の直後、またはオプションと引数の間のスペースがあってもよい。@option{-Ifoo}と@option{-I foo}は同じ効果がある。

@cindex grouping options
@cindex options, grouping
多くのオプションは複数文字の名前を持っている。 複数の一文字オプションはグループ化され@emph{ない}： @option{-dM}は@w{@samp {-d -M}}と非常に異なる。

@cindex options

@table @gcctabopt
@include cppopts.texi
@include cppdiropts.texi
@include cppwarnopts.texi
@end table
@c man end

@node Environment Variables
@chapter 環境変数
@cindex environment variables
@c man begin ENVIRONMENT

このセクションでは、CPPの動作に影響を与える環境変数について説明する。 これらを使用して、インクルードファイルの検索時や依存関係出力の制御時に使用するディレクトリや接頭辞を指定することができる。

@option{-I}などのオプションを使用して検索する場所を指定したり、@option{-M}（@pxref{Invocation}）などのオプションを使用して依存関係の出力を制御することもできる。 これらは環境変数よりも優先され、環境変数はGCCの設定よりも優先される。

@include cppenv.texi
@c man end

@page
@include fdl.texi

@page
@node Index of Directives
@unnumbered Index of Directives
@printindex fn

@node Option Index
@unnumbered Option Index
@noindent
CPP's command-line options and environment variables are indexed here
without any initial @samp{-} or @samp{--}.
@printindex op

@page
@node Concept Index
@unnumbered Concept Index
@printindex cp

@bye
