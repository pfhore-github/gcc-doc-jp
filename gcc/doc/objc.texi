@c Copyright (C) 1988-2018 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node Objective-C
@comment  node-name,  next,  previous,  up

@chapter GNU Objective-Cの特徴

このドキュメントは、GNU Objective-Cの機能のいくつかを説明するためのものである。 Objective-Cを教えることを意図したものではない。 インターネット上には、その言語を提示するいくつかのリソースがある。

@menu
* GNU Objective-C runtime API::
* Executing code before main::
* Type encoding::
* Garbage Collection::
* Constant string objects::
* compatibility_alias::
* Exceptions::
* Synchronization::
* Fast enumeration::
* Messaging with the GNU Objective-C runtime::
@end menu

@c =========================================================================
@node GNU Objective-C runtime API
@section GNU Objective-C ランタイム API

この節は、GNU Objective-Cランタイムに特有のものである。 別のランタイムを使用している場合は、この節をスキップできる。

GNU Objective-Cランタイムは、Objective-Cランタイムシステムと対話し、実行時ランタイム構造を照会し、それらを操作することを可能にするAPIを提供する。 これにより、例えば、クラス、メソッド、プロトコルを検査してナビゲートすることができる。 新しいクラスや新しいメソッドを定義し、既存のクラスやプロトコルを変更することさえできる。

GNUstep-Baseのような 「Foundation」'ライブラリを使用している場合、このライブラリは多くの検査タスクを行う豊富な機能を提供する。おそらく、新しいクラスやメソッドを定義するには、GNU Objective-CランタイムAPIに直接アクセスするだけで済む。

@menu
* Modern GNU Objective-C runtime API::
* Traditional GNU Objective-C runtime API::
@end menu

@c =========================================================================
@node Modern GNU Objective-C runtime API
@subsection 新しいGNU Objective-CランタイムAPI

GNU Objective-Cランタイムは、「Objective-C 2.0」のApple/NeXT Objective-Cランタイムが提供するAPIに似たAPIを提供する。 APIは、GNU Objective-Cランタイムのパブリックヘッダファイルに記述されている。

@itemize @bullet

@item
@file{objc/objc.h}: これは基本的なObjective-Cヘッダファイルで、@code{id}、@code{Class}、@code{BOOL}のような基本的なObjective-Cの型を定義する。 Objective-Cにはほとんど何でもするためにこのヘッダーを含める必要がある。

@item
@file{objc/runtime.h}: このヘッダーは、Objective-Cランタイムデータ構造の検査と操作を可能にする、ほとんどのパブリックランタイムAPI関数を宣言している。 これらの関数は、Objective-Cランタイム間でかなり標準化されており、Apple/NeXT Objective-Cランタイムとほぼ同じである。 特殊な領域（メッセージの呼び出しの作成と転送、スレッド化）での関数は宣言されてなく、下の他のヘッダーにある。 @file{objc/runtime.h}で宣言されている@code{class_getName()}などの関数を使用するには、@file{objc/objc.h}と@file{objc/runtime.h}をインクルードする必要がある。

@item
@file{objc/message.h}: このヘッダーは、メッセージの呼び出しを構築、分解、転送するために使用されるパブリック関数を宣言する。 メッセージングは異なるランタイムで全く異なる方法で行われるため、このヘッダーの関数はGNU Objective-Cランタイム実装に固有である。

@item
@file{objc/objc-exception.h}: このヘッダーは、Objective-C例外に関連するいくつかのパブリック関数を宣言する。 たとえば、このヘッダーの関数を使用すると、単純なC/C ++コードからObjective-C例外をスローすることができる。

@item
@file{objc/objc-sync.h}: このヘッダーはObjective-C @code{@@synchronized()}構文に関連するいくつかのパブリック関数を宣言し、Objective-C @code{@@synchronized()}ブロックを単純なC/C++コードでエミュレートできる。

@item
@file{objc/thr.h}: このヘッダーは、GNU Objective-Cランタイムによってのみ提供されるパブリックランタイムAPIスレッディングレイヤを宣言する。 これは、@code{objc_mutex_lock()}のような関数を宣言する。これは、プラットフォームに依存しないスレッド関数のセットを提供する。

@end itemize

ヘッダーファイルには、GNU Objective-CランタイムAPIの各関数の詳細なドキュメントが含まれている。

@c =========================================================================
@node Traditional GNU Objective-C runtime API
@subsection 従来のGNU Objective-CランタイムAPI

GNU Objective-Cランタイムは、「従来の」GNU Objective-CランタイムAPIと呼ばれる異なるAPIを提供するために使用されていた。 このAPIに属する関数は、@code{class_getSuperclass()}（現代のAPI）の代わりに@code{class_get_super_class()}（従来のAPI）などの異なる命名規則を使用するため、認識しやすくなる。 このAPIを使用するソフトウェアには、宣言されている@file{objc/objc-api.h}ファイルが含まれている。

GCC 4.7.0以降、もはや従来のGNUランタイムAPIは利用できない。

@c =========================================================================
@node Executing code before main
@section @code{+load}: @code{main}の前に実行されるコード

この節は、GNU Objective-Cランタイムに特有のものである。 別のランタイムを使用している場合は、この節をスキップできる。

GNU Objective-Cランタイムは、プログラムの実行が@code{main}関数に入る前にコードを実行できる方法を提供する。 このコードは特別なクラスメソッド@code{+load}によって、クラスごとおよびカテゴリごとに実行される。

この機能は、最初にクラスにメッセージを送信することなく、プログラムが直接アクセスできるグローバル変数を初期化する場合に非常に便利である。@code{+initialize}メソッドがグローバル変数を初期化する通常の方法は、場合によっては遅すぎる可能性があるため、最初のメッセージがクラスオブジェクトに送られたときにのみ呼び出されるので便利ではないかもしれない。

たとえば、以下のように、@code{Stdin}、@code{Stdout}および@code{Stderr}をグローバル変数として宣言する@code{FileStream}クラスがあるとする。

@smallexample

FileStream *Stdin = nil;
FileStream *Stdout = nil;
FileStream *Stderr = nil;

@@implementation FileStream

+ (void)initialize
@{
    Stdin = [[FileStream new] initWithFd:0];
    Stdout = [[FileStream new] initWithFd:1];
    Stderr = [[FileStream new] initWithFd:2];
@}

/* @r{Other methods here} */
@@end

@end smallexample

この例では、@code{Stdin}、@code{Stdout}と@code{+initialize}の@code{Stderr}の初期化が遅すぎる。 プログラマは、変数が実際に初期化される前に、これらのオブジェクトの1つにメッセージを送信して、メッセージを@code{nil}オブジェクトに送ることができる。 グローバル変数を実際に初期化する@code{+initialize}メソッドは、最初のメッセージがクラスオブジェクトに送られるまで呼び出されない。 これらの変数は、@code{main}を入力する直前に初期化する必要がある。

上記の問題の正しい解決策は、@code{+initialize}の代わりに@code{+load}メソッドを使うことである：

@smallexample

@@implementation FileStream

+ (void)load
@{
    Stdin = [[FileStream new] initWithFd:0];
    Stdout = [[FileStream new] initWithFd:1];
    Stderr = [[FileStream new] initWithFd:2];
@}

/* @r{Other methods here} */
@@end

@end smallexample

@code {+ load}は、カテゴリによってオーバーライドされないメソッドである。 クラスとカテゴリの両方が@code{+load}を実装している場合、両方のメソッドが呼び出される。 これにより、カテゴリ内でいくつかの追加の初期化を実行できる。

このメカニズムは、@code{+initialize}の代わりになるものではない。@code{+initialize}の代わりにそれを使用することに決めたときの限界を知っておくべきある。

@menu
* What you can and what you cannot do in +load::
@end menu


@node What you can and what you cannot do in +load
@subsection @code{+load}でできることとできないこと

@code{+load}は最後の手段としてのみ使用される。 非常に早い時期に実行されるため、@code{+load}が実行されたとき、ほとんどのObjective-Cランタイム機械は準備ができていない。 したがって、@code{+load}はObjective-Cランタイムとは独立したCコードの実行に最適である。

GNUランタイムの@code{+load}実装は、あなたに次のことを保証する。

@itemize @bullet

@item
あなたは好きなCコードを書くことができる。

@item
クラスが同じファイルに実装されているオブジェクトにメッセージを割り当てて送信することができる。

@item
クラスのすべてのスーパークラスの@code{+load}実装は、そのクラスの@code{+load}が実行される前に実行される。

@item
クラスの@code{+load}実装は、どのカテゴリの@code{+load}実装よりも前に実行される。

@end itemize

特に、次のようなことは、たとえ特定のケースで動いたとしても、保証されていない。

@itemize @bullet

@item
任意のオブジェクトへのメッセージの割り当てまたは送信。

@item
同じファイルにカテゴリが実装されているオブジェクトへのメッセージの割り当てまたは送信。

@item
Objective-C定数文字列にメッセージを送る（@code{@@"これは定数文字列"}）。

@end itemize

クラスの@code{+load}を書くときに、兄弟クラスで@code{+load}を受け取ることについての仮定をするべきではない。 兄弟クラスが@code{+load}を受け取る順序は保証されない。

これが問題であれば、@code{+load}と@code{+initialize}が呼び出される順序が問題になる可能性がある。@code{+load}の中にオブジェクトを配置しなければ、@code{+load}が@code{+initialize}の前に呼び出されることが保証される。 @code{+load}の中にオブジェクトを作成すると、@code{+load}が呼び出されなくても、オブジェクトのクラスの@code{+initialize}メソッドが呼び出される。 クラスに対して@code{+load}を明示的に呼び出すと、@code{+initialize}が最初に呼び出される。 考えられる問題を回避するには、これらのメソッドのうちの1つだけを実装しようとすること。

@code{+load}メソッドは、バンドルが実行中のプログラムに動的にロードされるときにも呼び出される。 これは、あなたからの介入なしに自動的に行われる。 バンドルを作成し、@code{+load}を書く必要があるときは、クラスが実行中のプログラムにすでに存在するオブジェクトにメッセージを作成して安全に送信できる。 上記と同じ制限は、バンドルで定義されたクラスに適用される。



@node Type encoding
@section 型符号化

これは高度なセクションである。型の符号化は、コンパイラとランタイムによって広く使用されるが、Objective-Cを使用するためにそれらについて知る必要はない。

Objective-Cコンパイラは、すべての型の型エンコーディングを生成する。これらの型の符号化は、実行時にセレクタとメソッド、およびオブジェクトとクラスに関する情報を検索するために使用される。

型は次のように符号化される。

@c @sp 1

@multitable @columnfractions .25 .75
@item @code{_Bool}
@tab @code{B}
@item @code{char}
@tab @code{c}
@item @code{unsigned char}
@tab @code{C}
@item @code{short}
@tab @code{s}
@item @code{unsigned short}
@tab @code{S}
@item @code{int}
@tab @code{i}
@item @code{unsigned int}
@tab @code{I}
@item @code{long}
@tab @code{l}
@item @code{unsigned long}
@tab @code{L}
@item @code{long long}
@tab @code{q}
@item @code{unsigned long long}
@tab @code{Q}
@item @code{float}
@tab @code{f}
@item @code{double}
@tab @code{d}
@item @code{long double}
@tab @code{D}
@item @code{void}
@tab @code{v}
@item @code{id}
@tab @code{@@}
@item @code{Class}
@tab @code{#}
@item @code{SEL}
@tab @code{:}
@item @code{char*}
@tab @code{*}
@item @code{enum}
@tab @code {enum}はコンパイラが使用する整数型として正確に符号化される。これは列挙値に依存する。 多くの場合、コンパイラは@code{unsigned int}を使用する。これは@code{I}として符号化される。
@item 未知の型
@tab @code{?}
@item 複素数型
@tab @code{j}の後ろに内部型がある。 たとえば、@code{_Complex double}は "jd"として符号化される。
@item ビットフィールド
@tab @code{b}の後ろにビットフィールドの開始位置、ビットフィールドのタイプ、ビットフィールドのサイズ（ビットフィールドの符号化は、NeXTのコンパイラ符号化から変更された。以下を参照せよ）
@end multitable

@c @sp 1

ビットフィールドの符号化は、ビットフィールドがビットフィールドを含む型のサイズおよび整列を計算する実行時関数によって適切に処理されるように変更された。 前の符号化は、ビットフィールドのサイズのみを含んでいた。 この情報のみを使用した場合、ビットフィールドが占有するサイズを確実に計算することはできない。 Boehmのガベージコレクタが存在する場合、オブジェクトはこのコレクタで使用可能な型付きメモリファシリティを使用して割り当てられるため、これは非常に重要である。 型付きメモリ割り当てには、ポインタがオブジェクト内にある場所に関する情報が必要である。

ビットフィールド内の位置は、構造の先頭に最も近いビットの位置をビットでカウントしたものである。

非アトミック型は、次のように符号化される。

@c @sp 1

@multitable @columnfractions .2 .8
@item ポインタ
@tab @samp{^}の後ろに参照される型
@item 配列
@tab @samp {{}の後に配列の要素数、要素の型、@samp{]}が続く。
@item 構造体
@tab @samp{@{}の後ろに構造体の名前（構造体に名前がない場合は@samp{?}）、@samp{=}記号、メンバーの型、@samp{@}}が続く。
@item 共用体
@tab @samp{@(}の後ろに構造体の名前（共用体に名前がない場合は@samp{?}）、@samp{=}記号、メンバーの型、@samp{@))}が続く。
@item ベクタ
@tab @samp{!}の後ろにvector_size（ベクトルを構成するバイト数）、カンマ、ベクトルの整列（バイト単位）、要素の型、@samp{]}が続く。
@end multitable

i386マシン上のコンパイラによって生成される、いくつかの型とその符号化がここにある：

@sp 1

@multitable @columnfractions .60 .40
@item Objective-C型
@tab コンパイラ符号化
@item
@smallexample
int a[10];
@end smallexample
@tab @code{[10i]}
@item
@smallexample
struct @{
  int i;
  float f[3];
  int a:3;
  int b:2;
  char c;
@}
@end smallexample
@tab @code{@{?=i[3f]b128i3b131i2c@}}
@item
@smallexample
int a __attribute__ ((vector_size (16)));
@end smallexample
@tab @code{![16,16i]} (アラインメントは機種依存）
@end multitable

@sp 1

型に加えて、コンパイラは型指定子も符号化する。 以下の表は、現在のObjective-C型指定子の符号化について説明する。

@sp 1

@multitable @columnfractions .25 .75
@item Specifier
@tab Encoding
@item @code{const}
@tab @code{r}
@item @code{in}
@tab @code{n}
@item @code{inout}
@tab @code{N}
@item @code{out}
@tab @code{o}
@item @code{bycopy}
@tab @code{O}
@item @code{byref}
@tab @code{R}
@item @code{oneway}
@tab @code{V}
@end multitable

@sp 1

型指定子は、型の直前に符号化される。 しかし型とは異なり、型指定子はメソッド引数型に現れるときにのみ符号化される。

@code{const}がポインタとやり取りする方法に注意せよ：

@sp 1

@multitable @columnfractions .25 .75
@item Objective-C型
@tab コンパイラ符号化
@item
@smallexample
const int
@end smallexample
@tab @code{ri}
@item
@smallexample
const int*
@end smallexample
@tab @code{^ri}
@item
@smallexample
int *const
@end smallexample
@tab @code{r^i}
@end multitable

@sp 1

@code{const int *}は@code {const int}へのポインタなので、@code{^ri}として符号化される。 一方、@code{int * const}は、@code {int}への@code{const}ポインタであり、したがって@code{r^i}として符号化される。

最後に、@code{const char *}と@code{char * const}を符号化するときに複雑なことがある。 @code{char *}は@code{^c}ではなく@code{*}として符号化されているので、@code{r}がポインターまたはポインタ対象に適用されるという事実を表現する方法はない。

したがって、@code{r*}は@code{const char *}を意味するという慣例として仮定されていて（それは最もよく使われるものである）、@code{char * const}を符号化する方法はない。 @code{char * const}は単に@code{*}として符号化され、@code{const}は失われる。

@menu
* Legacy type encoding::
* @@encode::
* Method signatures::
@end menu

@node Legacy type encoding
@subsection 古い型符号化

残念ながら、歴史的にGCCはコードのコードにいくつかのバグを持っていた。 NeXTランタイムは、GCCがこの歴史的フォーマット（GCC-3.3と互換性がある）で型符号化を生成することを期待する。そのため、NeXTランタイムを使用する場合、GCCは誤ったエンコーディングをいくつか導入する。

@itemize @bullet

@item
ポイントされるものの読み取り専用修飾子は '^'の前に出される。typedefでない限り、ポインタ自体の読み取り専用修飾子は無視される。 また、 'r'は最も外側の型に対してのみ送出される。

@item
32ビット長は 'l'または 'L'としてエンコードされるが、必ずしもそうではない。 typedefの場合、structフィールドまたはポインタを符号化する場合、コンパイラは代わりに 'i'または 'I'を使用する。

@item
実際には符号なしかlongであっても、@code{enum}は常に 'i'（int）として符号化される。

@end itemize
それに加えて、NeXTランタイムは、ビットフィールドに異なる符号化を使用する。 ビットオフセットや基になるフィールドタイプを使わずに、それらを@code{b}の後にサイズで符号化する。

@node @@encode
@subsection @code{@@encode}

GNU Objective-Cは、C/Objective-C型から型の符号化を作成できる@code{@@encode}構文をサポートしている。 たとえば、@code{@@encode(int)}は、コンパイラによって@code{"i"}にコンパイルされる。

@code{@@encode}は@code{const}以外の型修飾子をサポートしていない。 たとえば、@code {@@encode(const char *)}は有効で、@code{"r*"}へとコンパイルされるが、@code{@@encode(bycopy char *)}は無効でコンパイル エラーの原因となる。

@node Method signatures
@subsection メソッドシグネチャ

この節では、Objective-Cを使用するにはめったに必要にならないメソッド型の符号化について説明する。最初に読むときにはここを飛ばすべきである。ランタイムはメソッド上で動作する関数を提供し、パラメータのリストを辿って解釈することができる。 これらの関数はパブリック「API」の一部であり、ユーザコードからのメソッドシグネチャと対話するための好ましい方法である。

しかし、メソッドのシグネチャの問題をデバッグし、メソッドシグネチャの実装方法（つまり、 「ABI」）を知る必要がある場合は、読むこと。

メソッドは、「シグネチャ」が符号化され、実行時に利用可能になる。「シグネチャ」は、実行時にメソッドの呼び出しを動的に構築するのに必要なすべての情報、つまり戻り値の型と引数を符号化する。

「シグネチャ」はヌルで終了する文字列で、次の要素で構成される：

@itemize @bullet

@item
型修飾子を含む戻り型。 たとえば、@code{int}を返すメソッドはここに@code{i}を持つ。

@item
すべてのパラメータを渡すために必要な合計サイズ（バイト単位）。 これには2つの隠しパラメータ（オブジェクト@code{self}とメソッドセレクタ@code{_cmd}）が含まれる。

@item
それぞれの引数は、型の符号化の後に、パラメータのリスト内の引数のオフセット（バイト単位）が続く。

@end itemize
たとえば、ポインタのサイズが4の場合、引数を持たずに@code{int}を返すメソッドは、@code{i8@@0:4}のシグネチャを持つ。このシグネチャは、次のように解釈される。@code{i }は戻り値の型（@code{int}）、@code{8}はバイト単位のパラメータの合計サイズ（サイズがそれぞれ2つのポインタ）、@code{@@ 0}は最初のパラメータ （バイトオフセット@code{0}のオブジェクト）、@code{:4}は2番目のパラメータ（バイトオフセット@code{4}の@code{SEL}）である。

GCCでコンパイルされたObjective-Cオブジェクトファイルで"strings"プログラムを実行すると、より多くの例を簡単に見つけることができる。@code{i8@@0:4}と非常によく似た文字列が多数表示される。 それらはObjective-Cメソッドのシグネチャである。


@node Garbage Collection
@section Garbage Collection

This section is specific for the GNU Objective-C runtime.  If you are
using a different runtime, you can skip it.

Support for garbage collection with the GNU runtime has been added by
using a powerful conservative garbage collector, known as the
Boehm-Demers-Weiser conservative garbage collector.

To enable the support for it you have to configure the compiler using
an additional argument, @w{@option{--enable-objc-gc}}.  This will
build the boehm-gc library, and build an additional runtime library
which has several enhancements to support the garbage collector.  The
new library has a new name, @file{libobjc_gc.a} to not conflict with
the non-garbage-collected library.

When the garbage collector is used, the objects are allocated using the
so-called typed memory allocation mechanism available in the
Boehm-Demers-Weiser collector.  This mode requires precise information on
where pointers are located inside objects.  This information is computed
once per class, immediately after the class has been initialized.

There is a new runtime function @code{class_ivar_set_gcinvisible()}
which can be used to declare a so-called @dfn{weak pointer}
reference.  Such a pointer is basically hidden for the garbage collector;
this can be useful in certain situations, especially when you want to
keep track of the allocated objects, yet allow them to be
collected.  This kind of pointers can only be members of objects, you
cannot declare a global pointer as a weak reference.  Every type which is
a pointer type can be declared a weak pointer, including @code{id},
@code{Class} and @code{SEL}.

Here is an example of how to use this feature.  Suppose you want to
implement a class whose instances hold a weak pointer reference; the
following class does this:

@smallexample

@@interface WeakPointer : Object
@{
    const void* weakPointer;
@}

- initWithPointer:(const void*)p;
- (const void*)weakPointer;
@@end


@@implementation WeakPointer

+ (void)initialize
@{
  if (self == objc_lookUpClass ("WeakPointer"))
    class_ivar_set_gcinvisible (self, "weakPointer", YES);
@}

- initWithPointer:(const void*)p
@{
  weakPointer = p;
  return self;
@}

- (const void*)weakPointer
@{
  return weakPointer;
@}

@@end

@end smallexample

Weak pointers are supported through a new type character specifier
represented by the @samp{!} character.  The
@code{class_ivar_set_gcinvisible()} function adds or removes this
specifier to the string type description of the instance variable named
as argument.

@c =========================================================================
@node Constant string objects
@section Constant String Objects

GNU Objective-C provides constant string objects that are generated
directly by the compiler.  You declare a constant string object by
prefixing a C constant string with the character @samp{@@}:

@smallexample
  id myString = @@"this is a constant string object";
@end smallexample

The constant string objects are by default instances of the
@code{NXConstantString} class which is provided by the GNU Objective-C
runtime.  To get the definition of this class you must include the
@file{objc/NXConstStr.h} header file.

User defined libraries may want to implement their own constant string
class.  To be able to support them, the GNU Objective-C compiler provides
a new command line options @option{-fconstant-string-class=@var{class-name}}.
The provided class should adhere to a strict structure, the same
as @code{NXConstantString}'s structure:

@smallexample

@@interface MyConstantStringClass
@{
  Class isa;
  char *c_string;
  unsigned int len;
@}
@@end

@end smallexample

@code{NXConstantString} inherits from @code{Object}; user class
libraries may choose to inherit the customized constant string class
from a different class than @code{Object}.  There is no requirement in
the methods the constant string class has to implement, but the final
ivar layout of the class must be the compatible with the given
structure.

When the compiler creates the statically allocated constant string
object, the @code{c_string} field will be filled by the compiler with
the string; the @code{length} field will be filled by the compiler with
the string length; the @code{isa} pointer will be filled with
@code{NULL} by the compiler, and it will later be fixed up automatically
at runtime by the GNU Objective-C runtime library to point to the class
which was set by the @option{-fconstant-string-class} option when the
object file is loaded (if you wonder how it works behind the scenes, the
name of the class to use, and the list of static objects to fixup, are
stored by the compiler in the object file in a place where the GNU
runtime library will find them at runtime).

As a result, when a file is compiled with the
@option{-fconstant-string-class} option, all the constant string objects
will be instances of the class specified as argument to this option.  It
is possible to have multiple compilation units referring to different
constant string classes, neither the compiler nor the linker impose any
restrictions in doing this.

@c =========================================================================
@node compatibility_alias
@section @code{compatibility_alias}

The keyword @code{@@compatibility_alias} allows you to define a class name
as equivalent to another class name.  For example:

@smallexample
@@compatibility_alias WOApplication GSWApplication;
@end smallexample

tells the compiler that each time it encounters @code{WOApplication} as
a class name, it should replace it with @code{GSWApplication} (that is,
@code{WOApplication} is just an alias for @code{GSWApplication}).

There are some constraints on how this can be used---

@itemize @bullet

@item @code{WOApplication} (the alias) must not be an existing class;

@item @code{GSWApplication} (the real class) must be an existing class.

@end itemize

@c =========================================================================
@node Exceptions
@section Exceptions

GNU Objective-C provides exception support built into the language, as
in the following example:

@smallexample
  @@try @{
    @dots{}
       @@throw expr;
    @dots{}
  @}
  @@catch (AnObjCClass *exc) @{
    @dots{}
      @@throw expr;
    @dots{}
      @@throw;
    @dots{}
  @}
  @@catch (AnotherClass *exc) @{
    @dots{}
  @}
  @@catch (id allOthers) @{
    @dots{}
  @}
  @@finally @{
    @dots{}
      @@throw expr;
    @dots{}
  @}
@end smallexample

The @code{@@throw} statement may appear anywhere in an Objective-C or
Objective-C++ program; when used inside of a @code{@@catch} block, the
@code{@@throw} may appear without an argument (as shown above), in
which case the object caught by the @code{@@catch} will be rethrown.

Note that only (pointers to) Objective-C objects may be thrown and
caught using this scheme.  When an object is thrown, it will be caught
by the nearest @code{@@catch} clause capable of handling objects of
that type, analogously to how @code{catch} blocks work in C++ and
Java.  A @code{@@catch(id @dots{})} clause (as shown above) may also
be provided to catch any and all Objective-C exceptions not caught by
previous @code{@@catch} clauses (if any).

The @code{@@finally} clause, if present, will be executed upon exit
from the immediately preceding @code{@@try @dots{} @@catch} section.
This will happen regardless of whether any exceptions are thrown,
caught or rethrown inside the @code{@@try @dots{} @@catch} section,
analogously to the behavior of the @code{finally} clause in Java.

There are several caveats to using the new exception mechanism:

@itemize @bullet
@item
The @option{-fobjc-exceptions} command line option must be used when
compiling Objective-C files that use exceptions.

@item
With the GNU runtime, exceptions are always implemented as ``native''
exceptions and it is recommended that the @option{-fexceptions} and
@option{-shared-libgcc} options are used when linking.

@item
With the NeXT runtime, although currently designed to be binary
compatible with @code{NS_HANDLER}-style idioms provided by the
@code{NSException} class, the new exceptions can only be used on Mac
OS X 10.3 (Panther) and later systems, due to additional functionality
needed in the NeXT Objective-C runtime.

@item
As mentioned above, the new exceptions do not support handling
types other than Objective-C objects.   Furthermore, when used from
Objective-C++, the Objective-C exception model does not interoperate with C++
exceptions at this time.  This means you cannot @code{@@throw} an exception
from Objective-C and @code{catch} it in C++, or vice versa
(i.e., @code{throw @dots{} @@catch}).
@end itemize

@c =========================================================================
@node Synchronization
@section Synchronization

GNU Objective-C provides support for synchronized blocks:

@smallexample
  @@synchronized (ObjCClass *guard) @{
    @dots{}
  @}
@end smallexample

Upon entering the @code{@@synchronized} block, a thread of execution
shall first check whether a lock has been placed on the corresponding
@code{guard} object by another thread.  If it has, the current thread
shall wait until the other thread relinquishes its lock.  Once
@code{guard} becomes available, the current thread will place its own
lock on it, execute the code contained in the @code{@@synchronized}
block, and finally relinquish the lock (thereby making @code{guard}
available to other threads).

Unlike Java, Objective-C does not allow for entire methods to be
marked @code{@@synchronized}.  Note that throwing exceptions out of
@code{@@synchronized} blocks is allowed, and will cause the guarding
object to be unlocked properly.

Because of the interactions between synchronization and exception
handling, you can only use @code{@@synchronized} when compiling with
exceptions enabled, that is with the command line option
@option{-fobjc-exceptions}.


@c =========================================================================
@node Fast enumeration
@section Fast Enumeration

@menu
* Using fast enumeration::
* c99-like fast enumeration syntax::
* Fast enumeration details::
* Fast enumeration protocol::
@end menu

@c ================================
@node Using fast enumeration
@subsection Using Fast Enumeration

GNU Objective-C provides support for the fast enumeration syntax:

@smallexample
  id array = @dots{};
  id object;

  for (object in array)
  @{
    /* Do something with 'object' */
  @}
@end smallexample

@code{array} needs to be an Objective-C object (usually a collection
object, for example an array, a dictionary or a set) which implements
the ``Fast Enumeration Protocol'' (see below).  If you are using a
Foundation library such as GNUstep Base or Apple Cocoa Foundation, all
collection objects in the library implement this protocol and can be
used in this way.

The code above would iterate over all objects in @code{array}.  For
each of them, it assigns it to @code{object}, then executes the
@code{Do something with 'object'} statements.

Here is a fully worked-out example using a Foundation library (which
provides the implementation of @code{NSArray}, @code{NSString} and
@code{NSLog}):

@smallexample
  NSArray *array = [NSArray arrayWithObjects: @@"1", @@"2", @@"3", nil];
  NSString *object;

  for (object in array)
    NSLog (@@"Iterating over %@@", object);
@end smallexample


@c ================================
@node c99-like fast enumeration syntax
@subsection C99-Like Fast Enumeration Syntax

A c99-like declaration syntax is also allowed:

@smallexample
  id array = @dots{};

  for (id object in array)
  @{
    /* Do something with 'object'  */
  @}
@end smallexample

this is completely equivalent to:

@smallexample
  id array = @dots{};

  @{
    id object;
    for (object in array)
    @{
      /* Do something with 'object'  */
    @}
  @}
@end smallexample

but can save some typing.

Note that the option @option{-std=c99} is not required to allow this
syntax in Objective-C.

@c ================================
@node Fast enumeration details
@subsection Fast Enumeration Details

Here is a more technical description with the gory details.  Consider the code

@smallexample
  for (@var{object expression} in @var{collection expression})
  @{
    @var{statements}
  @}
@end smallexample

here is what happens when you run it:

@itemize @bullet
@item
@code{@var{collection expression}} is evaluated exactly once and the
result is used as the collection object to iterate over.  This means
it is safe to write code such as @code{for (object in [NSDictionary
keyEnumerator]) @dots{}}.

@item
the iteration is implemented by the compiler by repeatedly getting
batches of objects from the collection object using the fast
enumeration protocol (see below), then iterating over all objects in
the batch.  This is faster than a normal enumeration where objects are
retrieved one by one (hence the name ``fast enumeration'').

@item
if there are no objects in the collection, then
@code{@var{object expression}} is set to @code{nil} and the loop
immediately terminates.

@item
if there are objects in the collection, then for each object in the
collection (in the order they are returned) @code{@var{object expression}}
is set to the object, then @code{@var{statements}} are executed.

@item
@code{@var{statements}} can contain @code{break} and @code{continue}
commands, which will abort the iteration or skip to the next loop
iteration as expected.

@item
when the iteration ends because there are no more objects to iterate
over, @code{@var{object expression}} is set to @code{nil}.  This allows
you to determine whether the iteration finished because a @code{break}
command was used (in which case @code{@var{object expression}} will remain
set to the last object that was iterated over) or because it iterated
over all the objects (in which case @code{@var{object expression}} will be
set to @code{nil}).

@item
@code{@var{statements}} must not make any changes to the collection
object; if they do, it is a hard error and the fast enumeration
terminates by invoking @code{objc_enumerationMutation}, a runtime
function that normally aborts the program but which can be customized
by Foundation libraries via @code{objc_set_mutation_handler} to do
something different, such as raising an exception.

@end itemize

@c ================================
@node Fast enumeration protocol
@subsection Fast Enumeration Protocol

If you want your own collection object to be usable with fast
enumeration, you need to have it implement the method

@smallexample
- (unsigned long) countByEnumeratingWithState: (NSFastEnumerationState *)state
                                      objects: (id *)objects
                                        count: (unsigned long)len;
@end smallexample

where @code{NSFastEnumerationState} must be defined in your code as follows:

@smallexample
typedef struct
@{
  unsigned long state;
  id            *itemsPtr;
  unsigned long *mutationsPtr;
  unsigned long extra[5];
@} NSFastEnumerationState;
@end smallexample

If no @code{NSFastEnumerationState} is defined in your code, the
compiler will automatically replace @code{NSFastEnumerationState *}
with @code{struct __objcFastEnumerationState *}, where that type is
silently defined by the compiler in an identical way.  This can be
confusing and we recommend that you define
@code{NSFastEnumerationState} (as shown above) instead.

The method is called repeatedly during a fast enumeration to retrieve
batches of objects.  Each invocation of the method should retrieve the
next batch of objects.

The return value of the method is the number of objects in the current
batch; this should not exceed @code{len}, which is the maximum size of
a batch as requested by the caller.  The batch itself is returned in
the @code{itemsPtr} field of the @code{NSFastEnumerationState} struct.

To help with returning the objects, the @code{objects} array is a C
array preallocated by the caller (on the stack) of size @code{len}.
In many cases you can put the objects you want to return in that
@code{objects} array, then do @code{itemsPtr = objects}.  But you
don't have to; if your collection already has the objects to return in
some form of C array, it could return them from there instead.

The @code{state} and @code{extra} fields of the
@code{NSFastEnumerationState} structure allows your collection object
to keep track of the state of the enumeration.  In a simple array
implementation, @code{state} may keep track of the index of the last
object that was returned, and @code{extra} may be unused.

The @code{mutationsPtr} field of the @code{NSFastEnumerationState} is
used to keep track of mutations.  It should point to a number; before
working on each object, the fast enumeration loop will check that this
number has not changed.  If it has, a mutation has happened and the
fast enumeration will abort.  So, @code{mutationsPtr} could be set to
point to some sort of version number of your collection, which is
increased by one every time there is a change (for example when an
object is added or removed).  Or, if you are content with less strict
mutation checks, it could point to the number of objects in your
collection or some other value that can be checked to perform an
approximate check that the collection has not been mutated.

Finally, note how we declared the @code{len} argument and the return
value to be of type @code{unsigned long}.  They could also be declared
to be of type @code{unsigned int} and everything would still work.

@c =========================================================================
@node Messaging with the GNU Objective-C runtime
@section Messaging with the GNU Objective-C Runtime

This section is specific for the GNU Objective-C runtime.  If you are
using a different runtime, you can skip it.

The implementation of messaging in the GNU Objective-C runtime is
designed to be portable, and so is based on standard C.

Sending a message in the GNU Objective-C runtime is composed of two
separate steps.  First, there is a call to the lookup function,
@code{objc_msg_lookup ()} (or, in the case of messages to super,
@code{objc_msg_lookup_super ()}).  This runtime function takes as
argument the receiver and the selector of the method to be called; it
returns the @code{IMP}, that is a pointer to the function implementing
the method.  The second step of method invocation consists of casting
this pointer function to the appropriate function pointer type, and
calling the function pointed to it with the right arguments.

For example, when the compiler encounters a method invocation such as
@code{[object init]}, it compiles it into a call to
@code{objc_msg_lookup (object, @@selector(init))} followed by a cast
of the returned value to the appropriate function pointer type, and
then it calls it.

@menu
* Dynamically registering methods::
* Forwarding hook::
@end menu

@c =========================================================================
@node Dynamically registering methods
@subsection Dynamically Registering Methods

If @code{objc_msg_lookup()} does not find a suitable method
implementation, because the receiver does not implement the required
method, it tries to see if the class can dynamically register the
method.

To do so, the runtime checks if the class of the receiver implements
the method

@smallexample
+ (BOOL) resolveInstanceMethod: (SEL)selector;
@end smallexample

in the case of an instance method, or

@smallexample
+ (BOOL) resolveClassMethod: (SEL)selector;
@end smallexample

in the case of a class method.  If the class implements it, the
runtime invokes it, passing as argument the selector of the original
method, and if it returns @code{YES}, the runtime tries the lookup
again, which could now succeed if a matching method was added
dynamically by @code{+resolveInstanceMethod:} or
@code{+resolveClassMethod:}.

This allows classes to dynamically register methods (by adding them to
the class using @code{class_addMethod}) when they are first called.
To do so, a class should implement @code{+resolveInstanceMethod:} (or,
depending on the case, @code{+resolveClassMethod:}) and have it
recognize the selectors of methods that can be registered dynamically
at runtime, register them, and return @code{YES}.  It should return
@code{NO} for methods that it does not dynamically registered at
runtime.

If @code{+resolveInstanceMethod:} (or @code{+resolveClassMethod:}) is
not implemented or returns @code{NO}, the runtime then tries the
forwarding hook.

Support for @code{+resolveInstanceMethod:} and
@code{resolveClassMethod:} was added to the GNU Objective-C runtime in
GCC version 4.6.

@c =========================================================================
@node Forwarding hook
@subsection Forwarding Hook

The GNU Objective-C runtime provides a hook, called
@code{__objc_msg_forward2}, which is called by
@code{objc_msg_lookup()} when it cannot find a method implementation in
the runtime tables and after calling @code{+resolveInstanceMethod:}
and @code{+resolveClassMethod:} has been attempted and did not succeed
in dynamically registering the method.

To configure the hook, you set the global variable
@code{__objc_msg_forward2} to a function with the same argument and
return types of @code{objc_msg_lookup()}.  When
@code{objc_msg_lookup()} can not find a method implementation, it
invokes the hook function you provided to get a method implementation
to return.  So, in practice @code{__objc_msg_forward2} allows you to
extend @code{objc_msg_lookup()} by adding some custom code that is
called to do a further lookup when no standard method implementation
can be found using the normal lookup.

This hook is generally reserved for ``Foundation'' libraries such as
GNUstep Base, which use it to implement their high-level method
forwarding API, typically based around the @code{forwardInvocation:}
method.  So, unless you are implementing your own ``Foundation''
library, you should not set this hook.

In a typical forwarding implementation, the @code{__objc_msg_forward2}
hook function determines the argument and return type of the method
that is being looked up, and then creates a function that takes these
arguments and has that return type, and returns it to the caller.
Creating this function is non-trivial and is typically performed using
a dedicated library such as @code{libffi}.

The forwarding method implementation thus created is returned by
@code{objc_msg_lookup()} and is executed as if it was a normal method
implementation.  When the forwarding method implementation is called,
it is usually expected to pack all arguments into some sort of object
(typically, an @code{NSInvocation} in a ``Foundation'' library), and
hand it over to the programmer (@code{forwardInvocation:}) who is then
allowed to manipulate the method invocation using a high-level API
provided by the ``Foundation'' library.  For example, the programmer
may want to examine the method invocation arguments and name and
potentially change them before forwarding the method invocation to one
or more local objects (@code{performInvocation:}) or even to remote
objects (by using Distributed Objects or some other mechanism).  When
all this completes, the return value is passed back and must be
returned correctly to the original caller.

Note that the GNU Objective-C runtime currently provides no support
for method forwarding or method invocations other than the
@code{__objc_msg_forward2} hook.

If the forwarding hook does not exist or returns @code{NULL}, the
runtime currently attempts forwarding using an older, deprecated API,
and if that fails, it aborts the program.  In future versions of the
GNU Objective-C runtime, the runtime will immediately abort.
