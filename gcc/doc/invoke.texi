@c Copyright (C) 1988-2021 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@ignore
@c man begin INCLUDE
@include gcc-vers.texi
@c man end

@c man begin COPYRIGHT
Copyright @copyright{} 1988-2021 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the gfdl(7) man page.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.
@c man end
@c Set file name and title for the man page.
@setfilename gcc
@settitle GNU project C and C++ compiler
@c man begin SYNOPSIS
gcc [@option{-c}|@option{-S}|@option{-E}] [@option{-std=}@var{standard}]
    [@option{-g}] [@option{-pg}] [@option{-O}@var{level}]
    [@option{-W}@var{warn}@dots{}] [@option{-Wpedantic}]
    [@option{-I}@var{dir}@dots{}] [@option{-L}@var{dir}@dots{}]
    [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
    [@option{-f}@var{option}@dots{}] [@option{-m}@var{machine-option}@dots{}]
    [@option{-o} @var{outfile}] [@@@var{file}] @var{infile}@dots{}

Only the most useful options are listed here; see below for the
remainder.  @command{g++} accepts mostly the same options as @command{gcc}.
@c man end
@c man begin SEEALSO
gpl(7), gfdl(7), fsf-funding(7),
cpp(1), gcov(1), as(1), ld(1), gdb(1), dbx(1)
and the Info entries for @file{gcc}, @file{cpp}, @file{as},
@file{ld}, @file{binutils} and @file{gdb}.
@c man end
@c man begin BUGS
For instructions on reporting bugs, see
@w{@value{BUGURL}}.
@c man end
@c man begin AUTHOR
See the Info entry for @command{gcc}, or
@w{@uref{http://gcc.gnu.org/onlinedocs/gcc/Contributors.html}},
for contributors to GCC@.
@c man end
@end ignore

@node Invoking GCC
@chapter GCCコマンドラインオプション
@cindex GCC command options
@cindex command options
@cindex options, GCC command

@c man begin DESCRIPTION
GCCを呼び出すとき、通常は、プリプロセス、コンパイル、アセンブル、リンクを行う。
「全体のオプション」はこの過程を中間で止めることができる。例えば、
@option{-c}オプションはリンカを走らせないようにする。したがって、
出力はアセンブラによるオブジェクトファイルを含む。
@xref{Overall Options,,出力の種類を制御するオプション}

他のオプションは処理の1つ以上の段階に渡される。あるオプションは
プリプロセスを制御し、他のはコンパイラ自身を制御する。更に別のもはアセンブラや
リンカを制御する。それらのほとんどはここでは文書化しない。なぜならはそれらを使う必要は
殆ど無いからである。

@cindex C compilation options
GCCで使うことができるコマンドラインオプションのほとんどはCプログラムで有用である。
他の言語（大抵はC++）でのみ有用なオプションの場合は、明示的に説明する。
もし特定のオプションの描写でソース言語に言及がないならば、すべてのサポートされている言語で
使うことができる。

@cindex cross compiling
@cindex specifying machine version
@cindex specifying compiler version and target machine
@cindex compiler version, specifying
@cindex target machine, specifying
GCCを走らせる通常の方法は@command{gcc}、クロスコンパイルの時は@command{@var{machine}-gcc}、特定のGCCのバージョンの時は
@command{@var{machine}-gcc-@var{version}}と呼ばれる実行ファイルを走らせることである。C++プログラムをコンパイルするときは、
GCCを@command{g++}として起動するべきである。C++プログラムをコンパイルするときの
@command{gcc}と@code{G++}の振る舞いの差につての情報は@xref{Invoking G++,,C++プログラムをコンパイルする}。

@cindex grouping options
@cindex options, grouping
@command{gcc}プログラムはオプションとファイル名をオペランドとして受理する。多くのオプションは複数文字の名前である。したがって複数の単一文字オプションはグループ化@emph{できない}。@option{-dv}は@w{@samp{-d -v}}とは
全く異なる。

@cindex order of options
@cindex options, order
オプションと他の引数は混ぜることができる。多くの場合で、使う順番は問題にならない。同じ種類のオプションを
複数使う場合は順番が問題になる。例えば、@option{-L}を複数回指定すれば、ディレクトリは指定した順番で
検索される。同様に、@option{-l}の位置は意味を持つ。

多くのオプションは@samp{-f}ないし@samp{-W}で始まる長い名前を持つ。例えば@option{-fmove-loop-invariants}, 
@option{-Wformat}など。それらの大抵は肯定形と否定形を持つ。@option{-ffoo}の否定形は@option{-fno-foo}である。
このマニュアルはそれらの形の、デフォルトでない方のみを記述する。

一部のオプションは、オプション名からスペースまたは等号（@samp{=}）で区切られた1つ以上の引数を取ります。
特に記載がない限り、引数は数値または文字列のいずれかです。 数値引数は通常、小さな符号なし10進数または16進数の整数でなければなりません。16進引数は@samp{0x}プレフィックスで始まる必要があります。 ある種のサイズしきい値を指定するオプションの引数は、キロバイトとキビバイトの@code{kB}と@code{KiB}など、複数のバイトを指定するバイトサイズサフィックスが後に続く任意の大きな10進または16進整数です。メガバイトとメビバイトの場合は@code{MB}と@code{MiB}、ギガバイトとギギバイトの場合は@code{GB}と@code{GiB}などです。  このような引数は、次のテキストで@var{byte-size}で指定されます。 2進および10進のバイトサイズプレフィックスの完全なリストと説明については、NIST、IEC、およびその他の関連する国内および国際規格を参照してください。

@c man end

@xref{Option Index}はGCCはオプションの索引である

@menu
* Option Summary::     説明なしの全オプションのリスト
* Overall Options::     出力の種類を制御する。実行ファイル、オブジェクトファイル。
                         アセンブラファイル。プリプロセス済みソース
* Invoking G++::        C++プログラムの実行
* C Dialect Options::    コンパイルされるC言語の変種を制御する.
* C++ Dialect Options::  C++の変種
* bjective-C and Objective-C++ Dialect Options:: Objective-CとObjective-C++の変種
* Diagnostic Message Formatting Options:: 診断がどのように書式化されるかを制御する
* Warning Options::       どのくらいコンパイラがうるさいか
* Static Analyzer Options:: より高価な警告
* Debugging Options::   デバッグ可能なコードを生成する
* Optimize Options::    どのくらい最適化するか
* Instrumentation Options::       プロファイリングと追加の実行時エラーチェック
* Preprocessor Options::     ヘッダファイルとマクロ定義の制御。さらにMake用の依存情報を得る
* Assembler Options:: アセンブラに渡すオプション
* Link Options::     ライブラリの指定など
* Directory Options::   ヘッダファイルとライブラリを見つける場所。コンパイラが実行可能ファイルを見つける場所
* Code Gen Options:: 関数呼び出し、データレイアウト、レジスタ使用の規約の指定
* Developer Options:: GCCは設定情報、統計、デバッグダンプの出力
* Submodel Options:: 特定のプロセッサ変種のコンパイルのような、ターゲット固有のオプション
* Spec Files::         サブプロセスへスイッチを渡す方法
* Environment Variables::             GCCに影響する環境変数
* Precompiled Headers:: 一度コンパイルして、何度も使う
* C++ Modules::		実験的なC++20モジュールシステム。
@end menu

@c man begin OPTIONS

@node Option Summary
@section オプションの要約

これは全オプションの要約を、タイプ別にグループ化したものである。説明は以下の節にある。

@table @emph
@item 全体のオプション
@xref{Overall Options,,出力の種類を制御するオプション}.
@gccoptlist{-c  -S  -E  -o @var{file} 
-dumpbase @var{dumpbase}  -dumpbase-ext @var{auxdropsuf} 
-dumpdir @var{dumppfx}  -x @var{language}  
-v  -###  --help@r{[}=@var{class}@r{[},@dots{}@r{]]}  --target-help  --version 
-pass-exit-codes  -pipe  -specs=@var{file}  -wrapper  
@@@var{file}  -ffile-prefix-map=@var{old}=@var{new}  
-fplugin=@var{file}  -fplugin-arg-@var{name}=@var{arg}  
-fdump-ada-spec@r{[}-slim@r{]}  -fada-spec-parent=@var{unit}  -fdump-go-spec=@var{file}}

@item C言語オプション
@xref{C Dialect Options,,C変種を制御するオプション}.
@gccoptlist{-ansi  -std=@var{standard}  -fgnu89-inline 
-fpermitted-flt-eval-methods=@var{standard} 
-aux-info @var{filename}  -fallow-parameterless-variadic-functions 
-fno-asm  -fno-builtin  -fno-builtin-@var{function}  -fgimple
-fhosted  -ffreestanding 
-fopenacc  -fopenacc-dim=@var{geom}  -fopenacc-kernels=@var{mode} 
-fopenmp  -fopenmp-simd 
-fms-extensions  -fplan9-extensions  -fsso-struct=@var{endianness} 
-fallow-single-precision  -fcond-mismatch  -flax-vector-conversions 
-fsigned-bitfields  -fsigned-char 
-funsigned-bitfields  -funsigned-char}

@item C++言語オプション
@xref{C++ Dialect Options,,C++変種を制御するオプション}.
@gccoptlist{-fabi-version=@var{n}  -fno-access-control 
-faligned-new=@var{n}  -fargs-in-order=@var{n}  -fchar8_t  -fcheck-new 
-fconstexpr-depth=@var{n}  -fconstexpr-cache-depth=@var{n} 
-fconstexpr-loop-limit=@var{n}  -fconstexpr-ops-limit=@var{n} 
-fno-elide-constructors 
-fno-enforce-eh-specs 
-fno-gnu-keywords 
-fno-implicit-templates 
-fno-implicit-inline-templates 
-fno-implement-inlines  
-fmodule-header@r{[}=@var{kind}@r{]} -fmodule-only -fmodules-ts 
-fmodule-implicit-inline 
-fno-module-lazy 
-fmodule-mapper=@var{specification} 
-fmodule-version-ignore 
-fms-extensions 
-fnew-inheriting-ctors 
-fnew-ttp-matching 
-fno-nonansi-builtins  -fnothrow-opt  -fno-operator-names 
-fno-optional-diags  -fpermissive 
-fno-pretty-templates 
-fno-rtti  -fsized-deallocation 
-ftemplate-backtrace-limit=@var{n} 
-ftemplate-depth=@var{n} 
-fno-threadsafe-statics  -fuse-cxa-atexit 
-fno-weak  -nostdinc++ 
-fvisibility-inlines-hidden 
-fvisibility-ms-compat 
-fext-numeric-literals 
-flang-info-include-translate@r{[}=@var{name}@r{]} 
-flang-info-include-translate-not 
-stdlib=@var{libstdc++,libc++} 
-Wabi-tag  -Wcatch-value  -Wcatch-value=@var{n} 
-Wno-class-conversion  -Wclass-memaccess 
-Wcomma-subscript  -Wconditionally-supported 
-Wno-conversion-null  -Wctad-maybe-unsupported 
-Wctor-dtor-privacy  -Wno-delete-incomplete 
-Wdelete-non-virtual-dtor  -Wdeprecated-copy -Wdeprecated-copy-dtor 
-Wno-deprecated-enum-enum-conversion -Wno-deprecated-enum-float-conversion 
-Weffc++  -Wno-exceptions -Wextra-semi  -Wno-inaccessible-base 
-Wno-inherited-variadic-ctor  -Wno-init-list-lifetime 
-Winvalid-imported-macros 
-Wno-invalid-offsetof  -Wno-literal-suffix 
-Wno-mismatched-new-delete -Wmismatched-tags 
-Wmultiple-inheritance  -Wnamespaces  -Wnarrowing 
-Wnoexcept  -Wnoexcept-type  -Wnon-virtual-dtor 
-Wpessimizing-move  -Wno-placement-new  -Wplacement-new=@var{n} 
-Wrange-loop-construct -Wredundant-move -Wredundant-tags 
-Wreorder  -Wregister 
-Wstrict-null-sentinel  -Wno-subobject-linkage  -Wtemplates 
-Wno-non-template-friend  -Wold-style-cast 
-Woverloaded-virtual  -Wno-pmf-conversions -Wsign-promo 
-Wsized-deallocation  -Wsuggest-final-methods 
-Wsuggest-final-types  -Wsuggest-override  
-Wno-terminate  -Wuseless-cast  -Wno-vexing-parse  
-Wvirtual-inheritance  
-Wno-virtual-move-assign  -Wvolatile  -Wzero-as-null-pointer-constant}

@item Objective-CとObjective-C++言語オプション
@xref{Objective-C and Objective-C++ Dialect Options,,Objective-CとObjective-C++変種を制御するオプション}.
@gccoptlist{-fconstant-string-class=@var{class-name} 
-fgnu-runtime  -fnext-runtime 
-fno-nil-receivers 
-fobjc-abi-version=@var{n} 
-fobjc-call-cxx-cdtors 
-fobjc-direct-dispatch 
-fobjc-exceptions 
-fobjc-gc 
-fobjc-nilcheck 
-fobjc-std=objc1 
-fno-local-ivars 
-fivar-visibility=@r{[}public@r{|}protected@r{|}private@r{|}package@r{]} 
-freplace-objc-classes 
-fzero-link 
-gen-decls 
-Wassign-intercept  -Wno-property-assign-default 
-Wno-protocol -Wobjc-root-class -Wselector 
-Wstrict-selector-match 
-Wundeclared-selector}

@item 診断メッセージ書式化オプション
@xref{Diagnostic Message Formatting Options,,診断メッセージの書式を制御するオプション}.
@gccoptlist{-fmessage-length=@var{n}  
-fdiagnostics-plain-output 
-fdiagnostics-show-location=@r{[}once@r{|}every-line@r{]}  
-fdiagnostics-color=@r{[}auto@r{|}never@r{|}always@r{]}  
-fdiagnostics-urls=@r{[}auto@r{|}never@r{|}always@r{]}  
-fdiagnostics-format=@r{[}text@r{|}json@r{]}  
-fno-diagnostics-show-option  -fno-diagnostics-show-caret 
-fno-diagnostics-show-labels  -fno-diagnostics-show-line-numbers 
-fno-diagnostics-show-cwe  
-fdiagnostics-minimum-margin-width=@var{width} 
-fdiagnostics-parseable-fixits  -fdiagnostics-generate-patch 
-fdiagnostics-show-template-tree  -fno-elide-type 
-fdiagnostics-path-format=@r{[}none@r{|}separate-events@r{|}inline-events@r{]} 
-fdiagnostics-show-path-depths 
-fno-show-column 
-fdiagnostics-column-unit=@r{[}display@r{|}byte@r{]} 
-fdiagnostics-column-origin=@var{origin}}

@item 警告オプション
@xref{Warning Options,,警告の要求・抑制をするオプション}.
@gccoptlist{-fsyntax-only  -fmax-errors=@var{n}  -Wpedantic 
-pedantic-errors 
-w  -Wextra  -Wall  -Wabi=@var{n} 
-Waddress  -Wno-address-of-packed-member  -Waggregate-return 
-Walloc-size-larger-than=@var{byte-size}  -Walloc-zero 
-Walloca  -Walloca-larger-than=@var{byte-size} 
-Wno-aggressive-loop-optimizations 
-Warith-conversion 
-Warray-bounds  -Warray-bounds=@var{n} 
-Wno-attributes  -Wattribute-alias=@var{n} -Wno-attribute-alias 
-Wno-attribute-warning  -Wbool-compare  -Wbool-operation 
-Wno-builtin-declaration-mismatch 
-Wno-builtin-macro-redefined  -Wc90-c99-compat  -Wc99-c11-compat 
-Wc11-c2x-compat 
-Wc++-compat  -Wc++11-compat  -Wc++14-compat  -Wc++17-compat  
-Wc++20-compat  
-Wcast-align  -Wcast-align=strict  -Wcast-function-type  -Wcast-qual  
-Wchar-subscripts 
-Wclobbered  -Wcomment 
-Wconversion  -Wno-coverage-mismatch  -Wno-cpp 
-Wdangling-else  -Wdate-time 
-Wno-deprecated  -Wno-deprecated-declarations  -Wno-designated-init 
-Wdisabled-optimization 
-Wno-discarded-array-qualifiers  -Wno-discarded-qualifiers 
-Wno-div-by-zero  -Wdouble-promotion 
-Wduplicated-branches  -Wduplicated-cond 
-Wempty-body  -Wno-endif-labels  -Wenum-compare  -Wenum-conversion 
-Werror  -Werror=*  -Wexpansion-to-defined  -Wfatal-errors 
-Wfloat-conversion  -Wfloat-equal  -Wformat  -Wformat=2 
-Wno-format-contains-nul  -Wno-format-extra-args  
-Wformat-nonliteral  -Wformat-overflow=@var{n} 
-Wformat-security  -Wformat-signedness  -Wformat-truncation=@var{n} 
-Wformat-y2k  -Wframe-address 
-Wframe-larger-than=@var{byte-size}  -Wno-free-nonheap-object 
-Wno-if-not-aligned  -Wno-ignored-attributes 
-Wignored-qualifiers  -Wno-incompatible-pointer-types 
-Wimplicit  -Wimplicit-fallthrough  -Wimplicit-fallthrough=@var{n} 
-Wno-implicit-function-declaration  -Wno-implicit-int 
-Winit-self  -Winline  -Wno-int-conversion  -Wint-in-bool-context 
-Wno-int-to-pointer-cast  -Wno-invalid-memory-model 
-Winvalid-pch  -Wjump-misses-init  -Wlarger-than=@var{byte-size} 
-Wlogical-not-parentheses  -Wlogical-op  -Wlong-long 
-Wno-lto-type-mismatch -Wmain  -Wmaybe-uninitialized 
-Wmemset-elt-size  -Wmemset-transposed-args 
-Wmisleading-indentation  -Wmissing-attributes  -Wmissing-braces 
-Wmissing-field-initializers  -Wmissing-format-attribute 
-Wmissing-include-dirs  -Wmissing-noreturn  -Wno-missing-profile 
-Wno-multichar  -Wmultistatement-macros  -Wnonnull  -Wnonnull-compare 
-Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]} 
-Wnull-dereference  -Wno-odr  -Wopenmp-simd  
-Wno-overflow  -Woverlength-strings  -Wno-override-init-side-effects 
-Wpacked  -Wno-packed-bitfield-compat  -Wpacked-not-aligned  -Wpadded 
-Wparentheses  -Wno-pedantic-ms-format 
-Wpointer-arith  -Wno-pointer-compare  -Wno-pointer-to-int-cast 
-Wno-pragmas  -Wno-prio-ctor-dtor  -Wredundant-decls 
-Wrestrict  -Wno-return-local-addr  -Wreturn-type 
-Wno-scalar-storage-order  -Wsequence-point 
-Wshadow  -Wshadow=global  -Wshadow=local  -Wshadow=compatible-local 
-Wno-shadow-ivar 
-Wno-shift-count-negative  -Wno-shift-count-overflow  -Wshift-negative-value 
-Wno-shift-overflow  -Wshift-overflow=@var{n} 
-Wsign-compare  -Wsign-conversion 
-Wno-sizeof-array-argument 
-Wsizeof-array-div 
-Wsizeof-pointer-div  -Wsizeof-pointer-memaccess 
-Wstack-protector  -Wstack-usage=@var{byte-size}  -Wstrict-aliasing 
-Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} 
-Wstring-compare 
-Wno-stringop-overflow -Wno-stringop-overread 
-Wno-stringop-truncation 
-Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} 
-Wswitch  -Wno-switch-bool  -Wswitch-default  -Wswitch-enum 
-Wno-switch-outside-range  -Wno-switch-unreachable  -Wsync-nand 
-Wsystem-headers  -Wtautological-compare  -Wtrampolines  -Wtrigraphs 
-Wtsan -Wtype-limits  -Wundef 
-Wuninitialized  -Wunknown-pragmas 
-Wunsuffixed-float-constants  -Wunused 
-Wunused-but-set-parameter  -Wunused-but-set-variable 
-Wunused-const-variable  -Wunused-const-variable=@var{n} 
-Wunused-function  -Wunused-label  -Wunused-local-typedefs 
-Wunused-macros 
-Wunused-parameter  -Wno-unused-result 
-Wunused-value  -Wunused-variable 
-Wno-varargs  -Wvariadic-macros 
-Wvector-operation-performance 
-Wvla  -Wvla-larger-than=@var{byte-size}  -Wno-vla-larger-than 
-Wvolatile-register-var  -Wwrite-strings 
-Wzero-length-bounds}

@item 静的解析オプション
@gccoptlist{
-fanalyzer 
-fanalyzer-call-summaries 
-fanalyzer-checker=@var{name} 
-fno-analyzer-feasibility 
-fanalyzer-fine-grained 
-fanalyzer-state-merge 
-fanalyzer-state-purge 
-fanalyzer-transitivity 
-fanalyzer-verbose-edges 
-fanalyzer-verbose-state-changes 
-fanalyzer-verbosity=@var{level} 
-fdump-analyzer 
-fdump-analyzer-stderr 
-fdump-analyzer-callgraph 
-fdump-analyzer-exploded-graph 
-fdump-analyzer-exploded-nodes 
-fdump-analyzer-exploded-nodes-2 
-fdump-analyzer-exploded-nodes-3 
-fdump-analyzer-json 
-fdump-analyzer-state-purge 
-fdump-analyzer-supergraph 
-Wno-analyzer-double-fclose 
-Wno-analyzer-double-free 
-Wno-analyzer-exposure-through-output-file 
-Wno-analyzer-file-leak 
-Wno-analyzer-free-of-non-heap 
-Wno-analyzer-malloc-leak 
-Wno-analyzer-mismatching-deallocation 
-Wno-analyzer-null-argument 
-Wno-analyzer-null-dereference 
-Wno-analyzer-possible-null-argument 
-Wno-analyzer-possible-null-dereference 
-Wno-analyzer-shift-count-negative 
-Wno-analyzer-shift-count-overflow 
-Wno-analyzer-stale-setjmp-buffer 
-Wno-analyzer-tainted-array-index 
-Wanalyzer-too-complex 
-Wno-analyzer-unsafe-call-within-signal-handler 
-Wno-analyzer-use-after-free 
-Wno-analyzer-use-of-pointer-in-stale-stack-frame 
-Wno-analyzer-use-of-uninitialized-value 
-Wno-analyzer-write-to-const 
-Wno-analyzer-write-to-string-literal 
}

@item CとObjective-C専用の警告オプション
@gccoptlist{-Wbad-function-cast  -Wmissing-declarations 
-Wmissing-parameter-type  -Wmissing-prototypes  -Wnested-externs 
-Wold-style-declaration  -Wold-style-definition 
-Wstrict-prototypes  -Wtraditional  -Wtraditional-conversion 
-Wdeclaration-after-statement  -Wpointer-sign}

@item デバッグオプション
@xref{Debugging Options,,あなたのプログラムをデバッグするためのオプション}.
@gccoptlist{-g  -g@var{level}  -gdwarf  -gdwarf-@var{version} 
-ggdb  -grecord-gcc-switches  -gno-record-gcc-switches 
-gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf 
-gas-loc-support  -gno-as-loc-support 
-gas-locview-support  -gno-as-locview-support 
-gcolumn-info  -gno-column-info  -gdwarf32  -gdwarf64 
-gstatement-frontiers  -gno-statement-frontiers 
-gvariable-location-views  -gno-variable-location-views 
-ginternal-reset-location-views  -gno-internal-reset-location-views 
-ginline-points  -gno-inline-points 
-gvms  -gxcoff  -gxcoff+  -gz@r{[}=@var{type}@r{]} 
-gsplit-dwarf  -gdescribe-dies  -gno-describe-dies 
-fdebug-prefix-map=@var{old}=@var{new}  -fdebug-types-section 
-fno-eliminate-unused-debug-types 
-femit-struct-debug-baseonly  -femit-struct-debug-reduced 
-femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]} 
-fno-eliminate-unused-debug-symbols  -femit-class-debug-always 
-fno-merge-debug-strings  -fno-dwarf2-cfi-asm 
-fvar-tracking  -fvar-tracking-assignments}

@item 最適化オプション
@xref{Optimize Options,,最適化を制御するオプション}.
@gccoptlist{-faggressive-loop-optimizations 
-falign-functions[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-falign-jumps[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-falign-labels[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-falign-loops[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-fno-allocation-dce -fallow-store-data-races 
-fassociative-math  -fauto-profile  -fauto-profile[=@var{path}] 
-fauto-inc-dec  -fbranch-probabilities 
-fcaller-saves 
-fcombine-stack-adjustments  -fconserve-stack 
-fcompare-elim  -fcprop-registers  -fcrossjumping 
-fcse-follow-jumps  -fcse-skip-blocks  -fcx-fortran-rules 
-fcx-limited-range 
-fdata-sections  -fdce  -fdelayed-branch 
-fdelete-null-pointer-checks  -fdevirtualize  -fdevirtualize-speculatively 
-fdevirtualize-at-ltrans  -fdse 
-fearly-inlining  -fipa-sra  -fexpensive-optimizations  -ffat-lto-objects 
-ffast-math  -ffinite-math-only  -ffloat-store  -fexcess-precision=@var{style} 
-ffinite-loops 
-fforward-propagate  -ffp-contract=@var{style}  -ffunction-sections 
-fgcse  -fgcse-after-reload  -fgcse-las  -fgcse-lm  -fgraphite-identity 
-fgcse-sm  -fhoist-adjacent-loads  -fif-conversion 
-fif-conversion2  -findirect-inlining 
-finline-functions  -finline-functions-called-once  -finline-limit=@var{n} 
-finline-small-functions -fipa-modref -fipa-cp  -fipa-cp-clone 
-fipa-bit-cp  -fipa-vrp  -fipa-pta  -fipa-profile  -fipa-pure-const 
-fipa-reference  -fipa-reference-addressable 
-fipa-stack-alignment  -fipa-icf  -fira-algorithm=@var{algorithm} 
-flive-patching=@var{level} 
-fira-region=@var{region}  -fira-hoist-pressure 
-fira-loop-pressure  -fno-ira-share-save-slots 
-fno-ira-share-spill-slots 
-fisolate-erroneous-paths-dereference  -fisolate-erroneous-paths-attribute 
-fivopts  -fkeep-inline-functions  -fkeep-static-functions 
-fkeep-static-consts  -flimit-function-alignment  -flive-range-shrinkage 
-floop-block  -floop-interchange  -floop-strip-mine 
-floop-unroll-and-jam  -floop-nest-optimize 
-floop-parallelize-all  -flra-remat  -flto  -flto-compression-level 
-flto-partition=@var{alg}  -fmerge-all-constants 
-fmerge-constants  -fmodulo-sched  -fmodulo-sched-allow-regmoves 
-fmove-loop-invariants  -fno-branch-count-reg 
-fno-defer-pop  -fno-fp-int-builtin-inexact  -fno-function-cse 
-fno-guess-branch-probability  -fno-inline  -fno-math-errno  -fno-peephole 
-fno-peephole2  -fno-printf-return-value  -fno-sched-interblock 
-fno-sched-spec  -fno-signed-zeros 
-fno-toplevel-reorder  -fno-trapping-math  -fno-zero-initialized-in-bss 
-fomit-frame-pointer  -foptimize-sibling-calls 
-fpartial-inlining  -fpeel-loops  -fpredictive-commoning 
-fprefetch-loop-arrays 
-fprofile-correction 
-fprofile-use  -fprofile-use=@var{path} -fprofile-partial-training 
-fprofile-values -fprofile-reorder-functions 
-freciprocal-math  -free  -frename-registers  -freorder-blocks 
-freorder-blocks-algorithm=@var{algorithm} 
-freorder-blocks-and-partition  -freorder-functions 
-frerun-cse-after-loop  -freschedule-modulo-scheduled-loops 
-frounding-math  -fsave-optimization-record 
-fsched2-use-superblocks  -fsched-pressure 
-fsched-spec-load  -fsched-spec-load-dangerous 
-fsched-stalled-insns-dep[=@var{n}]  -fsched-stalled-insns[=@var{n}] 
-fsched-group-heuristic  -fsched-critical-path-heuristic 
-fsched-spec-insn-heuristic  -fsched-rank-heuristic 
-fsched-last-insn-heuristic  -fsched-dep-count-heuristic 
-fschedule-fusion 
-fschedule-insns  -fschedule-insns2  -fsection-anchors 
-fselective-scheduling  -fselective-scheduling2 
-fsel-sched-pipelining  -fsel-sched-pipelining-outer-loops 
-fsemantic-interposition  -fshrink-wrap  -fshrink-wrap-separate 
-fsignaling-nans 
-fsingle-precision-constant  -fsplit-ivs-in-unroller  -fsplit-loops
-fsplit-paths 
-fsplit-wide-types  -fsplit-wide-types-early  -fssa-backprop  -fssa-phiopt 
-fstdarg-opt  -fstore-merging  -fstrict-aliasing 
-fthread-jumps  -ftracer  -ftree-bit-ccp 
-ftree-builtin-call-dce  -ftree-ccp  -ftree-ch 
-ftree-coalesce-vars  -ftree-copy-prop  -ftree-dce  -ftree-dominator-opts 
-ftree-dse  -ftree-forwprop  -ftree-fre  -fcode-hoisting 
-ftree-loop-if-convert  -ftree-loop-im 
-ftree-phiprop  -ftree-loop-distribution  -ftree-loop-distribute-patterns 
-ftree-loop-ivcanon  -ftree-loop-linear  -ftree-loop-optimize 
-ftree-loop-vectorize 
-ftree-parallelize-loops=@var{n}  -ftree-pre  -ftree-partial-pre  -ftree-pta 
-ftree-reassoc  -ftree-scev-cprop  -ftree-sink  -ftree-slsr  -ftree-sra 
-ftree-switch-conversion  -ftree-tail-merge 
-ftree-ter  -ftree-vectorize  -ftree-vrp  -funconstrained-commons 
-funit-at-a-time  -funroll-all-loops  -funroll-loops 
-funsafe-math-optimizations  -funswitch-loops 
-fipa-ra  -fvariable-expansion-in-unroller  -fvect-cost-model  -fvpt 
-fweb  -fwhole-program  -fwpa  -fuse-linker-plugin -fzero-call-used-regs 
--param @var{name}=@var{value}
-O  -O0  -O1  -O2  -O3  -Os  -Ofast  -Og}

@item プログラム計装オプション
@xref{Instrumentation Options,,プログラム計装オプション}.
@gccoptlist{-p  -pg  -fprofile-arcs  --coverage  -ftest-coverage 
-fprofile-abs-path 
-fprofile-dir=@var{path}  -fprofile-generate  -fprofile-generate=@var{path} 
-fprofile-info-section  -fprofile-info-section=@var{name} 
-fprofile-note=@var{path} -fprofile-prefix-path=@var{path} 
-fprofile-update=@var{method} -fprofile-filter-files=@var{regex} 
-fprofile-exclude-files=@var{regex} 
-fprofile-reproducible=@r{[}multithreaded@r{|}parallel-runs@r{|}serial@r{]} 
-fsanitize=@var{style}  -fsanitize-recover  -fsanitize-recover=@var{style} 
-fasan-shadow-offset=@var{number}  -fsanitize-sections=@var{s1},@var{s2},... 
-fsanitize-undefined-trap-on-error  -fbounds-check 
-fcf-protection=@r{[}full@r{|}branch@r{|}return@r{|}none@r{|}check@r{]} 
-fstack-protector  -fstack-protector-all  -fstack-protector-strong 
-fstack-protector-explicit  -fstack-check 
-fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} 
-fno-stack-limit  -fsplit-stack 
-fvtable-verify=@r{[}std@r{|}preinit@r{|}none@r{]} 
-fvtv-counts  -fvtv-debug 
-finstrument-functions 
-finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} 
-finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{}}

@item プリプロセッサオプション
@xref{Preprocessor Options,,プリプロセッサを制御するオプション}.
@gccoptlist{-A@var{question}=@var{answer} 
-A-@var{question}@r{[}=@var{answer}@r{]} 
-C  -CC  -D@var{macro}@r{[}=@var{defn}@r{]} 
-dD  -dI  -dM  -dN  -dU 
-fdebug-cpp  -fdirectives-only  -fdollars-in-identifiers  
-fexec-charset=@var{charset}  -fextended-identifiers  
-finput-charset=@var{charset}  -flarge-source-files  
-fmacro-prefix-map=@var{old}=@var{new} -fmax-include-depth=@var{depth} 
-fno-canonical-system-headers  -fpch-deps  -fpch-preprocess  
-fpreprocessed  -ftabstop=@var{width}  -ftrack-macro-expansion  
-fwide-exec-charset=@var{charset}  -fworking-directory 
-H  -imacros @var{file}  -include @var{file} 
-M  -MD  -MF  -MG  -MM  -MMD  -MP  -MQ  -MT -Mno-modules 
-no-integrated-cpp  -P  -pthread  -remap 
-traditional  -traditional-cpp  -trigraphs 
-U@var{macro}  -undef  
-Wp,@var{option}  -Xpreprocessor @var{option}}

@item アセンブラオプション
@xref{Assembler Options,,アセンブラに渡すオプション}.
@gccoptlist{-Wa,@var{option}  -Xassembler @var{option}}

@item リンカオプション
@xref{Link Options,,リンクのオプション}.
@gccoptlist{@var{object-file-name}  -fuse-ld=@var{linker}  -l@var{library} 
-nostartfiles  -nodefaultlibs  -nolibc  -nostdlib 
-e @var{entry}  --entry=@var{entry} 
-pie  -pthread  -r  -rdynamic 
-s  -static  -static-pie  -static-libgcc  -static-libstdc++ 
-static-libasan  -static-libtsan  -static-liblsan  -static-libubsan 
-shared  -shared-libgcc  -symbolic 
-T @var{script}  -Wl,@var{option}  -Xlinker @var{option} 
-u @var{symbol}  -z @var{keyword}}

@item ディレクトリオプション
@xref{Directory Options,,ディレクトリ検索オプション}.
@gccoptlist{-B@var{prefix}  -I@var{dir}  -I- 
-idirafter @var{dir} 
-imacros @var{file}  -imultilib @var{dir} 
-iplugindir=@var{dir}  -iprefix @var{file} 
-iquote @var{dir}  -isysroot @var{dir}  -isystem @var{dir} 
-iwithprefix @var{dir}  -iwithprefixbefore @var{dir}  
-L@var{dir}  -no-canonical-prefixes  --no-sysroot-suffix 
-nostdinc  -nostdinc++  --sysroot=@var{dir}}

@item コード生成オプション
@xref{Code Gen Options,,コード生成規約オプション}.
@gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} 
-ffixed-@var{reg}  -fexceptions 
-fnon-call-exceptions  -fdelete-dead-exceptions  -funwind-tables 
-fasynchronous-unwind-tables 
-fno-gnu-unique 
-finhibit-size-directive  -fcommon  -fno-ident 
-fpcc-struct-return  -fpic  -fPIC  -fpie  -fPIE  -fno-plt 
-fno-jump-tables -fno-bit-tests 
-frecord-gcc-switches 
-freg-struct-return  -fshort-enums  -fshort-wchar 
-fverbose-asm  -fpack-struct[=@var{n}]  
-fleading-underscore  -ftls-model=@var{model} 
-fstack-reuse=@var{reuse_level} 
-ftrampolines  -ftrapv  -fwrapv 
-fvisibility=@r{[}default@r{|}internal@r{|}hidden@r{|}protected@r{]} 
-fstrict-volatile-bitfields  -fsync-libcalls}

@item デベロッパオプション
@xref{Developer Options,,GCCデベロッパオプション}.
@gccoptlist{-d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion 
-dumpfullversion  -fcallgraph-info@r{[}=su,da@r{]}
-fchecking  -fchecking=@var{n}
-fdbg-cnt-list   -fdbg-cnt=@var{counter-value-list} 
-fdisable-ipa-@var{pass_name} 
-fdisable-rtl-@var{pass_name} 
-fdisable-rtl-@var{pass-name}=@var{range-list} 
-fdisable-tree-@var{pass_name} 
-fdisable-tree-@var{pass-name}=@var{range-list} 
-fdump-debug  -fdump-earlydebug 
-fdump-noaddr  -fdump-unnumbered  -fdump-unnumbered-links 
-fdump-final-insns@r{[}=@var{file}@r{]} 
-fdump-ipa-all  -fdump-ipa-cgraph  -fdump-ipa-inline 
-fdump-lang-all 
-fdump-lang-@var{switch} 
-fdump-lang-@var{switch}-@var{options} 
-fdump-lang-@var{switch}-@var{options}=@var{filename} 
-fdump-passes 
-fdump-rtl-@var{pass}  -fdump-rtl-@var{pass}=@var{filename} 
-fdump-statistics 
-fdump-tree-all 
-fdump-tree-@var{switch} 
-fdump-tree-@var{switch}-@var{options} 
-fdump-tree-@var{switch}-@var{options}=@var{filename} 
-fcompare-debug@r{[}=@var{opts}@r{]}  -fcompare-debug-second 
-fenable-@var{kind}-@var{pass} 
-fenable-@var{kind}-@var{pass}=@var{range-list} 
-fira-verbose=@var{n} 
-flto-report  -flto-report-wpa  -fmem-report-wpa 
-fmem-report  -fpre-ipa-mem-report  -fpost-ipa-mem-report 
-fopt-info  -fopt-info-@var{options}@r{[}=@var{file}@r{]} 
-fprofile-report 
-frandom-seed=@var{string}  -fsched-verbose=@var{n} 
-fsel-sched-verbose  -fsel-sched-dump-cfg  -fsel-sched-pipelining-verbose 
-fstats  -fstack-usage  -ftime-report  -ftime-report-details 
-fvar-tracking-assignments-toggle  -gtoggle 
-print-file-name=@var{library}  -print-libgcc-file-name 
-print-multi-directory  -print-multi-lib  -print-multi-os-directory 
-print-prog-name=@var{program}  -print-search-dirs  -Q 
-print-sysroot  -print-sysroot-headers-suffix 
-save-temps  -save-temps=cwd  -save-temps=obj  -time@r{[}=@var{file}@r{]}}

@item 機種依存オプション
@xref{Submodel Options,,機種依存オプション}.
@c This list is ordered alphanumerically by subsection name.
@c Try and put the significant identifier (CPU or system) first,
@c so users have a clue at guessing where the ones they want will be.

@emph{AArch64 Options}
@gccoptlist{-mabi=@var{name}  -mbig-endian  -mlittle-endian 
-mgeneral-regs-only 
-mcmodel=tiny  -mcmodel=small  -mcmodel=large 
-mstrict-align  -mno-strict-align 
-momit-leaf-frame-pointer 
-mtls-dialect=desc  -mtls-dialect=traditional 
-mtls-size=@var{size} 
-mfix-cortex-a53-835769  -mfix-cortex-a53-843419 
-mlow-precision-recip-sqrt  -mlow-precision-sqrt  -mlow-precision-div 
-mpc-relative-literal-loads 
-msign-return-address=@var{scope} 
-mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}
+@var{b-key}]|@var{bti} 
-mharden-sls=@var{opts} 
-march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}  
-moverride=@var{string}  -mverbose-cost-dump 
-mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{sysreg} 
-mstack-protector-guard-offset=@var{offset} -mtrack-speculation 
-moutline-atomics }

@emph{Adapteva Epiphany Options}
@gccoptlist{-mhalf-reg-file  -mprefer-short-insn-regs 
-mbranch-cost=@var{num}  -mcmove  -mnops=@var{num}  -msoft-cmpsf 
-msplit-lohi  -mpost-inc  -mpost-modify  -mstack-offset=@var{num} 
-mround-nearest  -mlong-calls  -mshort-calls  -msmall16 
-mfp-mode=@var{mode}  -mvect-double  -max-vect-align=@var{num} 
-msplit-vecmove-early  -m1reg-@var{reg}}

@emph{AMD GCN Options}
@gccoptlist{-march=@var{gpu} -mtune=@var{gpu} -mstack-size=@var{bytes}}

@emph{ARC Options}
@gccoptlist{-mbarrel-shifter  -mjli-always 
-mcpu=@var{cpu}  -mA6  -mARC600  -mA7  -mARC700 
-mdpfp  -mdpfp-compact  -mdpfp-fast  -mno-dpfp-lrsr 
-mea  -mno-mpy  -mmul32x16  -mmul64  -matomic 
-mnorm  -mspfp  -mspfp-compact  -mspfp-fast  -msimd  -msoft-float  -mswap 
-mcrc  -mdsp-packa  -mdvbf  -mlock  -mmac-d16  -mmac-24  -mrtsc  -mswape 
-mtelephony  -mxy  -misize  -mannotate-align  -marclinux  -marclinux_prof 
-mlong-calls  -mmedium-calls  -msdata  -mirq-ctrl-saved 
-mrgf-banked-regs  -mlpc-width=@var{width}  -G @var{num} 
-mvolatile-cache  -mtp-regno=@var{regno} 
-malign-call  -mauto-modify-reg  -mbbit-peephole  -mno-brcc 
-mcase-vector-pcrel  -mcompact-casesi  -mno-cond-exec  -mearly-cbranchsi 
-mexpand-adddi  -mindexed-loads  -mlra  -mlra-priority-none 
-mlra-priority-compact mlra-priority-noncompact  -mmillicode 
-mmixed-code  -mq-class  -mRcq  -mRcw  -msize-level=@var{level} 
-mtune=@var{cpu}  -mmultcost=@var{num}  -mcode-density-frame 
-munalign-prob-threshold=@var{probability}  -mmpy-option=@var{multo} 
-mdiv-rem  -mcode-density  -mll64  -mfpu=@var{fpu}  -mrf16  -mbranch-index}

@emph{ARM Options}
@gccoptlist{-mapcs-frame  -mno-apcs-frame 
-mabi=@var{name} 
-mapcs-stack-check  -mno-apcs-stack-check 
-mapcs-reentrant  -mno-apcs-reentrant 
-mgeneral-regs-only 
-msched-prolog  -mno-sched-prolog 
-mlittle-endian  -mbig-endian 
-mbe8  -mbe32 
-mfloat-abi=@var{name} 
-mfp16-format=@var{name}
-mthumb-interwork  -mno-thumb-interwork 
-mcpu=@var{name}  -march=@var{name}  -mfpu=@var{name}  
-mtune=@var{name}  -mprint-tune-info 
-mstructure-size-boundary=@var{n} 
-mabort-on-noreturn 
-mlong-calls  -mno-long-calls 
-msingle-pic-base  -mno-single-pic-base 
-mpic-register=@var{reg} 
-mnop-fun-dllimport 
-mpoke-function-name 
-mthumb  -marm  -mflip-thumb 
-mtpcs-frame  -mtpcs-leaf-frame 
-mcaller-super-interworking  -mcallee-super-interworking 
-mtp=@var{name}  -mtls-dialect=@var{dialect} 
-mword-relocations 
-mfix-cortex-m3-ldrd 
-munaligned-access 
-mneon-for-64bits 
-mslow-flash-data 
-masm-syntax-unified 
-mrestrict-it 
-mverbose-cost-dump 
-mpure-code 
-mcmse 
-mfdpic}

@emph{AVR Options}
@gccoptlist{-mmcu=@var{mcu}  -mabsdata  -maccumulate-args 
-mbranch-cost=@var{cost} 
-mcall-prologues  -mgas-isr-prologues  -mint8 
-mdouble=@var{bits} -mlong-double=@var{bits} 
-mn_flash=@var{size}  -mno-interrupts 
-mmain-is-OS_task  -mrelax  -mrmw  -mstrict-X  -mtiny-stack 
-mfract-convert-truncate 
-mshort-calls  -nodevicelib  -nodevicespecs 
-Waddr-space-convert  -Wmisspelled-isr}

@emph{Blackfin Options}
@gccoptlist{-mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]} 
-msim  -momit-leaf-frame-pointer  -mno-omit-leaf-frame-pointer 
-mspecld-anomaly  -mno-specld-anomaly  -mcsync-anomaly  -mno-csync-anomaly 
-mlow-64k  -mno-low64k  -mstack-check-l1  -mid-shared-library 
-mno-id-shared-library  -mshared-library-id=@var{n} 
-mleaf-id-shared-library  -mno-leaf-id-shared-library 
-msep-data  -mno-sep-data  -mlong-calls  -mno-long-calls 
-mfast-fp  -minline-plt  -mmulticore  -mcorea  -mcoreb  -msdram 
-micplb}

@emph{C6X Options}
@gccoptlist{-mbig-endian  -mlittle-endian  -march=@var{cpu} 
-msim  -msdata=@var{sdata-type}}

@emph{CRIS Options}
@gccoptlist{-mcpu=@var{cpu}  -march=@var{cpu}  -mtune=@var{cpu} 
-mmax-stack-frame=@var{n}  -melinux-stacksize=@var{n} 
-metrax4  -metrax100  -mpdebug  -mcc-init  -mno-side-effects 
-mstack-align  -mdata-align  -mconst-align 
-m32-bit  -m16-bit  -m8-bit  -mno-prologue-epilogue  -mno-gotplt 
-melf  -maout  -melinux  -mlinux  -sim  -sim2 
-mmul-bug-workaround  -mno-mul-bug-workaround}

@emph{CR16 Options}
@gccoptlist{-mmac 
-mcr16cplus  -mcr16c 
-msim  -mint32  -mbit-ops
-mdata-model=@var{model}}

@emph{C-SKY Options}
@gccoptlist{-march=@var{arch}  -mcpu=@var{cpu} 
-mbig-endian  -EB  -mlittle-endian  -EL 
-mhard-float  -msoft-float  -mfpu=@var{fpu}  -mdouble-float  -mfdivdu 
-mfloat-abi=@var{name} 
-melrw  -mistack  -mmp  -mcp  -mcache  -msecurity  -mtrust 
-mdsp  -medsp  -mvdsp 
-mdiv  -msmart  -mhigh-registers  -manchor 
-mpushpop  -mmultiple-stld  -mconstpool  -mstack-size  -mccrt 
-mbranch-cost=@var{n}  -mcse-cc  -msched-prolog -msim}

@emph{Darwin Options}
@gccoptlist{-all_load  -allowable_client  -arch  -arch_errors_fatal 
-arch_only  -bind_at_load  -bundle  -bundle_loader 
-client_name  -compatibility_version  -current_version 
-dead_strip 
-dependency-file  -dylib_file  -dylinker_install_name 
-dynamic  -dynamiclib  -exported_symbols_list 
-filelist  -flat_namespace  -force_cpusubtype_ALL 
-force_flat_namespace  -headerpad_max_install_names 
-iframework 
-image_base  -init  -install_name  -keep_private_externs 
-multi_module  -multiply_defined  -multiply_defined_unused 
-noall_load   -no_dead_strip_inits_and_terms 
-nofixprebinding  -nomultidefs  -noprebind  -noseglinkedit 
-pagezero_size  -prebind  -prebind_all_twolevel_modules 
-private_bundle  -read_only_relocs  -sectalign 
-sectobjectsymbols  -whyload  -seg1addr 
-sectcreate  -sectobjectsymbols  -sectorder 
-segaddr  -segs_read_only_addr  -segs_read_write_addr 
-seg_addr_table  -seg_addr_table_filename  -seglinkedit 
-segprot  -segs_read_only_addr  -segs_read_write_addr 
-single_module  -static  -sub_library  -sub_umbrella 
-twolevel_namespace  -umbrella  -undefined 
-unexported_symbols_list  -weak_reference_mismatches 
-whatsloaded  -F  -gused  -gfull  -mmacosx-version-min=@var{version} 
-mkernel  -mone-byte-bool}

@emph{DEC Alpha Options}
@gccoptlist{-mno-fp-regs  -msoft-float 
-mieee  -mieee-with-inexact  -mieee-conformant 
-mfp-trap-mode=@var{mode}  -mfp-rounding-mode=@var{mode} 
-mtrap-precision=@var{mode}  -mbuild-constants 
-mcpu=@var{cpu-type}  -mtune=@var{cpu-type} 
-mbwx  -mmax  -mfix  -mcix 
-mfloat-vax  -mfloat-ieee 
-mexplicit-relocs  -msmall-data  -mlarge-data 
-msmall-text  -mlarge-text 
-mmemory-latency=@var{time}}

@emph{eBPF Options}
@gccoptlist{-mbig-endian -mlittle-endian -mkernel=@var{version}
-mframe-limit=@var{bytes} -mxbpf}

@emph{FR30 Options}
@gccoptlist{-msmall-model  -mno-lsim}

@emph{FT32 Options}
@gccoptlist{-msim  -mlra  -mnodiv  -mft32b  -mcompress  -mnopm}

@emph{FRV Options}
@gccoptlist{-mgpr-32  -mgpr-64  -mfpr-32  -mfpr-64 
-mhard-float  -msoft-float 
-malloc-cc  -mfixed-cc  -mdword  -mno-dword 
-mdouble  -mno-double 
-mmedia  -mno-media  -mmuladd  -mno-muladd 
-mfdpic  -minline-plt  -mgprel-ro  -multilib-library-pic 
-mlinked-fp  -mlong-calls  -malign-labels 
-mlibrary-pic  -macc-4  -macc-8 
-mpack  -mno-pack  -mno-eflags  -mcond-move  -mno-cond-move 
-moptimize-membar  -mno-optimize-membar 
-mscc  -mno-scc  -mcond-exec  -mno-cond-exec 
-mvliw-branch  -mno-vliw-branch 
-mmulti-cond-exec  -mno-multi-cond-exec  -mnested-cond-exec 
-mno-nested-cond-exec  -mtomcat-stats 
-mTLS  -mtls 
-mcpu=@var{cpu}}

@emph{GNU/Linux Options}
@gccoptlist{-mglibc  -muclibc  -mmusl  -mbionic  -mandroid 
-tno-android-cc  -tno-android-ld}

@emph{H8/300 Options}
@gccoptlist{-mrelax  -mh  -ms  -mn  -mexr  -mno-exr  -mint32  -malign-300}

@emph{HPPA Options}
@gccoptlist{-march=@var{architecture-type} 
-mcaller-copies  -mdisable-fpregs  -mdisable-indexing 
-mfast-indirect-calls  -mgas  -mgnu-ld   -mhp-ld 
-mfixed-range=@var{register-range} 
-mjump-in-delay  -mlinker-opt  -mlong-calls 
-mlong-load-store  -mno-disable-fpregs 
-mno-disable-indexing  -mno-fast-indirect-calls  -mno-gas 
-mno-jump-in-delay  -mno-long-load-store 
-mno-portable-runtime  -mno-soft-float 
-mno-space-regs  -msoft-float  -mpa-risc-1-0 
-mpa-risc-1-1  -mpa-risc-2-0  -mportable-runtime 
-mschedule=@var{cpu-type}  -mspace-regs  -msio  -mwsio 
-munix=@var{unix-std}  -nolibdld  -static  -threads}

@emph{IA-64 Options}
@gccoptlist{-mbig-endian  -mlittle-endian  -mgnu-as  -mgnu-ld  -mno-pic 
-mvolatile-asm-stop  -mregister-names  -msdata  -mno-sdata 
-mconstant-gp  -mauto-pic  -mfused-madd 
-minline-float-divide-min-latency 
-minline-float-divide-max-throughput 
-mno-inline-float-divide 
-minline-int-divide-min-latency 
-minline-int-divide-max-throughput  
-mno-inline-int-divide 
-minline-sqrt-min-latency  -minline-sqrt-max-throughput 
-mno-inline-sqrt 
-mdwarf2-asm  -mearly-stop-bits 
-mfixed-range=@var{register-range}  -mtls-size=@var{tls-size} 
-mtune=@var{cpu-type}  -milp32  -mlp64 
-msched-br-data-spec  -msched-ar-data-spec  -msched-control-spec 
-msched-br-in-data-spec  -msched-ar-in-data-spec  -msched-in-control-spec 
-msched-spec-ldc  -msched-spec-control-ldc 
-msched-prefer-non-data-spec-insns  -msched-prefer-non-control-spec-insns 
-msched-stop-bits-after-every-cycle  -msched-count-spec-in-critical-path 
-msel-sched-dont-check-control-spec  -msched-fp-mem-deps-zero-cost 
-msched-max-memory-insns-hard-limit  -msched-max-memory-insns=@var{max-insns}}

@emph{LM32 Options}
@gccoptlist{-mbarrel-shift-enabled  -mdivide-enabled  -mmultiply-enabled 
-msign-extend-enabled  -muser-enabled}

@emph{M32R/D Options}
@gccoptlist{-m32r2  -m32rx  -m32r 
-mdebug 
-malign-loops  -mno-align-loops 
-missue-rate=@var{number} 
-mbranch-cost=@var{number} 
-mmodel=@var{code-size-model-type} 
-msdata=@var{sdata-type} 
-mno-flush-func  -mflush-func=@var{name} 
-mno-flush-trap  -mflush-trap=@var{number} 
-G @var{num}}

@emph{M32C Options}
@gccoptlist{-mcpu=@var{cpu}  -msim  -memregs=@var{number}}

@emph{M680x0 Options}
@gccoptlist{-march=@var{arch}  -mcpu=@var{cpu}  -mtune=@var{tune} 
-m68000  -m68020  -m68020-40  -m68020-60  -m68030  -m68040 
-m68060  -mcpu32  -m5200  -m5206e  -m528x  -m5307  -m5407 
-mcfv4e  -mbitfield  -mno-bitfield  -mc68000  -mc68020 
-mnobitfield  -mrtd  -mno-rtd  -mdiv  -mno-div  -mshort 
-mno-short  -mhard-float  -m68881  -msoft-float  -mpcrel 
-malign-int  -mstrict-align  -msep-data  -mno-sep-data 
-mshared-library-id=n  -mid-shared-library  -mno-id-shared-library 
-mxgot  -mno-xgot  -mlong-jump-table-offsets}

@emph{MCore Options}
@gccoptlist{-mhardlit  -mno-hardlit  -mdiv  -mno-div  -mrelax-immediates 
-mno-relax-immediates  -mwide-bitfields  -mno-wide-bitfields 
-m4byte-functions  -mno-4byte-functions  -mcallgraph-data 
-mno-callgraph-data  -mslow-bytes  -mno-slow-bytes  -mno-lsim 
-mlittle-endian  -mbig-endian  -m210  -m340  -mstack-increment}

@emph{MeP Options}
@gccoptlist{-mabsdiff  -mall-opts  -maverage  -mbased=@var{n}  -mbitops 
-mc=@var{n}  -mclip  -mconfig=@var{name}  -mcop  -mcop32  -mcop64  -mivc2 
-mdc  -mdiv  -meb  -mel  -mio-volatile  -ml  -mleadz  -mm  -mminmax 
-mmult  -mno-opts  -mrepeat  -ms  -msatur  -msdram  -msim  -msimnovec  -mtf 
-mtiny=@var{n}}

@emph{MicroBlaze Options}
@gccoptlist{-msoft-float  -mhard-float  -msmall-divides  -mcpu=@var{cpu} 
-mmemcpy  -mxl-soft-mul  -mxl-soft-div  -mxl-barrel-shift 
-mxl-pattern-compare  -mxl-stack-check  -mxl-gp-opt  -mno-clearbss 
-mxl-multiply-high  -mxl-float-convert  -mxl-float-sqrt 
-mbig-endian  -mlittle-endian  -mxl-reorder  -mxl-mode-@var{app-model} 
-mpic-data-is-text-relative}

@emph{MIPS Options}
@gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} 
-mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2  -mips32r3  -mips32r5 
-mips32r6  -mips64  -mips64r2  -mips64r3  -mips64r5  -mips64r6 
-mips16  -mno-mips16  -mflip-mips16 
-minterlink-compressed  -mno-interlink-compressed 
-minterlink-mips16  -mno-interlink-mips16 
-mabi=@var{abi}  -mabicalls  -mno-abicalls 
-mshared  -mno-shared  -mplt  -mno-plt  -mxgot  -mno-xgot 
-mgp32  -mgp64  -mfp32  -mfpxx  -mfp64  -mhard-float  -msoft-float 
-mno-float  -msingle-float  -mdouble-float 
-modd-spreg  -mno-odd-spreg 
-mabs=@var{mode}  -mnan=@var{encoding} 
-mdsp  -mno-dsp  -mdspr2  -mno-dspr2 
-mmcu  -mmno-mcu 
-meva  -mno-eva 
-mvirt  -mno-virt 
-mxpa  -mno-xpa 
-mcrc  -mno-crc 
-mginv  -mno-ginv 
-mmicromips  -mno-micromips 
-mmsa  -mno-msa 
-mloongson-mmi  -mno-loongson-mmi 
-mloongson-ext  -mno-loongson-ext 
-mloongson-ext2  -mno-loongson-ext2 
-mfpu=@var{fpu-type} 
-msmartmips  -mno-smartmips 
-mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx 
-mips3d  -mno-mips3d  -mmt  -mno-mt  -mllsc  -mno-llsc 
-mlong64  -mlong32  -msym32  -mno-sym32 
-G@var{num}  -mlocal-sdata  -mno-local-sdata 
-mextern-sdata  -mno-extern-sdata  -mgpopt  -mno-gopt 
-membedded-data  -mno-embedded-data 
-muninit-const-in-rodata  -mno-uninit-const-in-rodata 
-mcode-readable=@var{setting} 
-msplit-addresses  -mno-split-addresses 
-mexplicit-relocs  -mno-explicit-relocs 
-mcheck-zero-division  -mno-check-zero-division 
-mdivide-traps  -mdivide-breaks 
-mload-store-pairs  -mno-load-store-pairs 
-mmemcpy  -mno-memcpy  -mlong-calls  -mno-long-calls 
-mmad  -mno-mad  -mimadd  -mno-imadd  -mfused-madd  -mno-fused-madd  -nocpp 
-mfix-24k  -mno-fix-24k 
-mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 
-mfix-r5900  -mno-fix-r5900 
-mfix-r10000  -mno-fix-r10000  -mfix-rm7000  -mno-fix-rm7000 
-mfix-vr4120  -mno-fix-vr4120 
-mfix-vr4130  -mno-fix-vr4130  -mfix-sb1  -mno-fix-sb1 
-mflush-func=@var{func}  -mno-flush-func 
-mbranch-cost=@var{num}  -mbranch-likely  -mno-branch-likely 
-mcompact-branches=@var{policy} 
-mfp-exceptions  -mno-fp-exceptions 
-mvr4130-align  -mno-vr4130-align  -msynci  -mno-synci 
-mlxc1-sxc1  -mno-lxc1-sxc1  -mmadd4  -mno-madd4 
-mrelax-pic-calls  -mno-relax-pic-calls  -mmcount-ra-address 
-mframe-header-opt  -mno-frame-header-opt}

@emph{MMIX Options}
@gccoptlist{-mlibfuncs  -mno-libfuncs  -mepsilon  -mno-epsilon  -mabi=gnu 
-mabi=mmixware  -mzero-extend  -mknuthdiv  -mtoplevel-symbols 
-melf  -mbranch-predict  -mno-branch-predict  -mbase-addresses 
-mno-base-addresses  -msingle-exit  -mno-single-exit}

@emph{MN10300 Options}
@gccoptlist{-mmult-bug  -mno-mult-bug 
-mno-am33  -mam33  -mam33-2  -mam34 
-mtune=@var{cpu-type} 
-mreturn-pointer-on-d0 
-mno-crt0  -mrelax  -mliw  -msetlb}

@emph{Moxie Options}
@gccoptlist{-meb  -mel  -mmul.x  -mno-crt0}

@emph{MSP430 Options}
@gccoptlist{-msim  -masm-hex  -mmcu=  -mcpu=  -mlarge  -msmall  -mrelax 
-mwarn-mcu 
-mcode-region=  -mdata-region= 
-msilicon-errata=  -msilicon-errata-warn= 
-mhwmult=  -minrt  -mtiny-printf  -mmax-inline-shift=}

@emph{NDS32 Options}
@gccoptlist{-mbig-endian  -mlittle-endian 
-mreduced-regs  -mfull-regs 
-mcmov  -mno-cmov 
-mext-perf  -mno-ext-perf 
-mext-perf2  -mno-ext-perf2 
-mext-string  -mno-ext-string 
-mv3push  -mno-v3push 
-m16bit  -mno-16bit 
-misr-vector-size=@var{num} 
-mcache-block-size=@var{num} 
-march=@var{arch} 
-mcmodel=@var{code-model} 
-mctor-dtor  -mrelax}

@emph{Nios II Options}
@gccoptlist{-G @var{num}  -mgpopt=@var{option}  -mgpopt  -mno-gpopt 
-mgprel-sec=@var{regexp}  -mr0rel-sec=@var{regexp} 
-mel  -meb 
-mno-bypass-cache  -mbypass-cache 
-mno-cache-volatile  -mcache-volatile 
-mno-fast-sw-div  -mfast-sw-div 
-mhw-mul  -mno-hw-mul  -mhw-mulx  -mno-hw-mulx  -mno-hw-div  -mhw-div 
-mcustom-@var{insn}=@var{N}  -mno-custom-@var{insn} 
-mcustom-fpu-cfg=@var{name} 
-mhal  -msmallc  -msys-crt0=@var{name}  -msys-lib=@var{name} 
-march=@var{arch}  -mbmx  -mno-bmx  -mcdx  -mno-cdx}

@emph{Nvidia PTX Options}
@gccoptlist{-m64  -mmainkernel  -moptimize}

@emph{OpenRISC Options}
@gccoptlist{-mboard=@var{name}  -mnewlib  -mhard-mul  -mhard-div 
-msoft-mul  -msoft-div 
-msoft-float  -mhard-float  -mdouble-float -munordered-float 
-mcmov  -mror  -mrori  -msext  -msfimm  -mshftimm}

@emph{PDP-11 Options}
@gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 
-mint32  -mno-int16  -mint16  -mno-int32 
-msplit  -munix-asm  -mdec-asm  -mgnu-asm  -mlra}

@emph{picoChip Options}
@gccoptlist{-mae=@var{ae_type}  -mvliw-lookahead=@var{N} 
-msymbol-as-address  -mno-inefficient-warnings}

@emph{PowerPC Options}
See RS/6000 and PowerPC Options.

@emph{PRU Options}
@gccoptlist{-mmcu=@var{mcu}  -minrt  -mno-relax  -mloop 
-mabi=@var{variant} }

@emph{RISC-V Options}
@gccoptlist{-mbranch-cost=@var{N-instruction} 
-mplt  -mno-plt 
-mabi=@var{ABI-string} 
-mfdiv  -mno-fdiv 
-mdiv  -mno-div 
-march=@var{ISA-string} 
-mtune=@var{processor-string} 
-mpreferred-stack-boundary=@var{num} 
-msmall-data-limit=@var{N-bytes} 
-msave-restore  -mno-save-restore 
-mshorten-memrefs  -mno-shorten-memrefs 
-mstrict-align  -mno-strict-align 
-mcmodel=medlow  -mcmodel=medany 
-mexplicit-relocs  -mno-explicit-relocs 
-mrelax  -mno-relax 
-mriscv-attribute  -mmo-riscv-attribute 
-malign-data=@var{type} 
+-mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{reg} 
+-mstack-protector-guard-offset=@var{offset}}

@emph{RL78 Options}
@gccoptlist{-msim  -mmul=none  -mmul=g13  -mmul=g14  -mallregs 
-mcpu=g10  -mcpu=g13  -mcpu=g14  -mg10  -mg13  -mg14 
-m64bit-doubles  -m32bit-doubles  -msave-mduc-in-interrupts}

@emph{RS/6000 and PowerPC Options}
@gccoptlist{-mcpu=@var{cpu-type} 
-mtune=@var{cpu-type} 
-mcmodel=@var{code-model} 
-mpowerpc64 
-maltivec  -mno-altivec 
-mpowerpc-gpopt  -mno-powerpc-gpopt 
-mpowerpc-gfxopt  -mno-powerpc-gfxopt 
-mmfcrf  -mno-mfcrf  -mpopcntb  -mno-popcntb  -mpopcntd  -mno-popcntd 
-mfprnd  -mno-fprnd 
-mcmpb  -mno-cmpb  -mhard-dfp  -mno-hard-dfp 
-mfull-toc   -mminimal-toc  -mno-fp-in-toc  -mno-sum-in-toc 
-m64  -m32  -mxl-compat  -mno-xl-compat  -mpe 
-malign-power  -malign-natural 
-msoft-float  -mhard-float  -mmultiple  -mno-multiple 
-mupdate  -mno-update 
-mavoid-indexed-addresses  -mno-avoid-indexed-addresses 
-mfused-madd  -mno-fused-madd  -mbit-align  -mno-bit-align 
-mstrict-align  -mno-strict-align  -mrelocatable 
-mno-relocatable  -mrelocatable-lib  -mno-relocatable-lib 
-mtoc  -mno-toc  -mlittle  -mlittle-endian  -mbig  -mbig-endian 
-mdynamic-no-pic  -mswdiv  -msingle-pic-base 
-mprioritize-restricted-insns=@var{priority} 
-msched-costly-dep=@var{dependence_type} 
-minsert-sched-nops=@var{scheme} 
-mcall-aixdesc  -mcall-eabi  -mcall-freebsd  
-mcall-linux  -mcall-netbsd  -mcall-openbsd  
-mcall-sysv  -mcall-sysv-eabi  -mcall-sysv-noeabi 
-mtraceback=@var{traceback_type} 
-maix-struct-return  -msvr4-struct-return 
-mabi=@var{abi-type}  -msecure-plt  -mbss-plt 
-mlongcall  -mno-longcall  -mpltseq  -mno-pltseq  
-mblock-move-inline-limit=@var{num} 
-mblock-compare-inline-limit=@var{num} 
-mblock-compare-inline-loop-limit=@var{num} 
-mno-block-ops-unaligned-vsx 
-mstring-compare-inline-limit=@var{num} 
-misel  -mno-isel 
-mvrsave  -mno-vrsave 
-mmulhw  -mno-mulhw 
-mdlmzb  -mno-dlmzb 
-mprototype  -mno-prototype 
-msim  -mmvme  -mads  -myellowknife  -memb  -msdata 
-msdata=@var{opt}  -mreadonly-in-sdata  -mvxworks  -G @var{num} 
-mrecip  -mrecip=@var{opt}  -mno-recip  -mrecip-precision 
-mno-recip-precision 
-mveclibabi=@var{type}  -mfriz  -mno-friz 
-mpointers-to-nested-functions  -mno-pointers-to-nested-functions 
-msave-toc-indirect  -mno-save-toc-indirect 
-mpower8-fusion  -mno-mpower8-fusion  -mpower8-vector  -mno-power8-vector 
-mcrypto  -mno-crypto  -mhtm  -mno-htm 
-mquad-memory  -mno-quad-memory 
-mquad-memory-atomic  -mno-quad-memory-atomic 
-mcompat-align-parm  -mno-compat-align-parm 
-mfloat128  -mno-float128  -mfloat128-hardware  -mno-float128-hardware 
-mgnu-attribute  -mno-gnu-attribute 
-mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{reg} 
-mstack-protector-guard-offset=@var{offset} -mprefixed -mno-prefixed 
-mpcrel -mno-pcrel -mmma -mno-mmma}

@emph{RX Options}
@gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu
-mcpu=
-mbig-endian-data  -mlittle-endian-data 
-msmall-data 
-msim  -mno-sim
-mas100-syntax  -mno-as100-syntax
-mrelax
-mmax-constant-size=
-mint-register=
-mpid
-mallow-string-insns  -mno-allow-string-insns
-mjsr
-mno-warn-multiple-fast-interrupts
-msave-acc-in-interrupts}

@emph{S/390 and zSeries Options}
@gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} 
-mhard-float  -msoft-float  -mhard-dfp  -mno-hard-dfp 
-mlong-double-64  -mlong-double-128 
-mbackchain  -mno-backchain  -mpacked-stack  -mno-packed-stack 
-msmall-exec  -mno-small-exec  -mmvcle  -mno-mvcle 
-m64  -m31  -mdebug  -mno-debug  -mesa  -mzarch 
-mhtm  -mvx  -mzvector 
-mtpf-trace  -mno-tpf-trace  -mtpf-trace-skip  -mno-tpf-trace-skip 
-mfused-madd  -mno-fused-madd 
-mwarn-framesize  -mwarn-dynamicstack  -mstack-size  -mstack-guard 
-mhotpatch=@var{halfwords},@var{halfwords}}

@emph{Score Options}
@gccoptlist{-meb  -mel 
-mnhwloop 
-muls 
-mmac 
-mscore5  -mscore5u  -mscore7  -mscore7d}

@emph{SH Options}
@gccoptlist{-m1  -m2  -m2e 
-m2a-nofpu  -m2a-single-only  -m2a-single  -m2a 
-m3  -m3e 
-m4-nofpu  -m4-single-only  -m4-single  -m4 
-m4a-nofpu  -m4a-single-only  -m4a-single  -m4a  -m4al 
-mb  -ml  -mdalign  -mrelax 
-mbigtable  -mfmovd  -mrenesas  -mno-renesas  -mnomacsave 
-mieee  -mno-ieee  -mbitops  -misize  -minline-ic_invalidate  -mpadstruct 
-mprefergot  -musermode  -multcost=@var{number}  -mdiv=@var{strategy} 
-mdivsi3_libfunc=@var{name}  -mfixed-range=@var{register-range} 
-maccumulate-outgoing-args 
-matomic-model=@var{atomic-model} 
-mbranch-cost=@var{num}  -mzdcbranch  -mno-zdcbranch 
-mcbranch-force-delay-slot 
-mfused-madd  -mno-fused-madd  -mfsca  -mno-fsca  -mfsrra  -mno-fsrra 
-mpretend-cmove  -mtas}

@emph{Solaris 2 Options}
@gccoptlist{-mclear-hwcap  -mno-clear-hwcap  -mimpure-text  -mno-impure-text 
-pthreads}

@emph{SPARC Options}
@gccoptlist{-mcpu=@var{cpu-type} 
-mtune=@var{cpu-type} 
-mcmodel=@var{code-model} 
-mmemory-model=@var{mem-model} 
-m32  -m64  -mapp-regs  -mno-app-regs 
-mfaster-structs  -mno-faster-structs  -mflat  -mno-flat 
-mfpu  -mno-fpu  -mhard-float  -msoft-float 
-mhard-quad-float  -msoft-quad-float 
-mstack-bias  -mno-stack-bias 
-mstd-struct-return  -mno-std-struct-return 
-munaligned-doubles  -mno-unaligned-doubles 
-muser-mode  -mno-user-mode 
-mv8plus  -mno-v8plus  -mvis  -mno-vis 
-mvis2  -mno-vis2  -mvis3  -mno-vis3 
-mvis4  -mno-vis4  -mvis4b  -mno-vis4b 
-mcbcond  -mno-cbcond  -mfmaf  -mno-fmaf  -mfsmuld  -mno-fsmuld  
-mpopc  -mno-popc  -msubxc  -mno-subxc 
-mfix-at697f  -mfix-ut699  -mfix-ut700  -mfix-gr712rc 
-mlra  -mno-lra}

@emph{System V Options}
@gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}

@emph{TILE-Gx Options}
@gccoptlist{-mcpu=CPU  -m32  -m64  -mbig-endian  -mlittle-endian 
-mcmodel=@var{code-model}}

@emph{TILEPro Options}
@gccoptlist{-mcpu=@var{cpu}  -m32}

@emph{V850 Options}
@gccoptlist{-mlong-calls  -mno-long-calls  -mep  -mno-ep 
-mprolog-function  -mno-prolog-function  -mspace 
-mtda=@var{n}  -msda=@var{n}  -mzda=@var{n} 
-mapp-regs  -mno-app-regs 
-mdisable-callt  -mno-disable-callt 
-mv850e2v3  -mv850e2  -mv850e1  -mv850es 
-mv850e  -mv850  -mv850e3v5 
-mloop 
-mrelax 
-mlong-jumps 
-msoft-float 
-mhard-float 
-mgcc-abi 
-mrh850-abi 
-mbig-switch}

@emph{VAX Options}
@gccoptlist{-mg  -mgnu  -munix}

@emph{Visium Options}
@gccoptlist{-mdebug  -msim  -mfpu  -mno-fpu  -mhard-float  -msoft-float 
-mcpu=@var{cpu-type}  -mtune=@var{cpu-type}  -msv-mode  -muser-mode}

@emph{VMS Options}
@gccoptlist{-mvms-return-codes  -mdebug-main=@var{prefix}  -mmalloc64 
-mpointer-size=@var{size}}

@emph{VxWorks Options}
@gccoptlist{-mrtp  -non-static  -Bstatic  -Bdynamic 
-Xbind-lazy  -Xbind-now}

@emph{x86 Options}
@gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} 
-mtune-ctrl=@var{feature-list}  -mdump-tune-features  -mno-default 
-mfpmath=@var{unit} 
-masm=@var{dialect}  -mno-fancy-math-387 
-mno-fp-ret-in-387  -m80387  -mhard-float  -msoft-float 
-mno-wide-multiply  -mrtd  -malign-double 
-mpreferred-stack-boundary=@var{num} 
-mincoming-stack-boundary=@var{num} 
-mcld  -mcx16  -msahf  -mmovbe  -mcrc32 
-mrecip  -mrecip=@var{opt} 
-mvzeroupper  -mprefer-avx128  -mprefer-vector-width=@var{opt} 
-mmmx  -msse  -msse2  -msse3  -mssse3  -msse4.1  -msse4.2  -msse4  -mavx 
-mavx2  -mavx512f  -mavx512pf  -mavx512er  -mavx512cd  -mavx512vl 
-mavx512bw  -mavx512dq  -mavx512ifma  -mavx512vbmi  -msha  -maes 
-mpclmul  -mfsgsbase  -mrdrnd  -mf16c  -mfma  -mpconfig  -mwbnoinvd  
-mptwrite  -mprefetchwt1  -mclflushopt  -mclwb  -mxsavec  -mxsaves 
-msse4a  -m3dnow  -m3dnowa  -mpopcnt  -mabm  -mbmi  -mtbm  -mfma4  -mxop 
-madx  -mlzcnt  -mbmi2  -mfxsr  -mxsave  -mxsaveopt  -mrtm  -mhle  -mlwp 
-mmwaitx  -mclzero  -mpku  -mthreads  -mgfni  -mvaes  -mwaitpkg 
-mshstk -mmanual-endbr -mforce-indirect-call  -mavx512vbmi2 -mavx512bf16 -menqcmd 
-mvpclmulqdq  -mavx512bitalg  -mmovdiri  -mmovdir64b  -mavx512vpopcntdq 
-mavx5124fmaps  -mavx512vnni  -mavx5124vnniw  -mprfchw  -mrdpid 
-mrdseed  -msgx -mavx512vp2intersect -mserialize -mtsxldtrk
-mamx-tile  -mamx-int8  -mamx-bf16 -muintr -mhreset -mavxvnni
-mcldemote  -mms-bitfields  -mno-align-stringops  -minline-all-stringops 
-minline-stringops-dynamically  -mstringop-strategy=@var{alg} 
-mkl -mwidekl 
-mmemcpy-strategy=@var{strategy}  -mmemset-strategy=@var{strategy} 
-mpush-args  -maccumulate-outgoing-args  -m128bit-long-double 
-m96bit-long-double  -mlong-double-64  -mlong-double-80  -mlong-double-128 
-mregparm=@var{num}  -msseregparm 
-mveclibabi=@var{type}  -mvect8-ret-in-mem 
-mpc32  -mpc64  -mpc80  -mstackrealign 
-momit-leaf-frame-pointer  -mno-red-zone  -mno-tls-direct-seg-refs 
-mcmodel=@var{code-model}  -mabi=@var{name}  -maddress-mode=@var{mode} 
-m32  -m64  -mx32  -m16  -miamcu  -mlarge-data-threshold=@var{num} 
-msse2avx  -mfentry  -mrecord-mcount  -mnop-mcount  -m8bit-idiv 
-minstrument-return=@var{type} -mfentry-name=@var{name} -mfentry-section=@var{name} 
-mavx256-split-unaligned-load  -mavx256-split-unaligned-store 
-malign-data=@var{type}  -mstack-protector-guard=@var{guard} 
-mstack-protector-guard-reg=@var{reg} 
-mstack-protector-guard-offset=@var{offset} 
-mstack-protector-guard-symbol=@var{symbol} 
-mgeneral-regs-only  -mcall-ms2sysv-xlogues 
-mindirect-branch=@var{choice}  -mfunction-return=@var{choice} 
-mindirect-branch-register -mneeded}

@emph{x86 Windows Options}
@gccoptlist{-mconsole  -mcygwin  -mno-cygwin  -mdll 
-mnop-fun-dllimport  -mthread 
-municode  -mwin32  -mwindows  -fno-set-stack-executable}

@emph{Xstormy16 Options}
@gccoptlist{-msim}

@emph{Xtensa Options}
@gccoptlist{-mconst16  -mno-const16 
-mfused-madd  -mno-fused-madd 
-mforce-no-pic 
-mserialize-volatile  -mno-serialize-volatile 
-mtext-section-literals  -mno-text-section-literals 
-mauto-litpools  -mno-auto-litpools 
-mtarget-align  -mno-target-align 
-mlongcalls  -mno-longcalls 
-mabi=@var{abi-type}}

@emph{zSeries Options}
See S/390 and zSeries Options.
@end table


@node Overall Options
@section 出力の種類を制御するオプション

コンパイルは、最高4つの段階を含み得る。プリプロセス、本来のコンパイル、アセンブル、リンクを常にこの順番で。
GCCは複数のファイルをプリプロセス・コンパイルして複数のアセンブラ入力ファイルにすることも、一つのアセンブラ入力ファイル
にすることもできる。それからそれぞれのアセンブラ入力ファイルはオブジェクトファイルを生成し、リンクですべてのオブジェクト
ファイル（新しくコンパイルされ、入力として指定されて）実行可能ファイルへと組み合わせられる。

@cindex file name suffix
入力ファイルに対して、ファイル名の拡張子によってどの種類のコンパイルを行うかを決定する。

@table @gcctabopt
@item @var{file}.c
プリプロセスをするべきのCソースコード

@item @var{file}.i
プリプロセスをするべきでないCソースコード

@item @var{file}.ii
プリプロセスをするべきでないC++ソースコード

@item @var{file}.m
Object-Cソースコード。Object-Cプログラムを動作させるためには、@file{libobjc}とリンクしなければならない
ことに注意する。

@item @var{file}.mi
プリプロセスをするべきでないObjective-Cソースコード

@item @var{file}.mm
@itemx @var{file}.M
Object-C++ソースコード。Object-C++プログラムを動作させるためには、@file{libobjc}とリンクしなければならない
ことに注意する。@samp{.M}は文字通り大文字のMを参照する。

@item @var{file}.mii
プリプロセスをするべきでないObjective-C++ソースコード

@item @var{file}.h
プリプロセス済みヘッダへと変換すべきC, C++, Objective-C, Objective-C++ヘッダファイル（デフォルト）および、
Ada specへと(@option{-fdump-ada-spec}スイッチ経由で)変換すべきC, C++ヘッダファイル

@item @var{file}.cc
@itemx @var{file}.cp
@itemx @var{file}.cxx
@itemx @var{file}.cpp
@itemx @var{file}.CPP
@itemx @var{file}.c++
@itemx @var{file}.C
プリプロセスをしなけれあばならないC++のソースコード。@samp{.cxx}の最後の2文字は文字通りの@samp{x}であることに注意する。
同様に、@samp{.C}は文字通りの大文字Cである。

@item @var{file}.mm
@itemx @var{file}.M
プリプロセスをしなければならないObject-C++ソースコード。

@item @var{file}.mii
プリプロセスをするべきではないObject-C++ソースコード。

@item @var{file}.hh
@itemx @var{file}.H
@itemx @var{file}.hp
@itemx @var{file}.hxx
@itemx @var{file}.hpp
@itemx @var{file}.HPP
@itemx @var{file}.h++
@itemx @var{file}.tcc
プリプロセス済みヘッダおよびAda specに変換されるC++ヘッダ

@item @var{file}.f
@itemx @var{file}.for
@itemx @var{file}.ftn
プリプロセスをすべきではないFortran固定形式のソースコード

@item @var{file}.F
@itemx @var{file}.FOR
@itemx @var{file}.fpp
@itemx @var{file}.FPP
@itemx @var{file}.FTN
（伝統的なプリプリプロセッサで）プリプロセスをしなければならないFortranソースコード

@item @var{file}.f90
@itemx @var{file}.f95
@itemx @var{file}.f03
@itemx @var{file}.f08
プリプロセスをすべきではない自由形式Fortranソースコード

@item @var{file}.F90
@itemx @var{file}.F95
@itemx @var{file}.F03
@itemx @var{file}.F08
（伝統的なプリプリプロセッサで）プリプロセスをしなければならない自由形式Fortranソースコード

@item @var{file}.go
Goソースコード

@item @var{file}.brig
BRIGファイル(HSAILのバイナリ表現)

@item @var{file}.d
Dのソースコード。

@item @var{file}.di
Dのインターフェースファイル。

@item @var{file}.dd
Dのドキュメントコード（Ddoc）。

@item @var{file}.ads
ライブラリユニット宣言（パッケージ宣言、サブプログラム、汎用、汎用特定化）を含むAdaソースコード、
ライブラリ単位リネーム宣言（パッケージ、汎用、サブプログラムリネーム宣言）。そのようなファイルは
@dfn{specs}と呼ばれる。

@item @var{file}.adb
ライブラリユニット本体（サブプログラムおよびパッケージ本体）を含むAdaソースコードファイル、そのようなファイルは
@dfn{ボディ}と呼ばれる。

@c GCCはまだ含まれていない言語の拡張子を知っている。
@c Ratfor:
@c @var{file}.r

@item @var{file}.s
アセンブラコード

@item @var{file}.S
@itemx @var{file}.sx
プリプロセスをしなければならないアセンブラコード

@item @var{other}
リンクへと直接食わせるオブジェクトファイル。認識しない拡張子を持つファイルは
この方法で扱われる。
@end table

@opindex x
入力言語を@option{-x}オプションで明示的に指定することができる。

@table @gcctabopt
@item -x @var{language}
入力ファイルが従う@var{language}(言語)を（コンパイラに拡張子に基づいて選択させるのではなく）
明示的に指定する。このオプションは次の@option{-x}オプションまでのすべてのファイルに適用される。可能な@var{language}の値は
@smallexample
c  c-header  cpp-output
c++  c++-header  c++-cpp-output
objective-c  objective-c-header  objective-c-cpp-output
objective-c++ objective-c++-header objective-c++-cpp-output
assembler  assembler-with-cpp
ada
d
f77  f77-cpp-input f95  f95-cpp-input
go
brig
@end smallexample

@item -x none
言語の指定を切って、残りのファイルが拡張子に基づいて（@option{-x}が全く使われていないように）
扱うようにする。
@end table

もしコンパイルのある段階のみを望むなら、@option{-x}を@command{gcc}がどこから始めるかを教え、
@option{-c}, @option{-S}, @option{-E}を@command{gcc}がどこで終わるかを教えるために使うことができる。
ある組み合わせ（例えば、@samp{-x cpp-output -E}は@command{gcc}に何もしないように指示することに注意。

@table @gcctabopt
@item -c
@opindex c
ソースのコンパイル・アセンブルはするがリンクしない。リンクの段階は単に行われない。
最終的な出力はそれぞれのファイルのオブジェクトファイルの形式である。

デフォルトでは、ソースファイルのオブジェクトファイル名は拡張子@samp{.c}, @samp{.i}, @samp{.s}などを
@samp{.o}で置換したものである。

認識できないファイル、コンパイル・アセンブルが不要なファイルは無視される。

@item -S
@opindex S
コンパイル自身の段階で止める。アセンブルしない。出力は指定した非アセンブラ入力ファイルのアセンブラコード
形式である。

デフォルトでは、ソースファイルのオブジェクトファイル名は拡張子@samp{.c}, @samp{.i}などを@samp{.s}で置換したものである。

コンパイルが必要ないファイルは無視される。

@item -E
@opindex E
プリプロセスの段階の後で停止する。コンパイラ自身は動かない。出力はプリプロセスされたソースコードの形式で、標準出力へ送られる。

プリプロセスを必要としないファイルは無視される。

@cindex output file option
@item -o @var{file}
@opindex o
ファイル@var{file}に出力させる。これは実行ファイル、オブジェクトファイル、アセンブラファイル、プリプロセス済みのCのコード
であるかにかかわらず、すべての種類の出力で適用される。

もし@option{-o}が指定されていないならば、デフォルトは実行ファイルが@file{a.out}であり、@file{@var{source}.@var{suffix}}の
オブジェクトファイルが@file{@var{source}.o}であり、そのアセンブラが@file{@var{source}.s}であり、プリプロセスされた
ヘッダファイルが@file{@var{source}.@var{suffix}.gch}であり、すべてのプリプロセスされたCソースが標準出力である。

@option{-o}はプライマリ出力のみに名前を付けますが、補助出力とダンプ出力の名前にも影響します。 以下の例を参照してください。 オーバーライドされない限り、補助出力とダンプ出力の両方がプライマリ出力と同じディレクトリに配置されます。 補助出力では、入力ファイルの接尾辞が補助出力ファイルタイプの接尾辞に置き換えられます。 ダンプ出力では、ダンプファイルのサフィックスが入力ファイルのサフィックスに追加されます。 コンパイルコマンドでは、補助出力とダンプ出力の両方のベース名はプライマリ出力のベース名です。 コンパイルおよびリンクコマンドでは、実行可能サフィックスを除いたプライマリ出力名が入力ファイル名と結合されます。 両方が同じベース名を共有している場合、接尾辞を無視して、組み合わせの結果はそのベース名になります。そうでない場合、それらはダッシュで区切られて連結されます。

@smallexample
gcc -c foo.c ...
@end smallexample

は@file{foo.o}をプライマリ出力として使用し、その隣に補助出力とダンプを配置します。たとえば、@option{-gsplit-dwarf}の場合は補助ファイル@file{foo.dwo}、@option{-fdump-rtl-final}ではダンプファイル@file{foo.c.???r.final}になります。

リンカ以外の出力ファイルが明示的に指定されている場合、auxファイルとdumpファイルはデフォルトで同じベース名を取ります。

@smallexample
gcc -c foo.c -o dir/foobar.o ...
@end smallexample

この場合、aux出力には@file{dir/foobar.*}という名前が付けられ、ダンプ出力には@file{dir/foobar.c.*}という名前が付けられます。

代わりに、リンカー出力はauxおよびdump出力のプレフィックスを付けます。

@smallexample
gcc foo.c bar.c -o dir/foobar ...
@end smallexample

は通常、aux出力に@file{dir/foobar-foo.*}および@file{dir/foobar-bar.*}という名前を付け、ダンプは出力@file{dir/foobar-foo.c.*}および@file{dir/foobar-bar.c.*}になります。

上記の1つの例外は、実行可能ファイルが単一の入力とベース名を共有する場合です。

@smallexample
gcc foo.c -o dir/foo ...
@end smallexample

この場合、aux出力には@file{dir/foo.*}という名前が付けられ、ダンプ出力には@file{dir/foo.c.*}という名前が付けられます。

補助出力とダンプ出力の場所と名前は、オプション@option{-dumpbase}、@option{-dumpbase-ext}、@option{-dumpdir}、@option{-save-temps=cwd}、 および@option{-save-temps=obj}で調整されます。

@item -dumpbase @var{dumpbase}
@opindex dumpbase
このオプションは、補助およびダンプ出力ファイルのベース名を設定します。 プライマリ出力ファイルの名前には影響しません。 中間出力は、保存されると、プライマリ出力とは見なされませんが、補助出力と見なされます。

@smallexample
gcc -save-temps -S foo.c
@end smallexample

は（もはや）一時的な前処理されたファイルを@file{foo.i}に保存し、
次に、（暗黙の）出力ファイル@file{foo.s}にコンパイルされますが、一方、

@smallexample
gcc -save-temps -dumpbase save-foo -c foo.c
@end smallexample

は@file{save-foo.i}で前処理し、@file{save-foo.s}（現在は中間出力、つまり補助出力）にコンパイルしてから、（暗黙の）出力ファイル@file{foo.o}にアセンブルします。

このオプションがない場合、dumpファイルとauxファイルは、入力ファイル、または明示的に指定されている場合は（非リンカー）出力ファイルから名前を取得します。入力名サフィックス付きダンプ出力ファイル（例：@option{-fdump-*}オプションで要求されたもの ）、およびそれなしのAux出力ファイル（他の非ダンプオプションによって要求されたもの、たとえば@code{-save-temps}、@code{-gsplit-dwarf}、@code{-fcallgraph-info} 。

明示的に指定された@option{-dumpbase basename.suf}についても、@option{-dumpbase-ext .suf}を指定することで、ダンプ出力とaux出力の同様の接尾辞の区別を実現できます。

@var{dumpbase}がディレクトリコンポーネントで明示的に指定されている場合、@var{dumppfx}の指定（@option{-dumpdir}や@option{-save-temp=*}など）は無視され、追加されません。 @var{dumpbase}はそれを完全にオーバーライドします。

@smallexample
gcc foo.c -c -o dir/foo.o -dumpbase alt/foo \
  -dumpdir pfx- -save-temps=cwd ...
@end smallexample

は@option{-o}の@file{dir/}、@option{-save-temps=cwd}によって暗黙的に含まれる@file{./}プレフィックス、および@option{-dumpdir}の@file{pfx-}を無視して、@file{alt/foo.*}という名前の補助出力とダンプ出力を作成します。

@option{-dumpbase}が、複数の入力をコンパイルするコマンド、またはコンパイルしてからリンクするコマンドで指定されている場合、@option{-dumpdir}で指定されているように、@var{dumppfx}と組み合わせることができます。 次に、結合された@var{dumppfx}を使用して各入力ファイルがコンパイルされ、@var{dumpbase}と@var{auxdropsuf}のデフォルト値が各入力ファイルに対して計算されます。

@smallexample
gcc foo.c bar.c -c -dumpbase main ...
@end smallexample

は@file{foo.o}と@file{bar.o}をプライマリ出力として作成し、@var{dumpbase}をプレフィックスとして使用して、@file{main-foo.*}および@file{main-bar.*}という名前の補助出力とダンプ出力を作成することにより、補助出力とダンプ出力の上書きを回避します。

@var{dumpbase}として指定された空の文字列は、コンパイル中の補助出力とダンプ出力の命名における出力ベース名の影響を回避し、デフォルト値を計算します。

@smallexample
gcc -c foo.c -o dir/foobar.o -dumpbase '' ...
@end smallexample

はaux出力に@file{dir/foo.*}という名前を付け、出力@file{dir/foo.c.*}をダンプします。 それらのベース名が入力名からどのように取得されるかに注意してください。ただし、ディレクトリはデフォルトで出力のディレクトリになります。

空の文字列のdumpbaseは、リンク中の出力に出力basenameを使用することを妨げません。

@smallexample
gcc foo.c bar.c -o dir/foobar -dumpbase '' -flto ...
@end smallexample

ソースファイルのコンパイルでは、補助出力に@file{dir/foo.*}と@file{dir/bar.*}という名前が付けられ、ダンプは@file{dir/foo.c.*}と@file{dir/bar.c.*}に出力されます。 リンク中のLTO再コンパイルでは、ダンプおよび補助ファイルのプレフィックスとして@file{dir/foobar.}が使用されます。

@item -dumpbase-ext @var{auxdropsuf}
@opindex dumpbase-ext
補助（ダンプではない）出力ファイルの名前を作成するときは、サフィックスを追加する前に、末尾の@var{auxdropsuf}を@var{dumpbase}から削除する。 指定しない場合、このオプションはデフォルトでデフォルトの@var{dumpbase}のサフィックスになります。つまり、コマンドラインに@option{-dumpbase}が存在しない場合の入力ファイルのサフィックスです。または、@var{dumpbase}が@var{dumppfx}と組み合わされています。

@smallexample
gcc foo.c -c -o dir/foo.o -dumpbase x-foo.c -dumpbase-ext .c ...
@end smallexample

は@file{dir/foo.o}をメイン出力として作成し、@file{dir/x-foo.*}に補助出力を生成し、プライマリ出力の場所を取得して、@var{dumpbase}から@file{.c}サフィックスを削除します。 ダンプ出力は接尾辞@file{dir/x-foo.c.*}を保持します。

このオプションは、指定された@var{dumpbase}のサフィックスと一致しない場合は無視されます。ただし、以下に指定するように、リンカー出力ベース名を@var{dumppfx}に追加する場合の実行可能サフィックスの代わりになります。

@smallexample
gcc foo.c bar.c -o main.out -dumpbase-ext .out ...
@end smallexample

プライマリ出力として@file{main.out}を作成し、実行可能ファイル名から@var{auxdropsuf}をプレフィックスとして使用して、@file{main-foo.*}という名前の補助出力を作成することにより、補助出力とダンプ出力の上書きを回避します。 および@file{main-bar.*}および@file{main-foo.c.*}および@file{main-bar.c.*}という名前のダンプを出力します。

@item -dumpdir @var{dumppfx}
@opindex dumpdir
補助出力ファイルまたはダンプ出力ファイルの名前を作成するときは、プレフィックスとして@var{dumppfx}を使用します。

@smallexample
gcc -dumpdir pfx- -c foo.c ...
@end smallexample

@file{foo.o}をプライマリ出力として作成し、@file{pfx-foo.*}という名前の補助出力を作成し、指定された@var{dumppfx}とデフォルトのプライマリ出力から派生したデフォルトの@var{dumpbase}を組み合わ、入力名から順番に派生します。 ダンプ出力には、入力名のサフィックス@file{pfx-foo.c.*}も使用されます。

@var{dumppfx}をディレクトリ名として使用する場合は、ディレクトリ区切り文字で終了する必要があります。

@smallexample
gcc -dumpdir dir/ -c foo.c -o obj/bar.o ...
@end smallexample

@file{obj/bar.o}をプライマリ出力として作成し、@file{dir/bar.*}という名前の補助出力を作成し、指定された@var{dumppfx}とプライマリ出力名から派生したデフォルトの@var{dumpbase}を組み合わせます。 。 ダンプ出力には、入力名のサフィックス@file{dir/bar.c*}も使用されます。

デフォルトでは、出力ファイルの場所になります。 オプション@option{-save-temps=cwd}および@option{-save-temps=obj}は、明示的な@option{-dumpdir}オプションと同様に、このデフォルトをオーバーライドします。 そのようなオプションが複数指定されている場合は、最後のオプションが優先されます。

@smallexample
gcc -dumpdir pfx- -c foo.c -save-temps=obj ...
@end smallexample

@option{-save-temps=*}は、以前の@option{-dumpdir}オプションで指定された@var{dumppfx}をオーバーライドするため、@file{foo.o}を@file{foo.*}という名前の補助出力で出力します。 @option{=obj}が@option{-save-temps}のデフォルトであることや、出力ディレクトリが暗黙的に現在のディレクトリであることは問題ではありません。 ダンプ出力の名前は@file{foo.c.*}です。

複数の入力ファイルからコンパイルする場合、@option{-dumpbase}が指定されていると、@var{dumpbase}から@var{auxdropsuf}サフィックスを引いたものとダッシュが追加されます（ディレクトリコンポーネントが含まれている場合はオーバーライドされます）。 またはデフォルトの@var{dumppfx}であるため、複数のコンパイルのそれぞれが異なる名前のauxおよびdump出力を取得します。

@smallexample
gcc foo.c bar.c -c -dumpdir dir/pfx- -dumpbase main ...
@end smallexample

補助ダンプを@file{dir/pfx-main-foo.*}と@file{dir/pfx-main-bar.*}に出力し、@var{dumpbase}-を@var{dumppfx}に追加します。 ダンプ出力は、入力ファイルのサフィックスを保持します：それぞれ@file{dir/pfx-main-foo.c.*}および@file{dir/pfx-main-bar.c.*}。 単一入力コンパイルと対比：

@smallexample
gcc foo.c -c -dumpdir dir/pfx- -dumpbase main ...
@end smallexample

つまり、@option{-dumpbase}を単一のソースに適用しても、入力ファイルごとに個別の@var{dumpbase}を計算して追加することはありません。 その補助出力とダンプ出力は@file{dir/pfx-main.*}にあります。

コンパイルしてから複数の入力ファイルからリンクする場合、デフォルトまたは明示的に指定された@var{dumppfx}も、上記の@var{dumpbase}変換を受けます（たとえば、上記の@file{foo.c}と@file{bar.c}のコンパイル、ただし@option {-c}なし）。 @option{-dumpdir}も@option{-dumpbase}も指定されていない場合、リンカーの出力ベース名から、指定されている場合は@var{auxdropsuf}を差し引いたもの、それ以外の場合は実行可能サフィックスを差し引いたものに、 代わりにデフォルトの@var{dumppfx}にダッシュが追加されます。 ただし、以前のリンクの場合とは異なり、次の点に注意してください。

@smallexample
gcc foo.c bar.c -dumpdir dir/pfx- -o main ...
@end smallexample

は@option{-dumpdir}が明示的に指定されているため、出力名@file{main}を@var{dumppfx}に追加しません。 目標は、明示的に指定された@var{dumppfx}に、必要に応じてプレフィックスの一部として指定された出力名を含めることができるようにすることです。 意味のあるオプションを単に破棄することを避けるために、明示的に指定された@option{-dumpbase}のみが結合されます。

単一の入力ファイルからコンパイルしてリンクする場合、リンカーの出力ベース名は、ベース名を単一の入力ファイル名と共有しない場合にのみ、上記のようにデフォルトの@var{dumppfx}に追加されます。 これは、上記の単一入力リンクのケースでカバーされていますが、@option{-save-temps=*}によってオーバーライドされた場合でも、組み合わせを禁止する明示的な@option{-dumpdir}ではカバーされていません。

@smallexample
gcc foo.c -dumpdir alt/pfx- -o dir/main.exe -save-temps=cwd ...
@end smallexample

補助出力には@file{foo.*}という名前が付けられ、@option{-save-temps=cwd}によって最終的に要求されるように、出力@file{foo.c.*}を現在の作業ディレクトリにダンプします。

直感的ですが少し不正確なデータフローのためにすべてを要約します。プライマリ出力名はディレクトリ部分とベース名部分に分割されます。 @var{dumppfx}は@option{-dumpdir}または@option{-save-temps=*}でオーバーライドされない限り前者に設定され、@var{dumpbase}は@option{-dumpbase}でオーバーライドされない限り後者に設定されます。 複数の入力またはリンクがある場合、この@var{dumpbase}を@var{dumppfx}と組み合わせて、各入力ファイルから取得できます。 各入力の補助出力名は、@var{dumppfx}、@var{dumpbase}マイナスサフィックス、および補助出力サフィックスを組み合わせて形成されます。 ダンプ出力名は、@var{dumpbase}のサフィックスが保持されるという点でのみ異なります。

LTOの再コンパイル中に作成された補助出力とダンプ出力に関しては、@var{dumppfx}と@var{dumpbase}の組み合わせが、指定されたとおり、またはリンカー出力名から派生したものであり、入力から派生したものではありません。 それ以外の場合はそのまま使用されませんが、@command{lto-wrapper}への@option{-dumpdir}オプションとして、コンパイラが追加したダッシュ（存在する場合）を置き換える末尾のピリオドが渡されます。 このプログラムはリンクに関与しているため、通常は@option{-dumpbase}と@option{-dumpbase-ext}を取得せず、それらを無視します。

サブコンパイラを実行する場合、@command{lto-wrapper}は受信した@var{dumppfx}にLTOステージ名を追加し、ディレクトリコンポーネントが含まれていることを確認して、@option{-dumpdir}をオーバーライドし、それを@option{-dumpbase}としてサブコンパイラに渡します。

@item -v
@opindex v
（標準エラー出力に）コンパイルの段階を走らせるために実行されるコマンドをプリントする。コンパイラ・ドライバ・プログラムの、そして、プリプロセッサと本来のコンパイラのバージョン番号もプリントする。

@item -###
@opindex ###
@option{-v}と同様だが、コマンドは実行されず、引数は単なるアルファベット文字と@code{./-_}のみを含んでいるのでない限りクォートされる。これはドライバが生成したコマンド行を取り込むシェルスクリプトで有用である。

@item --help
@opindex help
（標準出力に）@command{gcc}が理解するコマンド列オプションの説明を出力する。もし@option{-v}も指定された時は、
@option{--help}は@command{gcc}が呼び出す様々なプロセスにも@option{--help}が渡されて、それらが受け付けるコマンド行オプション
も表示できるようにする。もし@option{-Wextra}オプションが（@option{--help}の前に）指定された時は、対応する文書のないコマンド行オプションも表示する。

@item --target-help
@opindex target-help
（標準出力に）それぞれのツールでターゲット固有のコマンド行オプションの説明を表示する。あるターゲットでは、ターゲット固有の追加の情報もプリントする。

@item --help=@{@var{class}@r{|[}^@r{]}@var{qualifier}@}@r{[},@dots{}@r{]}
（標準出力に）コンパイラが理解し、すべての指定されたクラスと指定子に当てはまるコマンド行オプションを出力する。サポートするクラスがは、

@table @asis
@item @samp{optimizers}
コンパイラがサポートするすべての最適化オプションを表示する。

@item @samp{warnings}
コンパイラによって生成される警告メッセージを制御するすべてのオプションを表示する

@item @samp{target}
ターゲット固有のオプションを表示する。しかし、@option{--target-help}と異なり、リンカとアセンブラのターゲット固有のオプションは表示しない。これはそれらのツールが拡張@option{-help=}構文を現在サポートしていないからである。

@item @samp{params}
@option{-param}によって認識される値を表示する。

@item @var{language}
@var{language}がサポートするオプションを表示する。@var{language}はこのバージョンのGCCがサポートする言語名の１つである。オプションがすべての言語でサポートされている場合は、@samp{common}クラスを選択する必要があります。

@item @samp{common}
全言語で共通のオプションを表示する
@end table

サポートされた指定子は

@table @asis
@item @samp{undocumented}
文書化されていないオプションのみを表示する。

@item @samp{joined}
等号の後ろにテキストが続く@samp{--help=target}のような引数を表示する。

@item @samp{separate}
@samp{-o output-file}のような、元のオプションの後ろで分離した後で現れる引数を取るオプションを表示する。
@end table

したがって、コンパイラがサポートする文書化されていないターゲット固有のスイッチをすべて表示する例では、これを使う。

@smallexample
--help=target,undocumented
@end smallexample

指定子の意味は@samp{^}文字を前に置くことで反転することができ、例えば、説明のあるすべてのON/OFFの警告オプションを表示したいときはこれを使う。

@smallexample
--help=warnings,^joined,^undocumented
@end smallexample

@option{--help=}の引数は否定された指定子のみにするべきではない。

いくつかのクラスを組み合わせることは可能だが、これは通常は出力が何も表示されないように制限する。
しかし、機能するケースとして、クラスの一つが@var{targe}である場合である。
例えば、すべてのターゲット固有の最適化オプションを表示したい、これを使う。

@smallexample
--help=target,optimizers
@end smallexample

オプション@option{--help=}はコマンド行で繰り返すことができる。それぞれの連続した使用はオプションの繰り返された
列を出力し、すでに表示したものを飛ばす。

もし@option{-Q}が@option{--help=}オプションの前にコマンド行で現れるなら、@option{--help=}で表示される説明テキストが変わる。
表示されたオプションを描写する代わりに、オプションが有効・無効・特定の値がセットされているかどうかをの表示が与えられる。
（コンパイラが@option{--help=}オプションが使われた場所を知っていると仮定して）

ここにARMポートの@command{gcc}の短縮された例がある。

@smallexample
  % gcc -Q -mabi=2 --help=target -c
  The following options are target specific:
  -mabi=                                2
  -mabort-on-noreturn                   [disabled]
  -mapcs                                [disabled]
@end smallexample

出力は前のコマンドラインオプションの効果に依存するので、例えば、以下を使うことで@option{-O2}でどの最適化が有効になるかを
調べることが可能になる。

@smallexample
-Q -O2 --help=optimizers
@end smallexample

代わりに、以下を使うことで@option{-O3}で有効になるON/OFFの最適化を見つけることができる。

@smallexample
gcc -c -Q -O3 --help=optimizers > /tmp/O3-opts
gcc -c -Q -O2 --help=optimizers > /tmp/O2-opts
diff /tmp/O2-opts /tmp/O3-opts | grep enabled
@end smallexample

@item --version
@opindex version
呼びだされたGCCのバージョン番号と著作権を表示する。

@item -pass-exit-codes
@opindex pass-exit-codes
通常@command{gcc}プログラムはコンパイラのどの段階で非成功の返りコードを返しても
コード1で終了する。もし@option{-pass-exit-codes}を指定すると@command{gcc} プログラムは
代わりにエラー指示を返す段階で生じた数値的に最も高いエラーを返す。内部コンパイラ・エラーが
発生した場合は、C、C++とFortranフロントエンドは4を返す。

@item -pipe
@opindex pipe
種々のコンパイルの段階の間の通信に一時ファイルではなくパイプを用いる。これはアセンブラがパイプ
からの読み出しができないシステムでは失敗する。しかしGNUアセンブラでは問題がない。

@item -specs=@var{file}
@opindex specs
コンパイラは、標準的な@file{specs}ファイルを読み込むあと、@command{cc1}、@command{cc1plus}、@command{as}、@command{ld}、その他にどのスイッチを渡すか決定するときに、@command{gcc}ドライバ・プログラムが使うデフォルトを上書きするために@var{file}を処理する。コマンド行に1つより多くの@option{-specs=@var{file}}を使うことができ、それはその順で、左から右に処理される。
@var{file}の書式についての情報は@xref{Spec Files}。

@item -wrapper
@opindex wrapper
ラッパプログラムの下ですべてのサブプログラムを起動する。ラッパプログラムの名前と引数はコンマ区切りのリストで渡される。

@smallexample
gcc -c t.c -wrapper gdb,--args
@end smallexample

@noindent
これは@command{gcc}のすべてのサブプログラムを@samp{gdb --args}で実行し、
@command{cc1}の呼び出しは@samp{gdb --args cc1 @dots{}}である。

@item -ffile-prefix-map=@var{old}=@var{new}
@opindex ffile-prefix-map
ディレクトリ@file{@var{old}}にあるファイルをコンパイルするときは、ファイルがディレクトリ@file{@var{new}}にあるかのように、コンパイルの結果にそれらへの参照を記録します。 このオプションを指定することは、個々の@option{-f*-prefix-map}オプションをすべて指定することと同じです。 これは、場所に依存しない再現可能なビルドを作成するために使用できます。 @option{-fmacro-prefix-map}および@option{-fdebug-prefix-map}も参照してください。

@item -fplugin=@var{name}.so
@opindex fplugin
それがコンパイラによってdlopenされる共有オブジェクトであると仮定して、ファイル@var{name}.so
のプラグインコードをロードする。共有オブジェクトファイルの基底名は
引数解析の目的でプラグインを識別するために使われる。（下の
@option{-fplugin-arg-@var{name}-@var{key}=@var{value}}を見よ）
それぞれのプラグインはPlugins APIで指定されたコールバック関数を定義すべきである。

@item -fplugin-arg-@var{name}-@var{key}=@var{value}
@opindex fplugin-arg
プラグイン@var{name}の引数@var{key}を@var{value}で定義する。

@item -fdump-ada-spec@r{[}-slim@r{]}
@opindex fdump-ada-spec
CとC++のソースとインクルードファイルで、対応するAda specsを生成する。
@xref{Generating Ada Bindings for C and C++ headers,,, gnat_ugn,
GNAT ユーザガイド}で、この機能の詳細の文書が提供される。

@item -fada-spec-parent=@var{unit}
@opindex fada-spec-parent
上の@option{-fdump-ada-spec@r{[}-slim@r{]}}と合わせて、Ada specsを親の
@var{unit}の子単位で生成する。

@item -fdump-go-spec=@var{file}
@opindex fdump-go-spec
どんな言語の入力ファイルについてに対しても、@var{file}で対応するGo宣言を生成する。
これは、Go @code{const}、@code{type}、@code{var}とある他の言語で書かれるコードに
Goインターフェースを書き始める役に立つ方法であるかもしれない@code{func}宣言を生成する。

@include ../libiberty/at-file.texi
@end table

@node Invoking G++
@section C++プログラムのコンパイル

@cindex suffixes for C++ source
@cindex C++ source file suffixes
C++ソースファイルは通常@samp{.C}、@samp{.cc}、@samp{.cpp}、@samp{.CPP}、@samp{.c++}、
@samp{.cp}、@samp{.cxx}拡張子の一つを使う。C++ヘッダファイルは、@samp{.hh}、@samp{.hpp}、
@samp{.H}または（共有テンプレート・コードについては）@samp{.tcc}をしばしば使う。そして、プリプロセスされたC++ファイルは、接尾辞@samp{.ii}を使う。Cプログラム（通常名前@command{gcc}で）をコンパイルするためにあってたとえあなたが同じ方法でコンパイラを呼ぶとしても、GCCはこれらの名前でファイルを認識して、C++プログラムとしてそれらをコンパイルする。

@findex g++
@findex c++
しかし、@command{gcc}を使った場合はC++ライブラリを加えない。@command{g++}はGCCを呼んで自動的にC++ライブラリに
対してリンクする。それは@samp{.c}、@samp{.h}、@samp{.i}ファイルを@option{-x}を使わないかぎりはCソースではなく
C++ソースとして扱う。このプログラムは@samp{.h}拡張子のCヘッダファイルをC++で使うためにプリコンパイルするときに役立つ。
多くのシステムで、@command{g++}は@command{c++}でもインストールされる。

@cindex invoking @command{g++}
C++プログラムをコンパイルするとき、どんな言語をコンパイルするときのコマンドラインオプションと同じもの指定して良い。
C関連でのみ意味を持つコマンドラインオプション、C++プログラムでのみ意味を持つオプションもある。
@xref{C Dialect Options,,C変種を制御するオプション}はC関連言語のオプションの説明である。
@xref{C++ Dialect Options,,C++変種を制御するオプション}はC++プログラムでのみ意味を持つオプションの説明である。

@node C Dialect Options
@section C変種を制御するオプション
@cindex dialect options
@cindex language dialect options
@cindex options, dialect

以下のオプションはコンパイラが受理するC（もしくはC派生のC++、Objective-C、Objective-C++)の変種を制御するオプションである。

@table @gcctabopt
@cindex ANSI support
@cindex ISO support
@item -ansi
@opindex ansi
Cモードでは@option{-std=c90}と等価である。C++のモードでは@option{-std=c++98}と等価である。

これは@code{asm}や@code{typeof}キーワード、使っているシステムを識別する@code{unix}や@code{vax}
のような定義済みマクロのような、ISO C90(Cコードをコンパイルするとき)、標準C++(C++コードをコンパイルするとき)と
非互換のあるGCCの機能を消す。それは望まれず、めったに使われないトライグラフを有効にする。Cコンパイラでは
C++スタイルの@samp{//}コメントや@code{inline}キーワードも無効にする。

代替キーワード@code{__asm__}, @code{__extension__}, @code{__inline__}, @code{__typeof__}は@option{-ansi}
があっても機能する。もちろんISO Cプログラムで使いたくはないだろうが、@option{-ansi}でのコンパイル
に含まれるかもしれないヘッダファイルでは役に立つ。@code{__unix__}や@code{__vax__}のような代替定義済みマクロも、
@option{-ansi}の有無にかかわらず有効である。

@option{-ansi}オプションは、非ISOプログラムがむやみに拒絶される原因にならない。
それのために、@option{-Wpedantic}は@option{-ansi}に加えて必要とされる。
  @xref{Warning Options}.

@option{-ansi}オプションが使われるとき、マクロ@code{__STRICT_ANSI__}はあらかじめ定義されている。
あるヘッダファイルはこのマクロに注意するかもしれなくて、特定の機能を宣言するか、
ISO標準が必要としない特定のマクロを定めることを控えるかもしれない;これは、他のもののこれらの名前を
使用するかもしれないどんなプログラムにでも干渉することを避けることになっている。

通常組み込まれるが、意味論をISO Cによって定義されていない関数（例えば@code{alloca}と@code{ffs}）は
@option{-ansi}が使われるとき、組み込み関数でない。影響される関数の詳細は
@xref{Other Builtins,,GCCによって提供されている他の組み込み関数}。

@item -std=
@opindex std
言語標準を指定する。それらの言語標準の詳細は@xref{Standards,,GCCによってサポートされた言語標準}。このオプションは現在CかC++をコンパイルするときだけサポートしている。

コンパイラは、（例えば@samp{c90}または@samp{c++98}のような）いくつかのベース標準と、
（@samp{gnu90}や@samp{gnu++98}のような）それらの標準のGNU変種を受け入れることができる。
ベース標準が指定されるとき、コンパイラはその標準に追従しているすべてのプログラム＋
それと矛盾しないGNU拡張を使っているプログラムを受け入れる。
たとえば、@option{-std=c90}はISO C90と相容れないGCCの特定の機能（例えば@code{asm}と@code{typeof}キーワード）を
オフにするが、ISO C90で、意味をそんなに持たない（@code{?: }表現の中名辞を省略することのような）他のGNU拡張は
受け入れる。他方、標準のGNU変種が指定されるとき、それらの機能がベース標準の意味を変えるときでも、コンパイラによってサポートされるすべての機能は使用可能にされる。その結果、ある厳しく従っているプログラムは拒絶されるかもしれない。どの機能が標準のそのバージョンを与えられるGNU拡張であるかについて確認するために、特定の標準は、@option{-Wpedantic}により用いられる。たとえば、@option{-std=gnu90 -Wpedantic}はC++スタイルの@samp{//}コメントについて警告するが、@option{-std=gnu99 -Wpedantic}はそうしない。

このオプションの値は提供されなければならない。可能な値は以下のとおりである。

@table @samp
@item c90
@itemx c89
@itemx iso9899:1990
ISO C90プログラムすべてをサポートする。（ISO C90と衝突するいくつかのGNU拡張は無効にされる。Cコードでは
@option{-ansi}と同じである。

@item iso9899:199409
改正案1で修正されたISO C90

@item c99
@itemx c9x
@itemx iso9899:1999
@itemx iso9899:199x
ISO C99。剰余のバグと浮動小数点問題（主に附属書FとGからのオプションのC99機能に関するでない以外）を除いて、
この標準は、かなり完全にサポートされる。詳しい情報は@w{@uref{http://gcc.gnu.org/c99status.html}}を見よ。
名前@samp{c9x}と@samp{iso9899:199x}は非推奨である。

@item c11
@itemx c1x
@itemx iso9899:2011
ISO C11、ISO C標準の2011版である。この標準は、剰余のバグ、浮動小数点数の問題（
附属書FとGからのオプションのC11の機能と、主に、しかし完全にではなく関連している）、
オプションの附属書K（境界チェックインターフェース）、L（解析可能性）。名前@samp{c1x}は非推奨
である。

@item c17
@itemx c18
@itemx iso9899:2017
@itemx iso9899:2018
ISO C17、ISO C標準の2017年改訂版（2018年に公開）。 この標準は、欠陥の修正（すべて@option{-std=c11}で適用される）と@code{__STDC_VERSION__}の新しい値を除いてC11と同じであり、C11と同じ範囲でサポートされます。

@item c2x
ISO C標準の次のバージョン、まだ開発中です。 このバージョンのサポートは実験的で不完全です。

@item gnu90
@itemx gnu89
ISO C90のGNU変種（C99の機能をいくつか含む）

@item gnu99
@itemx gnu9x
ISO C99のGNU変種。名前@samp{gnu9x}は非推奨である。

@item gnu11
@itemx gnu1x
ISO C11のGNU変種。名前@samp{gnu1x}は非推奨である。

@item gnu17
@itemx gnu18
ISO C17のGNU変種。これはCコードのデフォルトである。

@item gnu2x
まだ開発中のISO C標準の次のバージョン、およびGNU拡張機能。 このバージョンのサポートは実験的で不完全です。

@item c++98
@itemx c++03
1998年のISO C++標準＋2003の技術的なエラッタと追加の不具合報告。C++コードでの@option{-ansi}と同じ。

@item gnu++98
@itemx gnu++03
@option{-std=c++98}のGNU変種。

@item c++11
@itemx c++0x
2011 ISO C++標準＋改定。名前@samp{c++0x}は非推奨である。

@item gnu++11
@itemx gnu++0x
@option{-std=c++11}のGNU変種。名前@samp{gnu++0x}は非推奨である。

@item c++14
@itemx c++1y
2014 ISO C++標準＋改定。名前@samp{c++1y}は非推奨である。

@item gnu++14
@itemx gnu++1y
@option{-std=c++14}のGNU変種。これはC++コードのデフォルトである。名前@samp{gnu++1y}は非推奨である。

@item c++17
@item c++1z
2017 ISO C++標準＋改定。名前@samp{c++1z}は非推奨である。

@item gnu++17
@item gnu++1z
@option{-std=c++17}のGNU変種。名前@samp{gnu++1z}は非推奨である。

@item c++20
@itemx c++2a
2020 ISO C++標準と修正。
サポートは実験的なものであり、将来のリリースで互換性のない方法で変更される可能性があります。
@samp{c++2a}という名前は非推奨になりました。

@item gnu++20
@itemx gnu++2a
@option {-std=c++20}のGNU変種。
サポートは実験的なものであり、将来のリリースで互換性のない方法で変更される可能性があります。
@samp {gnu ++ 2a}という名前は非推奨になりました。

@end table

@item -fgnu89-inline
@opindex fgnu89-inline
オプション@option{-fgnu89-inline}はGCCにC99モードで@code{inline}関数を使った時に伝統的なGNUの意味を使うように
伝える。@xref{Inline,,マクロと同速のインライン関数}.このオプションを使用することは、@code{gnu_inline}関数属性をすべてのインライン関数に加えることにざっと等しい。(@pxref{Function Attributes}).

オプション@option{-fno-gnu89-inline}は明示的にGCCにC99やgnu99モードでC99の意味を使えるように伝える。（すなわち、デフォルトの振る舞いを指定する。）このオプションは@option{-std=c90}や@option{-std=gnu90}モードではサポートしていない。

プリプロセスマクロ@code{__GNUC_GNU_INLINE__}と@code{__GNUC_STDC_INLINE__}を@code{inline}関数がどちらの意味であるかをチェックするのに使って良い。 @xref{Common Predefined
Macros,,,cpp,The C Preprocessor}.

@item -fpermitted-flt-eval-methods=@var{style}
@opindex fpermitted-flt-eval-methods
@opindex fpermitted-flt-eval-methods=c11
@opindex fpermitted-flt-eval-methods=ts-18661-3
ISO/IEC TS 18661-3は、交換または拡張フォーマットであるセマンティックタイプを持つ操作と定数を、
その型の精度と範囲で評価すべきかを示す@code{FLT_EVAL_METHOD}の新しい許容値を定義する。
これらの新しい値は、C99/C11で許可されているもののスーパーセットであり、
@code{FLT_EVAL_METHOD}の他の正の値の意味を指定しない。したがって、C11に準拠するコードは、
新しい値の可能性を期待して書かれていない可能性がある。

@option{-fpermitted-flt-eval-methods}は、コンパイラがC99/C11で指定された@code{FLT_EVAL_METHOD}の値のみを許可するか、
ISO/IEC TS 18661-3で指定された拡張された値のセットを許可するかを指定する。

@var{style}は必要に応じて@code{c11}か@code{ts-18661-3}である。

規格に準拠したモード（@option{-std=c11}など）のデフォルトは、@option{-fpermitted-flt-eval-methods=c11}である。
GNU変種（@option{-std=gnu11}など）のデフォルトは@option{-fpermitted-flt-eval-methods=ts-18661-3}である。

@item -aux-info @var{filename}
@opindex aux-info
与えられたファイル名にヘッダファイルを含めて、翻訳単位で宣言・定義されたすべての関数のプロトタイプ化した宣言を
出力する。このオプションはC以外の言語では黙って無視される。

宣言に加え、ファイルはコメント内に、それぞれの宣言の起源（ソースファイルと行）、
宣言が暗黙か、プロトタイプ化されているかしないか（それぞれ@samp{I}, 新しい時は@samp{N}, 古い時は@samp{I}で
行番号とコロンの後ろの最初の文字で）、宣言と定義のどちらから来たか（それぞれ続く文字で@samp{C}か@samp{F}で）
を指定する。。関数定義のの場合は、コメント内に、宣言の後ろで、K&R式の引数リストが宣言に続いて提供される。

@item -fallow-parameterless-variadic-functions
@opindex fallow-parameterless-variadic-functions
名前つきパラメータなしでの可変長関数を受理する。

そのような関数を定義することは可能だが、引数を読むことが不可能なのであまり役に立たない。
これはこの構造がC++では許可されているのでCでのみサポートしている。

@item -fno-asm
@opindex fno-asm
@code{asm}, @code{inline}, @code{typeof}をキーワードとして認識せず、識別子としてこの語を使えるようにする。
キーワード@code{__asm__}, @code{__inline__}, @code{__typeof__}は代わりに使うことができる。@option{-ansi}は
@option{-fno-asm}を含む。

C++では@code{asm}と@code{inline}は標準キーワードなので@code{typeof}キーワードのみに影響する。代わりに、
同じ効果を持つ@option{-fno-gnu-keywords}フラグを使いたいかもしれない。C99モード(@option{-std=c99}, 
@option{-std=gnu99})では、このスイッチは@code{inline}がC99で標準キーワードなので、@code{asm}と
@code{typeof}キーワードにのみ影響する。

@item -fno-builtin
@itemx -fno-builtin-@var{function}
@opindex fno-builtin
@cindex built-in functions
@samp{__builtin_}接頭辞で始まらない組み込み関数を認識しない。
ISOの標準の意味が無いために厳密なISO C準拠のための@option{-ansi}や@option{-std}オプション
では組み込み関数にならないものを含め、影響される関数は@xref{Other Builtins,,GCCによって提供される他の組み込み関数}

GCCは通常ある組み込み関数をもっと効率よく扱うために特別なコードを生成する。例えば、@code{alloca}は
スタックを直接調整する単一命令になるかもしれず、@code{memcpy}の呼び出しはインラインのコピーループ
になるかもしれない。結果のコードはしばしばより小さく、より速くなるが、関数呼び出し自体がもはや
現れないため、それらの呼び出しにブレークポイントをセットすることはできず。異なるライブラリをリンクして
挙動を変える事もできない。それに加え、関数が組み込み関数として認識されると、たとえ結果のコードがまだ
関数への呼び出しを含んでいても、GCCはそのような関数への呼び出しについての問題に警告したり、
もっと効率のよいコードを生成するために、その関数の情報を使うかもしれない。例えば、@code{printf}が組み込みならば
@option{-Wformat}での悪い呼び出しに警告を与え、@code{strlen}はグローバルメモリを修正しないことを知っている。

@option{-fno-builtin-@var{function}}オプションは組み込み関数@var{function}のみを無効にする。
@var{function}は@samp{__builtin_}で始まってはならない。もしこのバージョンのGCCで組み込みでない関数の名前の
場合は、このオプションは無視される。対応する@option{-fbuiltin-@var{function}}オプションはない。もし、
@option{-fno-builtin}か@option{-ffreestanding}を使っていて選択的に組み込み関数を有効にしたいならば、以下の様な
マクロを定義して良い。

@smallexample
#define abs(n)          __builtin_abs ((n))
#define strcpy(d, s)    __builtin_strcpy ((d), (s))
@end smallexample

@item -fgimple
@opindex fgimple

@code{__GIMPLE}とマークされた関数定義の解析を有効にする。これは実験的な機能であり、
GIMPLEパスの単体試験を可能にする。

@item -fhosted
@opindex fhosted
@cindex hosted environment

コンパイルターゲットをホスト環境と宣言する。これは@option{-fbuiltin}を含む。
ホスト環境は全標準ライブラリが利用可能で、@code{main}が@code{int}の戻り値型であるものである。
例はカーネル以外のほとんどすべてである。これは@option{-fno-freestanding}と等価である。

@item -ffreestanding
@opindex ffreestanding
@cindex hosted environment

コンパイルターゲットと自立環境と宣言する。これは@option{-fno-builtin}を含む。自立環境は
標準ライブラリが存在しないかもしれず、プログラムの開始が@code{main}とは限らないものである。
最も明白な例はOSのカーネルである。これは@option{-fno-hosted}と等価である。

自立環境とホスト環境の詳細は@xref{Standards,,GCCによってサポートされた言語標準}

@item -fopenacc
@opindex fopenacc
@cindex OpenACC accelerator programming
C/C++での@code{#pragma acc}とFortranでの@code{!$acc}OpenACCディレクティブを有効にする。
@option{-fopenacc}が指定された時は、コンパイラはOpenACCアプリケーション・プログラミングインターフェースv2.6
@w{@uref{https://www.openacc.org/}}に基づいた加速されたコードを生成する。このオプションは
@option{-pthread}を含み、したがって@option{-pthread}をサポートするターゲットでのみサポートされている。

@item -fopenacc-dim=@var{geom}
@opindex fopenacc-dim
@cindex OpenACC accelerator programming
明示的に指定されていない並列オフロード領域のデフォルト計算次元を指定する。@var{geom}の値は
':'で区切られた3つのサイズで、順番に'gang', 'worker', 'vector'である。サイズは省略でき、
ターゲット固有のデフォルト値が使われる。

@item -fopenacc-kernels=@var{mode}
@opindex fopenacc-kernels
@cindex OpenACC accelerator programming
OpenACCの `kernels 'コンストラクト処理のモードを指定します。
@option{-fopenacc-kernels=decompose}を使用すると、OpenACCの「カーネル」コンストラクトはパーツ（一連の計算コンストラクト）に分解され、それぞれが個別に処理されます。
これは進行中の作業です。 @option{-fopenacc-kernels=parloops}を使用すると、OpenACCの「カーネル」構造は@samp{parloops}パスによって一括で処理されます。 これが現在のデフォルトです。

@item -fopenmp
@opindex fopenmp
@cindex OpenMP parallel
C/C++での@code{#pragma omp}、Fortranでの@code{!$omp}OpenMPディレクティブを有効にする。
@option{-openmp}が指定された時は、コンパイラはOpenMPアプリケーションプログラムインターフェース
v4.5@w{@uref{http://www.openmp.org/}}による並列コードを生成する。このオプションは@option{-pthread}を含み、
したがって@option{-pthread}をサポートするターゲットでのみサポートされている。
@option{-fopenmp}は@option{-fopenmp-simd}を含む。

@item -fopenmp-simd
@opindex fopenmp-simd
@cindex OpenMP SIMD
@cindex SIMD
C/C++での@code{#pragma omp}とFortranでの@code{!$imp}でのOpenMPのSIMPディレクティブを有効にする。
他のOpenMPディレクティブは無視される。

@item -fgnu-tm
@opindex fgnu-tm
オプション@option{-fgnu-tm}が指定されると、コンパイラはIntelの現在のトランザクションメモリABI仕様書文書
(2009年5月6日、リビジョン1.1)のLinux変種のコードを生成する。これは公式の仕様書が変更されると、
GCCの将来のバージョンでインターフェースが変更されるかもしれない実験的な機能である。この機能は
すべてのアーキテクチャでサポートされているわけではないことに気をつけてください。

トランザクションメモリーのGCCのサポートの情報は
@xref{Enabling libitm,,The GNU Transactional Memory Library,libitm,GNU
Transactional Memory Library}.

トランザクションメモリーの機能は非呼び出し例外(@option{-fnon-call-exceptions}ありではサポートされない
ことに注意。

@item -fms-extensions
@opindex fms-extensions
Microsoftヘッダファイルで使われる非標準のいくつかを受理する。

C+＋コードでは、これは構造体のメンバ名が前の型宣言と同じであることを許す。

@smallexample
typedef int UOW;
struct ABC @{
  UOW UOW;
@};
@end smallexample

構造体と共用体での無名フィールドのある場合では、このオプションでのみ受理される。詳細は
 @xref{Unnamed Fields,,構造体・共用体内部の無名構造体・共用体フィールド}

このオプションはms-abiを使うx86ターゲット以外ではオフであることに注意。

@item -fplan9-extensions
@opindex fplan9-extensions
Plan9コードで使われる非標準の構造のいくつかを受理する。

これは@option{-fms-extensions}を有効にし、匿名フィールドを持つ構造体へのポインタをフィールドの型
の要素へのポインタを期待する関数を渡すことを許し、typedefを使って宣言された匿名フィールドへ参照することを
許可する。詳細は @xref{Unnamed Fields,,構造体・共用体内部の無名構造体・共用体フィールド}。これはCでのみサポートされ、C++ではサポートされない。

@item -fcond-mismatch
@opindex fcond-mismatch
条件式の第2引数と第3引数での型の不一致を許す。そのような式の値はvoidである。このオプションは
C++ではサポートされない。

@item -flax-vector-conversions
@opindex flax-vector-conversions
異なる要素数・非互換の要素型のベクタの暗黙の型変換を許す。このオプションは新しいコードでは使うべきではない。

@item -funsigned-char
@opindex funsigned-char
型@code{char}を@code{unsigned char}のように符号なしにさせる。

それぞれの機種では@code{char}がどちらであるべきかのデフォルトがある。@code{unsigned char}がデフォルトであるか、
@code{signed char}がデフォルトであるかのどちらかである。

理想的には、移植性のあるプログラムは常にオブジェクトの符号に依存するときには@code{signed char}か
@code{unsigned char}を使うべきである。しかし、多くのプログラムでは単なる@code{char}を使って書かれ、
書かれた機種に依存して、符号ありであるか、符号なしであるかを期待する。このオプションと、その逆は、
そのようなプログラムが逆のデフォルトでも動くようにさせる。

型@code{char}は、その振る舞いが@code{signed char}, @code{unsigned char}のどちらにいつも似ていても、
常にそれらの型とは異なる型である。

@item -fsigned-char
@opindex fsigned-char
型@code{char}を@code{signed char}のように符号付きにさせる。

これは、@option{-funsigned-char}の否定形である@option{-fno-unsigned-char}と等価である。
同様に、オプション@option{-fno-signed-char}は@option{-funsigned-char}と等価である。

@item -fsigned-bitfields
@itemx -funsigned-bitfields
@itemx -fno-signed-bitfields
@itemx -fno-unsigned-bitfields
@opindex fsigned-bitfields
@opindex funsigned-bitfields
@opindex fno-signed-bitfields
@opindex fno-unsigned-bitfields
これらのオプションはビットフィールドが、宣言に@code{signed}や@code{unsigned}が含まれていない時に
符号ありか符号なしかを制御する。デフォルトでは、そのようなビットフィールドは符号ありである。なぜなら
それで一貫しているからである。@code{int}のような基本的な整数型は符号あり型である。

@item -fsso-struct=@var{endianness}
@opindex fsso-struct
構造体や共用体のデフォルトの格納順序を指定されたエンディアンにする。受理される値は@samp{big-endian}と
@samp{little-endian}、ターゲットの本来のエンディアンである（デフォルトの）@samp{native}である。
このオプションはC++ではサポートされない。

@strong{警告：} @option{-fsso-struct}スイッチはもし指定されたエンディアンがターゲット本来のエンディアンでない場合には、オプション無しで生成したコードとバイナリ非互換のコードを生成する。
@end table

@node C++ Dialect Options
@section C++変種を制御するオプション

@cindex compiler options, C++
@cindex C++ options, command-line
@cindex options, C++
この節ではC++プログラムでのみ意味を持つコマンドラインオプションを描写する。どの言語が含まれているかにかかわらず、
GNUコンパイラオプションの殆どのオプションを使うことができる。例えば、@file{firstClass.C}をこのようにコンパイルできる。

@smallexample
g++ -g -fstrict-enums -O -c firstClass.C
@end smallexample

@noindent
この例で、@option{-fstrict-enums}はC++プログラムでのみ意味を持つオプションである。GCCでサポートされている
どの言語でも、他のプションを使うことができる。

@option{-std}のような、Cプログラムをコンパイルする幾つかのオプションはC++プログラムにも関連する。
@xref{C Dialect Options,,C変種を制御するオプション}.

ここにC++プログラムをコンパイルするとき@emph{だけ}のオプションのリストがある。

@table @gcctabopt

@item -fabi-version=@var{n}
@opindex fabi-version
C++ABIのバージョン@var{n}を使う。デフォルトは0である。

バージョン0はC++ABI仕様書に最も近く準拠するバージョンを参照する。したがって、バージョン0を使って得られる
ABIはABIのバグが修正されるとG++の異なるバージョンでは変化するだろう。

バージョン1はG++ 3.2で初めて現れたバージョンである。

バージョン２はG++3.4で初めて現れ、G++4.9までのデフォルトであった。

バージョン3はテンプレート引数としての定数アドレスのマングルでの誤りを修正する。

バージョン4は、G++ 4.5で最初に現れ、ベクタ型の標準マングルを実装する。

バージョン5は、G++ 4.6で最初に現れ、関数ポインタ型のconst/volatile属性のマングル、
素のdeclのdecltype、他のパラメータの宣言での関数パラメータの使用を修正する

バージョン6は、G++ 4.7で最初に現れ、C++11 スコープenumの昇格の振舞、とテンプレート引数パックのマングル、
const/ststic_cast, 前置++/-- テンプレート引数として使われるクラススコープ関数を修正する。 

バージョン7は、G++ 4.8で最初に現れ、nullptr_tを組み込み型として扱い、デフォルト引数スコープでのラムダのマングル
を修正する。

バージョン8は、G++ 4.9で最初に現れ、関数cv指定子ありの関数型の置換の振る舞いを修正する。

バージョン9は、G++ 5.2で最初に現れ、@code{nullptr_t}のアライメントを修正する。

バージョン10は、G++ 6.1で最初に現れ、(ia32呼び出し規約属性@samp{stdcall}のような)タイプ同一性に影響する
属性のマングルを加える。

バージョン11は、G++ 7で最初に現れ、sizeof...式とオペレーター名のマングリングを訂正する。
関数内で、異なるスコープで宣言されたの同じ名前を持つ複数のエンティティでは、マングリングは
12回の出現で変化を始める。それは@option{-fnew-inheriting-ctors}を含む。

G++ 8で初めて登場したバージョン12は、x86_64ターゲット上の空のクラスと、削除されたコピー/移動コンストラクタのみを持つクラスの呼び出し規約を修正している。 それは、誤って、削除されたコピーコンストラクタと簡単な移動コンストラクタを持つクラスの呼び出し規約を変更した。

バージョン13は、G++ 8.2ではじめて登場し、バージョン12の偶発的な変更を修正した。
 
G++10で最初に登場したバージョン14では、nullptr式のマングリングが修正されています。

G++11で最初に登場したバージョン15は、@code{__ alignof__}のマングリングを@code{alignof}のマングリングとは異なるものに変更します。

@option{-Wabi}も見よ。

@item -fabi-compat-version=@var{n}
@opindex fabi-compat-version
強いエイリアスをサポートするターゲットで、G++は間違ったマングルされた名前でシンボルが定義された時に、
正しくマングルされた名前へのエイリアスを作ることでマングルの変化に対処する。このスイッチはエイリアス
で使うABIバージョンを指定する。

@option{-fabi-version=0}で（デフォルト）、これはデフォルトを11（GCC7互換）とする。もしほかのABIバージョンが明示的に選択されれば、これはデフォルトを0とする。GCC3.2から4.9への互換性のためには、@option{-fabi-compat-version=2}を使う。

もしこのオプションが与えられず、@option{-Wabi=@var{n}}がある場合は、そのバージョンが互換エイリアスに使われる。
もしオプションが@option{-Wabi}（バージョン無しで）といっしょに提供された場合は、このオプションのバージョンが警告
で用いられる。

@item -fno-access-control
@opindex fno-access-control
すべてのアクセスコントロールチェックを切る。このスイッチは主にアクセスコントロールコードのバグの対処に有用である。

@item -faligned-new
@opindex faligned-new
@code{void:: operator new(std::size_t)}が提供する以上のアラインメントを要求する型のC++17@code{new}の
サポートを有効にする。@code{-faligned-new=32}のような数値の引数は（バイト単位で）どのぐらいのアラインメントが
その関数で提供されているを指定するために使うことができるが、殆どのユーザはデフォルトの@code{alignof(std::max_align_t)}
を上書きする必要はないだろう。

このフラグは@option {-std=c++17}でデフォルトで有効になっています。

@item -fchar8_t
@itemx -fno-char8_t
@opindex fchar8_t
@opindex fno-char8_t
C++2aで採用された@code{char8_t}のサポートを有効にします。 これには、新しい@code{char8_t}基本タイプの追加、UTF-8文字列と文字リテラルのタイプの変更、ユーザー定義リテラルの新しい署名、関連する標準ライブラリの更新、新しい@code {__cpp_char8_t}と@code{__ cpp_lib_char8_t}機能テストマクロが含まれます 。

このオプションを使用すると、通常の文字列およびUTF-8文字列に対して関数をオーバーロードできます。

@smallexample
int f(const char *);    // #1
int f(const char8_t *); // #2
int v1 = f("text");     // Calls #1
int v2 = f(u8"text");   // Calls #2
@end smallexample

@noindent
そしてユーザ定義リテラル用の新しい署名が導入されます。

@smallexample
int operator""_udl1(char8_t);
int v3 = u8'x'_udl1;
int operator""_udl2(const char8_t*, std::size_t);
int v4 = u8"text"_udl2;
template<typename T, T...> int operator""_udl3();
int v5 = u8"text"_udl3;
@end smallexample

@noindent
UTF-8文字列と文字リテラルのタイプの変更により、ISO C++11以降の標準との非互換性が生じます。 たとえば、次のコードはISO C++ 11で整形式ですが、@option{-fchar8_t}が指定されている場合は形式が正しくありません。

@smallexample
char ca[] = u8"xx";     // エラー: char配列がワイド文字列から
                        //        初期化される
const char *cp = u8"xx";// エラー: `const char8_t*'から
                        //         `const char*'への不正な変換
int f(const char*);
auto v = f(u8"xx");     // エラー: `const char8_t*'から
                        //         `const char*'への不正な変換
std::string s@{u8"xx"@};  // エラー: `std::basic_string<char>::basic_string()'
                        //        への呼び出し関数が見つからない
using namespace std::literals;
s = u8"xx"s;            // エラー: `basic_string<char8_t>'から
                        //         非スカラー型`basic_string<char>'への
                        //        変換が要求された
@end smallexample

@item -fcheck-new
@opindex fcheck-new
@code{operator new}で返されるポインタがnullでないことを割り当てられた領域を修正しようとする前にチェックする。
C++標準が@code{operator new}が@code{throw()}と宣言された場合にのみ@code{0}を返すと指定し、
その場合にはこのオプションなしでもコンパイラはいつも返り値をチェックするため、このチェックは通常は不必要である。
他の場合は、@code{operator new}が空でない例外指定を持つときは、メモリ枯渇は@code{std::bad_alloc}を投げることで
示される。@samp{new (nothrow)}も見よ。

@item -fconcepts
@itemx -fconcepts-ts
@opindex fconcepts
@opindex fconcepts-ts
@option{-std=c++2a}未満では、@option{-fconcepts}は、コンセプト技術仕様、ISO 19217（2015）のC++拡張のサポートを有効にします。

@option{-std=c++2a}以上では、概念は言語標準の一部であるため、@option{-fconcepts}はデフォルトでオンになります。 ただし、Conceptの標準仕様はTSとは大幅に異なるため、TSで許可されていても標準に組み込まれなかった一部の構成は、@option{-fconcepts-ts}によって有効にすることができます。

@item -fconstexpr-depth=@var{n}
@opindex fconstexpr-depth
C++11定数式関数の最大入れ子評価深さを@var{n}にセットする。制限は定数表現評価の無限再帰を検出するために
必要である。標準で指定された最小値は512である。

@item -fconstexpr-cache-depth=@var{n}
@opindex fconstexpr-cache-depth
@var{n}にキャッシュされるC++11 constexpr関数のネストされた評価深度の最大レベルを設定します。 これはヒューリスティックであり、コンパイル速度（キャッシュが繰り返し計算を回避する場合）とメモリー消費量（キャッシュが非常に再帰的な評価によって非常に大きくなる場合）をトレードオフします。 デフォルトは8です。ほとんどのユーザーはそれを調整する可能性がありませんが、コードでconstexprの計算を頻繁に行う場合は、自分に最適な値を見つけるために実験することをお勧めします。

@item -fconstexpr-loop-limit=@var{n}
@opindex fconstexpr-loop-limit
C++14constexpr関数でのループの繰り返し数の最大値を@var{n}に指定する。制限値は定数式評価中の
無限ループの検出に必要である。デフォルトは262144(1<<18)である。

@item -fconstexpr-ops-limit=@var{n}
@opindex fconstexpr-ops-limit
単一のconstexpr評価中の操作の最大数を設定します。
単一のループの反復回数が上記の制限で制限されている場合でも、複数のネストされたループがあり、それぞれに多くの反復があり、上記の制限よりも小さい場合、またはループの本体内またはさらにループの評価が必要な式が多すぎると、結果のconstexpr評価に時間がかかりすぎる可能性があります。
デフォルトは33554432（1 << 25）です。

@item -fcoroutines
@opindex fcoroutines
C++コルーチン拡張のサポートを有効にします（実験的）。

@item -fno-elide-constructors
@opindex fno-elide-constructors
C++標準は同じ型の他のオブジェクトを初期化するために使われるだけの一時値の生成を省略する実装を許している。
このオプションを指定するとその最適化を無効化し、G++がどんな場合でもコピーコンストラクタを呼ぶようにする。
このオプションはG++がさもなければインライン展開されるようなささいなメンバ関数を呼ぶようにもさせる。

C++17では、コンパイラはこれらの一時値を抜かすことを要求しているが、このオプションは些細なメンバ関数にはまだ影響する。

@item -fno-enforce-eh-specs
@opindex fno-enforce-eh-specs
実行時の例外指定違反のチェックコードを生成しない。このオプションはC++標準に反するが、
@code{NDEBUG}が定義されるような製品ビルドでコードサイズを削減するのに有用かもしれない。
これはユーザコードが例外指定に反する例外を投げることを許可するわけではない。コンパイラはそれでも指定に基づいて
最適化するので、予期せぬ例外を投げると実行時に未定義の振る舞いを引き起こす。

@item -fextern-tls-init
@itemx -fno-extern-tls-init
@opindex fextern-tls-init
@opindex fno-extern-tls-init
C++11とOpneMPは@code{thread_local}と@code{threadprivate}変数が動的に（実行時に）初期化することを認めている。
これをサポートするために、そのような変数の使用はラッパ関数を通して必要な初期化を呼び出す。
同じ翻訳単位で使用と定義をした場合には、このオーバーヘッドは最適化で消えるが、別の翻訳単位で使われた時は、
たとえ動的な初期化が実際には必要ない時でもかなりのオーバーヘッドがある。もしプログラマが動的の初期化のトリガが
必要な定義されていない翻訳単位への変数の使用がない（変数が静的に初期化されているか、他の翻訳単位で使う前に
定義された翻訳単位で実行されている）と確信できるときは、このオーバーヘッドを@option{-fo-extern-tls-init}オプション
で避けることができる。

シンボルエイリアスをサポートしているターゲットでは、デフォルトは@option{-fextern-tls-init}である。シンボルエイリアスを
サポートしていないターゲットでは、デフォルトは@option{-fno-extern-tls-init}である。

@item -fno-gnu-keywords
@opindex fno-gnu-keywords
@code{typeof}をキーワードとして認識せず、この語を識別子として使えるようにする。代わりにキーワード@code{__typeof__}を使うことができる。
このオプションは厳格なISO C++変種に含まれる。@option{-ansi}, @option{-std=c++98}, @option{-std=c++11}など。

@item -fno-implicit-templates
@opindex fno-implicit-templates
暗黙のうちに（すなわち、使うことで）実体化される非インラインテンプレートのコードを生成しない。明示的な実体化のみコードを生成する。このオプションを使用する場合は、リンク時に未定義のシンボルを取得しないように、必要なすべての明示的なインスタンス化を含めるようにコードを構造化する必要があります。
詳しい情報は@xref{Template Instantiation}。

@item -fno-implicit-inline-templates
@opindex fno-implicit-inline-templates
インラインテンプレートの暗黙の実体化のコードも生成しない。デフォルトはインラインを別に扱い、最適化の有無で明示的な実体化の必要な集合が変わらないようにする。

@item -fno-implement-inlines
@opindex fno-implement-inlines
空間を節約するために、@code{#pragma implementation}によって制御されるインライン関数の行外のコピーを生成しない。
これはもしそれらの関数が呼ばれた場所のどこでもインライン化されていないならばリンカエラーを起こすだろう。

@item -fmodules-ts
@itemx -fno-modules-ts
@opindex fmodules-ts
@opindex fno-modules-ts
C++20モジュール（@xref{C++ Modules}）のサポートを有効にします。 @option{-fno-modules-ts}はデフォルトであるため、通常は必要ありません。 これはC++20の機能ですが、現在、その標準バージョンを選択しても暗黙的に有効にはなりません。

@item -fmodule-header
@itemx -fmodule-header=user
@itemx -fmodule-header=system
@opindex fmodule-header
ヘッダーファイルをコンパイルして、インポート可能なヘッダーユニットを作成します。

@item -fmodule-implicit-inline
@opindex fmodule-implicit-inline
クラス定義で定義されたメンバー関数は、モジュラーコードに対して暗黙的にインラインではありません。 これは、正当な理由から、従来のC++の動作とは異なります。 ただし、コードの移植中に問題が発生する可能性があります。 このオプションは、そのような関数定義を暗黙的にインラインにします。 ただし、ABIの非互換性が発生するため、すべての場所で使うか、全く使わないようにする必要があります。（名前付きモジュールの外部にあるこのような定義は、関係なく、暗黙的にインラインのままです。）

@item -fno-module-lazy
@opindex fno-module-lazy
@opindex fmodule-lazy
遅延モジュールのインポートとモジュールマッパーの作成を無効にします。

@item -fmodule-mapper=@r{[}@var{hostname}@r{]}:@var{port}@r{[}?@var{ident}@r{]}
@itemx -fmodule-mapper=|@var{program}@r{[}?@var{ident}@r{]} @var{args...}
@itemx -fmodule-mapper==@var{socket}@r{[}?@var{ident}@r{]}
@itemx -fmodule-mapper=<>@r{[}@var{inout}@r{]}@r{[}?@var{ident}@r{]}
@itemx -fmodule-mapper=<@var{in}>@var{out}@r{[}?@var{ident}@r{]}
@itemx -fmodule-mapper=@var{file}@r{[}?@var{ident}@r{]}
@vindex CXX_MODULE_MAPPER @r{environment variable}
@opindex fmodule-mapper
モジュール名からファイル名へのマッピングを照会するオラクル。 指定されていない場合、@env{CXX_MODULE_MAPPER}環境変数が使用され、それが設定されていない場合、処理中のデフォルトが提供されます。

@item -fmodule-only
@opindex fmodule-only
コンパイル済みモジュールインターフェイスのみを発行し、オブジェクトファイルを禁止します。

@item -fms-extensions
@opindex fms-extensions
MFCで使われている、暗黙のintやメンバへのポインタを非標準の構文で得るような構造についての警告を無効にする。

@item -fnew-inheriting-ctors
@opindex fnew-inheriting-ctors
C++11コンストラクタ継承の意味に対してP0136の調整を有効にする。これはC++17の一部だが
C++11とC++14に対する欠陥レポートであるとも考えられる。このフラグは@option{-fabi-version=10}以下
が指定されない限りデフォルトである。

@item -fnew-ttp-matching
@opindex fnew-ttp-matching
Core issue150、テンプレートテンプレートパラメータとデフォルト引数へのP0522解決を有効にする。
これはデフォルトテンプレート引数のあるテンプレートをより少ないテンプレートパラメータでの
テンプレートテンプレートパラメータの引数としての使用を可能にする。このフラグは@option{-std=c++17}でデフォルトで
有効である。

@item -fno-nonansi-builtins
@opindex fno-nonansi-builtins
ANSI/ISO Cで義務付けられていない関数の組み込み宣言を無効にする。これは、@code{ffs}, @code{alloca}, @code{_exit}, @code{index}, @code{bzero},
@code{conjf}や他の関連した関数が含まれる。

@item -fnothrow-opt
@opindex fnothrow-opt
@code{throw()}例外指定を例外指定なしの関数に対してテキストサイズのオーバーヘッドの削減/除去のために@code{noexcept}指定をしたかのように扱う。
もし関数が自明でないデストラクタの型のローカル変数を持つならば、それの変数のEHクリーンアップは除去できるので、例外指定は実際に小さくなる。
意味論上の効果は例外指定のような関数の外で投げられた例外は@code{unexpected}ではなく@code{terminate}を呼ぶようになる。

@item -fno-operator-names
@opindex fno-operator-names
演算子名キーワード@code{and}, @code{bitand}, @code{bitor}, @code{compl}, @code{not}, @code{or}, @code{xor}を別名のキーワードして扱わない。

@item -fno-optional-diags
@opindex fno-optional-diags
標準がコンパイラが発行する必要が無いと言っている診断を無効にする。現在、G++によって発行されるそのような唯一の診断はクラス内で複数の意味を持つ名前
に関するものである。

@item -fpermissive
@opindex fpermissive
非準拠コードの幾つかの診断をエラーから警告に格下げする。したがって、@option{-fpermissive}を使うと幾つかの非準拠コードをコンパイルできるようになる。

@item -fno-pretty-templates
@opindex fno-pretty-templates
エラーメッセージが関数テンプレートの特殊化を参照するとき、コンパイラは通常どのテンプレートが関与しているかを明白にするために
テンプレート引数とシグネチャのtypedefか形名をテンプレートシグネチャの後ろに出力する。（例えば、@code{void f(int)}ではなく
@code{void f(T) [with T = int]}。エラーメッセージがクラステンプレートの特殊化を参照するとき、コンパイラはテンプレートのデフォルトテンプレート引数を
省略する。もしこれらの振る舞いがエラーメッセージを理解するのを易しくするのではなく、難しくしているときは、@option{-fno-pretty-templates}を使って
無効にすることができる。

@item -fno-rtti
@opindex fno-rtti
C++実行時型識別の機能(@code{dynamic_cast}と@code{typeid})で使うための仮想関数のある全クラスについての情報の出力を無効にする。
もし言語のこれらの機能を使わないならば、このフラグを使うことで空間を少し節約できる。例外の扱いも同じ情報を使うが、G++は必要に応じて
生成することに注意する。実行時型情報を使わないキャストでは@code{dynamic_cast}演算子はまだ使用可能である。すなわち、@code{void*}や
曖昧でない基底クラスへのキャスト。

@option{-frtti}でコンパイルされたコードと@option{-fno-rtti}でコンパイルされたコードを混在させることはできません。 たとえば、@option {-fno-rtti}でコンパイルされたクラスが@option{-frtti}でコンパイルされたクラスのベースとして使用されている場合、プログラムはリンクに失敗することがあります。

@item -fsized-deallocation
@opindex fsized-deallocation
C++14で導入される組み込みグローバル宣言
@smallexample
void operator delete (void *, std::size_t) noexcept;
void operator delete[] (void *, std::size_t) noexcept;
@end smallexample
を有効にする。これは、例えば、解放をより速くするためにオブジェクトのサイズを使うユーザ定義の置換解放関数に役立つ。
@option{-std=c++14}以上ではデフォルトで有効である。フラグ@option{-Wsized-deallocation}は定義を加えたいかもしれない場所について警告する。

@item -fstrict-enums
@opindex fstrict-enums
コンパイラが列挙型の値が（C++標準で定義されているように）列挙の値の一つのみだという仮定を使って最適化するのを許す。
（基本的には、可能な値はすべての列挙を表現できる最小のビット数で表現される。）
仮定はプログラムが任意の整数を列挙型に変換するためのキャストを使うならば正当でないかもしれない。

@item -fstrong-eval-order
@opindex fstrong-eval-order
C++17で採用されたとおり、メンバアクセス、配列の添字、シフト表現を左から右への順序で評価し、
代入文を右から左への順序で評価する。@option{-std=c++17}ではデフォルトで有効である。
@option{-fstrong-eval-order=some}はメンバアクセスとシフト表現の順序のみ有効にし、
@option{-std=c++17}なしでデフォルトである。

@item -ftemplate-backtrace-limit=@var{n}
@opindex ftemplate-backtrace-limit
単一の警告/エラーのテンプレート実体化注釈の最大値を設定する。デフォルト値は10である。

@item -ftemplate-depth=@var{n}
@opindex ftemplate-depth
テンプレートクラスの最大実体化の深さを@var{n}に設定する。テンプレート実体化の深さの制限はテンプレートクラス実体化の
無限再帰を検出するために必要である。ANSI/ISO C++に適合したプログラムは最大深さが17より多いことに依存してはならない。
(C++11では1024に変更された)。デフォルト値は900である。なぜならコンパイラはある状況では1024に到達する前にスタック空間を尽くしうるからだ。

@item -fno-threadsafe-statics
@opindex fno-threadsafe-statics
ローカル静的変数のスレッドセーフな初期化のC++ ABIで指定されたルーチンを使う追加のコードを生成しない。
このオプションをスレッドセーフにする必要が無いコードで少しコードサイズを削減するために使うことができる。

@item -fuse-cxa-atexit
@opindex fuse-cxa-atexit
静的領域のオブジェクトのデストラクタを@code{atexit}関数ではなく@code{__cxa_atexit}で登録する。このオプションは静的デストラクタの
完全に標準準拠の扱いに必要だが、Cライブラリが@code{__cxa_atexit}をサポートしている場合のみ働く。

@item -fno-use-cxa-get-exception-ptr
@opindex fno-use-cxa-get-exception-ptr
@code{__cxa_get_exception_ptr}ランタイムルーチンを使わない。これは@code{std::uncaught_exception}を正しくなくさせるが、
もしランタイムルーチンが利用できないならば必要である。

@item -fvisibility-inlines-hidden
@opindex fvisibility-inlines-hidden
このスイッチはユーザが２つの関数のアドレスが別の共有オブジェクトで取られるところで、
インライン関数やメソッドのポインタの比較をしようとしないと宣言する。

この効果はGCCが、事実上、インライン関数を@code{__attribute__ ((visibility ("hidden")))}とマークして、
DSOのエクスポートテーブルに現れないようにして。DSO内で使われた時にPLT間接を要求しないようにする。
このオプションを有効にするとライブラリがかなりのテンプレートを使っている時には動的エクスポートテーブルのサイズを大いに減らすので、
ロードとリンク時間に劇的な効果が有る。

このスイッチの振る舞いはメソッドに直接hiddenとマークするのと全く同じではない。なぜならそれは関数にローカルな静的変数には影響せず、
コンパイラに単一の共有オブジェクトで定義された関数を推測させるわけでもないからである。

メソッドをそのメソッドのスイッチの効果を反転させるのに明示的に可視性をマークしてもよい。例えば、特定のインラインメソッドへのポインタを比較したいならば、
デフォルトの可視性を持つようにマークするかもしれない。囲むクラスに明示的に可視性をマークしても効果はない。

明示的に実体化されたインラインメソッドは、リンケージが共有ライブラリの境界をまたぐかもしれないので、このオプションの効果はない。
@xref{Template Instantiation}.

@item -fvisibility-ms-compat
@opindex fvisibility-ms-compat
このフラグはGCCのC++リンケージモデルをMicrosoft Visual Studioのものと互換性を持たせるような可視性設定を使おうとする。

このフラグはGCCはリンケージモデルにこれらの変更を行う。

@enumerate
@item
デフォルトの可視性を、@option{-fvisibility=hidden}のように@code{hidden}にする。

@item
型は、メンバとは異なり、デフォルトでは隠されない。

@item
単一定義規則は複数の共有物で定められる明確な可視性仕様なしの型では緩和される。
このオプションが使われないときそれらが許されるならば、それらの宣言は許される。
@end enumerate

新しいコードは@option{-fvisibility=hidden}を使い、明示的に可視を意図するクラスをエクスポートした方がいい。
不幸にも、たぶん意図せずに、Visual Studioの振る舞いに依存するコードはありうる。

これらの変化の結果の間で、同じ名前で同じ型だが別の共有オブジェクトの静的データメンバは異なるので、
片方を変えても、もう片方は変わらない。そして異なる共有オブジェクトで定義された関数メンバへのポインタは
等しくないかもしれない。このフラグが与えられると、異なって同じ名前の型を定義するとODR違反となる。

@item -fno-weak
@opindex fno-weak
弱いシンボルをリンカが提供していても使わない。デフォルトでは、もし利用可能ならば弱いシンボルを使う。
これはテストのためだけに存在し。エンドユーザは使うべきではない。それは劣ったコードを引き起こし、利点はない。
このオプションは将来のG++のバージョンでは削除されるかもしれない。

@item -fext-numeric-literals @r{(C++とObjective-C++専用)}
@opindex fext-numeric-literals
@opindex fno-ext-numeric-literals
虚数、固定小数点、またはマシン定義のリテラル数サフィックスをGNU拡張機能として受け入れます。 このオプションをオフにすると、これらのサフィックスはC++11ユーザー定義のリテラル数値サフィックスとして扱われます。これは、C++11より前のすべての方言とすべてのGNU方言でデフォルトでオンになっています。すなわち、@option{-std=c++98}、@option{-std=gnu++98}、@option{-std=gnu++11}、@option{-std=gnu++14}。このオプションは、ISO C++11以降ではデフォルトでオフになっています（@option{-std=c++11}、...）。

@item -nostdinc++
@opindex nostdinc++
C++特有の標準ディレクトリでヘッダファイルを検索しないが、他の標準ディレクトリは検索する。（このオプションは
C++ライブラリをビルドするときに使う）

@item -flang-info-include-translate
@itemx -flang-info-include-translate-not
@itemx -flang-info-include-translate=@var{header}
@opindex flang-info-include-translate
@opindex flang-info-include-translate-not
診断に翻訳イベントを含めます。

@item -stdlib=@var{libstdc++,libc++}
@opindex stdlib
このオプションをサポートするようにG++が構成されている場合、代替のC++ランタイムライブラリを指定できます。 @var{libstdc++}（G++のデフォルトのネイティブC++ランタイム）と一部のオペレーティングシステム（Darwin11以降のDarwinバージョンなど）にインストールされているC++ランタイムである@var{libc++}の2つのオプションを使用できます。 このオプションは、リンクにC++ランタイムが必要な場合に、指定されたライブラリのヘッダーを使用し、それぞれ@code{-lstdc++}または@code{-lc++}を発行するようにG++を切り替えます。
@end table

加えて、これらの最適化、警告、コード生成オプションはC++プログラムでのみ意味を持つ。

@table @gcctabopt

@item -Wabi-tag @r{(C++とObjective-C++専用)}
@opindex Wabi-tag
@opindex -Wabi-tag
ABIタグを持たないコンテキストでABIタグが使われた型について警告する。
ABIタグについての情報は@ref{C++ Attributes}参照。

@item -Wcomma-subscript @r{(C++とObjective-C++専用)}
@opindex Wcomma-subscript
@opindex Wno-comma-subscript
添え字式内でのコンマ式の使用について警告します。
この使用法はC++20で廃止されました。 ただし、@code{())}でラップされたコンマ式は非推奨ではありません。 例：

@smallexample
@group
void f(int *a, int b, int c) @{
    a[b,c];     // deprecated
    a[(b,c)];   // OK
@}
@end group
@end smallexample

@option{-std=c++20}ではデフォルトで有効である。

@item -Wctad-maybe-unsupported @r{(C++とObjective-C++専用)}
@opindex Wctad-maybe-unsupported
@opindex Wno-ctad-maybe-unsupported
明示的に記述された推論ガイドがない型でクラステンプレート引数推論（CTAD）を実行するときに警告します。 この警告は、コンパイラーが暗黙の演繹ガイドを合成したためにのみCTADが成功した場合を示します。これは、プログラマーが意図したものではない可能性があります。 特定のスタイルガイドでは、特に「オプトイン」するタイプでのみCTADを許可しています。 つまり、CTADをサポートするように設計されたタイプ。 この警告は、次のパターンで抑制できます。

@smallexample
struct allow_ctad_t; // どんな名前でもいい
template <typename T> struct S @{
  S(T) @{ @}
@};
S(allow_ctad_t) -> S<void>; // 不完全パラメータ型のガイドは決して考慮されない
@end smallexample

@item -Wctor-dtor-privacy @r{(C++とObjective-C++専用)}
@opindex Wctor-dtor-privacy
@opindex Wno-ctor-dtor-privacy
そのクラスの全コンストラクタかデストラクタがprivateで、フレンドもpublicな静的メンバ関数もないために使用不可能に見えるときに警告する。
privateでないメソッドがあり、少なくとも1つコンストラクタでもデストラクタでもないprivateメンバ関数があるときにも警告する。

@item -Wdelete-non-virtual-dtor @r{(C++とObjective-C++専用)}
@opindex Wdelete-non-virtual-dtor
@opindex Wno-delete-non-virtual-dtor
@code{delete}が仮想関数と非仮想のデストラクタを持つクラスのインスタンスを破壊するために使われた時に警告する。もし基底クラスが仮想デストラクタを
持っていないなら、基底クラスへのポインタを通して派生クラスのインスタンスを削除するのは安全ではない。この警告は@option{-Wall}で有効になる。

@item -Wdeprecated-copy @r{(C++とObjective-C++専用)}
@opindex Wdeprecated-copy
@opindex Wno-deprecated-copy
C++11以降で、クラスにユーザー指定のコピーコンストラクターまたはコピー割り当て演算子がある場合、コピーコンストラクターまたはコピー割り当て演算子の暗黙的な宣言は廃止されることを警告します。 この警告は@option{-Wextra}によって有効にされます。 @option{-Wdeprecated-copy-dtor}を使用すると、クラスにユーザー指定のデストラクタがある場合も非推奨になります。

@item -Wno-deprecated-enum-enum-conversion @r{(C++とObjective-C++専用)}
@opindex Wdeprecated-enum-enum-conversion
@opindex Wno-deprecated-enum-enum-conversion
一方が列挙型でもう一方が異なる列挙型のオペランドに通常の算術変換が適用される場合の警告を無効にします。 この変換はC++20で非推奨になりました。例えば：

@smallexample
enum E1 @{ e @};
enum E2 @{ f @};
int k = f - e;
@end smallexample

@option{-Wdeprecated-enum-enum-conversion}は、@option{-std=c ++20}でデフォルトで有効になっています。 C++20より前の変種では、この警告は@option{-Wenum-conversion}によって有効にできます。

@item -Wno-deprecated-enum-float-conversion @r{(C++とObjective-C++専用)}
@opindex Wdeprecated-enum-float-conversion
@opindex Wno-deprecated-enum-float-conversion
一方が列挙型でもう一方が浮動小数点型のオペランドに通常の算術変換が適用される場合の警告を無効にします。 この変換はC++20で非推奨になりました。 例えば：

@smallexample
enum E1 @{ e @};
enum E2 @{ f @};
bool b = e <= 3.7;
@end smallexample

@option{-Wdeprecated-enum-float-conversion}は、@option{-std=c ++20}でデフォルトで有効になっています。 C++20より前の変種では、この警告は@option{-Wenum-conversion}によって有効にできます。

@item -Wno-init-list-lifetime @r{(C++とObjective-C++専用)}
@opindex Winit-list-lifetime
@opindex Wno-init-list-lifetime
@code{std::initializer_list}を使用して、ぶら下がりポインターになる可能性があるときに、警告しない。 @code{initializer_list}の基礎となる配列は通常のC++一時オブジェクトのように処理されるため、配列へのポインタを配列の有効期間の終了後も誤って保持するのは簡単です。 例えば：

@itemize @bullet
@item
関数が一時的な@code{initializer_list}またはローカルの@code{initializer_list}変数を返す場合、配列の有効期間はreturnステートメントの終わりで終了するため、返される値にはぶら下がりポインターがあります。

@item
new式が@code{initializer_list}を作成する場合、配列は囲まれた完全式の終わりまでしか存続しないため、ヒープ内の@code{initializer_list}にはぶら下がりポインターがあります。

@item
@code{initializer_list}変数が中括弧で囲まれた初期化子リストから代入されると、割り当ての右側に作成された一時配列は完全表現の最後までしか存続しないため、次のステートメントで@code{initializer_list}変数には、ぶら下がりポインターがあります。

@smallexample
// liの最初の基礎となる配列は、liと同じだけ長く存続します。
std::initializer_list<int> li = @{ 1,2,3 @};
// 代入はliを一時配列を指すように変更します。
li = @{ 4, 5 @};
// 今や一時値は消え、liはぶら下がりポインタです
int i = li.begin()[0] // 未定義の振る舞い
@end smallexample

@item
リストコンストラクターが@code{initializer_list}引数から@code{begin}ポインターを格納する場合、これは配列の寿命を延長しません。したがって、クラス変数が一時的な@code{initializer_list}から構築される場合、ポインター変数宣言文の終わりまでぶら下がります。

@end itemize


@item -Winvalid-imported-macros
@opindex Winvalid-imported-macros
@opindex Wno-invalid-imported-macros
インポートされたすべてのマクロ定義がコンパイルの最後に有効であることを確認します。 これは、決定するために追加の処理が必要になるため、デフォルトでは有効になっていません。 一貫性のあるマクロを確保するために、ヘッダーユニットのセットを準備するときに役立つ場合があります。

@item -Wno-literal-suffix @r{(C++とObjective-C++専用)}
@opindex Wliteral-suffix
@opindex Wno-literal-suffix
文字列または文字リテラルの後にアンダースコアで始まらないud-suffixが続く場合は警告しません。 準拠する拡張機能として、@code{<inttypes.h>}のフォーマットマクロを使用するコードとの下位互換性を維持するため、GCCはそのようなサフィックスを個別の前処理トークンとして扱います。例えば：

@smallexample
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <stdio.h>

int main() @{
  int64_t i64 = 123;
  printf("My int64: %" PRId64"\n", i64);
@}
@end smallexample

この場合、@code{PRId64}は別のプリプロセストークンとして扱われる。

さらに、ユーザ定義のリテラル演算子が、アンダースコアで始まらないリテラル接尾辞識別子で宣言されたときの警告も制御する。アンダースコアで始まらないリテラル接尾辞識別子は、将来の標準化のために予約されている。

この警告はデフォルトで有効である。

@item -Wno-narrowing @r{(C++とObjective-C++専用)}
@opindex Wnarrowing
@opindex Wno-narrowing
C++11以降の標準では、挟化変換は標準で要求される通り、デフォルトで診断される。
定数からの挟化変換はエラーを生成し、非定数からの挟化変換は警告を出すが、@option{-Wno-narrowing}は診断を抑制する。
これは正しく書かれたコードの意味に影響を与えない。挟化変換はSFIANE文脈ではまだ間違っていると判断される。

C++98では@option{-Wnarrowing}によって、C++11で@samp{@{ @}}内で禁止されている狭化変換について警告する。
例えば、

@smallexample
int i = @{ 2.2 @}; // error: narrowing from double to int
@end smallexample

このフラグは@option{-Wall}と@option{-Wc++11-compat}に含まれる。

@item -Wnoexcept @r{(C++とObjective-C++専用)}
@opindex Wnoexcept
@opindex Wno-noexcept
例外を投げない例外指定（すなわち、@code{throw()}か@code{noexcept}）を持たない関数を呼び出しているのでnoexcept式が偽と評価されるが、
コンパイラが決して例外を出さないと知っている時に警告する。

@item -Wnoexcept-type @r{(C++とObjective-C++専用)}
@opindex Wnoexcept-type
@opindex Wno-noexcept-type
関数型に@code{noexcept}部分が含まれるC++17の機能がC++14と比較してシンボルのマングル名を変えるなら警告する。
@option{-Wabi}と@option{-Wc++17-compat}で有効である。

例として：

@smallexample
template <class T> void f(T t) @{ t(); @};
void g() noexcept;
void h() @{ f(g); @}
@end smallexample

@noindent
C++14では、@code{f}は@code{f}@code{f<void(*)()>}を呼ぶが、C++17では、@code{f<void(*)()noexcept>}を呼ぶ。

@item -Wclass-memaccess @r{(C++とObjective-C++専用)}
@opindex Wclass-memaccess
@code{memset}や@code{memcpy}のような生のメモリ関数の呼び出し先がクラス型のオブジェクトで、そのようなオブジェクトへの書き込みがクラスの非自明な、または削除されたコンストラクタおよびコピー代入をバイパスするか、 constの正当性やカプセル化に違反するか、仮想テーブルポインタが壊れる可能性があるに警告する。 そのようなオブジェクトの表現を変更すると、そのクラスのメンバ関数によって維持される不変量に違反する可能性がある。 例えば、以下の@code{memset}への呼び出しは、自明ではないクラスオブジェクトを変更するため未定義で、診断される。 このような型のオブジェクトの記憶域を初期化またはクリアする安全な方法は、適切なコンストラクタまたは代入演算子が利用可能であればそれを使用することである。
@smallexample
std::string str = "abc";
memset (&str, 0, sizeof str);
@end smallexample
@option{-Wclass-memaccess}オプションは@option{-Wall}によって有効になる。明示的にクラスオブジェクトへのポインタを@code{void *}にキャストするか、生のメモリ関数によって安全にアクセスできる型にキャストすると警告が抑制される。

@item -Wnon-virtual-dtor @r{(C++とObjective-C++専用)}
@opindex Wnon-virtual-dtor
@opindex Wno-non-virtual-dtor
クラスが仮想関数を持ち、それ自身がアクセス可能な非仮想デストラクタを持つか、アクセス可能な多相基底クラスを持つ場合、
クラス自身かその基底クラスへのポインタを通して派生クラスのインスタンスを削除するのは可能だが安全でないために警告する。
この警告は@option{-Weffc++}が指定された時は自動的に有効になる。

@item -Wregister @r{(C++とObjective-C++専用)}
@opindex Wregister
@opindex Wno-register
GNU@ref{Explicit Register Variables}拡張の一部を除いて、@code{register}領域クラス指定子の使用について
警告する。領域クラス指定子としての@code{register}キーワードの使用はC++11で非推奨になりC++17では取り除かれた。
@option{-std=c++17}ではデフォルトで有効である。

@item -Wreorder @r{(C++とObjective-C++専用)}
@opindex Wreorder
@opindex Wno-reorder
@cindex reordering, warning
@cindex warning for reordering of member initializers
コード内で与えられたメンバ初期化子が実行される順番と一致しない時に警告する。例えば、

@smallexample
struct A @{
  int i;
  int j;
  A(): j (0), i (1) @{ @}
@};
@end smallexample

@noindent
コンパイラは@code{i}と@code{j}のメンバ初期化を並べ替えてメンバの宣言順に一致させ、その効果に対する警告を生成する。
この警告は@option{-Wall}で有効である。

@item -Wno-pessimizing-move @r{(C++とObjective-C++専用)}
@opindex Wpessimizing-move
@opindex Wno-pessimizing-move
この警告は、@code{std::move}の呼び出しがコピーの省略を防ぐときに警告します。 コピーの省略が発生する可能性がある典型的なシナリオは、クラスの戻り値の型で関数を返し、返される式が不揮発性の自動オブジェクトの名前であり、関数パラメーターではなく、 関数の戻り値の型であるときです。

@smallexample
struct T @{
@dots{}
@};
T fn()
@{
  T t;
  @dots{}
  return std::move (t);
@}
@end smallexample

しかし、この例では、@code{std::move}呼び出しはコピーの省略を防ぎます。

この警告は@option {-Wall}によって有効になります。

@item -Wno-redundant-move @r{(C++とObjective-C++専用)}
@opindex Wredundant-move
@opindex Wno-redundant-move
この警告は、@code{std::move}の冗長な呼び出しについて警告します。 つまり、@code{std::move}呼び出しがなくても移動操作が実行されていた場合です。 これは、コンパイラーが、コピー省略が適用できないローカル変数を返すなどの特定の状況で、オブジェクトを右辺値であるかのように処理することを強制されるために発生します。 以下を考えます：

@smallexample
struct T @{
@dots{}
@};
T fn(T t)
@{
  @dots{}
  return std::move (t);
@}
@end smallexample

ここでは、@code{std::move}呼び出しは冗長です。 G++はCore Issue 1579を実装しているためです。別の例は次のとおりです。

@smallexample
struct T @{ // convertible to U
@dots{}
@};
struct U @{
@dots{}
@};
U fn()
@{
  T t;
  @dots{}
  return std::move (t);
@}
@end smallexample
この例では、返される式のタイプと関数の戻りタイプが異なるため、コピー省略は適用できませんが、G++は戻り値を右辺値で指定されたものとして扱います。

この警告は@option{-Wextra}によって有効にされます。

@item -Wrange-loop-construct @r{(C++とObjective-C++専用)}
@opindex Wrange-loop-construct
@opindex Wno-range-loop-construct
この警告は、C++の範囲ベースのforループが不要なコピーを作成しているときに警告します。 これは、範囲宣言が参照ではないが、おそらく参照であるべき場合に発生する可能性があります。 例えば：

@smallexample
struct S @{ char arr[128]; @};
void fn () @{
  S arr[5];
  for (const auto x : arr) @{ @dots{} @}
@}
@end smallexample

コピーされる型が64バイト未満のサイズの簡単にコピー可能な型である場合は警告されません。

この警告は、範囲ベースのforループのループ変数が異なるタイプの値で初期化されてコピーが生成された場合にも警告します。 例えば：

@smallexample
void fn() @{
  int arr[10];
  for (const double &x : arr) @{ @dots{} @}
@}
@end smallexample

上記の例では、ループのすべての反復で、タイプ@code{double}の一時値が作成および破棄され、参照@code{const double&}がバインドされます。

この警告は@option{-Wall}によって有効になります。

@item -Wredundant-tags @r{(C++とObjective-C++専用)}
@opindex Wredundant-tags
@opindex Wno-redundant-tags
あいまいさを引き起こさずにキーを削除できるコンテキストで、クラス型と列挙型への参照で冗長なクラスキーと列挙キーについて警告します。 例えば：

@smallexample
struct foo;
struct foo *p;   // warn that keyword struct can be eliminated
@end smallexample

@noindent
一方、この例では警告はありません。

@smallexample
struct foo;
void foo ();   // "hides" struct foo
void bar (struct foo&);  // no warning, keyword struct is necessary
@end smallexample

@item -Wno-subobject-linkage @r{(C++とObjective-C++のみ)}
@opindex Wsubobject-linkage
@opindex Wno-subobject-linkage
クラスタイプが基底かフィールドがその型が匿名名前空間を使っているかリンケージのない型に依存している時に警告する。
もし型Aがリンケージなしか内部リンケージの型Bに依存している時、それを複数の翻訳空間で定義することはBの意味がそれぞれの翻訳単位で
異なるためにODR違反と違反になる。もしAが単一翻訳単位にしか現れないのであれば、警告を黙らせる最善の方法はそれも匿名名前空間において
内部リンケージを与えることである。コンパイラはメイン.Cファイルで定義された型には、複数の定義はありそうもないので、警告を与えない。
@option{-Wsubobject-linkage}はデフォルトで有効である。

@item -Weffc++ @r{(C++とObjective-C++専用)}
@opindex Weffc++
@opindex Wno-effc++
Scott Meyersの@cite{Effective C++}シリーズ本のスタイルガイドラインの違反について警告する。

@itemize @bullet
@item
動的に割り当てられるメモリのあるクラスのコピーコンストラクタと代入演算子を定義する。

@item
コンストラクタでは代入よりも初期化する。

@item
@code{operator=}は@code{*this}への参照を返す。

@item
オブジェクトを返さなければならないときに参照を返そうとするな。

@item
インクリメントとデクリメント演算子の前置と後置を区別せよ。

@item
@code{&&}, @code{||}, or @code{,}をオーバーロードするな。

@end itemize

このオプションはeffective C++の推奨のひとつでもある、@option{-Wnon-virtual-dtor}も有効にする。しかし、検査はアクセス可能な非多相基底クラスの仮想デストラクタの欠如にも警告する。

このオプションを選択した時は、標準ライブラリヘッダがすべてのガイドラインに従っているわけではないことに気をつけること。
@samp{grep -v}をそれらの警告を除外するのに使う。

@item -Wno-exceptions @r{(C++とObjective-C++専用)}
@opindex Wexceptions
@opindex Wno-exceptions
例外ハンドラーが別のハンドラーによってシャドウされている場合の警告を無効にします。これにより、例外ハンドラーの順序が間違っていることが指摘される可能性があります。

@item -Wstrict-null-sentinel @r{(C++とObjective-C++専用)}
@opindex Wstrict-null-sentinel
@opindex Wno-strict-null-sentinel
キャストなしの@code{NULL}を標識として使うことを警告する。@code{NULL}は@code{__null}と定義されているので、
GCCでコンパイルするときだけ有効化標識である。これはヌルポインタではなくヌルポインタ定数であるが、それはポインタと同じサイズ
であることが保証されている。しかしこれは他のコンパイラに対しては移植性がない。

@item -Wno-non-template-friend @r{(C++とObjective-C++専用)}
@opindex Wno-non-template-friend
@opindex Wnon-template-friend
非テンプレート化されたフレンド関数がテンプレート内で宣言された時の警告を無効にする。
ISO標準以前の実装である非常に古いバージョンのGCCは@samp{friend foo(int)}のような宣言で、フレンドの名前が非修飾識別子
であるならば、それはテンプレート関数の部分特殊化として解釈し得た。互換性の問題を診断する警告が存在し、デフォルトで有効である。

@item -Wold-style-cast @r{(C++とObjective-C++専用)}
@opindex Wold-style-cast
@opindex Wno-old-style-cast
もし非void型への旧式（C方式）のキャストがC++プログラムにあったら警告する。新式のキャスト(@code{dynamic_cast}, @code{static_cast},
@code{reinterpret_cast}, @code{const_cast})は意図しない効果を受けにくく、検索がずっとしやすい。

@item -Woverloaded-virtual @r{(C++とObjective-C++専用)}
@opindex Woverloaded-virtual
@opindex Wno-overloaded-virtual
@cindex overloaded virtual function, warning
@cindex warning for overloaded virtual function
基底クラスからの仮想関数を関数宣言が隠すときに警告する。例えば、

@smallexample
struct A @{
  virtual void f();
@};

struct B: public A @{
  void f(int);
@};
@end smallexample

は@code{f}の@code{A}クラスバージョンが@code{B}のものを隠し、以下のコードは

@smallexample
B* b;
b->f();
@end smallexample

@noindent
はコンパイルできない。

@item -Wno-pmf-conversions @r{(C++とObjective-C++専用)}
@opindex Wno-pmf-conversions
@opindex Wpmf-conversions
メンバ関数への結合ポインタから通常のポインタへの変換についての診断を無効にする。

@item -Wsign-promo @r{(C++とObjective-C++専用)}
@opindex Wsign-promo
@opindex Wno-sign-promo
オーバーロードの解決が符号なし・列挙から符号ありの型への格上げか、同じサイズの符号なし型への変換を選択するときに警告する。
前のバージョンのG++は符号性を維持しようとしたが、標準は現在の振る舞いを要求する。

@item -Wtemplates @r{(C++とObjective-C++専用)}
@opindex Wtemplates
主要テンプレート宣言に出会った時に警告する。あるコードルールはテンプレートを許さず、
これはその規則を強制させるために使うことができる。STLのようなシステムヘッダ内ではこの警告は効力がないため、
まだSTLは使用可能である。テンプレートの実体化や特殊化をしてもよい。

@item -Wno-mismatched-new-delete @r{(C++とObjective-C++専用)}
@opindex Wmismatched-new-delete
@opindex Wno-mismatched-new-delete
@code{operator new}または@code{operator delete}の呼び出しと、対応する割り当てまたは割り当て解除関数の呼び出しとの不一致について警告します。 これには、C++ @code{operator delete}の呼び出しと、不一致の形式の@code{operator new}から、または@code{operator delete}が適切なデロケーターではないオブジェクトを割り当てる他の関数から返されたポインターが含まれます。 また、@code{operator new}から返されたポインタを使用して、割り当て解除関数が適していない他の割り当て解除関数を呼び出します。

たとえば、以下の関数の@code delete}式は、ポインタ引数が返された@code{new}式の配列形式と一致しないために診断されます。 同様に、@ code{free}の呼び出しも診断されます。

@smallexample
void f ()
@{
  int *a = new int[n];
  delete a;   // warning: mismatch in array forms of expressions

  char *p = new char[n];
  free (p);   // warning: mismatch between new and free
@}
@end smallexample

関連するオプション@option{-Wmismatched-dealloc}は、@code{operator new}および@code{operator delete}以外の割り当ておよび割り当て解除関数に関連する不一致を診断します。

@option{-Wmismatched-new-delete}はデフォルトで有効になっています。

@item -Wmismatched-tags @r{(C++とObjective-C++専用)}
@opindex Wmismatched-tags
@opindex Wno-mismatched-tags
構造体、クラス、およびクラステンプレートの宣言とそれらの特殊化について、定義が提供されていない場合は定義または最初の宣言のいずれにも一致しないクラスキーを使用して警告します。

たとえば、@code{draw}の引数リストで@code{struct Object}を宣言すると、警告がトリガーされます。 これを回避するには、冗長なクラスキー@code{struct}を削除するか、@code{class}に置き換えて、その定義と一致させます。
@smallexample
class Object @{
public:
  virtual ~Object () = 0;
@};
void draw (struct Object*);
@end smallexample

上記の例が示すように、クラスキー@code{struct}でクラスを宣言することは間違いありません。 @option{-Wmismatched-tags}オプションは、一貫したスタイルのクラス宣言を実現するのに役立つことを目的としています。 Windowsベースのコンパイラへの移植を意図したコードでは、警告は、異なるクラスキーで宣言されたシンボルのマングリングの違いによる未解決の参照を防ぐのに役立ちます。 オプションは、単独で、または@option{-Wredundant-tags}と組み合わせて使用できます。

@item -Wmultiple-inheritance @r{(C++とObjective-C++専用)}
@opindex Wmultiple-inheritance
クラスが複数の直接基底クラスで定義されたときに警告する。あるコードルールは多重継承を禁止していて、これはそのルールを
強制するのに使うことができる。この警告はSTLのようなシステムヘッダファイルでは効力がないため、
STLはまだ使用可能である。間接的に多重継承しているクラスも定義できる。

@item -Wvirtual-inheritance
@opindex Wvirtual-inheritance
クラスが仮想の直接基底クラスで定義されていると警告する。あるコードルールは多重継承を禁止していて、これはそのルールを
強制するのに使うことができる。この警告はSTLのようなシステムヘッダファイルでは効力がないため、
STLはまだ使用可能である。間接的に仮想継承を使っているクラスも定義できる。

@item -Wno-virtual-move-assign
@opindex Wvirtual-move-assign
@opindex Wno-virtual-move-assign
非自明なC++11移動代入演算子を使用して仮想ベースから継承することに関する警告を抑制します。 仮想ベースが複数のパスに沿って到達可能である場合、仮想ベースが複数回移動されるため、両方のオブジェクトが移動元の状態になる可能性があるため、これは危険です。 移動元オブジェクトからの移動を回避するように割り当て割り当て演算子が記述されている場合、この警告を無効にすることができます。

@item -Wnamespaces
@opindex Wnamespaces
名前空間定義が開かれていると警告する。あるコードルールは名前空間を禁止していて、これはそのルールを
強制するのに使うことができる。この警告はSTLのようなシステムヘッダファイルでは効力がないため、
STLはまだ使用可能である。間接的に仮想継承を使っているクラスも定義できる。usingディレクティブと
修飾名も利用可能である。

@item -Wno-terminate @r{(C++とObjective-C++専用)}
@opindex Wterminate
@opindex Wno-terminate
@code{terminate}を直ちに呼ぶことになるthrows式について警告を無効化する。

@item -Wno-vexing-parse @r{(C++とObjective-C++専用)}
@opindex Wvexing-parse
@opindex Wno-vexing-parse
最も厄介な解析構文のあいまいさについて警告します。 これは、宣言が変数定義のように見えるが、C++言語では関数宣言として解釈する必要がある場合について警告します。 例えば：

@smallexample
void f(double a) @{
  int i();        // extern int i (void);
  int n(int(a));  // extern int n (int);
@}
@end smallexample

もう一つの例：

@smallexample
struct S @{ S(int); @};
void f(double a) @{
  S x(int(a));   // extern struct S x (int);
  S y(int());    // extern struct S y (int (*) (void));
  S z();         // extern struct S z (void);
@}
@end smallexample

警告は、そのようなあいまいさに対処する方法のオプションを提案します。 たとえば、かっこを削除するか、代わりに中かっこを使用することを提案できます。

この警告はデフォルトで有効になっています。

@item -Wno-class-conversion @r{(C++とObjective-C++専用)}
@opindex Wno-class-conversion
@opindex Wclass-conversion
変換関数がオブジェクトを同じ型、その型の基本クラス、またはvoidに変換する場合の警告を無効にします。 このような変換関数は呼び出されません。

@item -Wvolatile @r{(C++とObjective-C++専用)}
@opindex Wvolatile
@opindex Wno-volatile
@code{volatile}修飾子の廃止予定の使用について警告します。 これには、@code{volatile}修飾された型の前置・後置の@code{++}、@code{--}表現、左オペランドが@code{volatile}修飾された非クラス型の値である単純な代入、左オペランドが@code{volatile}修飾された非クラス型である複合代入、@code{volatile}修飾された関数戻り値型、@code{volatile}修飾されたパラメーター型、および@code{volatile}修飾型の構造化バインディングである複合代入。 この使用法はC++20で廃止されました。

@option{-std=c++20}でデフォルトで有効になります。

@item -Wzero-as-null-pointer-constant @r{(C++とObjective-C++専用)}
@opindex Wzero-as-null-pointer-constant
@opindex Wno-zero-as-null-pointer-constant
リテラル@samp{0}がnullポインタ定数として使用されている場合に警告します。 これは、C++11で@code{nullptr}への変換を容易にするのに役立ちます。

@item -Waligned-new
@opindex Waligned-new
@opindex Wno-aligned-new
@code{alignof(std::max_align_t)}よりも大きいアライメントが必要であるが、明示的なアライメントパラメータなしの割り当て関数を使用するタイプの新しい式について警告します。 このオプションは、@option{-Wall}によって有効になります。

通常、これはグローバル割り当て関数についてのみ警告しますが、
@option{-Waligned-new=all}は、クラスメンバーの割り当て関数についても警告します。

@item -Wno-placement-new
@itemx -Wplacement-new=@var{n}
@opindex Wplacement-new
@opindex Wno-placement-new
オブジェクトのタイプよりも小さいバッファ内にオブジェクトを作成するなど、未定義の動作を伴う配置new式について警告します。 たとえば、以下の配置new式は、64バイトの大きさのバッファーで64の整数の配列を構築しようとするため、診断されます。
@smallexample
char buf [64];
new (buf) int[64];
@end smallexample
この警告はデフォルトで有効になっています。

@table @gcctabopt
@item -Wplacement-new=1
これは、@option{-Wplacement-new}のデフォルトの警告レベルです。 このレベルでは、GCCがレガシーコードとの互換性のための拡張機能として許可している一部の厳密に定義されていない構成に対して警告は発行されません。 たとえば、次の@code{new}式は、1要素配列の終わりを超えて書き込むため、C++標準に従って未定義の動作があっても、このレベルでは診断されません。
@smallexample
struct S @{ int n, a[1]; @};
S *s = (S *)malloc (sizeof *s + 31 * sizeof s->a[0]);
new (s->a)int [32]();
@end smallexample

@item -Wplacement-new=2
このレベルでは、レベル1と同じすべての構成を診断することに加えて、構造が最後のメンバーにオブジェクトを構成する構築されるオブジェクトのサイズよりも大きいnew式を配置するための診断が発行されます。 前の例は診断されますが、次の構成ではレベル2での警告を回避するために柔軟なメンバー配列拡張を利用します。
@smallexample
struct S @{ int n, a[]; @};
S *s = (S *)malloc (sizeof *s + 32 * sizeof s->a[0]);
new (s->a)int [32]();
@end smallexample

@end table

@item -Wcatch-value
@itemx -Wcatch-value=@var{n} @r{(C++とObjective-C++専用)}
@opindex Wcatch-value
@opindex Wno-catch-value
参照を介してキャッチしないキャッチハンドラについて警告します。 @option{-Wcatch-value=1}（または略して@option{-Wcatch-value}）を使用すると、値によってキャッチされるポリモーフィッククラスタイプについて警告します。 @option{-Wcatch-value=2}を使用すると、値によってキャッチされるすべてのクラスタイプについて警告します。 @option{-Wcatch-value=3}を使用すると、参照によってキャッチされないすべてのタイプについて警告します。 @option{-Wcatch-value}は@option {-Wall}によって有効になります。

@item -Wconditionally-supported @r{(C++とObjective-C++専用)}
@opindex Wconditionally-supported
@opindex Wno-conditionally-supported
条件付きでサポートされている（C++11 [intro.defs]）構成について警告します。

@item -Wno-delete-incomplete @r{(C++とObjective-C++専用)}
@opindex Wdelete-incomplete
@opindex Wno-delete-incomplete
不完全な型へのポインタを削除するときに警告しない。実行時に未定義の動作を引き起こす可能性があります。 この警告はデフォルトで有効になっています。

@item -Wextra-semi @r{(C++, Objective-C++専用)}
@opindex Wextra-semi
@opindex Wno-extra-semi
クラス内の関数定義の後に、セミコロンの重複について警告します。

@item -Wno-inaccessible-base @r{(C++, Objective-C++専用)}
@opindex Winaccessible-base
@opindex Wno-inaccessible-base
このオプションは、あいまいさのために基本クラスから派生したクラスで基本クラスにアクセスできない場合の警告を制御します。 警告はデフォルトで有効になっています。 あいまいな仮想ベースの警告は、@option{-Wextra}オプションによって有効になることに注意してください。
@smallexample
@group
struct A @{ int a; @};

struct B : A @{ @};

struct C : B, A @{ @};
@end group
@end smallexample

@item -Wno-inherited-variadic-ctor
@opindex Winherited-variadic-ctor
@opindex Wno-inherited-variadic-ctor
継承元の基本クラスにC可変引数コンストラクタがある場合のC++11継承コンストラクタの使用に関する警告を抑制します。 省略記号は継承されないため、警告はデフォルトでオンになっています。

@item -Wno-invalid-offsetof @r{(C++とObjective-C++専用)}
@opindex Wno-invalid-offsetof
@opindex Winvalid-offsetof
@code{offsetof}マクロを非PODタイプに適用することによる警告を抑制します。 2014 ISO C++標準によれば、非標準レイアウトタイプに@code{offsetof}を適用することは定義されていません。 ただし、既存のC++実装では、@code{offsetof}は通常、意味のある結果をもたらします。 このフラグは、移植性のないコードを作成していることを認識しており、意図的にそれに関する警告を無視することを選択したユーザー向けです。

@code{offsetof}の制限は、C++標準の将来のバージョンで緩和される可能性があります。

@item -Wsized-deallocation @r{(C++とObjective-C++専用)}
@opindex Wsized-deallocation
@opindex Wno-sized-deallocation
以下のような対応するサイズの割り当て解除関数の定義のない、
@smallexample
void operator delete (void *, std::size_t) noexcept;
void operator delete[] (void *, std::size_t) noexcept;
@end smallexample
サイズなしの割り当て解除関数の定義
@smallexample
void operator delete (void *) noexcept;
void operator delete[] (void *) noexcept;
@end smallexample
もしくはその逆について警告する。@option{-Wextra}と@option{-fsized-deallocation}によって有効化されます。

@item -Wsuggest-final-types
@opindex Wno-suggest-final-types
@opindex Wsuggest-final-types
型がC++ 11@code{final}指定子で宣言された場合、または可能であれば匿名名前空間で宣言された場合にコード品質が向上する仮想メソッドを持つ型について警告します。 これにより、GCCはポリモーフィックな呼び出しをより積極的に仮想化解除できます。 この警告は、クラス階層グラフに関する情報がより完全なリンク時最適化でより効果的です。

@item -Wsuggest-final-methods
@opindex Wno-suggest-final-methods
@opindex Wsuggest-final-methods
メソッドがC++ 11@code{final}指定子で宣言された場合、または、可能であれば、その型は匿名の名前空間または@code{final}指定子で宣言されていた場合にコード品質が向上する仮想メソッドについて警告します。この警告は、クラス階層グラフに関する情報がより完全なリンク時最適化でより効果的です。 最初に@option{-Wsuggest-final-types}の提案を検討してから、新しい注釈で再構築することをお勧めします。

@item -Wsuggest-override
@opindex Wsuggest-override
@opindex Wno-suggest-override
@code{override}キーワードでマークされていない仮想関数のオーバーライドについて警告します。

@item -Wuseless-cast @r{(C++とObjective-C++専用)}
@opindex Wuseless-cast
@opindex Wno-useless-cast
式が自分自身の型にキャストされたときに警告します。

@item -Wno-conversion-null @r{(C++とObjective-C++専用)}
@opindex Wconversion-null
@opindex Wno-conversion-null
@code{NULL}と非ポインタ型の間の変換について警告しません。 @option{-Wconversion-null}はデフォルトで有効になっています。

@end table

@node Objective-C and Objective-C++ Dialect Options
@section Objective-CとObjective-C++変種を制御するオプション

@cindex compiler options, Objective-C and Objective-C++
@cindex Objective-C and Objective-C++ options, command-line
@cindex options, Objective-C and Objective-C++
(注意：このマニュアルはObjective-CとObjective-C++言語自身は説明していない。参照は
@xref{Standards,,GCCによってサポートされている言語標準})

この節はObjective-CとObjective-C++プログラムでのみ意味を持つコマンドラインオプションを説明する。
言語非依存のGNUコンパイラオプションのほとんども使用可能である。
例えば、@file{some_Class.m}を次のようにコンパイルするかもしれない。

@smallexample
gcc -g -fgnu-runtime -O -c some_class.m
@end smallexample

@noindent
この例では、@option{-fgnu-runtime}はObjective-CとObjective-C++プログラムでのみ意味をを持つ
オプションである。GCCでサポートされているどんな言語でもサポートされている他のオプションを使うことができる。

Objective-CがC言語の拡張なので、Objective-CのコンパイルはCフロントエンド特有の（例えば、@option{-Wtraditional}）オプション
も使うことができる。ことに注意する。同様に、Objective-C++コンパイルはC++と特有のオプション（例えば、@option{-Wabi}を使うことができる。

ここにObjective-CとObjective-C++プログラム@emph{専用}のオプションのリストがある。

@table @gcctabopt
@item -fconstant-string-class=@var{class-name}
@opindex fconstant-string-class
構文@code{@@"@dots{}"}で指定されたそれぞれの文字列定数を実体化するクラス名を@var{class-name}で指定する。
デフォルト名はGNUランタイムが使われたときは@code{NXConstantString}で、NeXTランタイムが使われた時は（下を見よ）
@code{NSConstantString}である。@option{-fconstant-cfstrings}オプションが、もし存在したら、
@option{-fconstant-string-class}設定を上書きして@code{@@"@dots{}"}定数が定数CoreFoundation文字列として展開する。

@item -fgnu-runtime
@opindex fgnu-runtime
標準GNU Objective-Cランタイムと互換性のあるオブジェクトコードを生成する。これはたいていのタイプのシステムで
デフォルトである。

@item -fnext-runtime
@opindex fnext-runtime
NeXTランタイムと互換性のある出力を生成する。これはDawrinとMac OS Xを含めた、NeXTベースのシステムでデフォルトである。
マクロ@code{__NEXT_RUNTIME__}がこのオプションが使われた（ときだけ）事前に定義される。

@item -fno-nil-receivers
@opindex fno-nil-receivers
この翻訳単位のすべてのObjective-Cメッセージディスパッチ(@code{[receiver message:arg]})でレシーバーが
@code{nil}でないことを確かめる。これはランタイムでのもっと効率的なエントリポインタが使われることを可能にする。
このオプションはNeXTランタイムでABIのバージョンが0か1の時のみ利用可能である。

@item -fobjc-abi-version=@var{n}
@opindex fobjc-abi-version
選択されたランタイムのObjective-C ABIのバージョン@var{n}を使う。これは現在NeXTランタイムでのみ
サポートされている。この場合、バージョン0は伝統的な(32ビットの)ABIでプロパティと他のObjective-C 2.0の追加をサポートしない。
バージョン1は伝統的な(32ビットの)ABIでプロパティと他のObjective-C 2.0の追加をサポートする。
バージョン2は現代の(64ビット)ABIである。もし何も指定されない時は、32ビットのターゲットの機種ではバージョン0で、
64ビットのターゲットの機種ではバージョン2である。

@item -fobjc-call-cxx-cdtors
@opindex fobjc-call-cxx-cdtors
それぞれのObjective-Cクラスで、そのインスタンス変数が自明でないデフォルトコンストラクタを持つC++オブジェクトかどうかをチェックする。
もしそうならば、そのようなインスタンス変数の非自明のデフォルトコンストラクタを、順番に呼んで、@code{self}を返す
特別な@code{- (id) .cxx_construct}インスタンスメソッドを合成する。同様に、もしインスタンス変数が非自明なデストラクタを持つC++オブジェクトならば、
そのような全デフォルトコンストラクタを逆順で呼ぶ特別な@code{- (void) .cxx_destruct}を合成する。

現在のObjective-Cクラスで宣言されるインスタンス変数にのみ、このように生成される@code{- (id) .cxx_construct}と@code{- (void) .cxx_destruct}メソッドは
作用し、上位クラスからは継承されない。オブジェクトの継承階層ですべてのそのようなメソッドを実行することは、Objective-Cランタイムの責任である。
@code{- (id) .cxx_construct}メソッドは、新しいオブジェクト例が割り当てられた直後にランタイムによって実行される。
ランタイムがオブジェクトインスタンスの割当てを解放する直前に@code{- (void) .cxx_destruct}メソッドは実行される。

これを書いている時点では、Mac OS X 10.4以降のNeXTランタイムでのみ@code{- (id) .cxx_construct}と@code{- (void) .cxx_destruct}メソッドの実行をサポートする。

@item -fobjc-direct-dispatch
@opindex fobjc-direct-dispatch
メッセージ分岐の高速ジャンプを許可する。Darwinではこれはcommページ経由で達成される。

@item -fobjc-exceptions
@opindex fobjc-exceptions
C++で提供されるものと同様の、Objective-Cでの構造化例外処理の構文サポートを有効にする。これはObjective-Cキーワード@code{@@try}, 
@code{@@throw}, @code{@@catch}, @code{@@finally}, @code{@@synchronized}の使用が要求される。このオプションはGNUランタイムと
NeXTランタイム（しかしNeXTランタイムのMac OS X 10.2以前では利用できない）の両方で利用可能である。

@item -fobjc-gc
@opindex fobjc-gc
Objective-CとObjective-C++プログラムのガベージコレクション(GC)を有効にする。このオプションはNeXTランタイムでのみ利用可能である。
GNUランタイムは特別なコンパイラフラグを必要としない別のガベージコレクション実装を持っていてる。

@item -fobjc-nilcheck
@opindex fobjc-nilcheck
ABIのバージョン2のNeXTランタイムで、実際のメソッド呼び出しを行う前にメソッド呼び出しのレシーバーがnilかをチェックする。
これはデフォルトであり、@option{-fno-objc-nilcheck}を使って無効にできる。
クラスメソッドとsuper呼び出しはこのフラグをセットしたかにかかわらずnilのチェックは決して行われない。
現在このフラグはGNUランタイムや、NeXTランタイムABIの古いバージョンでは何もしない。

@item -fobjc-std=objc1
@opindex fobjc-std
GCC 4.0で認識される言語、Objective-C 1.0の言語構文に従う。これは、C/C++言語へのObjective-C追加に影響を及ぼすだけである。
それはC/C++標準に適合に影響を及ぼさない。そして、それは別々のC/C++変種選択フラグによって制御される。
このオプションがObjective-CまたはObjective-C++コンパイラで使われるとき、GCC 4.0によって認識されないどんなObjective-C構文でも拒絶される。
あなたがあなたのObjective-CコードがGCCの以前の
バージョンでコンパイルされることができることを確認する必要があるならば、これは役に立つ。

@item -freplace-objc-classes
@opindex freplace-objc-classes
@command{ld(1)}に結果のオブジェクト・ファイルで静的にリンクしないように指示している特別な目印を発し、
@command{dyld(1)}がその代わりに実行時でそれを中にロードするのを許す。
修正して実行デバッグモード（問題のオブジェクト・ファイルは再コンパイルされ、プログラム実行の間に動的に再ロードされるかもしれない）とともに、これが、プログラムそのものを再開する必要なしで使われる。
現在では、修正して実行機能は、Mac OS X 10.3以降のNeXTランタイムでのみ利用可能である。

@item -fzero-link
@opindex fzero-link
NeXTランタイムでコンパイルしているとき、コンパイラは@code{objc_getClass("@dots{}")}への呼び出しを、
（クラスの名前がコンパイル時に知られているとき）に、ロード時間に初期化される静的クラス引用に通常置き換える。
そして、それは実行時パフォーマンスを向上させる。@option{-fzero-link}フラグを指定することはこのふるまいを抑えて、
@code{objc_getClass("@dots{}")}への呼び出しが保持されるようにする。
個々のクラスの実装がプログラム実行中に修正されるのをそれが許すので、ゼロリンク・デバッギング・モードに役立つ。
コマンド・ライン・オプションに関係なく、GNUランタイムは@code{objc_get_class("@dots{}")}に呼び出しを現在常に保持する。

@item -fno-local-ivars
@opindex fno-local-ivars
@opindex flocal-ivars
デフォルトではObjective=Cでのインスタンス変数はそれらが宣言されているクラスのメソッド内でローカス変数が宣言されているかのように
アクセス可能である。これはインスタンス変数と同じ名前でクラスメソッド内にローカルに宣言されたか、グローバルに宣言された他の変数を隠す。
@option{-fno-local-ivars}フラグを指定するとこの振る舞いを無効にして変数を隠す問題を避ける。

@item -fivar-visibility=@r{[}public@r{|}protected@r{|}private@r{|}package@r{]}
@opindex fivar-visibility
デフォルトインスタンス変数可視性を指定されたオプションにセットして、アクセス指定ディレクティブのスコープの外側で宣言されたインスタンス変数
がデフォルトで指定された可視性を持つようにする。

@item -gen-decls
@opindex gen-decls
名前@file{@var{sourcename}.decl}という名前のファイルへソースファイルで見られる全クラスのインターフェース定義をダンプする。

@item -Wassign-intercept @r{(Objective-CとObjective-C++専用)}
@opindex Wassign-intercept
@opindex Wno-assign-intercept
Objective-C代入がガベージコレクタで妨害される時には警告する。

@item -Wno-property-assign-default @r{(Objective-CとObjective-C++専用)}
@opindex Wproperty-assign-default
@opindex Wno-property-assign-default
Objective-Cオブジェクトのプロパティに割り当てセマンティクスが指定されていない場合は警告しません。

@item -Wno-protocol @r{(Objective-CとObjective-C++専用)}
@opindex Wno-protocol
@opindex Wprotocol
クラスがプロトコルを実行すると宣言されるならば、警告はクラスによって実装されないプロトコルにおいて、メソッドごとに発される。
たとえメソッド実装がスーパークラスから継承されるとしても、デフォルトの振る舞いはクラスで明示的に実装されないあらゆるメソッドの警告を発することになっている。
あなたが@option{-Wno-protocol}オプションを使用するならば、スーパークラスから継承されるメソッドは実装されると考えられる、そして、警告はそれらのために発されない。

@item -Wobjc-root-class @r{(Objective-CとObjective-C++専用)}
@opindex Wobjc-root-class
クラスインターフェイスにスーパークラスがない場合に警告します。 ほとんどのクラスは、たとえば@code{NSObject}（または@code{Object}）から継承します。 ルートクラスを意図したクラスを宣言する場合、インターフェースを@code{__attribute__((objc_root_class))}でマークすることにより、警告を抑制できます。

@item -Wselector @r{(Objective-CとObjective-C++専用)}
@opindex Wselector
@opindex Wno-selector
同じセレクタの異なるタイプの複数のメソッドがコンパイルで見つかるならば警告する。
チェックは、コンパイルの最後の段階にメソッドのリストで実行される。
その上、@code{@@selector(@dots{})}表現において現れている各々のセレクタと、コンパイルの間に見つかったそのセレクタの対応するメソッドでチェックは実行される。
これらのチェックがコンパイル終了後だけメソッド・テーブルを探査するので、コンパイルの最後の段階に達しない（たとえばエラーがコンパイル中に見つかるか、@option{-fsyntax-only}オプションが使われている）ならば、これらの警告は出されない。

@item -Wstrict-selector-match @r{(Objective-CとObjective-C++専用)}
@opindex Wstrict-selector-match
@opindex Wno-strict-selector-match
型@code{id}または@code{Class}のレシーバへこのセレクタを使ってメッセージを送ろうとするとき、異なっている引数による複数のメソッドや戻りタイプが与えられたセレクタのために見つかったら警告する。このフラグがオフである（デフォルトふるまいである）とき、見つかる違いが同じサイズと調整を共有するタイプに限定されるならば、コンパイラはそのような警告を省略する。

@item -Wundeclared-selector @r{(Objective-CとObjective-C++専用)}
@opindex Wundeclared-selector
@opindex Wno-undeclared-selector
もし未宣言のセレクタを参照する@code{@@selector(@dots{})}表現が見つかったら警告する。
セレクタは明示的に@code{@@interface}か@code{@@protocol}宣言でか、暗黙に@code{@@implementation}
セクションの中で、@code{@@selector(@dots{})}表現の前に宣言された名前を持つメソッドがないならば未宣言とみなされる。
このオプションは常に@code{@@selector(@dots{})}が見つかるとすぐにチェックを実行するが、
@option{-Wselector}はチェックをコンパイルの最後の段階でしか実行しない。これはメソッドとセレクタが使われる前に宣言されなければならないという
コードスタイル規約を強制することもする。

@item -print-objc-runtime-info
@opindex print-objc-runtime-info
もしあれば、値で渡された最大の構造を描写するCヘッダを生成する。

@end table

@node Diagnostic Message Formatting Options
@section 診断メッセージの書式を制御するオプション
@cindex options to control diagnostics formatting
@cindex diagnostic messages
@cindex message formatting

伝統的に、診断メッセージは、出力装置の状況（例えばその幅@dots{}）にかかわりなく書式を設定された。
あなたは、例えば、診断メッセージのためにフォーマット化しているアルゴリズムを制御するために以下に記すオプションを使用することができる：
行当たりの文字数、ソース情報をどのぐらい頻繁に報告すべきか。
ある言語フロントエンドがこれらのオプションを守らないかもしれないことに注意すべきである。

@table @gcctabopt
@item -fmessage-length=@var{n}
@opindex fmessage-length
エラーメッセージを行あたり@var{n}文字ぐらいで収めようとする。もし、@var{n}が0ならば、
行送り返しは行われない。それぞれのエラーメッセージは1行で現れる。これは全フロントエンドのデフォルトである。

注-このオプションは、@samp{#error}および@samp{#warning}プリプロセッサディレクティブ、および@samp{deprecated} 関数/型/変数属性の表示にも影響します。 ただし、@samp{pragma GCC warning}および@samp{pragma GCC error}プラグマには影響しません。

@item -fdiagnostics-plain-output
このオプションは、診断出力ができるだけ単純になるように要求します。これは、@command{dejagnu}または診断出力を解析する必要があり、時間の経過とともに安定性を維持する必要があるその他のユーティリティを実行する場合に役立ちます。
@option{-fdiagnostics-plain-output}は現在、次のオプションと同等です。
@gccoptlist{-fno-diagnostics-show-caret
-fno-diagnostics-show-line-numbers
-fdiagnostics-color=never
-fdiagnostics-urls=never
-fdiagnostics-path-format=separate-events}
将来、GCCが診断のデフォルトの外観を変更した場合、新しい動作を無効にするための対応するオプションがこのリストに追加されます。

@item -fdiagnostics-show-location=once
@opindex fdiagnostics-show-location
行送り返しモードでのみ意味を持つ。診断メッセージ報告器にソース場所情報を@emph{一度}だけを発するように命じる。
つまり、メッセージが単一の物理行にを収まらないほど長く、行送りをしなければならない場合には、
以降の継続行では、（接頭辞として）ソース場所は二度とは発されない。これは、デフォルトの振る舞いである。

@item -fdiagnostics-show-location=every-line
行送り返しモードでのみ意味を持つ。診断メッセージ報告器に単一行には収まらないほど長いメッセージを分割する過程の結果の物理行ごとに
（接頭辞として）同じソース場所情報を発するように命じる。

@item -fdiagnostics-color[=@var{WHEN}]
@itemx -fno-diagnostics-color
@opindex fdiagnostics-color
@cindex highlight, color
@vindex GCC_COLORS @r{environment variable}
診断で色を使う。@var{WHEN}は@samp{never}, @samp{always}, @samp{auto}である。デフォルトはコンパイラがどのように設定されたかに依存し、
上の@var{WHEN}オプションのどれかか、環境変数に@env{GCC_COLORS}が存在しなければ@samp{never}であり、さもなければ@samp{auto}である。
@samp{auto}は標準エラーがターミナルの時だけ色を使うことを意味する。@option{-fdiagnostics-color}型と@option{-fno-diagnostics-color}型は
それぞれ@option{-fdiagnostics-color=always}と@option{-fdiagnostics-color=never}の別名である。

色は環境変数@env{GCC_COLORS}で定義されている。その値はコロンで分割された機能とSelect Graphic Rendition (SGR)のリストである。
SGRコマンドはターミナルかターミナルエミュレータで解釈される。（文字属性として可能な値とその意味はターミナルの文書の該当節参照）
これらは部分文字列値はセミコロンで連結可能な10進表現の整数である。連結する一般的な値は
@samp{1}は太字
@samp{4}は下線
@samp{5}は点滅
@samp{7}は反転
@samp{39}はデフォルトの前景色
@samp{30}から@samp{37}は前景色
@samp{90}から@samp{97}は16色モードの前景色
@samp{38;5;0}から@samp{38;5;255}は88色と256色モードの前景色
@samp{49}はデフォルトの背景色
@samp{40}から@samp{47}は背景色
@samp{100}から@samp{107}は16色モードの背景色
@samp{48;5;0}から@samp{48;5;255}は88色と256色モードの背景色である。

デフォルトの@env{GCC_COLORS}は
@smallexample
error=01;31:warning=01;35:note=01;36:range1=32:range2=34:locus=01:\
quote=01:fixit-insert=32:fixit-delete=31:\
diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32:\
type-diff=01;32
@end smallexample
@noindent
であり、@samp{01;31}は太字の赤、@samp{01;35}は太字のマゼンタ、
@samp{01;36}は太字のシアン、@samp{32}は緑、@samp{34}は青、
@samp{01}は太字、@samp{31}は赤である。
@env{GCC_COLORS}を空文字列にすると色を無効にする。サポートされた機能は以下である。

@table @code
@item error=
@vindex error GCC_COLORS @r{capability}
エラーのマーカーのSGR部分文字列

@item warning=
@vindex warning GCC_COLORS @r{capability}
警告のマーカーのSGR部分文字列

@item note=
@vindex note GCC_COLORS @r{capability}
注釈のマーカーのSGR部分文字列

@item path=
@vindex path GCC_COLORS @r{capability}
@option{-fdiagnostics-path-format=}を介して出力される制御フローイベントのパスを色付けするためのSGRサブストリング。個々のイベントの識別子や、手続き間の呼び出しと戻りを示す行など。

@item range1=
@vindex range1 GCC_COLORS @r{capability}
最初の追加範囲のSGR部分文字列

@item range2=
@vindex range2 GCC_COLORS @r{capability}
二番目の追加範囲のSGR部分文字列
SGR substring for second additional range.

@item locus=
@vindex locus GCC_COLORS @r{capability}
場所情報、@samp{file:line}や@samp{file:line:column}などのSGR部分文字列

@item quote=
@vindex quote GCC_COLORS @r{capability}
引用符内で出力された情報のSGR部分文字列

@item fixit-insert=
@vindex fixit-insert GCC_COLORS @r{capability}
挿入されるか置換されるように提案された修正ヒントテキストのSGR部分文字列

@item fixit-delete=
@vindex fixit-delete GCC_COLORS @r{capability}
削除されるように提案された修正ヒントテキストのSGR部分文字列

@item diff-filename=
@vindex diff-filename GCC_COLORS @r{capability}
生成されたパッチ内でのファイル名ヘッダのSGR部分文字列

@item diff-hunk=
@vindex diff-hunk GCC_COLORS @r{capability}
生成されたパッチ内でのハンクの開始のSGR部分文字列

@item diff-delete=
@vindex diff-delete GCC_COLORS @r{capability}
生成されたパッチ内での削除された行のSGR部分文字列

@item diff-insert=
@vindex diff-insert GCC_COLORS @r{capability}
生成されたパッチ内の追加された行のSGR部分文字列

@item type-diff=
@vindex type-diff GCC_COLORS @r{capability}
C++フロントエンドでのテンプレート引数内でハイライトしている一致していない型のSGR部分文字列。

@end table

@item -fdiagnostics-urls[=@var{WHEN}]
@opindex fdiagnostics-urls
@cindex urls
@vindex GCC_URLS @r{environment variable}
@vindex TERM_URLS @r{environment variable}
診断にURLを埋め込むためにエスケープシーケンスを使用します。 たとえば、@option{-fdiagnostics-show-option}が診断を制御するコマンドラインオプションを示すテキストを出力する場合、そのオプションのドキュメントのURLを埋め込みます。

@var{WHEN}は@samp{never}、@samp{always}、または@samp{auto}です。 @samp{auto}は、標準エラーが端末であり、この機能と互換性がないことがわかっているemacsシェルまたはグラフィカル端末で実行されていない場合にのみ、GCCにURLエスケープシーケンスを使用させます。以下を参照してください。

デフォルトは、コンパイラーの構成方法によって異なります。 上記の@var{WHEN}オプションのいずれかです。

GCCを（@option{-with-diagnostics-urls=auto-if-env} configure-timeオプションを使用して構成して、デフォルトが環境変数の影響を受けるようにすることもできます。そのような構成では、GCCはデフォルトで@env{GCC_URLS}または@env{TERM_URLS}のいずれかの環境変数が存在し、コンパイラーの環境で空でない場合は@samp{auto}を使用し、どちらでもない場合は@samp{never}を使用します。

ただし、@option{-fdiagnostics-urls=always}を使用しても、動作はそれらの環境変数に依存します。@env{GCC_URLS}が空または@samp{no}に設定されている場合、診断にURLを埋め込まない。 @samp{st}に設定すると、URLはSTエスケープシーケンスを使用します。 デフォルトの@samp{bel}に設定すると、URLはBELエスケープシーケンスを使用します。 他の空でない値は、機能を有効にします。 @env{GCC_URLS}が設定されていない場合は、フォールバックとして@env{TERM_URLS}を使用します。 注：STはANSIエスケープシーケンス、文字列ターミネーター@samp{ESC \}、BELはASCII文字、通常はビープ音のように聞こえるCTRL-Gです。

現時点では、GCCは、URL機能を実装していないか、バグが有るか、少なくともまだ使われているバージョンのいくつかにバグがあってURLエスケープが誤動作する可能性が高いことがわかっているいくつかの端末も検出しようとします。
そのリストは現在xfce4-terminal、バグのあるgnome-terminalバージョン、Linuxコンソール、およびmingwであることがわかっています。 このチェックは、@option{-fdiagnostics-urls=always}でスキップできます。

@item -fno-diagnostics-show-option
@opindex fno-diagnostics-show-option
@opindex fdiagnostics-show-option
デフォルトでは、それぞれの生成された診断には（もしそのようなオプションが診断機構に既知であれば）
直接診断を生成するコマンドラインオプションを指すテキストを含める。
@option{-fno-diagnostics-show-option}フラグを指定するとこの振る舞いを抑制する。

@item -fno-diagnostics-show-caret
@opindex fno-diagnostics-show-caret
@opindex fdiagnostics-show-caret
デフォルトでは、生成されたそれぞれの診断には元のソース行と列を示すキャレット@samp{^}を含む。
このオプションはこの情報を抑制する。@option{-fmessage-length=n}が与えられた時は、ソース行は@var{n}文字へと切り詰められる。
出力がターミナルへと行われるときは、幅は@env{COLUMNS}環境変数か、もしセットされていない時はターミナルの幅へと制限される。

@item -fno-diagnostics-show-labels
@opindex fno-diagnostics-show-labels
@opindex fdiagnostics-show-labels
デフォルトでは、ソースコードを（@option {-fdiagnostics-show-caret}を介して）印刷するとき、診断は式のタイプなどの関連情報でソースコードの範囲にラベルを付けることができます。

@smallexample
    printf ("foo %s bar", long_i + long_j);
                 ~^       ~~~~~~~~~~~~~~~
                  |              |
                  char *         long int
@end smallexample

このオプションは、これらのラベルの印刷を抑制します（上記の例では、垂直バーと「char *」および「long int」テキスト）。

@item -fno-diagnostics-show-cwe
@opindex fno-diagnostics-show-cwe
@opindex fdiagnostics-show-cwe
診断メッセージには、オプションで@url{https://cwe.mitre.org/index.html, CWE}識別子を関連付けることができます。GCC自体は、@option{-fanalyzer}診断の一部にのみそのようなメタデータを提供します。 GCCプラグインは、そのようなメタデータで診断を提供する場合もあります。 デフォルトでは、この情報が存在する場合、診断とともに印刷されます。 このオプションは、このメタデータの印刷を抑制します。

@item -fno-diagnostics-show-line-numbers
@opindex fno-diagnostics-show-line-numbers
@opindex fdiagnostics-show-line-numbers
デフォルトでは、ソースコードを印刷するとき（@option{-fdiagnostics-show-caret}を使用）、左マージンが印刷され、行番号が表示されます。 このオプションは、この左マージンを抑制します。

@item -fdiagnostics-minimum-margin-width=@var{width}
@opindex fdiagnostics-minimum-margin-width
このオプションは、@option{-fdiagnostics-show-line-numbers}によって出力される左マージンの最小幅を制御します。 デフォルトは6です。

@item -fdiagnostics-parseable-fixits
@opindex fdiagnostics-parseable-fixits
IDEによる推測に適した、機械で解析可能な形式で修正ヒントを生成する。それぞれの修正で、
行は関連する診断の後に、``fix-it:''文字列で始まって出力される。例えば、

@smallexample
fix-it:"test.c":@{45:3-45:21@}:"gtk_widget_show_all"
@end smallexample

場所は半開区間で表現され、バイト単位で、最初の桁をバイト１で始めて表現される。
上の例では、``test.c''の行45の3から20までのバイトが与えられた文字列で置換される。

@smallexample
00000000011111111112222222222
12345678901234567890123456789
  gtk_widget_showall (dlg);
  ^^^^^^^^^^^^^^^^^^
  gtk_widget_show_all
@end smallexample

ファイル名と置換文字列はバックスラッシュが``\\", タブが``\t''、改行が``\n'',
二重引用符が``\"'', 非出力文字は8進で(例えば、垂直タブは``\013'')出力される。

空の置換文字列は与えられる範囲が削除すべきことを示す。空の範囲(例えば ``45:3-45:3'')は
文字列が与えられた位置に挿入すべきことを意味する。

@item -fdiagnostics-generate-patch
@opindex fdiagnostics-generate-patch
修正ヒントを標準エラーに統一diffフォーマットで、診断の後に出力する。例えば、
@smallexample
--- test.c
+++ test.c
@@ -42,5 +42,5 @@

 void show_cb(GtkDialog *dlg)
 @{
-  gtk_widget_showall(dlg);
+  gtk_widget_show_all(dlg);
 @}

@end smallexample

diffは色が付くかも付かないかもしれず、診断と同じ規則が適用される。
(@option{-fdiagnostics-color}参照)

@item -fdiagnostics-show-template-tree
@opindex fdiagnostics-show-template-tree

C++フロントエンドで、次のようなテンプレートタイプの不一致を示す診断を印刷する場合：

@smallexample
  could not convert 'std::map<int, std::vector<double> >()'
    from 'map<[...],vector<double>>' to 'map<[...],vector<float>>
@end smallexample

@option{-fdiagnostics-show-template-tree}フラグを使用すると、次のようなタイプの共通部分と異なる部分を示すツリーのような構造を印刷できます。

@smallexample
  map<
    [...],
    vector<
      [double != float]>>
@end smallexample

異なる部分は色で強調表示されます（この場合は「double」と「float」）。

@item -fno-elide-type
@opindex fno-elide-type
@opindex felide-type
デフォルトでは、C++フロントエンドが不一致のテンプレートタイプを示す診断を出力するとき、エラーメッセージを簡素化するために、タイプの一般的な部分は ``[...]''として出力されます。 例えば：

@smallexample
  could not convert 'std::map<int, std::vector<double> >()'
    from 'map<[...],vector<double>>' to 'map<[...],vector<float>>
@end smallexample

@option{-fno-elide-type}フラグを指定すると、その動作が抑制されます。
このフラグは、@option{-fdiagnostics-show-template-tree}フラグの出力にも影響します。

@item -fdiagnostics-path-format=@var{KIND}
@opindex fdiagnostics-path-format
そのようなパスが関連付けられている診断の制御フローイベントのパスを出力する方法を指定します。

@var{KIND}は@samp{none}, @samp{separate-events}, またはデフォルトの@samp{inline-events}です。

@samp{none}は診断パスを出力しないことを意味します。

@samp{separate-events}は、診断内のイベントごとに個別の「メモ」診断を出力することを意味します。 例えば：

@smallexample
test.c:29:5: error: passing NULL as argument 1 to 'PyList_Append' which requires
                    a non-NULL parameter
test.c:25:10: note: (1) when 'PyList_New' fails, returning NULL
test.c:27:3: note: (2) when 'i < count'
test.c:29:5: note: (3) when calling 'PyList_Append', passing NULL from (1)
                   as argument 1
@end smallexample

@samp{inline-events}は、イベントをソースコード内に「インライン」で出力することを意味します。 このビューは、イベントを十分に近いイベントの実行に統合して、ソース内のラベル付き範囲として出力しようとします。

たとえば、上記と同じイベントは次のように出力されるかもしれません。

@smallexample
  'test': events 1-3
    |
    |   25 |   list = PyList_New(0);
    |      |          ^~~~~~~~~~~~~
    |      |          |
    |      |          (1) when 'PyList_New' fails, returning NULL
    |   26 |
    |   27 |   for (i = 0; i < count; i++) @{
    |      |   ~~~
    |      |   |
    |      |   (2) when 'i < count'
    |   28 |     item = PyLong_FromLong(random());
    |   29 |     PyList_Append(list, item);
    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~
    |      |     |
    |      |     (3) when calling 'PyList_Append', passing NULL from (1) as argument 1
    |
@end smallexample

プロシージャ間の制御フローは、イベントをスタックフレームごとにグループ化し、インデントを使用してスタックフレームのネスト、プッシュ、ポップの方法を示しています。

例えば、

@smallexample
  'test': events 1-2
    |
    |  133 | @{
    |      | ^
    |      | |
    |      | (1) entering 'test'
    |  134 |   boxed_int *obj = make_boxed_int (i);
    |      |                    ~~~~~~~~~~~~~~~~~~
    |      |                    |
    |      |                    (2) calling 'make_boxed_int'
    |
    +--> 'make_boxed_int': events 3-4
           |
           |  120 | @{
           |      | ^
           |      | |
           |      | (3) entering 'make_boxed_int'
           |  121 |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));
           |      |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           |      |                                    |
           |      |                                    (4) calling 'wrapped_malloc'
           |
           +--> 'wrapped_malloc': events 5-6
                  |
                  |    7 | @{
                  |      | ^
                  |      | |
                  |      | (5) entering 'wrapped_malloc'
                  |    8 |   return malloc (size);
                  |      |          ~~~~~~~~~~~~~
                  |      |          |
                  |      |          (6) calling 'malloc'
                  |
    <-------------+
    |
 'test': event 7
    |
    |  138 |   free_boxed_int (obj);
    |      |   ^~~~~~~~~~~~~~~~~~~~
    |      |   |
    |      |   (7) calling 'free_boxed_int'
    |
(etc)
@end smallexample

@item -fdiagnostics-show-path-depths
@opindex fdiagnostics-show-path-depths
このオプションは、診断に関連する制御フローパスを印刷するときに追加情報を提供します。

このオプションを指定すると、@option{-fdiagnostics-path-format=separate-events}内のイベントの実行ごとにスタック深度が出力されます。

これは、プロシージャ間の制御フローを報告する診断をデバッグするときに、GCC開発者およびプラグイン開発者が使用することを目的としています。

@item -fno-show-column
@opindex fno-show-column
@opindex fshow-column
診断で桁番号を出力しない。これはもし診断が桁番号を理解しない、例えば@command{dejagnu}のような
プログラムでスキャンされるときには必要かもしれない。

@item -fdiagnostics-column-unit=@var{UNIT}
@opindex fdiagnostics-column-unit
列番号の単位を選択します。 これは、従来の診断（@option{-fno-show-column}がない場合）、および要求された場合はJSON形式の診断に影響します。

デフォルトの@var{UNIT}、@samp{display}は、各文字が占める表示列の数を考慮します。 これは、タブ文字の場合は文字のエンコードに必要なバイト数よりも大きい場合があり、マルチバイト文字の場合は小さい場合があります。 たとえば、文字「GREEK SMALL LETTER PI（U + 03C0）」は1つの表示列を占め、そのUTF-8エンコーディングには2バイトが必要です。 文字「SLIGHTLY SMILING FACE（U + 1F642）」は2つの表示列を占め、そのUTF-8エンコーディングには4バイトが必要です。

@var{UNIT}を@samp{byte}に設定すると、バージョン11.1.0より前のGCCによって従来出力されていたように、すべての場合で列番号が生のバイト数に変更されます。

@item -fdiagnostics-column-origin=@var{ORIGIN}
@opindex fdiagnostics-column-origin
列番号の原点、つまり最初の列に割り当てられた列番号を選択します。 デフォルト値の1は、従来のGCCの動作とGNUスタイルガイドに対応しています。 一部のユーティリティは、原点が0の方がパフォーマンスが向上する場合があります。 負でない値を指定できます。

@item -fdiagnostics-format=@var{FORMAT}
@opindex fdiagnostics-format
診断を印刷するために別の形式を選択します。
@var{FORMAT}は@samp{text}または@samp{json}です。
デフォルトは@samp{text}です。

@samp{json}形式は、診断を表すJSONオブジェクトを含むトップレベルのJSON配列で構成されます。

JSONはフォーマットなしで1行として出力されます。 以下の例は明確にするためにフォーマットされています。

診断には、子診断を含めることがあります。 たとえば、このエラーと注意は：

@smallexample
misleading-indentation.c:15:3: warning: this 'if' clause does not
  guard... [-Wmisleading-indentation]
   15 |   if (flag)
      |   ^~
misleading-indentation.c:17:5: note: ...this statement, but the latter
  is misleadingly indented as if it were guarded by the 'if'
   17 |     y = 2;
      |     ^
@end smallexample

@noindent
次のように（フォーマット後）JSON形式で印刷される場合があります。

@smallexample
[
    @{
        "kind": "warning",
        "locations": [
            @{
                "caret": @{
                    "column": 3,
                    "file": "misleading-indentation.c",
                    "line": 15
                @},
                "finish": @{
                    "column": 4,
                    "file": "misleading-indentation.c",
                    "line": 15
                @}
            @}
        ],
        "message": "this \u2018if\u2019 clause does not guard...",
        "option": "-Wmisleading-indentation",
        "children": [
            @{
                "kind": "note",
                "locations": [
                    @{
                        "caret": @{
                            "column": 5,
                            "file": "misleading-indentation.c",
                            "line": 17
                        @}
                    @}
                ],
                "message": "...this statement, but the latter is @dots{}"
            @}
        ]
    @},
    @dots{}
]
@end smallexample

@noindent
@code{note}は@code{warning}の子です。

診断には@code{kind}があります。 これが@code{warning}の場合、警告を制御するコマンドラインオプションを説明する@code{option}キーがあります。

診断には、0個以上の場所を含めることができます。 各場所には、オプションの@code{label}文字列と、その中に最大3つの位置（@code{caret}位置、オプションの@code{start}および@code{finish}位置）があります。 位置は、@code{file}名、@code{line}番号、および列の位置を示す3つの番号で記述されます。
@itemize @bullet

@item
@code{display-column}は、タブとマルチバイト文字を考慮して、表示列をカウントします。

@item
@code {byte-column}は生のバイトをカウントします。

@item
@code{column}は、@option{-fdiagnostics-column-unit}オプションで指定されているように、前の2つのうちの1つと同じです。

@end itemize
3つの列はすべて、@option{-fdiagnostics-column-origin}で指定された原点を基準にしています。これは通常1に等しいですが、他のユーティリティとの互換性のために、たとえば0に設定できます。0から列に番号を付けます。列の起点は、@code{column-origin}タグのJSON出力に記録されます。 以下の残りの例では、簡潔にするために、余分な列番号の出力は省略されています。

たとえば、次のエラーでは

@smallexample
bad-binary-ops.c:64:23: error: invalid operands to binary + (have 'S' @{aka
   'struct s'@} and 'T' @{aka 'struct t'@})
   64 |   return callee_4a () + callee_4b ();
      |          ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~
      |          |              |
      |          |              T @{aka struct t@}
      |          S @{aka struct s@}
@end smallexample

@noindent
3つの場所があります。 そのプライマリロケーションは、列23の「+」トークンにあります。2つのセカンダリロケーションがあり、式の左辺と右辺にラベルが付いています。 JSON形式で次のように印刷される場合があります。

@smallexample
    @{
        "children": [],
        "kind": "error",
        "locations": [
            @{
                "caret": @{
                    "column": 23, "file": "bad-binary-ops.c", "line": 64
                @}
            @},
            @{
                "caret": @{
                    "column": 10, "file": "bad-binary-ops.c", "line": 64
                @},
                "finish": @{
                    "column": 21, "file": "bad-binary-ops.c", "line": 64
                @},
                "label": "S @{aka struct s@}"
            @},
            @{
                "caret": @{
                    "column": 25, "file": "bad-binary-ops.c", "line": 64
                @},
                "finish": @{
                    "column": 36, "file": "bad-binary-ops.c", "line": 64
                @},
                "label": "T @{aka struct t@}"
            @}
        ],
        "message": "invalid operands to binary + @dots{}"
    @}
@end smallexample

診断に修正ヒントが含まれている場合、@option{-fdiagnostics-parseable-fixits}の出力に似た、半開間隔で構成される@code{fixits}配列があります。 たとえば、この診断と置換の修正のヒント：

@smallexample
demo.c:8:15: error: 'struct s' has no member named 'colour'; did you
  mean 'color'?
    8 |   return ptr->colour;
      |               ^~~~~~
      |               color
@end smallexample

@noindent
JSON形式で次のように印刷される場合があります。

@smallexample
    @{
        "children": [],
        "fixits": [
            @{
                "next": @{
                    "column": 21,
                    "file": "demo.c",
                    "line": 8
                @},
                "start": @{
                    "column": 15,
                    "file": "demo.c",
                    "line": 8
                @},
                "string": "color"
            @}
        ],
        "kind": "error",
        "locations": [
            @{
                "caret": @{
                    "column": 15,
                    "file": "demo.c",
                    "line": 8
                @},
                "finish": @{
                    "column": 20,
                    "file": "demo.c",
                    "line": 8
                @}
            @}
        ],
        "message": "\u2018struct s\u2019 has no member named @dots{}"
    @}
@end smallexample

@noindent
ここで修正ヒントは、@code{start}から@code{next}までのテキストを@code{string}の値に置き換えることを示唆しています。 削除は、@code{string}の空の値、@code{start}が@code{next}に等しい挿入によって表されます。

診断に関連する制御フローイベントのパスがある場合、診断には、イベントを表すオブジェクトの@code{path}配列があります。 各イベントオブジェクトには、@code{description}文字列、@code{location}オブジェクト、@code{function}文字列、および手続き間パスを表す@code{depth}番号があります。 @code{function}はそのイベントでの現在の関数を表し、@code{depth}はベースラインに対するスタックの深さを表します。高いほど、スタック内のフレーム数が多くなります。

たとえば、@option{-fdiagnostics-path-format=}の手順内の例では、パスに次のJSONが含まれる場合があります。

@smallexample
    "path": [
        @{
            "depth": 0,
            "description": "when 'PyList_New' fails, returning NULL",
            "function": "test",
            "location": @{
                "column": 10,
                "file": "test.c",
                "line": 25
            @}
        @},
        @{
            "depth": 0,
            "description": "when 'i < count'",
            "function": "test",
            "location": @{
                "column": 3,
                "file": "test.c",
                "line": 27
            @}
        @},
        @{
            "depth": 0,
            "description":
              "when calling 'PyList_Append', passing NULL from (1) as argument 1",
            "function": "test",
            "location": @{
                "column": 5,
                "file": "test.c",
                "line": 29
            @}
        @}
    ]
@end smallexample
@end table

@node Warning Options
@section 警告を要求・抑制するオプション
@cindex options to control warnings
@cindex warning messages
@cindex messages, warning
@cindex suppressing warnings

警告は本質的には誤っていないが、危険であったり、誤りを示唆するかもしれない構造を
報告するメッセージである。

以下の言語非依存のオプションは特定の警告を有効にはしないが、GCCが生成する診断の
種類を制御する。

@table @gcctabopt
@cindex syntax checking
@item -fsyntax-only
@opindex fsyntax-only
コードの構文エラーをチェックするが、それ以上の事はしない。

@item -fmax-errors=@var{n}
@opindex fmax-errors
エラーメッセージの最大数を@var{n}に制限し、その時点でソースコードの処理を続けようとは
せずに、GCCは脱出する。もし@var{n}が0ならば（デフォルト）、生成されるエラーメッセージ
の制限はない。もし@option{-Wfatal-errors}も指定されるなら、@option{-Wfatal-errors}
はこのオプションより優先する。

@item -w
@opindex w
全ての警告メッセージを抑制する。

@item -Werror
@opindex Werror
@opindex Wno-error
全ての警告をエラーにする。

@item -Werror=
@opindex Werror=
@opindex Wno-error=
指定された警告をエラーにする。警告の指定子が加えられる。例えば、@option{-Werror=switch}
は@option{-Wswitch}で制御される警告をエラーにする。このスイッチは否定形を取り、特定の警告で
@option{-Werror}を反転させるために使う。例えば、@option{-Wno-error=switch}は
@option{-Wswitch}警告、@option{-Werror}の効果があってもエラーにしない。

それぞれの制御可能な警告の警告メッセージは警告を制御するオプションを含む。そのオプションは
上で描写された@option{-Werror=}と@option{-Wno-error=}で使うことができる。
（警告メッセージ内のオプションの出力は@option{-fno-diagnostics-show-option}フラグで無効にできる）

@option{-Werror=}@var{foo}を指定すると自動的に@option{-W}@var{foo}を含むことに注意。
しかし、@option{-Wno-error=}@var{foo}は何も含まない。

@item -Wfatal-errors
@opindex Wfatal-errors
@opindex Wno-fatal-errors
このオプションはコンパイルの最初のエラーが起きた場所で、続けてこれ以上エラーメッセージを出力する
代わりにコンパイルを中止させる。

@end table

@samp{-W}（たとえば潜在的な宣言の警告を要請する@option{-Wimplicit}）で始まるオプションで、あなたは多くの特定の警告を要請することができる。
これらの特定の警告オプションの各々も、警告を消すために@samp{-Wno-}を開始している否定形を持つ。たとえば、@option{-Wno-implicit}。
このマニュアルは、2つの形（デフォルトでないものはどれでも）の1つだけをリストする。さらに言語に特有のオプションについても、
@ref{C++ Dialect Options}と@ref{Objective-C and Objective-C++ Dialect Options}を参照する。

あるオプション（例えば@option{-Wall}と@option{-Wextra}）は他のオプション（例えば@option{-Wunused}）をオンにする。そして、
それは更なるオプション（例えば@option{-Wunused-value}）をオンにするかもしれない。正と負の形の複合効果は、コマンド・ラインの位置と独立して、
より特定のオプションがより特定でないものに優先するということである。同じ特性のオプションについては、最後の1つが実施される。
まるでそれらがコマンド・ラインの終わりに現れるように、pragmas（@pxref{Diagnostic Pragmas}）を通して使用可能にされるか、使用不能なオプションは実施される。

認められていない警告オプションが要請される（例えば、@option{-Wunknown-warning}）とき、GCCはオプションが認識されないと述べている診断を発する。
しかし、@option{-Wno-}の形が使われるならば、ふるまいはわずかに異なる：他の診断が生み出されない限り、
診断は@option{-Wno-unknown-warning}のために生み出されない。これは古いコンパイラで新しい@option{-Wno-}オプションを使用可能にする、
しかし、何かがうまくいかないならば、コンパイラは認められていないオプションが存在すると警告する。

@table @gcctabopt
@item -Wpedantic
@itemx -pedantic
@opindex pedantic
@opindex Wpedantic
厳格なISO CとISO C++によって要求されるすべての警告を発する。禁じられた拡張を使うすべてのプログラムとISO CとISO C++に追従しないある他のプログラムを拒絶する。
ISO Cでは、使われるどんな@option{-std}オプションで特定されたISO C標準のバージョンにも追従する。

有効なISO CとISO C++プログラムはこのオプションの有無にかかわらずきちんとコンパイルするべきである（まれな少数派がISO cの必須の版を指定している@option{-ansi}または@option{-std}オプションを必要とするけれども）。しかし、このオプションなしでは、特定のGNU拡張と伝統的なのCとC++機能も同様にサポートされる。
このオプションで、それらは拒絶される。

名前が@samp{__}で始まって終わる代替キーワードの用法は、@option{-Wpedantic}では警告メッセージを引き起こさない。この代替形式を使用して、ISO以外の@samp{__intN}タイプ、つまり@samp{__intN__}の警告を無効にすることもできます。@code{__extension__}に追従する表現も、衒学的な警告が無効にされる。しかし、システム・ヘッダファイルだけでこれらの脱出ルートを使うべきである。アプリケーション・プログラムは、それらを避けるべきである。@xref{Alternate Keywords}。

あるユーザーは、厳しいISO C適合のための検査プログラムに@option{-Wpedantic}を使おうと試みる。それらは、それらが欲するものではないとすぐにわかる。
それは、いくつかの非ISO実行を見つけるが、全てではない。 ― それらISO Cが@emph{要求する}の診断とその診断で加えられるものだけである。

ISO Cに適合することの失敗の報告の機能はある状況では役立つかもしれないが、かなりの更なる働きを必要として、@option{-Wpedantic}と全く異なる。我々には、近い将来、そのような機能をサポートする計画はない。

@option{-std}で指定される標準がC（例えば@samp{gnu90}または@samp{gnu99}）のGNU拡張変種を意味する所では、対応する@dfn{ベース標準}（GNU延長した変種が基礎を形成されるISO Cの版）がある。それらがベース標準によって必要とされるところを、@option{-Wpedantic}からの警告は、与えられる。
（定義上、CのGNU変種は与えられたオプションでコンパイラがサポートする機能を全て含み、警告すべきものは何もないため、
指定されたGNU C変種にない機能に対して与えられる警告は意味をなさない。）

@item -pedantic-errors
@opindex pedantic-errors
@dfn{基底標準}（@option{-Wpedantic}参照）が診断を要求するとき、ある場合にはコンパイル時に未定義の振る舞いがあり、
別の場合には、標準に従って正当なプログラムのコンパイルを妨げない場合、エラーを発する。これは@option{-Werror=pedantic}と
等価ではない。なぜならばこのオプションで有効になるが後者ではならないエラーや、その逆があるからだ。

@item -Wall
@opindex Wall
@opindex Wno-all
あるユーザは不確かと考え、安易に避けられる（もしくは警告を抑止するように修正できる）構造に関する警告を、
マクロと複合中でもすべて有効にする。これは@ref{C++ Dialect Options} and @ref{Objective-C and Objective-C++ Dialect Options}
で描写されるある言語依存の警告も有効にする。

@option{-Wall}は以下の警告フラグをONにする。

@gccoptlist{-Waddress   
-Warray-bounds=1 @r{(} @option{-O2}@r{でのみ)}  
-Warray-parameter=2 @r{(CとObjective-C専用)} 
-Wbool-compare  
-Wbool-operation  
-Wc++11-compat  -Wc++14-compat  
-Wcatch-value @r{(C++とObjective-C++専用)}  
-Wchar-subscripts  
-Wcomment  
-Wduplicate-decl-specifier @r{(CとObjective-C専用)} 
-Wenum-compare @r{(C/ObjC用。C++ではデフォルトでオンである)} 
-Wformat   
-Wformat-overflow  
-Wformat-truncation  
-Wint-in-bool-context  
-Wimplicit @r{(CとObjective-C専用)} 
-Wimplicit-int @r{(CとObjective-C専用)} 
-Wimplicit-function-declaration @r{(CとObjective-C専用)} 
-Winit-self @r{(C++専用)} 
-Wlogical-not-parentheses 
-Wmain @r{(C/ObjC専用かつ} @option{-ffreestanding}@r{でないとき)}  
-Wmaybe-uninitialized 
-Wmemset-elt-size 
-Wmemset-transposed-args 
-Wmisleading-indentation @r{(C/C++専用)} 
-Wmissing-attributes 
-Wmissing-braces @r{(C/ObjC専用)} 
-Wmultistatement-macros  
-Wnarrowing @r{(C++専用)}  
-Wnonnull  
-Wnonnull-compare  
-Wopenmp-simd 
-Wparentheses  
-Wpessimizing-move @r{(C++専用)}  
-Wpointer-sign  
-Wrange-loop-construct @r{(C++専用)}  
-Wreorder   
-Wrestrict   
-Wreturn-type  
-Wsequence-point  
-Wsign-compare @r{(C++専用)}  
-Wsizeof-array-div 
-Wsizeof-pointer-div 
-Wsizeof-pointer-memaccess 
-Wstrict-aliasing  
-Wstrict-overflow=1  
-Wswitch  
-Wtautological-compare  
-Wtrigraphs  
-Wuninitialized  
-Wunknown-pragmas  
-Wunused-function  
-Wunused-label     
-Wunused-value     
-Wunused-variable  
-Wvla-parameter @r{(CとObjective-C専用)} 
-Wvolatile-register-var  
-Wzero-length-bounds}

ある警告フラグが@option{-Wall}によって含まれないことに注意すべきである。ユーザーが不確かであると一般に思わないが
あなたは時折それについて調べたいかもしれない構造のいくつかも警告する。他のものは
必要であるかあるケースを中で避けることが難しく、警告を抑制するためにコードを修正する簡単な方法がない。
それらの一部は@option{-Wextra}によって使用可能にされるが、それらの多くは個々に使用可能にされなければならない。

@item -Wextra
@opindex W
@opindex Wextra
@opindex Wno-extra
@option{-Wall}で有効にならない追加の警告フラグのいくつかを有効にする。（このオプションはかつては@option{-W}と呼ばれていた。
古い名前はまだ利用可能だが、新しい名前はより描写的である。）

@gccoptlist{-Wclobbered  
-Wcast-function-type  
-Wdeprecated-copy @r{(C++専用)} 
-Wempty-body  
-Wenum-conversion @r{(C専用)} 
-Wignored-qualifiers 
-Wimplicit-fallthrough=3 
-Wmissing-field-initializers  
-Wmissing-parameter-type @r{(C専用)}  
-Wold-style-declaration @r{(C専用)}  
-Woverride-init  
-Wsign-compare @r{(C専用)} 
-Wstring-compare 
-Wredundant-move @r{(C++専用)}  
-Wtype-limits  
-Wuninitialized  
-Wshift-negative-value @r{(C++03とC99以降)}  
-Wunused-parameter @r{(} @option{-Wunused} @r{または} @option{-Wall}@r{設定時のみ)} 
-Wunused-but-set-parameter @r{(} @option{-Wunused} @r{または} @option{-Wall}@r{設定時のみ)}
-Wunused-parameter@r{(} @option{-Wunused} @r{または} @option{-Wall}@r{設定時のみ)}
-Wunused-but-set-parameter @r{(} @option{-Wunused} @r{または} @option{-Wall}@r{設定時のみ)}}
オプション@option{-Wextra}は以下の場合の警告メッセージも出力する。

@itemize @bullet

@item
ポインタが整数0と@code{<}, @code{<=}, @code{>}, @code{>=}と比較されている。

@item
(C++のみ) 列挙と非列挙が条件式に両方現れる。

@item
(C++のみ) 曖昧な仮想基底。

@item
(C++のみ) @code{register}で宣言された配列の添字

@item
(C++のみ) @code{register}で宣言された変数のアドレス取得

@item
(C++のみ) 導出クラスのコピーコンストラクタで初期化されていない基底クラス

@end itemize

@item -Wabi @r{(C, Objective-C, C++とObjective-C++専用)}
@opindex Wabi
@opindex Wno-abi

ABIの変更の影響を受けるコードについて警告します。 これには、特定のターゲットのpsABIだけでなく、ベンダー中立のC++ ABIと互換性がない可能性があるコードが含まれます。

G++は現在、メジャーリリースごとにデフォルトでABIを更新するので、@option{-Wabi}は通常、
初期のリリース以降に発見されたABIの問題のためにリリースの後半で加えられたチェックがある場合だけ警告する。@option{-Wabi}は
(@option{-fabi-version=@var{n}}で)古いABIバージョンが選択されたときにはもっと多くの警告をする。

特定の@option{-fabi-version}レベル（例えば@option{-fabi-version=2}と比較した変化について警告する@option{-Wabi=2}）との
互換性について警告するために、@option{-Wabi}が明確なバージョン番号で使われることもできる。

明確なバージョン番号が提供され、@option{-fabi-compat-version}が指定されないならば、このオプションからのバージョン番号が互換性別名のために使われる。
明確なバージョン番号がこのオプションで提供されないが@option{-fabi-compat-version}が指定されるならば、そのバージョン番号がABI警告のために使われる。

すべての場合について警告するように努力するが、たとえG++が非互換のコードを生成しているとしても、警告されないあるケースが多分あるだろう。たとえ生成されるコードが互換性を持つとしても、警告が発されるケースも、あるかもしれない。

G++によって生成されるコードが他のコンパイラによってコードを生成してバイナリ互換でないかもしれないという事実を心配するならば、あなたはこれらの警告を避けるためにあなたのコードを書き直すべきである。

@option{-fabi-version=2}（GCC 3.4～4.9からのデフォルトであった）の既知の非互換性は、以下を含む：

@itemize @bullet

@item
参照型の非型のテンプレートパラメータのテンプレートは誤ってマングルされた
@smallexample
extern int N;
template <int &> struct S @{@};
void n (S<N>) @{2@}
@end smallexample

これは@option{-fabi-version=3}で修正された。

@item
@code{__attribute ((vector_size))}を使って宣言されたSIMDベクタ型は異なるサイズのベクタを取るオーバーロードができない
非標準のやり方でマングルされた

マングルは@option{-fabi-version=4}で変わった。

@item
@code{__attribute ((const))}と@code{noreturn}は型修飾子としてマングルされ、素の宣言の@code{decltype}は折りたたまれた。

これらのマングルの問題は@option{-fabi-version=5}で修正された。

@item
可変長引数関数に渡されるスコープの列挙は非スコープの列挙のように格上げされ、@code{va_arg}が文句を言う。多くのターゲットでは、@code{int}より小さな
引数を渡す方法がないので、これは効果を持たない。

さらに、ABIはテンプレート引数の詰め、@code{const_cast}, @code{static_cast}, 前置インクリメント・デクリメント、テンプレート引数として使われるクラススコープの関数
のマングルを変えた。

これらの問題は@option{-fabi-version=6}で修正された。

@item
デフォルト引数スコープでのラムダは間違ってマングルされ、ABIは@code{nullptr_t}のマングルを変えた。

これらの問題は@option{-fabi-version=7}で修正された。

@item
関数cv修正子つきの関数型をマングルするとき、修正子なしの関数型は誤って置換対象として扱われた。

これは @option{-fabi-version=8}で修正され、GCC5.1のデフォルトである。

@item
@code{decltype(nullptr)}は誤ってアライメント1を持ち。非境界アクセスを起こした。これはパラメータが最小のアラインメントを持つので、
@code{nullptr_t}パラメータを持つ関数のABIには影響しないことに注意。

これは @option{-fabi-version=9}で修正され、GCC5.2のデフォルトである。

@item
関数型のia32呼び出し規約(stdcall, regparmなど)のような、型の識別性に影響するターゲット固有の属性はマングル名に影響せず、テンプレート引数として関数ポインタ
が使われた時は名前の衝突を引き起こした。

これは @option{-fabi-version=10}で修正され、GCC6.1のデフォルトである。

@end itemize

psABI関連の変更についても警告する。現時点での既知のpsABIの変更は以下を含む。

@itemize @bullet

@item
SysV/x86-64では、@code{long double}を持つ共用体メンバはpsABIで指定されたようにメモリで渡される。GCC 4.4より前は、これは当てはまりませんでした。 例えば：

@smallexample
union U @{
  long double ld;
  int i;
@};
@end smallexample

@noindent
@code{union U}は常にメモリで渡される。

@end itemize

@item -Wchar-subscripts
@opindex Wchar-subscripts
@opindex Wno-char-subscripts
配列の添字が@code{char}ならば警告する。これはプログラマーがこの型がある機種では符号付きであることをしばしば忘れるので
一般的なエラーの原因である。
この警告は@option{-Wall}で有効になる。

@item -Wno-coverage-mismatch
@opindex Wno-coverage-mismatch
フィードバックプロファイルが@option{-fprofile-use}オプションを使った時と一致しない時に警告する。
もしソースファイルが@option{-fprofile-gen}でコンパイルした時と@option{-fprofile-use}で
コンパイルした時で変わっている場合は、プロファイルフィードバックのファイルはソースファイルと
一致することができず、GCCはプロファイルフィードバック情報を使うことができない。
デフォルトでは、この警告は有効でエラーとして扱われる。
@option{-Wno-coverage-mismatch}は警告を無効にするために使うことができ、
@option{-Wno-error=coverage-mismatch}はエラーを無効にするために使うことができる。
この警告のエラーを無効にすると、貧弱な最適化のコードを生成する可能性があり、
既存のコードベースへのバグ修正のようなとても小さな変更の場合のみ有用である。
この警告を完全に無効にすることは勧められない。

@item -Wno-cpp
@r{(C, Objective-C, C++, Objective-C++とFortran専用)}
@opindex Wno-cpp
@opindex Wcpp
@code{#warning}ディレクティブによって生成された警告メッセージを抑制する。

@item -Wdouble-promotion @r{(C, C++, Objective-C とObjective-C++専用)}
@opindex Wdouble-promotion
@opindex Wno-double-promotion
@code{float}型の値が暗黙に@code{double}に格上げされるときに警告する。
32ビット「単精度」浮動小数点ユニットがあるCPUはハードウェアで@code{float}を実装するが、
@code{double}をソフトウェアで再現している。そのような機種で、@code{double}値を使った計算は
ソフトウェアエミュレーションで要求されるオーバーヘッドのためにずっと高く付く。

浮動小数点定数が暗黙に型@code{double}であるために、誤って@code{double}で計算するのは容易い。
例えば、
@smallexample
@group
float area(float radius)
@{
   return 3.14159 * radius * radius;
@}
@end group
@end smallexample
はコンパイラは浮動小数点定数が@code{double}であるために、全計算を@code{double}で行う。

@item -Wduplicate-decl-specifier @r{(CとObjective-C専用)}
@opindex Wduplicate-decl-specifier
@opindex Wno-duplicate-decl-specifier
宣言が重複した@code{const}, @code{volatile}, @code{restrict}, @code{_Atomic}指定子を持つなら警告する。
この警告は@option{-Wall}で有効になる。

@item -Wformat
@itemx -Wformat=@var{n}
@opindex Wformat
@opindex Wno-format
@opindex ffreestanding
@opindex fno-builtin
@opindex Wformat=
@code{printf}、@code{scanf}などの呼び出しを検査し、提供された引数が指定されたフォーマット文字列に対して
適切な型であり、フォーマット文字列で指定された規約が意味をなすことを確かめる。これは標準関数と、
他のformat属性(@pxref{Function Attributes})、@code{printf}, @code{scanf}, @code{strftime}, @code{strfmon}
(X/Open拡張でCで標準ではない)ファミリー（および他のターゲット固有のファミリー）が含まれる。
format属性なしでどの関数がチェックされるかは選択された標準バージョンに依存して、指定された属性無しの
そのようなチェックは@option{-ffreestanding}か@option{-fno-builtin}で無効にされる。

GNU libc版2.2によってサポートされるフォーマット機能に対してフォーマットは照合される。これらは、
すべてのISO C90とC99機能を含み、Single Unix SpecificationとあるBSDとGNU拡張からの機能も同様である。
他のライブラリ実装が、すべてのこれらの機能をサポートするというわけではないかもしれない。
特定のライブラリの限界を越える機能について、GCCは警告をサポートしない。
しかし、@option{-Wpedantic}が@option{-Wformat}で使われるならば、選ばれた標準的なバージョンにない
フォーマット機能については警告されない。
（しかし、それらがどんなC標準のバージョンにもないので、@code{strfmon}フォーマットは別である）
 @xref{C Dialect Options,,C変種を制御するオプション}.

@table @gcctabopt
@item -Wformat=1
@itemx -Wformat
@opindex Wformat
@opindex Wformat=1
オプション@option{-Wformat}は@option{-Wformat=1}と等価であり、@option{-Wno-format}は@option{-Wformat=0}と等価である。
@option{-Wformat}はいくつかの関数でnullフォーマット引数の検査も行うので、@option{-Wformat}は@option{-Wnonnull}も含む。
フォーマット・チェックのこのレベルのある側面は、以下のオプションで無効にできる。 @option{-Wno-format-contains-nul},
@option{-Wno-format-extra-args}, @option{-Wno-format-zero-length}。
@option{-Wformat}は@option{-Wall}で有効にされる。

@opindex Wformat=2
@option{-Wformat}と追加のフォーマットチェックを有効にします。 現在、@/
@option{-Wformat -Wformat-nonliteral -Wformat-security -Wformat-y2k}と同等です。
@end table

@item -Wno-format-contains-nul
@opindex Wno-format-contains-nul
@opindex Wformat-contains-nul
もし@option{-Wformat}が指定されるならば、NULバイトを含むフォーマット文字列について警告しない。

@item -Wno-format-extra-args
@opindex Wno-format-extra-args
@opindex Wformat-extra-args
もし@option{-Wformat}が指定されるならば、@code{printf}や@code{scanf}への余分な引数について警告しない。C標準は
そのような引数が無視されると指定している。

未使用に引数が@samp{$}オペランド番号指定子で指定された使用された引数の間にあるならば、実装は未使用の引数
を飛ばすために@code{va_arg}へ渡す型を知ることができないため、通常は警告はまだ与えられる。しかし、
@code{scanf}フォーマットの場合は、もしも未使用に引数が全てポインタならば、Single Unix Specificationがそのような未使用の引数を
許しているので、このオプションは警告を抑制する。

@item -Wformat-overflow
@itemx -Wformat-overflow=@var{level}
@opindex Wformat-overflow
@opindex Wno-format-overflow
@code{sprintf}や@code{vsprintf}のような、フォーマットされた入出力関数への呼び出しが、
出力バッファをオーバーフローする可能性があることを警告する。
コンパイル時にformatディレクティブによって書き込まれるバイト数が正確に決まらない場合は、
@var{level}引数と最適化に依存するヒューリスティックに基づいて推定される。
ほとんどの場合、最適化を有効にすると警告の精度が向上するが、誤検出の可能性もある。

@table @gcctabopt
@item -Wformat-overflow
@itemx -Wformat-overflow=1
@opindex Wformat-overflow
@opindex Wno-format-overflow
@option{-Wformat}によって有効にされる@option{-Wformat-overflow}のレベル@var{1}は、
バッファオーバーフローの可能性が最も高いコールについてのみ警告する保守的なアプローチを採用している。
このレベルでは、未知の値を持つ指令ディレクティブの数値引数は1の値を持ち、未知の長さの文字列は空であると仮定される。
それらの型の部分範囲に束縛されていることが知られている数値引数、またはその出力がそのディレクティブの精度か有限の
文字列リテラルのセットによって制限されている文字列引数は、最大のバイトは出力されると仮定される。
たとえば、下の@code{sprintf}の呼び出しは、例え@var{a}と@var{b}の両方が0であっても、
出力バッファへ関数によって加えられる終了NUL文字（@code{'\0'}）が末端を超えているので、診断が行われる。
バッファーオーバーフローを回避するには十分ではないかもしれないが、
警告を回避するにはバッファのサイズを1バイト増やすだけで十分である。

@smallexample
void f (int a, int b)
@{
  char buf [13];
  sprintf (buf, "a = %i, b = %i\n", a, b);
@}
@end smallexample

@item -Wformat-overflow=2
レベル@var{2}は、十分な長さまたは大きさの引数を与えられたときに出力バッファをオーバーフローさせる可能性のある
コールについても警告する。レベル@var{2}では、未知の数値引数は、精度が1より大きい符号付き型の場合は
表現可能な最小値をとり、それ以外の場合は表現可能な最大値を持つものとみなされる。
その長さがディレクティブの精度、及び評価されるかもしれない文字列リテラル及び指し示している文字配列の有限集合によって制限されない
未知の文字列引数は、1文字長と仮定される。

レベル@var{2}では、上の例の呼び出しが再度診断されるが、今回は、@var{a}が32ビットの@code{INT_MIN}に等しいので、
最初の@code{%i}ディレクティブは出力バッファの末尾を越えていくつかの数字を書く。
2つの変数の値にかかわらず呼び出しを安全にするには、宛先バッファのサイズを少なくとも34バイトに増やす必要がある。
GCCは、警告に続く情報ノート内のバッファの最小サイズが含まれている。

出力バッファのサイズを増やすことの代替手段は、書式化される値の範囲を制限することである。
文字列引数の最大長はフォーマットディレクティブでの精度を指定することで制限される。
フォーマットディレクティブの数値引数がその型の精度未満で制限されていると仮定で切る時は、
フォーマット指定子に適切な長さ指定子を選ぶことで、必要なバッファサイズを減らすだろう。
例えば、もし上の例の@var{a}と@var{b}が@code{short int}型の範囲内であると仮定できるなら、
@code{%hi}フォーマットディレクティブを使うか引数を@code{short}にキャストすることで
要求される最大サイズを24バイトへと減らす。

@smallexample
void f (int a, int b)
@{
  char buf [23];
  sprintf (buf, "a = %hi, b = %i\n", a, (short)b);
@}
@end smallexample
@end table

@item -Wno-format-zero-length
@opindex Wno-format-zero-length
@opindex Wformat-zero-length
もし@option{-Wformat}が指定されるならば、ゼロ長フォーマットについて警告しない。Cの標準はゼロ長フォーマットが許されると
指定している。

@item -Wformat-nonliteral
@opindex Wformat-nonliteral
@opindex Wno-format-nonliteral
もし@option{-Wformat}が指定されたら、フォーマット関数が@code{va_list}としてフォーマット引数を取るのでない限り、
フォーマット文字列が文字列定数でなく、チェックできない時に警告する。

@item -Wformat-security
@opindex Wformat-security
@opindex Wno-format-security
もし@option{-Wformat}が指定されたら、セキュリティー問題の可能性があるフォーマット関数の使用についても警告する。
現在、これは@code{printf (foo);}のようにフォーマットもじれうtが文字列定数でなく、フォーマット引数がない@code{printf}および
@code{scanf}関数の呼び出しについて警告する。これはフォーマット文字列は信頼出来ない入力から来た文字列で@samp{%n}を含むならば
セキュリティホールとなるかもしれない。（これは現在@option{-Wformat-nonliteral}が警告するものの部分集合だが、将来の警告では
@option{-Wformat-nonliteral}に含まれないものが@option{-Wformat-security}へ加えられるかもしれない。

@item -Wformat-signedness
@opindex Wformat-signedness
@opindex Wno-format-signedness
もし@option{-Wformat}が指定されたら、フォーマット文字列が符号なしを要求していて、引数が符号付きであるか、その逆の時にも警告する。

@item -Wformat-truncation
@itemx -Wformat-truncation=@var{level}
@opindex Wformat-truncation
@opindex Wno-format-truncation
@code{snprintf}と@code{vsnprintf}のような書式化入出力関数の呼び出しが出力を切り詰めるかもしれない時に警告する。
フォーマットディレクティブによって書かれる正確なバイト数がコンパイル時に決定できない時は、
@var{level}引数と最適化に依存したヒューリスティックによって推測される。
最適化を有効にしたときには大抵の場合に警告の正確さが向上するが、偽の警告も出すかもしれない。他で指摘したことを除いて、
このオプションは@option{-Wformat-overflow}と同じ論理を使う。

@table @gcctabopt
@item -Wformat-truncation
@itemx -Wformat-truncation=1
@opindex Wformat-truncation
@opindex Wno-format-overflow
@option{-Wformat}によって有効にされる@option{-Wformat-truncation}のレベル@var{1}は、
戻り値が未使用で大抵の場合に出力の切り詰めが起こるであろう制限された関数への呼び出しについてのみ警告する
保守的なアプローチを採用している。

@item -Wformat-truncation=2
レベル@var{2}は戻り値が使われて、十分な長さまたは大きさの引数が与えられた場合に切り捨てられる可能性がある、
境界付き関数への呼び出しについても警告する。
@end table

@item -Wformat-y2k
@opindex Wformat-y2k
@opindex Wno-format-y2k
もし@option{-Wformat}が指定されたら、数字2つの年のみを生成する@code{strftime}書式についても警告する。

@item -Wnonnull
@opindex Wnonnull
@opindex Wno-nonnull
@code{nonnull}関数属性によって非nullを要求するようにマークされている引数にnullポインタを渡すことについて警告する。

@option{-Wnonnull}は@option{-Wall}と@option{-Wformat}に含まれている。@option{-Wno-nonnull}オプションで無効にできる。

@item -Wnonnull-compare
@opindex Wnonnull-compare
@opindex Wno-nonnull-compare
@code{nonnull}関数属性でマークされた引数とnullをその関数内で比較すると警告する。

@option{-Wnonnull-compare}は@option{-Wall}に含まれる。@option{-Wno-nonnull-compare}で無効にできる。

@item -Wnull-dereference
@opindex Wnull-dereference
@opindex Wno-null-dereference
コンパイラがnullポインタの参照剥がしのためにエラーか未定義の振る舞いを引き起こす経路を探知した時に警告する。
このオプションは@option{-fdelete-null-pointer-checks}が活性の時だけ活性で、多くのターゲットで最適化が有効の時である。
この警告の精度はオプションが使われた最適化に依存する。

@item -Winit-self @r{(C, C++, Objective-C, Objective-C++専用)}
@opindex Winit-self
@opindex Wno-init-self
自分自身で初期化された未初期化の変数について警告する。このオプションは@option{-Wuninitialized}オプションと一緒にだけ使うことができる。

例えば、GCCは@option{-Winit-self}が指定された時だけ以下の断片で未初期化の@code{i}について警告する。
@smallexample
@group
int f()
@{
  int i = i;
  return i;
@}
@end group
@end smallexample

この警告はC++では@option{-Wall}で有効である。

@item -Wimplicit-int @r{(CとObjective-C専用)}
@opindex Wimplicit-int
@opindex Wno-implicit-int
宣言が型を指定しない場合に警告する。この警告は@option{-Wall}で有効である。

@item -Wimplicit-function-declaration @r{(CとObjective-C専用)}
@opindex Wimplicit-function-declaration
@opindex Wno-implicit-function-declaration
関数が宣言される前に使われた時に警告する。C99モード(@option{-std=c99}か@option{-std=gnu99})では、
この警告はデフォルトで有効で、@option{-pedantic-errors}でエラーになる。この警告は@option{-Wall}でも有効になる。

@item -Wimplicit @r{(CとObjective-C専用)}
@opindex Wimplicit
@opindex Wno-implicit
@option{-Wimplicit-int}と@option{-Wimplicit-function-declaration}と同じである。
この警告は@option{-Wall}で有効になる。

@item -Wimplicit-fallthrough
@opindex Wimplicit-fallthrough
@opindex Wno-implicit-fallthrough
@option{-Wimplicit-fallthrough}は@option{-Wimplicit-fallthrough=3}と同じであり、
@option{-Wno-implicit-fallthrough}は@option{-Wimplicit-fallthrough=0}と同じである。

@item -Wimplicit-fallthrough=@var{n}
@opindex Wimplicit-fallthrough=
switchのcaseで下へ落下(fall-through)したときの警告する。例えば、

@smallexample
@group
switch (cond)
  @{
  case 1:
    a = 1;
    break;
  case 2:
    a = 2;
  case 3:
    a = 3;
    break;
  @}
@end group
@end smallexample

この警告はcaseの最後の文が下へ落下できないとき、例えば、return文かnoreturn属性で宣言された
関数への呼び出しのときには警告しない。@option{-Wimplicit-fallthrough=}
は制御フロー文、例えばif、も考慮し、適切なときのみ警告する。例えば、

@smallexample
@group
switch (cond)
  @{
  case 1:
    if (i > 3) @{
      bar (5);
      break;
    @} else if (i < 1) @{
      bar (0);
    @} else
      return;
  default:
    @dots{}
  @}
@end group
@end smallexample

switch caseの下への落下が望ましい場合もあるので、GCCは属性@code{__attribute__ ((fallthrough))}
を提供し、それは通常起こる警告を抑制するために空文と一緒に使われる。

@smallexample
@group
switch (cond)
  @{
  case 1:
    bar (0);
    __attribute__ ((fallthrough));
  default:
    @dots{}
  @}
@end group
@end smallexample

C++17ではGNU属性の代わりに、@code{[[fallthrough]];}を使って@option{-Wimplicit-fallthrough}警告
抑制する標準の方法が存在する。C++11およびC++14のユーザはGNU拡張である@code{[[gnu::fallthrough]];}
を使うことができる。これらの属性の代わりに、フォールスルー・コメントを追加して警告を抑止することもできる。 CまたはC++形式のコメントの本文は、以下に示す正規表現と一致する必要がある。 オプション引数@var{n}は、どのようなコメントが受け入れられるかを指定する：

@itemize @bullet

@item @option{-Wimplicit-fallthrough=0}は警告完全に無効にする

@item @option{-Wimplicit-fallthrough=1}は@code{.*}正規表現の一致し、
どんなコメントも落下コメントとして使うことができる

@item @option{-Wimplicit-fallthrough=2}は大文字小文字を無視して正規表現@code{.*falls?[ \t-]*thr(ough|u).*}
に一致する

@item @option{-Wimplicit-fallthrough=3}は大文字小文字を区別して以下の正規表現のどれかに一致する。

@itemize @bullet

@item @code{-fallthrough}

@item @code{@@fallthrough@@}

@item @code{lint -fallthrough[ \t]*}

@item @code{[ \t.!]*(ELSE,? |INTENTIONAL(LY)? )?@*FALL(S | |-)?THR(OUGH|U)[ \t.!]*(-[^\n\r]*)?}

@item @code{[ \t.!]*(Else,? |Intentional(ly)? )?@*Fall((s | |-)[Tt]|t)hr(ough|u)[ \t.!]*(-[^\n\r]*)?}

@item @code{[ \t.!]*([Ee]lse,? |[Ii]ntentional(ly)? )?@*fall(s | |-)?thr(ough|u)[ \t.!]*(-[^\n\r]*)?}

@end itemize

@item @option{-Wimplicit-fallthrough=4}は大文字小文字を区別して、以下の正規表現のどれかに一致する

@itemize @bullet

@item @code{-fallthrough}

@item @code{@@fallthrough@@}

@item @code{lint -fallthrough[ \t]*}

@item @code{[ \t]*FALLTHR(OUGH|U)[ \t]*}

@end itemize

@item @option{-Wimplicit-fallthrough=5}はどんなコメントも落下コメントとして認識せずに、
属性のみが警告を無効にする。

@end itemize


@code{case}や@code{default}のキーワードや、@code{case}や@code{default}のラベルに先行するユーザのラベルによって、
コメントはオプションの空白やその他のコメントの後に続く必要がある。

@smallexample
@group
switch (cond)
  @{
  case 1:
    bar (0);
    /* FALLTHRU */
  default:
    @dots{}
  @}
@end group
@end smallexample

The @option{-Wimplicit-fallthrough=3}警告は@option{-Wextra}によって有効になる。

@item -Wif-not-aligned @r{(C, C++, Objective-C, Objective-C++のみ)}
@opindex Wif-not-aligned
@opindex Wno-if-not-aligned
@code{warn_if_not_aligned}属性によってトリガされる警告を発行するかどうかを制御する。 これはデフォルトで有効になっている。

@item -Wignored-qualifiers @r{(CとC++専用)}
@opindex Wignored-qualifiers
@opindex Wno-ignored-qualifiers
関数の戻り値が@code{const}のような型修飾子を持つなら警告する。ISO Cでは関数の戻り値は左辺値ではないので
そのような型修飾子には意味が無い。C++では、警告はスカラ型か@code{void}の時だけ発せられる。
ISO Cは関数定義で修飾された@code{void}戻り型を禁じているため、このオプション無しでもそのような戻り型はいつも警告を受ける。

この警告は@option{-Wextra}でも有効になる。

@item -Wignored-attributes @r{(CとC++専用)}
@opindex Wignored-attributes
@opindex Wno-ignored-attributes
属性が無視された時に警告する。これはコンパイラが属性を外すように決定したとき警告し、
属性が未知であるか、間違った場所で使われた時などではないことで@option{-Wattributes}とは異なる。これはデフォルトで有効である。

@item -Wmain
@opindex Wmain
@opindex Wno-main
@code{main}の型が疑わしいならば警告する。@code{main}は外部リンケージを持ち、intを返し、引数は適切な型の0、2、3個のどれかであるべきである。
この警告はC++ではデフォルトで有効で、@option{-Wall}か@option{-Wpedantic}のどちらかによって有効である。

@item -Wmisleading-indentation @r{(CとC++専用)}
@opindex Wmisleading-indentation
@opindex Wno-misleading-indentation
コードのインデントがブロック構造を反映していない時に警告する。特に、中括弧を使っていないガード文の@code{if}、@code{else}、@code{while}、@code{for}節に、
同じインデントの非ガード文が続く場合に警告する。

以下の例で、「bar」への呼び出しは「if」条件でガードされているかのように誤解を招くインデントをしている。

@smallexample
  if (some_condition ())
    foo ();
    bar ();  /* おっと、これは「if」でガードされていない  */
@end smallexample

タブとスペースが混合されている場合、警告は文が整列しているかどうかを決定するために@option{-ftabstop=}オプションを使う。（デフォルトは8）

警告は以下の例のような複数行プリプロセスロジックが関与している場合には警告しない。

@smallexample
  if (flagA)
    foo (0);
#if SOME_CONDITION_THAT_DOES_NOT_HOLD
  if (flagB)
#endif
    foo (1);
@end smallexample

警告は、@code{#line}ディレクトティブの後ろでは、それが典型的には自動生成されたコードを示し、
ディレクティブが参照するファイルのレイアウトについてのなんの仮定もできないために、警告は発せられない。

この警告はCとC++では@option{-Wall}で有効である。

@item -Wmissing-attributes
@opindex Wmissing-attributes
@opindex Wno-missing-attributes
関数の宣言に、関連する関数が宣言されている1つ以上の属性が欠落しており、その欠落が生成されたコードの正確性または効率に悪影響を与える可能性がある場合に警告します。 たとえば、属性を使用してターゲットの要件よりも制限の少ない要件を指定するエイリアスの宣言に対して警告が発行されます。
これは通常、潜在的な最適化の機会を表しています。
対照的に、@option{-Wattribute-alias=2}オプションは、エイリアスがターゲットよりも制限的である場合に発行される警告を制御します。これは、誤ったコード生成につながる可能性があります。
考慮される属性には、@code{alloc_align}、 @code{alloc_size}、@/
@code{cold}、 @code{const}、 @code{hot}、 @code{leaf}、 @code{malloc}、@/
@code{nonnull}、 @code{noreturn}、 @code{nothrow}、 @code{pure}、@/
@code{returns_nonnull}、 および@code{returns_twice}があります。

C++では、属性@code{alloc_align}、@code{alloc_size}、@code{assume_aligned}、@code{format}、@code{format_arg}、@code{malloc}、@code{nonnull}で宣言されたプライマリテンプレートの明示的な特殊化が宣言されていない場合に警告が発行されます。 属性@code{deprecated}、@code{error}、および@code{warning}は警告を抑制します。
(@pxref{Function Attributes}).

@code{copy}属性を使用して、属性を明示的に列挙せずに、別の宣言と同じ属性セットを宣言に適用できます。 この属性は、関数（@pxref{Common Function Attributes}）、変数（@pxref{Common Variable Attributes}）、または型（@pxref{Common Type Attributes}）の宣言に適用できます。

@option{-Wmissing-attributes}は@option{-Wall}によって有効化されます。

たとえば、以下のプライマリ関数テンプレートの宣言は属性@code{malloc}と@code{alloc_size}の両方を使用しているため、テンプレートの明示的な特殊化の宣言は、属性の1つがないため診断されます。

@smallexample
template <class T>
T* __attribute__ ((malloc, alloc_size (1)))
allocate (size_t);

template <>
void* __attribute__ ((malloc))   // missing alloc_size
allocate<void> (size_t);
@end smallexample

@item -Wmissing-braces
@opindex Wmissing-braces
@opindex Wno-missing-braces
集合か共用体初期化子が完全に括弧付けしていない場合に警告する。以下の例では、@code{a}は完全に括弧付けしていないが、
@code{b}は完全に括弧付けされている。この警告はCでは@option{-Wall}で有効である。

@smallexample
int a[2][2] = @{ 0, 1, 2, 3 @};
int b[2][2] = @{ @{ 0, 1 @}, @{ 2, 3 @} @};
@end smallexample

この警告は@option{-Wall}で有効である。

@item -Wmissing-include-dirs @r{(C、C++、Objective-C、Objective-C++専用)}
@opindex Wmissing-include-dirs
@opindex Wno-missing-include-dirs
ユーザの提供したincludeディレクトリが存在しない時警告する。

@item -Wmissing-profile
@opindex Wmissing-profile
@opindex Wno-missing-profile
@option {-fprofile-use}オプションの使用時にフィードバックプロファイルが欠落している場合に警告します。
このオプションは、プロファイルを再生成せずに、@option{-fprofile-generate}と@option{-fprofile-use}を使用してコンパイルする間に、新しい関数または新しいファイルがユーザーコードに追加される場合を診断します。 これらの場合、プロファイルフィードバックデータファイルには、それぞれ新しく追加された関数またはファイルのプロファイルフィードバック情報が含まれていません。 また、プロファイルカウントデータ（.gcda）ファイルが削除された場合、GCCはプロファイルフィードバック情報を使用できません。 これらのすべての場合、プロファイル生成ステップの期限が切れたことをユーザーに通知する警告が発行されます。 @option{-Wno-missing-profile}を使用して、
警告を無効にします。 警告を無視すると、コードの最適化が不十分になる可能性があります。
警告を完全に無効にすることはお勧めできません。存在しないプロファイルデータが正当化される場合にのみ実行する必要があります。

@item -Wno-mismatched-dealloc
@opindex Wmismatched-dealloc
@opindex Wno-mismatched-dealloc

前者が適切なデアロケーターではない割り当て関数から返されたポインター引数を使用して、割り当て解除関数を呼び出す場合に警告します。 関数のペアは、属性@code{malloc}を使用して、一致するアロケーターとデロケーターとして関連付けることができます。 @option{-fno-builtin}オプションで無効にされていない限り、標準関数@code{calloc}、@code{malloc}、@code{realloc}、@code{free}、および対応する形式のC++ @code{operator new}と@code{operator delete}は、一致するアロケーターとデアロケーターとして暗黙的に関連付けられています。 次の例では、@code{mydealloc}は@code{myalloc}から返されたポインターのデアロケーターです。

@smallexample
void mydealloc (void*);

__attribute__ ((malloc (mydealloc, 1))) void*
myalloc (size_t);

void f (void)
@{
  void *p = myalloc (32);
  // @dots{}use p@dots{}
  free (p);   // warning: not a matching deallocator for myalloc
  mydealloc (p);   // ok
@}
@end smallexample

C++では、関連するオプション@option{-Wmismatched-new-delete}は、@code{operator new}または@code{operator delete}のいずれかを含む不一致を診断します。

オプション@option{-Wmismatched-dealloc}はデフォルトで有効になっています。

@item -Wmultistatement-macros
@opindex Wmultistatement-macros
@opindex Wno-multistatement-macros
@code{if}、@code{else}、@code{for}、@code{switch}、または@code{while}などの節によって保護されているように見える安全でない複数ステートメントマクロについて警告します。 マクロが展開された後、最初のステートメントだけが実際に保護されます。

例えば、

@smallexample
#define DOIT x++; y++
if (c)
  DOIT;
@end smallexample

@code{c}が保持されているときだけでなく、無条件に@code{y}をインクリメントします。
通常、do-whileループでマクロをラップすることで修正できます。
@smallexample
#define DOIT do @{ x++; y++; @} while (0)
if (c)
  DOIT;
@end smallexample

この警告は、CおよびC++の@option{-Wall}によって有効になります。

@item -Wparentheses
@opindex Wparentheses
@opindex Wno-parentheses
真偽値が来た逸される文脈での代入、演算子が人々がしばしば混乱する優先順位で入れ子になっているなどのような文脈で、
括弧が省略されている場合に警告する。

@code{x<=t<=x}のような比較でも警告する。これは@code{x<=y ? 1 : 0) <= z}と等価であり、一般的な数学の表記の解釈とは異なる。

@code{?:}の第2項を省略するGNU拡張の危険な使い方も警告する。@code{?:}演算子の条件が真偽値の場合は、
省略された値は常に１である。しばしばプログラマは代わりに条件節内部で計算された値であることを期待する。

C++の場合、宣言で不要なかっこのいくつかの場合に警告される。これは宣言ではなく、関数呼び出しの試みを示しうる。

@smallexample
@{
  // Declares a local variable called mymutex.
  std::unique_lock<std::mutex> (mymutex);
  // User meant std::unique_lock<std::mutex> lock (mymutex);
@}
@end smallexample


この警告は@option{-Wall}で有効になる。

@item -Wsequence-point
@opindex Wsequence-point
@opindex Wno-sequence-point
CとC++標準の副作用完了点規則違反のために未定義の意味を持つかもしれないコードについて警告する。

CとC++標準はプログラムの部分の実行間の部分順序を表現する、@dfn{副作用完了点}の用語で、C/C++プログラムで
どの式が実行されるかの順番を定義している。副作用完了点の前に実行されるものと、その後に実行されるもの。
それらは完全式（より大きな式の一部でないもの）の実行の後、@code{%%}, @code{||}, @code{? :}, @code{,}(コンマ)演算子の後、
関数呼び出しの前（しかし、引数と呼ぶ関数を生成する式の後）、他の幾つかの場所の後である。
副作用完了点規則で表現されたものの他には、表現の部分式の評価の順序は、指定されない。すべてのこれらの規則は完全な順序ではなく
部分的な順序だけを記述し、例えば、2つの関数がそれらの間で副作用完了点がない一つの式内で呼ばれるならば、関数が呼ばれる順序は指定されない。
しかし、標準委員会は、関数呼び出しが重ならないと決定した。

オブジェクトの値への修正がいつシーケンス点の間で実施されるかは指定されない。ふるまいがこれに依存するプログラムは、未定義ふるまいをする;
「前で次の副作用完了点の間で、オブジェクトはその保存された値を式の評価によって最高でも一度だけ修正する。さらに古い値は、
格納される値を決定するためだけに読まれる」ことを、CとC++標準は、示している。プログラムがこれらの規則を破るならば、
どんな特定の実装の結果でもまったく予測できない。

未定義の振る舞いのコードの例は、@code{a = a++;}, @code{a[n] = b[n++]}, @code{a[i++] = i;}などである。
もっと複雑なあるケースはこのオプションによって診断されず、それは時折の偽陽性結果を与えるかもしれないが、
一般に、プログラムでこの種類の問題を見つけることでかなり効果的であるとわかった。

C++17標準は大抵の場合でのオペランドの評価の順序を定義する予定である。特に、代入の右辺値は左辺値より前に
評価されることを要求するので、上の例はもはや未定義ではない。しかし、この警告は、人々がCとC++の以前の版で未定義である
コード書くのを避けるのを避けるためにまだ警告するだろう。

標準は紛らわしく言い表される、したがって、副作用完了点規則の正確な意味についてのある議論が微妙なケースにある。
@uref{http://gcc.gnu.org/@/readings.html}でのGCCの読本ページで、問題（提案された正式な定義を含む）に関する議論との関連は見つかるかもしれない

この警告はCとC++で@option{-Wall}で有効である。

@item -Wno-return-local-addr
@opindex Wno-return-local-addr
@opindex Wreturn-local-addr
関数が帰ったあとでスコープから出るポインタ（およびC++での参照）を返すことについて警告しない。

@item -Wreturn-type
@opindex Wreturn-type
@opindex Wno-return-type
関数が戻り値がデフォルトの@code{int}で定義されていると警告する。戻り値型が@code{void}でない関数で
の戻り値なしの@code{return}文（関数の本体の最後で抜けるのは戻り値なしで返るとみなされる）も警告する。

Cのみでは、戻り型が@code{void}である関数内の式つきの@code{return}文を、式の型も@code{void}出ない限りは
警告する。GNU拡張として、後者の場合は@option{-Wpedantic}が使われない限り警告なしで受理される。

Cとは異なり、C++では、@code{main}以外の@code{void}以外の関数の末尾からフローすると、関数の値が使用されていない場合でも未定義の動作が発生します。

この警告はC++ではデフォルトで有効であり、@option{-Wall}で有効になる。

@item -Wno-shift-count-negative
@opindex Wshift-count-negative
@opindex Wno-shift-count-negative
シフト数が負ならば警告する。この警告はデフォルトで有効である。

@item -Wno-shift-count-overflow
@opindex Wshift-count-overflow
@opindex Wno-shift-count-overflow
シフト数が型の幅以上ならば警告する。この警告はデフォルトで有効である。

@item -Wshift-negative-value
@opindex Wshift-negative-value
@opindex Wno-shift-negative-value
負数を左シフトすると警告する。この警告はC99とC++11モード（以降）で@option{-Wextra}で有効である。

@item -Wno-shift-overflow
@itemx -Wshift-overflow=@var{n}
@opindex Wshift-overflow
@opindex Wno-shift-overflow
左シフトオーバーフローについて警告する。これはC99とC++11モード（以降）でデフォルトで有効である。

@table @gcctabopt
@item -Wshift-overflow=1
これは@option{-Wshift-overflow}の警告レベルであり、C99およびC++11モード（およびそれ以降）ではデフォルトで有効になっています。 この警告レベルは、1を符号ビットに左シフトすることについて警告しません。 （ただし、Cでは、整数定数式が必要なコンテキストでは、このようなオーバーフローは引き続き拒否されます。）C++20モード（およびそれ以降）では、符号付き左シフトが常に折り返されるため、警告は発行されません。

@item -Wshift-overflow=2
これはC++14モード（以降）がアクティブでないかぎりは、符号ビットへの左１シフトについても警告する。
@end table

@item -Wswitch
@opindex Wswitch
@opindex Wno-switch
@code{switch}文が列挙型の添字を持ち、列挙の名前付きコードの１つ以上の@code{case}が欠けていると警告する。
（@code{default}ラベルがあるとこの警告を出さない）列挙範囲の外側の@code{case}ラベルもこのオプションが使われた時には
（@code{default}ラベルがあったとしても）警告を出す。
この警告は@option{-Wall}で有効である。

@item -Wswitch-default
@opindex Wswitch-default
@opindex Wno-switch-default
@code{switch}文が@code{default}の場合がない場合にいつも警告する。

@item -Wno-switch-bool
@opindex Wswitch-bool
@opindex Wno-switch-bool
@code{switch}文が列挙型の添字を持ち、列挙の名前付きの１つ以上の@code{case}が欠けている時にいつも警告する。
このオプションが使われた時は列挙範囲の外の@code{case}ラベルも警告を発する。このオプションと@option{-Wswitch}との唯一の違いは
たとえ@code{default}ラベルがあったとしても省略された列挙コードの警告を発することである。

@item -Wswitch-bool
@opindex Wswitch-bool
@opindex Wno-switch-bool
@code{switch}文が真偽値型の添字を取り、ケース値が真偽値の範囲外の場合にいつも警告する。@code{bool}以外の型へ条件式をキャスト
することでこの警告を抑制できる。例えば、
@smallexample
@group
switch ((int) (a == 4))
  @{
  @dots{}
  @}
@end group
@end smallexample
この警告はCとC++のプログラムでデフォルトで有効である。

@item -Wno-switch-outside-range
@opindex Wswitch-outside-range
@opindex Wno-switch-outside-range
このオプションは、@code{switch}ケースにそれぞれのタイプの範囲外の値がある場合の警告を制御します。 この警告は、CおよびC++プログラムではデフォルトで有効になっています。

@item -Wno-switch-unreachable
@opindex Wswitch-unreachable
@opindex Wno-switch-unreachable
@code{switch}文が制御式と最初のcaseラベルの間に文を含むときに警告する。それは決して実行されない。
例えば、
@smallexample
@group
switch (cond)
  @{
   i = 15;
  @dots{}
   case 5:
  @dots{}
  @}
@end group
@end smallexample
@option{-Wswitch-unreachable}は制御式と最初のcaseラベルの間の文が単なる宣言の場合には警告しない。
@smallexample
@group
switch (cond)
  @{
   int i;
  @dots{}
   case 5:
   i = 5;
  @dots{}
  @}
@end group
@end smallexample
この警告はCとC++プログラムではデフォルトで有効である。

@item -Wsync-nand @r{(CとC++専用)}
@opindex Wsync-nand
@opindex Wno-sync-nand
@code{__sync_fetch_and_nand}と@code{__sync_nand_and_fetch}組み込み関数が使われた時に警告する。これらの関数はGCC4.4で意味が変わった。

@item -Wunused-but-set-parameter
@opindex Wunused-but-set-parameter
@opindex Wno-unused-but-set-parameter
代入されたが、（宣言の他に）他の場所で使われていない関数パラメータについて警告する。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

この警告は@option{-Wextra}と一緒の@option{-Wunused}で有効である。


@item -Wunused-but-set-variable
@opindex Wunused-but-set-variable
@opindex Wno-unused-but-set-variable
局所変数が代入されたが、（宣言の他に）他の場所で使われていないと警告する。
この警告は@option{-Wall}で有効である。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

この警告は@option{-Wunused}で有効であり、それは@option{-Wall}で有効になる。

@item -Wunused-function
@opindex Wunused-function
@opindex Wno-unused-function
静的関数が宣言されたが定義されていないか、非インラインの静的関数が使われていない時に警告する。
この警告は@option{-Wall}で有効である。

@item -Wunused-label
@opindex Wunused-label
@opindex Wno-unused-label
ラベルが宣言されたが使われていない時に警告する。
この警告は@option{-Wall}で有効である。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@item -Wunused-local-typedefs @r{(C, Objective-C, C++, Objective-C++専用)}
@opindex Wunused-local-typedefs
typedefが関数内で局所的に宣言されたが使われていない時に警告する。
この警告は@option{-Wall}で有効である。

@item -Wunused-parameter
@opindex Wunused-parameter
@opindex Wno-unused-parameter
関数パラメータが宣言の他には使われていない時に警告する。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@item -Wno-unused-result
@opindex Wunused-result
@opindex Wno-unused-result
@code{warn_unused_result} (@pxref{Function Attributes})属性をマークされた
関数の呼び出し元で戻り値が使われていない時に警告しない。デフォルトは@option{-Wunused-result}である。

@item -Wunused-variable
@opindex Wunused-variable
@opindex Wno-unused-variable
局所か静的変数が宣言の他に使われていない時に警告する。これはCでは@option{-Wunused-const-variable=1}を含むが
C++では含まない。この警告は@option{-Wall}で有効になる。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@item -Wunused-const-variable
@itemx -Wunused-const-variable=@var{n}
@opindex Wunused-const-variable
@opindex Wno-unused-const-variable
定数静的変数が宣言の他に使われていない時にいつも警告する。@option{-Wunused-const-variable=1}は
Cでは@option{-Wunused-variable}の時に有効であるが、C++では異なる。Cではこれは変数領域を宣言するが、
C++では定数変数が@code{#define}を置き換えたのでエラーではない。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@table @gcctabopt
@item -Wunused-const-variable=1
これはCでは@option{-Wunused-variable}によって有効にされる警告レベルである。
主要コンパイル単位で定義された未使用の静的定数変数についてのみ警告し、includeされたヘッダ
で宣言された静的定数変数は警告しない。

@item -Wunused-const-variable=2
これはヘッダ（システムヘッダを除く）で宣言された未使用の定数静的変数にも警告する。これは
@option{-Wunused-const-variable}の警告レベルであり、C++ではエラーではなく、
Cでも含まれる全てのヘッダを掃除するのは困難なので明示的に要求しなければならない。
@end table

@item -Wunused-value
@opindex Wunused-value
@opindex Wno-unused-value
式が明示的に使われていない結果しているときにいつも警告する。この警告を抑制するには
未使用の式を@code{void}にキャストする。これは式文と、副作用を持たないコンマ式の左辺を含む。
例えば、@code{x[i,j]}のような式は警告を発するが、@code{x[(void)i,j]}はしない。

この警告は@option{-Wall}で有効になる。

@item -Wunused
@opindex Wunused
@opindex Wno-unused
上の全ての@option{-Wunused}オプションを組み合わせる。

未使用の関数パラメータについて警告するには、@option{-Wextra -Wunused}を指定するか
（@option{-Wall}は@option{-Wunused}を含む）、別に@option{-Wunused-parameter}を指定する。

@item -Wuninitialized
@opindex Wuninitialized
@opindex Wno-uninitialized
自動変数が最初に初期化されずに使われるか、変数が@code{setjmp}の呼び出しで破壊されるかも知れない
時に警告する。C++では、非静的参照か非静的@code{const}メンバがコンストラクタのないクラスに
現れるときに警告する。

さらに、初期化されていないオブジェクトへのポインタ（またはC++では参照）を、オブジェクトを読み取ることがわかっている組み込み関数の@code{const}修飾引数に渡すこともこの警告によって診断されます。
（@option{-Wmaybe-uninitialized}は通常の関数に対して発行されます。）

もし変数の未初期化値を初期化子で使うコードについて警告したいなら、@option{-Winit-self}オプション
を使う。

これらの警告は全体として未初期化・破壊される変数と同様に、構造体、共用体、配列変数の個々の
未初期化・破壊される要素にも起こる。@code{volatile}と宣言されている変数や要素には起こらない。
それらの警告は最適化に依存しているので、警告が起こる正確な変数および要素は正確な最適化オプションと
使われたGCCはのバージョンに依存する。

計算に使われるがそれ自身は一度も使われない変数は、そのような計算が警告が出力される前にデータフロー解析で
削除されるかもしれないため、警告されないかもしれないことに注意する。

@item -Wno-invalid-memory-model
@opindex Winvalid-memory-model
@opindex Wno-invalid-memory-model
操作が無効であるか@code{memory_order}列挙の値の範囲外であるメモリ一貫性引数を持つ
@ref{__atomic Builtins}, @ref{__sync Builtins}の呼び出しと、C11アトミック汎用関数を警告する。
例えば、@code{__atomic_store}と@code{__atomic_store_n}組み込みはリラックス、リリース、
経時的に一貫性のメモリ順序で定義されているので、以下のコードは診断される。

@smallexample
void store (int *i)
@{
  __atomic_store_n (i, 0, memory_order_consume);
@}
@end smallexample

@option{-Winvalid-memory-model}はデフォルトで有効である。

@item -Wmaybe-uninitialized
@opindex Wmaybe-uninitialized
@opindex Wno-maybe-uninitialized
自動もしくか割り当てられた領域の期間の変数で、関数の入り口から初期化されている変数の使用までの経路があるが、変数が初期化されない
他の経路があるならば、コンパイラは未初期化の経路が実行時に実行されないことが証明できないならば警告を発する。

さらに、初期化されていないオブジェクトへのポインタ（またはC++では参照）を@code{const}で修飾された関数の引数に渡すことも、この警告によって診断されます。 （@option{-Wuninitialized}は、オブジェクトを読み取ることがわかっている組み込み関数に対して発行されます。）属性@code{access(none)}で関数に注釈を付けると、引数がオブジェクトへのアクセスに使用されないことを示し、警告を回避します。 （@pxref{Common Function Attributes}）。

これらの警告は最適化コンパイルでのみ可能である。なぜならさもなければGCCは変数の状態を追わないからである。

これらの警告はGCCがコードがエラーに見えるがコードが正しいかもしれない理由全てを見れるほど賢くないので、オプションである。ここでこれが起こる一つの例がある。

@smallexample
@group
@{
  int x;
  switch (y)
    @{
    case 1: x = 1;
      break;
    case 2: x = 4;
      break;
    case 3: x = 5;
    @}
  foo (x);
@}
@end group
@end smallexample

@noindent
もし@code{y}の値が常に1, 2, 3のどれかならば、@code{x}は常に初期化されるが、GCCは知ることができない。
警告を抑制するためには、assert(0)か同等のdefaultケースを提供する必要がある。

@cindex @code{longjmp} warnings
このオプションは非volatileの自動変数が@code{longjmp}への呼び出しで変更されるかもしれないときにも警告する。
コンパイラは@code{setjmp}への呼び出しのみが見える。どこで@code{longjmp}が呼ばれるかを知ることができない。
実際、シグナルハンドラはコードの任意の点で呼びうる。結果として、@code{longjmp}が実際には問題を起こす
場所で呼ぶことができないので問題がないときでも警告を得るかもしれない。

いくつかの疑わしい警告は使う全ての決して返らない関数を@code{noreturn}と宣言すれば避けることができる。
@xref{Function Attributes}.

この警告は@option{-Wall}か@option{-Wextra}で有効になる。

@item -Wunknown-pragmas
@opindex Wunknown-pragmas
@opindex Wno-unknown-pragmas
@cindex warning for unknown pragmas
@cindex unknown pragmas, warning
@cindex pragmas, warning of unknown
GCCが理解できない@code{#pragma}ディレクティブに出会ったら警告する。もしこのコマンドラインオプション
が使われたら、システムヘッダファイルの未知のプラグまでも警告を出す。これは@option{-Wall}コマンドラインオプション
によってのみ有効になるケースとは異なる。

@item -Wno-pragmas
@opindex Wno-pragmas
@opindex Wpragmas
正しくないパラメータ、不正の構文、プラグマ間の矛盾のようなプラグマの不正利用について警告しない。
@option{-Wunknown-pragmas}.

@item -Wno-prio-ctor-dtor
@opindex Wno-prio-ctor-dtor
@opindex Wprio-ctor-dtor
コンストラクターまたはデストラクターに0から100までの優先順位が使用されている場合、警告しません。コンストラクター属性とデストラクター属性を使用すると、コンストラクター/デストラクターに優先順位を割り当てて、@code{main}が呼び出される前または戻った後の実行順序を制御できます。 コンパイラーは実装のために0から100の間の優先順位値を予約しているため、優先順位値は100より大きくなければなりません。

@item -Wstrict-aliasing
@opindex Wstrict-aliasing
@opindex Wno-strict-aliasing
このオプションは@option{-fstrict-aliasing}が有効の時だけ有効である。
コンパイラが最適化に使う厳密なエイリアス規則を破るかもしれないコードについて警告する。
警告は全場合を捕まえるわけではないが、より多くの一般的な落とし穴を捕まえようとする。
これは@option{-Wall}に含まれている。

これは@option{-Wstrict-aliasing=3}と等価である。

@item -Wstrict-aliasing=n
@opindex Wstrict-aliasing=n
このオプションは@option{-fstrict-aliasing}が有効の時だけ有効である。
コンパイラが最適化に使う厳密なエイリアス規則を破るかもしれないコードについて警告する。
高いレベルは高い正確性（より少ない偽陽性）に対応している。高いレベルはより多くの努力にも対応し、
@option{-O}と同様の働きをする。
@option{-Wstrict-aliasing}は@option{-Wstrict-aliasing=3}と等価である。

レベル１：最も積極的で、素早く、最も正確でない。
最も少ない偽陰性なので、高いレベルが警告しないが@option{-fstrict-aliasing}がまだコードを壊す場合に
多分役立つ。しかし、多数の偽陽性を持つ。
非互換の可能性のある型同士の全てのポインタ変換、たとえ一度も被参照されなくても警告する。フロントエンドのみで動く。

レベル２：積極的で、素早く、あまり正確でない。
まだ多くの偽陽性があるかもしれない（しかしレベル１ほどではない）。偽陰性は少ない（しかし多分レベル１よりは多い）。
レベル１とは異なり、アドレスが取れらた場所でのみ警告する。非完全型について警告する。フロントエンドのみで動く。

レベル３（@option{-Wstrict-aliasing}のデフォルト）：
偽陽性がとても少なく、偽陰性も少ないはずである。最適化が有効になっている時はレベル１、２よりもかなり遅い。
フロントエンドで共通の別名化＋被参照パターンの場合を拾う。@code{*(int*)&some_float}。
最適化が有効ならば、バックエンドでも動き、フロー依存の点への情報を使って複数の分の場合を扱う。
変換されたポインタが被参照された場合のみ警告する。
非完全型には警告しない。

@item -Wstrict-overflow
@itemx -Wstrict-overflow=@var{n}
@opindex Wstrict-overflow
@opindex Wno-strict-overflow
このオプションは符号付きの桁溢れが未定義の場合のみ有効である。コンパイラが符号付き桁溢れが
起こらないと仮定して最適化した場合について警告する。コードが桁溢れするかもしれない場所全てを警告するわけではない
ことに注意する。コンパイラが最適化を実装している場所のケースのみを警告する。したがってこの警告は最適化レベル
に依存する。

符号つき桁溢れが起こらないという過程する最適化はもし関与した変数の値は実際に決して桁溢れを起こさないならば
完全に安全である。したがってこの警告は容易に偽陽性を与えうる。実際には問題ではないコードの警告。
重要な問題に集中するのを助けるために、いくつかの警告レベルが定義されている。ループが何回回るか見積もる時の
未定義の符号付き桁溢れは、時にループがそもそも事項するかどうかを判断する時は警告しない。

@table @gcctabopt
@item -Wstrict-overflow=1
疑わしく、かつ安易に避けられる場合について警告する。例えば、
@code{x + 1 > x}を@code{1}に単純化する。この@option{-Wstrict-overflow}のレベルは
は@option{-Wall}で有効になる。より高いレベルは有効にならないので、明示的に要求しなければならない。

@item -Wstrict-overflow=2
比較が定数へと単純化される場所の他のケースで警告する。例えば、@code{abs (x) >= 0}である。
これは符号付きの桁溢れが未定義の時だけ単純化される。なぜなら、@code{abs (INT_MIN)}は
@code{INT_MIN}へと桁溢れし、0より小さい。@option{-Wstrict-overflow} （レベルなし）は
@option{-Wstrict-overflow=2}と同じである。

@item -Wstrict-overflow=3
比較が単純化される他の例についても警告する。例えば、@code{x + 1 > 1}は@code{x > 0}へと単純化される。

@item -Wstrict-overflow=4
上の例でカバーされない他の単純化についても警告する。例えば、@code{(x * 10) / 5}は@code{x * 2}
へと単純化される。

@item -Wstrict-overflow=5
コンパイラが比較での定数の強度を削減した場合について警告する。例えば、@code{x + 2 > y}は
@code{x + 1 >= y}へと単純化される。これはこの単純化が多くの比較に適用され、多数の偽陽性
を与えるために、最高の警告レベルでのみ警告される。
@end table

@item -Wstring-compare
@opindex Wstring-compare
@opindex Wno-string-compare
ひとつの引数の長さが他方の引数が格納されている配列のサイズ（もしくは@code{strncmp}の場合には境界）よりも大きいために、そのような等価に対する検査でゼロであるか非ゼロであるかが決定できるような@code{strcmp}と@code{strncmp}への呼び出しに対して警告します。 たとえば、以下の@code{strcmp}の呼び出しは、配列@code{a}の内容に関係なく、その結果が必ずゼロ以外になるため、診断されます。

@smallexample
extern char a[4];
void f (char *d)
@{
  strcpy (d, "string");
  @dots{}
  if (0 == strcmp (a, d))   // cannot be true
    puts ("a and d are the same");
@}
@end smallexample

@option{-Wstring-compare}は@option{-Wextra}で有効になります。

@item -Wno-stringop-overflow
@item -Wstringop-overflow
@itemx -Wstringop-overflow=@var{type}
@opindex Wstringop-overflow
@opindex Wno-stringop-overflow
出力バッファを溢れさせると判断された@code{memcpy}や@code{strcpy}のような文字列操作関数の呼び出し
について警告する。余分な引数は出力先のサイズを決定するために実行するObject Size Checkingの種類よりも
１大きい。 @xref{Object Size Checking}.
引数は、文字配列での操作を行うが関数でのみ意味を持つが、@code{memcpy}のような生メモリ関数は、オブジェクトサイズ
タイプ0をいつも使うので意味を持たない。オプションは、最大の可能なオブジェクトか多くても@code{SIZE_MAX / 2}バイト
を超えてサイズを指定した呼び出しにも警告する。オプションは最適化が利用可能なときに最高の結果を生むが、
最適化なしでも標準関数に対応する@code{__builtin_memcpy}のようなGCCの組み込み関数の呼び出しでも検出する。
どんな場合でも、このオプションは対応するオーバーフローチェック組み込み関数によって検出される
バッファオーバーフローの単なるサブセットについて警告する。例えば、このオプションは
以下の@code{strcpy}呼び出しを、少なくとも5文字（文字列@code{"blue"}と末端のNUL）をサイズ４のバッファにコピーするので
警告を発する。

@smallexample
enum Color @{ blue, purple, yellow @};
const char* f (enum Color clr)
@{
  static char buf [4];
  const char *str;
  switch (clr)
    @{
      case blue: str = "blue"; break;
      case purple: str = "purple"; break;
      case yellow: str = "yellow"; break;
    @}

  return strcpy (buf, str);   // warning here
@}
@end smallexample

オプション@option{-Wstringop-overflow=2}はデフォルトで有効である。
@end table

@table @gcctabopt
@item -Wstringop-overflow
@itemx -Wstringop-overflow=1
@opindex Wstringop-overflow
@opindex Wno-stringop-overflow
@option{-Wstringop-overflow=1}オプションは、タイプ0のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。これはオプションのデフォルト設定である。
この設定では、最大のサブオブジェクトのサイズがわかっていない限り、ポインターによってアクセスされる大きなオブジェクトのサブオブジェクトの末尾を越える書き込みについて警告しない。
宛先が複数のオブジェクトのうちの1つである場合、それらの中で最大のものとみなされる。
Linuxシステムでは、この設定で最適化を有効にすると、@code{_FORTIFY_SOURCE}マクロがゼロ以外の値に定義されているときと同じコードが警告される。

@item -Wstringop-overflow=2
@option{-Wstringop-overflow=2}オプションは、タイプ1のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。この設定では、正確なサイズがわかっている最大の完全オブジェクトのメンバーに書き込むときに、オーバーフローに関する警告が表示される。ただし、未知の要素数を含む配列を指している可能性があるため、ポインタによって参照される未知のオブジェクトの同じメンバーへの過剰な書き込みについて警告しない。

@item -Wstringop-overflow=3
@option{-Wstringop-overflow=3}オプションは、タイプ2のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。この設定では、最小のオブジェクトまたはデータメンバーのオーバーフローに関する警告が表示される。これは、安全なコードを警告するオプションの重要な制限設定である。

@item -Wstringop-overflow=4
@option{-Wstringop-overflow=4}オプションは、タイプ3のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。この設定では、データメンバーのオーバーフローに関する警告が表示され、宛先が複数のオブジェクトのいずれかである場合は、最大のサイズを使用して警告を出すかどうかを決定する。@option{-Wstringop-overflow=3}と同様に、このオプションの設定により、良質なコードの警告が発生する可能性があります。

@item -Wno-stringop-truncation
@opindex Wstringop-truncation
@opindex Wno-stringop-truncation
@code{strncat}、@code{strncpy}、@code{stpncpy}など、コピーされた文字列を切り捨てるか、宛先を変更しないままにする可能性のある、境界付き文字列操作関数の呼び出しについて警告しません。

次の例では、@code{strncat}の呼び出しで、ソース文字列の長さより短い境界が指定されています。 その結果、ソースのコピーが切り捨てられるため、呼び出しが診断されます。 警告を回避するには、@code{bufsize-strlen (buf) -1}を境界として使用します。

@smallexample
void append (char *buf, size_t bufsize)
@{
  strncat (buf, ".txt", 3);
@}
@end smallexample

別の例として、次の@code{strncpy}の呼び出しは、末尾にNULを追加することなく、終了NULの前の文字だけを@code{d}にコピーします。 @code{strncpy}の結果が必然的にNULで終了する文字列であると仮定することはよくある間違いであるため、呼び出しは診断されます。 結果がNULで終了すると予想されない場合の警告を回避するには、代わりに@code{memcpy}を呼び出します。

@smallexample
void copy (char *d, const char *s)
@{
  strncpy (d, s, strlen (s));
@}
@end smallexample

次の例では、@code{strncpy}の呼び出しで、宛先バッファのサイズを境界として指定しています。 ソース文字列の長さがこのサイズ以上の場合、コピーの結果はNULで終了しません。 したがって、コールも診断されます。 警告を避けるには、@code{sizeof buf-1}を境界として指定し、バッファーの最後の要素を@code{NUL}に設定します。

@smallexample
void copy (const char *s)
@{
  char buf[80];
  strncpy (buf, s, sizeof buf);
  @dots{}
@}
@end smallexample

文字配列が終了@code{NUL}なしでバイトシーケンスを格納することを意図している状況では、この警告を回避するために、配列に属性@code{nonstring}で注釈を付けることができます。 ただし、そのような配列は、@code{NUL}で終了する文字列を期待する関数の適切な引数ではありません。 そのような配列の偶発的な誤用の検出を支援するために、GCCは、使用が安全であると証明できる場合を除き、警告を発行します。@xref{Common Variable Attributes}.

@item -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}cold@r{|}malloc@r{]}
@opindex Wsuggest-attribute=
@opindex Wno-suggest-attribute=
属性を加えることが有用かもしれない場合について警告する。現在サポートされている属性は以下に並べられている。

@table @gcctabopt
@item -Wsuggest-attribute=pure
@itemx -Wsuggest-attribute=const
@itemx -Wsuggest-attribute=noreturn
@itemx -Wmissing-noreturn
@itemx -Wsuggest-attribute=malloc
@opindex Wsuggest-attribute=pure
@opindex Wno-suggest-attribute=pure
@opindex Wsuggest-attribute=const
@opindex Wno-suggest-attribute=const
@opindex Wsuggest-attribute=noreturn
@opindex Wno-suggest-attribute=noreturn
@opindex Wmissing-noreturn
@opindex Wno-missing-noreturn
@opindex Wsuggest-attribute=malloc
@opindex Wno-suggest-attribute=malloc

属性@code{pure}、@code{const}、@code{noreturn}または@code{malloc}の候補であるかもしれない関数について警告する。コンパイラは他のコンパイル単位で見える関数にだけ、あるいは（@code{pure}と@code{const}の場合）
関数は通常戻ると証明できないならば警告する。それが無限のループを含まないか、例外を投げるか、
@code{abort}を呼ぶか、トラップを呼ぶことによって異常に帰らことがないならば、関数は通常に戻る。
この解析はオプション@option{-fipa-pure-const}を必要とする。そして、それは@option{-O}以上で
デフォルトで使用可能にされる。より高い最適化レベルは、解析の正確さを改善する。

@item -Wsuggest-attribute=format
@itemx -Wmissing-format-attribute
@opindex Wsuggest-attribute=format
@opindex Wmissing-format-attribute
@opindex Wno-suggest-attribute=format
@opindex Wno-missing-format-attribute
@opindex Wformat
@opindex Wno-format

@code{format}属性の候補であるかもしれない関数ポインタについて警告する。
これらが考えられる候補だけであって、絶対のものでない点に注意する。
結果として生じるものの属性が型に対応する@code{format}を、代入、初期化、パラメータ渡し、return文において使われる@code{format}属性による関数ポインタが持つべきであると、GCCは推測する。
すなわち：警告を避けるためには、代入または初期化の左側、パラメータ変数の型、
含んでいる関数の型がそれぞれ@code{format}を持つべきである。

@code{format}属性の候補であるかもしれない関数定義についても、GCCは警告する。
再び、これらは考えられる候補だけである。@code{vprintf}または@code{vscanf}のような関数を呼ぶ
どんな関数でも、@code{format}属性が適切かもしれないと、GCCは推測する、しかし、
これは必ずしも本当でないかもしれない、そして、@code{format}属性が適切であるある関数は
見つけられないかもしれない。

@item -Wsuggest-attribute=cold
@opindex Wsuggest-attribute=cold
@opindex Wno-suggest-attribute=cold

@code{cold}属性の候補となる可能性がある関数について警告する。 これは静的な検出に基づいており、一般的にはC++の@code{throw}のラッパーや@code{abort}につながる致命的なエラー報告関数のような別の@code{cold}関数への呼び出しにつながる関数についてのみ警告する。

@end table

@item -Walloc-zero
@opindex Wno-alloc-zero
@opindex Walloc-zero
組み込み形式の関数@code{aligned_alloc}、@code{alloca}、@code{calloc}、@code{malloc}と@code{realloc}含め、属性@code{alloc_size}で装飾された割り当て関数へのゼロバイトを指定した呼び出しについて警告する。これらの関数のサイズがゼロで呼び出されたときの動作は実装によって異なる（@code{realloc}の場合は廃止された）ので、それに頼ると微妙な移植性のバグが生じる可能性があるので避けるべきである。

@item -Walloc-size-larger-than=@var{byte-size}
@opindex Walloc-size-larger-than=
@opindex Wno-alloc-size-larger-than
指定されたバイト数よりも大きいオブジェクトを割り当てようとする属性@code{alloc_size}で装飾された関数の呼び出し、または無限精度の整数型でのサイズ計算の結果がターゲットでの@samp{PTRDIFF_MAX}の値を超える場合に警告します。
@option{-Walloc-size-larger-than=}@samp{PTRDIFF_MAX}はデフォルトで有効になっています。
オプションによって制御される警告は、@samp{SIZE_MAX}以上の@var{byte-size}を指定するか、@ option{-Wno-alloc-size-larger-than}によって無効にできます。
@xref{Function Attributes}.

@item -Wno-alloc-size-larger-than
@opindex Wno-alloc-size-larger-than
@option{-Walloc-size-larger-than =}警告を無効にします。 このオプションは、@option{-Walloc-size-larger-than=}@samp{SIZE_MAX}以上と同等です。

@item -Walloca
@opindex Wno-alloca
@opindex Walloca
このオプションはソースでの@code{alloca}の全使用を警告する。

@item -Walloca-larger-than=@var{byte-size}
@opindex Walloca-larger-than=
@opindex Wno-alloca-larger-than
このオプションは、整数型の引数を多くても@var{byte-size}バイトに制限する制御述語によって制限されない@code{alloca}への呼び出し、またはバインドが未知の@code{alloca}への呼び出しを警告しり。
非整数型の引数は、期待される範囲に制約されているように見えても、無制限と見なされます。

例えば、@code{alloca}の制限された場合は以下のようである。

@smallexample
void func (size_t n)
@{
  void *p;
  if (n <= 1000)
    p = alloca (n);
  else
    p = malloc (n);
  f (p);
@}
@end smallexample

上の例で、@code{-Walloca-larger-than=1000}を渡しても@code{alloca}への呼び出しが多くても1000バイトであると既知なので警告を発しない。しかし、@code{-Walloca-larger-than=500}が渡されたとすると、コンパイラは警告を発するだろう。

一方、制限なしの場合は、整数を制限する制御述語なしでの@code{alloca}の使用である。例えば、

@smallexample
void func ()
@{
  void *p = alloca (n);
  f (p);
@}
@end smallexample

もし、@code{-Walloca-larger-than=500}が渡されたとすると、上は警告を発するが、今回は範囲チェックの欠如のためである。

注意として、一見正しくは符号付き整数を含むコードでも警告を発する：

@smallexample
void func (signed int n)
@{
  if (n < 500)
    @{
      p = alloca (n);
      f (p);
    @}
@}
@end smallexample

上の例では、@var{n}は負になりうるので、@code{alloca}呼び出しへの暗黙のキャストによって予測された
引数よりも大きくなる。

このオプションは、ループ内で@code{alloca}が使われたときも警告する。

このオプションは@option{-Wall}では有効にならず、@option{-ftree-vrp}が活性（@option{-O2}以上でのデフォルト）のときのみ活性になる。

@option{-Wvla-larger-than=}@samp{byte-size}も見よ。

@item -Wno-alloca-larger-than
@opindex Wno-alloca-larger-than
@option{-Walloca-larger-than=}の警告を無効にします。 このオプションは、@option{-Walloca-larger-than=}@samp{SIZE_MAX}以上と同等です。

@item -Warith-conversion
@opindex Warith-conversion
@opindex Wno-arith-conversion
オペランドを同じ型に変換しても値を変更できない場合でも、算術演算からの暗黙的な変換について警告します。 これは、@option{-Wconversion}、@option{-Wfloat-conversion}、および@option{-Wsign-conversion}からの警告に影響します。

@smallexample
@group
void f (char c, int i)
@{
  c = c + i; // warns with @option{-Wconversion}
  c = c + 1; // only warns with @option{-Warith-conversion}
@}
@end group
@end smallexample

@item -Warray-bounds
@itemx -Warray-bounds=@var{n}
@opindex Wno-array-bounds
@opindex Warray-bounds
このオプションは@option{-ftree-vrp}が有効で(@option{-O2}以上のデフォルト)の時のみ有効である。
配列の添字が常に範囲外の時に警告する。このオプションは@option{-Wall}で有効になる。

@table @gcctabopt
@item -Warray-bounds=1
これは@option{-Warray-bounds}の警告レベルであり、@option{-Wall}で有効になる。より高いレベルは
ならないので、明示的に要求しなければならない。

@item -Warray-bounds=2
この警告は構造体の終わりの配列とポインタ経由でアクセスされる配列の境界外アクセスについても警告する。
これは多数の偽陽性を与えるかもしれず、デフォルトで無効にされる。
@end table

@item -Warray-parameter
@itemx -Warray-parameter=@var{n}
@opindex Wno-array-parameter
一貫性のない種類または形式の配列またはポインター型の引数を含む関数の再宣言について警告し、@option{-Warray-bounds}などの警告によってそのようなパラメーターへの範囲外アクセスの検出を有効にします。

最初の関数宣言が配列形式を使用する場合、配列で指定された境界は、関数の呼び出しで提供されると予想される要素の最小数と、関数によってアクセスされる要素の最大数であると見なされます。 十分なサイズの引数を提供しなかったり、最大数を超える要素にアクセスしたりすると、@ option{-Warray-bounds}などの警告によって診断される場合があります。 レベル1では、警告は@code{T [static N]}形式を使用して宣言された配列パラメーターに関連する不整合を診断します。

たとえば、警告は次の再宣言のトリガーになります。これは、最初の宣言では任意のサイズの配列を@code{f}に渡すことができ、2番目の宣言ではキーワード@code{static}を使用すると、配列引数には、少なくとも4つの要素が必要だと宣言しています。

@smallexample
void f (int[static 4]);
void f (int[]);           // warning (inconsistent array form)

void g (void)
@{
  int *p = (int *)malloc (4);
  f (p);                  // warning (array too small)
  @dots{}
@}
@end smallexample

レベル2では、警告は、配列または配列サイズを示すポインター引数形式の他の不整合を含む再宣言のトリガーにもなります。 指定されていない境界のポインターと配列は同等と見なされ、警告をトリガーしません。

@smallexample
void g (int*);
void g (int[]);     // no warning
void g (int[8]);    // warning (inconsistent array bound)
@end smallexample

@option{-Warray-parameter=2}は@option {-Wall}に含まれています。 @option{-Wvla-parameter}オプションは、可変長配列引数に関連する同様の不整合に対して警告をトリガーします。

@item -Wattribute-alias=@var{n}
@itemx -Wno-attribute-alias
@opindex -Wattribute-alias
@opindex -Wno-attribute-alias
@code{alias}と、ターゲットがエイリアスのタイプと互換性がない同様の属性を使用した宣言について警告します。
@xref{Function Attributes,,関数の属性の宣言}.

@table @gcctabopt
@item -Wattribute-alias=1
@option{-Wattribute-alias}オプションのデフォルトの警告レベルは、エイリアス宣言のタイプとそのターゲットのタイプ間の非互換性を診断します。 このような非互換性は通常、バグを示しています。

@item -Wattribute-alias=2

このレベルでは、@option{-Wattribute-alias}は、エイリアス宣言の属性がターゲットに適用される属性よりも制限されている場合も診断します。 これらの不一致により、誤ったコードが生成される可能性があります。 他の場合には、それらは無害であり、ターゲットに欠落している属性を追加するだけで解決できます。 比較のために、@option{-Wmissing-attributes}オプションを参照してください。これは、エイリアス宣言がターゲットよりも制限が厳しくなく、制限が少ない場合に診断を制御します。

考慮される属性には、@code{alloc_align}、@code{alloc_size}、@code{cold}、@code{const}、@/
@code{hot}、@code{leaf}、@code{malloc}、@code{nonnull}、@code{noreturn}、@code{nothrow}、@code{pure}、@/
@code{returns_nonnull}、および@code{returns_twice}があります。
@end table

@option{-Wattribute-alias}は@option{-Wattribute-alias=1}と同等です。
これがデフォルトです。 @option{-Wno-attribute-alias}または@option{-Wattribute-alias=0}でこれらの警告を無効にできます。

@item -Wbool-compare
@opindex Wno-bool-compare
@opindex Wbool-compare
真偽値表現を@code{true}/@code{false}とは異なった整数値と比較していることについて警告する。
例えば、以下の比較は常に偽である。
@smallexample
int n = 5;
@dots{}
if ((n > 1) == 2) @{ @dots{} @}
@end smallexample
この警告は@option{-Wall}で有効になる。

@item -Wbool-operation
@opindex Wno-bool-operation
@opindex Wbool-operation
ブール型の式に対する疑わしい操作について警告する。 たとえば、ブール値のビット単位の否定は、プログラムのバグである可能性が非常に高い。Cの場合、この警告はブール値のインクリメント・デクリメントについても警告するが、それはめったに意味があることはないためである。（C++では、ブール値のデクリメントは常に無効である。ブール値のインクリメントはC++17では無効で、それ以外の場合は非推奨である。）

この警告は@option{-Wall}によって有効になる。

@item -Wduplicated-branches
@opindex Wno-duplicated-branches
@opindex Wduplicated-branches
if-elseが同一の分岐を持つときに警告する。この警告は以下の様な場合
@smallexample
if (p != NULL)
  return 0;
else
  return 0;
@end smallexample
これは両方の分岐が空文をのみを含んでいる場合には警告しない。この警告は条件演算子に対しても警告する。
@smallexample
  int i = x ? *p : *p;
@end smallexample

@item -Wduplicated-cond
@opindex Wno-duplicated-cond
@opindex Wduplicated-cond
if-else-if連鎖での重複した条件について警告する。例えば、以下のコードで警告する。
@smallexample
if (p->q != NULL) @{ @dots{} @}
else if (p->q != NULL) @{ @dots{} @}
@end smallexample

@item -Wframe-address
@opindex Wno-frame-address
@opindex Wframe-address
@samp{__builtin_frame_address}か@samp{__builtin_return_address}が0より大きな引数で
呼ばれたら警告する。そのような呼び出しは不定値を返すか、プログラムをクラッシュさせる。この警告は
@option{-Wall}に含まれている。

@item -Wno-discarded-qualifiers @r{(CとObjective-Cのみ)}
@opindex Wno-discarded-qualifiers
@opindex Wdiscarded-qualifiers
ポインタの型修飾子が削除されることについて警告しない。典型的には、コンパイラは、
@code{const char*}変数が@code{char *}パラメータを取る関数に渡されたら警告する。
このオプションはそのような警告を抑制する。

@item -Wno-discarded-array-qualifiers @r{(CとObjective-Cのみ)}
@opindex Wno-discarded-array-qualifiers
@opindex Wdiscarded-array-qualifiers
ポインタ・ターゲットである配列の型修飾子が削除されることについて警告しない。
典型的には、コンパイラは@code{const int (*)[]}変数が@code{ int (*)[]}パラメータを取る
関数に渡されたら警告する。このオプションはそのような警告を抑制する。

@item -Wno-incompatible-pointer-types @r{(CとObjective-Cのみ)}
@opindex Wno-incompatible-pointer-types
@opindex Wincompatible-pointer-types
ポインタとそれに非互換の型の間の変換について警告しない。この警告は@option{-Wno-pointer-sign}で
カバーしていないケースを警告し、それは異なった符号性のポインタ引数渡しか代入について警告する。

@item -Wno-int-conversion @r{(CとObjective-Cのみ)}
@opindex Wno-int-conversion
@opindex Wint-conversion
非互換の整数とポインタの変換について警告しない。この警告は暗黙の変換について警告する。
明示的な変換は警告@option{-Wno-int-to-pointer-cast}と@option{-Wno-pointer-to-int-cast}
が使われるかもしれない。


@item -Wzero-length-bounds
@opindex Wzero-length-bounds
@opindex Wzero-length-bounds
同じオブジェクトの他のメンバーと重複する可能性がある長さゼロの配列メンバーの要素へのアクセスについて警告します。 長さゼロの内部配列の宣言は推奨されていません。それらへのアクセスは定義されていないためです。 @xref{Zero Length}を参照してください。

たとえば、配列要素が後続のメンバー@code{b}および@code{c}と重複するため、関数@code{bad}の最初の2つのストアが診断されます。 3番目のストアは、囲んでいるオブジェクトの境界を超えているため、@option{-Warray-bounds}によって診断されます。

@smallexample
struct X @{ int a[0]; int b, c; @};
struct X x;

void bad (void)
@{
  x.a[0] = 0;   // -Wzero-length-bounds
  x.a[1] = 1;   // -Wzero-length-bounds
  x.a[2] = 2;   // -Warray-bounds
@}
@end smallexample

オプション@option{-Wzero-length-bounds}は@option{-Warray-bounds}によって有効になります。

@item -Wno-div-by-zero
@opindex Wno-div-by-zero
@opindex Wdiv-by-zero
コンパイル時の整数ゼロ除算について警告しない。浮動小数点数ゼロ除算は、無限と非数を得る
合法な手段なので警告しない。

@item -Wsystem-headers
@opindex Wsystem-headers
@opindex Wno-system-headers
@cindex warnings from system headers
@cindex system headers, warnings from
システムヘッダファイルに見つかった構造の警告メッセージを出力する。
システムヘッダからの警告は、通常は本当の問題を指しておらず、コンパイラの出力を読みにくくするという仮定で、
通常は抑制されている。このコマンドラインオプションを使うと、ユーザコードで起こったかのようにシステムヘッダからの警告を
出力するようにGCCに伝える。しかし、このオプションと組み合わせで@option{-Wall}を使ってもシステムヘッダの未知のプラグマ
は警告され@emph{ない}ことに注意する。そのためには、@option{-Wunknown-pragmas}を使わなくてはならない。

@item -Wtautological-compare
@opindex Wtautological-compare
@opindex Wno-tautological-compare
自己比較が常に真か偽と評価されるなら警告する。この警告は以下の様な様々な誤りを検知する。
@smallexample
int i = 1;
@dots{}
if (i > i) @{ @dots{} @}
@end smallexample

この警告は、常にtrueまたはfalseに評価されるビット単位の比較についても警告する。たとえば、

@smallexample
if ((a & 16) == 10) @{ @dots{} @}
@end smallexample
は常に偽である。
 
この警告は@option{-Wall}で有効である。

@item -Wtrampolines
@opindex Wtrampolines
@opindex Wno-trampolines
入れ子関数へのポインタとして生成されたトランポリンについて警告する。トランポリンは
入れ子関数のアドレスが取られた時に実行時にスタックに生成される小さいデータやコードであり、
入れ子関数を間接的に呼ぶときに使われる。あるターゲットでは、データだけで構成され、特殊な処理は不要である。
しかし大抵のターゲットでは、コードで構成され、したがってプログラムを適切に実行するためにはスタックが実行可能である必要がある。

@item -Wfloat-equal
@opindex Wfloat-equal
@opindex Wno-float-equal
浮動小数点数が等価比較で使われたら警告する。

この背後の考えは、時々、浮動小数点値を無限に正確な実数の近似と思うことが（プログラマにとって）便利であるということである。
こうしているならば、あなたは計算が持ち出す最大であるかありそうな最大のエラーを計算し（コードを分析することによって、あるいはなんとかして）
、比較（そして、出力を生じるとき、しかし、それは異なる問題である）を実行するときそれを考慮に入れる必要がある。
特に、等価のためのテストの代わりに、あなたは、2つの値が重なる範囲を持つかどうか見るためにチェックするべきである。
そして、これは関係演算子でされるので、等価比較は多分誤っているだろう。

@item -Wtraditional @r{(CとObjective-Cのみ)}
@opindex Wtraditional
@opindex Wno-traditional
伝統的なCとISO Cで異なって振る舞う構造のいくつかについて警告する。伝統的なCに等価物がないISO Cの構造と、避けるべき問題のある構造についても警告する。

@itemize @bullet
@item
マクロ本体内の文字列定数内に現れるマクロパラメータ。伝統的なCでは文字列定数内でマクロ置換で置き換えられが、ISO Cではしない。

@item
伝統的なCでは、幾つかのプリプロセスディレクティブが存在しない。伝統的なプリプロセスでは@samp{#}が行の第1桁の時だけディレクティブとみなされる。
したがって、@option{-Wtraditional}は伝統的なCが理解するが、@samp{#}が行の先頭でないために無視されるディレクティブについて警告する。
それは@code{#pragma}のような伝統的なCが理解できないディレクティブを隠すためにインデントするようにも提案する。ある伝統的な実装は
@code{#elif}を認識しないので、このオプションはそれを完全に避けるように提案する。

@item
引数なしで現れる関数風マクロ。

@item
単項プラス演算子

@item
@samp{U}整数定数接尾辞、@samp{F}および@samp{L}浮動小数点定数接尾辞。（伝統的なCは整数定数での@samp{L}接尾辞はサポートしている）
これらの接尾辞はたいていの最近のシステムのシステムヘッダで定義されたマクロに現れることに注意する。例えば、
@code{<limits.h>}の@samp{_MIN}/@samp{_MAX}マクロ。どんなにGCCの統合化プリプロセッサにはこれらの場合警告を避けるのに十分なコンテキストがあっても、
ユーザコードのこれらのマクロの使用はもっともらしい警告に通常つながるかもしれない。

@item
一つのブロックで外部として宣言され、ブロック終わりの後ろで使われた関数。

@item
@code{switch}文が@code{long}型のオペランドを持つ。

@item
非@code{staic}関数宣言が@code{static}に続く。この構造はいくつかの伝統的なCコンパイラでは受理されない。

@item
整数定数のISO型は伝統的な型とは異なった幅と符号性を持つ。定数の底が10であるときだけこの警告は発される。すなわち、
16進と8進の値は、典型的にはビットパターンを表し、警告されない。

@item
ISO文字列連結の使用を検知した時。

@item
自動集合値の初期化。

@item
ラベルと衝突する識別子。伝統的なCは分離されたラベル名前空間を欠けている。

@item
共用体の初期化。もし初期化子が0ならばこの警告は飛ばされる。これはユーザコードの0初期化子が初期化子警告を逃すことを避けるために例えば、@code{__STDC__}上で条件つきに見えて、伝統的なCケースでゼロへのデフォルト初期化に頼るという仮定中でこれはされる。

@item
プロトタイプによる固定・浮動小数点数およびその逆の変換。伝統的なCでこれらのプロトタイプなしでコンパイルすると深刻な問題を引き起こす。これはありうる変換警告の一部である。完全な集合には、@option{-Wtraditional-conversion}を使う。

@item
ISO C方式の関数定義の使用。この警告はプロトタイプ宣言や可変長関数では、それらのISO Cの機能がlibiberryの伝統的なCの互換性マクロ
@code{PARAMS}と@code{VPARAMS}で使われているので意図的に発せられ@emph{ない}。この警告は入れ子関数でも、この機能がすでにGCC拡張であって、
伝統的なC互換性と無関係なので素通りされる。
@end itemize

@item -Wtraditional-conversion @r{(CとObjective-Cのみ)}
@opindex Wtraditional-conversion
@opindex Wno-traditional-conversion
プロトタイプがプロトタイプがない場合同じ引数で起こるものとは異なる型変換を引き起こすならば警告する。
これは固定小数点数から浮動小数点数への変換とその逆、固定小数点引数がデフォルト格上げと同じ場合を除いて幅と符号性が変わる場合を含む。

@item -Wdeclaration-after-statement @r{(CとObjective-Cのみ)}
@opindex Wdeclaration-after-statement
@opindex Wno-declaration-after-statement
ブロック内の文の後に宣言が見つかった場合に警告する。この構造は、C++由来として知られ、ISO C99で導入され、GCCではデフォルトで許されている。
ISO C90ではサポートされていない。 @xref{Mixed Labels and Declarations}.


@item -Wshadow
@opindex Wshadow
@opindex Wno-shadow
ローカル変数または型宣言が別の変数、パラメーター、型、クラスメンバー（C++の場合）、またはインスタンス変数（Objective-Cの場合）をシャドウするとき、または組み込み関数がシャドウされるときはいつでも警告します。 C++では、ローカル変数が明示的なtypedefをシャドウしている場合は警告しますが、struct/class/enumをシャドウしている場合は警告しません。 この警告が有効になっている場合、ローカルシャドウイングのすべてのインスタンスも含まれます。 これは、@option{-Wshadow}が使用されている場合は@option{-Wno-shadow=local}と@option {-Wno-shadow=compatible-local}が無視されることを意味します。 @option{-Wshadow=global}と同じです。

@item -Wno-shadow-ivar @r{(Objective-Cのみ)}
@opindex Wno-shadow-ivar
@opindex Wshadow-ivar
Objective-Cメソッドでローカル変数がインスタンス変数を隠すときに警告しない。

@item -Wshadow=global
@opindex Wshadow=global
どんな隠しにも警告する。@option{-Wshadow}と同じである。

@item -Wshadow=local
@opindex Wshadow=local
ローカル変数が他のローカル変数・パラメータを隠すときに警告する。

@item -Wshadow=compatible-local
@opindex Wshadow=compatible-local
ローカル変数が、隠している変数の型と互換性のある別のローカル変数またはパラメータを隠したときに警告する。 C++では、ここでのタイプの互換性とは、隠している変数の型を隠された変数のタイプに変換できることを意味する。 このフラグの作成（@option{-Wshadow=local}に加えて）は、ローカル変数が互換性のない型の別のものを隠すとき、バグや誤字ではなく、意図的である可能性が高いという考えに基づいている。 次の例：


@smallexample
@group
for (SomeIterator i = SomeObj.begin(); i != SomeObj.end(); ++i)
@{
  for (int i = 0; i < N; ++i)
  @{
    ...
  @}
  ...
@}
@end group
@end smallexample

上での例の2つの変数@code{i}は非互換の型を持つので、@option{-Wshadow=compatible-local}だけを有効にした場合には警告を発しない。それらの型は非互換なので、たとえプログラマが誤って取り違えて使っても、型検査がそれをキャッチしてエラーか警告を発するだろう。したがって、この場合に（隠すことに関して）警告しないことはバグの漏れを引き起こさない。@option{-Wshadow=local}の代わりにこのフラグを使うことで意図的な隠しによって引き起こされる警告の数を減らすことができるかもしれない。

この警告は@option{-Wshadow=local}によって有効になる。

@item -Wlarger-than=@var{byte-size}
@opindex Wlarger-than=
@opindex Wlarger-than-@var{byte-size}
サイズが@var {byte-size}を超えるオブジェクトが定義されるたびに警告します。
@option{-Wlarger-than=}@samp{PTRDIFF_MAX}はデフォルトで有効になっています。
オプションによって制御される警告は、@samp{SIZE_MAX}以上の@var{byte-size}を指定するか、@ option{-Wno-larger-than}によって無効にできます。

また、@code{memchr}や@code{strnlen}など、可能な最大のオブジェクト（デフォルトでは@samp{PTRDIFF_MAX}バイト）より大きい境界を指定する境界関数の呼び出しについても警告します。 これらの警告は、@option{-Wno-larger-than}によってのみ無効にできます。

@item -Wno-larger-than
@opindex Wno-larger-than
@option{-Wlarger-than=}警告を無効にします。 このオプションは、@option{-Wlarger-than=}@samp{SIZE_MAX}以上と同等です。

@item -Wframe-larger-than=@var{byte-size}
@opindex Wframe-larger-than=
@opindex Wno-frame-larger-than
関数フレームが@var{byte-size}バイトよりも大きいサイズの時に警告する。
スタック・フレームサイズを測定するためにされる計算は、概算で、保守的でない。たとえあなたが警告を得なとしても、実際の必要条件は@var{byte-size}よりいくぶん大きいかもしれない。そのうえ、警告を発するべきかどうか決定するとき、@code{alloca}、可変長の配列または関連した
構成概念を通して割り当てられる少しのスペースもコンパイラによって含まれない。
@option{-Wframe-larger-than=}@samp{PTRDIFF_MAX}はデフォルトで有効になっています。
@samp{SIZE_MAX}以上の@var{byte-size}を指定するか、@option{-Wno-frame-larger-than}でオプションによって制御される警告を無効にできます。

@item -Wno-frame-larger-than
@opindex Wno-frame-larger-than
@option{-Wframe-larger-than=}警告を無効にします。 このオプションは、@option{-Wframe-larger-than=}@samp {SIZE_MAX}以上と同等です。

@item -Wno-free-nonheap-object
@opindex Wno-free-nonheap-object
@opindex Wfree-nonheap-object
ヒープに割り当てられていないオブジェクトの割り当てを解除しようとしたとき、または対応する割り当て関数への以前の呼び出しから返されなかったポインターを使用して警告します。 たとえば、@code{stpcpy}を呼び出すと、オブジェクトの先頭ではなく、終了するヌル文字へのポインタが返されるため、以下の@code{free}の呼び出しが診断されます。

@smallexample
void f (char *p)
@{
  p = stpcpy (p, "abc");
  // ...
  free (p);   // warning
@}
@end smallexample

@option{-Wfree-nonheap-object}はデフォルトで有効になっています。

@item -Wstack-usage=@var{byte-size}
@opindex Wstack-usage
@opindex Wno-stack-usage
関数のスタック使用が@var{byte-size}バイトを超えるかもしれない時に警告する。
スタック使用を決定するための計算は保守的である。@code{alloca}によって割り当てられる空間,
可変長配列、関連する構造は警告を発するかどうかを決定する際にコンパイラによって含まれる。

メッセージは@option{-fstack-usage}の出力で保持される。

@itemize
@item
もしスタックの使用が完全に静的指定された範囲を超えるなら、こうなる。

@smallexample
  warning: stack usage is 1120 bytes
@end smallexample
@item
もしスタックの使用が（部分的に）動的だが、上限があるならば、こうなる。

@smallexample
  warning: stack usage might be 1648 bytes
@end smallexample
@item
もしスタックの使用が（部分的に）動的に、上限がないならば、こうなる。

@smallexample
  warning: stack usage might be unbounded
@end smallexample
@end itemize

@option{-Wstack-usage=}@samp{PTRDIFF_MAX}はデフォルトで有効になっています。
@samp{SIZE_MAX}以上の@var{byte-size}を指定するか、@option{-Wno-stack-usage}でオプションによって制御される警告を無効にできます。

@item -Wno-stack-usage
@opindex Wno-stack-usage
@option{-Wstack-usage=}警告を無効にします。 このオプションは、@option{-Wstack-usage=}@samp{SIZE_MAX}以上と同等です。

@item -Wunsafe-loop-optimizations
@opindex Wunsafe-loop-optimizations
@opindex Wno-unsafe-loop-optimizations
コンパイラがループインデックスの境界で何も想定できないため、ループを最適化できない場合に警告します。 @option{-funsafe-loop-optimizations}を使用すると、コンパイラーがそのような仮定を行う場合に警告が表示されます。

@item -Wno-pedantic-ms-format @r{(MinGWターゲットのみ)}
@opindex Wno-pedantic-ms-format
@opindex Wpedantic-ms-format
@option{-Wformat}とGNU拡張なしの@option{-pednatic}を組み合わせて使った時に、
このオプションは非ISOの@code{printf} / @code{scanf}フォーマットを
MSランタイムに依存して、ウィンドウズターゲットで使われる@code{I32}, @code{I64}, @code{I}
指定子で使った時の警告を無効にする。

@item -Wpointer-arith
@opindex Wpointer-arith
@opindex Wno-pointer-arith
関数型および@code{void}の「サイズ」に依存したもの全てに警告する。GNU Cは、@code{void*}ポインタと
関数へのポインタでの計算の便利のために、それらのサイズを1とする。C++では、@code{NULL}が関与する
算術演算にも警告する。この警告は@option{-Wpedantic}で有効になる。

@item -Wpointer-compare
@opindex Wpointer-compare
@opindex Wno-pointer-compare
ポインタが0文字定数と比較されていると警告する。これは通常ポインタが参照剥がしされる意図があったことを意味する。例えば：

@smallexample
const char *p = foo ();
if (p == '\0')
  return 42;
@end smallexample

上のコードはC++11では不正であることに注意する。

この警告はデフォルトで有効である。

@item -Wtsan
@opindex Wtsan
@opindex Wno-tsan
ThreadSanitizerでサポートされていない機能について警告します。

ThreadSanitizerは@code{std::atomic_thread_fence}をサポートしておらず、誤検知を報告する可能性があります。

この警告はデフォルトで有効になっています。

@item -Wtype-limits
@opindex Wtype-limits
@opindex Wno-type-limits
比較がデータ型の制限された範囲のために常に真か偽になるときに警告するが、定数表現では警告しない。
例えば、もし符号なし値が0と@code{<}か@code{>=}で比較されていたら警告する。この警告は
@option{-Wextra}で有効になる。

@item -Wabsolute-value @r{(CとObjective-C専用)}
@opindex Wabsolute-value
@opindex Wno-absolute-value
より適切な標準関数が利用可能な場合、引数の絶対値を計算する標準関数の呼び出しを警告します。
たとえば、@code{abs(3.14)}を呼び出すと、double引数の絶対値を計算するために呼び出す適切な関数が@code{fabs}であるため、警告がトリガーされます。 このオプションは、そのような関数の呼び出しの引数に符号なしの型がある場合にも警告をトリガーします。 この警告は、明示的な型キャストによって抑制でき、@option{-Wextra}によっても有効になります。

@include cppwarnopts.texi

@item -Wbad-function-cast @r{(CとObjective-C専用)}
@opindex Wbad-function-cast
@opindex Wno-bad-function-cast
関数呼び出しが一致しない型へキャストされていたら警告する。例えば、整数型を返す関数呼び出しが
ポインタ型へキャストされていたら警告する。

@item -Wc90-c99-compat @r{(CとObjective-C専用)}
@opindex Wc90-c99-compat
@opindex Wno-c90-c99-compat
ISO C90にはないが、ISO C99にはある機能について警告する。例えば、、可変長配列の使用、@code{long long}型、@code{bool}型、複合定数、指示付きの初期化子など。このオプションは標準モードと
独立である。警告は@code{__extension__}に続く式では無効にされる。

@item -Wc99-c11-compat @r{(CとObjective-C専用)}
@opindex Wc99-c11-compat
@opindex Wno-c99-c11-compat
ISO C99にはないが、ISO C11にはある機能について警告する。例えば、匿名構造体と共用体の使用、
@code{_Atomic}型指定子、@code{_Thread_local}ストレージクラス指定子、
@code{_Alignas}指定子、@code{Alignof}演算子、@code{_Generic}キーワードなど。
このオプションは標準モードと独立である。警告は@code{__extension__}に続く式では無効にされる。

@item -Wc11-c2x-compat @r{(CとObjective-C専用)}
@opindex Wc11-c2x-compat
@opindex Wno-c11-c2x-compat
ISO C11にはないがISO C2Xにはある機能について警告します。たとえば、@code{_Static_assert}の文字列の省略、属性に対する@samp{[[]]}構文の使用、10進浮動小数点型の使用などについて警告します。 このオプションは、標準モードから独立しています。 @code{__extension__}に続く式では警告が無効になっています。

@item -Wc++-compat @r{(CとObjective-C専用)}
@opindex Wc++-compat
ISO CとISO C++の共通部分集合の外側のISO C構造について警告する。例えば、@code{void *}から
非@code{void}型へのポインタへの暗黙の変換の要求。

@item -Wc++11-compat @r{(C++とObjective-C++専用)}
@opindex Wc++11-compat
ISO C++ 1998とISO C++ 2011で意味が異なるC++構造について警告する。例えば、ISO C++ 2011で
キーワードであるISO C++1998での識別子。この警告は@option{-Wnarrowing}を有効にし、
@option{-Wall}で有効になる。

@item -Wc++14-compat @r{(C++とObjective-C++専用)}
@opindex Wc++14-compat
ISO C++2011とISO C++2014で意味が異なるC++構造について警告する。
この警告は@option{-Wall}で有効になる。

@item -Wc++17-compat @r{(C++とObjective-C++専用)}
@opindex Wc++17-compat
ISO C++ 2014とISO C++ 2017の間で意味が異なるC++構造について警告する。これは@option{-Wall}で有効になる。

@item -Wc++20-compat @r{(C++とObjective-C++専用)}
@opindex Wc++20-compat
@opindex Wno-c++20-compat
ISO C++ 2017とISO C++ 2020の間で意味が異なるC++構造について警告する。これは@option{-Wall}で有効になる。

@item -Wcast-qual
@opindex Wcast-qual
@opindex Wno-cast-qual
ポインタがターゲット型から型修飾子が削除されるようにキャストされると警告する。例えば、
@code{const char*}が単なる@code{char *}へとキャストされると警告する。

安全でない方法で型修飾子が追加されるキャストにも警告する。例えば、
@code{char **}から@code{const char **}へのキャストはこの例のように安全でない。

@smallexample
  /* p はchar **の値  */
  const char **q = (const char **) p;
  /* 読み出し専用文字列のconst char*への代入はOK  */
  *q = "string";
  /* 今char**は読み出し専用のメモリを指している  */
  **p = 'b';
@end smallexample

@item -Wcast-align
@opindex Wcast-align
@opindex Wno-cast-align
ターゲットの要求されるアラインメントが増えるようにポインタがキャストされると警告する。
例えば、整数が２か４バイトの境界でしかアクセスできない機種で@code{char *}が@code{int *}に
キャストされると警告する。

@item -Wcast-align=strict
@opindex Wcast-align=strict
ターゲットの必要なアライメントが増加するようにポインターがキャストされるたびに警告します。 たとえば、ターゲットマシンに関係なく、@code{char *}が@code{int *}にキャストされた場合に警告します。

@item -Wcast-function-type
@opindex Wcast-function-type
@opindex Wno-cast-function-type
関数ポインターが互換性のない関数ポインターにキャストされたときに警告します。
可変引数リストを持つ関数型を含むキャストでは、提供される初期引数の型のみが考慮されます。
ポインタータイプのパラメーターは、他のポインタータイプと一致します。 ILP32ターゲットの@code{int}と@code{long}のように、整数型の良性の違いは無視されます。 同様に、型修飾子は無視されます。 関数型@code{void(*) (void)}は特別であり、すべてに一致します。これを使用して、この警告を抑制できます。メンバー型へのポインターを含むキャストでは、型キャストがメンバー型へのポインターを変更するたびにこの警告が警告されます。この警告は@option{-Wextra}によって有効にされます。

@item -Wwrite-strings
@opindex Wwrite-strings
@opindex Wno-write-strings
Cをコンパイルするとき、文字列定数に型@code{const char[@var{length}]}を、1つのアドレスを非@code{const} @code{char *}ポインタにコピーするために与えると警告を出す。
これらの警告は文字列定数に書こうとするコードをコンパイル時に見つけるのには役立つが、あなたが宣言とプロトタイプで@code{const}を使うことに非常に慎重な場合だけ、その場合に限りである。さもなければ、それは単なる迷惑である。そういうわけで、我々は@option{-Wall}をこれらの警告を要請させなかった。

C++をコンパイルするとき、文字列定数から@code{char *}への廃止予定の変換ついて警告する。この警告は、C++プログラムではデフォルトで使用可能である。

@item -Wclobbered
@opindex Wclobbered
@opindex Wno-clobbered
変数が@code{longjmp}や@code{vfork}で変わるかもしれないときに警告する。これは@option{-Wextra}で有効である。

@item -Wconversion
@opindex Wconversion
@opindex Wno-conversion
値が変わるかもしれない暗黙の変換について警告する。これは@code{x}が@code{double}の時の@code{abs (x)}のような、実数と整数の変換、
@code{unsigned ui = -1}のような符号ありと符号なしの変換。@code{sqrtf (M_PI)}のようなより小さい型への変換を含む。
@code{abs ((int) x)} and @code{ui = (unsigned) -1}のような明示的なキャスト、および@code{abs (2.0)}のような値の変化しない変換は警告しない。
符号ありと符号なしの整数間の変換の警告は@option{-Wno-sign-conversion}で無効にできる。

C++の場合、ユーザー定義の変換のオーバーロード解決を混乱させることについても警告します。 型変換演算子を使用しない変換：@code{void}への変換、同じ型、基本クラス、またはそれらへの参照。 @option{-Wsign-conversion}が明示的に有効にされていない限り、符号付き整数と符号なし整数の間の変換に関する警告は、C++ではデフォルトで無効になっています。

小さい型の算術からその型への変換に関する警告は、@option{-Warith-conversion}でのみ表示されます。

@item -Wdangling-else
@opindex Wdangling-else
@opindex Wno-dangling-else
どの@code{if}に@code{else}分岐が属しているか混乱するかもしれない構造に警告する。ここの例の場合、

@smallexample
@group
@{
  if (a)
    if (b)
      foo ();
  else
    bar ();
@}
@end group
@end smallexample

C・C++では、それぞれの@code{else}分岐は可能な最も内側の@code{if}文に属し、この例では@code{if (b)}である。これはしばしば、上の例でプログラマの選択したインデントで示されるように、プログラマの期待した通りでない。この混乱の潜在性があるときには、GCCはこのフラグが指定されたときには警告を発する。警告を除去するためには、@code{else}が囲っている@code{if}に属すことができないように最も内側の@code{if}の周りに明示的なカッコを加える。結果のコードはこのようになる。

@smallexample
@group
@{
  if (a)
    @{
      if (b)
        foo ();
      else
        bar ();
    @}
@}
@end group
@end smallexample

この警告は@option{-Wparentheses}で有効になる。

@item -Wdate-time
@opindex Wdate-time
@opindex Wno-date-time
ビット単位で同一のコンパイル再現性を妨げるかもしれないため、@code{__TIME__}、 @code{__DATE__}、@code{__TIMESTAMP__}に出会ったら警告する。

@item -Wempty-body
@opindex Wempty-body
@opindex Wno-empty-body
@code{if}, @code{else}, @code{do while}文に空の本体が現れると警告する。これは@option{-Wextra}でも有効になる。

@item -Wno-endif-labels
@opindex Wendif-labels
@opindex Wno-endif-labels
@code{#else}と@code{#endif}の後に、トークンが残っていることについて警告しません。

@item -Wenum-compare
@opindex Wenum-compare
@opindex Wno-enum-compare
異なる列挙型の値間の比較について警告する。C++では条件式での列挙の不一致も診断して警告はデフォルトで有効になる。
Cではこの警告は@option{-Wall}で有効になる。

@item -Wenum-conversion
@opindex Wenum-conversion
@opindex Wno-enum-conversion
列挙型の値が暗黙的に別の列挙型に変換されたときに警告します。 この警告は、Cでは@option{-Wextra}によって有効になります。

@item -Wjump-misses-init @r{(C, Objective-C専用)}
@opindex Wjump-misses-init
@opindex Wno-jump-misses-init
@code{goto}文か@code{switch}文が変数の初期化をまたいで飛ぶか、初期化された後にラベルへと戻って飛ぶときに警告する。
これは宣言された時に初期化された変数についてのみ警告する。この警告はCとObjective-Cでのみサポートされている。
C++ではこの種類の分岐はどのみちエラーである。

@option{-Wjump-misses-init}は@option{-Wc++-compat}に含まれている。@option{-Wno-jump-misses-init}オプションで無効にできる。

@item -Wsign-compare
@opindex Wsign-compare
@opindex Wno-sign-compare
@cindex warning for comparison of signed and unsigned values
@cindex comparison of signed and unsigned values, warning
@cindex signed and unsigned values, comparison warning
符号付きと符号なしの値の比較が符号付き値が符号なし値に変換された時に不正確な結果を生み出す時に警告する。
C++では、この警告は@option{-Wall}でも有効である。Cでは、@option{-Wextra}でも有効である。

@item -Wsign-conversion
@opindex Wsign-conversion
@opindex Wno-sign-conversion
符号付き製数式を符号なし整数値に代入するような、整数値の符号が変わるかもしれない暗黙の変換について警告する。
明示的なキャストはこの警告を黙らせる。Cでは、このオプションは@option{-Wconversion}でも有効になる。

@item -Wfloat-conversion
@opindex Wfloat-conversion
@opindex Wno-float-conversion
実数値の精度を減らす暗黙の変換を警告する。これは実数から整数、高い精度の実数から低い精度の実数への変換を含む。
このオプションは@option{-Wconversion}でも有効になる。

@item -Wno-scalar-storage-order
@opindex -Wno-scalar-storage-order
@opindex -Wscalar-storage-order
逆スカラー格納順に関する疑わしい構造について警告しない。

@item -Wsizeof-pointer-div
@opindex Wsizeof-pointer-div
@opindex Wno-sizeof-pointer-div
ポインタサイズを要素サイズで割る2つのsizeof式の疑わしい除算について警告する。これは、配列サイズを計算する通常の方法だが、ポインタで正しく機能しない。 この警告は、例えば@code{sizeof(ptr)/ sizeof(ptr [0])}について、@code{ptr}が配列ではなくポインタであると警告する。 この警告は@option{-Wall}によって有効になる。

@item -Wsizeof-pointer-memaccess
@opindex Wsizeof-pointer-memaccess
@opindex Wno-sizeof-pointer-memaccess
引数が@code{sizeof}を使用する場合で、特定の文字列とメモリの組み込み関数について疑わしい長さパラメータを警告する。 この警告は、例えば、@code{ptr}が配列でなく、ポインタである場合の@code{memset (ptr, 0, sizeof (ptr));}で、可能な修正を示唆している場合や、@code{memcpy (&foo, ptr, sizeof (&foo));}についてである。@option{-Wsizeof-pointer-memaccess}は、ソース配列の@code{sizeof}表現を制限として指定した@code{strncat}や@code{strncpy}のような制限文字列コピー関数の呼び出しについても警告する。 たとえば、次の関数では、@code{strncat}を呼び出すと、ソース文字列のサイズが範囲として指定されます。 それはほぼ間違いであり、呼び出しは診断される。
@smallexample
void make_file (const char *name)
@{
  char path[PATH_MAX];
  strncpy (path, name, sizeof path - 1);
  strncat (path, ".text", sizeof ".text");
  @dots{}
@}
@end smallexample

@option{-Wsizeof-pointer-memaccess}オプションは@option{-Wall}で有効になる。

@item -Wsizeof-array-argument
@opindex Wsizeof-array-argument
@opindex Wno-sizeof-array-argument
@code{sizeof}演算子が関数定義の配列として宣言されているパラメータに適用されていると警告する。この警告はCとC++プログラムではデフォルトである。

@item -Wmemset-elt-size
@opindex Wmemset-elt-size
@opindex Wno-memset-elt-size
疑わしい@code{memset}組み込み関数への呼び出しを警告する。もし最初の引数が配列への参照で、
三番目の引数が要素数と等しいが、メモリ内での配列サイズと等しくない場合。これはユーザが要素サイズで掛け忘れたことを示している。この警告は@option{-Wall}で有効になる。

@item -Wmemset-transposed-args
@opindex Wmemset-transposed-args
@opindex Wno-memset-transposed-args
@code{memset}組み込み関数の疑わしい呼び出しを、もし第2引数が0でなく第3引数が0ならば警告する。
これは例えば、@code{memset (buf, sizeof buf, 0)}について警告し、おそらく代わりに
@code{memset (buf, 0, sizeof buf)}を意図していたであろう。診断は第３引数が定数0の時だけ生成される。
もしそれが0へと変換される式であるか、ある型への0のキャストであるなどならば、ユーザが引数を間違えたことは
ずっとありそうもないので、警告は生成されない。この警告は@option{-Wall}で有効になる。

@item -Waddress
@opindex Waddress
@opindex Wno-address
メモリアドレスの疑わしい使う方について警告する。これは@code{void func(void); if (func)}のような条件式での関数のアドレスの使用、
@code{if (x == "abc")}のような、文字列定数のメモリアドレスに対する比較を含む。そのような仕様は典型的にはプログラマの誤りを示している。
関数のアドレスは常に真へと評価されるので、条件式でのそれらの仕様は大抵プログラマが関数呼び出しの括弧を忘れたことを示している。
文字列通しの比較は未指定の振る舞いを起こし、Cでは移植性がないので、プログラマが代わりに@code{strcmp}を使うべきなことを示している。
この警告は@option{-Wall}で有効になる。

@item -Wno-address-of-packed-member
@opindex Waddress-of-packed-member
@opindex Wno-address-of-packed-member
structまたはunionのパックされたメンバーのアドレスが取得されたときに警告します。
これは通常、位置合わせされていないポインター値になります。 これはデフォルトで有効になっています。

@item -Wlogical-op
@opindex Wlogical-op
@opindex Wno-logical-op
式での論理演算子の疑わしい使用について警告する。これはビット単位の演算子がおそらく期待される文脈での論理演算子の使用を含む。
さらに演算子のオペランドが同じ場合も警告する。
@smallexample
extern int a;
if (a < 0 && a < 0) @{ @dots{} @}
@end smallexample

@item -Wlogical-not-parentheses
@opindex Wlogical-not-parentheses
@opindex Wno-logical-not-parentheses
比較の左辺値使われていない論理について警告する。このオプションはもし右辺値が真偽値の時は警告しない。その目的は
以下の様な疑わしいコードを検出することである。
@smallexample
int a;
@dots{}
if (!a > 1) @{ @dots{} @}
@end smallexample

左辺値を括弧で囲うことで抑制できる。
@smallexample
if ((!a) > 1) @{ @dots{} @}
@end smallexample

この警告は@option{-Wall}で有効になる。

@item -Waggregate-return
@opindex Waggregate-return
@opindex Wno-aggregate-return
構造体や共用体を返す関数が定義・呼びだされた時に警告する。（配列を返すことができる言語では、それも警告を誘発する）

@item -Wno-aggressive-loop-optimizations
@opindex Wno-aggressive-loop-optimizations
@opindex Waggressive-loop-optimizations
定数回数のループでコンパイラが1つ以上の繰り返しの間に文の中に未定義の振る舞いを検知した場合に警告する。

@item -Wno-attributes
@opindex Wno-attributes
@opindex Wattributes
認識しない属性、変数に適用された関数属性など、予期せぬ@code{__attribute__}が使われた時に警告しない。
これはサポートされた属性の間違った使用のエラーは止めない。

@item -Wno-builtin-declaration-mismatch
@opindex Wno-builtin-declaration-mismatch
@opindex Wbuiltin-declaration-mismatch
組み込み関数が互換性のないシグネチャで宣言されている場合、または非関数として宣言されている場合、またはプロトタイプを含まない型で宣言された組み込み関数が、その昇格された型が関数で期待されるものと一致しない引数で呼び出された場合に警告します。@option{-Wno-builtin-declaration-mismatch}警告はデフォルトで有効になっています。 警告を回避するには、組み込み関数のプロトタイプをスコープに入れるための適切なヘッダーを含めます。

たとえば、以下の@code{memset}の呼び出しは、関数が引数として@code{size_t}型の値を予期しているが、@code{32}の型は@code{int}であるため、警告によって診断されます。 @option{-Wextra}を使用すると、関数の宣言も診断されます。
@smallexample
extern void* memset ();
void f (void *d)
@{
  memset (d, '\0', 32);
@}
@end smallexample

@item -Wno-builtin-macro-redefined
@opindex Wno-builtin-macro-redefined
@opindex Wbuiltin-macro-redefined
いくつかの組み込みマクロが再定義された時に警告しない。これは@code{__TIMESTAMP__}, @code{__TIME__},
@code{__DATE__}, @code{__FILE__}, @code{__BASE_FILE__}の再定義の警告を抑制する。

@item -Wstrict-prototypes @r{(CとObjective-C専用)}
@opindex Wstrict-prototypes
@opindex Wno-strict-prototypes
関数が引数型を指定しないで宣言・定義されたら警告する。（旧式の関数定義は続く宣言は引数型を指定していれば警告なしで受け入れる）

@item -Wold-style-declaration @r{(CとObjective-C専用)}
@opindex Wold-style-declaration
@opindex Wno-old-style-declaration
C標準によれば、宣言での時代遅れの使用を警告する。例えば、@code{static}のような格納クラス指定子が宣言の先頭でないならば警告する。
この警告は@option{-Wextra}でも有効になる。

@item -Wold-style-definition @r{(CとObjective-C専用)}
@opindex Wold-style-definition
@opindex Wno-old-style-definition
旧式の関数定義が使われたら警告する。警告は前のプロトタイプがあっても与えられる。

@item -Wmissing-parameter-type @r{(CとObjective-C専用)}
@opindex Wmissing-parameter-type
@opindex Wno-missing-parameter-type
関数パラメータがK&R式関数で型指定なしで宣言されている。

@smallexample
void foo(bar) @{ @}
@end smallexample

この警告は@option{-Wextra}でも有効になる。

@item -Wmissing-prototypes @r{(CとObjective-C専用)}
@opindex Wmissing-prototypes
@opindex Wno-missing-prototypes
グローバル関数が前のプロトタイプ宣言なしで定義されていると警告する。
この警告は定義自身がプロトタイプを提供しても発行される。このオプションを使うと
ヘッダファイルに対応するプロトタイプ宣言がないグローバル関数を検知できる。
このオプションは全関数宣言がプロトタイプを提供し、一致しない宣言は前の宣言との衝突ではなくオーバーロードの宣言なので
C++では有効ではない。
C++で失われた宣言を探知するには@option{-Wmissing-declarations}を使う。

@item -Wmissing-declarations
@opindex Wmissing-declarations
@opindex Wno-missing-declarations
グローバル関数が前の宣言なしで定義されていると警告する。定義自身がプロトタイプを提供していてもそうする。
このオプションを使うとヘッダファイルで宣言されていないグローバル関数を検知することができる。
Cでは、前に非プロトタイプの宣言のある関数は警告が発せられない。失われたプロトタイプを探知するには
@option{-Wmissing-prototypes}を使う。C++では、関数テンプレート、インライン関数、匿名名前空間での関数には警告が発せられない。

@item -Wmissing-field-initializers
@opindex Wmissing-field-initializers
@opindex Wno-missing-field-initializers
@opindex W
@opindex Wextra
@opindex Wno-extra
構造体の初期化子であるフィールドが抜けていると警告する。例えば、以下のコードは@code{x.h}が暗黙に0なので、警告を引き起こす。

@smallexample
struct s @{ int f, g, h; @};
struct s x = @{ 3, 4 @};
@end smallexample

このオプションは指示付きの初期化子については警告しないので、以下の修正は警告を引き起こさない。

@smallexample
struct s @{ int f, g, h; @};
struct s x = @{ .f = 3, .g = 4 @};
@end smallexample

Cでは、汎用ゼロ初期化子@samp{@{ 0 @}}については警告しない。:
 
@smallexample
struct s @{ int f, g, h; @};
struct s x = @{ 0 @};
@end smallexample

同様に、C++では空@{ @}の初期化子については警告しない。例えば、

@smallexample
struct s @{ int f, g, h; @};
s x = @{ @};
@end smallexample

この警告は@option{-Wextra}に含まれている。これなしで他の@option{-Wextra}警告を得るには、
@option{-Wextra -Wno-missing-field-initializers}を使う。

@item -Wno-multichar
@opindex Wno-multichar
@opindex Wmultichar
複数文字定数(@samp{'FOOF'})が使われていも警告しない。これは、実装定義値を持ち、移植可能なコードでは使うべきではないので、
通常はユーザコードの誤字を示す。

@item -Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]}
@opindex Wnormalized=
@opindex Wnormalized
@opindex Wno-normalized
@cindex NFC
@cindex NFKC
@cindex character set, input normalization
ISO CとISO C++では、それらが文字の異なるシーケンスであるならば、2つの識別子は異なる。
しかし、時々基本的なASCIIキャラクタセットの外の文字が使われるとき、あなたは同じものに見える2つの異なる文字シーケンスを持つことができる。
混乱を避けるために、同じものに見える2つのシーケンスが同じシーケンスに変えられることを、適用されるとき、確実とするある@dfn{正規化規則}を、
標準のISO 10646は提示する。あなたが正規化されなかった識別子を使っているならば、GCCはあなたに警告することができる;このオプションは、その警告を制御する。

GCCがサポートする4レベルの警告がある。デフォルトは@option{-Wnormalized=nfc}である。そして、ISO 「C」正規化型@dfn{NFC}になり識別子には何でも警告する。
NFCは、大部分の用途のための推薦された形である。それは、@option{-Wnormalized}に等しい。

不幸にも、ISO CとISO C++によって、識別子と認められているが、NFCに変換すると認められない文字がある。すなわち、これらのシンボルを移植性のあるCとC++で使い、
すべての識別子をNFCにする方法はない。@option{-Wnormalized=id}は、これらの文字の警告を抑える。関係する標準の将来のバージョンがこれを修正することが望まれる。
そして、それはこのオプションがデフォルトでない理由である。

@option{-Wnormalized=none}または@option{-Wno-normalized}を書くことによって、あなたはすべての文字のために警告のスイッチを切ることができる。
、ある他の（「D」のような）正規化スキームを使っているならば、あなたはこうするべきだけである。なぜならな、さもなければ
見るのが文字通り不可能であるバグを簡単に生じさせることができるからである。

ISO 10646はあるフォントや表示方法では、特にフォーマッティングが適用されると、同一に見えるが異なる意味を持つ
例えば、@code{\u207F}、「上付きラテン小文字N」は上付き文字の場所に置かれた単なる@code{n}のように表示される。
ISO 10646はそれらすべても同様に標準系に変換する@dfn{NFKC}正規化スキームを定義していて、GCCは
@option{-Wnormalized=nfkc}を使っているならNFKCでないコードに警告する。この警告は数字0と混乱するかもしれないという理由で文字Oを含む
すべての識別子を警告するようなものなので、デフォルトではないが、プログラム環境がそれらの文字を区別して表示できないならばローカルコード規約として
役立つかもしれない。

@item -Wno-attribute-warning
@opindex Wno-attribute-warning
@opindex Wattribute-warning
@code{warning}属性で宣言された関数（@pxref{Function Attributes}）の使用について警告しない。 デフォルトでは、この警告は有効になっています。 @option{-Wno-attribute-warning}を使用して警告を無効にしたり、@option{-Wno-error=attribute-warning}を使用して@option{-Werror}フラグでコンパイルしたときにエラーを無効にしたりできます。

@item -Wno-deprecated
@opindex Wno-deprecated
@opindex Wdeprecated
廃止された機能の使用について警告しない。 @xref{Deprecated Features}.

@item -Wno-deprecated-declarations
@opindex Wno-deprecated-declarations
@opindex Wdeprecated-declarations
@code{deprecated}を使うことで廃止予定としてマークされた関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、
型(@pxref{Type Attributes})について警告しない。

@item -Wno-overflow
@opindex Wno-overflow
@opindex Woverflow
定数式のコンパイル時桁あふれについて警告しない。

@item -Wno-odr
@opindex Wno-odr
@opindex Wodr
リンク時最適化中の単一定義規則違反を警告する。
デフォルトで有効である。

@item -Wopenmp-simd
@opindex Wopenm-simd
ベクトル化コストモデルがユーザによって設定されたOpenMP simdディレクティブを上書きしたら警告する。
@option{-fsimd-cost-model=unlimited}はコストモデルを和らげるために使うことができる。

@item -Woverride-init @r{(CとObjective-C専用)}
@opindex Woverride-init
@opindex Wno-override-init
@opindex W
@opindex Wextra
@opindex Wno-extra
指示付きの初期化子を使った時に副作用のない初期化されたフィールドが上書きされていたら警告する。
(@pxref{Designated Inits, , 指示付きの初期化子}).

この警告は@option{-Wextra}に含まれる。これなしで他の@option{-Wextra}警告を得るには、@option{-Wextra
-Wno-override-init}を使う。

@item -Woverride-init-side-effects @r{(CとObjective-C専用)}
@opindex Woverride-init-side-effects
@opindex Wno-override-init-side-effects
指示付きの初期化子(@pxref{Designated Inits, , 指示付きの初期化子})を使った時に副作用付きの初期化フィールドを
上書きしたら警告する。これはデフォルトで有効である。

@item -Wpacked
@opindex Wpacked
@opindex Wno-packed
構造体がpacked属性を与えられているが、構造体のレイアウトかサイズにpacked属性がなんの効果もない時に警告する。
そのような構造体はあまりない利点のために境界がずれているかもしれない。例えば、このコードでは、
@code{struct bar}の変数@code{f.x}は@code{struct bar}自身はpack属性がないにもかかわらず、境界がずれている。

@smallexample
@group
struct foo @{
  int x;
  char a, b, c, d;
@} __attribute__((packed));
struct bar @{
  char z;
  struct foo f;
@};
@end group
@end smallexample

@item -Wpacked-bitfield-compat
@opindex Wpacked-bitfield-compat
@opindex Wno-packed-bitfield-compat
GCCの4.1、4.2、4.3系列は@code{char}型のビットフィールドの@code{packed}属性を無視する。
これはGCC 4.4では修正されたが、この変更は構造体のレイアウトの違いを引き起こす。
GCCはGCC4.4でそのようなフィールドのオフセットが変わった時に知らせる。
例えば、この構造体でもはや@code{a}フィールドと@code{b}フィールドには4ビットの隙間が存在しない。

@smallexample
struct foo
@{
  char a:4;
  char b:8;
@} __attribute__ ((packed));
@end smallexample

この警告はデフォルトで有効である。この警告を無効にするには、@option{-Wno-packed-bitfield-compat}を使う。

@item -Wpacked-not-aligned @r{(C, C++, Objective-C  Objective-C++専用)}
@opindex Wpacked-not-aligned
@opindex Wno-packed-not-aligned
パックされたstructまたはunionで明示的に指定されたアラインメントを持つ構造体フィールドがミスアラインされている場合に警告します。 たとえば、このコードでは、@code{warning：alignment 1 of
'struct S' is less than 8}のように、@code{struct S}で警告が発行されます。

@smallexample
@group
struct __attribute__ ((aligned (8))) S8 @{ char a[8]; @};
struct __attribute__ ((packed)) S @{
  struct S8 s8;
@};
@end group
@end smallexample

この警告は@option{-Wall}によって有効になります。

@item -Wpadded
@opindex Wpadded
@opindex Wno-padded
構造体の要素の境界を合わせるためか、構造体全体の境界を合わせるために構造体に隙間を入れていたら警告する。
これが起こった時、隙間を減らして時々構造体をもっと小さくするために構造体のフィールドを並べ替える事が可能である。

@item -Wredundant-decls
@opindex Wredundant-decls
@opindex Wno-redundant-decls
複数の宣言が正当で、なんの変化がない時でも、何かが同じスコープで１つより多くのものが宣言されていたら警告する。

@item -Wno-restrict
@opindex Wrestrict
@opindex Wno-restrict
@code{restrict}修飾パラメータ（またはC++では@code{__restrict}修飾パラメータ）によって参照されるオブジェクトが別の引数でエイリアスされた場合、またはそのようなオブジェクト間のコピーが重複した場合に警告する。たとえば、以下の@code{strcpy}関数を呼び出しは、最初の文字を最後の4文字に置き換えて文字列を切り詰めようとする。 しかし、呼び出しが終端NULを@code{a[4]}に書き込むため、コピーは重なり、呼び出しは診断される。

@smallexample
void foo (void)
@{
  char a[] = "abcd1234";
  strcpy (a, a + 4);
  @dots{}
@}
@end smallexample
@option{-Wrestrict}オプションは、最適化を行わなくてもシンプルなオーバーラップのインスタンスを検出するが、@option{-O2}以上でうまく動作する。 これは@option{-Wall}に含まれている。

@item -Wnested-externs @r{(CとObjective-C専用)}
@opindex Wnested-externs
@opindex Wno-nested-externs
@code{extern}宣言が関数内に現れたら警告する。

@item -Winline
@opindex Winline
@opindex Wno-inline
関数がインラインと宣言されていてもインラインできない時に警告する。
このオプションを使っても、コンパイラはシステムヘッダで宣言されたインライン関数への失敗は警告しない。

コンパイラは関数をインライン化するかどうかを決定するために様々なヒューリスティックを使う。例えば、
コンパイラはインライン化される関数のサイズと現在の関数ですでにされたインラインの量を考慮する。
したがって、ソースプログラムでのの一見ささいな変化が@option{-Winline}で生成される警告を現れたり、消したりする、

@item -Wint-in-bool-context
@opindex Wint-in-bool-context
@opindex Wno-int-in-bool-context
@code{if（a <= b ? 2 : 3）}のような、ブール値のコンテキストでの非ブール値整数定数を使った条件式（？:)のような、ブール値が予想される場所での整数値の疑わしい使用を警告する。または、@code{for（a = 0; 1 << a; a ++）;}のような、ブール値のコンテキスト内の符号付きの左シフト整数。同様にデータの種類に関係なく、あらゆる種類の乗算。この警告は@option{-Wall}によって有効になる。

@item -Wno-int-to-pointer-cast
@opindex Wno-int-to-pointer-cast
@opindex Wint-to-pointer-cast
異なるサイズの整数へのポインタへのキャストについての警告を抑制する。C++ではより小さいサイズのポインタ型へのキャストはエラーである。
@option{Wint-to-pointer-cast}はデフォルトで有効である。

@item -Wno-pointer-to-int-cast @r{(CとObjective-C専用)}
@opindex Wno-pointer-to-int-cast
@opindex Wpointer-to-int-cast
ポインタから異なるサイズの整数型へのキャストの警告を抑制する。

@item -Winvalid-pch
@opindex Winvalid-pch
@opindex Wno-invalid-pch
コンパイル済みヘッダ(@pxref{Precompiled Headers})が検索パスに見つかったが使うことができないときに警告する。

@item -Wlong-long
@opindex Wlong-long
@opindex Wno-long-long
@code{long long}型が使われた時に警告する。これはISO C90とC++98モードで@option{-Wpedantic}か@option{-Wtraditional}によって有効になる。
警告メッセージを抑制するには、@option{-Wno-long-long}を使う。

@item -Wvariadic-macros
@opindex Wvariadic-macros
@opindex Wno-variadic-macros
可変長マクロがISO C90モードで使われたか、GNU代替構文がISO C99モードで使われたら警告する。これは@option{-Wpedantic}か@option{-Wtraditional}
で有効になる。警告メッセージを抑制するなら、@option{-Wno-variadic-macros}を使う。

@item -Wno-varargs
@opindex Wvarargs
@opindex Wno-varargs
@code{va_start}のような可変長引数を扱うためのマクロの疑問な使用法を警告しない。これらの警告これはデフォルトで有効である。

@item -Wvector-operation-performance
@opindex Wvector-operation-performance
@opindex Wno-vector-operation-performance
ベクトル操作がアーキテクチャのSIMD機能経由で実装されていなければ警告する。主にパフォーマンス調整に役立つ。
ベクトル操作は@code{piecewise}で実装可能であり、それは全ベクトル単位でスカラー演算が実行されることを意味する。
@code{in parallel}は、ベクトル操作がより広い型のスカラーを使って実装されることを意味し、通常ははもっとパフォーマンスがよくなる。
@code{as single scalar}は、ベクトルがスカラー型に合うことを意味する。

@item -Wvla
@opindex Wvla
@opindex Wno-vla
コードで可変長配列が使われたら警告する。@option{-Wno-vla}は@option{-Wpedantic}から可変長配列の警告を止める。

@item -Wvla-larger-than=@var{byte-size}
@opindex Wvla-larger-than=
@opindex Wno-vla-larger-thanこのオプションが使われると、コンパイラはサイズが制限されていないか、@var{byte-size}バイト以上になりうる引数によって制限されている使用について警告する。これは@option{-Walloca-larger-than=@var{byte-size}}の動きと同様だが、可変長配列に対して働く。

GCCは既知の値の小さい可変長配列をただの配列に最適化するかもしれず、したがって、そのような配列では警告が発せられないかもしれないことに注意する。

この警告は@option{-Wall}によっては有効にされず、@option{-ftree-vrp}が活性（@option{-O2}以上のデフォルト）のときだけ活性になる。

@option{-Walloca-larger-than=@var{byte-size}}も見よ。

@item -Wno-vla-larger-than
@opindex Wno-vla-larger-than
@option{-Wvla-larger-than=}警告を無効にします。 このオプションは、@option{-Wvla-larger-than=}@samp{SIZE_MAX}以上と同等です。

@item -Wvla-parameter
@opindex Wno-vla-parameter
一貫性のない種類または形式の可変長配列型の引数を含む関数の再宣言について警告し、@option{-Warray-bounds}などの警告によってそのようなパラメーターへの範囲外アクセスの検出を有効にします。

最初の関数宣言がVLA形式を使用する場合、配列で指定された境界は、関数の呼び出しで提供されると予想される要素の最小数と、関数によってアクセスされる要素の最大数であると見なされます。 十分なサイズの引数を提供しなかったり、最大数を超える要素にアクセスしたりすると、診断される場合があります。

たとえば、警告は次の再宣言に対してトリガーされます。これは、最初の宣言では任意のサイズの配列を@code{f}に渡すことができ、2番目の宣言では配列引数に少なくとも@code{n}要素が必要であると指定されているためです。 さらに、実際のVLAバウンドを超える関連付けられたVLAバウンドパラメーターを使用して@code{f}を呼び出すと、警告もトリガーされます。

@smallexample
void f (int n, int[n]);
void f (int, int[]);     // warning: argument 2 previously declared as a VLA

void g (int n)
@{
    if (n > 4)
      return;
    int a[n];
    f (sizeof a, a);     // warning: access to a by f may be out of bounds
  @dots{}
@}

@end smallexample

@option{-Wvla-parameter}は@option {-Wall}に含まれています。 @option{-Warray-parameter}オプションは、通常の配列引数に関連する同様の問題に対して警告をトリガーします。

@item -Wvolatile-register-var
@opindex Wvolatile-register-var
@opindex Wno-volatile-register-var
レジスタ変数がvolatileと宣言されていたら警告する。volatile修飾子はレジスタ変数の読み書きを消すかもしれない
すべての最適化を抑制する。この警告は@option{-Wall}で有効である。

@item -Wdisabled-optimization
@opindex Wdisabled-optimization
@opindex Wno-disabled-optimization
要求される最適化パスが無効にされていたら警告する。この警告は一般的にはあなたのコードに何か悪いことがあることを意味するのではない。
単にGCCでの最適化器がコードを効果的に扱うことができないこと意味する。しばしば、問題はコードが大きすぎるか複雑すぎることにある。
GCCは最適化自身が大量の過度の時間を取りそうな場合はプログラムの最適化を拒否する。

@item -Wpointer-sign @r{(CとObjective-C専用)}
@opindex Wpointer-sign
@opindex Wno-pointer-sign
異なる符号性のポインタ引数渡しか代入について警告する。このオプションはCとObjective-Cでのみサポートされている。
これは@option{-Wall}と@option{-Wpedantic}に含まれていて、@option{-Wno-pointer-sign}で無効にできる。

@item -Wstack-protector
@opindex Wstack-protector
@opindex Wno-stack-protector
このオプションは@option{-fstack-protector}が有効の時だけ有効である。それはスタック破壊から守られない関数を警告する。

@item -Woverlength-strings
@opindex Woverlength-strings
@opindex Wno-overlength-strings
C標準で指定された「最小の最大」長より長い文字列定数について警告する。最近のコンパイラは一般的には
標準の最小限度よりずっと長い文字列定数を許すが、とても移植性のあるプログラムは長い文字列を使うのを避けるべきである。

制限は文字列定数連結の@emph{後に}に適用され、最後のNULはカウントしない。C90では、制限は509文字である。
C99では4095に引き上げられた。C++98では規範的な最小最大値が指定されていないので、C++では長すぎる文字列を診断しない。

このオプションは@option{-pedantic}に含まれていて、@option{-Wno-overlength-strings}で無効にできる。

@item -Wunsuffixed-float-constants @r{(CとObjective-C専用)}
@opindex Wunsuffixed-float-constants
接尾辞がないどんな浮動小数点定数にも警告を発する。@option{-Wsystem-headers}と一緒に使った時は
システムヘッダ内のそのような定数に警告する。これはC99への10進浮動小数点拡張からのプラグマ
@code{FLOAT_CONST_DECIMAL64}と一緒に使うコードを準備するときに役立つ。

@item -Wno-lto-type-mismatch
@opindex Wlto-type-mismatch
@opindex Wno-lto-type-mismatch

リンク時最適化の間に異なるコンパイル単位からのグローバル宣言ち不一致の型について警告する。
有効にするには@option{-flto}が要求される。デフォルトで有効である。

@item -Wno-designated-init @r{(CとObjective-C専用)}
@opindex Wdesignated-init
@opindex Wno-designated-init
位置の初期化子が@code{designated_init}属性をマークされた構造体を初期化するために使われたら警告する。

@end table

@node Static Analyzer Options
@section 静的解析を制御するオプション

@table @gcctabopt
@item -fanalyzer
@opindex analyzer
@opindex fanalyzer
@opindex fno-analyzer
このオプションは、プログラムフローの静的分析を有効にし、コードを介して「興味深い」プロシージャ間パスを探し、見つかった問題について警告を発行します。

この分析は、他のGCC警告よりもはるかにコストがかかります。

このオプションを有効にすると、次の警告が効果的に有効になります。

@gccoptlist{ 
-Wanalyzer-double-fclose 
-Wanalyzer-double-free 
-Wanalyzer-exposure-through-output-file 
-Wanalyzer-file-leak 
-Wanalyzer-free-of-non-heap 
-Wanalyzer-malloc-leak 
-Wanalyzer-mismatching-deallocation 
-Wanalyzer-possible-null-argument 
-Wanalyzer-possible-null-dereference 
-Wanalyzer-null-argument 
-Wanalyzer-null-dereference 
-Wanalyzer-shift-count-negative 
-Wanalyzer-shift-count-overflow 
-Wanalyzer-stale-setjmp-buffer 
-Wanalyzer-tainted-array-index 
-Wanalyzer-unsafe-call-within-signal-handler 
-Wanalyzer-use-after-free 
-Wanalyzer-use-of-pointer-in-stale-stack-frame 
-Wanalyzer-write-to-const 
-Wanalyzer-write-to-string-literal 
}

このオプションは、GCCがアナライザーサポートを有効にして構成されている場合にのみ使用できます。

@item -Wanalyzer-too-complex
@opindex Wanalyzer-too-complex
@opindex Wno-analyzer-too-complex
@option{-fanalyzer}が有効な場合、アナライザーはさまざまなヒューリスティックを使用してプログラム内の制御フローとデータフローを探索しようとしますが、これらは十分に複雑なコードによって無効にすることがあります。

デフォルトでは、コードが複雑すぎてアナライザーが完全に探索できず、内部制限に達すると、分析はサイレントに停止します。 @option{-Wanalyzer-too-complex}オプションは、これが発生した場合に警告します。

@item -Wno-analyzer-double-fclose
@opindex Wanalyzer-double-fclose
@opindex Wno-analyzer-double-fclose
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。 @option{-Wno-analyzer-double-fclose}を使用して無効にします。

この診断は、@code{FILE *}が@code{fclose}を複数回呼び出すことができるコードを通るパスについて警告します。

@item -Wno-analyzer-double-free
@opindex Wanalyzer-double-free
@opindex Wno-analyzer-double-free
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。 @option{-Wno-analyzer-double-free}を使用して無効にします。

この診断は、ポインターが@code{free}を複数回呼び出すことができるコードのパスを警告します。

@item -Wno-analyzer-exposure-through-output-file
@opindex Wanalyzer-exposure-through-output-file
@opindex Wno-analyzer-exposure-through-output-file
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。 @option{-Wno-analyzer-exposure-through-output-file}を使用して無効にします。

この診断は、セキュリティ上重要な値が出力ファイルに書き込まれる（ログファイルにパスワードを書き込むなど）コードを通るパスについて警告します。

@item -Wno-analyzer-file-leak
@opindex Wanalyzer-file-leak
@opindex Wno-analyzer-file-leak
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。 @option{-Wno-analyzer-file-leak}を使用して無効にします。

この診断は、@code{<stdio.h>} @code{FILE *}ストリームオブジェクトがリークしているコードのパスを警告します。

@item -Wno-analyzer-free-of-non-heap
@opindex Wanalyzer-free-of-non-heap
@opindex Wno-analyzer-free-of-non-heap
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-free-of-non-heap}を使用して無効にします。

この診断は、@code{free}が非ヒープポインター（たとえば、スタック上のバッファー、またはグローバル）で呼び出されるコードのパスを警告します。

@item -Wno-analyzer-malloc-leak
@opindex Wanalyzer-malloc-leak
@opindex Wno-analyzer-malloc-leak
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-malloc-leak}を使用して無効にします。

この診断は、@code{malloc}を介して割り当てられたポインターがリークされるコードのパスについて警告します。

@item -Wno-analyzer-mismatching-deallocation
@opindex Wanalyzer-mismatching-deallocation
@opindex Wno-analyzer-mismatching-deallocation
この警告には@option{-fanalyzer}が必要です。これにより、警告が有効になります。 @option{-Wno-analyzer-mismatching-deallocation}を使用して無効にします。

この診断は、ポインター値の割り当てに使用された関数に基づいて、ポインター値に対して誤った割り当て解除関数が呼び出されたコードを通るパスについて警告します。

@item -Wno-analyzer-possible-null-argument
@opindex Wanalyzer-possible-null-argument
@opindex Wno-analyzer-possible-null-argument
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-possible-null-argument}を使用して無効にします。

この診断は、NULLの可能性がある値が、非NULL値を必要とする@code{__attribute__((nonnull))}でマークされた関数引数に渡されるコードのパスを警告します。

@item -Wno-analyzer-possible-null-dereference
@opindex Wanalyzer-possible-null-dereference
@opindex Wno-analyzer-possible-null-dereference
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-possible-null-dereference}を使用して無効にします。

この診断は、NULLの可能性がある値が逆参照されるコードを通るパスについて警告します。

@item -Wno-analyzer-null-argument
@opindex Wanalyzer-null-argument
@opindex Wno-analyzer-null-argument
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-null-argument}を使用して無効にします。

この診断は、NULLであることがわかっている値が非NULL値を必要とする@code{__attribute__((nonnull))}でマークされた関数引数に渡されるコードを通るパスを警告します。

@item -Wno-analyzer-null-dereference
@opindex Wanalyzer-null-dereference
@opindex Wno-analyzer-null-dereference
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-null-dereference}を使用して無効にします。

この診断は、NULLであることがわかっている値が逆参照されるコードを通るパスについて警告します。

@item -Wno-analyzer-shift-count-negative
@opindex Wanalyzer-shift-count-negative
@opindex Wno-analyzer-shift-count-negative
この警告には@option{-fanalyzer}が必要です。これにより、警告が有効になります。 @option{-Wno-analyzer-shift-count-negative}を使用して無効にします。

この診断は、負のカウントでシフトが試行されたコードを通るパスについて警告します。 これは、C/C ++フロントエンドに実装されている@option{-Wshift-count-negative}診断に似ていますが、構文ツリーを解析するだけでなく、プロシージャ間のパスの分析に基づいて実装されています。 ただし、アナライザーはそのようなパスの検出を優先しないため、他の警告に比べてフォールスネガティブになる可能性が高くなります。

@item -Wno-analyzer-shift-count-overflow
@opindex Wanalyzer-shift-count-overflow
@opindex Wno-analyzer-shift-count-overflow
この警告には@option{-fanalyzer}が必要です。これにより、警告が有効になります。 @option{-Wno-analyzer-shift-count-overflow}を使用して無効にします。

この診断は、オペランドの型の精度以上のカウントでシフトが試行されたコード内のパスについて警告します。 これは、C/C++フロントエンドに実装されている@option{-Wshift-count-overflow}診断に似ていますが、構文ツリーを解析するだけでなく、プロシージャ間のパスの分析に基づいて実装されています。 ただし、アナライザーはそのようなパスの検出を優先しないため、他の警告に比べてフォールスネガティブになる可能性が高くなります。

@item -Wno-analyzer-stale-setjmp-buffer
@opindex Wanalyzer-stale-setjmp-buffer
@opindex Wno-analyzer-stale-setjmp-buffer
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-stale-setjmp-buffer}を使用して無効にします。

この診断では、@code{longjmp}が呼び出されて返された関数の@code{setjmp}呼び出しに関連する@code{jmp_buf}に巻き戻されるコードを通るパスについて警告します。

巻き戻しの場所を記録するために@code{jmp_buf}で@code{setjmp}が呼び出されると、スタックフレームが記録されます。 @code{setjmp}呼び出しを含む関数が戻ると、スタックフレームは無効になります。 @code{longjmp}を介して巻き戻そうとすると、存在しないスタックフレームを参照し、おそらくクラッシュ（またはさらに悪いこと）につながります。

@item -Wno-analyzer-tainted-array-index
@opindex Wanalyzer-tainted-array-index
@opindex Wno-analyzer-tainted-array-index
この警告には@option{-fanalyzer}と@option{-fanalyzer-checker=taint}が必要で、それらがあると有効になります。@option{-Wno-analyzer-tainted-array-index}を使用して無効にします。

この診断は、攻撃者の制御下にある可能性のある値がサニタイズされずに配列アクセスのインデックスとして使用されるコードを通るパスについて警告します。

@item -Wno-analyzer-unsafe-call-within-signal-handler
@opindex Wanalyzer-unsafe-call-within-signal-handler
@opindex Wno-analyzer-unsafe-call-within-signal-handler
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-unsafe-call-within-signal-handler}を使用して無効にします。

この診断では、非同期シグナルに対して安全でないことがわかっている関数（@code{fprintf}など）がシグナルハンドラーから呼び出されるコードのパスについて警告します。

@item -Wno-analyzer-use-after-free
@opindex Wanalyzer-use-after-free
@opindex Wno-analyzer-use-after-free
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-use-after-free}を使用して無効にします。

この診断は、@code{free}が呼び出された後にポインターが使用されるコードのパスを警告します。

@item -Wno-analyzer-use-of-pointer-in-stale-stack-frame
@opindex Wanalyzer-use-of-pointer-in-stale-stack-frame
@opindex Wno-analyzer-use-of-pointer-in-stale-stack-frame
この警告には@option{-fanalyzer}が必要で、それがあると有効になります。
@option{-Wno-analyzer-use-of-pointer-in-stale-stack-frame}を使用して無効にします。

この診断は、古いスタックフレーム内の変数を指すポインターが逆参照されるコードを通るパスについて警告します。

@item -Wno-analyzer-write-to-const
@opindex Wanalyzer-write-to-const
@opindex Wno-analyzer-write-to-const
この警告には@option{-fanalyzer}が必要です。これにより、警告が有効になります。 @option{-Wno-analyzer-write-to-const}を使用して無効にします。

この診断は、アナライザーが@code{const}オブジェクトへのポインターを介して書き込もうとしたことを検出したコードを通るパスについて警告します。 ただし、アナライザーはそのようなパスの検出を優先しないため、他の警告に比べてフォールスネガティブになる可能性が高くなります。

@item -Wno-analyzer-write-to-string-literal
@opindex Wanalyzer-write-to-string-literal
@opindex Wno-analyzer-write-to-string-literal
この警告には@option{-fanalyzer}が必要です。これにより、警告が有効になります。 @option{-Wno-analyzer-write-to-string-literal}を使用して無効にします。

この診断は、アナライザーが文字列リテラルへのポインターを介して書き込もうとしたことを検出したコードを通るパスについて警告します。 ただし、アナライザーはそのようなパスの検出を優先しないため、他の警告に比べてフォールスネガティブになる可能性が高くなります。

@end table

探索を制御するための関連パラメータは次のとおりです。
@option{--param analyzer-bb-explosion-factor=@var{value}}, 
@option{--param analyzer-max-enodes-per-program-point=@var{value}}, 
@option{--param analyzer-max-recursion-depth=@var{value}}, と
@option{--param analyzer-min-snodes-for-call-summary=@var{value}}.

以下のオプションはアナライザーを制御します。

@table @gcctabopt

@item -fanalyzer-call-summaries
@opindex fanalyzer-call-summaries
@opindex fno-analyzer-call-summaries
コールサイトから可能な各リターンまでの関数のすべてのパスを探索するのではなく、特定の呼び出しの効果を計算することにより、手続き間の分析を簡素化します。

有効にした場合、呼び出しの要約は複数の呼び出しサイトを持つ、（@option{-param analyzer-min-snodes-for-call-summary=@var{value}}による）十分に複雑な関数にのみ使用されます。

@item -fanalyzer-checker=@var{name}
@opindex fanalyzer-checker
名前付きチェッカーのみを実行するようにアナライザーを制限し、それを有効にします。

@option{-Wanalyzer-tainted-array-index}を実装する@code{taint}チェッカーなど、一部のチェッカーはデフォルトで（@option{-fanalyzer}を使用しても）無効になっており、このオプションは有効にするために必要です。

@item -fno-analyzer-feasibility
@opindex fanalyzer-feasibility
@opindex fno-analyzer-feasibility
このオプションは、アナライザー開発者を対象としています。

デフォルトでは、アナライザーは、発行する診断ごとに実行可能な制御フローパスがあることを確認します。つまり、保持される条件は相互に排他的ではありません。 実行可能なパスが見つからない診断は拒否されます。 このコードの問題をデバッグするために、このフィルタリングは@option{-fno-analyzer-feasibility}で抑制できます。

@item -fanalyzer-fine-grained
@opindex fanalyzer-fine-grained
@opindex fno-analyzer-fine-grained
このオプションは、アナライザー開発者を対象としています。

内部的にアナライザーは、制御フローグラフとデータフロー情報を組み合わせた「分解グラフ」を作成します。

デフォルトでは、このグラフのエッジには、基本ブロック内の複数のステートメントの実行の影響を含めることができます。 @option{-fanalyzer-fine-grained}を使用すると、各ステートメントが独自の優位性を獲得します。

@item -fanalyzer-show-duplicate-count
@opindex fanalyzer-show-duplicate-count
@opindex fno-analyzer-show-duplicate-count
このオプションはアナライザーの開発者を対象としています。複数の診断が互いに重複していることが検出された場合、最適な診断を報告するときにノートが発行され、重複排除ロジックによって抑制された追加の診断の数が示されます。

@item -fno-analyzer-state-merge
@opindex fanalyzer-state-merge
@opindex fno-analyzer-state-merge
このオプションは、アナライザー開発者を対象としています。

デフォルトでは、アナライザーは、「分解されたグラフ」を作成するときに、各プログラムポイントで十分に類似した状態をマージすることにより、分析を簡略化しようとします。 @option{-fno-analyzer-state-merge}を使用すると、このマージを抑制して、状態処理の問題をデバッグできます。

@item -fno-analyzer-state-purge
@opindex fanalyzer-state-purge
@opindex fno-analyzer-state-purge
このオプションは、アナライザー開発者を対象としています。

デフォルトでは、アナライザーは、プログラムポイントでの状態の側面のうち、関連性がなくなったように見える部分、例えば 関数内で後でアクセスされず、リーク分析に関連しないローカルの値をパージすることにより、分析を簡略化しようとします。

@option{-fno-analyzer-state-purge}を使用すると、状態処理の問題をデバッグするために、この状態のパージを抑制できます。

@item -fanalyzer-transitivity
@opindex fanalyzer-transitivity
@opindex fno-analyzer-transitivity
このオプションは、アナライザー内の制約の推移性を有効にします。

@item -fanalyzer-verbose-edges
このオプションは、アナライザー開発者を対象としています。 これにより、診断パス内の制御フローの説明で、より詳細で低レベルの詳細が可能になります。

@item -fanalyzer-verbose-state-changes
このオプションは、アナライザー開発者を対象としています。 診断パス内のステートマシンに関連するイベントの説明で、より詳細で低レベルの詳細が可能になります。

@item -fanalyzer-verbosity=@var{level}
このオプションは、アナライザー診断のために出力される制御フローパスの複雑さを制御します。

@var{level}は以下の値をとります。

@table @samp
@item 0
このレベルでは、プロシージャ間の呼び出しと戻りのイベントが、診断に関連する最も適切な状態変化イベントと共に表示されます。 たとえば、二重@code{free}診断の場合、@code{free}への両方の呼び出しが表示されます。

@item 1
前のレベルと同様に、各関数へのエントリのイベントも表示します。

@item 2
前のレベルと同様に、問題のトリガーに重要な制御フローに関連するイベントも表示します（例：条件付きの「実際のパス」）。

このレベルがデフォルトです。

@item 3
前のレベルと同様ですが、重要なイベントだけでなく、すべての制御フローイベントを表示します。

@item 4
このレベルはアナライザー開発者を対象としています。 アナライザーのデバッグを目的とした他のさまざまなイベントを追加します。

@end table

@item -fdump-analyzer
@opindex fdump-analyzer
アナライザーの動作に関する内部の詳細を@file{@var{file}.analyzer.txt}にダンプします。
このオプションは、@option{-fdump-analyzer-stderr}によってオーバーライドされます。

@item -fdump-analyzer-stderr
@opindex fdump-analyzer-stderr
アナライザーが標準エラーに対して行っていることに関する内部の詳細をダンプします。
このオプションは@option{-fdump-analyzer}をオーバーライドします。

@item -fdump-analyzer-callgraph
@opindex fdump-analyzer-callgraph
GraphVizでの表示に適したコールグラフの表現を@file{@var{file}.callgraph.dot}にダンプします。

@item -fdump-analyzer-exploded-graph
@opindex fdump-analyzer-exploded-graph
GraphVizでの表示に適した「分解グラフ」の表現を@file{@var{file}.eg.dot}にダンプします。
ノードは、状態の変化を強調するために、状態マシンの状態に基づいて色分けされます。

@item -fdump-analyzer-exploded-nodes
@opindex dump-analyzer-exploded-nodes
「分解されたグラフ」のノードがプログラムソースに関連している場所を示す診断を送信します。

@item -fdump-analyzer-exploded-nodes-2
@opindex dump-analyzer-exploded-nodes-2
「分解グラフ」のテキスト表現を@file{@var{file}.eg.txt}にダンプします。

@item -fdump-analyzer-exploded-nodes-3
@opindex dump-analyzer-exploded-nodes-3
「分解グラフ」のテキスト表現をノードごとに1つのダンプファイルに、@file{@var{file}.eg-@var{id}.txt}にダンプします。これは通常、多数のダンプファイルです。

@item -fdump-analyzer-json
@opindex fdump-analyzer-json
アナライザー内部の圧縮されたJSON表現を@file{@var{file}.analyzer.json.gz}にダンプします。 正確な形式は変更される場合があります。

@item -fdump-analyzer-state-purge
@opindex fdump-analyzer-state-purge
@option{-fdump-analyzer-supergraph}のように、GraphVizでの表示に適した「スーパーグラフ」の表現をダンプしますが、各ノードでパージされる状態に関する情報をグラフに注釈として付けます。
グラフは@file{@var{file}.state-purge.dot}に書き込まれます。

@item -fdump-analyzer-supergraph
@opindex fdump-analyzer-supergraph
GraphVizでの表示に適した「スーパーグラフ」の表現を@file{@var{file}.supergraph.dot}および@file{@var {file}.supergraph-eg.dot}にダンプします。 これらは、プログラム内のすべての制御フローグラフと、呼び出しと戻りの手続き間エッジを示しています。 2番目のダンプには、「分解されたグラフ」内のノードとそれらに関連付けられた診断を示す注釈が含まれています。

@end table

@node Debugging Options
@section あなたのプログラムをデバッグするオプション
@cindex options, debugging
@cindex debugging information options

GCCにデバッガで使う追加の情報を出力するように伝えるには、殆どの場合で他のオプションに@option{-g}を加える必要があるだけである。

GCCは@option{-O}つきで@option{-g}を使うことができる。最適化コードによって取られた近道は時々驚かせるかもしれない。
あなたが宣言したある変数は全く存在しないかもしれない。制御の流れはあなたが期待する場所から一時的に移動するかもしれない。
ある文は定数の結果を計算しているか、すでに持っている値なので実行されないかもしれない。ある文はループの外に移動したので異なる場所で実行されているかもしれない。
それにもかかわらず、最適化された出力をデバッグすることは可能である。これはバグが有るかもしれないプログラムに最適化器を使うことを
合理的にする。

もし他の最適化オプションを使っていないなら、@option{-Og}を@option{-g}と一緒に使うことを考えよ。(@pxref{Optimize Options})
@option{-O}オプションが全く無いと、デバッグに有用な情報集めるコンパイラパスが全く走らないので、@option{-Og}はよりよいデバッグ経験を起こすかもしれない。

@table @gcctabopt
@item -g
@opindex g
オペレーションシステムのネイティブのフォーマット(stabs, COFF, XCOFF, DWARF)でデバッグ情報を生成する。GDBはこのデバッグ情報で動くことができる。

stabsフォーマットを使う大抵のシステムでは、GDBだけが使うことができる追加のデバッグ情報の使用を@option{-g}は有効にする。この追加の情報は
GDBでのデバッグをより良くするが、他のデバッガをクラッシュさせたり、プログラムの読み込みを拒否させるだろう。もし、追加の情報の生成するかどうかを
制御したいならば、@option{-gstabs+}, @option{-gstabs}, @option{-gxcoff+}, @option{-gxcoff}, @option{-gvms}(下を見よ）を使う。

@item -ggdb
@opindex ggdb
GDBによって使うためのデバッグ情報を生成する。これは利用可能な最も表現力のあるフォーマット
（DWARF, stabs,もしどちらもサポートされていないならネイティブフォーマット）を使い、もし可能ならばGDBで拡張を含むことを意味する。

@item -gdwarf
@itemx -gdwarf-@var{version}
@opindex gdwarf
（もしサポートされているなら）DWARFフォーマットでデバッグ情報を出力する。@var{varsion}は２、３、４、５のどれかでよい。
デフォルトのバージョンはたいていのターゲットで４である。DWARFバージョン５は実験的でしかない。

DWARFバージョン２では、ある移植では巻き戻しテーブルで衝突しないあるDWARF3拡張を要求し、いつも使う。

バージョン4は最大の効果にはGDB 7.0と@option{-fvar-tracking-assignments}を要求する。

GCCはもはやDWARFバージョン1をサポートせず、それはバージョン2以降とかなり異なっている。
歴史的な理由で、他の@option{-fno-dwarf2-cfi-asm}のようなDWARF関連のオプションは名前にDWARFバージョン2への参照を含んでいるが、DWARFの現在サポートされたすべてのバージョンに適用される。

@item -gstabs
@opindex gstabs
（もしサポートされているなら）stabsフォーマットにデバッグ情報をGDB拡張なしで生成する。
これはたいていのBSDシステムでDBXで使われたフォーマットである。MIPS、Alpha、System Vリリース4システムでは、
このオプションはDBXで理解されないstabsデバッグ出力を生成する。System V リリース4システムでは、このオプションは
GNUアセンブラを要求する。

@item -gstabs+
@opindex gstabs+
（もしサポートされているなら）stabsフォーマットにGNUデバッガ(GDB)によってのみ理解されるGNU拡張を使って
デバッグ情報を生成する。これらの拡張の使用はおそらく他のデバッガをクラッシュさせたり、プログラムの読み込みを拒否させたりするだろう。

@item -gxcoff
@opindex gxcoff
（もしサポートされているなら）XCOFFフォーマットにデバッグ情報を生成する。
これはIBM RS/6000システムのDBXデバッガで使われるフォーマットである。

@item -gxcoff+
@opindex gxcoff+
（もしサポートされているなら）XCOFFフォーマットにGNUデバッガ(GDB)によってのみ理解されるGNU拡張を使ってデバッグ情報を生成する。
これらの拡張の使用はおそらく他のデバッガをクラッシュさせたり、プログラムの読み込みを拒否させたりし、GNUアセンブラ(GAS)以外のアセンブラを
エラーで失敗させるだろう。

@item -gvms
@opindex gvms
（もしサポートされているなら）Alpha/VMSデバッグフォーマットにデバッグ情報を生成する。これはAlpha/VMSシステムのDEBUGによって使われるフォーマットである。

@item -g@var{level}
@itemx -ggdb@var{level}
@itemx -gstabs@var{level}
@itemx -gxcoff@var{level}
@itemx -gvms@var{level}
デバッグ情報を要求し、@var{level}でどのくらい多くの情報かを指定する。デフォルトのレベルは2である。

レベル0はデバッグ情報を全く生成しない。したがって、@option{-g0}は@option{-g}を反転させる。

レベル1は最小の情報を生成し、デバッグする計画のないプログラムの部分でバックトレースを生成するのに十分な量である。
これは関数、外部変数、行番号表の記述を含むが、ローカル変数の情報はない。

レベル3は、プログラム中の全マクロ定義のような、追加の情報を含む。あるデバッガは@option{-g3}を使った時にマクロ展開をサポートする。

@option{-gdwarf}は@option{-gdwarf-@var{level}}との混乱を避けるために、デバッグレベルの連結を受理しない。代わりにDWARFデバッグレベルを変えるためには
追加の@option{-g@var{level}}を使う。

@item -fno-eliminate-unused-debug-symbols
@opindex feliminate-unused-debug-symbols
@opindex fno-eliminate-unused-debug-symbols
デフォルトでは、実際に使用されていないシンボルのデバッグ情報は生成されません。 すべてのシンボルのデバッグ情報が必要な場合は、このオプションを使用します。

@item -femit-class-debug-always
@opindex femit-class-debug-always
C++クラスのデバッグ情報を単一オブジェクトファイルに生成する代わりに、クラスを使っている全オブジェクトファイルに生成する。
このオプションを使用すると2のベキの単位でデバッグ情報のサイズを増やすので、
GCCがクラスのためにデバッグ情報を通常発する方法を取り扱うことができないデバッガだけで、このオプションが使われるべきである。

@item -fno-merge-debug-strings
@opindex fmerge-debug-strings
@opindex fno-merge-debug-strings
リンカに異なったオブジェクトファイルで同一のデバッグ情報で文字列をマージしないように伝える。マージはすべてのアセンブラとリンカでサポートしているわけではない。
マージはリンク処理時間を増やす代わりに出力ファイルのデバッグ情報のサイズを減らす。マージはデフォルトで有効である。

@item -fdebug-prefix-map=@var{old}=@var{new}
@opindex fdebug-prefix-map
ディレクトリ@file{@var{old}}にあるファイルをコンパイルするときは、そのファイルがディレクトリ@file{@var{new}}にあるかのようにデバッグ情報を記述する。 これは、ビルド時のパスをデバッグ情報のインストール時のパスに置き換えるために使用できる。 @var{new}に@file{.}を使用することによって、絶対パスを相対パスに変更することもできる。 これは場所に依存しないより再現性の高いビルドを提供することができるが、GDBにソースファイルの場所を指示するための追加のコマンドが必要になることがある。 @option {-ffile-prefix-map}も参照せよ。

@item -fdebug-prefix-map=@var{old}=@var{new}
@opindex fdebug-prefix-map
ディレクトリ@file{@var{old}}にあるファイルをコンパイルするときは、ファイルがディレクトリ@file{@var{new}}にあるかのようにそれらを説明するデバッグ情報を記録します。 これを使用して、デバッグ情報でビルド時パスをインストール時パスに置き換えることができます。 @var{new}に@file{.}を使用して、絶対パスを相対パスに変更するためにも使用できます。 これにより、場所に依存しない再現性の高いビルドが得られますが、ソースファイルの場所をGDBに指示するための追加のコマンドが必要になる場合があります。 @option{-ffile-prefix-map}も参照してください。

@item -fvar-tracking
@opindex fvar-tracking
変数追跡パスを走らせる。それはどの変数がコードのそれぞれの場所で記録されるかを計算する。
（もしデバッグ情報書式がこの情報をサポートしているなら）それからよりよいデバッグ情報が生成される。

最適化あり(@option{-Os},@option{-O}, @option{-O2}, @dots{})、デバッグ情報(@option{-g})ありコンパイルし、
デバッグ情報書式がサポートしている時はデフォルトで有効である。

@item -fvar-tracking-assignments
@opindex fvar-tracking-assignments
@opindex fno-var-tracking-assignments
最適化でのデバッグ情報を向上させようとして、コンパイルの初期でユーザ変数への代入に注釈をつけ、
注釈をコンパイルの最後まで引き継ごうとする。@option{-gdwarf-4}とともに使うことが推奨される。

たとえ変数追跡が使用不能であるとしても使用可能にでき、その場合には、注釈は作成されて維持されるが、終わりに捨てられる。デフォルトで、選択的なスケジューリングが使用可能にされるとき以外は、このフラグは@option{-fvar-tracking}と共に使用可能にされる。

@item -gsplit-dwarf
@opindex gsplit-dwarf
できるだけ多くのDWARFデバッグ情報を拡張子@file{.dwo}の別の出力ファイルへと分離する。これは
ビルドシステムがデバッグ情報をリンクするのを避けることを可能にする。このオプションが役立つためには、
@file{.dwo}ファイルをデバッガが読める必要がある。

@item -gdwarf32
@itemx -gdwarf64
@opindex gdwarf32
@opindex gdwarf64
DWARFデバッグ情報が有効になっている場合、@option{-gdwarf32}は32ビットのDWARF形式を選択し、@option{-gdwarf64}は64ビットのDWARF形式を選択します。 デフォルトはターゲット固有ですが、ほとんどのターゲットでは@option{-gdwarf32}です。 32ビットのDWARF形式は小さいですが、どのDWARFデバッグ情報セクションでも2GiBを超えるデバッグ情報をサポートすることはできません。 64ビットのDWARF形式では、より大きなデバッグ情報が可能であり、まだすべてのコンシューマーで十分にサポートされていない可能性があります。

@item -gdescribe-dies
@opindex gdescribe-dies
人工変数、外部参照、呼び出しサイトパラメーターDIEなど、名前属性のない一部のDWARF DIEに説明属性を追加します。

@item -gpubnames
@opindex gpubnames
DWARF@code{.debug_pubnames}セクションと@code{.debug_pubtypes}セクションを生成する。

@item -ggnu-pubnames
@opindex ggnu-pubnames
GDBインデックスへの変換に適した書式で@code{.debug_pubnames}と@code{.debug_pubtypes}セクションを生成する。
これはGDBインデックスバージョン7を生成できるリンカでのみ役立つ。

@item -fdebug-types-section
@opindex fdebug-types-section
@opindex fno-debug-types-section
DWARFバージョン4以上を使っている時、型DIEをpcode{.debug_info}セクションの一部にする代わりに、
自身の@code{.debug_types}セクションに置けるようにする。リンカが重複を削除できるのでそれらを別の
コンバットセクションに置けばもっと効率的になる。しかし、まだすべてのDWARFコンシューマーが@code{.debug_types}セクションを
サポートしているわけではなく、あるオブジェクトでは@code{.debug_types}が小さいデバッグ情報の代わりに大きく生成する。

@item -grecord-gcc-switches
@itemx -gno-record-gcc-switches
@opindex grecord-gcc-switches
@opindex gno-record-gcc-switches
このスイッチはコード生成に影響するかもしれないコンパイラを実行するのに使ったコマンドラインオプションをDWARFデバッグ情報の
DW_AT_producer属性に追加する。オプションはコンパイラのバージョンとそれぞれを空白で区切って結合される。これはデフォルトで有効である。
オブジェクトファイルにコマンドラインオプションを格納する他の方法は@option{-frecord-gcc-switches}参照。

@item -gstrict-dwarf
@opindex gstrict-dwarf
@option{-gdwarf-@var{version}}で選択された以降のDWARF標準バージョンの拡張の使用を禁止する。
大抵のターゲットでは以降の標準バージョンからの衝突しないDWARF拡張の使用は許されている。

@item -gno-strict-dwarf
@opindex gno-strict-dwarf
@option{-gdwarf-@var{version}}で選択された以降のDWARFバージョン標準バージョンの拡張の使用を許可する。

@item -gas-loc-support
@opindex gas-loc-support
アセンブラが@code{.loc}ディレクティブをサポートしていることをコンパイラに通知する。 その後、アセンブラがDWARF2+行番号テーブルを生成するために使用するかもしれない。
 
アセンブラで生成された行番号テーブルは、コンパイラが生成できるものよりはるかにコンパクトであるため、これが一般に望ましい。

このオプションは、GCCの設定時に、アセンブラでサポートされている場合に、デフォルトで有効になる。
 
@item -gno-as-loc-support
@opindex gno-as-loc-support
DWARF2 +行番号テーブルを生成する場合、GCCにDWARF2+行番号テーブルを内部的に生成させる。

@item gas-locview-support
@opindex gas-locview-support
アセンブラが@code{view}の割り当てをサポートし、@code{.loc}ディレクティブのアサーションチェックをリセットすることをコンパイラに通知する。

このオプションは、GCCの設定時に、アセンブラでサポートされている場合に、デフォルトで有効になる。

@item gno-as-locview-support
@option{-gvariable-location-views}が明示的に要求されている場合、GCCに内部的にビュー番号を割り当てさせる。

@item -gcolumn-info
@itemx -gno-column-info
@opindex gcolumn-info
@opindex gno-column-info
ファイルと行だけでなく、DWARFデバッグ情報に位置情報の列情報を出力する。このオプションはデフォルトで有効になっている。

@item -gstatement-frontiers
@itemx -gno-statement-frontiers
@opindex gstatement-frontiers
@opindex gno-statement-frontiers
このオプションを指定すると、GCCはステートメントの開始時に内部表現のマーカーを作成し、コンパイル時にそれらを大まかに保持して、行番号テーブルの@code{is_stmt}マーカーの出力をガイドするのに使用する。 これは、最適化（@option{-Os}、@option{-O}、@option{-O2}、@dots{}）でコンパイルし、DWARF 2デバッグ情報を通常レベルで出力するときにデフォルトで有効になる。

@item -gvariable-location-views
@itemx -gvariable-location-views=incompat5
@itemx -gno-variable-location-views
@opindex gvariable-location-views
@opindex gvariable-location-views=incompat5
@opindex gno-variable-location-views
行番号テーブルから暗示されるプログレッシブビュー番号で可変ロケーションリストを拡張する。 これにより、たとえその時点で対応するソース位置に関連する命令が存在しなくても、デバッグ情報コンシューマはプログラムの特定の点で状態を検査することが可能になる。 アセンブラで行番号テーブルのビュー番号がサポートされていない場合、コンパイラは行番号テーブルを生成する。これにより、一般に多少コンパクトになる。 拡張された行番号テーブルとロケーションリストは完全に下位互換性があるため、これらの拡張機能を認識していないデバッグ情報コンシューマによって消費される可能性があるが、それらの利点もありません。

これは、@option{-fvar-tracking-assignments}が有効で、@option{-gstrict-dwarf}が有効でない限り、DWARF 2デバッグ情報を通常レベルで出力するときにデフォルトで有効になる。 アセンブラのサポートが利用できない場合、これはまだ有効になっている可能性があるが、GCCに内部行番号テーブルを出力させ、@option{-INTERNAL-reset-location-views}が有効になっていないと、 ロケーションビューが一致しない。

DWARF 5で導入されたロケーションリスト形式と下位互換性のないビュー番号のための提案された表現があり、@option{-gvariable-location-views=incompat5}で有効にできる。 このオプションは将来削除される可能性があり、提案された表現の参照実装としてのみ提供される。 デバッグ情報のコンシューマは、この拡張形式をサポートするとは期待されず、使用不能と判断され、位置リストをデコードできないだろう。

@item -ginternal-reset-location-views
@itemx -gnointernal-reset-location-views
@opindex ginternal-reset-location-views
@opindex gno-internal-reset-location-views
ロケーションビューリストを省略することができるロケーションビューを決定しようとする。 これにより、コンパイラは非常に正確なinsn長さの推定値を必要とするが、必ずしもそうであるとは限らず、ロケーションビューリストをサポートしないアセンブラを使用すると、誤ったビューリストが自動的に生成される可能性がある。 GNUアセンブラはそのようなエラーを@code{view number mismatch}として警告する。 これは、信頼性の高い推定機能を定義するポートでのみ有効になる。

@item -ginline-points
@itemx -gno-inline-points
@opindex ginline-points
@opindex gno-inline-points
インライン関数の拡張デバッグ情報を生成する。 インラインエントリーポイントに位置ビュートラッキングマーカーが挿入されているため、アドレスとビュー番号を計算してデバッグ情報に出力できる。 これはロケーションビューとは独立して有効にすることができる。この場合、ビュー番号は出力されないが、ステートメントフロンティアとともに有効にすることができ、ロケーションビューが有効な場合にのみデフォルトで有効になる。

@item -gz@r{[}=@var{type}@r{]}
@opindex gz
もしサポートされているなら、DWARF書式で圧縮されたデバッグセクションを生成する。
もし@var{type}が与えられないならば、デフォルトタイプは使われたアセンブラとリンカの能力に依存する。
@var{type}は@samp{none}（デバッグセクションを圧縮しない）、@samp{zlib}（ELF gABIフォーマットでzlib圧縮を使う）、
@samp{zlib-gnu}（伝統的なGNU書式でzlib圧縮を使う）のどれかである。もしリンカが圧縮されたデバッグセクションを書くことを
サポートしていないなら、オプションは拒絶される。さもなければ、もしアセンブラはサポートしていないなら、@option{-gz}は
オブジェクトファイルを生成するときに単に無視される。

@item -femit-struct-debug-baseonly
@opindex femit-struct-debug-baseonly
コンパイルのソースファイルの基底名がその構造体が定義されたファイルの基底名と一致するときだけ
構造体風の型のデバッグ情報を生成する。

このオプションはデバッグ情報のサイズを事実上削減するが、デバッガへの型情報の重要な潜在的損失を起こすだろう。
あまり積極的でないオプションは@option{-femit-struct-debug-reduced}参照。もっと詳細な制御は
@option{-femit-struct-debug-detailed}参照。

このオプションはDWARFデバッグ出力でのみ働く。

@item -femit-struct-debug-reduced
@opindex femit-struct-debug-reduced
構造体がテンプレートか、システムヘッダで定義されていないかぎり、コンパイルのソースファイルの基底名が
その構造体が定義されたファイルの基底名と一致するときだけ構造体風の型のデバッグ情報を生成する。

このオプションはデバッグ情報のサイズを事実上削減するが、デバッガへの型情報の重要な潜在的損失を起こすだろう。
もっと積極的なオプションは@option{-femit-struct-debug-baseonly}参照。もっと詳細な制御は
@option{-femit-struct-debug-detailed}参照。

このオプションはDWARFデバッグ出力でのみ働く。

@item -femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]}
@opindex femit-struct-debug-detailed
コンパイラがデバッグ情報を生成する構造体風の型を指定する。
意図は、同じプログラムの範囲内で異なるオブジェクト・ファイルの間で重複の構造体デバッグ情報を減らすことである。

このオプションは大抵の必要性を満たす@option{-femit-struct-debug-reduced}と@option{-femit-struct-debug-baseonly}
の詳細なバージョンである。

指定は以下の構文を持つ@*
[@samp{dir:}|@samp{ind:}][@samp{ord:}|@samp{gen:}](@samp{any}|@samp{sys}|@samp{base}|@samp{none})

オプションの最初の語は直接(@samp{dir:})か間接(@samp{ind:})で使われる構造体への記述を制限する。
構造体型は変数、メンバの型であるときに直接使われる。間接使用は構造体へのポインタを通して使われる。
すなわち、非完全構造体の使用が正当なとき、その使用は間接である。例は
@samp{struct one direct; struct two * indirect;}である。

オプションの2番めの語は普通の構造体(@samp{ord:})か汎用の構造体(@samp{gen:})の記述を制限する。
汎用構造体は少し説明が複雑である。C++では、非明示的なテンプレートクラスの特殊化および、
上記内の非テンプレートクラスである。他のプログラム言語は汎用型を持つが、
@option{-femit-struct-debug-detailed}はまだそれらをサポートしていない。

三番目はコンパイラがデバッグ情報を発すべき構造体のソースファイルを指定する。値@samp{none}と@samp{any}は普通の意味を持つ。
値@samp{base}は型宣言が現れるファイル名の基底が主要コンパイルファイラうの名前の基底を一致しなければならないことを意味する。
実際には、これは@file{foo.c}をコンパイルするとき、デバッグ情報がそのファイルと@file{foo.h}には宣言されているが、他のヘッダファイルにはない
型に対して生成されることを意味する。値@samp{sys}は@samp{base}を満たすか、システムかコンパイラのヘッダで宣言されていることを意味する。

あなたのアプリケーション最適の設定を決定するには実験する必要があるかもしれない。

デフォルトは@option{-femit-struct-debug-detailed=all}である。

このオプションはDWARFデバッグ出力でのみ働く。

@item -fno-dwarf2-cfi-asm
@opindex fdwarf2-cfi-asm
@opindex fno-dwarf2-cfi-asm
GAS@code{.cfi_*}ディレクティブを使う代わりにコンパイラが生成した@code{.eh_frame}セクションとして
DWARFで巻き戻し情報を生成する。

@item -fno-eliminate-unused-debug-types
@opindex feliminate-unused-debug-types
@opindex fno-eliminate-unused-debug-types
通常、DWARF出力を生成するとき、GCCはコンパイルされたソースファイルでどこでも使われていない
型のデバッグシンボルの出力の生成を避ける。時々、コンパイル単位で使ったかどうかにかかわらず、
コンパイル単位で宣言された全型のデバッグ情報を出力するのが役立つかもしれない。
例えば、もし、デバッガであなたのプログラムで実際には使われていない（が宣言されている）
型へ値をキャストしたくなった時など。しかし、より頻繁には、これは多量のスペースの浪費になるだろう。
@end table

@node Optimize Options
@section 最適化を制御するオプション
@cindex optimize options
@cindex options, optimization

これらのオプションを様々な種類の最適化を制御する。

最適化オプションなしでは、コンパイラの目標はコンパイルのコストを削減して、
デバッグは予期する結果を生むようにさせることである。文は独立している。もしプログラムが文の間の
ブレークポイントで止まるなら、どんな変数にも新しい値を代入でき、関数内の他の文へプログラムカウンタを変更でき
ソースコードから期待される正確な結果を得るだろう。

最適化フラグをオンにするとコンパイラはパフォーマンスと・およびコードサイズをコンパイル時間とおそらくプログラムをデバッグする可能性と
引き換えに向上させようとする

コンパイラはそのプログラムの知識に基いて最適化を行う。複数のファイルを一つの出力ファイルに一度にコンパイルすれば
コンパイラはそれぞれをコンパイルするときに全ファイルから得られた情報を使うことができる。

すべての最適化がフラグで直接制御できるわけではない。フラグを持つ最適化だけがこの節でリストされている。

ほとんどの最適化は、@option{-O0}で、または@option{-O}レベルがコマンドラインで設定されていない場合、個々の最適化フラグが指定されていても完全に無効になります。 同様に、@option{-Og}は多くの最適化パスを抑制します。

ターゲットとGCCでがどのように設定されているかに依存して、ここでリストされた他にそれぞれの@option{-O}レベルで有効になる最適化の集合が少し異なる。
GCCを@option{-Q --help=optimizers}で起動することでそれぞれのレベルで有効になる正確な最適化の集合を見つけることができる。
例は@xref{Overall Options}。

@table @gcctabopt
@item -O
@itemx -O1
@opindex O
@opindex O1
最適化する。最適化コンパイルは時間が少しかかり、大きな関数ではかなり多くのメモリを使う。

@option{-O}で、コンパイル時間を大きく使う最適化を行わずに、コンパイラはコードサイズと実行時間を減らそうとする。

@c Note that in addition to the default_options_table list in opts.c,
@c several optimization flags default to true but control optimization
@c passes that are explicitly disabled at -O0.

@option{-O}は以下の最適化フラグをオンにする

@c Please keep the following list alphabetized.
@gccoptlist{-fauto-inc-dec 
-fbranch-count-reg 
-fcombine-stack-adjustments 
-fcompare-elim 
-fcprop-registers 
-fdce 
-fdefer-pop 
-fdelayed-branch 
-fdse 
-fforward-propagate 
-fguess-branch-probability 
-fif-conversion 
-fif-conversion2 
-finline-functions-called-once 
-fipa-modref 
-fipa-profile 
-fipa-pure-const 
-fipa-reference 
-fipa-reference-addressable 
-fmerge-constants 
-fmove-loop-invariants 
-fomit-frame-pointer 
-freorder-blocks 
-fshrink-wrap 
-fshrink-wrap-separate 
-fsplit-wide-types 
-fssa-backprop 
-fssa-phiopt 
-ftree-bit-ccp 
-ftree-ccp 
-ftree-ch 
-ftree-coalesce-vars 
-ftree-copy-prop 
-ftree-dce 
-ftree-dominator-opts 
-ftree-dse 
-ftree-forwprop 
-ftree-fre 
-ftree-phiprop 
-ftree-pta 
-ftree-scev-cprop 
-ftree-sink 
-ftree-slsr 
-ftree-sra 
-ftree-ter 
-funit-at-a-time}

@item -O2
@opindex O2
さらに最適化する。GCCは空間・時間のトレードオフが関与しないほぼすべてのサポートされた最適化を行う。
@option{-O}と比較して、これはコンパイル時間と生成されたコードのパフォーマンスの両方を増やす。

@option{-O2}は@option{-O}で指定された最適化フラグすべてをオンにする。それはさらに以下の最適化フラグもオンにする。
@c Please keep the following list alphabetized!
@gccoptlist{-falign-functions  -falign-jumps 
-falign-labels  -falign-loops 
-fcaller-saves 
-fcode-hoisting 
-fcrossjumping 
-fcse-follow-jumps  -fcse-skip-blocks 
-fdelete-null-pointer-checks 
-fdevirtualize  -fdevirtualize-speculatively 
-fexpensive-optimizations 
-ffinite-loops 
-fgcse  -fgcse-lm  
-fhoist-adjacent-loads 
-finline-functions 
-finline-small-functions 
-findirect-inlining 
-fipa-bit-cp  -fipa-cp  -fipa-icf 
-fipa-ra  -fipa-sra  -fipa-vrp 
-fisolate-erroneous-paths-dereference 
-flra-remat 
-foptimize-sibling-calls 
-foptimize-strlen 
-fpartial-inlining 
-fpeephole2 
-freorder-blocks-algorithm=stc 
-freorder-blocks-and-partition  -freorder-functions 
-frerun-cse-after-loop  
-fschedule-insns  -fschedule-insns2 
-fsched-interblock  -fsched-spec 
-fstore-merging 
-fstrict-aliasing 
-fthread-jumps 
-ftree-builtin-call-dce 
-ftree-pre 
-ftree-switch-conversion  -ftree-tail-merge 
-ftree-vrp}

計算gotoを使うプログラムでは@option{-O2}を呼ぶことについての@option{-fgcse}の警告に注意せよ。

@item -O3
@opindex O3
もっと最適化する。@option{-O3}は@option{-O2}によって指定されたすべての最適化をオンにして、以下の最適化フラグもオンにする。
@c Please keep the following list alphabetized!
@gccoptlist{-fgcse-after-reload 
-fipa-cp-clone
-floop-interchange 
-floop-unroll-and-jam 
-fpeel-loops 
-fpredictive-commoning 
-fsplit-loops 
-fsplit-paths 
-ftree-loop-distribution 
-ftree-loop-vectorize 
-ftree-partial-pre 
-ftree-slp-vectorize 
-funswitch-loops 
-fvect-cost-model 
-fvect-cost-model=dynamic 
-fversion-loops-for-strides}

@item -O0
@opindex O0
コンパイル時間を削減してデバッグが期待された結果を得るようにする。これはデフォルトである。

@item -Os
@opindex Os
サイズを最適化する。@option{-Os}はコードサイズを典型的に増やさない@option{-O2}最適化を有効にする。それはコードサイズを削減するように設計された
さらなる最適化も行う。

@option{-Os}は以下の最適化フラグを無効にする。
@gccoptlist{-falign-functions  -falign-jumps 
-falign-labels  -falign-loops 
-fprefetch-loop-arrays  -freorder-blocks-algorithm=stc}

また、@option{-finline-functions}を有効にし、コンパイラーに実行速度ではなくコードサイズを調整させ、コードサイズを削減するように設計されたさらなる最適化を実行します。

@item -Ofast
@opindex Ofast
厳密な標準準拠を無視する。@option{-Ofast}はすべての@option{-O3}最適化を有効にする。
それはすべての標準準拠プログラムで正当なわけではない最適化を有効にする。それは@option{-ffast-math}と、
Fortran固有の@option{-fstack-arrays}、@option{-fmax-stack-var-size}が指定されていない限り@option{-fno-protect-parens}をオンにする。

@item -Og
@opindex Og
デバッグ経験を最適化する。@option{-Og}はデバッグを干渉しない最適化を有効にする。それは標準的な
編集・コンパイル・デバッグサイクルにとっての選択肢のレベルとなる最適化であるべきで、
速いコンパイルとよいデバッグ経験を維持する合理的なレベルを提供する。 デバッグ情報を収集する一部のコンパイラパスは@option{-O0}で無効になるため、デバッグ可能なコードの生成には@option{-O0}よりも適切な選択です。

@option{-O0}と同様に、@option{-Og}は多くの最適化パスを完全に無効にするため、それらを制御する個々のオプションは効果がありません。 それ以外の場合、@option{-Og}は、デバッグを妨げる可能性のあるフラグを除く、すべての@option{-O1}最適化フラグを有効にします。

@gccoptlist{-fbranch-count-reg  -fdelayed-branch 
-fdse  -fif-conversion  -fif-conversion2  
-finline-functions-called-once 
-fmove-loop-invariants  -fssa-phiopt 
-ftree-bit-ccp  -ftree-dse  -ftree-pta  -ftree-sra}

@end table

もし、レベル数のありなしにかかわらず、複数の@option{-O}オプションを使うなら、最後のそのようなオプションが有効なものである。

形式@option{-f@var{flag}}のオプションは機種非依存のフラグを指定する。大抵のフラグは肯定形と否定形の両方がある。@option{-ffoo}の否定形は
@option{-fno-foo}である。以下のテーブルで、形式の片方だけをリストする。典型的にあなたが使う方である。@samp{no-}を消すか加える事で
他の形式を得ることができる。

以下のオプションは特定の最適化を制御する。それらは@option{-O}で有効にされるか、それと関連しているかである。
以下のフラグをまれな場合に、実行する最適化の「微調整」が望まれる場合に使うことができる。

@table @gcctabopt
@item -fno-defer-pop
@opindex fno-defer-pop
@opindex fdefer-pop
関数呼び出し後に引数をポップする必要があるマシンの場合、各関数が戻るとすぐに引数を常にポップします。@option{-O1}以上のレベルでは、@option{-fdefer-pop}がデフォルトです。 これにより、コンパイラーは、いくつかの関数呼び出しの引数をスタックに蓄積し、それらを一度にポップすることができます。

@item -fforward-propagate
@opindex fforward-propagate
RTLでの前方伝搬パスを実行する。このパスは2つの命令を結合しようとして、結果が単純化できるかどうかチェックする。もしループ展開が有効ならば、
2つのパスが実行され、2番めはループ展開の後にスケジュールされる。

このオプションは最適化レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}でデフォルトで有効である。

@item -ffp-contract=@var{style}
@opindex ffp-contract
@option{-ffp-contract=off}は浮動小数点表現構築を無効にする。
@option{-ffp-contract=fast}はもしターゲットがネイティブでサポートしているなら融合乗加算操作の形式のような浮動小数点表現構築を有効にする。
@option{-ffp-contract=on}はもし言語標準が許すなら浮動小数点表現構築をを有効にする。現在は実装されておらず、@option{-ffp-contract=off}と同等に扱う。

デフォルトは@option{-ffp-contract=fast}である。

@item -fomit-frame-pointer
@opindex fomit-frame-pointer
必要がない関数でフレームポインタを省略する。これはフレームポインタの保存、準備、復帰の命令を避ける。それは多くの関数で余分なレジスタを利用可能にする。 

あるターゲットではこのフラグは標準呼び出し列が常にフレームポインタを使い、省略できないので、効果がない。

@option{-fno-omit-frame-pionter}はフレームポインタがすべての関数で使われることを保証しない。あるターゲットでは末端の関数では常にフレームポインタを省略する。

レベル@option{-O}以上で有効である。

@item -foptimize-sibling-calls
@opindex foptimize-sibling-calls
兄弟と末尾再帰呼び出しを最適化する。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -foptimize-strlen
@opindex foptimize-strlen
種々のC文字列関数（例えば、@code{strlen}, @code{strchr}, @code{Strcpy})とその@code{_FORTIFY_SOURCE}対応物を
より速い代替物でと最適化する。

レベル@option{-O2}, @option{-O3}で有効になる。

@item -fno-inline
@opindex fno-inline
@code{always_inline}属性でマークされたものを除いてインライン関数を展開しない。これは最適化しない時のデフォルトである。

単一の関数は@code{noinline}属性でマークすることでインラインから免除することができる。

@item -finline-small-functions
@opindex finline-small-functions
本体が期待される関数呼び出しコードよりも小さい時（したがってプログラム全体のサイズが小さくなる時）に呼び出し元で統合する。
コンパイラはヒューリスティックにどの関数はこの方法で統合する価値が有るほど小さいかを決定する。
インライン化は、たとえinlineと宣言されていなくても、全関数に適用される。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -findirect-inlining
@opindex findirect-inlining
前のインラインのおかげでコンパイル時に既知であると発見された間接呼び出しもインライン化する。
これは@option{-finline-functions}か@option{-finline-small-functions}オプションによってインライン自身がオンで時のみ効果がある。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -finline-functions
@opindex finline-functions
たとえinlineと宣言されていなくても、インラインで全関数を考える。コンパイラはヒューリスティックにどの関数がこの方法で統合する価値のあるかを決定する。

もし与えられた関数のすべての呼び出しが統合され、関数が@code{static}と宣言されていたら、関数はそれ自身は通常は出力されない。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。@option{-fprofile-use}および@option{-fauto-profile}によっても有効になります。

@item -finline-functions-called-once
@opindex finline-functions-called-once
すべての一度だけ呼ばれた@code{static}関数を@code{inline}をマークされていなくても呼び出し元へのインライン化と考える。
もし与えられた関数が統合されたなら、関数自身はアセンブラコードとしては出力されない。

レベル@option{-O1}, @option{-O2}, @option{-O3}と@option{-Os}で有効になるが、@option{-Og}ではならない。

@item -fearly-inlining
@opindex fearly-inlining
@code{always_inline}とマークされたインライン関数とその本体が関数呼び出しオーバーヘッドよりも小さいように見える関数を
@option{-fprofile-generate}計装と本当のインラインパスを行う前にインライン化する。そうすることで
プロファイリングをかなり簡易にして通常は入れ子のラッパ関数の大きな連鎖を持つプログラムのインライン化を高速にする。

デフォルトで有効である。

@item -fipa-sra
@opindex fipa-sra
手続間の集合体のスカラー置換、未使用パラメータの削除、参照渡しのパラメータの値渡しのパラメータへの置換を行う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -finline-limit=@var{n}
@opindex finline-limit
デフォルトでは、GCCはインライン化される関数のサイズを制限する。このフラグは、この制限の粗い制御を可能にする。
@var{n}は擬似命令の数によるインライン化できる関数のサイズである。

インライン化は実際は幾つかのパラメータで制御され、別々に@option{--param @var{name}=@var{value}}を使うことで指定可能である。
@option{-finline-limit=@var{n}}オプションは以下のパラメータのいくつかをセットする。

@table @gcctabopt
@item max-inline-insns-single
は@var{n}/2にセットされる。
@item max-inline-insns-auto
は@var{n}/2にセットされる。
@end table

インライン化を制御する個々のパラメータとそれらのパラメータのデフォルトは文書の下を見よ。

@emph{注意:} デフォルトの振る舞いを起こす@option{-finline-limit}の値はないかもしれない。

@emph{注意:} 擬似命令は、この文脈では、抽象的な関数のサイズの尺度である。それはアセンブリ命令の数を表すわけでは全く無く、
その正確な意味はリリースが変わるごとに変化するかもしれない。

@item -fno-keep-inline-dllexport
@opindex fno-keep-inline-dllexport
これは@option{-fkeep-inline-functions}のよりきめが細かいバージョンである。そして、
@code{dllexport}属性またはdeclspecを使って宣言される関数だけにそれは適用される。
 (@xref{Function Attributes,,関数の属性の宣言})

@item -fkeep-inline-functions
@opindex fkeep-inline-functions
Cで、@code{inline}と宣言された@code{static}関数を、たとえ関数がそのすべての呼び出し元へインライン化されていても生成する。
このスイッチはGNU C90での@code{extern inline}拡張を使った関数には影響しない。C++では、全インライン関数をオブジェクトファイルへ出力する。

@item -fkeep-static-functions
@opindex fkeep-static-functions
関数が使われていなくても、@code{static}関数をオブジェクトファイルへ出力する。

@item -fkeep-static-consts
@opindex fkeep-static-consts
たとえ変数が参照されていなくても、最適化がオン出ない時に@code{static const}と宣言された変数を出力する。

GCCはこのオプションをデフォルトで有効にする。もし最適化がオンになっているかにかかわらず
コンパイラに変数が参照されているかのチェックを強制させたいならば、@option{-fno-keep-static-consts}を使う。
.
@item -fmerge-constants
@opindex fmerge-constants
コンパイル単位を横切って同一の定数（文字列定数と浮動小数点数定数）を併合しようとする。

このオプションはもしアセンブラとリンカがサポートしていたら最適化コンパイルのデフォルトである。
この振る舞いを抑制するには@option{-fno-merge-constants}を使う。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fmerge-all-constants
@opindex fmerge-all-constants
同一の定数と同一の変数を併合しようとする。

このオプションは@option{-fmerge-constants}を含む。@option{-fmerge-constants}に加えて、
これは、例えば、定数で初期化された配列や初期化された定数整数や浮動小数点型の変数でさえ考慮する。
CやC++のような言語はそれぞれの変数が、再帰呼び出しでの同じ変数の複数の実体を含めて、別々の場所を持つことを要求するので、
このオプションを使うと非準拠の振る舞いを起こす。

@item -fmodulo-sched
@opindex fmodulo-sched
最初のスケジューリングパスの直前に振動モジュロスケジューリングを実行する。このパスは最も内側のループを見て
その命令を重なっている別の繰り返しで並べ替える。

@item -fmodulo-sched-allow-regmoves
@opindex fmodulo-sched-allow-regmoves
レジスタ移動が許可されたもっと積極的なSMSベースのモジュロスケジューリングを実行する。
このフラグをセットすることである反依存エッジは削除され、生存範囲解析に基づいたレジスタ移動の生成が発動する。
このオプションは@option{-fmodulo-sched}が有効の時だけ効果がある。

@item -fno-branch-count-reg
@opindex fno-branch-count-reg
@opindex fbranch-count-reg
レジスタをデクリメントして、ゼロと比較し、その結果に基いて分岐する列を生成する代わりに
カウントレジスタでの「デクリメントと分岐」命令の使用の機会をスキャンする最適化パスを無効化する。
このオプションはそのような命令をサポートしたアーキテクチャでのみ意味を持ち、x86、PowerPC、IA-64、S/390を含む。
@option{-fno-branch-count-reg}オプションは他の最適化パスによって導入された生成された命令列からの
デクリメント・分岐命令は削除しないことに注意。

@option{-Og}以外での@option{-O1}より高い場合デフォルトで有効である。

@item -fno-function-cse
@opindex fno-function-cse
@opindex ffunction-cse
レジスタに関数アドレスを置かない。定数関数を呼ぶそれぞれの命令に関数のアドレスを明示的に含ませる。

このオプションは非効率なコードを生み出すが、アセンブラ出力を変更する奇妙なハックはこのオプションが使われない
時に実行される最適化によって混乱させるかもしれない。

デフォルトは@option{-ffunction-cse}である。

@item -fno-zero-initialized-in-bss
@opindex fno-zero-initialized-in-bss
もしターゲットがBSSセクションをサポートしているなら、GCCはデフォルトで0初期化される変数をBSSに置く。
これは結果のコードで空間を節約できる。

このオプションはあるプログラムが明示的に変数がデータセクションに行くことに頼っている、例えば
結果のコードがそのセクションの始まりを見つける、かつ・またはそれに基づいた仮定をするなどのためにこの振る舞いを切る。

デフォルトは@option{-fzero-initialized-in-bss}である。

@item -fthread-jumps
@opindex fthread-jumps

最初によって包含されるもう一つの比較が見つかる場所に、ジャンプが分岐するかどうか見るためにチェックする最適化を実行する。
もしそうならば、条件が真か偽と既知であるかに依存して、最初の分岐は二番目の分岐の目的地点か、その直前の点へと振り向けられる。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fsplit-wide-types
@opindex fsplit-wide-types
32ビットシステムにおける@code{long long}のように、複数のレジスタを専有する型を使っている時に、レジスタを分割して独立して割り当てる。
これは通常それらの型でもっと良いコードを生成するが、デバッグがより難しくなるかもしれない。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fsplit-wide-types-early
@opindex fsplit-wide-types-early
ワイドタイプを非常に遅くではなく、早く完全に分割します。 @option{-fsplit-wide-types}がオンになっていない限り、このオプションは効果がありません。

これは、一部のターゲットのデフォルトです。

@item -fcse-follow-jumps
@opindex fcse-follow-jumps
共通部分式除去（CSE）で、ジャンプの行き先が他のパスで到達しない時に、ジャンプ命令を通してスキャンする。
例えば、CSEが@code{else}句のある@code{if}文に出会った時、試験された条件が偽ならば、CSEはジャンプを追う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fcse-skip-blocks
@opindex fcse-skip-blocks
これは@option{-fcse-follow-jumps}と同様であるが、CSEにブロックを条件的に飛び越えるジャンプを追いかけさせる。
CSEがelse句のない単純な@code{if}文に出会ったならば、@option{-fcse-skip-blocks}は@code{if}の本体の周りのジャンプを追いかけさせる。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -frerun-cse-after-loop
@opindex frerun-cse-after-loop
ループ最適化の後の共通部分式除去の再実行を行う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fgcse
@opindex fgcse
大域共通部分式除去パスを行う。このパスは大域定数とコピーの伝搬も行う。

@emph{注意：} GCC拡張の計算gotoを使ったプログラムをコンパイルするときは、
大域共通部分式除去パスをコマンドラインで@option{-fno-gcse}を加える事で無効にしたほうがよい実行時パフォーマンスを得るかもしれない。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fgcse-lm
@opindex fgcse-lm
@option{-fgcse-lm}が有効の時、大域共通部分式除去は自分自身へのストアによって殺されるのみのロードを移動させようとする。
これはロード・ストア列を含むループがループの外でロードし、ループ内でコピー・ストアすることを可能にする。

@option{-fgcse}が有効の時デフォルトで有効である。

@item -fgcse-sm
@opindex fgcse-sm
@option{-fgcse-sm}が有効の時、ストア移動パスが大域共通部分式除去の後に走る。このパスはストアをループの外に移動しようとする。
@option{-fgcse-lm}と組み合わせて使うとき、ロード・ストア列を含むループはループの前にロードし、ループの後にストアすることを可能にする。

どの最適化レベルでも有効でない。

@item -fgcse-las
@opindex fgcse-las
@option{-fgcse-las}が有効の時、大域共通部分式除去パスが同じメモリ場所へのストアの直後の冗長なロードを除去する。
（部分的・完全に冗長なものの両方）

どの最適化レベルでも有効でない。

@item -fgcse-after-reload
@opindex fgcse-after-reload
@option{-fgcse-after-reload}が有効になる時、冗長ロード除去パスがリロードの後に行われる。このパスの目的は
冗長なこぼれを片付けることである。

@option{-fprofile-use}および@option{-fauto-profile}によって有効になります。

@item -faggressive-loop-optimizations
@opindex faggressive-loop-optimizations
このオプションはループ最適化器にループの繰り返し数の境界を引き出すために言語制約を使うように伝える。
これはループコードが例えば整数桁あふれや境界外配列アクセスのような未定義の振る舞いを呼ばないと仮定する。
ループの繰り返しの数の境界はループ展開とループ剥がし、ループ脱出テスト最適化によって使われる。
このオプションはデフォルトで有効である。

@item -funconstrained-commons
@opindex funconstrained-commons
このオプションはコンパイラに共通ブロック（例えば、Fortran）で宣言された変数が後でより長い後端の配列で上書きされるかもしれないと伝える。
これは配列の境界を知っているかに依存するある最適化を防ぐ。

@item -fcrossjumping
@opindex fcrossjumping
Perform cross-jumping transformation.
この変換は等価のコードを統合し、コードサイズを節約する。結果のコードはクロスジャンプなしよりも良くなるかもしれないし、
悪くなるかもしれない。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fauto-inc-dec
@opindex fauto-inc-dec
アドレスのインクリメント・デクリメントとメモリアクセスを結合させる。このパスはこれをサポートする命令のないアーキテクチャでは
常にスキップされる。これをサポートするアーキテクチャの@option{-O}以上でデフォルトで有効である。

@item -fdce
@opindex fdce
RTLでの非到達コード除去（DCE)を実行する。@option{-O}以上でデフォルトで有効である。

@item -fdse
@opindex fdse
RTLでの非到達ストア除去（DSE)を実行する。@option{-O}以上でデフォルトで有効である。

@item -fif-conversion
@opindex fif-conversion
条件付きジャンプを分岐なしの等価物に変換しようとする。これは条件付きムーブ、最小、最大、フラグセット、絶対値命令、標準算術で可能ないくつかの
トリックの使用を含む。サポートするチップでの条件付き実行の使用は @option{-fif-conversion2}で制御される。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で利用可能である。

@item -fif-conversion2
@opindex fif-conversion2
（利用可能な場所で）条件付き実行を使って条件付きジャンプを分岐なしの等価物に変換する。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で利用可能である。

@item -fdeclone-ctor-dtor
@opindex fdeclone-ctor-dtor
C++ ABIはコンストラクタとデストラクタの複数の入り口を必要とする。基底のサブオブジェクト用、完全オブジェクト用、
その後でdelete演算子を呼ぶ仮想デストラクタ用。仮想基底のある階層では、基底と完全の変種は同一で、関数の2つのコピーがあることを意味する。
このオプションで、基底で完全変種は共通の実装を呼ぶサンクに変換される。

@option{-Os}で有効になる。

@item -fdelete-null-pointer-checks
@opindex fdelete-null-pointer-checks
プラグラムが安全にヌルポインタの参照外しができず、アドレス0にはコードもデータ要素もないと仮定する。
このオプションは全最適化レベルでの単純な定数畳み込み最適化を有効にする。それに加え、
GCCでの他の最適化パスはヌルポインタの無用なチェックを除去する大域データフロー解析を制御するために
このフラグを使う。これらはアドレス0へのメモリアクセスは常にトラップを発生させ、したがってもしすでに参照外しされた後で
ポインタがチェックされるなら、nullではありえないと仮定する。

しかし、ある環境ではこの仮定は真ではないことに注意。この振る舞いに依存したプログラムでは、
@option{-fno-delete-null-pointer-checks}を使ってこの最適化を無効にする。

このオプションはたいていのターゲットではデフォルトで有効である。Nios II ELFでは、デフォルトでオフである。
AVRILとCR16、MSP430では、このオプションは完全に無効にされる。

データフロー情報を使うパスは別の最適化レベルで独立して有効にされる。

@item -fdevirtualize
@opindex fdevirtualize
仮想関数の呼び出しを直接呼び出しへ変換しようとする。これは手続き内と間接インライン化
(@option{-findirect-inlining})と手続間定数伝搬(@option{-fipa-cp})の一部としての手続間の両方で
行われる。
レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fdevirtualize-speculatively
@opindex fdevirtualize-speculatively
仮想関数の呼び出しを不確かな直接呼び出しに変換しようとする。
型継承グラフの解析に基づいて、与えられた呼び出しのためにありそうな目標のセットを決定する。
セットが小さく、望ましくはサイズ１ならば、直接的および間接的な呼び出しのいずれかに決定している条件文に呼び出しを変える。
不確かな呼び出しは、より多くの最適化（インライン化のような）を使用可能にする。
それらが更なる最適化の後役に立たないようであるとき、それらは原形に戻される。

@item -fdevirtualize-at-ltrans
@opindex fdevirtualize-at-ltrans
ローカル変換モードでリンク時最適化器を走らせるとき、積極的な非仮想化のために必要とされる余分の情報を流れ出させる。
このオプションはより多くの非仮想化を使用可能にするが、かなり流れられたデータのサイズを増やす。この理由で、
それはデフォルトで無効にされている。

@item -fexpensive-optimizations
@opindex fexpensive-optimizations
いくつかの比較的高価な小さい最適化を行う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -free
@opindex free
冗長な拡張命令を取り除こうとする。これは特にx86-64アーキテクチャで有用である。それは32ビットの下半分に書くと
暗黙に64ビットレジスタに0拡張される。

レベル@option{-O2}, @option{-O3}, @option{-Os}でAlpha, AArch64, x86で有効である。

@item -fno-lifetime-dse
@opindex fno-lifetime-dse
C++では、オブジェクトの値はその生存期間内での変更しか影響しない。コンストラクタが始まった時、
オブジェクトは不定値を持っていて、生存期間中の変更はオブジェクトが破壊された時に消える。
通常非到達ストア除去はこれの利点を使う。もしあなたのコードがオブジェクトの生存期間を超えて存在する領域のオブジェクトの値に
依存しているならば、このフラグをつかってこの最適化を無効にすることができる。コンストラクタが始まる前のストアを保持するが
（例えば、あなたのnew演算子がオブジェクト領域をクリアするので）、デストラクタの後ではオブジェクトが死んでいるとまだ扱うためには、
@option{-flifetime-dse=1}を使う。デフォルトの振る舞いは明示的に@option{-flifetime-dse=2}で選択できる。
@option{-flifetime-dse=0}は@option{-fno-lifetime-dse}と等価である。

@item -flive-range-shrinkage
@opindex flive-range-shrinkage
レジスタ生存範囲縮小を通してレジスタ圧を減らそうとする。これは小さいか適度なサイズのレジスタセットを持つ高速なプロセッサには有用である。

@item -fira-algorithm=@var{algorithm}
@opindex fira-algorithm
統合レジスタアロケータに指定された色付アルゴリズムを使用する。@var{algorithm}引数は
、Chowの優先順位色付けを指定する@samp{priority}、Chaitin-Briggs色付けを行う@samp{CB}にできる。
Chaitin-Briggs色付けはすべてのアーキテクチャで実装されているわけではないが、サポートされているターゲットでは、
より良いコードを生成するのでデフォルトである。

@item -fira-region=@var{region}
@opindex fira-region
統合レジスタアロケータの指定された領域を使う。@var{region}は以下のものの一つであるべきである。

@table @samp

@item all
レジスタ割当領域として全ループを使う。これは小さく、かつ・または不規則なレジスタセットでは最良のコードを生成する。

@item mixed
領域として小さいレジスタ圧のループ以外のすべてのループを使う。これは通常大抵のケースで大抵のアーキテクチャで最良のコードを生成し、
スピードの最適化でコンパイルするとき(@option{-O}, @option{-O2}, @dots{})のデフォルトである。

@item one
単一の領域として全関数を使う。これは典型的には最小のコードサイズを起こすので、@option{-Os}か@option{-O0}でデフォルトである。

@end table

@item -fira-hoist-pressure
@opindex fira-hoist-pressure
表現を巻き上げる決定のためのコードを巻き上げるパスにおいてレジスタ圧を評価するために、IRA（統合レジスタアロケータ）を使う。
このオプションはより小さいコードを起こすが、それはコンパイラを遅くすることがある。

このオプションはすべてのターゲットでレベル@option{-Os}で有効になる。

@item -fira-loop-pressure
@opindex fira-loop-pressure
ループ不変を動かす決定のためにループでレジスタ圧を評価するためにIRA（統合レジスタアロケータ）を使う。
このオプションは通常大きなレジスタファイル（＞＝３２レジスタ）をもつ機種ではより速く、より小さいコードコードを生成するが、
コンパイラを遅くすることがある。

このオプションはあるターゲットでレベル@option{-O3}で有効になる。

@item -fno-ira-share-save-slots
@opindex fno-ira-share-save-slots
呼び出しを通して生存する呼び出しで使われるハードレジスタの保存で使うスタックスロットの共有を無効にする。
それぞれのハードレジスタ別のスタックスロットを持ち、結果の関数のスタックフレームを大きくなる。

@item -fno-ira-share-spill-slots
@opindex fno-ira-share-spill-slots
擬似レジスタを割り当てるスタックスロットの共有を無効にする。ハードレジスタがないそれぞれの擬似レジスタは別々のスタックスロットを持ち、
結果の関数のスタックフレームは大きくなる。

@item -flra-remat
@opindex flra-remat
LRAでCFGに影響される再実体化を有効にする。こぼれた擬似レジスタの値をロードする代わり、
LRAは利益があるならば再実体化（再計算）を試みる。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fdelayed-branch
@opindex fdelayed-branch
もしターゲット機種がサポートしているなら、遅延分岐命令の後の利用可能な命令スロットを活用するために
命令を並べ替えようとする。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効であるが@option{-Og}は違う。

@item -fschedule-insns
@opindex fschedule-insns
もしターゲット機種がサポートしているなら、必要なデータが利用不可能なための実行の停止を
除去するために命令を並べ替えようとする。これは遅い浮動小数点演算やメモリーロード命令を持つ機種が
ロードや浮動小数点演算の結果が要求されるまでに他の命令が実行されることを可能とする。

レベル@option{-O2}, @option{-O3}で有効である。

@item -fschedule-insns2
@opindex fschedule-insns2
@option{-fschedule-insns}と同様だが、レジスタ割当が行われた後に追加の命令スケジューリングのパスを要求する。
これは特に比較的小さな数のレジスタとメモリーロード命令が1サイクルよりおおくかかる機種で役立つ。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fno-sched-interblock
@opindex fno-sched-interblock
@opindex fsched-interblock
基本ブロックをまたいで命令をスケジュールしない。通常はレジスタ割当前のスケジュールではデフォルトで有効である。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fno-sched-spec
@opindex fno-sched-spec
@opindex fsched-spec
非ロード命令の投機的な移動を許可しない。通常はレジスタ割当前のスケジュールではデフォルトで有効である。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fsched-pressure
@opindex fsched-pressure
レジスタ割当前のレジスタ圧感知の命令スケジューリングを有効位にする。
これはレジスタ割当前のスケジューリングが有効の時だけ意味を持つ。すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。
このオプションの使用は利用可能なレジスタの数を超えてレジスタ圧が増え、続いてレジスタ割当で溢れることを防ぎ
コード生成を向上させサイズを削減する。

@item -fsched-spec-load
@opindex fsched-spec-load
あるロード命令の投機的移動を許可する。これはレジスタ割当前のスケジューリングが有効の時だけ意味を持つ。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fsched-spec-load-dangerous
@opindex fsched-spec-load-dangerous
もっとロード命令の投機的移動を許可する。これはレジスタ割当前のスケジューリングが有効の時だけ意味を持つ。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fsched-stalled-insns
@itemx -fsched-stalled-insns=@var{n}
@opindex fsched-stalled-insns
第2スケジューリングパスの間に準備リストへ停止中の命令のキューから（もし存在すれば）どのくらい多くの命令を
時期早々に移動できるかを定義する。@option{-fno-sched-stalled-insns}は時期早々には一つも命令を移動できないことを意味し、
@option{-fsched-stalled-insns=0}は時期早々に移動できるキューされた命令の移動個数に制限がないことを意味する。
値のない@option{-fsched-stalled-insns}は@option{-fsched-stalled-insns=1}と等価である。

@item -fsched-stalled-insns-dep
@itemx -fsched-stalled-insns-dep=@var{n}
@opindex fsched-stalled-insns-dep
停止中の命令全体のキューから時期早々に除去する候補である停止中の命令の依存関係をどのくらい多くの
命令グループ（サイクル）で確認するかを定義する。これは第2スケジューリングパスの間でのみ効果があり、
@option{-fsched-stalled-insns}が使われている場合、その場合のみ効果がある。
@option{-fno-sched-stalled-insns-dep}は@option{-fsched-stalled-insns-dep=0}と等価である。
値なしの@option{-fsched-stalled-insns-dep}は@option{-fsched-stalled-insns-dep=1}と等価である。

@item -fsched2-use-superblocks
@opindex fsched2-use-superblocks
レジスタ割当後のスケジューリングで、スーパーブロックスケジューリングを使う。
これは、基本ブロック境界をまたいだ移動を許し、より速いスケジューリングを起こす。
GCCによって使われるすべての機種描写がアルゴリズムから信頼できない結果を避けるのに十分近く
CPUをモデル化するというわけではないので、このオプションは実験的である。

これはレジスタ割当後のスケジューリングでのみ意味を持つ。すなわち、@option{-fschedule-insns2}か
@option{-O2}以上である。

@item -fsched-group-heuristic
@opindex fsched-group-heuristic
スケジューラーでのグループヒューリスティックを有効にする。このヒューリスティックは
スケジュールグループに属する命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-critical-path-heuristic
@opindex fsched-critical-path-heuristic
スケジューラでのクリティカル・パスヒューリスティックを有効にする。このヒューリスティックは
クリティカルパス上の命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-spec-insn-heuristic
@opindex fsched-spec-insn-heuristic
スケジューラでの投機的な命令ヒューリスティックを有効にする。このヒューリスティックは
より大きな依存性の弱点のある投機的命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-rank-heuristic
@opindex fsched-rank-heuristic
スケジューラのランクヒューリスティックを有効にする。このヒューリスティックは
より大きなサイズか頻度の基本ブロックに属する命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-last-insn-heuristic
@opindex fsched-last-insn-heuristic
スケジューラでの最終命令ヒューリスティックを有効にする。このヒューリスティックは
スケジュールされた最後の命令にあまり依存していない命令を選好する。
これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-dep-count-heuristic
@opindex fsched-dep-count-heuristic
スケジューラで依存カウントヒューリスティックを有効にする。このヒューリスティックは
それに依存する命令が多い命令を選好する。
これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -freschedule-modulo-scheduled-loops
@opindex freschedule-modulo-scheduled-loops
伝統的なスケジューリングの前にモジュロスケジューリングを実行する。もしループがモジュロでスケジューリングされるなら、
後半のスケジューリングパスはスケジュールを変更させるかもしれない。このオプションを使うことでその振る舞いを制御できる。

@item -fselective-scheduling
@opindex fselective-scheduling
選択的スケジューリングアルゴリズムを使って命令をスケジュールする。選択的スケジューリングは
最初のスケジューラパスの代わりに走る。

@item -fselective-scheduling2
@opindex fselective-scheduling2
選択的スケジューリングアルゴリズムを使って命令をスケジュールする。選択的スケジューリングは
第2スケジューラパスの代わりに走る。

@item -fsel-sched-pipelining
@opindex fsel-sched-pipelining
選択的スケジューリングの間も最も内側のループのソフトウェアパイプライン化を有効にする。
このオプションは@option{-fselective-scheduling}か@option{-fselective-scheduling2}がオンにならないかぎり効果はない。

@item -fsel-sched-pipelining-outer-loops
@opindex fsel-sched-pipelining-outer-loops
選択的スケジューリングの間のループのパイプライン化で外側のループもパイプライン化する。
このオプションは@option{-fsel-sched-pipelining}がオンでない限り効果がない。

@item -fsemantic-interposition
@opindex fsemantic-interposition
ELFのようなあるオブジェクトフォーマットで、動的リンカによるシンボルの挿入を許可する。
これはDSOからエクスポートされたシンボルで、問題の関数や変数が変わるかもしれないという予想により、
コンパイラは手続間の伝搬、インライン化、他の最適化ができなくなることを意味する。
この機能は例えば、メモリ割り当て関数をデバッグ実装で書き換えることなどで有用かもしれないが、
コード品質の観点では高くつく。
@option{-fno-semantic-interposition}によって、コンパイラはもし関数の挿入が起こったらならば、
上書きされる関数は正確に同じ意味（と副作用）を持つと仮定する。同様にもし変数の挿入が起こったならば、
変数のコンストラクタは同じであるだろう。フラグは明示的にインラインと宣言された関数（それは意味を変える挿入が決して許されない）
と、明示的に弱く宣言されたシンボルには効果がない。

@item -fshrink-wrap
@opindex fshrink-wrap
関数の先頭ではなく、それを必要とする関数の部分の前にだけ関数プロローグを出す。
このフラグは@option{-O}以上でデフォルトで有効である。

@item -fshrink-wrap-separate
@opindex fshrink-wrap-separate
プロローグとエピローグの別々の部分を個別に縮小してラップし、必要なときにのみ実行するようにする。このオプションはデフォルトではオンになっているが、@option{-fshrink-wrap}もオンになっていてターゲットがこれをサポートしていないと効果はない。

@item -fcaller-saves
@opindex fcaller-saves
関数呼び出しで破壊されるレジスタへの値の割り当てを、そのような呼び出しの前後でレジスタの保存と
復帰の余分な命令を出すことで有効にする。そのような割り当てはそのほうが良いコードを生成しそうなときだけ行われる。

このオプションはある機種でデフォルトで常に有効であり、通常はそのような機種では代わりに使う呼び出しで保持されるレジスタがない。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fcombine-stack-adjustments
@opindex fcombine-stack-adjustments
スタック調整（プッシュとポップ）とスタックメモリ参照を追って、それらを結合できる方法を探そうとする。

@option{-O1}以上でデフォルトで有効である。

@item -fipa-ra
@opindex fipa-ra
呼ばれた関数で使われていないならば、割り当てに呼び出し元保存レジスタを使う。
その場合では、呼び出し前後で保存と復帰をする必要が無い。これは呼ばれた関数が
現在の関数と同じコンパイル単位の一部でそれより前にコンパイルされている時だけ可能である。

レベル@option{-O2}、@option{-O3}、@option{-Os}で有効になりますが、プロファイリング用に生成されたコードがインスツルメントされる場合、オプションは無効になります（@option{-p}または@option{-pg}）または呼び出し先のレジスタの使用状況を正確に知ることができない場合（これは、RTLでプロローグとエピローグを公開しないターゲットで発生します）。

@item -fconserve-stack
@opindex fconserve-stack
スタックの使用を最小化しようとする。コンパイラは、それがプログラムを遅くするとしてもスタック空間を
あまり使わなくしようとする。このオプションを@option{large-stack-frame}パラメータに100をセットし、
@option{large-stack-frame-growth}パラメータに400をセットすることを含む。

@item -ftree-reassoc
@opindex ftree-reassoc
木への再連結を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -fcode-hoisting
@opindex fcode-hoisting
コード巻上げを実行する。 コード巻上げは、すべてのパスで実行された式の評価を可能な限り早く関数出口に移動しようとする。これはコードサイズの最適化として特に有用だが、コードスピードにも役立つ。このフラグは、デフォルトでは@option{-O2}以上で有効になっている。

@item -ftree-pre
@opindex ftree-pre
木での部分冗長除去(PRE)を行う。このフラグは@option{-O2}と@option{-O3}でデフォルトで有効である。

@item -ftree-partial-pre
@opindex ftree-partial-pre
部分冗長除去(PRE)をもっと積極的に行う。このフラグは@option{-O3}でデフォルトで有効である。

@item -ftree-forwprop
@opindex ftree-forwprop
木での前方伝搬を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-fre
@opindex ftree-fre
木での完全冗長除去(FRE)を行う。FREとPRESUMEの差はFREとが冗長圧縮を導くすべての経路で計算された式のみ考慮することである。
この解析はPREより速いが、冗長を少ししか検知しない。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-phiprop
@opindex ftree-phiprop
木での条件ポインタからのロードの持ち上げを行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -fhoist-adjacent-loads
@opindex fhoist-adjacent-loads
もしロードが同じ構造体の隣接の場所からでターゲットアーキテクチャが条件付きmove命令を持つならば
if-then-elseの両方の分岐からロードを投機的に持ち上げる。このフラグは@option{-O2}以上でデフォルトで有効である。 

@item -ftree-copy-prop
@opindex ftree-copy-prop
木でのコピー伝搬を行う。このパスは不必要なコピー操作を除去する。
このフラグは@option{-O}以上でデフォルトで有効である。

@item -fipa-pure-const
@opindex fipa-pure-const
pure、constな関数を発見する。@option{-O}以上でデフォルトで有効である。

@item -fipa-reference
@opindex fipa-reference
コンパイル単位を脱出しない静的変数を発見する。@option{-O}以上でデフォルトで有効である。

@item -fipa-reference-addressable
@opindex fipa-reference-addressable
読み取り専用、書き込み専用、およびアドレス指定不可能な静的変数を発見します。
@option{-O}以降でデフォルトで有効になります。

@item -fipa-stack-alignment
@opindex fipa-stack-alignment
可能な場合、呼び出しサイトでのスタック調整を減らします。
デフォルトで有効になっています。

@item -fipa-pta
@opindex fipa-pta
手続間ポインタ解析と手続間修正・参照解析を行う。このオプションは大きなコンパイル単位で
非常に多いメモリとコンパイル単位時間を起こしうる。どの最適間レベルでもデフォルトで有効にならない。

@item -fipa-profile
@opindex fipa-profile
手続間プロファイル伝搬を行う。冷たい関数からのみ呼ばれた関数を冷たいとマークする。
一度呼ばれた関数（@code{cold}、 @code{noreturn}、静的コンストラクタとデストラクタ）は識別される。
冷たい関数と一度実行される関数のループのない部分はサイズで最適化される。
@option{-O}以上でデフォルトで有効である。

@item -fipa-modref
@opindex fipa-modref
手続き間mod/ref分析を実行します。 この最適化は、関数の副作用（変更または参照されるメモリ位置）を分析し、関数呼び出しの境界を越えてより良い最適化を可能にします。 このフラグは、@option{-O}以降でデフォルトで有効になっています。

@item -fipa-cp
@opindex fipa-cp
手続間定数伝搬を行う。この最適化は関数へ渡される値がいつ定数であるかを決定するためにプログラムを解析して、
それにそって最適化する。この最適化はもしアプリケーションが関数に定数を渡していたらかなりパフォーマンスを向上させうる。
このフラグは@option{-O2}, @option{-Os} and @option{-O3}でデフォルトで有効である。

@item -fipa-cp-clone
@opindex fipa-cp-clone
手続間定数伝搬をより強くするために関数複製を行う。有効になると、手続間定数典範は外部で可視の関数が定数引数で呼びうる良きに関数複製を行う。
この最適化が関数の複数のコピーを作りうるので、コードサイズがかなり増えるかもしれない。
(@option{--param ipcp-unit-growth=@var{value}}を見よ。)
このフラグは@option{-O3}でデフォルトで有効である。

@item -fipa-bit-cp
@opindex fipa-bit-cp
有効にすると、プロシージャ間のビット定数定数伝播を実行します。 このフラグは、@option{-O2}でデフォルトで有効になり、@option{-fprofile-use}および@option{-fauto-profile}で有効になります。
@option{-fipa-cp}が有効になっている必要があります。

@item -fipa-vrp
@opindex fipa-vrp
有効にした場合、値の範囲のプロシージャー間の伝搬を実行します。 このフラグは、@option{-O2}でデフォルトで有効になっています。 @option{-fipa-cp}が有効になっている必要があります。

@item -fipa-icf
@opindex fipa-icf
関数と読み込み専用変数の同一コード畳み込みを行う。この最適化はコードサイズを削減して、
関数を異なる名前の同様物で置換することでスタック巻き戻しを乱すかもしれない。この最適化はリンク時最適化が有効の時に
もっと効果的に働く。

振る舞いはGoldリンカICF最適化と似ているにもかかわらず、GCC ICFは異なるレベルで働きそれ故に最適化は同じではない。
GCCによってのみ見つかる同一性もGoldによってのみ見つかる同一性もある。

このフラグは@option{-O2}と@option{-Os}でデフォルトで有効である。

@item -flive-patching=@var{level}
@opindex flive-patching
GCCの最適化を制御して、ライブパッチに適した出力を生成します。

コンパイラーの最適化が関数の本体またはその本体から抽出された情報を使用して別の関数を最適化/変更する場合、後者は前者の影響を受ける関数と呼ばれます。 関数にパッチを適用する場合、影響を受ける関数にもパッチを適用する必要があります。

影響を受ける関数は、コンパイラのプロシージャー間の最適化によって決まります。 たとえば、関数を呼び出し元にインライン化する場合、関数を複製して呼び出し元を変更してこの新しいクローンを呼び出す場合、関数の純粋性/安定性情報を抽出して直接または間接呼び出し元を最適化する場合など、呼び出し元に影響があります。

通常、IPA最適化を有効にすると、各関数の影響を受ける関数の数が多くなります。 影響を受ける関数の数を制御し、影響を受ける関数のリストをより簡単に計算するために、2つの異なるレベルでIPA最適化を部分的に有効にできます。

@var{level}引数は次のいずれかでなければなりません：

@table @samp

@item inline-clone

インライン化、クローン作成、集合体のプロシージャー間のスカラー置換、部分的なインライン化など、インライン化とクローン作成の最適化のみを有効にします。その結果、関数にパッチを適用すると、そのすべての呼び出し元とそのクローンの呼び出し元が影響を受けるため、同様にパッチを適用する必要があります。

@option{-flive-patching=inline-clone}は以下の最適化オプションを無効化します。
@gccoptlist{-fwhole-program  -fipa-pta  -fipa-reference  -fipa-ra 
-fipa-icf  -fipa-icf-functions  -fipa-icf-variables 
-fipa-bit-cp  -fipa-vrp  -fipa-pure-const  -fipa-reference-addressable 
-fipa-stack-alignment -fipa-modref}

@item inline-only-static

静的関数のインライン化のみを有効にします。
その結果、静的関数にパッチを適用すると、すべての呼び出し元が影響を受けるため、同様にパッチを適用する必要があります。

@option{-flive-patching=inline-clone}が無効にするすべてのフラグに加えて、@option {-flive-patching=inline-only-static}は次の追加の最適化フラグを無効にします。
@gccoptlist{-fipa-cp-clone  -fipa-sra  -fpartial-inlining  -fipa-cp}

@end table

@option{-flive-patching}が値なしで指定された場合、デフォルト値は@var{inline-clone}です。

このフラグはデフォルトで無効になっています。

@option{-flive-patching}はリンク時最適化（@option{-flto}）ではサポートされていないことに注意してください。

@item -fisolate-erroneous-paths-dereference
@opindex fisolate-erroneous-paths-dereference
nullポインタの被参照のために間違っているか未定義の振る舞いを起こす経路を検知する。
主要制御フローからそれらのパスを孤立させてエラーか未定義の振る舞いのある文をトラップに変換する。
このフラグは@option{-O2}以上でデフォルトで有効で@option{-fdelete-null-pointer-checks}が有効かどうかにも依存している。

@item -fisolate-erroneous-paths-attribute
@opindex fisolate-erroneous-paths-attribute
@code{returns_nonnull}か@code{nonnull}によって禁止されている方法で使われているnull値のために
間違っているか未定義の振る舞いを起こすパスを検知する。主要制御フローからそれらのパスを孤立させて
誤っているか未定義の振る舞いの文をトラップに変換する。これは現在有効でないが、
将来は@option{-O2}で有効になるかもしれない。

@item -ftree-sink
@opindex ftree-sink
木でストアを前方に移動する。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-bit-ccp
@opindex ftree-bit-ccp
木で疎条件ビット定数伝搬を行い、ポインタ境界情報を伝搬させる。
このパスは局所スカラー変数でのみ行われ、@option{-O}以上でデフォルトで有効である。
それは@option{-ftree-ccp}が有効である必要がある。

@item -ftree-ccp
@opindex ftree-ccp
木での疎条件定数伝搬(CCP)を行う。このパスは局所スカラー変数でのみ行われ、@option{-O}以上でデフォルトで有効である。

@item -fssa-backprop
@opindex fssa-backprop
定義を単純化するために定義連鎖を上がって値の使用についての情報を伝搬する。例えば、このパスは
もし値の符号が決して問題にならないなら符号操作を削る。このフラグは@option{-O}以上でデフォルトで有効である。

@item -fssa-phiopt
@opindex fssa-phiopt
条件コードを最適化するためにSSA PHIノードでのパターンマッチを行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-switch-conversion
@opindex ftree-switch-conversion
switchでの単純な初期化からスカラー配列からの初期化への変換を行う。
このフラグは@option{-O2}以上でデフォルトで有効である。

@item -ftree-tail-merge
@opindex ftree-tail-merge
同一コード列を検索する。見つかった時は、それを他の物へのジャンプに置換する。
この最適化は末端マージやクロスジャンプとして知られている。このフラグは@option{-O2}以上で
デフォルトで有効になる。このパスでのコンパイル時間は@option{max-tail-merge-comparisons}パラメータと
@option{max-tail-merge-iterations}パラメータを使って制限できる。

@item -ftree-dce
@opindex ftree-dce
木での未実行コード除去（DCE)を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-builtin-call-dce
@opindex ftree-builtin-call-dce
@code{errno}をセットするかもしれないがそれ以外では副作用のない組み込み関数の呼び出しに対する
条件付き未実行コード除去(DCE)を行う。このフラグは@option{-O}以上で@option{-Os}が指定されていないならば
デフォルトで有効である。

@item -ffinite-loops
@opindex ffinite-loops
@opindex fno-finite-loops
出口のあるループが最終的に出口を取り、無期限にループしないと仮定します。 これにより、コンパイラは、他に副作用のないループを削除でき、最終的な無限ループを考慮しません。

このオプションは、-std=c++11以降のC++の@option{-O2}でデフォルトで有効になっています。

@item -ftree-dominator-opts
@opindex ftree-dominator-opts
ドミネーター・ツリー横断に基づいた様々な単純なスカラー整理（構築・コピー伝搬、冗長除去、範囲伝搬と式の単純化）
を行う。これは（ジャンプからジャンプを削減するための）ジャンプ・スレッディングも行う。
このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-dse
@opindex ftree-dse
木での非到達ストア除去（DSE)を行う。非到達ストアは間のロードがなく、後で他のストアによって上書きされるメモリの場所への
ストアである。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-ch
@opindex ftree-ch
木でのループヘッダコピーを行う。これはコード移動最適化の効果を向上させるので有益である。それはジャンプも節約する。
このフラグは@option{-O}以上でデフォルトで有効である。これは、通常コードサイズを増加させるので、@option{-Os}では有効ではない。

@item -ftree-loop-optimize
@opindex ftree-loop-optimize
木でのループ最適化を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-loop-linear
@itemx -floop-strip-mine
@itemx -floop-block
@opindex ftree-loop-linear
@opindex floop-strip-mine
@opindex floop-block
ループ入れ子最適化を行う。@option{-floop-nest-optimize}と同じである。この変換を使うためには、
GCCはGraphiteループ変換基盤を有効にするために@option{--with-isl}で設定されていなければならない。

@item -fgraphite-identity
@opindex fgraphite-identity
グラファイトの同一性変換を有効にする。すべてのSCoPで多面体的な表現を生成し、gimpleに変換して戻す。
@option{-fgraphite-identity}を使うことでGIMPLE -> GRAPHITE -> GIMPLEのコストや利点をチェックすることができる。
ある添字分割や、ループでの非実行コード除去のようのな最小の最適化もコード生成islによって行われる。

@item -floop-nest-optimize
@opindex floop-nest-optimize
islに基いてループ入れ子最適化器を有効にする。これはPluto最適化アルゴリズムにもどついた汎用ループ入れ子最適化器である。
それはデータ局所性と並列性用に最適化されたループ構造体を計算する。このオプションは実験的である。

@item -floop-parallelize-all
@opindex floop-parallelize-all
並列化できるループを識別できるGraphiteデータ依存解析を使う。ループを並列するのに有益であるとチェックしないで
依存を運ぶループを含まないと解析できるすべてのループを並列化する。

@item -ftree-coalesce-vars
@opindex ftree-coalesce-vars
SSA表現の外へプログラムを変換する間、単なるコンパイラの一時値の代わりに、
異なるユーザ定義変数の合体バージョンによってコピーを削減しようとする。
これは@option{-fno-var-tracking-assignments}でコンパイルされた最適化されたプログラムをデバッグする能力を
ひどく制限するかもしれない。否定形で、このフラグはユーザ変数のSSA合体を防ぐ。このオプションは
最適化が有効ならばデフォルトで有効であり、さもなければほとんど行わない。

@item -ftree-loop-if-convert
@opindex ftree-loop-if-convert
最も内側のループでの条件付きジャンプを分岐なしの等価物に変換しようとする。
意図はベクトル化パスはループを扱う能力を向上させるために最も内側のループから制御フロー
を取り除くことである。これはベクトル化が有効ならばデフォルトで有効である。

@item -ftree-loop-distribution
@opindex ftree-loop-distribution
ループ分散を行う。このフラグは大きなループ本体でのキャッシュパフォーマンスを向上させ、
並列化やベクトル化のようなさらなるループ最適化を可能にする。例えば、ループ
@smallexample
DO I = 1, N
  A(I) = B(I) + C
  D(I) = E(I) * F
ENDDO
@end smallexample
は
@smallexample
DO I = 1, N
   A(I) = B(I) + C
ENDDO
DO I = 1, N
   D(I) = E(I) * F
ENDDO
@end smallexample
へと変換される。このフラグは、@option{-O3}でデフォルトで有効になっています。
@option{-fprofile-use}および@option{-fauto-profile}によっても有効になります。

@item -ftree-loop-distribute-patterns
@opindex ftree-loop-distribute-patterns
ライブラリに呼び出しで生成されるコードになりうるパターンのループ分散を実行する。
このフラグは、@option{-O3}でデフォルトで有効である
。
このパスは初期化ループを分散させて、memset 0への呼び出しを生成する。例えば、ループ
@smallexample
DO I = 1, N
  A(I) = 0
  B(I) = A(I) + I
ENDDO
@end smallexample
は
@smallexample
DO I = 1, N
   A(I) = 0
ENDDO
DO I = 1, N
   B(I) = A(I) + I
ENDDO
@end smallexample
へと変換され、初期化ループはmemset 0への呼び出しへと変換される。このフラグは@option{-O3}でデフォルトで有効になる。@option{-fprofile-use}および@option{-fauto-profile}によっても有効になります。

@item -floop-interchange
@opindex floop-interchange
グラファイトの外側でループ交換を実行します。 このフラグを使用すると、ループネストのキャッシュパフォーマンスが向上し、ベクトル化などのループの最適化をさらに行うことができます。 たとえば、ループ
@smallexample
for (int i = 0; i < N; i++)
  for (int j = 0; j < N; j++)
    for (int k = 0; k < N; k++)
      c[i][j] = c[i][j] + a[i][k]*b[k][j];
@end smallexample
は以下へと変換されます。
@smallexample
for (int i = 0; i < N; i++)
  for (int k = 0; k < N; k++)
    for (int j = 0; j < N; j++)
      c[i][j] = c[i][j] + a[i][k]*b[k][j];
@end smallexample
このフラグは@option{-O3}でデフォルトで有効になる。@option{-fprofile-use}および@option {-fauto-profile}によっても有効になります。

@item -floop-unroll-and-jam
@opindex floop-unroll-and-jam
実現可能なループでアンロールとジャム変換を適用する。 ループネストでは、外部ループを何らかの要因で展開し、結果として得られる複数の内部ループを融合する。 このフラグはデフォルトで@option{-O3}で有効になっている。

@item -ftree-loop-im
@opindex ftree-loop-im
木でのループ不変式移動を行う。このパスはRTLレベルで扱うのが難しい不変式（関数呼び出し、非自明の命令列へと拡張される操作）
のみを動かす。@option{-funswitch-loops}でループの外の不変である条件のオペランドも移動するので、
ループ非スイッチ化で単なる自明不変解析を使うことができる。このパスはストア移動も含んでいる。

@item -ftree-loop-ivcanon
@opindex ftree-loop-ivcanon
繰り返しの数を決定するために複雑な解析を必要とするループで、繰り返しの数ために規範的なカウンタを作成する。
後の最適化は、それから簡単に数を測定するかもしれない。特にループ展開に関連して役に立つ。

@item -ftree-scev-cprop
@opindex ftree-scev-cprop
最終的な値の置換を実行します。 ループを終了するときの値が初期値とループ反復回数のみを使用して決定できるようにループ内で変数が変更された場合、そのような計算によって最終値の使用を十分に安価に置き換えます 。これにより、データの依存関係が減り、さらに簡素化できる場合があります。@option{-O}以降でデフォルトで有効になります。

@item -fivopts
@opindex fivopts
木で誘導変数最適化（強さ縮小、結合している誘導変数と誘導変数除去）を実行する。

@item -ftree-parallelize-loops=n
@opindex ftree-parallelize-loops
ループを並列化する。すなわち、その繰り返し空間をｎスレッドで走るように分割する。
これはその繰り返しが独立で任意に並べ替えができるループでのみ可能である。
この最適化は、例えばメモリ帯域幅によって制約されるよりはむしろ、CPU集約型であるループ用のため、
マルチプロセッサマシンでのみ利益をもたらす。このオプションは@option{-pthread}を含み、
したがって@option{-pthread}をサポートしているターゲットでのみサポートされる。

@item -ftree-pta
@opindex ftree-pta
木での関数局所対点解析を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-sra
@opindex ftree-sra
集計のスカラー置換を実行します。 このパスは、構造参照をスカラーに置き換えて、構造をメモリにコミットするのが早すぎることを防ぎます。 このフラグは、@option{-Og}を除き、@option{-O1}以上でデフォルトで有効になっています。

@item -fstore-merging
@opindex fstore-merging
狭い記憶域を連続したメモリアドレスにマージする。このパスは、命令の数を減らすために、ワード長よりも狭い直接値の隣接するストアをより少ないより広いストアにマージする。 これはデフォルトでは@option{-O2}以上、@option{-Os}で有効になっている。

@item -ftree-ter
@opindex ftree-ter
SSA→通常フェーズの間に一時式置換を行う。単一使用・単一定義の一時式はその使用場所でその定義式へ置換される。
これは非GIMPLEコード内で起こるが、展開器にもっとずっと複雑な木を与えて、よりよいTRL生成が起こるように取り組む。
これは@option{-O}以上でデフォルトで有効である。

@item -ftree-slsr
@opindex ftree-slsr
木での直線長さ削減を行う。これは乗算を含んでいる関連した表現を認識して、可能な場合それらをより高価でない計算と置き換える。
これは@option{-O}以上でデフォルトで有効である。

@item -ftree-vectorize
@opindex ftree-vectorize
木でのベクトル化を行う。このフラグはもし明示的に指定されていないなら@option{-ftree-loop-vectorize}と
@option{-ftree-slp-vectorize}を有効にする。

@item -ftree-loop-vectorize
@opindex ftree-loop-vectorize
木でのループベクトル化を行う。このフラグは@option{-O3}でと、@option{-ftree-vectorize}が有効の時にデフォルトで有効である。

@item -ftree-slp-vectorize
@opindex ftree-slp-vectorize
木での基本ブロックベクトル化を行う。このフラグは@option{-O3}でと、@option{-ftree-vectorize}が有効の時にデフォルトで有効である。

@item -fvect-cost-model=@var{model}
@opindex fvect-cost-model
ベクトル化で使われるコストモデルを変更する。@var{model}引数は @samp{unlimited}, @samp{dynamic}, @samp{cheap}の一つであるべきである。
@samp{unlimited}モデルではベクトル化されたコードパスは利益があると仮定される一方、
@samp{dynamic}モデルではランタイムチェックがベクトル化されたコードパスが繰り返し回数が元のスカラーループが実行される時よりも
速いだろう時のみ有効にするように守る。@samp{cheap}モデルは、そうすることがたとえばデータ依存またはアラインメントの必須の
ランタイム・チェックのために
ひどく高くつく時にループベクトル化を無効にするが、それ以外は@samp{dynamic}モデルと等しい。

@item -fsimd-cost-model=@var{model}
@opindex fsimd-cost-model
OpenMP simdディレクティブマークされたループのベクトル化で使われるコストモデルを変える。
@var{model}引数は @samp{unlimited}, @samp{dynamic}, @samp{cheap}の一つであるべきである。
@var{model}のすべての値は@option{-fvect-cost-model}で描写されたのと同じ意味をもち、デフォルトでは
@option{-fvect-cost-model}で使われたコストモデルが使われる。

@item -ftree-vrp
@opindex ftree-vrp
木での値範囲伝搬を行う。これは定数伝搬パスに似ているが、値の代わりに、値の範囲が伝搬する。
これは不必要な配列境界チェックやヌルポインタチェックのような範囲チェックを削除する最適化を可能にする。
これは@option{-O2}以上でデフォルトで有効である。ヌルポインタチェック除去は@option{-fdelete-null-pointer-checks}が
有効の時だけ行われる。

@item -fsplit-paths
@opindex fsplit-paths
ループバックエッジを導くパスを分割する。これは非到達コード除去と共通部分式除去を向上させる。これは
@option{-O3}以上でデフォルトで有効である。

@item -fsplit-ivs-in-unroller
@opindex fsplit-ivs-in-unroller
最初の繰り返しでの値を使って展開されたループの後半の繰り返しでの導出変数の値の表現を有効にする。
これはループ依存連鎖を壊すので、スケジューリングパスの効率性を向上させる。

@option{-fweb}とCSEの組み合わせはしばしば同じ効果を得るために十分である。しかし、これはループ本体が
単一基本ブロックよりも複雑な場合には信頼出来ない。それはさらに、CSEパスでの制限のためにあるアーキテクチャでは全く働かない。

この最適化はデフォルトで有効である。

@item -fvariable-expansion-in-unroller
@opindex fvariable-expansion-in-unroller
このオプションでコンパイラはループ展開時にある局所変数の複数のコピーを作り、それはより良いコードを起こしうる。

この最適化は、PowerPCターゲットではデフォルトで有効になっていますが、それ以外の場合はデフォルトで無効になっています。

@item -fpartial-inlining
@opindex fpartial-inlining
関数の部分をインライン化する。このオプションはインライン自身が@option{-finline-functions}か
@option{-finline-small-functions}オプションによってONの時だけ効果がある。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fpredictive-commoning
@opindex fpredictive-commoning
予測的共通化最適化、すなわち（時にメモリのロード・ストアする）前のループの繰り返しで行われた計算の再利用を行う。

このオプションはレベル@option{-O3}で有効である。@option{-fprofile-use}および@option{-fauto-profile}によっても有効になります。

@item -fprefetch-loop-arrays
@opindex fprefetch-loop-arrays
ターゲット機種がサポートしているならば、大きは配列にアクセスするループのパフォーマンスを向上させるために、
メモリへのプリフェッチの命令を生成する。

このオプションはより良いコードもより悪いコードも生成するかもしれない。結果はソースコード内のループの構造に
強く依存する。

レベル@option{-Os}で無効にされる。

@item -fno-printf-return-value
@opindex fno-printf-return-value
@opindex fprintf-return-value
@code{sprintf}、@code{vprintf}、@code{vsprintf}、@code{vsnprintf}のようなフォーマットされた出力関数の既知の戻り値に定数を代入しない。 （しかし@code{sprintf}と@code{fprintf}は除く）。
この変換により、GCCは、定数であるか、または正確な戻り値を可能にする範囲内の値であることが知られている引数で呼び出される、これらの関数の既知の戻り値に基づいて分岐を最適化または排除することさえできる。 たとえば、@option{-fprintf-return-value}が有効な場合、@code{if}文の分岐と本体（@code{snprintf}の呼び出しではない） は、@code{i}が32ビット以下の整数のときは、戻り値が多くても8であると保証されているので最適化で消すことができる。

@smallexample
char buf[9];
if (snprintf (buf, "%08x", i) >= sizeof buf)
  @dots{}
@end smallexample

@option{-fprintf-return-value}オプションは、他の最適化に依存し、@option{-O2}以上で最良の結果をもたらす。 @option{-Wformat-overflow}オプションと@option{-Wformat-truncation}オプションと連携して動作する。
@option{-fprintf-return-value}オプションは、デフォルトで有効になっている。

@item -fno-peephole
@itemx -fno-peephole2
@opindex fno-peephole
@opindex fpeephole
@opindex fno-peephole2
@opindex fpeephole2
機種依存の覗き穴最適化を無効にする。@option{-fno-peephole}と@option{-fno-peephole2}の違いは
コンパイラ内でどのように実装されているかである。あるターゲットは片方を使い、別のはもう片方を使い、一部は両方使う。

@option{-fpeephole}はデフォルトで有効である。
@option{-fpeephole2}はレベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fno-guess-branch-probability
@opindex fno-guess-branch-probability
ヒュリスティックを使って分岐確率を推測しない。

GCCをはもしプロファイリングフィードバック(@option{-fprofile-arcs})によって提供されていない時は、
分岐確率を推測するのにヒューリスティックを使う。
これらのヒューリスティックは制御フローグラフにもとづいている。もし分岐確率が@code{__builtin_expect}で指定されているならば、
ヒューリスティックは制御フローグラフの残りの分岐確率を推測するのに使われ、@code{__builtin_expect}情報が考慮に入れられる。
ヒューリスティックと@code{__builtin_expect}の相互作用は複雑になりえ、ある場合には、ヒューリスティックを無効にして
@code{__builtin_expect}の効果が理解しやすくすることが役立つかもしれない。

デフォルトはレベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}では@option{-fguess-branch-probability}である。

@item -freorder-blocks
@opindex freorder-blocks
取られる分岐を減らしてコード局所性を向上させるためにコンパイルされた関数の基本ブロックを並べ替える。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -freorder-blocks-algorithm=@var{algorithm}
@opindex freorder-blocks-algorithm
基本ブロックの並べ替えに、指定されたアルゴリズムを使う。@var{algorithm}引数は、
（アラインメントのような時々の二次作用を除いて）それはコードサイズを増やさない@samp{simple}、
しばしば実行コードをまとめ、追加のコードのコピーを作ることで実行される分岐の数を最小化する
「ソフトウェアトレースキャッシュ」アルゴリズムの@samp{stc}が可能である。

デフォルトはレベル@option{-O}, @option{-Os}では@samp{simple}で、レベル@option{-O2}, @option{-O3}
では@samp{stc}である。

@item -freorder-blocks-and-partition
@opindex freorder-blocks-and-partition
コンパイルされた関数での基本ブロックの並べ替えに加え、取られる分岐の数を減らすために、
熱いのと冷たい基本ブロックをアセンブリと@file{.o}ファイルの別々のセクションへと分割し、
ページングとキャッシュ局所性パフォーマンスを向上させる。

この最適化は、例外処理または巻き戻しテーブル（setjump/longjumpまたはターゲット固有のスキームを使用するターゲット）、リンク・ワンスセクション、ユーザー定義セクション属性を持つ関数、および名前付きセクションサポートしていないアーキテクチャで自動的にオフになる。 @option{-fsplit-stack}を使用すると、このオプションはデフォルトでは（リンカエラーを避けるために）有効にはならないが、明示的に有効にすることができる（機能するリンカーを使用している場合）。
  
@option {-O2}、@option {-O3}、@option {-Os}のレベルでx86用に有効になる。

@item -freorder-functions
@opindex freorder-functions
コード局所性を向上させるためにオブジェクトファイルの関数を並べ替える。
これは最も頻繁に実行される関数に@code{.text.hot}サブセクションを使って、あまり実行されない関数に
@code{.text.unlikely}を使うことで実行される。並べ替えはリンカによって行われるので
オブジェクトファイルフォーマットは名前付きセクションをサポートしてリンカは合理的な方法で
それらを配置しなければならない。

さらにこのオプションを効果的にするにはプロファイル・フィードバックも有効にしなければならない。
詳細は@option{-fprofile-arcs}を見よ。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fstrict-aliasing
@opindex fstrict-aliasing
コンパイラはコンパイルされる言語のに適用される最も厳格なエイリアスルールを仮定する。
C（とC++）では、これは式の型に基づいた最適化を有効にする。特に、一つの型のオブジェクトは
型がほとんど同じでない限りは、決して同じアドレスで異なる型で存在しないと仮定する。
例えば、@code{unsigned int}は@code{int}とは別名になれるが、@code{void*}や@code{double}とは
別名になれない。文字型は他のどの型とも別名になっても良い。

@anchor{Type-punning}このようなコードに注意を払え。
@smallexample
union a_union @{
  int i;
  double d;
@};

int f() @{
  union a_union t;
  t.d = 3.0;
  return t.i;
@}
@end smallexample
最も最近に書かれたものではない共用体のメンバから読むこと（タイプ・パンニングと呼ばれる）は一般的である。
@option{-fstrict-aliasing}があっても、タイプ・パンニングは許され、メモリは共用体を通してアクセスできる。
したがって、上のコードは期待した通りに動く。 @xref{Structures unions enumerations and bit-fields
implementation}。しかし、このコードはそうでないかもしれない。
@smallexample
int f() @{
  union a_union t;
  int* ip;
  t.d = 3.0;
  ip = &t.i;
  return *ip;
@}
@end smallexample

同様に、アドレスを取ってアクセスし、結果のポインタをキャストして、
その結果の被参照をすることは、たとえキャストが共用体を使っていても未定義の振る舞いである。例えば、
@smallexample
int f() @{
  double d = 3.0;
  return ((union a_union *) &d)->i;
@}
@end smallexample

@option{-fstrict-aliasing}オプションはレベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -falign-functions
@itemx -falign-functions=@var{n}
@itemx -falign-functions=@var{n}:@var{m}
@itemx -falign-functions=@var{n}:@var{m}:@var{n2}
@itemx -falign-functions=@var{n}:@var{m}:@var{n2}:@var{m2}
@opindex falign-functions
関数の先頭を、@var{m}-1バイトまでスキップして、@var{n}より大きい次の2のべき乗に揃えます。 これにより、@var{n}バイトのアライメント境界を超えることなく、少なくとも関数の最初の@var{m}バイトをCPUでフェッチできます。

@var{m}が指定されていない場合、デフォルトは@var{n}になります。

例：@option{-falign-functions=32}は、関数を次の32バイト境界に位置合わせします。@option{-falign-functions=24}は、23バイト以下をスキップしてこれを行うことができる場合にのみ、次の32バイト境界に位置合わせします。@option{-falign-functions=32:7}は、6バイト以下をスキップしてこれを実行できる場合にのみ、次の32バイト境界に整列します。

@var{n2}:@var{m2}値の2番目のペアでは、2次アライメントを指定できます。@option{-falign-functions=64:7:32:3}は、6バイト以下をスキップすることで実行できる場合には次の64バイト境界にアライメントします。 さもなければ、2バイト以下をスキップすることで実行できる場合は、次の32バイト境界に揃えます。
@var{m2}が指定されていない場合、デフォルトは@var{n2}になります。

一部のアセンブラは、@var{n}が2の累乗の場合にのみこのフラグをサポートします。その場合、切り上げられます。

@option{-fno-align-functions}と@option{-falign-functions=1}は同等であり、関数が整列されないことを意味します。

@var{n}が指定されていないかゼロの場合、マシン依存のデフォルトを使用します。許可される@var{n}オプションの最大値は65536です。

レベル@option{-O2}, @option{-O3}で有効である。

@item -flimit-function-alignment
このオプションを有効にすると、コンパイラは不要なオーバーアライン機能を回避しようとする。 @option{-falign-functions}で指定された量だけ整列するが、関数のサイズよりも多くのバイトをスキップしないようにアセンブラに指示するが。

@item -falign-labels
@itemx -falign-labels=@var{n}
@itemx -falign-labels=@var{n}:@var{m}
@itemx -falign-labels=@var{n}:@var{m}:@var{n2}
@itemx -falign-labels=@var{n}:@var{m}:@var{n2}:@var{m2}
@opindex falign-labels
@option{-falign-functions}のように@var{n}バイトまでを飛ばしてすべての分岐ターゲットを2のベキの境界に揃える。

このオプションのパラメーターは、@option{-falign-functions}オプションに類似しています。@option{-fno-align-labels}と@option{-falign-labels=1}は同等であり、ラベルが整列されていないことを意味します。

@option{-falign-loops}か@option{-falign-jumps}が適用可能でこの値よりも大きいならば、代わりにそれらの値が使われる。

もし@var{n}が指定されていないか0ならば、機種依存のデフォルト値が使われ、それはアラインメントをしないことを意味する@samp{1}である可能性が高い。@var{n}の可能な最大値は65536である。

レベル@option{-O2}, @option{-O3}で有効である。

@item -falign-loops
@itemx -falign-loops=@var{n}
@itemx -falign-loops=@var{n}:@var{m}
@itemx -falign-loops=@var{n}:@var{m}:@var{n2}
@itemx -falign-loops=@var{n}:@var{m}:@var{n2}:@var{m2}
@opindex falign-loops
@option{-falign-functions}のように@var{n}バイトまで飛ばしてループを２のベキの境界に揃える。
もしループが何回も実行されるなら、これはダミー操作の実行を作る。

このオプションのパラメーターは、@option{-falign-functions}オプションに類似しています。 @option{-fno-align-loops}と@option{-falign-loops=1}は同等であり、ループが整列しないことを意味します。許可される@var {n}オプションの最大値は65536です。

もし@var{n}が指定されていないか0ならば、機種依存のデフォルトが使われる。

レベル@option{-O2}, @option{-O3}で有効である。

@item -falign-jumps
@itemx -falign-jumps=@var{n}
@itemx -falign-jumps=@var{n}:@var{m}
@itemx -falign-jumps=@var{n}:@var{m}:@var{n2}
@itemx -falign-jumps=@var{n}:@var{m}:@var{n2}:@var{m2}
@opindex falign-jumps
ジャンプによってのみ到達可能な分岐ターゲットを、@option{-falign-functions}のように@var{n}バイトまで飛ばして2のベキの境界に揃える。
この場合には、ダミー操作を実行する必要はない。

このオプションのパラメーターは、@option{-falign-functions}オプションに類似しています。 
@option{-fno-align-jumps}と@option{-falign-jumps=1}は等価であり、ループがアラインメントされないことを意味する。

もし@var{n}が指定されていないか0ならば、機種依存のデフォルトが使われる。@var{n}の可能な最大値は65536である。

レベル@option{-O2}, @option{-O3}で有効である。

@item -fno-allocation-dce
@opindex fno-allocation-dce
デッドコードの除去で未使用のC++割り当てを削除しない。

@item -fallow-store-data-races
@opindex fallow-store-data-races
変数が他のスレッドによって同時にアクセスできないことを証明することなく、コンパイラーがストアに新しいデータ競合を導入する可能性のある最適化を実行できるようにします。 ローカルデータの最適化には影響しません。 グローバルデータが複数のスレッドによってアクセスされないことがわかっている場合は、このオプションを使用しても安全です。

@option{-fallow-store-data-races}によって有効化される最適化の例には、すでにメモリ内にある値が同じ値で再書き込みされる可能性のある巻き上げまたはif変換が含まれます。 このような書き換えは、シングルスレッドのコンテキストでは安全ですが、マルチスレッドのコンテキストでは安全でない場合があります。 一部のプロセッサでは、ベクトル化を有効にするためにif変換が必要になる場合があることに注意してください。

レベル@option{-Ofast}で有効になります。

@item -funit-at-a-time
@opindex funit-at-a-time
このオプションは互換性のために残されている。@option{-funit-at-a-time}には効果がないが、
@option{-fno-unit-at-a-time}は@option{-fno-toplevel-reorder}と@option{-fno-section-anchors}を含む。

デフォルトで有効である。

@item -fno-toplevel-reorder
@opindex fno-toplevel-reorder
関数、変数、@code{asm}を並べ替えない。それらの出力は入力ファイルで現れたのと同じ順で出力される。
このオプションが使われると、未参照の静的変数は削除されない。このオプションは特定の順序に依存した既存のコードをサポートすることを
意図している。新しいコードでは、可能なら属性を使ったほうがいい。

@option{-ftoplevel-reorder}は、@option{-O1}以上ではデフォルトであり、@option{-fsection-anchors}が明示的に要求されている場合は@option{-O0}でもデフォルトです。
さらに、@option{-fno-toplevel-reorder}は@option{-fno-section-anchors}を意味します。

@item -fweb
@opindex fweb
レジスタ割当の目的で一般的に使われる網羅図を構築し、それぞれの網羅図に個々の擬似レジスタを割り当てる。
これはレジスタ割当パスが擬似レジスタを直接操作することを可能にするが、CSE、ループ最適化、自明の非実行コードの除去のような
いくつかの他の最適化も強化する。しかし、変数がもはや「ホームレジスタ」にとどまっていないので、デバッグを不可能にしうる。

@option{-funroll-loops}でデフォルトで有効である。

@item -fwhole-program
@opindex fwhole-program
現在のコンパイル単位がコンパイルされう全プログラムを表現していると仮定する。@code{main}の例外を除いたすべてのパブリック関数と変数と
属性@code{externally_visible}によってマージされたものは静的関数になり、その効果で手続間最適化によってもっと積極的に最適化される。

このオプションは@option{-flto}と組み合わせて使うべきではない。代わりにリンカプラグインに頼って、もっと安全でもっと正確な情報を
提供すべきである。

@item -flto[=@var{n}]
@opindex flto
このオプションは標準リンク時最適化を走らせる。ソースコード付きで実行した時は、GIMPLE（GCCの内部表現の一つ）を生成して
オブジェクトファイルの特別なELEセクションに書き出す。オブジェクトファイルが一緒にリンクされた時は、
すべての関数本体がそれらのELFセクションから読み出されて同じ翻訳単位であるかのように実体化される。

リンク時最適化を使うためには、@option{-flto}と最適化オプションがコンパイル時と最後のリンクの間に指定されるべきである。
あなたが同じオプションで同じリンクに関与しているすべてのファイルをコンパイルして、そのうえオプションをリンク時にも指定することを推奨する。
例えば：

@smallexample
gcc -c -O2 -flto foo.c
gcc -c -O2 -flto bar.c
gcc -o myprog -flto -O2 foo.o bar.o
@end smallexample

最初の２つのGCCはへの呼び出しはGIMPLEのバイトコード表現を@file{foo.o}と@file{bar.o}に保存する。
最後の呼び出しは@file{foo.o}と@file{bar.o}からGIMPLEバイトコードを呼んで、一つのイメージにマージして、
いつもどおり結果をコンパイルする。@file{foo.o}と@file{bar.o}の両方が単一のイメージにマージされるので、
これは２つのファイルをまたいで働くGCCはでの手続間解析と最適化のすべてが、まるで単一ファイルであるかのように効くようになる。
これは、例えば、インライン化器が@file{bar.o}での関数を@file{foo.o}にインライン化したり、その逆ができるようになることを意味する。

他の（もっと単純な）リンク時最適化を有効にする方法は：

@smallexample
gcc -o myprog -flto -O2 foo.c bar.c
@end smallexample

上は@file{foo.c}と@file{bar.c}のバイトコードを生成し、それらを単一のGIMPLE表現にマージして
いつもどおり@file{myprog}を生成するために最適化する。

心に留めておかないといけない唯一の重要なことはリンク時最適化を有効にするためにはリンクステップを行うために
GCCはドライバを使う必要があることである。GCCは関与したオブジェクトのどれかががそれから@option{-flto}コマンドラインオプションで
コンパイルされているなら自動的にリンク時最適化を行う。GCCはリンク時に指定しそこねたならばコンパイル時に使われたオプションから
最適化レベルを推測することで賢くなろうとするが、一般的にはリンク時最適化で使われる最適化オプションを指定すべきである。
いつもリンク時に@option{-fno-lto}をリンクコマンドに渡すことでリンク時最適化の自動決定を上書きできる。

全プログラム最適化を効果的にするには、ある全プログラム仮定を置く必要がある。
コンパイラはどの関数と変数がライブラリとリンク時最適化単位の外のランタイムによってアクセスされうるかを知る必要がある。
リンカによってサポートされている時、リンカプラグイン(@option{-fuse-linker-plugin}参照)はコンパイラに使われて外部から可視のシンボルの
情報を渡す。リンカプラグインが利用できない時は、@option{-fwhole-program}をコンパイラがこれらの仮定を行うことを許可するのに使うべきであり、
それによってもっと積極的な最適化の決定を導く。

@option{-fuse-linker-plugin}が有効でない時は、@option{-flto}でファイルがコンパイルされるとき、
生成されたオブジェクトファイルはGIMPLEバイトコードと通常の最終コードを含むので(@option{-ffat-lto-objects}参照)
通常のオブジェクトファイルよりも大きくなる。これはLTO情報ありのオブジェクトファイルは通常のオブジェクトとしてリンクできることを意味する。
もし@option{-fno-lto}がリンカに渡されたなら、手続間最適化は適用されない。
@option{-fno-fat-lto-objects}が有効なときはコンパイル段階は速くなるが、それらを通常の非LTOリンクは行えないことに注意する。

最終バイナリを生成するとき、GCCはリンク時最適化をバイトコードを含むファイルに対してのみ適用する。
したがって、オブジェクトファイルとライブラリをGIMPLEバイトコードと最終オブジェクトコードで混ぜて一致させることができる。
GCCは自動的にどのファイルがLTOモードで最適化されてどのファイルがさらなる処理をせずにリンクするかを選択する。

一般に、リンク時に指定されたオプションはコンパイル時に指定されたオプションをオーバーライドしますが、GCCは入力ファイルのコンパイルに使用される設定からリンク時オプションを推測しようとする場合があります。

リンク時に最適化レベルオプション@option{-O}を指定しない場合、GCCはオブジェクトファイルのコンパイル時に使用される最高の最適化レベルを使用します。 2つの理由から、コンパイル時ではなくリンク時のみに最適化レベルオプションを指定することは一般に無効であることに注意してください。 まず、最適化なしでコンパイルすると、リンク時に効果的な最適化に必要な情報を収集するコンパイラパスが抑制されます。 第二に、いくつかの初期の最適化パスはリンク時にではなくコンパイル時にのみ実行できます。

次のオプション@option{-fPIC}、@option{-fpic}、@option{-fpie}、および@option{-fPIE}は、次のスキームに基づいて組み合わされます。

@smallexample
@option{-fPIC} + @option{-fpic} = @option{-fpic}
@option{-fPIC} + @option{-fno-pic} = @option{-fno-pic}
@option{-fpic/-fPIC} + (no option) = (no option)
@option{-fPIC} + @option{-fPIE} = @option{-fPIE}
@option{-fpic} + @option{-fPIE} = @option{-fpie}
@option{-fPIC/-fpic} + @option{-fpie} = @option{-fpie}
@end smallexample

あるABI変更フラグはすべてのコンパイル単位で一致する必要があり、リンク時にこの値を矛盾した値で上書きしようとしても無視される。
これには@option{-freg-struct-return}や@option{-fpcc-struct-return}のようなオプションが含まれる。

他の@option{-ffp-contract}, @option{-fno-strict-overflow},
@option{-fwrapv}, @option{-fno-trapv}, @option{-fno-strict-aliasing}のようなオプションは
リンク段階を通して渡され、矛盾する翻訳単位で保守的にマージされる。特に
@option{-fno-strict-overflow}, @option{-fwrapv}, @option{-fno-trapv}は優先順位を取る。
そして例えば、@option{-ffp-contract=off}は@option{-ffp-contract=fast}より優先される。それらはリンク時に上書きされる。

@option{-Wstringop-overflow}などの診断オプションはリンクステージに渡され、それらの設定は関数の粒度でコンパイルステップの設定と一致します。 これは、最適化中に発行された診断に対してのみ重要であることに注意してください。 コードがコンパイル時の設定と一致しない場合、インライン化などのコード変換により、リージョンに対して警告が有効または無効になる可能性があることに注意してください。

@option{-Wa}または@option{-Xassembler}を介してアセンブラにオプションを渡す必要がある場合は、そのような翻訳単位を@option{-fno-lto}でコンパイルするか、すべての翻訳単位で一貫して同じアセンブラオプションを使用してください。 または、LTOリンク時にアセンブラオプションを指定することもできます。

デバッグ情報の生成を有効にするには、コンパイル時に@option{-g}を指定する必要があります。 リンク時の入力ファイルのいずれかがデバッグ情報生成を有効にして構築されている場合、リンクはデバッグ情報生成も有効にします。 ドワーフレベル@option{-gdwarf-5}などの複雑なデバッグ情報設定は、リンカーコマンドラインで明示的に繰り返す必要があり、異なる設定を異なる翻訳単位で混在させることはお勧めしません。

もしLTOが一緒にリンクされる別の翻訳単位の型と非互換で宣言されているCリンケージのオブジェクトに出会ったら、
(ISO C99 6.2.7によれば未定義の振る舞い), 致命的でない診断が出るかもしれない。振る舞いは実行時は依然として未定義である。
同様の診断が他の言語でも発するかも知れない。

LTOのもう一つの機能は別の言語で書かれたファイルで手続間最適化が適用できることである。

@smallexample
gcc -c -flto foo.c
g++ -c -flto bar.cc
gfortran -c -flto baz.f90
g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran
@end smallexample

最後のリンクはC++実行時ライブラリを得るために@command{g++}で行われFortran実行時ライブラリを得るために
@option{-lgfortran}が加えられる。一般的に、LTOのモードで言語を混ぜるときは、通常の（非LTOの）コンパイルで
言語を混ぜるときと同じリングコマンドオプションを使うべきである。

もしGIMPLEバイトコードを含むオブジェクトファイルが、例えば@file{libfoo.a}のようなライブラリアーカイブに格納されているなら、
プラグインサポートのあるリンカを使えばそれらを抽出してLTOリンクで使うことができる。LTOに適した静的ライブラリを作るためには、
@command{ar}と@command{ranlib}の代わりに @command{gcc-ar}と@command{gcc-ranlib}を使う。
GIMPLEバイトコードでオブジェクトファイルのシンボルを見るためには、@command{gcc-nm}を使う。
これらのコマンドは@command{ar}, @command{ranlib}, @command{nm}がプラグインサポートでコンパイルされている必要がある。
リンク時にLTO最適化過程でライブラリが関与することを保証するためには、フラグ@option{-fuse-linker-plugin}を使う。

@smallexample
gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo
@end smallexample

リンカプラグインが有効ならば、リンカは必要なGIMPLEファイルを@file{libfoo.a}から抽出してそれらを最適化される集積されたGIMPLEイメージ
の一部に加えるように走っているGCCのに渡す。

もしプラグインサポートのあるリンカを使っていないかつ・またはリンカプラグインを有効にしていないならば、
@file{libfoo.a}内部のオブジェクトが抽出されていつもどおりリンクされるが、LTO最適化処理には関与しない。
LTO最適化と通常のリンクの両方に適した静的ライブラリを作るためには、オブジェクトファイルを
@option{-flto} @option{-ffat-lto-objects}でコンパイルする。

リンク時最適化は操作するのにプログラム全体が存在する必要はない。もしプログラムがエクスポートされるシンボルを必要としないなら、
向上された最適化の機会を導くかもしれないもっと積極的な過程を使った手続間最適化を可能にするように@option{-flto}と@option{-fwhole-program}を
組み合わせることが可能である。
@option{-fwhole-program}の使用はリンカプラグインが起動中の時は必要ない(@option{-fuse-linker-plugin}参照)。

LTOの現在の実装は異なるタイプのホストで移植性があるバイトコードを生成しようとはしない。
バイトコードファイルはバージョン化されて、厳密なバージョンチェックがあるので、あるバージョンのGCCで生成された
バイトコードファイルは古い、もしくは新しいGCCのバージョンでは動かない。

リンク時最適化はELFとDWARFの組み合わせ以外でのシステムでのデバッグ情報の生成とはうまく働かない。

任意の@var{n}を指定したならば、リンク時の最適化とコード生成はインストールされた@command{make}プログラムを調整して
@var{n}の並列ジョブを使って並列に実行される。環境変数@env{MAKE}は使われるプログラムを上書きするのに使うことができる。
@var{n}のデフォルト値は1である。

@option{-flto=jobserver}をGNU makeのジョブサーバーモードを並列ジョブの数を決定するために使うために指定することができる。
これはすでにGCCを呼ぶMakefileがすでに並列で実行されている時に役立つ。これを働かせるためには現在のMakefileで
コマンドレシピの前に@samp{+}を加えなくてはならない。このオプションは@env{MAKE}がGNU makeの時だけ働くだろう。

@option{-flto=auto}を使用して、GNU makeのジョブサーバーを使用します（使用可能な場合）。または、システムに存在するCPUスレッドの数の自動検出にフォールバックします。

@item -flto-partition=@var{alg}
@opindex flto-partition
リンク時最適化器で使われる分割アルゴリズムを指定する。値は元のソースファイルを反映する
分割を指定する@samp{1to1}か、（可能なときは）同等のサイズのチャンクへと分割するように指定する@samp{balanced}か、
可能な限り各シンボルで新しい領域を作る@samp{max}のどれかである。
アルゴリズムとして@samp{none}を指定すると分割を無効にして完全にストリーミングする。
デフォルト値は@samp{balanced}である。様々なコード順序問題の回避方法として@samp{1to1}を使うことができる一方、
@samp{max}分割は内部テスト専用を意図している。値@samp{one}が正確に一つの分割が使われるべきであることを指定するのに対し、
値@samp{none}は分割を迂回してリンク時最適化ステップをWPAフェーズから直接実行する。

@item -flto-compression-level=@var{n}
@opindex flto-compression-level
このオプションはLTOオブジェクトファイルに書かれる中間言語で使われる圧縮レベルを指定し、LTOモード(@option{-flto})との組み合わせ
でのみ意味を持つ。正当な値は0(圧縮なし)から9(最大圧縮)である。この範囲外の値は0か9に固定される。もしオプションが与えられなければ、
デフォルトのバランスのとれた圧縮設定が使われる。

@item -fuse-linker-plugin
@opindex fuse-linker-plugin
リンク時最適化でリンカプラグインの使用を有効にする。このオプションはリンカでのプラグインサポートに依存していて、
goldかGNU ld 2.21以降で利用可能である。

このオプションはGIMPLEバイトコードのあるオブジェクトファイルをライブラリアーカイブから抽出することを可能にする。
これはリンク時最適化でもっと多くのコードを晒すことで最適化の質を向上させる。この情報はどのシンボルが外部でアクセスされることが可能かを
（非LTOのオブジェクトか動的リンクの間に）指定する。バイナリ（と共有リンク）での結果のコード品質向上は
@option{-fwhole-program}と同様である。このフラグの効果の描写とどのように使うかは@option{-flto}を見よ。

このオプションはGCCはのLTOサポートが有効でGCCがプラグインをサポートするリンカ(GNU ld 2.21以降かgold)を使うように設定されていたら
デフォルトで有効である。

@item -ffat-lto-objects
@opindex ffat-lto-objects
ファット・LTOオブジェクトは中間言語とオブジェクトコードの両方を含むオブジェクトファイルである。
これはそれらをLTOリンクと通常のリンクの両方で利用可能にする。このオプションは@option{-flto}でコンパイルした時だけ
効果があり、リンク時は無視される。

@option{-fno-fat-lto-objects}は素のLTOに比較してコンパイル時間を向上させるが、LTOを感知する完全なツールチェーンが必要である。
それは基本機能にリンカプラグインサポートのあるリンカを必要とする。さらに、@command{nm}、@command{ar}、@command{ranlib}が
（静的ライブラリなどをビルドする能力がある）完全に機能するビルド環境を許すためにはリンカプラグインをサポートする必要がある。
GCCは正しいオプションをそれらのツールに渡すために@command{gcc-ar}, @command{gcc-nm}, @command{gcc-ranlib}ラッパを提供している。
非ファットLTOのmakefileはそれらを使うように修正する必要がある。

現代のbinutilsは、プラグインの自動ロードメカニズムを提供している。 リンカプラグインを@file{$libdir/bfd-plugins}にインストールすると、コマンドラッパー（@command{gcc-ar}、@command{gcc-nm}、@command{gcc-ranlib}）と同じ効果がある 。

デフォルトはリンカプラグインをサポートしたターゲットでは@option{-fno-fat-lto-objects}である。

@item -fcompare-elim
@opindex fcompare-elim
レジスタ割当とレジスタ割当後命令分割の後に、その算術に基づく比較命令と同様のプロセッサフラグを計算している算術命令を識別する。
もし可能なら、明示的な比較命令を除去する。

このパスはレジスタ割当が完了するまえに比較操作を明示的に表現できないあるターゲットでの適用される。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fcprop-registers
@opindex fcprop-registers
レジスタ割当とレジスタ割当後命令分割の後に、スケジュール依存を削減しようとするために、コピー伝搬パスを行い、時々コピーを除去する。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fprofile-correction
@opindex fprofile-correction
マルチスレッドプログラムの測定バイナリを使って収集されたプロファイルは失われたカウンタ交信のために矛盾しているかもしれない。
このオプションが指定された時は、GCCはヒューリスティックを使ってこの矛盾を修正・補正する。デフォルトではGCCは矛盾したプロファイルを検知したら
エラーメッセージを生成する。

@item -fprofile-partial-training
@opindex fprofile-use
@code{-fprofile-use}を使用すると、訓練の走行中に実行されないプログラムのすべての部分が、速度ではなくサイズに対して積極的に最適化されます。 プログラム内のすべての可能なホットパスをトレーニングするのが現実的でない場合があります。 （たとえば、プログラムには特定のハードウェアに固有の関数が含まれている場合があり、トリアーニングは、プログラムが実行されるすべてのハードウェア構成をカバーしていない場合があります。）@code{-fprofile-partial-training}を使用すると、プロファイルフィードバックは、 それらがプロファイルフィードバックなしでコンパイルされたかのように最適化されるようにトレーニングを実行します。 これにより、トレインランが代表的ではない場合のパフォーマンスが向上しますが、コードが大幅に大きくなります。

@item -fprofile-use
@itemx -fprofile-use=@var{path}
@opindex fprofile-use
プロファイルのフィードバックに指示された最適化を有効にし、プロファイルフィードバックが利用可能なときだけ一般的に有益な
最適化に従う。

@gccoptlist{-fbranch-probabilities  -fprofile-values 
-funroll-loops  -fpeel-loops  -ftracer  -fvpt 
-finline-functions  -fipa-cp  -fipa-cp-clone  -fipa-bit-cp 
-fpredictive-commoning  -fsplit-loops  -funswitch-loops 
-fgcse-after-reload  -ftree-loop-vectorize  -ftree-slp-vectorize 
-fvect-cost-model=dynamic  -ftree-loop-distribute-patterns 
-fprofile-reorder-functions}

このオプションを使うことができる前には、最初にプロファイル情報を生成しなければならない。
@option{-fprofile-generate}オプションについての情報は@xref{Optimize Options}

デフォルトでは、GCCはもしフィードバックプロファイルがソースコードと一致しない時はエラーメッセージを出す。
このエラーは@option{-Wcoverage-mismatch}を使うことで警告に変換できる。これは貧弱に最適化されたコードになるかもしれないことに注意。

もし@var{path}が指定されたなら、GCCは@var{path}をプロファイルフィードバックデータファイルを探すために見る。@option{-fprofile-dir}参照。

@item -fauto-profile
@itemx -fauto-profile=@var{path}
@opindex fauto-profile
サンプリングベースのフィードバックに指示された最適化を有効にし、プロファイルフィードバックが利用可能なときだけ一般的に有益な
最適化に従う。

@gccoptlist{-fbranch-probabilities  -fprofile-values 
-funroll-loops  -fpeel-loops  -ftracer  -fvpt 
-finline-functions  -fipa-cp  -fipa-cp-clone  -fipa-bit-cp 
-fpredictive-commoning  -fsplit-loops  -funswitch-loops 
-fgcse-after-reload  -ftree-loop-vectorize  -ftree-slp-vectorize 
-fvect-cost-model=dynamic  -ftree-loop-distribute-patterns 
-fprofile-correction}

@var{path}はAutoFDOプロファイル情報を含むファイルの名前である。省略された時は、
現在のディレクトの@file{fbdata.afdo}がデフォルトである。

AutoFDOプロファイルデータのプロファイリングにはサポートされたGNU/Linuxターゲットシステムでの
@command{perf}ユーティリティでプログラムを実行する必要がある。さらなる情報は@uref{https://perf.wiki.kernel.org/}を見よ。

例えば、
@smallexample
perf record -e br_inst_retired:near_taken -b -o perf.data \
    -- your_program
@end smallexample

それから@command{create_gcov}ツールを生プロファイルデータからGCCが使える書式へ変換するために使う。
このツールにプログラムのストリップされていないバイナリを提供する必要もある。
@uref{https://github.com/google/autofdo}参照。

例えば、
@smallexample
create_gcov --binary=your_program.unstripped --profile=perf.data \
    --gcov=profile.afdo
@end smallexample
@end table

以下のオプションは浮動小数点算術に関するコンパイラの振る舞いを制御する。これらのオプションは速度と正確さのトレードオフである。
すべては明示的に有効にしなければならない。

@table @gcctabopt
@item -ffloat-store
@opindex ffloat-store
浮動小数点変数をレジスタに格納せず、浮動小数点数値がレジスタとメモリのどちらから取ってくるかを変更するかもしれない他のオプションを抑制する。

@cindex floating-point precision
このオプションは68000のような（68881の）浮動小数点レジスタが@code{double}が持つよりも多くの精度を維持する機種で望まない
余計な精度を防ぐ。x86アーキテクチャも同様である。多くのプログラムで、余分な精度は単にいいことであるが、あるプログラムは
IEEE浮動小数点数の正確な定義に依存している。そのようなプログラムで@option{-ffloat-store}を使うことでそれらを修正した後に、
変数にすべての関係する中間の計算を保存する。

@item -fexcess-precision=@var{style}
@opindex fexcess-precision
このオプションは浮動小数点レジスタがIEEE @code{float}と@code{double}型より多くの精度を持ちプロセッサが
それらの型への丸め操作をサポートしない機種で余分な精度の更なる制御を可能にする。
デフォルトで、@option{-fexcess-precision=fast}が有効である。これは、操作がレジスタの精度で実行され、
ソースコードで指定されている型への丸めが起こるとき、それが予測できないことを意味する。
Cをコンパイルするとき、@option{-fexcess-precision=standard}が指定されるならば、
過剰な精度はISO C99で指定されている規則に追従する;
特に、キャストと代入は、値をそれらの意味論的な型（@option{-ffloat-store}が代入に影響を及ぼすだけであるのに対して）に丸められる。
@option{-std=c99}のような厳しい適合オプションが使われるならば、このオプションはCでデフォルトで使用可能である。@option{-ffast-math}は、厳密な適合オプションが使用されているかどうかに関係なく、デフォルトで@option{-fexcess-precision=fast}を有効にします。

@opindex mfpmath
@option{-fexcess-precision=standard}はC以外の言語では実装されておらず、@option{-funsafe-math-optimizations}か@option{-ffast-math}が
指定されていたら効果がない。x86では、@option{-mfpmath=sse}か@option{-mfpmath=sse+387}が指定されていた時も効果がない。
前者では余分な精度なしでIEEEの意味が適用され、後者では、丸めは予測不能である。

@item -ffast-math
@opindex ffast-math
オプション@option{-fno-math-errno}, @option{-funsafe-math-optimizations},
@option{-ffinite-math-only}, @option{-fno-rounding-math},
@option{-fno-signaling-nans}, @option{-fcx-limited-range},
@option{-fexcess-precision=fast}をセットする。

このオプションはプリプロセッサマクロ@code{__FAST_MATH__}を定義させる。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でもオンにならない。
しかし、それはそれらの仕様の保証を必要としないプログラムの実行を高速化するかもしれない。

@item -fno-math-errno
@opindex fno-math-errno
@opindex fmath-errno
@code{sqrt}のような単一命令で実行される数学関数を呼んだ後に@code{errno}をセットしない。
数学のエラーハンドリングのIEEE例外に依存したプログラムはIEEE算術互換性を維持する一方で速度のために
このフラグを使いたいかもしれない。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でのオンにならない。
しかし、それはそれらの仕様の保証を必要としないプログラムの実行を高速化するかもしれない。

デフォルトは@option{-fmath-errno}である。

Darwinシステムでは、数学関数は決して@code{errno}をセットしない。したがって、コンパイラが互換性を考える理由がないので
@option{-fno-math-errno}がデフォルトである。

@item -funsafe-math-optimizations
@opindex funsafe-math-optimizations

（A)引数と結果が正当であると仮定し、（B)IEEEやANSI標準に反するかもしれない浮動小数点算術の最適化を許可する。
リンク時に使われた時は、デフォルトのCPU制御後や他の同様の最適化を変えるかもしれないライブラリやスタートアップファイルを含むかもしれない。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でのオンにならない。
しかし、それはそれらの仕様の保証を必要としないプログラムの実行を高速化するかもしれない。
@option{-fno-signed-zeros}, @option{-fno-trapping-math}, @option{-fassociative-math}, @option{-freciprocal-math}を有効にする。

デフォルトは@option{-fno-unsafe-math-optimizations}である。

@item -fassociative-math
@opindex fassociative-math

一連の浮動小数点演算子のオペランドの再結合を許可する。これは計算結果を変える可能性があるので
ISO CやC++の言語標準に違反する。注意：並べ替えはゼロの符号を変えるかもしれず。NaNを無視したり、アンダーフローやオーバーフロー
を抑制したり作ったりするかもしれない（そして、@code{(x + 2**52) - 2**52}のような丸めの振る舞いに依存したコードでは使うことができない）
浮動小数点数比較を並べ替えるかもしれず、順序の比較が要求されるときは使うことができない。
このオプションは@option{-fno-signed-zeros}と@option{-fno-trapping-math}の両方が効果がある必要がある。
さらに、@option{-frounding-math}と一緒では意味を成さない。Fortranではオプションは
@option{-fno-signed-zeros}と@option{-fno-trapping-math}の両方が有効なときは自動的に有効になる。

デフォルトは@option{-fno-associative-math}である。

@item -freciprocal-math
@opindex freciprocal-math

この最適化が有効ならば値を割る代わりに値の逆数を使うことを許可する。例えば、@code{x / y}は@code{x * (1/y)}で置換され、
これは@code{(1/y)}が共通部分式除去の対象ならば役立つ。これは精度を失い、値の操作するフロップの数を増やすことに注意。

デフォルトは@option{-fno-reciprocal-math}である。

@item -ffinite-math-only
@opindex ffinite-math-only
引数と結果がNaNや+-Infでないと仮定する浮動小数点算術の最適化を許可する。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でのオンにならない。

デフォルトは@option{-fno-finite-math-only}である。

@item -fno-signed-zeros
@opindex fno-signed-zeros
@opindex fsigned-zeros
ゼロの符号を無視する浮動小数点算術の最適化を許可する。IEEE算術は+0.0と@minus{}0.0値を区別する振る舞いを指定していて、
x+0.0や0.0*xのような表現の単純化を(@option{-ffinite-math-only}であっても)禁じている。
このオプションは結果のゼロの符号が意味を持たないことを暗示する。

デフォルトは@option{-fsigned-zeros}である。

@item -fno-trapping-math
@opindex fno-trapping-math
@opindex ftrapping-math
コードを浮動小数点演算がユーザに可視のトラップを生成しないと仮定してコンパイルする。これらのトラップは、
ゼロによる除算、オーバーフロー、アンダーフロー、不正確の結果と不正な操作が含まれる。このオプションは
@option{-fno-signaling-nans}が有効なことが要求される。もし例えば、「非停止」IEEE算術に依存しているなら
このオプションをセットするとより速いコードを可能にするかもしれない。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
どんな@option{-O}でのオンにならないはずである。

デフォルトは @option{-ftrapping-math}である。

@item -frounding-math
@opindex frounding-math
デフォルトの浮動小数点丸への振る舞いを仮定した変換と最適化を無効にする。
これはすべての浮動小数点数から整数への０への丸めと、他のすべての算術切り詰めでの最近傍丸めである。
このオプションはFP丸めモードを動的に変更するか、非標準の丸めモードで実行されるかもしれないプログラムに指定すべきである。
このオプションはコンパイル時の（丸めモードによって影響されるかもしれない）浮動小数点数の定数展開と符号依存の丸めモード
の存在下で安全でない算術変換を無効にする。

デフォルトは@option{-fno-rounding-math}である。

このオプションは実験的で、現在は丸めモードに影響されるすべてのGCCは最適化を無効にすることは保証されない、
GCCの将来のバージョンはC99の@code{FENV_ACCESS}プラグマを使うことでこの設定のもっと細かい制御を提供するかもしれない。
このコマンドラインオプションは@code{FENV_ACCESS}のデフォルトの状態を指定するのに使われるだろう。

@item -fsignaling-nans
@opindex fsignaling-nans
IEEEシグナルNaNがユーザ可視のトラップを浮動小数点操作の間に生成するかもしれないと仮定してコードをコンパイルする。
このオプションをセットするとシグナルNaNで可視の例外の数を変えるかもしれない最適化を無効にする。
このオプションは@option{-ftrapping-math}を含んでいる。

このオプションはプリプロセッサマクロ@code{__SUPPORT_SNAN__}を定義させる。

デフォルトは@option{-fno-signaling-nans}である。

このオプションは実験的で現在はすべてのシグナルNaNの振る舞いに影響するGCCの最適化を無効にすることは保証されない。

@item -fno-fp-int-builtin-inexact
@opindex fno-fp-int-builtin-inexact
@opindex ffp-int-builtin-inexact
組み込み関数@code{ceil}、@code{floor}、@code{round}と@code{trunc}、およびそれらの@code{float}および@code{long double}変種に非整数引数で「不正確」浮動小数点例外を発生させることを許可しない。ISO C99とC11は、これらの関数が「不正確」例外を発生させることを許しているが、IEEE 754-2008へのCバインディングであるISO/IEC TS 18661-1:2014では、そうすることは許可していない。

デフォルトは@option{-ffp-int-builtin-inexact}で、例外を発生させる。 このオプションは、@option{-ftrapping-math}が有効でない限りは何も行わない。

@option{-fno-fp-int-builtin-inexact}が使用されていても、関数がライブラリ関数の呼び出しを生成した場合、ライブラリ実装がTS 18661に従わない場合、「不正確」例外が発生する可能性がある。

@item -fsingle-precision-constant
@opindex fsingle-precision-constant
浮動小数点定数を暗黙に倍精度定数に変換する代わりに単精度として扱う。

@item -fcx-limited-range
@opindex fcx-limited-range
有効にした時、このオプションは複素数除算を行うときに範囲縮小ステップが必要ないと述べる。
さらに、複素数乗算や除算の結果が@code{NaN + I*NaN}であるかをチェックせず、その場合の状況を救う必要がないとする。
デフォルトは@option{-fno-cx-limited-range}であるが、@option{-ffast-math}で有効にされる。

このオプションはISO C99での@code{CX_LIMITED_RANGE}プラグマのデフォルト設を制御する。しかし、
このオプションはすべての言語に適用される。

@item -fcx-fortran-rules
@opindex fcx-fortran-rules
複素数乗算と除算でFortran規則に従う。範囲縮小は複素数除算の一部として行われるが、
複素数乗算や除算の結果が@code{NaN + I*NaN}であるかをチェックせず、その場合の状況を救う必要がないとする。

デフォルトは@option{-fno-cx-fortran-rules}である。

@end table

以下のオプションをパフォーマンスを向上させるかもしれない最適化を制御するが、どんな@option{-O}オプションでも有効にならない。
この節は壊れたコードを生成するかもしれない実験的なオプションを含む。

@table @gcctabopt
@item -fbranch-probabilities
@opindex fbranch-probabilities
@option{-fprofile-arcs}でコンパイルしたプログラムを走らせた後(@pxref{Instrumentation Options})、
それぞれの分岐回数に基づいた最適化を向上させるために、@option{-fbranch-probabilities}を使って
2回めのコンパイルをすることができる。@option{-fprofile-arcs}でコンパイルされたプログラムが終了するときに、
それぞれのソースファイルで@file{@var{sourcename}.gcda}と呼ばれるアーク実行カウントを保存する。
このデータの情報は生成されたコードの構造にとても依存するので、両方のコンパイルで同じソースコードと
同じ最適化オプションを使わなくてはならない。

@option{-fbranch-probabilities}で、GCCはそれぞれの
@samp{JUMP_INSN}と@samp{CALL_INSN}で@/ @samp{REG_BR_PROB}注釈を置く。
これらは最適化を向上させるために使うことができる。現在、それらは1箇所のみで使われる。@file{reorg.c}で、分岐がどのくらい取られるかを
推測する代わりに、@samp{REG_BR_PROB}がパスがどのくらいの頻度でとられるかを正確に決定するのに使われる。

@option{-fprofile-use}と@option{-fauto-profile}で有効になる。

@item -fprofile-values
@opindex fprofile-values
@option{-fprofile-arcs}と組み合わせれば、それはプログラム内で式の値についてのデータが収集されるようにコードを追加する。

@option{-fbranch-probabilities}で、それは最適化での使用のための表現の値のプライファイリングから収集されたデータを読み戻す。

@option{-fprofile-generate}と @option{-fprofile-use}、@option{-fauto-profile}で有効になる。

@item -fprofile-reorder-functions
@opindex fprofile-reorder-functions
プロファイル計装に基づいた関数並べ替えが関数の実行の最初の時間を収集して、それらの関数を昇順で並べる。

@option{-fprofile-use}で有効である。

@item -fvpt
@opindex fvpt
@option{-fprofile-arcs}と組み合わせると、このオプションはコンパイラに式の値についての情報を収集するコードを追加するように支持する。

@option{-fbranch-probabilities}で、収集したデータを読み戻して実際にそれらに基づいた最適化を行う。現在最適化は除数の値についてを知識
を使った除算命令の特殊化を含む。

@option{-fprofile-use}と@option{-fauto-profile}で有効になる。

@item -frename-registers
@opindex frename-registers
レジスタ割当後に残されたレジスタを使うことによってスケジュールされたコードでの偽の依存性を避けようとする。
この最適化は多数のレジスタを持つプロセッサで最も利点がある。しかし、変数が「ホームレジスタ」にもはやとどまらないので、
ターゲットによって採用されるデバッグ情報フォーマットに依存して、デバッギングを不可能にしうる。

@option{-funroll-loops}でデフォルトで有効である。

@item -fschedule-fusion
@opindex fschedule-fusion
それらが命令フローで互いに隣接してあるならばターゲット機種がより効率的にそれらを実行することができるので、
一緒に同じ型のスケジュール命令への命令ストリームについてのターゲット依存的なパスを実行する。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -ftracer
@opindex ftracer
スーパーブロックサイズを大きくするために末端複写を行う。この変換は関数の制御フローを単純化して
他の最適化がもっといい仕事ができるようにする。

@option{-fprofile-use}と@option{-fauto-profile}で有効になる。

@item -funroll-loops
@opindex funroll-loops
繰り返し数がコンパイル時かループの入り口までに決定できるループを展開する。
@option{-funroll-loops}は@option{-frerun-cse-after-loop}, @option{-fweb}, @option{-frename-registers}を含む。
これは完全ループ引き剥がし（すなわち、小さい定数回の繰り返しのループを完全に除去する）もオンにする。
これはコードを大きくし、実行を速くするかもしれないししないかもしれない。

@option{-fprofile-use}と@option{-fauto-profile}で有効になる。

@item -funroll-all-loops
@opindex funroll-all-loops
すべてのループを、たとえループ開始時に繰り返し数が不確定でも展開する。これは通常プログラムの実行を遅くする。
@option{-funroll-all-loops}は@option{-funroll-loops}と同じオプションを含む。

@item -fpeel-loops
@opindex fpeel-loops
（プロファイル・フィードバックから）情報が十分にあるあまり巻かれないループを引き剥がす。
これは完全ループ引き剥がし（すなわち、小さい定数回の繰り返しのループを完全に除去する）もオンにする。

@option{-O3}, @option{-fprofile-use}, @option{-fauto-profile}で有効になる。

@item -fmove-loop-invariants
@opindex fmove-loop-invariants
RTLループ最適化器でループ不変移動パスを有効にする。@option{-Og}以外のレベル@option{-O1}以上で有効になる。

@item -fsplit-loops
@opindex fsplit-loops
反復空間の一方の側で常に真であり、他方で偽である条件を含む場合、ループを2つに分割する。

@option{-fprofile-use}, @option{-fauto-profile}で有効になる。

@item -funswitch-loops
@opindex funswitch-loops
ループ不変条件の分岐を、両方の分岐でループの重複させて、ループの外へ移動する。（条件の結果に応じて修正する）

@option{-fprofile-use}, @option{-fauto-profile}で有効になる。

@item -fversion-loops-for-strides
@opindex fversion-loops-for-strides
ループが可変ストライドを使用して配列を反復処理する場合、ストライドが常に1であると想定する別のバージョンのループを作成します。 例えば：

@smallexample
for (int i = 0; i < n; ++i)
  x[i * stride] = @dots{};
@end smallexample

becomes:

@smallexample
if (stride == 1)
  for (int i = 0; i < n; ++i)
    x[i] = @dots{};
else
  for (int i = 0; i < n; ++i)
    x[i * stride] = @dots{};
@end smallexample

これは、Fortranで想定される形状の配列の場合に特に便利です。Fortranでは、連続アクセスを想定したベクトル化が改善されます。このフラグは、@option{-O3}でデフォルトで有効になっています。
@option{-fprofile-use}, @option{-fauto-profile}でも有効になる。

@item -ffunction-sections
@itemx -fdata-sections
@opindex ffunction-sections
@opindex fdata-sections
もしターゲットが任意のセクションをサポートしていたらそれぞれの関数やデータアイテムを出力ファイルの自身のセクションに置く。
関数やデータアイテムの名前は出力ファイルのセクションの名前を決定する。

リンカが最適化を実行して命令空間内の参照の局所性を改善できるシステムでは、これらのオプションを使用する。 ELFオブジェクト形式を使用するほとんどのシステムは、そのような最適化を備えたリンカを持っている。 AIXでは、リンカーはコールグラフに基づいてセクション（CSECT）を再配置する。 パフォーマンスへの影響はさまざまである。
 
リンカのガベージコレクション（リンカの@option{-gc-sections}オプション）と一緒に使うと、これらのオプションは静的にリンクされた実行可能ファイル（ストリッピング後）を小さくするかもしれない。
 
ELF/DWARFシステムでは、これらのオプションはデバッグ情報の品質を劣化させない。 他のオブジェクトファイル/デバッグ情報フォーマットでは問題がある可能性がある。

これらのオプションは、大きな利点がある場合にのみ使用すること。 これらのオプションを指定すると、アセンブラとリンカはより大きなオブジェクトファイルと実行可能ファイルを作成し、処理速度も低下する。 これらのオプションはコード生成に影響する。 それらはリンク時間まで未知であるため、翻訳ユニット内の相対位置を使用するコンパイラおよびアセンブラによる最適化を妨げる。このような最適化の一例は、ショートコール命令へのコールを緩和することである。

@item -fstdarg-opt
@opindex fstdarg-opt
可変数引数の使用法に関して、その関数のプロローグを最適化する。

@item -fsection-anchors
@opindex fsection-anchors
近くのオブジェクトを指す共有「アンカー」シンボルを使うことでシンボルアドレス計算の数を削減しようとする。
この変換はGTO項目の数とあるターゲットでのGTO項目アクセスを削減するのを助ける。

例えば、以下の関数@code{foo}の実装で

@smallexample
static int a, b, c;
int foo (void) @{ return a + b + c; @}
@end smallexample

@noindent
は通常すべての三つの変数のアドレスを計算するが、もし@option{-fsection-anchors}でコンパイルしたら、
代わりに共通アンカーポイントから変数にアクセスする。効果は以下の（正当なCではない）擬似コードと同様である。

@smallexample
int foo (void)
@{
  register int *xr = &x;
  return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
@}
@end smallexample

すべてのターゲットがこのオプションをサポートしているわけではない。

@item -fzero-call-used-regs=@var{choice}
@opindex fzero-call-used-regs
Return-Oriented Programming（ROP）攻撃を軽減するか、レジスタを介した情報漏えいを防ぐことにより、プログラムのセキュリティを強化するために、関数リターンで呼び出しに使用されるレジスタをゼロにします。

@var{choice}の可能な値は、@code{zero_call_used_regs}属性（@pxref{Function Attributes}）の場合と同じです。デフォルトは@samp{skip}です。

関数属性@code{zero_call_used_regs}（@pxref{Function Attributes}）を使用して、特定の関数のこの動作を制御できます。

@item --param @var{name}=@var{value}
@opindex param
ある場所で、GCCはは行われる最適化の量を制御する様々な定数を使う。例えば、
GCCは命令がある数より大きい関数はインライン化しない。コマンドラインで
@option{--param}オプションを使うことでこれらの定数のいくつかを制御することができる。

指定されたパラメータの名前、値の意味はコンパイラの内部と結びついていて、
将来のリリースで注意なしに変わる対象である。

パラメータの最小値、最大値、およびデフォルト値を取得するには、
@option{-help=param -Q}オプションを使用できます。

どの場合にも、@var{value}は整数である。@var{name}の可能な選択肢は以下である。

@table @gcctabopt
@item predictable-branch-outcome
分岐がこの（%での）閾値よりも小さい確率で予測されるならば、よく予測可能だとみなされる。

@item max-rtl-if-conversion-insns
RTLのif変換がブロック周りの条件付き分岐を削除して条件付き実行命令で置換しようとする。
このパラメータはif変換で考慮されるべきブロックの最大命令数を与える。コンパイラは、他のヒューリスティックを使用して、if変換が有益かどうかを判断します。

@item max-rtl-if-conversion-predictable-cost
@itemx max-rtl-if-conversion-unpredictable-cost
RTL if-conversionは、ブロックの周りの条件分岐を削除し、それらを条件付きで実行された命令に置き換えようとする。 これらのパラメータは、ブランチが予測可能であると静的に決定されているかどうかに応じて、if変換によって生成されるシーケンスの許容最大コストを示す。 このパラメータの単位は、GCCの内部seq_costメトリックの単位と同じである。 コンパイラは、BRANCH_COSTターゲットマクロを使用して、このパラメータに合理的なデフォルトを提供しようとする。

@item max-crossjump-edges
クロス・ジャンプのために考慮する入って来るエッジの最大数。@option{-fcrossjumping}により用いられるアルゴリズムは、
各々のブロックへのエッジ入力の数の@math{O(N^2)}である。値の増加はより積極的な最適化を意味する。そして、
コンパイル時間を増加させ、おそらく実行サイズで少し向上させる。

@item min-crossjump-insns
クロスジャンプが行われる前に２つのブロックの終わりに一致しなければならない命令の最小数。
この値はそこからクロスジャンプされるブロックの全命令が一致した場合には無視される。

@item max-grow-copy-bb-insns
ジャンプの代わりに基本ブロックがコピーされるときに最大コードサイズ拡張係数。
拡張はジャンプ命令との比率である。

@item max-goto-duplication-insns
計算gotoへジャンプするブロックへの重複する命令の最大値。
いくつかのパスにおいて@math{O(N^2)}ふるまいを避けるために、
GCCはできるだけ遅く、早く計算されたgotoをコンパイル・プロセスを分解し、それらをできるだけ遅くに結合する。
max-goto-duplication-命令を超えない基本ブロックの末端での計算ジャンプのみが結合される。

@item max-delay-slot-insn-search
遅延スロットを満たす命令を探すときに考慮される命令の最大数。もしこの任意の命令数よりも多くが見つかったならば、
遅延スロットを埋める時間を節約し、検索を止める。値を増やすともっと積極的な最適化を意味し、コンパイル時間を増やして
おそらく実行時間に小さな向上をするだろう。

@item max-delay-slot-live-search
遅延スロットを埋めるときに、正当な生存レジスタ情報のあるブロックを検索するときに考慮される命令の最大数。
この任意の選ばれた値を増やすともっと積極的な最適化を意味し、コンパイル時間を増やすだろう。
このパラメータは制御フローグラフを維持するために遅延スロットコードが書き直された時には削除されるべきである。

@item max-gcse-memory
大域共通部分式除去最適化を行うために割り当てられるおおよその最大メモリ量。もし指定されたよりも多くのメモリが必要ならば、
最適化は行われない。

@item max-gcse-insertion-ratio
もし削除に対する式挿入比が任意の式でこの値よりも大きいならば、RTL PREは式の挿入や削除を行い、
命令ストリームでの部分冗長計算を残す。

@item max-pending-list-length
現在の状態をフラッシュして完全に始める前に許可する保留依存スケジューリングの最大値。
少ない分岐や関数呼び出しの大きな関数は不必要にメモリや資源を消費する非常に大きなリストを作るかもしれない。

@item max-modulo-backtrack-attempts
スケジューラがループ中でモジュロスケジューリングをするときに作るべきバックトラックの試みの最大数。
大きな値はコンパイル時間を非常に増やしうる。

@item max-inline-insns-single
GCCで使われるツリーインライン化器を制御する幾つかのパラメータ。
この数はツリーインライン化器がインライン化を考慮する単一関数での（GCCの内部表現で数えられた）
命令の最大数をセットする。これはinlineと宣言された関数とクラス宣言(C++)で実装されたメソッドのみに影響する。

@item max-inline-insns-auto
@option{-finline-funcions}(@option{-O3}に含まれる)を使った時、
さもなければコンパイラによってインラインの考慮をされない多数の関数が調査される。これらの関数には、インラインで宣言された関数とは異なる（より制限的な）制限を適用できます（@option{-param max-inline-insns-auto}）。

@item max-inline-insns-small
これは、@option{-finline-small-functions}に関連すると見なされる呼び出しに適用されます。

@item max-inline-insns-size
これは、サイズが最適化された呼び出しに適用される範囲です。 インライン化によって露出される最適化の機会を予測するために、わずかな成長が望ましい場合があります。

@item uninlined-function-insns
関数のプロローグやエピローグなどの関数のオーバーヘッドについて、インライン化によって処理される命令の数。

@item uninlined-function-time
関数のプロローグやエピローグの実行に必要な時間など、関数のオーバーヘッドのためにインライナーが考慮する余分な時間

@item inline-heuristics-hint-percent
インラインヒューリスティックがインライン化が非常に有益である（後で最適化を有効にする）ことを示唆する場合に@option{inline-insns-single}、@option{inline-insns-single-O2}、@option{inline-insns-auto}に適用されるスケール（パーセント） 。

@item uninlined-thunk-insns
@item uninlined-thunk-time
@option{-param uninlined-function-insns}および@option{-param uninlined-function-time}と同じですが、関数サンクに適用されます

@item inline-min-speedup
呼び出し元・呼び出し先の推測されたパフォーマンスの向上がこの（パーセントでの）閾値を超えると、
@option{--param max-inline-insns-single}と@option{--param max-inline-insns-auto}の制限にもかかわらず
インライン化されうる。

@item large-function-insns
ほんとうに大きい関数を指定する制限。インライン化の後でこの制限よりも大きい関数では、インライン化は
@option{--param large-function-growth}によって抑制される。このパラメータはバックエンドによって使われる
非線形アルゴリズムによる極端なコンパイル時間を避けるために主に役立つ。

@item large-function-growth
インライン化による大きな関数の最大成長率をパーセントで指定します。
たとえば、パラメータ値100は、大きな関数の成長を元のサイズの2.0倍に制限します。

@item large-unit-insns
大きな翻訳単位を指定する制限。この制限より大きい単位のインライン化によって引き起こされる成長は
@option{--param inline-unit-growth}によって制限される。小さい単位ではこれは厳しすぎるかもしれない。
例えば、インライン化されるA関数とAを3回呼ぶだけのBを考える。もしBがAがに比べて小さいならば、
成長率は300\%だがそれでもそのようなインライン化はとてもまともである。しかし、小さいインライン化可能な関数を含むとても大きな単位では、
全体の成長率制限はコードサイズの指数的拡大を避けるために必要である。したがって、もっと小さい単位では、
サイズは@option{--param inline-unit-growth}が適用される前に@option{--param large-unit-insns}へと増やされる。

@item lazy-modules
遅延読み込み時に同時に開くC++モジュールファイルの最大数。

@item inline-unit-growth
インライン化によって起こされるコンパイル単位の全体の最大成長率を指定する。
デフォルトは20で元のサイズ1.2倍に制限される。冷たい関数（属性によってか
プロファイル・フィードバックによって）は単位サイズに入らない。

@item ipcp-cp-unit-growth
プロシージャー間の定数伝搬によって引き起こされるコンパイル単位の全体的な最大成長を指定します。 たとえば、パラメータ値10は、ユニットの成長を元のサイズの1.1倍に制限します。

@item ipa-cp-large-unit-insns
IPA-CPパスが大きいと見なす変換単位のサイズ。

@item large-stack-frame
大きなスタックフレームを指定する制限。インライン化の間にアルゴリズムはこの制限をあまり超えて成長しないようにしようとする。

@item large-stack-frame-growth
インライン化で起こされる大きなスタックフレームの最大成長率をパーセントで指定する。
たとえば、パラメータ値1000は、大きなスタックフレームの成長を元のサイズの11倍に制限します。

@item max-inline-insns-recursive
@itemx max-inline-insns-recursive-auto
再帰インライン化をすることによって自己再帰インライン関数の線からはみ出たコピーが成長する命令の最大数を指定する。

@option{--param max-inline-insns-recursive}はインラインと宣言された関数に適用される。インラインと宣言されていない関数では、
再帰インライン化は@option{-finline-functions} (@option{-O3}に含まれる)が有効の時だけ起こる。
代わりに@option{--param max-inline-insns-recursive-auto}が適用される。

@item max-inline-recursive-depth
@itemx max-inline-recursive-depth-auto
再帰インライン化で使われる最大再帰深さを指定する。

@option{--param max-inline-recursive-depth}はインラインと宣言された関数に適用される。インラインと宣言されていない関数では、
再帰インライン化は@option{-finline-functions} (@option{-O3}に含まれる)が有効の時だけ起こる。
代わりに@option{--param max-inline-recursive-depth-auto}が適用される。

@item min-inline-recursive-probability
再帰インライン化は平均で深い再帰を持つ関数にだけ有益であまり再帰が深くない関数には
プロローグサイズや関数本体の複雑性の増加によって他の最適化器を傷つけうる。

プロファイル・フィードバックが利用可能(@option{-fprofile-generate}参照)な時、
実際の再帰深さは与えられた関数式経由で関数が再帰する確率から推測できる。
パラメータはその確率が与えられた（パーセントでの）しきい値を超えた呼び出し式のみをインライン化するように制限する。

@item early-inlining-insns
初期インライン化が作る成長率を指定する。実際には大きな抽象化ペナルティを持つコードのインライン化の量を増加させる。

@item max-early-inliner-iterations
初期インライン化の繰り返し数を制限する。これは基本的には初期インライン化は解決できる入れ子の間接呼び出しの数を制限する。
深い連鎖はまだ後のインライン化で扱われる。

@item comdat-sharing-probability
combat可視性のあるC++のインライン関数が複数のコンパイル単位をまたいで共有される（パーセントでの）確率。

@item modref-max-bases
@item modref-max-refs
@item modref-max-accesses
mod/ref分析によって、単一の関数に格納されるベースポインター、参照、およびアクセスの最大数を指定します。

@item modref-max-tests
mod/ref情報を使用してメモリ位置を明確にするためにエイリアスoracleが実行できるテストの最大数を指定します。 このパラメーターは、@option{-parammodref-max-bases}および@option{-parammodref-max-refs}よりも大きくする必要があります。

@item modref-max-depth
modrefエスケープ分析で使用されるDFSウォークの最大深度を指定します。 0に設定すると、分析が完全に無効になります。

@item modref-max-escape-points
SSA名ごとにmodrefによって追跡されるエスケープポイントの最大数を指定します。

@item profile-func-internal-id
プロファイルデータベース検索での関数内部IDを使うかどうかを制御するパラメータ。もし値が0ならば、コンパイラは
関数でアセンブラ名とファイル名に基づいたIDを使い、古いプロファイルデータを関数並べ替えなどのソースの変更にもっと
耐えられるようにする。

@item min-vect-loop-bound
@option{-ftree-vectorize}が使われた時にループがベクトル化されない最小の繰り返し数。
ベクトル化を可能にするためにはベクトル化後の繰り返し数がこのオプションによって指定された値よりも大きい必要がある。

@item gcse-cost-distance-ratio
GCSE最適化によって移動させる表現の最大距離の計算での拡大率。これは現在コード持ち上げ過程でのみサポートされていrう。
比率を大きくするほど、もっと積極的なコード持ち上げが単純な式によって、すなわち、コストが
@option{gcse-unrestricted-cost}未満である式によって行われる。0を指定すると単純な式の持ち上げを無効にする。

@item gcse-unrestricted-cost
大雑把に単一の典型的な機械語のコストによって測られる、GCSE最適化が式が移動できる距離を拘束しないコストである。
これは現在コード持ち上げ過程でのみサポートされている。コストを小さくすると、より積極的なコード持ち上げをなる。
0を指定するとすべての式が未制限の距離を移動できるようになる。

@item max-hoist-depth
ドミネーター・ツリーで式を持ち上げる時の検索の深さ。これは持ち上げアルゴリズムで二次の振る舞いを避けるのに使われる。
0の値は、検索に対する制限をせず、巨大な関数のコンパイルを遅くするかもしれない。

@item max-tail-merge-comparisons
bbと比較する類似のbbの最大量。これは木末端マージの二次の振る舞いを避けるために使われる。

@item max-tail-merge-iterations
関数を超えた経路の繰り返しの最大値。これは木末端マージでのコンパイル時間を制限するために使われる。

@item store-merging-allow-unaligned
ストアのマージパスで、アライメントの合わないストアを導入することが合法的である場合は、許可する。 

@item max-stores-to-merge
ストアのマージパスでより広いストアにマージしようとするストアの最大数。 

@item max-unrolled-insns
ループは展開されなければならないかもしれない命令の最大値。もしループが展開されたなら、このパラメータは
ループコードが何回展開されるかも決定する。

@item max-average-unrolled-insns
ループが展開されなければならない実行の確率によって重み付けされた命令の最大値。
もしループが展開させるなら、このパラメータは何回ループが展開されるかも決定する。

@item max-unroll-times
単一のループの展開の最大値。

@item max-peeled-insns
ループが引き剥がされるかもしれない命令の最大値。もしループが剥がされるならば、
このパラメータは何回ループコードが剥がされるかも決定する。

@item max-peel-times
単一ループの引き剥がしの最大値。

@item max-peel-branches
引き剥がされた列を通したホットな経路の分岐の最大値。

@item max-completely-peeled-insns
完全に引き剥がされたループの命令の最大値。

@item max-completely-peel-times
完全引き剥がしに適したループの繰り返し数の最大値。

@item max-completely-peel-loop-nest-depth
完全引き剥がしに適した入れ子ループの最大深さ。

@item max-unswitch-insns
非分岐されたループの命令の最大値。

@item max-unswitch-level
単一ループでの非分岐された分岐の最大値。

@item lim-expensive
ループ不変移動での高価な式の最小コスト。

@item iv-consider-all-candidates-bound
すべての候補が誘導変数最適化で使用ごとに考慮される、誘導変数の候補の数の範囲。
もしこれよりも候補が多いならば、二次の時間複雑性を避けるために最も重要なものだけが考慮される。

@item iv-max-considered-uses
誘導変数が使う以上を含むループで誘導変数最適化を諦める。

@item iv-always-prune-cand-set-bound
もし集合での候補の数がこの値よりも小さいならばいつも新規を追加するときに集合から不必要な誘導変数を
取り除こうとする。

@item avg-loop-niter
ループの平均反復回数。

@item dse-max-object-size
デッド・ストア除去によって追従されるオブジェクトの最大サイズ（バイト単位）。
値を大きくするとコンパイル時間が長くなる可能性がある。

@item dse-max-alias-queries-per-store
ストアごとのエイリアスoracleへのクエリの最大数。
値を大きくするとコンパイル時間が長くなり、デッドストアがより多く削除される場合があります。

@item scev-max-expr-size
スカラー変化解析で使われる式のサイズの境界。大きな式は解析器を遅くする。

@item scev-max-expr-complexity
スカラー変化解析器での式の複雑性の境界。複雑な式は解析器を遅くする。

@item max-tree-if-conversion-phi-args
ループがsimdプラグマでマークされていない場合、TREEによってサポートされているPHIの引数の最大数。

@item vect-max-version-for-alignment-checks
ベクトル化でのアラインメントのループバージョン化をしている時に行われる実行時チェックの最大数。

@item vect-max-version-for-alias-checks
ベクトル化で別名のループバージョン化をしている時に行われる実行時チェックの最大数。

@item vect-max-peeling-for-alignment
ベクトル化でアクセスアラインメントを強化するためのループ剥がしの最大値。値-1は制限なしを意味する。

@item max-iterations-to-track
評価しようとするループの繰り返し数の解析のためのループの虱潰しアルゴリズムの最大繰り返し数。

@item hot-bb-count-fraction
プログラム全体における基本ブロックの最大実行カウントの分数1/nの分母nは、基本ブロックがホットと見なされるために少なくとも必要です。 デフォルトは10000です。これは、実行カウントが最大実行カウントの1/10000より大きい場合、基本ブロックがホットであると見なされることを意味します。 0は、決してホットとは見なされないことを意味します。 非LTOモードで使用されます。

@item hot-bb-count-ws-permille
ホットと見なされるために基本ブロックの実行カウントが含まれている必要があるプログラム全体のプロファイルされた実行の、0〜1000の範囲で最も実行されたパーミルの数。 デフォルトは990です。これは、基本ブロックの実行カウントがプログラム全体のプロファイルされた実行の上位990パーミル、つまり99.0%に寄与する場合、基本ブロックがホットであると見なされることを意味します。 0は、決してホットとは見なされないことを意味します。 LTOモードで使用されます。

@item hot-bb-frequency-fraction
この関数の基本ブロックがホットと見なされるために少なくとも必要な、関数のエントリブロックの実行頻度の分数1/nの分母n。 デフォルトは1000です。これは、基本ブロックが関数のエントリブロックの頻度の1/1000よりも頻繁に実行される場合、その基本ブロックが関数内でホットであると見なされることを意味します。 0は、決してホットとは見なされないことを意味します。

@item unlikely-bb-count-fraction
プログラム全体のプロファイルされた実行数の分数1/nの分母n。これを下回ると、基本ブロックが実行される可能性が低いと見なされるために、基本ブロックの実行カウントが必要になります。 デフォルトは20です。これは、基本ブロックがプログラムの実行の1/20、つまり5%未満で実行された場合、実行される可能性が低いと見なされることを意味します。 0は、常に実行される可能性が低いと見なされることを意味します。

@item max-predicted-iterations
静的に予測するループ繰り返し数の最大値。これは関数が既知の境界を持つ単一ループと未知の境界を持つ別のループを含んでいる場合に
役立つ。既知の繰り返し回数は正確に予測されるが、未知の繰り返し回数は大雑把に平均10と予測される。これは
境界のないループは他のものに比べて人工的に冷たいことを意味する。

@item builtin-expect-probability
指定された値を持つ式の確率を制御する。このパラメータは入力でパーセント（0から100）を取る。
90のデフォルト確率は経験的に得られている。

@item builtin-string-cmp-inline-length
インライン化に適格な組み込みストリングcmp呼び出しの定数ストリングの最大長。

@item align-threshold
基本ブロックをアラインメントするために関数内の基本ブロックの実行の最大頻度の割合を選択する。

@item align-loop-iterations
ループが少なくとも選択された繰り返し数がアラインメントされていると予期されるだけ繰り返す。

@item tracer-dynamic-coverage
@itemx tracer-dynamic-coverage-feedback

一旦実行された命令の与えられたパーセンテージがカバーされるならば、
この値はスーパーブロック構造を制限するのに用いられる。これは不必要なコードサイズ拡張を制限する。

@option{tracer-dynamic-coverage-feedback}パラメータはプロファイル・フィードバックが利用可能なときだけ使われる。
（静的に推測されたものに対して、）本当のプロファイルはずっと非均等的で、大きな値へのしきい値を可能にする。

@item tracer-max-code-growth
一旦末端重複化コード成長が与えられたパーセンテージに達したらならば止める。これは、重複の大抵が後でクロスジャンプで除去されるので、
むしろ人工的な制限であり、望まれたコード成長よりもずっと高い値にセットされるかもしれない。

@item tracer-min-branch-ratio
最良エッジの逆確率が（パーセントで）この境界を下回ったた時に逆成長を止める。

@item tracer-min-branch-probability
@itemx tracer-min-branch-probability-feedback

もし最良エッジがこの境界を下回る確率を持つならば前方成長を止める。

@option{tracer-dynamic-coverage}と同様に2つのパラメータが提供される。
@option{tracer-min-branch-probability-feedback}がプロファイルフィードバックありでコンパイルした時に使われ、
@option{tracer-min-branch-probability}がなしの時にコンパイルした時に使われる。
プロファイルフィードバックありでのコンパイルｄの値はトレーサーを効果的にするためにはより保守的（高く）する必要がある。

@item stack-clash-protection-guard-size
オペレーティングシステムが提供するスタックガードのサイズを、2の@var{num}乗バイトで指定します。 値を大きくすると、明示的なプローブの数を減らすことができますが、ガードが提供するオペレーティングシステムよりも大きい値を設定すると、コードがスタッククラッシュスタイル攻撃に対して脆弱になります。

@item stack-clash-protection-probe-interval
スタッククラッシュ保護には、割り当てられたスタックスペースの調査が含まれます。 このパラメーターは、2の@var{num}乗バイトで、スタックへのプローブ間の最大距離を制御します。 値を大きくすると、明示的なプローブの数を減らすことができますが、ガードが提供するオペレーティングシステムよりも大きい値を設定すると、コードがスタッククラッシュスタイル攻撃に対して脆弱になります。

@item max-cse-path-length
CSEが考える経路での基本ブロックの最大値。

@item max-cse-insns
フラッシュの前のCSEが持つ最大命令数。

@item ggc-min-expand

GCCは自身のメモリ割り当てを管理するためにガベージコレクションを使う。
このパラメータははガベージコレクタのヒープが収集の間に拡張を許す最小のパーセンテージを指定する。
これを調整するとコンパイル速度を向上させるかもしれないが、コード生成には影響がない。

デフォルトは30% + 70% * (RAM/1GB)でRAM >= 1GBの時は上限100%である。もし@code{getrlimit}が利用可能なときは、
「RAM」の表記は実際のRAMと@code{RLIMIT_DATA}と@code{RLIMIT_AS}の最小値である。
もし特定のプラットフォームでRAMが計算出来ない時は、下界の30%が使われる。
このパラメータと@option{ggc-min-heapsize}をゼロにセットすると全機会で完全収集を引き起こす。
これはとても遅いが、デバッグには役立つ。

@item ggc-min-heapsize

ゴミを収集することを気にし始める前のガベージコレクタの最小サイズ。
最初の収集は@option{ggc-min-heapsize}を@option{ggc-min-expand}%超えてヒープが拡張した後に起こる。
再び、これを調整するとコンパイル速度を向上させるかもしれないが、コード生成には影響がない。

デフォルトはRAM/8、RLIMIT_TSS、RLIMIT_DATAかRLIMIT_ASが拡張しないことを保証しようとする限界の最小
であるが、下界は4096(４メガバイト）で上界は131072(１２８メガバイト）である。もしGCCは特定のプラットフォームで
RAMを計算出来ない時は、下界が使われる。このパラメータをとても大きくすると事実上ガベージコレクションを無効にする。
このパラメータと@option{ggc-min-expand}をゼロにすると全機会で完全収集を引き起こす。

@item max-reload-search-insns
等価レジスタを後方検索する命令リロードの最大数。値を増やすともっと積極的な最適化を意味し、
コンパイル時間を増加させておそらく少しパフォーマンスを向上させる。

@item max-cselib-memory-locations
cselibが考慮するメモリ場所の最大値。値を増やすともっと積極的な最適化を意味し、
コンパイル時間を増加させておそらく少しパフォーマンスを向上させる。

@item max-sched-ready-insns
第1スケジュールパスの間に与えられた時間でスケジューラで考慮される発せる準備ができた命令の最大値。
値を増やすもっと徹底的な検索をすることを意味し、コンパイル時間を増加させておそらく小さな利点がある。

@item max-sched-region-blocks
ブロック間スケジューリングで考慮される領域のブロックの最大数。

@item max-pipeline-region-blocks
選択的スケジューラでパイプライン化で考慮される領域のブロックの最大数。

@item max-sched-region-insns
ブロック間スケジューリングで考慮される領域の命令の最大数。

@item max-pipeline-region-insns
選択的スケジューラでのパイプライン化で考慮される領域の命令の最大数。

@item min-spec-prob
ブロック間推測スケジューリング用のソースブロック到達の（パーセントでの）最小確率。

@item max-sched-extend-regions-iters
CFGを通しての拡張領域への繰り返しの最大数。値0（デフォルト）は領域拡張を無効にする。

@item max-sched-insn-conflict-delay
推測移動で考慮される命令の最大衝突遅延。

@item sched-spec-prob-cutoff
推測成功で、推測命令がスケジューリングされる（パーセントでの）最小確率。

@item sched-state-edge-prob-cutoff
スケジューラがエッジ全体でその段階を保存するためになければならない最小限の確率。

@item sched-mem-true-dep-cost
同じ場所を目的とするストアとロードの間の（CPUサイクルでの）最小距離。

@item selsched-max-lookahead
選択的スケジューリングの前方窓の最大サイズ。それは利用可能な命令の検索の深さである。

@item selsched-max-sched-times
選択的スケジューリングの間に命令がスケジュールされる時間の最大値。
これは命令がそれを通してパイプライン化されるかもしれない繰り返し数の制限である。

@item selsched-insns-to-rename
選択的スケジューリングでの名前変えで考慮される準備済みリストでの最良の命令の最大数。

@item sms-min-sc
振動モジュロスケジューラーが生成するステージカウントの最小値。

@item max-last-value-rtl
そのレジスタの最後の既知の値として疑似レジスタのコンバイナの表現において記録されることができる多くのRTLとして計られる最大サイズ。

@item max-combine-insns
RTLコンバイナが結合しようとする命令の最大数。

@item integer-share-limit
小さい整数定数は共有データ構造を使うことができ、コンパイラのメモリ使用を減らして速度を速める。
これは共有整数定数の最大値をセットする。

@item ssp-buffer-size
@option{-fstack-protection}を使っている時のスタック破壊防御を受け取るバッファ（すなわち、配列）の最小値。

@item min-size-for-stack-sharing
最適化しない時のスタックスロット共有の一部をなす変数の最小サイズ。

@item max-jump-thread-duplication-stmts
スレッドジャンプの時に複製する必要があるブロックで許される行の最大値。

@item max-fields-for-field-sensitive
ポインタ解析の間でのフィールドに敏感なやり方で扱われる構造のフィールドの最大数。

@item prefetch-latency
プリフェッチが終わる前に実行される命令の平均値の推測。前もってプリフェッチされる距離は
この定数に比例する。この数を増やすとプリフェッチされるストリームも小さくなるかもしれない。
(@option{simultaneous-prefetches}参照)

@item simultaneous-prefetches
同時に走ることができるプリフェッチの最大数。

@item l1-cache-line-size
バイトでのL1キャッシュでのキャッシュラインのサイズ。

@item l1-cache-size
キロバイトでの、L1キャッシュのサイズ。

@item l2-cache-size
キロバイトでの、L2キャッシュのサイズ。

@item prefetch-dynamic-strides
ループ配列プリフェッチパスが、一定でないストライドに対してソフトウェアプリフェッチヒントを発行するかどうか。 ストライドが非一定であるという事実により、これらのヒントを発行する明確なメリットがあるかどうかを予測することが困難になる場合がありますが、これは有益な場合があります。

一定でないストライドに対してプリフェッチヒントを発行する必要がある場合は、1に設定します。 一定で、@option{prefetch-minimum-stride}以下であることがわかっているストライドに対してのみプリフェッチヒントを発行する必要がある場合は、0に設定します。

@item prefetch-minimum-stride
プリフェッチヒントの使用を開始する最小定数ストライド（バイト単位）。 ストライドがこのしきい値よりも小さい場合、プリフェッチヒントは発行されません。

この設定は、ハードウェアプリフェッチャーを備えたプロセッサに役立ちます。この場合、ハードウェアプリフェッチャーとソフトウェアプリフェッチャーの間に競合が発生する可能性があります。 ハードウェアプリフェッチャーが処理可能な最大ストライドを持っている場合、ソフトウェアプリフェッチャーの使用を改善するためにここで使用する必要があります。

値-1は、しきい値がないことを意味するため、一定のストライドに対してプリフェッチヒントを発行できます。

この設定は、既知で一定のストライドにのみ役立ちます。

@item loop-interchange-max-num-stmts
交換されるループ内のstmtの最大数。

@item loop-interchange-stride-ratio
交換が有益になるための2つのループのストライド間の最小比率。

@item min-insn-to-prefetch-ratio
命令数とループでのプリフェッチを可能にするためのプリフェッチの数の最小比。

@item prefetch-min-insn-to-mem-ratio
命令数とループのプリフェッチを可能にするためのメモリ参照の数の最小比。

@item use-canonical-types
コンパイラが「正規の」型システムを使うべきか。デフォルトでは、これは常に1であるべきで、
C++とObjective-C++で型を比較するのにもっと効率のいい内部メカニズムを使う。しかし、
もし正規型システムでのバグが比較の失敗を起こすならば、正規型を無効にするためにこの値を0にセットする。

@item switch-conversion-max-branch-ratio
switch初期化変換がswitch内で@option{switch-conversion-max-branch-ratio}の分岐の数倍よりも大きい配列を作ることを拒否する。

@item max-partial-antic-length
@option{-O3}以上で最適化するときに木部分冗長除去(@option{-ftree-pre})の間に計算される部分奇怪集合の最大長。
ある種類のソースコードでは、強化された部分冗長除去最適化は暴走することがありえ、それはホスト機械で利用できるメモリの全てを消費する。
このパラメータは計算されるセットの長さの上に制限を置き、手に負えないふるまいを妨げる。
0の値をこのパラメータに設定することは、無制限のセットされた長さを許す。

@item rpo-vn-max-loop-depth
楽観的に値が付けられた最大ループ深度。
制限が最も内側の@var{rpo-vn-max-loop-depth}ループに達すると、ループネストの最も外側のループは楽観的に値が付けられ、残りはしません。

@item sccvn-max-alias-queries-per-access
ロードとストアの冗長を探すときに行うエイリアス・オラクルクエリの最大数。
もしこの制限が当たったならば検索は中止されロード・ストアは冗長とはみなされない。
クエリの数は関数エントリへのロード空のすべての経路でのストアの数へとアルゴリズム的に制限される。

@item ira-max-loops-num
IRAはデフォルトで領域レジスタ割り当てを使う。もし関数がこのパラメータで与えられう数よりも多くのループを含むなら、
多くとも領域レジスタ割り当ての領域からの最もよく実行されるループの与えられる数のみである。

@item ira-max-conflict-table-size 
IRAは衝突テーブルを圧縮するために洗練されたアルゴリズムを用いているけれども、テーブルはそれでも巨大な関数には
かなりの量のメモリを要求しうる。もし関数の衝突テーブルがこのパラメータによってMBで与えられるサイズをよりも大きくなりうるなら、
レジスタアロケータは代わりに疑似レジスタ衝突テーブルを作る必要がない速くて、単純で、低品質なアルゴリズムを使う。

@item ira-loop-reserved-regs
IRAはループ不変式を移動するための決定のために(@option{-O3}参照)ループ内のもっと正確なレジスタ圧力を評価するために使うことができる。
ある他の目的のために予約された利用可能なレジスタの数はこのパラメータで与えられる。パラメータのデフォルト値は数々の実験で最良であることがわかっている値です。

@item lra-inheritance-ebb-probability-cutoff
LRAは、以降の命令でのレジスタで再ロードされる値を再利用しようと試みる。
この最適化は継承と呼ばれる。EBBはこの最適化をするための領域として使われる。
パラメータはLRAでEBBを継承するためにBBを加えるために使われる最小のフォールスルーの最小確率を
パーセントで定義する。パラメータのデフォルト値はx86-64でのSPEC2000の数々の実行から選択された。

@item loop-invariant-max-bbs-in-loop
ループ不変式移動は、とても大きいループでは、コンパイル時間とコンパイル時に必要なメモリの量の両方で、とても高価になりうる。
このパラメータよりも多い基本ブロックを持つループにはループ不変移動最適化が行われない。

@item loop-max-datarefs-for-datadeps
とても大きいループではデータ遺贈の構築は高価である。このパラメータはデータ依存解析で考慮されるループでのデータ参照の数を
制限する。これらの大きいループはループデータ依存を使った最適化では扱われない。

@item max-vartrack-size
任意の関数の変数追跡データフロー解析の間に使うハッシュテーブルスロットの最大値をセットする。
もしこの制限が有効にされた代入での変数追跡で超えたならば、その関数からすべてのデバッグ命令を取り除いた後に
その関数の解析はそれ無しで再試行される。もし制限がデバッグ命令なしでさえ超過したならば、変数追跡解析はその関数では完全に無効にされる。
このパラメータを０にすると無制限になる。

@item max-vartrack-expr-depth
変数名かデバッグ一時値を値式へ割り当てようとするときの再帰レベルの最大値をセットする。
これはもっと完全なデバッグ情報のコンパイル時間と交換する。もしこれがあまりにも低くセットされていたら、
利用可能でデバッグ情報で表現されうる値式は最終的に使われないかもしれない。これを高くすると
コンパイラがもっと複雑なデバッグ式をみつけることができるかもしれないが、コンパイル時間とメモリが増えるかもしれない。

@item max-debug-marker-count
デバッグマーカー（たとえば、stmtマーカーの開始）の数にしきい値を設定して、RTLへのインライン化または拡張時の複雑さの爆発を回避します。
関数に設定された制限よりも多くのそのようなgimple stmtがある場合、そのようなstmtは関数のインラインコピーおよびそのRTL拡張から削除されます。

@item min-nondebug-insn-uid
非デバッグ命令用にこのパラメータで始まるuidを使う。このパラメータ未満の範囲は
@option{-fvar-tracking-assignments}で作られるデバッグ命令用に排他的に予約されているが、
デバッグ命令はこれより上の（重ならない）udiをもし予約された範囲が枯渇したなら使うかもしれない。

@item ipa-sra-ptr-growth-factor
それらの累積的なサイズが@option{ipa-sra-ptr-growth-factor}の最初のポインタ・パラメータのサイズ倍以下の時だけ、
IPA-SRAは一つ以上の新しいパラメータで集計へのポインタを置き換える。

@item ipa-sra-max-replacements
IPA-SRAが追跡するアグリゲートの最大ピース。 結果として、これは仮パラメーターの置換の最大数でもあります。

@item sra-max-scalarization-size-Ospeed
@itemx sra-max-scalarization-size-Osize
２つの集合値のスカラー導出過程(SRAとIPA-SRA)は集合値のスカラー部分を独立のスカラー変数の使用に置換することを助ける。
これらのパラメータはストレージ単位での、それぞれ速度(@option{sra-max-scalarization-size-Ospeed})か
サイズ(@option{sra-max-scalarization-size-Osize})でコンパイルした時に置換として考慮される集合値の最大値を制御する。

@item sra-max-propagations
コピーの伝播を容易にするために、1つのローカル変数ごとに集約値のスカラー置換（SRA）が追跡する人工アクセスの最大数。

@item tm-max-aggregate-size
トランザクション内でスレッド局所変数のコピーを作るときに、変数がロギングで関数を保存されるバイト単位のサイズが
コード・シーケンス一組をセーブ・リストアさせるように、このパラメータは指定する。
このオプションは@option{-fgnu-tm}を使っているときだけ適用される。

@item graphite-max-nb-scop-params
Graphiteループ変換での指数的な効果を避けるために、静的制御部分(SCoP)でのパラメータの数は制限される。0の値を使用して境界を持ち上げることができる。 コンパイル時に値が不明で、SCoPの外部で定義されている変数は、SCoPのパラメータである。

@item loop-block-tile-size
@option{-floop-block}か@option{-floop-strip-mine}で有効になる、ループブロッキングかループ露天掘り変換で、
与えられた繰り返し数によって入れ子のループ内のそれぞれのループで露天掘りを行う。
露天掘りの長さは@option{loop-block-tile-size}を使って変更できる。

@item ipa-jump-function-lookups
ジャンプ関数オフセット検出中にアクセスされるステートメントの数を指定します。

@item ipa-cp-value-list-size
IPA-CPは関数のパラメータを伝搬させて非仮想化を実行するするためにすべての可能な値と渡された型を追おうとする。
@option{ipa-cp-value-list-size}は、それが関数の1つの形式的パラメータにつき保存する値と型の最大数である。

@item ipa-cp-eval-threshold
IPA-CPはクローンニング収益性ヒューリスティックのそれ自身の得点を計算して、
@option{ipa-cp-eval-threshold}を上回る得点で、それらのクローニング機会を行う。

@item ipa-cp-max-recursive-depth
自己再帰関数の再帰クローンの最大深度。

@item ipa-cp-min-recursive-probability
呼び出しが実行される確率がパラメーターを超えた場合にのみ、再帰的な複製。

@item ipa-cp-recursion-penalty
クローンニングで評価での再帰関数が受け取るパーセントのペナルティ。

@item ipa-cp-single-call-penalty
クローンニングの評価での他の関数の単一呼び出しを含む関数が受け取るパーセントのペナルティ。

@item ipa-max-agg-items
IPA-CPも、集合値で渡されるいくつかのスカラー値を伝播するための能力がある。
@option{ipa-max-agg-items}は、1つのパラメータにつきそのような値の最大数を制御する。

@item ipa-cp-loop-hint-bonus
クローニング候補が知られているループの繰り返しの数を作るとIPA-CPが決定するとき、
それは@option{ipa-cp-loop-hint-bonus}のボーナスを候補の収益性得点に加える。

@item ipa-max-loop-predicates
関数内のループに既知のプロパティがある場合を記述するためにIPAが使用するさまざまな述語の最大数。

@item ipa-max-aa-steps
関数本体のその解析の間、IPA-CPは、関数パラメータによって指される値を追うために、別名解析を使用する。
巨大な関数を分析することにあまりにたくさんの時間を費やさないために、それは諦めてメモリを修正している@option{ipa-max-aa-steps}分を調べた後に
破壊されるすべてのメモリを考慮する。

@item ipa-max-switch-predicate-bounds
switchステートメントのケース範囲の境界エンドポイントの最大数。 この制限を超えるスイッチの場合、IPA-CPは、switchステートメントのデフォルトの場合に、クローン作成の利点を見積もるために使用されるクローン作成コスト述語を作成しません。

@item ipa-max-param-expr-ops
IPA-CPは、いくつかの関数パラメーターを参照する条件ステートメントを分析して、特定の定数値でのクローン作成の利点を見積もります。 ただし、パラメータ式の演算数が@option{ipa-max-param-expr-ops}を超えると、式は複雑なものとして扱われ、IPA分析では処理されません。

@item lto-partitions
WHOPRコンパイルの間、生み出される望ましい分割数を指定する。
分割数は、コンパイルのために使われるCPUの数を超えるべきである。

@item lto-min-partition
WHOPR（推定された命令で）のための最小の分割のサイズ。
これは、非常に小さいプログラムをあまりに多くの分割に分けることの費用を防ぐ。

@item lto-max-partition
パーティションの個々のサイズの上限を提供するWHOPRの最大パーティションサイズ（推定命令内）。
平衡パーティショニングでのみ使用することを意味する。

@item lto-max-streaming-parallelism
LTOストリーミングに使用される並列プロセスの最大数。

@item cxx-max-namespaces-for-diagnostic-help
C++名検索が識別子のために失敗するとき、提案について相談する名前空間の最大数。

@item sink-frequency-threshold
文が文の降下を許す本来のブロックと比較してターゲット・ブロックの最大相対的な（パーセントでの）実行頻度。
大きい数はより積極的な文の降下を起こす。デフォルト値は75である。それらは降下するほどより収益性の高いので、
小さな正の調整は、メモリ・オペランドを持つ文に適用される。

@item max-stores-to-sink
降下可能な条件付きストア対の最大数。もしベクトル化(@option{-ftree-vectorize})とif変換
(@option{-ftree-loop-if-convert})のどちらかが無効にされているなら0にセットする。

@item case-values-threshold
条件付き分岐の木の代わりにジャンプテーブルを使うのが最良である異なった値の最小値。もし値が0ならば、その機種のデフォルトを使う。

@item jump-table-max-growth-ratio-for-size
ジャンプテーブルに展開するときの最大コードサイズの増加率（パーセント）。 このパラメーターは、サイズを最適化するときに使用されます。

@item jump-table-max-growth-ratio-for-speed
ジャンプテーブルに展開するときの最大コードサイズの増加率（パーセント）。 このパラメーターは、速度を最適化するときに使用されます。

@item tree-reassoc-width
再結合木で並列に実行される命令の最大数。このパラメータはもし非0の値を持つならばデフォルトで使われる
ターゲット依存のヒューリスティックを上書きする。

@item sched-pressure-algorithm
@option{-fsched-pressure}の利用可能な2つの実装の間で選択する。
アルゴリズム１は元々の実装で命令が再整列されるのを最も防ぐだろう。
アルゴリズム２はアルゴリズム1によってされる比較的保守的なアプローチと
デフォルト・スケジューラによってされるむしろ積極的なアプローチの間の妥協であるように設計された。
それは、普通のレジスタ・ファイルと正確なレジスタ圧クラスがあることにより重く依存している。
詳細はGCCソースの@file{haifa-sched.c}を見よ。

デフォルトの選択肢はターゲットに依存している。

@item max-slsr-cand-scan
新しい直線強度縮小候補の基礎を探すときに考慮される存在する候補の最大数。

@item asan-globals
グローバルオブジェクトのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
グローバルオブジェクト防御を無効にするには@option{--param asan-globals=0}を使う。

@item asan-stack
スタックオブジェクトでのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
スタック防御を無効にするには@option{--param asan-stack=0}オプションを使う。

@item asan-instrument-reads
メモリ読み出しでのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
メモリ読み出し防御を無効にするには@option{--param asan-instrument-reads=0}を使う。

@item asan-instrument-writes
メモリ書き込みでのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
メモリ書き込み防御を無効にするには@option{--param asan-instrument-writes=0}オプションを使う。

@item asan-memintrin
組み込み関数の検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
組み込み関数防御を無効にするには@option{--param asan-memintrin=0}を使う。

@item asan-use-after-return
使用後に復帰の検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
使用後復帰の検知を無効にするには、@option{--param asan-use-after-return=0}を使う。

注：デフォルトでは、チェックは実行時に無効になっています。 これを有効にするには、@code{detect_stack_use_after_return=1}を環境変数@env{ASAN_OPTIONS}に追加します。

@item asan-instrumentation-with-call-threshold
インストルメントされる関数のメモリアクセス数がこの数以上の場合、インラインチェックの代わりにコールバックを使用します。例えば。 インラインコードを無効にするには、@option{-param asan-instrumentation-with-call-threshold=0}を使用します。

@item hwasan-instrument-stack
静的にサイズ設定されたスタック割り当て変数のhwasanインスツルメンテーションを有効にします。
この種のインストルメンテーションは、@option{-fsanitize=hwaddress}を使用するとデフォルトで有効になり、@option{-fsanitize=kernel-hwaddress}を使用するとデフォルトで無効になります。
スタックインストルメンテーションを無効にするには@option{--param hwasan-instrument-stack=0}を使用し、有効にするには@option{--param hwasan-instrument-stack=1}を使用します。

@item hwasan-random-frame-tag
スタックインストルメンテーションを使用する場合は、フレームごとにランダムなタグで始まる決定論的シーケンスを使用して、スタック変数のタグを決定します。 このパラメーターを使用すると、タグは同じシーケンスを使用して選択されますが、1から始まります。これは@option{-fsanitize=hwaddress}ではデフォルトで有効になっており、@option{-fsanitize=kernel-hwaddress}では使用できません。 無効にするには、@option{--param hwasan-random-frame-tag=0}を使用します。

@item hwasan-instrument-allocas
動的にサイズ設定されたスタック割り当て変数のhwasanインスツルメンテーションを有効にします。 この種のインストルメンテーションは、@option{-fsanitize=hwaddress}を使用するとデフォルトで有効になり、@option{-fsanitize=kernel-hwaddress}を使用するとデフォルトで無効になります。 このような変数のインストルメンテーションを無効にするには、@option{--param hwasan-instrument-allocas=0}を使用し、有効にするには、@option{--param hwasan-instrument-allocas=1}を使用します。

@item hwasan-instrument-reads
メモリ読み取りでhwasanチェックを有効にします。 読み取りのインストルメンテーションは、@option{-fsanitize=hwaddress}と@option{-fsanitize=kernel-hwaddress}の両方でデフォルトで有効になっています。 メモリ読み取りのチェックを無効にするには、@option{--param hwasan-instrument-reads=0}を使用します。

@item hwasan-instrument-writes
メモリ書き込みのhwasanチェックを有効にします。 書き込みのインストルメンテーションは、@option{-fsanitize=hwaddress}と@option{-fsanitize=kernel-hwaddress}の両方でデフォルトで有効になっています。 メモリ書き込みのチェックを無効にするには、@option{--param hwasan-instrument-writes=0}を使用します。

@item hwasan-instrument-mem-intrinsics
組み込み関数のhwasanインスツルメンテーションを有効にします。 これらの組み込み関数のインストルメンテーションは、@option{-fsanitize=hwaddress}と@option{-fsanitize=kernel-hwaddress}の両方でデフォルトで有効になっています。 組み込み関数のインストルメンテーションを無効にするには、@option{--param hwasan-instrument-mem-intrinsics=0}を使用します。

@item use-after-scope-direct-emission-threshold
バイト単位のローカル変数のサイズがこの数値以下である場合、ランタイムコールバックを使用する代わりに、シャドウメモリを直接ポイズニング（または無害化）します。


@item tsan-distinguish-volatile
volatileへのアクセスのために特別な機器を放出します。

@item tsan-instrument-func-entry-exit
__tsan_func_entry()および__tsan_func_exit()へのインストルメンテーション呼び出しを発行します。

@item max-fsm-thread-path-insns
有限状態オートマトンジャンプスレッド経路でのブロック複製でコピーされる命令の最大数。

@item max-fsm-thread-length
有限状態オートマトンジャンプスレッド経路での基本ブロックの最大数。

@item max-fsm-thread-paths
有限状態オートマトン用に作るための新しいジャンプスレッドの最大数。

@item parloops-chunk-size
parloopsによって並列化されたループ用のompスケジュールのチャンクサイズ。

@item parloops-schedule
parloopsによって並列化されたループ用のompスケジュールのスケジュールタイプ。（static, dynamic, guided, auto, runtime)

@item parloops-min-per-thread
並列化バリアントがシングルスレッドループよりも優先される、最も内側の並列化ループのスレッドごとの最小反復回数。 並列化されたループネストの場合、スレッドごとの最も外側のループの最小反復回数は2回です。

@item max-ssa-name-query-depth
畳み込みルーチンのようなものでのSSA名の属性を要求するときの再帰の最大深さ。
再帰の1レベルはuse-def連鎖の追尾に対応する。

@item max-speculative-devirt-maydefs
投機的に非仮想化できるかもしれない仮想呼び出しを呼び出すオブジェクトの動的型を指定する確実に定義されているものの検索時に解析する
定義されているかもしれないものの最大値。

@item max-vrp-switch-assertions
VRP中にswitchステートメントのデフォルトエッジに沿って追加するアサーションの最大数。 デフォルトは10である。

@item unroll-jam-min-percent
unroll-and-jam変換が利益をもたらすと考えられるように最適化する必要のあるメモリー参照の最小パーセンテージ。

@item unroll-jam-max-unroll
unroll-and-jam変換によって外側ループを展開する必要のある最大回数。

@item max-rtl-if-conversion-unpredictable-cost
予測不能と見なされるブランチのRTL if-conversionパスによって生成されるシーケンスの最大許容コスト。

@item max-rtl-if-conversion-unpredictable-cost
予測不可能と見なされるブランチのRTLif-conversionパスによって生成されるシーケンスの最大許容コスト。

@item max-variable-expansions-in-unroller
@option {-fvariable-expansion-in-unroller}を使用する場合、ループの展開中に個々の変数が展開される最大回数。

@item tracer-min-branch-probability-feedback
最適なエッジの確率がこのしきい値（パーセント）より小さい場合、前方成長を停止します。 プロファイルのフィードバックが利用可能な場合に使用されます。

@item partial-inlining-entry-probability
分割領域のエントリBBの最大確率（関数のエントリBBに対するパーセント）で、部分的なインライン化が発生します。

@item max-tracked-strlens
strlen最適化パスが文字列の長さを追跡する文字列の最大数。

@item gcse-after-reload-partial-fraction
リロード後に部分的な冗長性の除去を実行するためのしきい値比率。

@item gcse-after-reload-critical-fraction
リロード後に冗長性の除去を実行できるクリティカルエッジ実行カウントのしきい値比。

@item max-loop-header-insns
ループヘッダーのコピーコピーによって複製されるループヘッダーのinsnの最大数。

@item vect-epilogues-nomask
小さいベクトルサイズを使用してループエピローグベクトル化を有効にします。

@item vect-partial-vector-usage
ループベクトライザーがスカラーコードにフォールバックする代わりに、部分的なベクトルのロードとストアの使用を検討するタイミングを制御します。 0は、ベクトライザーが部分的なベクトルのロードとストアを使用しないようにします。 1は、ベクトル化によってコードを反復する必要がなくなった場合に、部分的なベクトルのロードとストアを許可します。 2は、部分的なベクトルのロードを許可し、すべてのループに格納します。 このパラメーターは、部分的なベクトルのロードとストアをサポートするターゲットにのみ影響します。

@item avoid-fma-max-bits
FMAの作成を回避する最大ビット数。

@item sms-loop-average-count-threshold
Swing Moduloスケジューラーによって考慮される平均ループカウントのしきい値。

@item sms-dfa-history
swing moduloスケジューラーがDFAを使用して競合をチェックするときに考慮するサイクルの数。

@item max-inline-insns-recursive-auto
再帰的インライン化を介して増加できる、非インライン関数の命令の最大数。

@item graphite-allow-codegen-errors
@option{-fchecking}のときにcodegenエラーがICEであるかどうか。

@item sms-max-ii-factor
Swing Moduloスケジューラーがループのスケジューリングに使用する上限を調整するための要因。

@item lra-max-considered-reload-pseudos
非リロード擬似のスピル中に考慮されるリロード擬似の最大数。

@item max-pow-sqrt-depth
実数定数によるべき乗を合成するときに使用するsqrtチェーンの最大の深さ。

@item max-dse-active-local-stores
RTLデッドストアの削除におけるアクティブなローカルストアの最大数。

@item asan-instrument-allocas
asan allocas/VLA保護を有効にします。

@item max-iterations-computation-cost
反復回数を計算するための式のコストにバインドされています。

@item max-isl-operations
isl操作の最大数。0は無制限を意味します。

@item graphite-max-arrays-per-scop
scopごとの配列の最大数。

@item max-vartrack-reverse-op-size
逆操作を追加するlocリストの最大サイズ。

@item unlikely-bb-count-fraction
プロファイルの最小部分は、ありそうであると見なされるべきではない、与えられた基本ブロック実行カウントを実行します。

@item tracer-dynamic-coverage-feedback
トレース形成でカバーする必要がある実行頻度で重み付けされた関数の割合。
プロファイルのフィードバックが利用可能な場合に使用されます。

@item max-inline-recursive-depth-auto
非インライン関数の再帰的インライン化の最大の深さ。

@item fsm-scale-path-stmts
（スケーリングされた）ブロックの数と比較するときに、スレッドパス内のステートメントの数に適用するスケール係数。

@item fsm-maximum-phi-arguments
FSMスレッダーがブロックのスレッド化を試行しない前に、PHIが持つことができる引数の最大数

@item uninit-control-dep-attempts
初期化されていない変数分析中に制御依存関係を検索するためのネストされた呼び出しの最大数。

@item sra-max-scalarization-size-Osize
サイズをコンパイルする際にスカラー化を考慮する必要がある集合体の最大サイズ（ストレージ単位）。

@item fsm-scale-path-blocks
（スケーリングされた）ステートメントの数と比較するときに、スレッドパス内のブロックの数に適用されるスケール係数。

@item sched-autopref-queue-depth
ハードウェア自動プリフェッチャースケジューラモデル制御フラグ。
モデルが調べる先読みサイクルの数。 ''で、命令ソートヒューリスティックのみを有効にします。

@item loop-versioning-max-inner-insns
ループバージョン管理パスがコピーするには大きすぎると見なす前に、内部ループが保持できる命令の最大数。

@item loop-versioning-max-outer-insns
ループバージョン管理パスがコピーするには大きすぎると見なす前に外部ループが保持できる命令の最大数で、バージョン管理から直接恩恵を受ける内部ループ内の命令を割引きます。

@item ssa-name-def-chain-limit
値など、変数のプロパティを決定する際に従うSSA_NAME割り当ての最大数。 これにより、特定のステートメントを最適化するとき、または診断を発行する前にそれらの有効性を判断するときに、GCCが実行する反復または再帰呼び出しの数が制限されます。

@item store-merging-max-size
単一ストアのマージ領域の最大サイズ（バイト単位）。

@item hash-table-verification-limit
検索された要素ごとにハッシュテーブル検証が行われる要素の数。

@item max-find-base-term-values
1回のfind_base_term呼び出し中に処理されるVALUEの最大数。

@item analyzer-max-enodes-per-program-point
そのポイントの分析を終了する前のアナライザー内のプログラムポイントごとの展開ノードの最大数。

@item analyzer-max-constraints
状態ごとの制約の最大数。

@item analyzer-min-snodes-for-call-summary
アナライザーが呼び出しサイトでの影響の要約を検討するための関数内のスーパーノードの最小数。

@item analyzer-max-enodes-for-full-dump
冗長性の低い形式に切り替える前にドットダンプに表示される、展開されたノードの最大深度。

@item analyzer-max-recursion-depth
より深く繰り返されるコールの分析を終了する前に、コールサイトがアナライザ内のコールスタックに表示される最大回数。

@item analyzer-max-svalue-depth
値を不明として概算する前の、シンボリック値の最大深度。

@item gimple-fe-computed-hot-bb-threshold
ホットと見なされる基本ブロックの実行数。 このパラメーターは、GIMPLEFEでのみ使用されます。

@item analyzer-bb-explosion-factor
分析を終了する前の、スーパーノードごとのアナライザー内の「スーパーノード後」の爆発ノードの最大数。

@end table

@var{name}の次の選択肢は、AArch64ターゲットで使用できます。

@table @gcctabopt
@item aarch64-sve-compare-costs
SVEをベクトル化するときは、小さい要素に「アンパック」ベクトルを使用することを検討し、コストモデルを使用して最も安価なアプローチを選択します。 また、コストモデルを使用して、SVEと高度なSIMDベクトル化のどちらかを選択します。

解凍されたベクトルの使用には、小さな要素を大きなコンテナーに格納することや、負荷を拡張してストアを切り捨てて要素にアクセスすることが含まれます。

@item aarch64-float-recp-precision
float型の逆数を計算するためのニュートン反復の数。 除算近似が有効になっている場合、除算の精度はこのパラメータに比例します。 デフォルト値は1です。

@item aarch64-double-recp-precision
ダブルタイプの逆数を計算するためのニュートン反復の数。 除算近似が有効になっている場合、除算の精度はこのパラメータに比例します。 デフォルト値は2です。

@item aarch64-autovec-preference
自動ベクトル化のためのISA選択戦略を強制します。 0から4までの値を受け入れます。
@table @samp
@item 0
デフォルトのヒューリスティックを使用します。
@item 1
自動ベクトル化にはAdvancedSIMDのみを使用します。
@item 2
自動ベクトル化にはSVEのみを使用します。
@item 3
AdvancedSIMDとSVEの両方を使用します。 コストが等しいと見なされる場合は、高度なSIMDを優先します。
@item 4
AdvancedSIMDとSVEの両方を使用します。 コストが等しいと見なされる場合は、SVEを優先します。
@end table
デフォルト値は0です。

@end table

@end table

@node Instrumentation Options
@section プログラム計装オプション
@cindex instrumentation options
@cindex program instrumentation options
@cindex run-time error checking options
@cindex profiling options
@cindex options, program instrumentation
@cindex options, run-time error checking
@cindex options, profiling

実行時計装をそれが通常生成するコードに加えることを制御するいくつかのコマンド・ライン・オプションを、GCCはサポートする。
たとえば計装の1つの目的は、プログラム・ホットスポット、コード範囲解析またはプロフィール誘導最適化を見つけるために、
プロファイリング統計を集めることである。プログラム計装のもう一つの種類は
不正ポインタ被参照、境界線外配列アクセスなどのプログラミングエラーや、
スタック破壊やC++仮想テーブルハイジャックのような恋の敵対的攻撃の検知である。
デバッグまたはプログラム解析目的のために追跡または関数レベルの計装の道具他の形に使われることができる一般的なフックもある。

@table @gcctabopt
@cindex @command{prof}
@cindex @command{gprof}
@item -p
@itemx -pg
@opindex p
@opindex pg
分析プログラム@command{prof}（@option{-p}の場合）または@command{gprof}（@option {-pg}の場合）に適したプロファイル情報を書き込むための追加コードを生成します。  このオプションは、データが必要なソースファイルをコンパイルするときに使用する必要があり、リンクするときにも使用する必要があります。

関数属性@code{no_instrument_function}を使用して、これらのオプションでコンパイルするときに個々の関数のプロファイリングを抑制することができます。
@xref{Common Function Attributes}。

@item -fprofile-arcs
@opindex fprofile-arcs
プログラムフロー@dfn{arcs}が測定されるようにコードを追加する。実行の間に
プログラムはそれぞれの分岐と呼び出しが何回実行されるかと何回取られる・返るかを記録する。
優先度をサポートするコンストラクターをサポートするターゲットでは、プロファイリングは、グローバル変数のタイプとして使用されるクラスのコンストラクター、デストラクタ、およびC++コンストラクタ（およびデストラクタ）を適切に処理します。

コンパイルされたプログラムが終了するときにそれぞれのファイルごとに
@file{@var{auxname}.gcda}と呼ばれるファイルにこのデータを保存する。
データはプロファイルに指示された最適化(@option{-fbranch-probabilities})、
テストカバレッジ解析(@option{-ftest-coverage})でも使うことができる。
それぞれのオブジェクトファイルの@var{auxname}は、
もし明示的に指定されていて最終実行ファイルでないならば出力されたファイルの名前から生成され、
さもなければソースファイルの基底名である。両方の場合で拡張子は取り除かれる。
（例えば、入力ファイル@file{dir/foo.c}では@file{foo.gcda}であり、
@option{-o dir/foo.o})として指定された出力ファイルは@file{dir/foo.gcda}である。
@xref{Cross-profiling}.

@cindex @command{gcov}
@item --coverage
@opindex coverage

このオプションはカバレッジ解析のために測定されたコードをコンパイル・リンクするために使う。
このオプションは@option{-fprofile-arcs} @option{-ftest-coverage}(コンパイル時)と
@option{-lgcov}（リンク時）と同義語である。詳細はこれらのオプションを見よ。

@itemize

@item
@option{-fprofile-arcs}と最適化とコード生成オプションでソースファイルをコンパイルする。
テストカバレッジ解析のためには、追加の@option{-ftest-coverage}オプションを使う。
プログラムの全ソースファイルをプロファイルする必要はない。

@item
@option{-fprofile-abs-path}を使用してソースファイルをコンパイルし、@file{.gcno}ファイルに絶対パス名を作成する。 これにより@command{gcov}は異なる作業ディレクトリでコンパイルが行われるプロジェクトで正しいソースを見つけることができる。

@item
オブジェクトファイルを@option{-lgcov}ないし@option{-fprofile-arcs}でリンクする。
（後者は前者を含む）

@item
arcプロフィール情報を生成する代表的な作業負担の計画を実行する。これは任意回数繰り返されるかもしれない。プログラムの並列のインスタンスを走らせることができ、そして、ファイルシステムがロックすることをサポートするならば、データ・ファイルは正しく更新される。また、厳密なISO C変種が有効でない限り、@code{fork}呼び出しは見つけられて、二重カウントなしで正しく取り扱われる。

@item
プロファイル誘導最適化のためには、ソースファイルを再び同じ最適化とコード生成オプションに加えて@option{-fbranch-probabilities}
を使ってコンパイルする。 (@pxref{Optimize Options,,最適化を制御するオプション}).

@item
テストカバレッジ解析のためには、@file{.gcno}と@file{.gcda}ファイルから人間が読める情報を生成するために@command{gcov}を使う。
さらなる情報は@command{gcov}文書を参照のこと。

@end itemize

@option{-fprofile-arcs}で、あなたのプログラムのそれぞれの関数でGCCはデータフローグラフを作成し、
グラフの全域木を見つける。全域木になりarcのみが測定される。コンパイラはそれらのarcが実行される回数を数えるコードを追加する。
arcが唯一の出口であるかブロックへの唯一の入り口であるとき、測定コードがブロックに追加される。
さもなければ、新しいキボンブロックが測定コードを保持するために作られなければならない。

@need 2000
@item -ftest-coverage
@opindex ftest-coverage
@command{gcov}コード解析ユーティリティ(@pxref{Gcov,, @command{gcov}---テストカバレッジプログラム})が
プログラムカバレッジを表示するために使うことができるノートファイルを生成する。
それぞれのソースファイルのノートファイルは@file{@var{auxname}.gcno}と呼ばれる。
テストカバレッジデータを生成する方法での@var{auxname}と命令の説明のために、
上記の@option{-fprofile-arcs}オプションを参照せよ。
最適化しないならば、カバレッジデータはより密接にソース・ファイルに一致する。

@item -fprofile-abs-path
@opindex fprofile-abs-path
@file{.gcno}ファイル内の相対ソースファイル名を絶対パス名に自動的に変換します。 これにより、@command{gcov}は、異なる作業ディレクトリでコンパイルが行われるプロジェクトで正しいソースを見つけることができます。

@item -fprofile-dir=@var{path}
@opindex fprofile-dir

@var{path}に中でプロフィール・データ・ファイルを捜すためのディレクトリを決める。
このオプションは、@option{-fprofile-generate}、@option{-ftest-coverage}、@option{-fprofile-arcs}によって生成されて、
@option{-fprofile-use}と@option{-fbranch-probabilities}とその関連したオプションによって使われるプロフィール・データだけに影響を及ぼす。
絶対と相対パスが、使われることができる。
デフォルトで、GCCは@var{path}としてカレント・ディレクトリを使い、したがって
プロフィール・データ・ファイルはオブジェクト・ファイルと同じディレクトリに現れる。

実行可能ファイルを大規模な並列環境で実行する場合は、プロファイルを異なるフォルダーに保存することをお勧めします。 これは、実行時にエクスポートされる@var{path}の変数を使用して実行できます。

@table @gcctabopt

@item %p
プロセスID。

@item %q@{VAR@}
環境変数@var{VAR}の値

@end table

@item -fprofile-generate
@itemx -fprofile-generate=@var{path}
@opindex fprofile-generate

測定アプリケーションがプロフィール・フィードバックに基づいた最適化での後の再コンパイルに役立つプロフィールを生成するのに通常使われる
オプションを有効にする。@option{-fprofile-generate}をコンパイルとリンクの両方で使わなくてはならない。

以下のオプションが有効になる： @option{-fprofile-arcs}, @option{-fprofile-values}, @option{-fvpt}.

もし@var{path}が指定されたならば、GCCはプロファイルフィードバックデータファイルを見つけるために@var{path}を見る。
@option{-fprofile-dir}を見よ。

収集されたプロファイル情報に基づいてプログラムを最適化するためには、@option{-fprofile-use}を使う。
さらなる情報は@xref{Optimize Options}。

@item -fprofile-info-section
@itemx -fprofile-info-section=@var{name}
@opindex fprofile-info-section

コンストラクタ/デストラクタを使用する代わりに、指定されたセクションにプロファイル情報を登録します。セクション名は、指定されている場合は@var{name}です。指定されていない場合、セクション名はデフォルトで@code{.gcov_info}になります。 @option{-fprofile-arcs}または@option{-ftest-coverage}によって生成されたプロファイル情報へのポインターは、各翻訳単位の指定されたセクションに配置されます。このオプションは、コンストラクタを介したプロファイル情報の登録を無効にし、デストラクタを介したプロファイル情報処理を無効にします。このオプションは、GNU/Linuxなどのホスト環境での使用を目的としたものではありません。コンストラクタとデストラクタをサポートしない、リソースが限られているシステムを対象としています。リンカは、入力セクションを連続メモリブロックに収集し、開始シンボルと終了シンボルを定義できます。ランタイムサポートは、たとえば、プログラムの終了時にこのリンカセットに登録されたプロファイリング情報をシリアルラインにダンプできます。リンカ出力セクションを定義するGNUリンカスクリプトの例は次のとおりです。

@smallexample
  .gcov_info      :
  @{
    PROVIDE (__gcov_info_start = .);
    KEEP (*(.gcov_info))
    PROVIDE (__gcov_info_end = .);
  @}
@end smallexample

@item -fprofile-note=@var{path}
@opindex fprofile-note

@var{path}が指定されている場合、GCCは@file{.gcno}ファイルを@var{path}の場所に保存します。 オプションを複数のソースファイルと組み合わせると、@file{.gcno}ファイルが上書きされます。

@item -fprofile-prefix-path=@var{path}
@opindex fprofile-prefix-path

このオプションを@option{profile-generate=}@var{profile_dir}および@option{profile-use=}@var{profile_dir}と組み合わせて使用すると、ビルドされたソースツリーのベースディレクトリがどこにあるかをGCCに通知できます。 デフォルトでは、@var{profile_dir}には、ビルドされたプロジェクト内のすべてのオブジェクトファイルの絶対パスがマングルされたファイルが含まれます。インストルメント済みバイナリのビルドに使用されるディレクトリが、プロファイルフィードバックで最適化されたバイナリのビルドに使用されるディレクトリと異なる場合、最適化されたビルド中にプロファイルデータが見つからないため、これは望ましくありません。そのようなセットアップでは、ビルドのベースディレクトリを指す@var{path}つきの@option{-fprofile-prefix-path=}@var{path}を使用して、パスの無関係な部分を削除し、メインビルドディレクトリにすべてのファイル名を相対に保つことができます。

@item -fprofile-update=@var{method}
@opindex fprofile-update

プロファイルフィードバックベースの最適化のために計測されたアプリケーションの更新メソッドを変更する。 @var{method}引数は@samp{single}、@samp{atomic}または@samp{prefer-atomic}のいずれかでなければならない。
最初のものはシングルスレッドのアプリケーションには便利だが、2番目のものはスレッドセーフなコードを出力することでプロファイルの破損を防ぎます。

@strong{警告:} アプリケーションがすべてのスレッドを正しくジョインしない場合（または分離されたスレッドを作成する）は、プロファイルファイルはまだ破損する可能性がある。

@samp{prefer-atomic}を使うと、ターゲットでサポートされている場合は@samp{atomic}に、それ以外の場合は@samp {single}に変換される。 コマンドラインに@option{-pthread}がある場合、GCCドライバは自動的に@samp{prefer-atomic}を選択する。

@item -fprofile-filter-files=@var{regex}
@opindex fprofile-filter-files

名前が正規表現（セミコロンで区切られた）に一致するファイルの関数のみを計装する。

たとえば、@option{-fprofile-filter-files=main.c;module.*.c}は@file {main.c}と「module」で始まるすべてのCファイルのみをインスツルメントします。

@item -fprofile-exclude-files=@var{regex}
@opindex fprofile-exclude-files

名前がすべての正規表現（セミコロンで区切られた）に一致しないファイルの関数のみを計装する。

たとえば、@option{-fprofile-exclude-files=/usr/*}は、@file{/usr/}フォルダーにあるすべてのファイルのインストルメンテーションを防ぎます。

@item -fprofile-reproducible=@r{[}multithreaded@r{|}parallel-runs@r{|}serial@r{]}
@opindex fprofile-reproducible
@code{-fprofile-generate}によって収集されたプロファイルの再現性の制御レベル。 これにより、たとえば配布パッケージに役立つ同じ結果でプログラムを再構築することができます。

@option{-fprofile-reproducibility=serial}を使用すると、@option{-fprofile-generate}によって収集されたプロファイルは、トレーニングされたプログラムが訓練実行の各呼び出しで同じように動作し、マルチスレッドではなく、プロファイルデータストリーミング常に同じ順序で行われる限り、再現可能です。プロファイルのストリーミングは、プログラムの実行終了時だけでなく、@code{fork}関数が呼び出される前にも発生することに注意してください。

プログラムの一部の実行回数は、たとえば、一時ファイル名の長さやメモリ空間のランダム化（ハッシュテーブルの衝突率に影響を与える可能性がある）に依存することがよくあることに注意してください。このようなプログラムの再現できない部分は、@code{no_instrument_function}関数属性によって注釈を付けることができます。 @option{-l}を指定した@code{gcov-dump}を使用して、収集したデータをダンプし、それらが実際に再現可能であることを確認できます。

@option{-fprofile-reproducibility=parallel-runs}を使用すると、データがgcdaファイルにストリーミングされる順序に関係なく、収集されたプロファイルは再現性を維持します。 この設定により、インストルメント済みプログラムの複数のインスタンスを並列に実行できます（@code{make -j}などを使用）。 これにより、収集されたデータ、特に間接呼び出しプロファイリングの品質が低下します。

@item -fsanitize=address
@opindex fsanitize=address
高速なメモリエラー検知器のAddressSanitizerを有効にする。
メモリアクセス命令は境界外と解放後使用のバグを検知するために測定される。
このオプションは、@option{-fsanitize-address-use-after-scope}を有効にします。
さらなる詳細は@uref{https://github.com/google/sanitizers/wiki/AddressSanitizer}を見よ。
実行時の振る舞いは@env{ASAN_OPTIONS}環境変数を使って影響させることができる。
@code{help=1}をセットすると、測定されるプログラムの開始時に利用可能なオプションが表示される。
サポートされているオプションのリストは@url{https://github.com/google/sanitizers/wiki/AddressSanitizerFlags#run-time-flags}を見よ。
このオプションは@option{-fsanitize=thread}かつ/及び@option{-fcheck-pointer-bounds}と組み合わせることはできない。

@item -fsanitize=kernel-address
@opindex fsanitize=kernel-address
Linuxカーネル用のAddressSanitizerを有効にする。詳しい詳細は@uref{https://github.com/google/kasan/wiki}を見よ。


@item -fsanitize=hwaddress
@opindex fsanitize=hwaddress
ハードウェア支援AddressSanitizerを有効にします。これは、ハードウェア機能を使用してポインターの上位バイトを無視し、メモリオーバーヘッドを低く抑えてメモリエラーを検出できるようにします。 メモリアクセス命令は、範囲外および解放後使用のバグを検出するように装備されています。 このオプションは、@option{-fsanitize-address-use-after-scope}を有効にします。 詳細については、@uref{https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html}を参照してください。 実行時の動作は、@env{HWASAN_OPTIONS}環境変数を使用して影響を受ける可能性があります。 @code{help=1}に設定すると、インストルメントされたプログラムの起動時に使用可能なオプションが表示されます。 このオプションは、@option{-fsanitize=thread}または@option{-fsanitize=address}と組み合わせることはできず、現在AArch64でのみ使用できます。

@item -fsanitize=kernel-hwaddress
@opindex fsanitize=kernel-hwaddress
Linuxカーネルのコンパイルに対してハードウェア支援AddressSanitizerを有効にします。 @option{-fsanitize=kernel-address}に似ていますが、別のインストルメンテーション方法を使用し、@option{-fsanitize=hwaddress}に似ていますが、Linuxカーネルのコンパイルに必要なインストルメンテーションの違いがあります。 これらの違いは、hwasanライブラリの初期化呼び出しを回避し、最上位バイトに異なる値を持つスタックポインタを考慮に入れるためです。

@emph{注意:} このオプションのデフォルトは、@option{-fsanitize = hwaddress}とは異なります。 スタックおよびalloca呼び出しのインストルメンテーションはデフォルトではオンになっていませんが、それぞれコマンドラインオプション@option{--param hwasan-instrument-stack=1}および@option{--param hwasan-instrument-allocas=1}を指定することで引き続き可能です。ランダムフレームタグの使用は、カーネルインストルメンテーションには実装されていません。

@item -fsanitize=pointer-compare
@opindex fsanitize=pointer-compare
ポインターオペランドを使用した機器比較操作（<、<=、>、> =）を計装する。
オプションは、@option{-fsanitize=kernel-address}または@option{-fsanitize=address}のいずれかと組み合わせる必要があります
このオプションは@option{-fsanitize=thread}と組み合わせることはできません。
注：デフォルトでは、実行時にチェックは無効になっています。 有効にするには、環境変数@env{ASAN_OPTIONS}に@code{detect_invalid_pointer_pairs=2}を追加します。 @code{detect_invalid_pointer_pairs=1}を使用すると、両方のポインターがnullでない場合にのみ無効な操作が検出されます。

@item -fsanitize=pointer-subtract
@opindex fsanitize=pointer-subtract
ポインターオペランドを使用した減算を計装する。
オプションは、@option{-fsanitize=kernel-address}または@option{-fsanitize=address}のいずれかと組み合わせる必要があります。
オプションを@option{-fsanitize=thread}と組み合わせることはできません。
注：デフォルトでは、実行時にチェックは無効になっています。 有効にするには、
@code{detect_invalid_pointer_pairs=2}を環境変数@env{ASAN_OPTIONS}に追加します。 @code{detect_invalid_pointer_pairs=1}を使用すると、両方のポインターがnullでない場合にのみ無効な操作が検出されます。

@item -fsanitize=thread
@opindex fsanitize=thread
高速なデータ競合検知器のThreadSanitizerを有効にする。
メモリアクセス命令はデータ競合バグを検知するために測定される。
さらなる詳細は@uref{https://github.com/google/sanitizers/wiki#threadsanitizer}を見よ。
実行時の振る舞いは@env{TSAN_OPTIONS}環境変数を使って影響させることができる。
サポートされているオプションのリストは@url{https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags}を見よ。
このオプションは@option{-fsanitize=address}, @option{-fsanitize=leak}と組み合わせることはできない。

サニタイズされたアトミックビルトインは、非呼び出し例外（@option{-fnon-call-exceptions}）で無効なメモリアドレスを操作する場合、例外をスローできないことに注意してください。

@item -fsanitize=leak
@opindex fsanitize=leak
メモリリーク検知器のLeakSanitizerを有効にする。
このオプションはもし@option{-fsanitize=address}と@option{-fsanitize=thread}のどちらも使われていないならば
実行ファイルのリンクにのみ関連する。そのような場合には、実行ファイルは@code{malloc}と他の割り当て関数を上書きする
ライブラリに対してリンクされる。さらなる詳細は
@uref{https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer}を見よ。
実行時の振る舞いは@env{LSAN_OPTIONS}環境変数を使って影響させることができる。
このオプションは@option{-fsanitize=thread}と組み合わせることはできない。

@item -fsanitize=undefined
@opindex fsanitize=undefined
高速な未定義の振る舞い検知器、UndefinedBehaviorSanitizerを有効にする。
実行時の未定義の振る舞いを検知するために様々な計算が測定される。現在のサブオプションは以下である。

@table @gcctabopt

@item -fsanitize=shift
@opindex fsanitize=shift
このオプションはシフト演算の結果が未定義でないかをチェックすることを有効にする。
どれが正確に未定義であるかは、CとC++で、またISO C90とC99の間で微妙に異なっていることに注意。
このオプションには2つのサブオプション、@option{-fsanitize=shift-base}と@option{-fsanitize=shift-exponent}がある。

@item -fsanitize=shift-exponent
@opindex fsanitize=shift-exponent
このオプションは、シフト操作の第2引数が負ではなく、昇格した第1引数の精度よりも小さいことをチェックする。

@item -fsanitize=shift-base
@opindex fsanitize=shift-base
シフト演算の2番目の引数が範囲内にある場合は、シフト演算の結果が未定義でないことを確認する。 正確には未定義とみなされるものは、CとC++の間、およびISO C90とC99の間など、わずかに異る。

@item -fsanitize=integer-divide-by-zero
@opindex fsanitize=integer-divide-by-zero
ゼロ除算と@code{INT_MIN / -1}除算を検知する。

@item -fsanitize=unreachable
@opindex fsanitize=unreachable
このオプションで、コンパイラは@code{__builtin_unreachable}を代わりに診断メッセージ呼び出しに変換する。
@code{__builtin_unreachable}呼び出しに到達するとき、振る舞いは未定義である。

@item -fsanitize=vla-bound
@opindex fsanitize=vla-bound
このオプションはコンパイラに可変長配列の長さが正であるかどうかをチェックするように指示する。

@item -fsanitize=null
@opindex fsanitize=null
このオプションはポインタチェックを有効にする。特に、このオプションでビルドしたアプリケーションは
NULLポインタを被参照しようとしたとき、もし参照が（多分右辺値参照）がNULLポインタと結合したならば、
もしメソッドがNULLポインタで指示されたオブジェクトで実行されたならば、エラーメッセージを発する。

@item -fsanitize=return
@opindex fsanitize=return
このオプションはreturn文チェックを有効にする。このオプションによってビルドされたプログラムは
非void関数の終わりが実際に値を返すことなく到達したならばエラーメッセージを発する。
このオプションはC++のでのみ働く。

@item -fsanitize=signed-integer-overflow
@opindex fsanitize=signed-integer-overflow
このオプションは符号付き整数桁あふれチェックを有効にする。@code{+}, @code{*}と単項と2項の@code{-}で
符号付き算術が桁あふれしないかをチェックする。注意として、整数格上げ規則が考慮に入れられなければならない。
すなわち、以下は桁あふれではない。
@smallexample
signed char a = SCHAR_MAX;
a++;
@end smallexample

@item -fsanitize=bounds
@opindex fsanitize=bounds
このオプションは配列境界の計装を有効にする。様々な境界外アクセスが検知される。可変長配列メンバ、可変長配列メンバ様配列、静的領域の変数の初期化は計装されない。

@item -fsanitize=bounds-strict
@opindex fsanitize=bounds-strict
このオプションは厳密な配列境界の計装を有効にする。ほとんどの境界外アクセスは、可変長配列メンバと可変長配列メンバ様配列も含めて
計装される。静的領域の変数の初期化は計装されない。

@item -fsanitize=alignment
@opindex fsanitize=alignment
このオプションは被参照されるか、参照が不十分にアラインメントされた目標に結合しているか、
メソッドおよびコンストラクタが不十分にアラインメントされたオブジェクトに対して呼ばれているならば、ポインタのアラインメントをチェックする。

@item -fsanitize=object-size
@opindex fsanitize=object-size
このオプションは@code{__builtin_object_size}関数を使ったメモリ参照の計装を有効にする。様々な境界外ポインタアクセスが検知される。

@item -fsanitize=float-divide-by-zero
@opindex fsanitize=float-divide-by-zero
浮動小数点ゼロ除算を検知する。他の同様のオプションとは異なり、@option{-fsanitize=float-divide-by-zero}は
@option{-fsanitize=undefined}によっては有効にならない。なぜなら浮動小数点ゼロ除算は
無限大や非数を得る正当な方法だからである。

@item -fsanitize=float-cast-overflow
@opindex fsanitize=float-cast-overflow
このオプションは符号小数点数から整数型への変換のチェックを有効にする。我々は変換の結果が桁あふれしないかを検査する。他の同様のオプションとは異なり、@option{-fsanitize=float-cast-overflow}は@option{-fsanitize=undefined}では有効にならない。
このオプションは@code{FE_INVALID}例外が有効のときはよく働かない。

@item -fsanitize=nonnull-attribute
@opindex fsanitize=nonnull-attribute

このオプションは@code{nonnull}関数属性によって非ヌル値を要求するとマークされている引数へnull値を渡していないかどうかを検査する、
呼び出しの計装を有効にする。

@item -fsanitize=returns-nonnull-attribute
@opindex fsanitize=returns-nonnull-attribute

このオプションは@code{returns_nonnull}関数属性でマークされている関数でのreturn文の計装を有効にし、そのような関数からの
null値の返却を検知する。

@item -fsanitize=bool
@opindex fsanitize=bool

このオプションはboolからのロードの計装を有効にする。もし0/1以外の値がロードされたなら、
ランタイムエラーが発せられる。

@item -fsanitize=enum
@opindex fsanitize=enum

このオプションは列挙型からのロードの計装を有効にする。もし列挙型の範囲外の値がロードされたなら、
ランタイムエラーが発せられる。

@item -fsanitize=vptr
@opindex fsanitize=vptr

このオプションはC++メンバ関数呼び出し、メンバアクセス、基底へのポインタとその導出クラス間のある変換の計装を有効にし、
参照されたオブジェクトが正しい動的型を持つかを検証する。

@item -fsanitize=pointer-overflow
@opindex fsanitize=pointer-overflow

このオプションは、ポインタ演算の計測を有効にします。 ポインター演算がオーバーフローすると、実行時エラーが発行されます。

@item -fsanitize=builtin
@opindex fsanitize=builtin

このオプションは、選択された組み込み関数への引数の計測を有効にします。 そのような引数に無効な値が渡されると、実行時エラーが発行されます。 たとえば、引数として@code{__builtin_ctz}または@code{__builtin_clz}に0を渡すと、未定義の動作が呼び出され、このオプションによって診断されます。

@end table

@option{-ftrapv}が符号付き桁あふれでトラップを起こす一方、{-fsanitize=undefined}は診断メッセージを与える。
これは現在C言語族にしか働かない。

@item -fno-sanitize=all
@opindex fno-sanitize=all

このオプションはすべての前で有効にしたサニタイザを無効にする。あるサニタイザは一緒に使うことができないので、
@option{-fsanitize=all}は許可されていない。

@item -fasan-shadow-offset=@var{number}
@opindex fasan-shadow-offset
このオプションはGCCにAddressSanitizerチェックでのカスタム・シャドウ・オフセットを使うことを強制する。
これはカーネルAddressSanitizerでの異なったシャドウメモリレイアウトで実験しているときに役立つ。

@item -fsanitize-sections=@var{s1},@var{s2},...
@opindex fsanitize-sections
選択されたユーザ定義セクションでのグローバル変数を浄化する。@var{si}はワイルドカードを含んでも良い。

@item -fsanitize-recover@r{[}=@var{opts}@r{]}
@opindex fsanitize-recover
@opindex fno-sanitize-recover
@option{-fsanitize-recover=}は@var{opts}のコンマで区切られたリストで指摘されたサニタイザのエラー回復モードを制御する。
このオプションを有効にすることでサニタイザコンポネートがエラーが起こっていないかのようにプログラムを走り続けようとさせる。
これは単一のプログラム実行で複数のランタイムエラーが報告されうることを意味し、
プログラムの終了コードはエラーが報告されたにもかかわらず成功を示すかもしれない。
@option{-fno-sanitize-recover=}オプションはこの振る舞いを変えるために使うことができる。
最初に検知されたエラーが報告されプログラムは非ゼロの終了コードで終了する。

現在この機能は@option{-fsanitize=undefined} (と@option{-fsanitize=unreachable}と@/@option{-fsanitize=return}を除いたそのサブオプション)、
@option{-fsanitize=float-cast-overflow}、@option{-fsanitize=float-divide-by-zero}、@option{-fsanitize=bounds-strict}、
@option{-fsanitize=kernel-address} 、@option{-fsanitize=address}でのみ働く。
これらのサニタイザではエラー回復はデフォルトでオンであり、例外は@option{-fsanitize=address}であり、この機能は実験的である。
@option{-fsanitize-recover=all}と@option{-fno-sanitize-recover=all}も受理され、前者はそれをサポートするすべてのサニタイザ
の回復を有効にし、後者はそれをサポートするすべてのサニタイザで回復を無効にする。

コンパイラー側でリカバリー・モードをオンにしても、ランタイム・ライブラリー側でもリカバリー・モードを使用可能にする必要がある。そうしないと、障害は依然として致命的である。
実行時ライブラリのデフォルトはThreadSanitizerとUndefinedBehaviorSanitizerでは@code{halt_on_error = 0}であるが、AddressSanitizerのデフォルト値は@code{halt_on_error = 1}である。 これは、対応する環境変数の@code{halt_on_error}フラグをセットすることでオーバーライドできる。

明示的な@var{opts}パラメータなしの構文は廃止予定である。それは以下のOPTSを指定したのと
等価である。

@smallexample
undefined,float-cast-overflow,float-divide-by-zero,bounds-strict
@end smallexample

@item -fsanitize-address-use-after-scope
@opindex fsanitize-address-use-after-scope
スコープ使用後のバグを検出するためのローカル変数サニタイズを有効にする。このオプションは@option{-fstack-reuse}を@samp{none}に設定します。

@item -fsanitize-undefined-trap-on-error
@opindex fsanitize-undefined-trap-on-error
@option{-fsanitize-undefined-trap-on-error}オプションはコンパイラに未定義の振る舞いを
@code{libubsan}ライブラリルーチンではなく@code{__builtin_trap}使うように指示する。
この利点は@code{libubsan}が不要でリンクされず、自律環境でも利用可能なことである。

@item -fsanitize-coverage=trace-pc
@opindex fsanitize-coverage=trace-pc
カバレッジに指示されたファジングコード計装を有効にする。すべての基本ブロックに
@code{__sanitizer_cov_trace_pc}への呼び出しを挿入する。

@item -fsanitize-coverage=trace-cmp
@opindex fsanitize-coverage=trace-cmp
データフローに基づくファジングコードの計装を有効にします。オペランド変数または@code{__sanitizer_cov_trace_const_cmp1}両方と一体の比較のために@code{__sanitizer_cov_trace_cmp1}、@code{__sanitizer_cov_trace_cmp2}、@code{__sanitizer_cov_trace_cmp4}または@code{__sanitizer_cov_trace_cmp8}への呼び出しを挿入、
@code{__sanitizer_cov_trace_const_cmp2}、@ code{__sanitizer_cov_trace_const_cmp4}、または@code{__sanitizer_cov_trace_const_cmp8}は、1つのオペランド定数との整数比較用、@code{__sanitizer_cov_trace_cmpf}または@code {__sanitizer_cov_trace_cmpd}は、floatまたはdouble比較の場合、@code{__sanitizer_cov_trace_switch}は、switchステートメントの場合です。

@item -fcf-protection=@r{[}full@r{|}branch@r{|}return@r{|}none@r{]}check@r{]}
@opindex fcf-protection
制御フロー転送のコード計装を有効にして、制御フロー転送命令（間接関数呼び出し、関数戻り、間接ジャンプなど）のターゲットアドレスが有効であることを確認して、プログラムのセキュリティを向上させます。 これにより、制御の流れが予期しないターゲットに迂回するのを防ぎます。 これは、リターン指向プログラミング（ROP）、同様に呼び出し/jmp指向プログラミング（COP/JOP）などの脅威から保護することを目的としています。

値@code{branch}は、間接分岐命令、つまりcall/jmp命令のポイントで制御フロー転送の有効性のチェックを実装するようコンパイラーに指示します。 値@code{return}は、関数から戻った時点での有効性のチェックを実装します。 値@code{full}は、@code{branch}と@code{return}の両方を指定するためのエイリアスです。 値@code{none}は、計装をオフにします。

値@code{check}は、リンク時最適化（LTO）を使用した最終リンクに使用されます。 LTOオブジェクトファイルが異なる@option{-fcf-protection}値でコンパイルされている場合、エラーが発行されます。 値@code{check}は、コンパイル時に無視されます。

マクロ@code{__CET__}は、@ option{-fcf-protection}が使用されるときに定義されます。 @code{__CET__}の最初のビットは値@code{branch}に対して1に設定され、@code{__CET__}の2番目のビットは@code{return}に対して1に設定されます。

@code{nocf_check}属性を使用して、計装からスキップする必要がある関数と呼び出しを特定することもできます（@pxref{Function Attributes}）。

現在、x86 GNU/LinuxターゲットはIntel Control-flow Enforcement Technology（CET）に基づく実装を提供しています。

@item -fstack-protector
@opindex fstack-protector
スタック破壊攻撃のようなバッファ溢れのチェックをする追加のコードを生成する。
これは攻撃されやすいオブジェクトのあらう関数にガード変数を加えることで行われる。
これは@code{alloca}を呼ぶ関数、8バイトより大きなバッファを持つ関数が含まれる。
ガードは関数が入ったときに初期化され、関数が抜けるときにチェックされる。
もしガードチェックが失敗したらなば、エラーメッセージが出力されてプログラムが終了する。

@item -fstack-protector-all
@opindex fstack-protector-all
すべての関数が保護されることを除いて@option{-fstack-protector}と同様である。

@item -fstack-protector-strong
@opindex fstack-protector-strong
@option {-fstack-protector}に似ていますが、保護される追加の関数が含まれます---ローカル配列定義を持つ、またはローカルフレームアドレスへの参照を持つ関数。 スタックに実際に割り当てられている変数のみが考慮され、最適化された変数またはレジスターに割り当てられた変数はカウントされません。

@item -fstack-protector-explicit
@opindex fstack-protector-explicit
@option{-fstack-protector}と同様だが@code{stack_protect}属性を持つ関数のみを保護する。

@item -fstack-check
@opindex fstack-check
スタックの境界を超えないように検証するコードを生成する。このフラグをマルチスレッドで走る環境ならば指定すべきだが、
もしひとつしかスタックがないならばほとんどすべてのシステムで自動的にスタック溢れは検知されるので
単一スレッド環境ではめったに指定する必要はない。

このスイッチがチェックが実は、されることを矯正しないことに注意すべきである。オペレーティングシステムまたは言語ランタイムがそうしなければならない。スイッチは、コードの生成がそれらが拡張されているスタックを見ることを確実とするようにさせる。

文字列パラメータをさらに指定することができる：
@samp{no}はチェックしないことを意味し、@samp{generic}手段は旧式なチェックの使用を強制し、
@samp{specific}は最高のチェック方法を意味し、裸の@option{-fstack-check}に等しい。

旧式なチェックは、コンパイラでの特定のターゲットのサポートを要求しない一般的なメカニズムであるが、以下の欠点がある。

@enumerate
@item
大きなオブジェクトへの修正された割り当て戦略。それらはもし固定しきい値をサイズが超えるならば常に動的に割り当てられる。これはコードの意味を変えるかもしれないことに注意。

@item
関数の静的フレームのサイズの固定値制限。それが特定の関数によって上回られるとき、スタック・チェックは信頼できず、
警告はコンパイラによって発される。

@item
非効率性。修正された割り当て戦略と汎用の実装のために、コードパフォーマンスは妨げられる。
@end enumerate

旧式スタックチェックはもしコンパイラでターゲットサポートが加えられないならば、@samp{specific}の代替方法でもあることに注意。

@samp{-fstack-check=}は、Adaが無限再帰とスタックオーバーフローを検出する必要があるために設計されています。 @samp{specific}は、Adaコードをコンパイルする際の優れた選択肢です。 スタッククラッシュ攻撃から保護するには、一般的には十分ではありません。 @samp{-fstack-clash-protection}を使用してこれらを保護します。

@item -fstack-clash-protection
@opindex fstack-clash-protection
スタッククラッシュスタイルの攻撃を防ぐためのコードを生成します。 このオプションを有効にすると、コンパイラーは一度に1ページのスタックスペースのみを割り当て、各ページは割り当て直後にアクセスされます。 したがって、オペレーティングシステムによって提供されるスタックガードページを飛び越えて割り当てられるのを防ぎます。

ほとんどのターゲットはスタック衝突保護を完全にはサポートしていません。 ただし、これらのターゲットでは、@option{-fstack-clash-protection}は動的スタック割り当てを保護します。 ターゲットが@option{-fstack-check=specific}をサポートしている場合、@option{-fstack-clash-protection}は、静的スタック割り当ての保護を制限することもできます。

@item -fstack-limit-register=@var{reg}
@itemx -fstack-limit-symbol=@var{sym}
@itemx -fno-stack-limit
@opindex fstack-limit-register
@opindex fstack-limit-symbol
@opindex fno-stack-limit
スタックが特定の値、レジスタの値かシンボルのアドレスを超えないことを確かめるコードを生成する。
もしより大きなスタックが必要ならば、実行時シグナルが発せられる。大抵のターゲットで、
シグナルはスタックが境界を超える前に発せられるので、特別な予防策なしでシグナルを捕捉することは可能である。

例えば、もしスタックが絶対アドレス@samp{0x80000000}で始まり下方に成長するならば、
フラグ@option{-fstack-limit-symbol=__stack_limit}と@option{-Wl,--defsym,__stack_limit=0x7ffe0000}を
スタック制限を128KBに強制するために使うことができる。
これはGNUリンカでのみ働くかもしれないことに注意。

@code{no_stack_limit}関数属性(@pxref{Function Attributes})を使ってスタック制限チェックを局所的に上書きすることができる。

@item -fsplit-stack
@opindex fsplit-stack
スタックを溢れる前に自動的に分割するコードを生成する。結果のプログラムはプログラムがこれ以上メモリを割り当てられない
場合に限り溢れる非連続のスタックになる。これはスレッド化されたプログラムで一番有用である。なぜならもはやそれぞれで適切なスタックサイズを
計算する必要がないためである。これは現在GNU/Linuxで走るx86ターゲットでのみ実装されている。

@option{-fsplit-stack}でコンパイルされたコードが@option{-fsplit-stack}なしでコンパイルされたコードを呼ぶとき、
後者が走る利用可能なスタック空間があまりないかもしれない。もしライブラリコードを含めて、
@option{-fsplit-stack}ですべてのコードをコンパイルすることがオプションでないならば、
リンカはそれらの呼び出しを@option{-fsplit-stack}が常に大きなスタックを持つように修正できる。
これのサポートはGNU binutilsリリース2.21以降のgoldリンカで実装されている。

@item -fvtable-verify=@r{[}std@r{|}preinit@r{|}none@r{]}
@opindex fvtable-verify
このオプションはC++コードをコンパイルするときだけ利用可能である。それは仮想呼び出しごとに、
呼び出しがなされるvtableポインタがオブジェクトの型が正当であり、
破壊されていないか上書きされていないことを、実行時で確かめるセキュリティ機能をオンにする
（もしくは、@option{-fvtable-verify=none}を使ってオフにする）。
もし実行時に不正なvtableポインタを検知したらならば、エラーが報告され、プログラムの実行が直ちに停止される。

このオプションはプログラム開始時に実行時データ構造が構築されるようにし、それはvtableポインタを検証するために使われる。
オプション@samp{std}と@samp{preinit}はいつそれらのデータ構造が構築されるかのタイミングを制御する。両方の場合で
データ構造は実行が@code{main}に達する前に構築される。@option{-fvtable-verify=std}を使うと
データ構造は共有ライブラリがロードされて初期化された後に構築される。
@option{-fvtable-verify=preinit}はそれらが共有ライブラリがロードされて初期化される前に構築されるようにする。

もしこのオプションがコマンドラインで複数回現れ、異なる値が指定されるならば、@samp{none}が、@samp{std}と@samp{preinit}よりも優先される。
@samp{preinit}が@samp{std}よりも優先される。

@item -fvtv-debug
@opindex fvtv-debug
@option{-fvtable-verify=std}および@option{-fvtable-verify=preinit}とともに使われるとき、それはvtable確認機能のための
ランタイム関数のデバッグ・バージョンを呼ばれるようにする。このフラグはまた、コンパイラをそれがクラスごとにどのvtableポインタを
見つけるかという情報を記録するようにもする。
この情報はもし定義されていたら環境変数@env{VTV_LOGS_DIR}の名前のディレクトリ、さもなければ現在の作業ディレクトリの
@file{vtv_set_ptr_data.log}という名前のファイルに書かれる。

注意：この機能はログファイルにデータを@emph{加える}。もし新鮮なログファイルがほしいならば、既存のファイルを確実に削除すべきである。

@item -fvtv-counts
@opindex fvtv-counts
これはデバッグフラグである。@option{-fvtable-verify=std}および@option{-fvtable-verify=preinit}とともに使われるとき、
これは、コンパイラをそれが遭遇する仮想呼び出しの総数とそれが挿入する確認の数の経過を追うようにする。
それは、挿入する特定のランタイムライブラリ関数に呼び出しの数を数えて、各々のコンパイル単位でこの情報も記録する。
この情報はもし定義されていたら環境変数@env{VTV_LOGS_DIR}の名前のディレクトリ、さもなければ現在の作業ディレクトリの
@file{vtv_count_data.log}という名前のファイルに書かれる。それはさらにクラスごとにvtableポインタ・セットの寸法を数えて、
同じディレクトリに@file{vtv_class_set_sizes.log}にこの情報を書く。

注意：この機能はログファイルにデータを@emph{加える}。もし新鮮なログファイルがほしいならば、既存のファイルを確実に削除すべきである。

@item -finstrument-functions
@opindex finstrument-functions
関数の入り口と出口に計装呼び出しを生成する。関数呼び出しの直前と直後に、以下のプロファイル関数が
現在の関数のアドレスと呼び出し場所をともなって呼ばれる。（あるプラットフォームでは、
@code{__builtin_return_address}が現在の関数を超えて働かないので、それ以外では呼び出し場所情報はプロファイル関数に対しては
利用可能でないかもしれない）

@smallexample
void __cyg_profile_func_enter (void *this_fn,
                               void *call_site);
void __cyg_profile_func_exit  (void *this_fn,
                               void *call_site);
@end smallexample

最初の引数は現在の関数の先頭のアドレスで、シンボルテーブルで正確に見つけることができる。

この計装は、他の関数でインライン展開された関数にもされる。インライン関数が、概念的に、どこで入れられて、出たかについて、
プロファイリング呼び出しは示す。これは、そのような関数のアドレス指定可能なバージョンは利用できなければならないことを意味する。
関数のあなたのすべての活用法が展開されたインラインであるならば、これはコード・サイズの更なる膨張を意味するかもしれない。
あなたがあなたのCコードで@code{extern inline}を使うならば、そのような関数のアドレス指定可能なバージョンは提供されなければならない。
（これはいずれにしろ通常本当であるが、あなたが幸運で、最適化器が常に関数をインライン展開するならば、
あなたは静的コピーを提供することなく来るかもしれない。）

関数は属性@code{no_instrument_function}を与えることができ、その場合にはこの計装は行われない。
これは、多々追えば、上に並べたプロファイル関数、高優先度割り込みルーチン、プロファイル関数を安全に呼ぶことができない関数
（多分、もしプロファイルルーチンが出力やメモリ割り当てを行うならば、シグナルハンドラ）に対して使うことができる。

@item -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{}
@opindex finstrument-functions-exclude-file-list

計装（@option{-finstrument-functions}の説明を見よ）から除外される関数のリストをセットする。
関数定義を含むファイルが@var{file}の1つと合うならば、その関数は計装されない。
マッチは、部分文字列の上でされる：@var{file}パラメータがファイル名の部分文字列であるならば、それはマッチであると考えられる。

例えば：

@smallexample
-finstrument-functions-exclude-file-list=/bits/stl,include/sys
@end smallexample

@noindent
はそのパス名が@file{/bits/stl}および@file{include/sys}であるファイルに定義されたインライン関数を除外する。

もし、ある理由で、文字@samp{,}を@var{sym}の一つに含めたいならば、@samp{\,}と書く。例えば、
@option{-finstrument-functions-exclude-file-list='\,\,tmp'}（オプションを囲む単一引用符に注意）

@item -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{}
@opindex finstrument-functions-exclude-function-list

これは@option{-finstrument-functions-exclude-file-list}と類似しているが、
このオプションは計装から除外される関数名のリストをセットする。
マッチされる関数名は、そのユーザー見える名前（例えば@code{vector<int> blah(const vector<int> &)}）であって、
内部のマングルされた名前（例えば、@code{_Z4blahRSt6vectorIiSaIiEE}）でない。
マッチは、部分文字列の上でされる：@var{sym}パラメータが関数名の部分文字列であるならば、それはマッチであると考えられる。
C99とC++拡張された識別子では、関数名はUTF-8で与えられていなければならない。そして、一般的な文字名を使用しない。

@item -fpatchable-function-entry=@var{N}[,@var{M}]
@opindex fpatchable-function-entry
各関数の先頭に@var{N} NOPを生成し、@var{M}番目のNOPの前に関数のエントリポイントを置きます。 @var{M}を省略すると、デフォルトで@code{0}になるため、関数のエントリは最初のNOPにあるアドレスを指します。 NOP命令は、コードセグメントが書き込み可能であれば、実行時に任意のインストルメンテーションにパッチを適用するために使用できる余分なスペースを予約します。 スペースの量は、NOPの数を介して間接的に制御できます。 使用されるNOP命令は、内部GCCバックエンドインターフェイス@code{gen_nop}によって発行される命令に対応しています。 この動作はターゲット固有であり、アーキテクチャバリアントや他のコンパイルオプション、あるいはその両方によって異なる場合があります。

実行時の識別のために、それぞれの関数エントリから@var{M}を引いたものに対応するこれらの領域の開始アドレスが、結果のバイナリの@code{__patchable_function_entries}セクションに追加で収集されます。

@code{__attribute__((patchable_function_entry(N,M)))}の値は、コマンドラインオプション@option{-fpatchable-function-entry=N,M}よりも優先されることに注意してください。 これを使用して、領域サイズを大きくしたり、単一の関数で領域を完全に削除したりできます。 @code{N = 0}の場合、パッド位置は記録されません。

NOP命令は、プロローグよりも前であっても、関数のエントリアドレス(@var{M}に応じて、その前かもしれない）に挿入されます。

@end table


@node Preprocessor Options
@section プリプロセッサを制御するオプション
@cindex preprocessor options
@cindex options, preprocessor

これらのオプションはCプリプロセッサを制御する。そして、それは実際のコンパイルの前に各々のCソース・ファイルで動く。

あなたが@option{-E}オプションを使用するならば、何もプリプロセス以外はされない。
プリプロセッサ出力を実際のコンパイルに不適当であるようにするので、これらのオプションのいくらかは@option{-E}と共にだけ意味をなす。

ここに挙げたオプションに加えて、@ref{Directory Options}に記述されているインクルードファイルの検索パスを制御するオプションがいくつかあります。プリプロセッサ診断を制御するオプションは、@ref{Warning Options}にリストされている。.

@table @gcctabopt
@include cppopts.texi

@item -Wp,@var{option}
@opindex Wp
コンパイラ・ドライバを回避して、プリプロセッサに直接オプションを渡すために、
@option{-Wp,@var{option}}を使うことができる。オプションがコンマを含むならば、
それはコンマで複数のオプションに分けられる。しかし、多くのオプションはプリプロセッサに渡される前に
コンパイラ・ドライバによって修正されるか、翻訳されるか、解釈される、そして、@option{-Wp}はこの段階を強制的に回避する。

@item -Xpreprocessor @var{option}
@opindex Xpreprocessor
@var{option}をオプションとしてプリプロセッサに渡す。これをGCCが認識しないシステム固有のプリプロセッサオプションを提供するために
使うことができる。

もし引数を取るオプションを渡したいならば、@option{-Xpreprocessor}を二度、オプションとその引数で一度ずつ渡さなくてはならない。

@item -no-integrated-cpp
@opindex no-integrated-cpp
コンパイルの前に別のパスとしてプリプロセスを行う。デフォルトでは、GCCは入力トークン化とパースの組み込まれた一部として
プリプロセスを行う。もしこのオプションが提供されたなら、適切な言語フロントエンド
(C、C++、Objective-Cにそれぞれ対応して@command{cc1}, @command{cc1plus}, @command{cc1obj})が代わりに二度呼ばれ、
一度はプリプロセスだけのために、もう一度はプリプロセスされた入力の実際のコンパイルのために呼ばれる。
このオプションは@option{-B}か@option{-wrapper}オプションと組み合わせて、代替のプリプロセッサを指定するか、
通常のプリプロセスとコンパイルの間に追加の処理を行うときに役立つ。

@item -flarge-source-files
@opindex flarge-source-files
コンパイルが遅くなり、メモリ使用量が増えるという犠牲を払って、大きなソースファイルを期待するようにGCCを調整します。

具体的には、GCCは通常、ソースファイル内の列番号と行番号の両方を追跡し、通常、診断でこれらの番号の両方を出力します。 ただし、特定の数のソース行を処理すると、列番号の追跡を停止し、行番号のみを追跡します。 これは、後の行の診断に列番号が含まれないことを意味します。 また、@option{-Wmisleading-indentation}のようなオプションはその時点で機能しなくなりますが、これが発生するとコンパイラはメモを出力します。 @option{-flarge-source-files}を渡すと、GCCが列の追跡を停止する前に処理できるソース行の数が大幅に増加します。

@end table

@node Assembler Options
@section アセンブラに渡すオプション

@c prevent bad page break with this line
アセンブラにオプションを渡すことができる。

@table @gcctabopt
@item -Wa,@var{option}
@opindex Wa
アセンブラへのオプションとして@var{option}を渡す。もし@var{option}がコンマを含むなら、コンマで複数のオプションに分割する。

@item -Xassembler @var{option}
@opindex Xassembler
アセンブラにオプションとして@var{option}を渡す。これをGCCにが理解しないシステム固有のアセンブラオプションを提供するために使うことができる。

もし引数を取るオプションを渡したいときは、@option{-Xassembler}を二度使わなければならない。オプションで一度と、引数で一度。

@end table

@node Link Options
@section リンクのオプション
@cindex link options
@cindex options, linking

これらのオプションはコンパイラがオブジェクトファイルを実行可能出力ファイルへとリンクするときに役割を演じるものである。
それらはもしコンパイラがリンク段階まで行かないならば役に立たない。

@table @gcctabopt
@cindex file names
@item @var{object-file-name}
特別に認識される接尾辞で終わらないファイル名はオブジェクトかライブラリの名前とみなされる。（オブジェクトファイルは
リンカによってファイルの中身からライブラリと区別される）。もしリンクが行われたならば、それらのオブジェクトファイルはリンカへの入力
として使われる。

@item -c
@itemx -S
@itemx -E
@opindex c
@opindex S
@opindex E
もしこれらのオプションが使われるなら、リンカは走らないので、オブジェクトファイル名は引数として使われるべきではない。
@xref{Overall Options}.

@item -flinker-output=@var{type}
@opindex flinker-output
このオプションは、リンク時オプティマイザのコード生成を制御します。 デフォルトでは、リンカー出力はリンカープラグインによって自動的に決定されます。 コンパイラをデバッグする場合、および非LTOオブジェクトファイルとのインクリメンタルリンクが必要な場合は、タイプを手動で制御すると便利な場合があります。

@var{type}が@samp{exec}の場合、コード生成は静的バイナリを生成します。 この場合、@option{-fpic}と@option{-fpie}はどちらも無効になります。

@var{type}が@samp{dyn}の場合、コード生成により共有ライブラリが作成されます。 この場合、@option{-fpic}または@option{-fPIC}は保持されますが、自動的に有効にはなりません。 これにより、位置に依存しないコードを使わずに、これが可能なアーキテクチャ、つまりx86上で共有ライブラリを構築できます。

@var{type}が@samp{pie}の場合、コード生成は@option{-fpie}実行可能ファイルを生成します。 これにより、@samp{exec}と同様の最適化が行われますが、コンパイル時に指定された場合、@option{-fpie}は無効にされません。

@var{type}が@samp{rel}の場合、コンパイラはインクリメンタルリンクが行われたと見なします。 リンク時の最適化のための中間コードを含むセクションは、マージされ、事前に最適化され、結果のオブジェクトファイルに出力されます。 さらに、@option{-ffat-lto-objects}が指定されている場合、将来の非LTOリンク用にバイナリコードが生成されます。 インクリメンタルリンクによって生成されるオブジェクトファイルは、同じオブジェクトファイルから生成される静的ライブラリよりも小さくなります。 リンク時に、ライブラリ内のオブジェクトの大部分が使用されていると仮定すると、インクリメンタルリンクの結果は静的ライブラリよりも速く読み込まれます。

最後に、@samp{nolto-rel}は、コード生成が強制され、最終的なバイナリが生成され、後でリンク時の最適化のための中間コードが取り除かれるインクリメンタルリンク用にコンパイラーを構成します。 複数のオブジェクトファイルをリンクすると、リンク時の最適化を無効にした場合よりもコードが最適化されます（たとえば、モジュール間のインライン化が発生します）が、プログラム全体の最適化の利点のほとんどは失われます。

（@option{-r}による）インクリメンタルリンク中、リンカープラグインはデフォルトで@option{rel}になります。 ただし、GNU Binutilsへの現在のインターフェースでは、LTOオブジェクトと非LTOオブジェクトを1つの混合オブジェクトファイルに段階的にリンクすることはできません。 インクリメンタルリンクのオブジェクトファイルのいずれかがリンク時の最適化に使用できない場合、リンカープラグインは警告を発行し、@samp{nolto-rel}を使用します。 プログラム全体の最適化を維持するには、そのようなオブジェクトを静的ライブラリにリンクすることをお勧めします。 または、H.J.Luのbinutilsと混合オブジェクトのサポートを使用することもできます。

@item -fuse-ld=bfd
@opindex fuse-ld=bfd
デフォルトリンカの代わりに@command{bfd}を使う。

@item -fuse-ld=gold
@opindex fuse-ld=gold
デフォルトリンカの代わりに@command{gold}を使う。

@item -fuse-ld=lld
@opindex fuse-ld=lld
デフォルトリンカの代わりにLLVM @command{lld}を使う。

@cindex Libraries
@item -l@var{library}
@itemx -l @var{library}
@opindex l
リンク時に@var{library}という名前のライブラリを探す。（別の引数としてライブラリを渡す
第2の選択肢はPOSIX適合としてのみのためであり、推奨されない。）

@option{-l}オプションは、GCCによってリンカーに直接渡されます。 正確な詳細については、リンカのドキュメントを参照してください。 以下の一般的な説明は、GNUリンカーに適用されます。

リンカは、ディレクトリの標準リストでライブラリを検索します。 検索されるディレクトリには、いくつかの標準システムディレクトリに加えて、@option{-L}で指定したディレクトリが含まれます。

静的ライブラリはオブジェクトファイルのアーカイブであり、@file{lib@var{library}.a}のようなファイル名を持っています。 一部のターゲットは、共有ライブラリもサポートしています。共有ライブラリは通常、@file{lib@var{library}.so}のような名前です。 静的ライブラリと共有ライブラリの両方が見つかった場合、@option{-static}オプションが使用されていない限り、リンカは共有ライブラリとのリンクを優先します。

コマンドのどこにこのオプションを書くかによって違いが生じます。 リンカは、指定された順序でライブラリとオブジェクトファイルを検索して処理します。 したがって、@samp{foo.o -lz bar.o}は、ファイル@file{foo.o}の後、@file{bar.o}の前にライブラリ@samp{z}を検索します。 @file{bar.o}が@samp{z}の関数を参照している場合、それらの関数はロードされない可能性があります。

@item -lobjc
@opindex lobjc
Objective-CやObjective-C++プログラムをリンクするためには@option{-l}オプションのこの特別な場合が必要である。

@item -nostartfiles
@opindex nostartfiles
リンク時に標準システムスタートアップファイルを使わない。@option{-nostdlib}または@option{-nodefaultlibs}
が使われない限り、標準システムライブラリは通常使われる。

@item -nodefaultlibs
@opindex nodefaultlibs
リンク時に標準システムライブラリを使わない。指定されたライブラリだけがリンカに渡され、
@option{-static-libgcc}のようなシステムライブラリのリンケージを指定するオプションは無視される。
@option{-nostartfiles}が使われない限り、標準スタートアップファイルは通常使われる。

コンパイラは@code{memcmp}、@code{memset}、@code{memcpy}、@code{memmove}への呼び出しを生成するかもしれない。
これらのエントリは通常libcのエントリによって解決される。これらのエントリポイントはこのオプションを指定したときは
他のメカニズムを通して提供されるべきである。

@item -nolibc
@opindex nolibc
リンク時には、Cライブラリまたはシステムライブラリと密結合したシステムライブラリを使用しない。 スタートアップファイル、@file{libgcc}、または@file{libgnat}、@file{libgfortran}、@file{libstdc++}などのツールチェーンが提供する言語サポートライブラリとはまだリンクします。 これにより、通常、リンクコマンドラインから@option{-lc}が削除され、また、通常はそれに付随し、Cライブラリがないと想定されると意味がなくものも削除されます。たとえば、@option{-lpthread}または 一部の構成では@option{-lm}。 これは、実際に使用可能なCライブラリがない場合のベアボードターゲットを対象としています。

@item -nostdlib
@opindex nostdlib
リンク時に標準システムスタートファイルもライブラリも使わない。
スタートアップファイルはなく、指定したライブラリのみがリンカに渡され、
@option{-static-libgcc}および@option{-shared-libgcc}のような、システムライブラリのリンケージを指定するオプションは無視される。

コンパイラは@code{memcmp}、@code{memset}、@code{memcpy}、@code{memmove}への呼び出しを生成するかもしれない。
これらのエントリは通常libcのエントリによって解決される。これらのエントリポイントはこのオプションを指定したときは
他のメカニズムを通して提供されるべきである。

@cindex @option{-lgcc}, use with @option{-nostdlib}
@cindex @option{-nostdlib} and unresolved references
@cindex unresolved references and @option{-nostdlib}
@cindex @option{-lgcc}, use with @option{-nodefaultlibs}
@cindex @option{-nodefaultlibs} and unresolved references
@cindex unresolved references and @option{-nodefaultlibs}
@option{-nostdlib}とoption{-nodefaultlibs}によって迂回される標準ライブラリの一つは@file{libgcc.a}であり、
GCCが特定の機種の欠点を克服するため、および、ある言語での特別に必要になるために使う内部サブルーチンのライブラリである。
(@file{libgcc.a}の詳しい議論は@xref{Interface,,Interfacing to GCC Output,gccint,GNU Compiler Collection (GCC) Internals})
大抵の場合は、他の標準ライブラリを避けたい場合でも@file{libgcc.a}は必要である。言い換えると、
@option{-nostdlib}および@option{-nodefaultlibs}を指定するときには、通常は@option{-lgcc}も同様に指定すべきである。
これは内部GCCライブラリサブルーチンへの未解決のシンボルがないことを保証する。
(そのような内部サブルーチンの例は@code{__main}で、C++のコンストラクタが呼ばれることを保証するために使われる。
 @pxref{Collect2,,@code{collect2}, gccint, GNU Compiler Collection (GCC) Internals}.)

@item -e @var{entry}
@itemx --entry=@var{entry}
@opindex e
@opindex entry

プログラムのエントリポイントが@var{entry}であることを指定します。 引数はリンカによって解釈されます。 GNUリンカーは、シンボル名またはアドレスのいずれかを受け入れます。

@item -pie
@opindex pie
それをサポートするターゲット上で動的にリンクされた位置独立実行可能ファイルを生成する。 予測可能な結果を得るには、このリンカオプションを指定するときに、コンパイルに使用するのと同じオプションセット（@option{-fpie}、@option{-fPIE}、またはモデルサブオプション）も指定する必要がある。
  
@item -no-pie
@opindex no-pie
動的にリンクされた位置独立実行可能ファイルを生成しない。
 
@item -static-pie
@opindex static-pie
それをサポートするターゲット上で静的位置独立実行可能ファイルを生成する。 静的位置独立実行可能ファイルは静的実行可能ファイルに似ているが、ダイナミックリンカなしで任意のアドレスにロードできる。予測可能な結果を得るには、コンパイルに使用するのと同じオプションセットも指定する必要がある（@option{-fpie}、@option{-fPIE}、またはmodelサブオプション）を指定する。

@item -pthread
@opindex pthread
POSIXスレッドライブラリとのリンク。 このオプションは、GNU/Linuxターゲット、その他のほとんどのUnix派生物、x86 CygwinおよびMinGWターゲットでもサポートされている。 いくつかのターゲットでは、このオプションはプリプロセッサのフラグも設定するので、コンパイルとリンクの両方に一貫して使用する必要がある。

@item -r
@opindex r
再配置可能なオブジェクトを出力として生成します。 これは部分リンクとも呼ばれます。

@item -rdynamic
@opindex rdynamic
それをサポートするターゲットで、フラグ@option{-export-dynamic}をELFリンカに渡す。
これはリンカに、動的シンボルテーブルに、使われるものだけでなく、全シンボルを加えるように指示する。
このオプションは@code{dlopen}のある使用法や、プログラム内からバックトレースを得ることを可能にするために必要である。

@item -s
@opindex s
実行ファイルからすべてのシンボルテーブルと再割り当て情報を取り除く。

@item -static
@opindex static
動的リンクをサポートするシステムで、@option{-pie}を上書きして共有ライブラリへのリンクを防ぐ。他のシステムでは、このオプションには効果がない。

@item -shared
@opindex shared
実行ファイルから他のオブジェクトとリンクできる共有オブジェクトを生成する。すべてのシステムがこのオプションをサポートする
わけではない。予測可能な結果のためには、
このリンカオプションを指定するときにはコンパイルで使われたのと同じオプション集合
(@option{-fpie}, @option{-fPIE},およびモデルサブオプション）も指定しなければならない。
@footnote{あるシステムでは、@samp{gcc -shared}はコンストラクタが働くためには余分なスタブコードをビルドする必要がある。
複数ライブラリのシステムでは、@samp{gcc -shared}はそれに対してリンクするための正しいサポートライブラリ選択しなくてはならない。
正しいフラグの提供に失敗すると些細な欠陥を引き起こすかもしれない。それらが必要でない場合、それらを供給することは無害である。}

@item -shared-libgcc
@itemx -static-libgcc
@opindex shared-libgcc
@opindex static-libgcc
共有ライブラリとして@file{libgcc}を提供するシステムで、これらのオプションは
それぞれ共有・静的バージョンの使用を強制する。もしコンパイラが設定されたときに
@file{libgcc}の共有バージョンがなければ、これらのオプションには効果がない。

アプリケーションが静的バージョンの代わりに共有@file{libgcc}を使うべき幾つかの状況がある。
それらの最も一般的なものはアプリケーションが異なる共有ライブラリをまたいで例外を投げて受け取りたいときである。
その倍位には、アプリケーション自身と同様にそれぞれのライブラリでも共有の@file{libgcc}を使うべきである。

したがって、G++とドライバは共有ライブラリおよびメイン実行ファイルをビルドするときはいつでも
自動的に@option{-shared-libgcc}を加える。なぜならC++プログラムは典型的に例外を使い、したがってこれはして正しいことだからである。

かわりに、もし共有ライブラリを作るのにGCCにドライバを使うなら、常に共有@file{libgcc}でリンクされるわけではないことに気づくかもしれない。
もしGCCは設定時に、非GNUリンカかオプション@option{--eh-frame-hdr}をサポートしないGNUリンカを持つとわかるなら、
デフォルトで共有ライブラリに@file{libgcc}の共有バージョンをリンクする。さもなければ、リンカの利点を取って
@file{libgcc}の共有バージョンのリンクを最適化でなくす。これはライブラリロード時の再配置コストを負うことなく、
そのような共有ライブラリを通して例外が伝搬することを可能にする。

しかし、もしライブラリかメイン実行ファイルが例外を投げるか受け取るならば、それが共有@file{libgcc}でリンクされるように、
プログラムで使われる言語に適切であるように、G++ドライバを使ってリンクしなければならないか、オプション@option{-shared-libgcc}を用いて
リンクしなければならない。

@item -static-libasan
@opindex static-libasan
@option{-fsanitize=address}オプションがプログラムをリンクするために使われるときに、
GCCドライバは自動的に@option{libasan}に対してリンクする。もし@file{libasan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libasan}の共有バージョンに対してリンクする。
@option{-static-libasan}オプションはGCCドライバに@file{libasan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-libtsan
@opindex static-libtsan
@option{-fsanitize=thread}オプションがプログラムをリンクするために使われるときに、
GCCドライバは自動的に@option{libtsan}に対してリンクする。もし@file{libtsan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libtsan}の共有バージョンに対してリンクする。
@option{-static-libtsan}オプションはGCCドライバに@file{libtsan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-liblsan
@opindex static-liblsan
@option{-fsanitize=leak}オプションがプログラムをリンクするために使われるときに、
GCCは自動的に@option{liblsan}に対してリンクする。もし@file{liblsan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{liblsan}の共有バージョンに対してリンクする。
@option{-static-liblsan}オプションはGCCドライバに@file{liblsan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-libubsan
@opindex static-libubsan
@option{-fsanitize=undefined}オプションがプログラムをリンクするために使われるときに、
GCCドライバは自動的に@option{libubsan}に対してリンクする。もし@file{libubsan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libubsan}の共有バージョンに対してリンクする。
@option{-static-libubsan}オプションはGCCドライバに@file{libubsan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-libstdc++
@opindex static-libstdc++
@command{g++}プログラムがC++プログラムをリンクするために使われるとき、
通常は@option{libstdc++}に対して自動的にリンクする。
もし@file{libstdc++}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libstdc++}の共有バージョンに対してリンクする。
これは通常はよい。しかし、時々完全に静的リンクをすることなしにプログラムで使われる@file{libstdc++}のバージョンを
固定することが役立つ。@option{-static-libstdc++}オプションは@command{g++}ドライバに@file{libstdc++}を静的にリンクして、
他のライブラリを静的にリンクする必要をなくす。

@item -symbolic
@opindex symbolic
共有オブジェクトに結合するときにグローバルシンボルへの参照を結合させる。
（リンクエディタオプション@option{-Xlinker -z -Xlinker defs}によって上書きされない限り）
未解決の参照について警告する。少しのシステムだけがこのオプションをサポートしている。

@item -T @var{script}
@opindex T
@cindex linker script
リンカスクリプトとして@var{script}を使う。このオプションはGNUリンカを使う大抵のシステムではサポートされている。
オペレーションシステムのないベアボードターゲットのような、あるターゲットでは、@option{-T}オプションは
リンク時に未解決のシンボルへの参照を避けるために要求されるかもしれない。

@item -Xlinker @var{option}
@opindex Xlinker
@var{option}をリンカへのオプションとして渡す。これをGCCのが認識しないシステム固有のリンカオプションを提供するために使うことができる。

もし引数を取るオプションを渡したいときは、@option{-Xlinker}を二度使わなければならない。オプションで一度と、引数で一度。
例えば、@option{-assert definitions}を渡したいときは、@option{-Xlinker -assert -Xlinker definitions}を書かなければならない。
@option{-Xlinker "-assert definitions"}と書くのは働かない。なぜなら、これは全体の文字列を単一の引数として文字列で渡し、
それはリンカが期待するものではないからである。

GNUリンカを使うときは、別れた引数よりは@option{@var{option}=@var{value}}構文を使ってリンカオプションに引数を渡すほうが通常は便利である。
例えば、@option{-Xlinker -Map=output.map}を@option{-Xlinker -Map -Xlinker output.map}ではなく指定する。他のリンカはコマンドラインオプションに
この構文をサポートしていないかもしれない。

@item -Wl,@var{option}
@opindex Wl
@var{option}をリンカに渡すオプションとして渡す。もし、@var{option}がコンマを含むなら、コンマでオプションを分割する。
この構文をオプションへの力数を渡すために使うことができる。例えば、@option{-Wl,-Map,output.map}は
リンカに@option{-Map output.map}を渡す。GNUリンカを使うときは、@option{-Wl,-Map=output.map}でも同じ効果を得ることができる。

@item -u @var{symbol}
@opindex u
シンボルが@var{symbol}が未定義だと装い、それを定義したライブらいモジュールのリンクを強制する。
追加のライブラリモジュールのロードを強制するために異なるシンボルに対して複数回@option{-u}を使うことができる。

@item -z @var{keyword}
@opindex z
@option{-z}はキーワード@var{keyword}を伴ってリンカに直接渡される。許される値とその意味はリンカの文書の節を見よ。
@end table

@node Directory Options
@section ディレクトリ検索のオプション
@cindex directory options
@cindex options, directory search
@cindex search path

これらのオプションはヘッダファイル、ライブラリ、コンパイラの部品の検索ディレクトリを指定する。

@table @gcctabopt
@include cppdiropts.texi

@item -iplugindir=@var{dir}
@opindex iplugindir=
プラグインを検索するディレクトリを@option{-fplugin=@var{path}/@var{name}.so}の代わりに
@option{-fplugin=@var{name}}によって渡されたものにセットする。このオプションはユーザによって使われるものではなく、
ドライバによってのみ渡されることを意図している。

@item -L@var{dir}
@opindex L
@option{-l}のために検索されるディレクトリのリストに@var{dir}ディレクトリを加える。

@item -B@var{prefix}
@opindex B
このオプションは実行ファイル、ライブラリ、インクルードファイル、コンパイラ自身のデータファイルを検索する場所を指定する。

コンパイラドライバプログラムは副プログラム@command{cpp}、@command{cc1}、@command{as}、@command{ld}の1つ以上を走らせる。
それは走らせようとするそれぞれのプログラムの接頭辞として@var{prefix}を、対応するターゲット機種とコンパイラバージョンで
@samp{@var{machine}/@var{version}/}をありとなしの両方で試す。

それぞれの副プログラムを走らせるために、コンパイラドライバは最初に、もしあれば@option{-B}接頭辞を試す。
もし名前が見つからないか、@option{-B}が指定されていなければ、ドライバは2つの標準接頭辞
@file{/usr/lib/gcc/}と@file{/usr/local/lib/gcc/}を試す。もし見つかったファイル名ないのそれらの結果のどちらもなければ、
未修正のプログラム名が@env{PATH}環境変数内で指定されたディレクトリを使って検索される。

コンパイラは@option{-B}で提供されるパスがディレクトリを参照しているかをチェックし、もし必要ならパスの末尾にディレクトリ分離文字を加える。

コンパイラがリンカのためにこれらのオプションから@option{-L}オプションに変換するので、
ディレクトリ名も効果的に指定する@option{-B}接頭辞はリンカでライブラリに適用される。
コンパイラがプリプロセッサのためにこれらのオプションから@option{-isystem}オプションに変換するので、
それらもプリプロセッサのインクルードファイルに適用される。この場合、コンパイラは接頭辞に@samp{include}を追加する。

ランタイムサポートファイル@file{libgcc.a}も、もし必要なら@option{-B}接頭辞を使って検索されうる。もしそこで見つからなければ、
上の2つの標準接頭辞が試され、それですべてである。それがそれらの手段で見つからないならば、ファイルは関連から省かれる。

ほぼ@option{-B}接頭辞のような接頭辞を指定するもう一つの方法は、環境変数@env{GCC_EXEC_PREFIX}を使うことである。

特別なクラッジとして、もし@option{-B}で提供されたパスが@file{[dir/]stage@var{N}/}であり、ここで
@var{N}が0から9までの数値ならば、それは@file{[dir/]include}によって置換される。これはコンパイラの
ブートストラップを助けるためである。

@item -no-canonical-prefixes
@opindex no-canonical-prefixes
シンボリックリンクを展開せず、@samp{/../}および@samp{/./}への参照を解決せず、相対接頭辞を生成するときのパス絶対も作らない。

@item --sysroot=@var{dir}
@opindex sysroot
ヘッダとライブラリの論理ルートディレクトリとして@var{dir}を使う。例えば、
コンパイラが通常@file{/usr/include}と@file{/usr/lib}でのライブラリを検索するとき、
かわりに@file{@var{dir}/usr/include}と@file{@var{dir}/usr/lib}を検索する。

もしこのオプションと@option{-isysroot}オプションの両方を使ったならば、
@option{--sysroot}オプションはライブラリに適用され、@option{-isysroot}オプションはヘッダファイルに適用される。

GNUリンカ（2.16以降）はこのオプションの必須のサポートを持っている。もしリンカがこのオプションをサポートしないなら、
@option{--sysroot}のヘッダファイルの部分は動くが、ライブラリの部分は動かない。

@item --no-sysroot-suffix
@opindex no-sysroot-suffix
あるターゲットで、接尾辞は使われた他のオプションに依存して、@option{--sysroot}で指定されたルートディレクトリに加えられ、
ヘッダは例えば@file{@var{dir}/usr/include}の代わりに@file{@var{dir}/@var{suffix}/usr/include}で見つかるかもしれない。
このオプションはそのような接尾辞を無効にする。

@end table

@node Code Gen Options
@section コード生成規約オプション
@cindex code generation conventions
@cindex options, code generation
@cindex run-time options

これらはコード生成で使われるインターフェース規約を制御する機種独立のオプションである。

これらの殆どは肯定形と否定形がある。@option{-ffoo}の否定形は@option{-fno-foo}である。
以下の表で、形式の一つだけがリストされる。デフォルトでないほう。@samp{no-}を取り除くか加えることで
もう片方を得ることができる。

@table @gcctabopt
@item -fstack-reuse=@var{reuse-level}
@opindex fstack_reuse
このオプションは、ユーザー宣言されたローカル/自動変数とコンパイラ生成の一時値のスタック空間の再生利用を制御する。
@var{reuse_level}は、@samp{all}、@samp{named_vars}または@samp{none}であることができる。
@samp{all}はすべての局所変数と一時値のスタック再利用を使用可能にする、
@samp{named_vars}は名前のあるユーザー定義済みの局所変数だけの再利用を使用可能にする、
そして、@samp{none}は完全にスタック再利用を抑制する。デフォルト値は@samp{all}である。
プログラムがスコープを持つ局所変数の有効期間を拡張するか、コンパイラが言語によって定義される端点を超えて一時値を生成したとき、
オプションが必要である。変数の有効期間が終わるとき、そして、変数がメモリで生きるならば、生存範囲がそれと重ならない他の一時値または
スコープを持つ局所変数でそのスタック空間を再利用する自由が、最適化しているコンパイラにはある。
ローカル有効期間を拡張している古いコードは、スタック再利用最適化で破壊しうる。

例えば、

@smallexample
   int *p;
   @{
     int local1;

     p = &local1;
     local1 = 10;
     ....
   @}
   @{
      int local2;
      local2 = 20;
      ...
   @}

   if (*p == 10)  // local1のスコープ外使用
     @{

     @}
@end smallexample

他の例は:
@smallexample

   struct A
   @{
       A(int k) : i(k), j(k) @{ @}
       int i;
       int j;
   @};

   A *ap;

   void foo(const A& ar)
   @{
      ap = &ar;
   @}

   void bar()
   @{
      foo(A(10)); // 一時オブジェクトの有効期間はfooが返るときに終わる。

      @{
        A a(20);
        ....
      @}
      ap->i+= 10;  // スコープ外のap参照の空間はaで再利用される。ap->iの値は？
   @}

@end smallexample

コンパイラ生成の一時値テンポラリーの有効期間は、C++標準によってはっきりしている。
一時変数の有効期間が終わるとき、そして、一時変数がメモリで生きるならば、生存範囲がそれと重ならない他の一時値またはスコープ局所変数で
そのスタック空間を再利用する自由が、最適化しているコンパイラにはある。
どんなに一時値のスタック空間が再利用されない以前のコンパイラの作用に古いコードの一部が頼っても、
攻撃的スタック再利用はランタイム・エラーにつながりうる。このオプションは、一時的なスタック再利用最適化を制御するのに用いられる。

@item -ftrapv
@opindex ftrapv
このオプションは加算、減算、乗算操作での符号付き桁あふれにトラップを生成する。オプション@option{-ftrapv}と@option{-fwrapv}は
それぞれを上書きし、コマンドラインで@option{-ftrapv} @option{-fwrapv}を使うと@option{-fwrapv}が有効になる。
有効オプションのみが上書きするので、コマンドラインでの@option{-ftrapv} @option{-fwrapv} @option{-fno-wrapv}は
@option{-ftrapv}が有効なことに注意する。

@item -fwrapv
@opindex fwrapv
このオプションは、コンパイラが加算、減算、乗算の符号付き算術桁あふれが2の補数表現を使って循環すると仮定させる。
このフラグはある最適化を有効にして別のものを無効にする。このオプションはJavaフロントエンドでは、Java言語仕様で要求されているので
デフォルトである。オプション@option{-ftrapv}と@option{-fwrapv}は
それぞれを上書きし、コマンドラインで@option{-ftrapv} @option{-fwrapv}を使うと@option{-fwrapv}が有効になる。
有効オプションのみが上書きするので、コマンドラインでの@option{-ftrapv} @option{-fwrapv} @option{-fno-wrapv}は
@option{-ftrapv}が有効なことに注意する。

@item -fwrapv-pointer
@opindex fwrapv-pointer
このオプションは、加算および減算でのポインター算術オーバーフローが2の補数表現を使用してラップアラウンドすると想定するようにコンパイラーに指示します。 このフラグは、ポインターのオーバーフローが無効であると想定する一部の最適化を無効にします。

@item -fstrict-overflow
@opindex fstrict-overflow
このオプションは@option{-fno-wrapv} @option{-fno-wrapv-pointer}を意味し、否定された場合は@option{-fwrapv} @option{-fwrapv-pointer}を意味します。

@item -fexceptions
@opindex fexceptions
例外処理を有効にする。例外を伝搬するのに必要な追加のコードを生成する。
あるターゲットでは、これはGCCに全関数のフレーム巻き戻し情報を生成させることを暗示し、それはかなりのデータサイズオーバーヘッド
を生むが、実行には影響しない。もしこのオプションを指定しないならば通常は例外処理が必要なC++ののような言語ではデフォルトで有効にし、
C++ののような通常は必要としない言語では無効にする。しかし、C++で書かれた例外処理と適切に相互作用する必要があるCコードをコンパイルするときは
このオプションを有効にする必要があるかもしれない。もし例外処理を使わない古いC++プログラムをコンパイルするならばこのオプションを無効にしたいかもしれない。

@item -fnon-call-exceptions
@opindex fnon-call-exceptions
トラップ命令が例外を投げることを可能にするコードを生成する。これはプラットフォーム固有の必ずしもすべての場所では存在しない
ランタイムサポートが必要なことに注意する。さらに、これは@emph{_トラップ_}命令が例外を投げることしか許可しない。
すなわち、メモリ参照か浮動小数点命令である。@code{SIGALRM}のような任意のシグナルハンドラから投げられる例外は許可しない。

@item -fdelete-dead-exceptions
@opindex fdelete-dead-exceptions
例外を投げるかもしれないが、プログラムの実行にそれ以外は貢献しない命令は最適化で消えるかもしれないとみなす。
Ada言語仕様によって許されるように、このオプションはAdaフロントエンドではデフォルトで有効である。
死んだ例外を取り除かれるようにする最適化パスは、異なる最適化レベルで独立して使用可能にされる。

@item -funwind-tables
@opindex funwind-tables
@option{-fexceptions}と同様だが、必要な静的データだけを生成し、他の方法では生成されたコードに影響させないことを除く。
通常はこのオプションを有効にする必要はない。この扱いを必要とする言語プロセッサが代わりに有効にする。

@item -fasynchronous-unwind-tables
@opindex fasynchronous-unwind-tables
もしターゲット機種がサポートしていれば、DWARFフォーマットに巻き戻しテーブルを生成する。
テーブルはそれぞれの命令境界で正確なので、（デバッガやガベージコレクタのような）非同期イベントからの
スタック巻き戻しで使うことができる。

@item -fno-gnu-unique
@opindex fno-gnu-unique
最近のGNUアセンブラとCライブラリのあるシステムで、C++コードコンパイラは
@code{RTLD_LOCAL}のある場合でさえもテンプレート静的データメンバの定義とインライン関数の静的ローカル変数が唯一であることを保証するために
@code{STB_GNU_UNIQUE}結合を使う。これは、2つの異なる@code{RTLD_LOCAL}プラグインで、それらのうちの一つの依存しているものによって使われ、
それ故にシンボルの結合に関して食い違っているライブラリの問題を避けるために必要である。しかし、これは@code{dlclose}に影響を受けるDSOを
無視されるようにする。あなたのプログラムが@code{dlclose}と@code{dlopen}を通してDSOの最初期化に頼るならば、
あなたは@option{-fno-gnu-unique}を使うことができる。

@item -fpcc-struct-return
@opindex fpcc-struct-return
「短い」@code{struct}と@code{union}の値を長いもののように、レジスタではなくメモリで返す。この規約はあまり効率的ではないが、
GCCでコンパイルされたファイルと他のコンパイラ、特にPortable C Comipler(pcc)でコンパイルされたファイルとの相互運用を可能にする利点がある。

メモリで構造体を返す正確な規約はターゲット設定マクロに依存する。

短い構造体と共用体はそのサイズと境界がある整数型と一致するものである。

@strong{注意：} @option{-fpcc-struct-return}スイッチでコンパイルされたコードは@option{-freg-struct-return}スイッチでコンパイルされた
コードとはバイナリ互換性がない。それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -freg-struct-return
@opindex freg-struct-return
可能なときは@code{struct}と@code{union}値をレジスタで返す。これは@option{-fpcc-struct-return}よりも
小さい構造体ではより効率的である。

もし@option{-fpcc-struct-return}も@option{-freg-struct-return}も指定しないなら、GCCはデフォルトではどちらの規約かは
ターゲットの標準である。もし標準規約がないならば、GCCはデフォルトでは、GCCは主要コンパイラであるターゲットを除いて、
@option{-fpcc-struct-return}である。それらの場合では、標準を選び、代替として最も効率的なレジスタ返却を選ぶ。

@strong{注意：} @option{-freg-struct-return}スイッチでコンパイルされたコードは@option{-fpcc-struct-return}スイッチでコンパイルされた
コードとはバイナリ互換性がない。それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fshort-enums
@opindex fshort-enums
@code{enum}型に可能な値の宣言された範囲に必要なバイト数だけを割り当てる。具体的には、
@code{enum}型は十分な余地がある最小の整数型と等しい。

@strong{警告:} @option{-fshort-enums}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fshort-wchar
@opindex fshort-wchar
@code{wchar_t}の基本型をターゲットのデフォルトの代わりに@code{short unsigned int}で上書きする。このオプションはWINEで走る
プログラムをビルドするときに役立つ。

@strong{警告:} @option{-fshort-wchar}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fcommon
@opindex fcommon
@opindex fno-common
@cindex tentative definitions
Cコードでは、このオプションは、初期化子なしで定義されたグローバル変数の配置を制御します。これは、C標準では@dfn{仮定義}と呼ばれています。 仮定義は、ストレージを割り当てない@code{extern}キーワードを使用した変数の宣言とは異なります。

デフォルトは@option{-fno-common}で、コンパイラーが初期化されていないグローバル変数をオブジェクトファイルのBSSセクションに配置することを指定します。 これにより、リンカーによる一時的な定義のマージが禁止されるため、同じ変数が誤って複数のコンパイルユニットで定義されている場合は、多重定義エラーが発生します。

@option{-fcommon}は、初期化されていないグローバル変数を共通ブロックに配置します。
これにより、リンカーは、異なるコンパイルユニットにある同じ変数のすべての仮定義を、同じオブジェクトまたは非仮定義に解決できます。 この動作はC++と一貫性がなく、多くのターゲットでは、グローバル変数参照の速度とコードサイズのペナルティを意味します。 レガシーコードをエラーなしでリンクできるようにすることが主に役立ちます。

@item -fno-ident
@opindex fno-ident
@code{#ident}ディレクティブを無視する。

@item -finhibit-size-directive
@opindex finhibit-size-directive
@code{.size}アセンブラディレクティブ、あるいは、関数が中央で分割され、メモリのかなり離れた場所に両方が配置されるならば問題を
起こすであろう他のものを出力しない。
@file{crtstuff.c}をコンパイルするとき、このオプションが使われる。他のどれに対しても使われるべきではない。

@item -finhibit-size-directive
@opindex finhibit-size-directive
@code{.size}アセンブラディレクティブなど、関数が途中で分割され、2つの半分がメモリ内で離れた場所に配置されている場合に問題が発生するようなものは出力しない。 このオプションは、@file{crtstuff.c}をコンパイルするときに使用されます。 他の目的に使用するべきではありません。

@item -fverbose-asm
@opindex fverbose-asm
読めるようにするために生成されたアセンブリコードに追加のコメント情報を置く。このオプションは
通常は実際に生成されたアセンブリコードを読む必要がある人（たぶんコンパイラ自身をデバッグしているとき）
にだけ役立つ。

デフォルトの@option{-fno-verbose-asm}は、追加の情報が取り除かれ、2つのアセンブラファイルを比較するときに役立つ。

加えられるコメントは以下を含む。

@itemize @bullet

@item
コンパイラバージョンとコマンドライン・オプションの情報。

@item
形式FILENAME:LINENUMBER:CONTENT OF LINEでのアセンブリ命令と結び付けられたソースコード行。

@item
高レベルの式が様々なアセンブリ命令オペランドに対応するヒント。

@end itemize

例えば、このCソースファイルが与えられ、

@smallexample
int test (int n)
@{
  int i;
  int total = 0;

  for (i = 0; i < n; i++)
    total += i * i;

  return total;
@}
@end smallexample

@option{-S}経由で(x86_64)アセンブリへとコンパイルし、@option{-o} @option{-}経由で標準出力へと直接生成すると
@smallexample
gcc -S test.c -fverbose-asm -Os -o -
@end smallexample

このような出力になる。

@smallexample
	.file	"test.c"
# GNU C11 (GCC) version 7.0.0 20160809 (experimental) (x86_64-pc-linux-gnu)
  [...snip...]
# options passed:
  [...snip...]

	.text
	.globl	test
	.type	test, @@function
test:
.LFB0:
	.cfi_startproc
# test.c:4:   int total = 0;
	xorl	%eax, %eax	# <retval>
# test.c:6:   for (i = 0; i < n; i++)
	xorl	%edx, %edx	# i
.L2:
# test.c:6:   for (i = 0; i < n; i++)
	cmpl	%edi, %edx	# n, i
	jge	.L5	#,
# test.c:7:     total += i * i;
	movl	%edx, %ecx	# i, tmp92
	imull	%edx, %ecx	# i, tmp92
# test.c:6:   for (i = 0; i < n; i++)
	incl	%edx	# i
# test.c:7:     total += i * i;
	addl	%ecx, %eax	# tmp92, <retval>
	jmp	.L2	#
.L5:
# test.c:10: @}
	ret
	.cfi_endproc
.LFE0:
	.size	test, .-test
	.ident	"GCC: (GNU) 7.0.0 20160809 (experimental)"
	.section	.note.GNU-stack,"",@@progbits
@end smallexample

コメントは機械ではなく人間を対象としているため、コメントの正確な形式は変更される可能性がある。

@item -frecord-gcc-switches
@opindex frecord-gcc-switches
このスイッチは、コンパイラを呼び出すのに用いられるコマンド・ラインを作成されているオブジェクト・ファイルに記録されるようにする。
このスイッチはあるターゲットの上で実装されるだけである。そして、記録の正確なフォーマットはターゲットとバイナルファイル
形式に依存するが、それはアスキー・テキストを含んでいるセクションの形を通常はとる。
このスイッチは@option{-fverbose-asm}スイッチに関連がある、しかし、そのスイッチはコメントとしてアセンブラ出力ファイルで
情報を記録するだけであるので、それはオブジェクト・ファイルに決して達しない。
オブジェクト・ファイルにコンパイラ・オプションを格納するもう一つの方法のために、@option{-grecord-gcc-switches}参照。

@item -fpic
@opindex fpic
@cindex global offset table
@cindex PIC
もしターゲット機種がサポートしてたら、共有ライブラリに使うのに適した位置独立コード(PIC)を生成する。
そのようなコードはすべての定数アドレスをグローバルオフセットテーブル(GOT)を通してアクセスする。
動的ローダはGTOエントリをプログラム開始時に解決する。（動的ローダはGCCの一部ではない。それはオペレーションシステムの一部である）
もしリンクされた実行ファイルのGOTサイズが機種指定の最大サイズを超えたらなら、@option{-fpic}が働かないことを示す
リンカからのエラーメッセージを得る。その場合には、代わりに@option{-fPIC}で再コンパイルする。（最大はSPARCでは8k,AArch64では28k,
m68kとRS/6000では32k。x86はそのような限度はない。）

位置独立コードは特別なサポートを必要とし、特定の機種でのみ働く。x86では、GCCはSystem VではPICをサポートするが、Sun 386iではしない。
IBM RS/6000のために生成されたコードは常に位置独立である。

このフラグがセットされると、マクロ@code{__pic__}と@code{__PIC__}は1に定義される。

@item -fPIC
@opindex fPIC
もしターゲット機種がサポートしているならば、動的リンクに適し、グローバルオフセットテーブルのサイズの制限を回避した位置独立コードを
生成する。このオプションはAArch64, m68k, PowerPC, SPARCでは異なっている。

位置独立コードは特別なサポートを必要とし、それゆえに特定の機種でのみ働く。

このフラグがセットされると、マクロ@code{__pic__}と@code{__PIC__}は2に定義される。

@item -fpie
@itemx -fPIE
@opindex fpie
@opindex fPIE
これらのオプションは@option{-fpic}と@option{-fPIC}に似ているが、実行ファイルへとリンクされることだけができる
位置独立コードを生成する。これらのオプションは通常は@option{-pie}GCCオプションリンク時に使われるときに使われる。

@option{-fpie}と@option{-fPIE}の両方はマクロ@code{__pie__}と@code{__PIE__}を定義する。
マクロは@option{-fpie}では1で@option{-fPIE}では2である。

@item -fno-plt
@opindex fno-plt
位置独立コードでの外部関数呼び出しにPLTを使わない。代わりに、GOTとそれへの分岐からの呼び出し場所での呼び出し元アドレスをロードする。
これはPLTスタブを除去してGOTロードを最適化に晒すことによってもっと効率的なコードにさせる。
32ビットx86のようなPLTスタブが特定のレジスタでのGTOポインタを期待するアーキテクチャでは、これはコンパイラはより多くのレジスタ割り当ての
自由を与える。遅延バインディングはPLTをの使用を要求する。@option{-fno-plt}ではすべての外部シンボルがロード時に解決される。

代わりに、関数属性@code{noplt}を特定の外部関数にPLTを通しての呼び出しを避けるために使うことができる。

位置依存コードで、幾つかのターゲットはPLTを使わないとマークされている関数への呼び出しも代わりにGOTを使うように変換する。

@item -fno-jump-tables
@opindex fno-jump-tables
switch分でジャンプテーブルをそれが他のコード生成戦略よりも効率的であっても使わない。
このオプションは@option{-fpic}か@option{-fPIC}と組み合わせて、動的リンカの一部を構成し、
ジャンプテーブルのアドレスを参照できないコードを生成するときに使う。
あるターゲットでは、ジャンプテーブルはGOTを必要とせず、このオプションは必要ない。

@item -fno-bit-tests
@opindex fno-bit-tests
@opindex fbit-tests
他のコード生成戦略よりも効率的である場合でも、switchステートメントにビットテストを使用しない。

@item -ffixed-@var{reg}
@opindex ffixed
@var{reg}という名前のレジスタを固定レジスタとして扱う。生成されたコードはそれを決して参照するべきではない。
（多分スタックポインタ、フレームポインタ、および他の固定役割でを除いて）

@var{reg}はレジスタ名でなければならない。受理されるレジスタ名は機種依存で機種描写マクロファイルの
@code{REGISTER_NAMES}マクロで定義されている。

このフラグは3択を指定するので、否定形はない。

@item -fcall-used-@var{reg}
@opindex fcall-used
名前@var{reg}のレジスタを関数呼出しで破壊される割り当て可能レジスタとして扱う。
一時値か呼び出しを通して生存しない変数に割り当てられるかもしれにあ。
この方法でコンパイルされた関数はレジスタ@var{reg}の保存・復帰をしない。

このフラグをフレームポインタかスタックポインタで使うのはエラーである。マシンの実行モデルで
固定の全面的な役割がある他のレジスタでこのフラグを使うと壊滅的な結果を引き起こす。

このフラグは3択を指定するので、否定形はない。

@item -fcall-saved-@var{reg}
@opindex fcall-saved
名前@var{reg}のレジスタを関数によって保存される割り当て可能なレジスタとして扱う。
それ呼び出しをまたいで生存する一時値か変数としてさえも割り当てられるかもしれない。
今方法でコンパイルされる関数は使われた場合には@var{reg}レジスタの保存と復帰を行う。

このフラグをフレームポインタかスタックポインタで使うのはエラーである。マシンの実行モデルで
固定の全面的な役割がある他のレジスタでこのフラグを使うと壊滅的な結果を引き起こす。

そのレジスタに値を返すかもしれない関数でこのフラグを使うと別種の惨事を起こす。

このフラグは3択を指定するので、否定形はない。

@item -fpack-struct[=@var{n}]
@opindex fpack-struct
値を指定しないと、構造体のメンバをすべて穴なしで詰める。値が指定されると（2の小さいベキでなければならない）、
最大アラインメントを表現する、この値に従って構造体メンバを詰める。
（すなわち、デフォルトでアラインメントの要求がこれより大きいオブジェクトは潜在的に次の合う場所に揃わない。

@strong{警告:} @option{-fpack-struct}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それに加えて、それはコードを最適でなくする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fleading-underscore
@opindex fleading-underscore
このオプションとその反対@option{-fno-leading-underscore}は、強制的にCシンボルがオブジェクトファイルでどう表現されるかを変更する。
古いアセンブリコードとのリンクを助けるために使う。

@strong{警告:} @option{-fpack-struct}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。
すべてのターゲットがこのスイッチを完全にサポートするわけではない。

@item -ftls-model=@var{model}
@opindex ftls-model
使われるスレッド局所領域モデルを変える。 (@pxref{Thread-Local})
@var{model}引数は@samp{global-dynamic}, @samp{local-dynamic}, @samp{initial-exec}, @samp{local-exec}
のどれかであるべきである。選択が最適化を受けることに注意すべきである：
翻訳単位の外で不可視のシンボルに対して、もしくは@option{-fpic}がコマンドラインに与えられないならば、
もっと効率的なモデルを使うかもしれない。

@option{-fpic}なしのデフォルトは@samp{initial-exec}である。@option{-fpic}では、デフォルトは
@samp{global-dynamic}である。

@item -ftrampolines
@opindex ftrampolines
通常ネストされた関数にトランポリンを必要とするターゲットの場合は、記述子を使用する代わりに常に生成する。それ以外の場合、HP-PAやIA-64のようなそれらを必要としないターゲットの場合は何も行わない。

トランポリンは、ネストされた関数のアドレスが取られたときに実行時にスタック上に作成され、ネストされた関数を間接的に呼び出すために使用される小さなコードである。したがって、プログラムが正常に動作するためにはスタックを実行可能にする必要があります。

@option{-fno-trampolines}は、言語単位で言語に対してデフォルトで有効になっており、コンパイラが安全であると判断して記述子で置き換えないようコンパイラに指示する。記述子はデータのみで構成されているが、生成されたコードはそれらを処理するための準備が必要である。この記事の執筆時点では、@option{-fno-trampolines}はAdaの場合にのみデフォルトで有効になっています。

さらに、@option{-ftrampolines}でコンパイルされたコードと@option{-fno-trampolines}でコンパイルされたコードは、ネストされた関数が存在する場合、バイナリ互換ではない。したがって、このオプションはプログラム全体で使用する必要があり、細心の注意を払って操作する必要がある。

@item -fvisibility=@r{[}default@r{|}internal@r{|}hidden@r{|}protected@r{]}
@opindex fvisibility
デフォルトELFイメージ・シンボル可視性を指定されたオプションにセットする 
― コードの範囲内でくつがえされない限り、シンボルがこれで記されるすべてで。
この機能を使うことで、共有オブジェクト・ライブラリのリンクおよびロード時間を非常に大幅に改善することができ、
より最適化されたコードを生成することができ、ほぼ完全なAPIエクスポートを提供することができ、シンボル衝突を防止することができる。
配布する共有オブジェクトではこれを使うことを@strong{強く}勧める。

命名法にもかかわらず、@samp{default}はpublicを常に意味する。すなわち、共有オブジェクトの外でからリンクされることが可能である。
@samp{protected}と@samp{internal}は現実の使用においてかなり役に立たないので、
唯一の他の一般的に用いられるオプションは@samp{hidden}である。
デフォルトはもし@option{-fvisibility}は指定されないならばsamp{default}であり、すなわちあらゆるシンボルをpublicにする。

ELFシンボルが正しい可視性を持つことを確実とすることによって提供される利益の良い説明は
Ulrich Drepperによる「共有ライブラリの書き方」（@w{@uref{http://www.akkadia.org/drepper/}}で見つかる）
で与えられる。しかし、デフォルトがpublicであるとき、hiddenとマークすることにこのオプションによって可能になる
優れた解決は、デフォルトをhiddenにして、ものをpublicと記すことである。これはWindowsのDLLによる基準であり、
@code{__declspec(dllexport)}の代わりに@option{-fvisibility=hidden}と
@code{__attribute__ ((visibility("default")))}で、あなたは同一の構文でほぼ同一の意味を得る。
これは、クロスプラットフォーム・プロジェクトで働いている人にとっての大きな利益である。

既存のコードに可視性を加える人にとって、@code{#pragma GCC visibility}が役に立つとわかるかもしれない。
これは、あなたが（たとえば）@code{#pragma GCC visibility push(hidden)}と@code{#pragma GCC visibility pop}で
可視性をセットしたい宣言を囲むことで働く。シンボル可視性が@strong{APIインターフェース契約の一部として}見られるべきであり、
したがってそれがデフォルトでないとき、すべての新しいコードは可視性を常に指定するべきであることを心に留めておくべきである。
すなわち、ローカルDSOの中だけで使う宣言はPLT間接オーバーヘッドを避けるために@strong{常に}明示的にhiddenとしてマークすべきである。
また、これを非常に明白にすることは、コードの読みやすさと自己ドキュメンテーションを助ける。
ISO C++仕様必要条件のために、@code{operator new}と@code{operator delete}は常にデフォルト可視性でなければならない点に注意する。

プロジェクトの外からのヘッダ、特にシステムヘッダと使っている他のライブラリからのヘッダは、デフォルト以外の可視性でコンパイルされることを予期していないかもしれないことに注意せよ。そのようなヘッダを含む前に明示的に@code{#pragma GCC visibility push(default)}を言う必要があるかもしれない。

@code{extern}宣言は@option{-fvisibility}に影響を受けないので、多くのコードは修正なしで@option{-fvisibility=hidden}で
再コンパイルされることができる。しかし、これは、明確な可視性のない@code{extern}関数への呼び出しがPLTを使うことを意味するので、
隠されるように、どの@code{extern}宣言が扱われるべきかについて、コンパイラに話すために
@code{__attribute ((visibility))}や@code{#pragma GCC visibility}を使うことがより効果的である。

@option{-fvisibility}がC++の曖昧なリンケージのエンティティに影響することに注意すべきである。
これは、例えば、DSO間で投げられた例外クラスは、@samp{type_info}ノードがDSO間に統合されるように明示的にdefaultとマークされなければならない
ことを意味する。

これらの技術、利点と使い方は@uref{http://gcc.gnu.org/@/wiki/@/Visibility}にある。

@item -fstrict-volatile-bitfields
@opindex fstrict-volatile-bitfields
volatileのビットフィールド
（もしくは、いずれにせよコンパイラは通常はそれらの型を守るはずの他の構造体フィールド）へのアクセスが、
可能ならば自然なアライメントに揃えられて、フィールドの型の幅の単一のアクセスをつかうべきならばこのオプションを使うである。
例えば、メモリーマップされた周辺レジスタのターゲットはそのようなアクセスがすべて16ビット幅であることが要求されるかもしれない。
このフラグですべての周辺ビットフィールドが（それらのターゲットでshortが16ビットであると仮定して）@code{unsigned short}として宣言して、
GCCに多分もっと効率的な32ビットアクセスの代わりに16ビットアクセスを使うように強制する。

このオプションが無効ならば、コンパイラは最も効率的な命令を使う。前の例では、これはたとえそれがビットフィールドに含まれていないバイトや、
更新されるものに無関係なメモリマップされたレジスタにアクセスしたとしても、32ビットロード命令になるかもしれない。

@code{packed}属性が構造体フィールドに適用されるときのような、幾つかの場合は、対象の機種で正しくアライメントされた単一の読み書きで
フィールドにアクセスすることが不可能かもしれない。この場合には、GCCは実行時にフォールトするか切り詰められるコードではなく、複数のアクセスの
生成へとフォールバックする。

注意：C・C++11メモリモデルの制限のために、非ビットフィールドメンバを触る書き込みアクセスは許されていない。それ故に
ビットフィールドメンバとしてフィールドの型の全ビットを定義することが推奨される。

このオプションのデフォルト値はターゲットプロセッサのアプリケーションバイナリインターフェースによって決定される。

@item -fsync-libcalls
@opindex fsync-libcalls
このオプションは関数の@code{__sync}族の行外のインスタンスが関数のC++11@code{__atomic}族を実装するために使って良いかを制御する。

このオプションのデフォルト値は有効で、したがって、オプションの有用な唯一の形式は@option{-fno-sync-libcalls}である。
このオプションは@file{libatomic}ランタイムライブラリの実装で使われる。

@end table

@node Developer Options
@section GCCデベロッパオプション
@cindex developer options
@cindex debugging GCC
@cindex debug dump options
@cindex dump options
@cindex compilation statistics

このセクションは、GCC開発者（コンパイラ・テストとコンパイラのバグとコンパイル回のパフォーマンス問題の調査をサポートするオプションを含む）に、主に興味深いコマンド・ライン・オプションを記載する。
これは、コンパイルにおいていろいろな点でデバッグ・ダンプを生じるオプションを含む;その出力統計（例えばメモリ使用と実行時間）;そして、GCCの構成（それがライブラリを捜すところのような）に関するその出力情報。
あなたは、めったに、普通のコンパイルとタスクをリンクすることためにこれらのオプションの何も使用する必要はあるべきでない。

GCCに出力をファイルにダンプさせる多くの開発者オプションには、オプションの@samp{=@var{filename}}サフィックスが付きます。 @samp{stdout}または@samp{-}を指定して標準出力にダンプし、@samp{stderr}を指定して標準エラーを出力できます。

@samp{=@var{filename}}を省略した場合、デフォルトのダンプファイル名は、ベースダンプファイル名、パス番号、フェーズレター、パス名を連結して作成されます。 ベースダンプファイル名は、明示的に指定され、実行可能ファイルではない場合に、コンパイラによって生成される出力ファイルの名前です。 それ以外の場合は、ソースファイル名です。 パス番号は、パスがコンパイラのパスマネージャに登録された順序によって決定されます。 これは一般に実行の順序と同じですが、プラグインによって登録されたパス、ターゲット固有のパス、または他の方法で遅れて登録されたパスは、以前に実行された場合でも、@samp{final}という名前のパスよりも大きい番号が付けられます。 フェーズレターは、@samp{i}（手続き間分析）、@samp{l}（言語固有）、@samp{r}（RTL）、または@samp{t}（ツリー）のいずれかです。 ファイルは、出力ファイルのディレクトリに作成されます。

@table @gcctabopt

@item -fcallgraph-info
@itemx -fcallgraph-info=@var{MARKERS}
@opindex fcallgraph-info
オブジェクトファイルごとに、コンパイラーにプログラムのコールグラフ情報を出力させます。 情報は一般的なVCG形式で生成されます。 カンマ区切りのマーカーのリストが追加で指定されている場合は、ノードごと、エッジごと、またはその両方の追加情報で装飾できます。 @code{su}マーカーが指定されている場合、コールグラフはスタック使用情報で装飾されます。 @option{-fstack-usage}と同等です。 @code{da}マーカーが指定されると、コールグラフは動的に割り当てられたオブジェクトに関する情報で装飾されます。

@option {-flto}でコンパイルすると、オブジェクトファイルとともにコールグラフ情報は出力されません。 LTOリンク時に、@option{-fcallgraph-info}は、中間のLTO出力ファイルの隣に複数のコールグラフ情報ファイルを生成する場合があります。

@item -d@var{letters}
@itemx -fdump-rtl-@var{pass}
@itemx -fdump-rtl-@var{pass}=@var{filename}
@opindex d
@opindex fdump-rtl-@var{pass}
時々コンパイルの間のデバッギング・ダンプを@var{letters}によって指定されるようにするように言う。
コンパイラのRTLベースのパスをデバッグするために、これが使われる。

@option{-E}が前処理に使用される場合、一部の@option{-d@var{letters}}スイッチは異なる意味を持ちます。 プリプロセッサ固有のダンプオプションについては、@xref{Preprocessor Options}。

デバッグ・ダンプは、@option{-fdump-rtl}スイッチまたはある@option{-d}オプション@var{letters}で使用可能にされることができる。
@var{pass}と@var{letters}とそれらの意味に用いられる可能性がある文字は、ここにある：

@table @gcctabopt

@item -fdump-rtl-alignments
@opindex fdump-rtl-alignments
分岐アラインメントが計算された後にダンプする。

@item -fdump-rtl-asmcons
@opindex fdump-rtl-asmcons
入出力制約を満たさないRTL文の修正の後にダンプする

@item -fdump-rtl-auto_inc_dec
@opindex fdump-rtl-auto_inc_dec
自動・インクリメント・デクリメント回復の後にダンプする。このパスは自動インクリメントか自動デクリメント命令を持つアーキテクチャ
でのみ走る。

@item -fdump-rtl-barriers
@opindex fdump-rtl-barriers
バリア命令の掃除の後にダンプする。

@item -fdump-rtl-bbpart
@opindex fdump-rtl-bbpart
ホット・コールド基本ブロックの分割の後にダンプする。

@item -fdump-rtl-bbro
@opindex fdump-rtl-bbro
ブロック並べ替えの後にダンプする。

@item -fdump-rtl-btl1
@itemx -fdump-rtl-btl2
@opindex fdump-rtl-btl2
@opindex fdump-rtl-btl2
@option{-fdump-rtl-btl1}と@option{-fdump-rtl-btl2}はふたつの分岐ターゲットロード最適化パスの後のダンプを有効にする。

@item -fdump-rtl-bypass
@opindex fdump-rtl-bypass
ジャンプ迂回と制御フロー最適化の後にダンプする。

@item -fdump-rtl-combine
@opindex fdump-rtl-combine
RTL命令結合パスの後にダンプする。

@item -fdump-rtl-compgotos
@opindex fdump-rtl-compgotos
計算gotoの非重複化の後にダンプする。

@item -fdump-rtl-ce1
@itemx -fdump-rtl-ce2
@itemx -fdump-rtl-ce3
@opindex fdump-rtl-ce1
@opindex fdump-rtl-ce2
@opindex fdump-rtl-ce3
@option{-fdump-rtl-ce1}、@option{-fdump-rtl-ce2}、@option{-fdump-rtl-ce3}は
３つのif変換パスの後にダンプする。

@item -fdump-rtl-cprop_hardreg
@opindex fdump-rtl-cprop_hardreg
ハードレジスタコピー伝搬の後にダンプする。

@item -fdump-rtl-csa
@opindex fdump-rtl-csa
結合スタック調整の後にダンプする。

@item -fdump-rtl-cse1
@itemx -fdump-rtl-cse2
@opindex fdump-rtl-cse1
@opindex fdump-rtl-cse2
@option{-fdump-rtl-cse1}と@option{-fdump-rtl-cse2}は２つの共通部分式除去パスの後のダンプを有効にする。

@item -fdump-rtl-dce
@opindex fdump-rtl-dce
独立未到達コード除去パスの後にダンプする。

@item -fdump-rtl-dbr
@opindex fdump-rtl-dbr
遅延分岐スケジューリングの後にダンプする。

@item -fdump-rtl-dce1
@itemx -fdump-rtl-dce2
@opindex fdump-rtl-dce1
@opindex fdump-rtl-dce2
@option{-fdump-rtl-dce1}と@option{-fdump-rtl-dce2}は２つの死んでいるストアの除去パスの後のダンプを有効にする。

@item -fdump-rtl-eh
@opindex fdump-rtl-eh
EH処理コードの最終化の後にダンプする。

@item -fdump-rtl-eh_ranges
@opindex fdump-rtl-eh_ranges
EH処理範囲領域の変換後にダンプする。
D
@item -fdump-rtl-expand
@opindex fdump-rtl-expand
RTL生成の後にダンプする。

@item -fdump-rtl-fwprop1
@itemx -fdump-rtl-fwprop2
@opindex fdump-rtl-fwprop1
@opindex fdump-rtl-fwprop2
@option{-fdump-rtl-fwprop1}と@option{-fdump-rtl-fwprop2}は２つの前方伝搬パスの後のダンプを有効にする。

@item -fdump-rtl-gcse1
@itemx -fdump-rtl-gcse2
@opindex fdump-rtl-gcse1
@opindex fdump-rtl-gcse2
@option{-fdump-rtl-gcse1}と@option{-fdump-rtl-gcse2}はグローバル共通部分式除去の後のダンプを有効にする。

@item -fdump-rtl-init-regs
@opindex fdump-rtl-init-regs
レジスタの初期化の後にダンプする。

@item -fdump-rtl-initvals
@opindex fdump-rtl-initvals
初期値集合の計算の後にダンプする。

@item -fdump-rtl-into_cfglayout
@opindex fdump-rtl-into_cfglayout
cfglayoutモードへの変換の後にダンプする。

@item -fdump-rtl-ira
@opindex fdump-rtl-ira
繰り返しレジスタ割り当ての後にダンプする

@item -fdump-rtl-jump
@opindex fdump-rtl-jump
第二ジャンプ最適化の後にダンプする

@item -fdump-rtl-loop2
@opindex fdump-rtl-loop2
@option{-fdump-rtl-loop2}はrtlループ最適化パスの後のダンプを有効にする

@item -fdump-rtl-mach
@opindex fdump-rtl-mach
機種依存再組織化パスの行ったあとに、そのパスが存在するならダンプする

@item -fdump-rtl-mode_sw
@opindex fdump-rtl-mode_sw
冗長モードスイッチ除去の後にダンプする

@item -fdump-rtl-rnreg
@opindex fdump-rtl-rnreg
レジスタ再番号化の後にダンプする

@item -fdump-rtl-outof_cfglayout
@opindex fdump-rtl-outof_cfglayout
cfglayoutモードからの変換の後にダンプする

@item -fdump-rtl-peephole2
@opindex fdump-rtl-peephole2
覗き穴パスの後にダンプする

@item -fdump-rtl-postreload
@opindex fdump-rtl-postreload
リロード後最適化の後にダンプする

@item -fdump-rtl-pro_and_epilogue
@opindex fdump-rtl-pro_and_epilogue
関数プロローグとエピローグの後にダンプする

@item -fdump-rtl-sched1
@itemx -fdump-rtl-sched2
@opindex fdump-rtl-sched1
@opindex fdump-rtl-sched2
@option{-fdump-rtl-sched1}と@option{-fdump-rtl-sched2}は基本ブロックスケジューリングパスの後のダンプを
有効にする。

@item -fdump-rtl-ree
@opindex fdump-rtl-ree
符号・0拡張除去の後にダンプする。

@item -fdump-rtl-seqabstr
@opindex fdump-rtl-seqabstr
共通列回復の後にダンプする。

@item -fdump-rtl-shorten
@opindex fdump-rtl-shorten
分岐短縮化の後にダンプする。

@item -fdump-rtl-sibling
@opindex fdump-rtl-sibling
兄弟呼び出し最適化の後にダンプする。

@item -fdump-rtl-split1
@itemx -fdump-rtl-split2
@itemx -fdump-rtl-split3
@itemx -fdump-rtl-split4
@itemx -fdump-rtl-split5
@opindex fdump-rtl-split1
@opindex fdump-rtl-split2
@opindex fdump-rtl-split3
@opindex fdump-rtl-split4
@opindex fdump-rtl-split5
これらのオプションは命令分割の5段階の後のダンプを有効にする。

@item -fdump-rtl-sms
@opindex fdump-rtl-sms
モジュロ・スケジューリングの後にダンプする。このパスはあるアーキテクチャでのみ走る。

@item -fdump-rtl-stack
@opindex fdump-rtl-stack
GCCの「水平レジスタファイル」レジスタからx87のスタック風レジスタへの変換の後にダンプする。
このパスはx86変種でのみ走る。

@item -fdump-rtl-subreg1
@itemx -fdump-rtl-subreg2
@opindex fdump-rtl-subreg1
@opindex fdump-rtl-subreg2
@option{-fdump-rtl-subreg1}と@option{-fdump-rtl-subreg2}は2つのサブレジスタ表現パスの後のダンプを有効にする。

@item -fdump-rtl-unshare
@opindex fdump-rtl-unshare
全rtlが非共有された後にダンプする。

@item -fdump-rtl-vartrack
@opindex fdump-rtl-vartrack
変数追尾の後にダンプする。

@item -fdump-rtl-vregs
@opindex fdump-rtl-vregs
仮想レジスタからハードレジスタへの変換の後にダンプする。

@item -fdump-rtl-web
@opindex fdump-rtl-web
生存範囲分割の後にダンプする。

@item -fdump-rtl-regclass
@itemx -fdump-rtl-subregs_of_mode_init
@itemx -fdump-rtl-subregs_of_mode_finish
@itemx -fdump-rtl-dfinit
@itemx -fdump-rtl-dfinish
@opindex fdump-rtl-regclass
@opindex fdump-rtl-subregs_of_mode_init
@opindex fdump-rtl-subregs_of_mode_finish
@opindex fdump-rtl-dfinit
@opindex fdump-rtl-dfinish
これらのダンプは定義されているが常に空ファイルを生成する。

@item -da
@itemx -fdump-rtl-all
@opindex da
@opindex fdump-rtl-all
上に挙げられたすべてをダンプする。

@item -dA
@opindex dA
アセンブラ出力に雑多なデバッグ情報の注釈をつける。

@item -dD
@opindex dD
プリプロセスの最後に、通常の出力に加えて全マクロ定義を出力する。
normal output.

@item -dH
@opindex dH
エラーがいつ起こったかに関わらずコアダンプを生成する。

@item -dp
@opindex dp
アセンブラ出力にどのパターンと選択肢が使われたかを示すコメントで注釈する。それぞれの命令の長さとコストも出力される。

@item -dP
@opindex dP
それぞれの命令の前にコメントとしてアセンブラ出力でのRTLをダンプする。@option{-dp}注釈もオンにする。

@item -dx
@opindex dx
コンパイルする代わりに関数のRTLをだけを生成する。通常は@option{-fdump-rtl-expand}と使われる。
@end table

@item -fdump-debug
@opindex fdump-debug
デバッグ中に生成されたデバッグ情報をダンプする。

@item -fdump-earlydebug
@opindex fdump-earlydebug
初期のデバッグ生成フェーズで生成されたデバッグ情報をダンプします。

@item -fdump-noaddr
@opindex fdump-noaddr
デバッグダンプをするとき、アドレス出力を抑制する。これは異なるコンパイラのバイナリかつ/または異なる
text / bss / data / heap / stack / dso開始場所のあるコンパイラ呼び出しでdiffをより使いやすくする。

@item -freport-bug
@opindex freport-bug
もし内部コンパイラエラー(ICE)が起きたならばデバッグ情報を収集して一時ファイルへダンプする。

@item -fdump-unnumbered
@opindex fdump-unnumbered
デバッグダンプをしているとき、命令番号とアドレス出力を抑制する。
これは異なるオプション、特に@option{-g}のありなしでのデバッグダンプでdiffをより使いやすくする。

@item -fdump-unnumbered-links
@opindex fdump-unnumbered-links
デバッグダンプをするとき(上の@option{-d}を見よ)、列の前後の命令へのリンクの命令番号を抑制する。

@item -fdump-ipa-@var{switch}
@opindex fdump-ipa
手続間解析の各段階で言語木をファイルにダンプするのを制御する。ファイル名はソースファイル名にスイッチ固有の接尾辞を加えることで
生成され、出力ファイルと同じディレクトリに作られる。以下のダンプが可能である。

@table @samp
@item all
全手続区間解析ダンプを有効にする。

@item cgraph
呼び出しグラフ最適化、未使用関数削除、インライン化決定についての情報をダンプする。

@item inline
関数インライン化の後にダンプする。

@end table

さらに、オプション@option{-optimized}、@option{-missed}、@option{-note}、および@option{-all}を提供でき、@option{-fopt-info}と同じ意味です 、デフォルトは@option{-optimized}です。

たとえば、@option{-fdump-ipa-inline-optimized-missed}は、インライン化されなかった呼び出しサイトとともに、インライン化された呼び出しサイトに関する情報を出力します。

デフォルトでは、ダンプには、成功した最適化に関するメッセージ（@option{-optimized}と同等）と分析に関する低レベルの詳細が含まれます。

@item -fdump-lang
@opindex fdump-lang
言語固有の情報をダンプします。 ファイル名は、ソースファイル名に@file{.lang}を追加することで作成されます。

@item -fdump-lang-all
@itemx -fdump-lang-@var{switch}
@itemx -fdump-lang-@var{switch}-@var{options}
@itemx -fdump-lang-@var{switch}-@var{options}=@var{filename}
@opindex fdump-lang-all
@opindex fdump-lang
言語固有の情報のダンプを制御します。 @var{options}と@var{filename}の部分は、@option{-fdump-tree}オプションで説明されているように動作します。 次の@var{switch}値が受け入れられます。

@table @samp
@item all

すべての言語固有のダンプを有効にします。

@item class
クラス階層情報をダンプします。 '@option{slim}'が指定されていない限り、仮想テーブル情報が出力されます。 このオプションはC++にのみ適用されます。

@item module
モジュール情報をダンプします。 オプション@option{lineno}（場所）、@option{graph}（到達可能性）、@option{blocks}（クラスター）、@option{uid}（シリアル化）、@option{alias}（マージ可能）、@option{asmname}（Elrond）、@option{eh}（マッパー）、@option{vops}（マクロ）が追加情報を提供する場合があります。 このオプションはC++にのみ適用されます。

@item raw
生の内部ツリーデータをダンプします。 このオプションはC++にのみ適用されます。

@end table

@item -fdump-passes
@opindex fdump-passes
現在のコマンドラインオプションでオン・オフになる最適化パスのリストをダンプする。

@item -fdump-statistics-@var{option}
@opindex fdump-statistics
別々のファイルでパス統計のダンピングを使用可能にして制御する。ソース・ファイル名に@samp{.statistics}で終わっている
接尾辞を追加することによってファイル名は生成され、ファイルは出力ファイルと同じディレクトリで作成される。
@samp{-@var{option}}の形が使われるならば、パスがそれらを生成して@samp{-details}があらゆるイベントをダンプする間、
@samp{-stats}はカウンタを全部のコンパイル単位の上に合計されるようにする。
オプションのないデフォルトは、コンパイルされる各々の関数のためにカウンタを合計するようにする。

@item -fdump-tree-all
@itemx -fdump-tree-@var{switch}
@itemx -fdump-tree-@var{switch}-@var{options}
@itemx -fdump-tree-@var{switch}-@var{options}=@var{filename}
@opindex fdump-tree-all
@opindex fdump-tree
中間言語木を処理する様々な段階でのファイルへのダンプを制御する。ファイル名はスイッチ固有の接尾辞をソースファイル名
に食わることで生成され、ファイルは出力ファイルと同じディレクトリに作られる。
@option{=@var{filename}}オプションの場合には、ダンプは自動の名前のダンプファイルの代わりに与えられたファイル名に出力される。
もし@samp{-@var{options}}形式が使われたならば、@var{options}は@samp{-}で区切られたダンプの詳細を制御するオプションのリストである。
すべてのオプションがすべてのダンプに適用可能なわけではない。意味のないものは無視される。以下のオプションが利用可能である。

@table @samp
@item address
それぞれのノードのアドレスを出力する。通常これは環境とソース・ファイルに依存して変わるので意味を持たない。
その主要な使い方はデバッグ環境でダンプファイルと関連させるためである。
@item asmname
もし@code{DECL_ASSEMBLER_NAME}が与えられた宣言でセットされていたら、@code{DECL_NAME}の代わりにダンプでそれが使われる。
その主要な使い方はアセンブリファイルでのマングルされた名前から後方に働かせるときである。
@item slim
フロントエンドの中間の表現をダンプするとき、単にその範囲に達しただけでの関数の範囲または本体のメンバーの廃棄を禁止する。
ある他のパスによって直接届くときだけ、それはそのようなアイテムをダンプする。

ダンピングが木を整えて印字したとき、このオプションは制御構造の本体をダンプすることを妨げる。

RTLをダンプするとき、デフォルトのLISP風表現の代わりに薄い（凝縮される）形式でRTLをプリントする。
@item raw
木の生表現を出力する。デフォルトでは、木はC風の表現にきれいに出力される。
@item details
より詳細なダンプを有効にする。（すべてのダンプ・オプションによって引き受けられるというわけではない）
最適化パスからの情報も含まれる。
@item stats
パスについての様々な統計のダンプを有効にする。（すべてのダンプ・オプションによって引き受けられるというわけではない）
@item blocks
基本ブロック境界の表示を有効にする。（生ダンプでは無効にされる）
@item graph
他の示されたダンプ・ファイル（@option{-fdump-rtl-@var{pass}}）の各々で、
@file{@var{file}.@var{passid}.@var{pass}.dot}にGraphVizで見ることにふさわしい制御フロー・グラフの表現をダンプする。
ファイルの各々の関数はサブグラフとして整えて出力印字され、GraphVizは一つのプロットでそれらにすべてを与えることができる。

このオプションは現在RTLダンプにのみ働き、RTLはいつもslim形式でダンプされる。
@item vops
全文での仮想オペランドの表示を有効にする。
@item lineno
文の行番号の表示を有効にする。
@item uid
それぞれの変数の固有ID(@code{DECL_UID})の表示を有効にする。
@item verbose
それぞれの文の木ダンプの表示を有効にする。
@item eh
それぞれの文を保持するEH領域番号の表示を有効にする。
@item scev
スカラー進化解析詳細の表示を有効にする。
@item optimized
最適化情報の表示を有効にする。（あるパスでの利用可能である）
@item missed
失われた最適化情報の表示を有効にする。（あるパスでのみ利用可能である）
@item note
他の詳細の最適化情報を有効にする。（あるパスでのみ利用可能である）
@item all
@option{raw}, @option{slim}, @option{verbose}, @file{lineno}を除く全オプションを有効にする。
@item optall
すべての最適化オプション、すなわち、@option{optimized}, @option{missed}, @option{note}をオンにする。
@end table

使用可能なツリーダンプを特定する、またはパスのダンプを検索するためには、以下の手順に従う。

@enumerate
@item
@option{-fdump-passes}でGCCを起動し、@file{stderr}の出力で目的のパスに対応するコードを探す。
たとえば、@code{tree-evrp}、@code{tree-vrp1}、@code{tree-vrp2}というコードは、3つの値域伝播パスに対応している。
最後の数字は、同じパスの別々の呼び出しを区別する。
@item
ダンプファイルの作成を有効にするには、パスコードを@option{-fdump-}オプション接頭辞に付加し、GCCをそれつきで呼ぶ。 たとえば、初期値範囲伝播パスからダンプを有効にするには、@option{-fdump-tree-evrp}オプションを指定してGCCを起動する。 オプションで、ダンプ・ファイルの名前を指定することもできる。 指定しない場合、GCCは以下のように作成する。
@item
ピリオドで区切られた3つのコンポーネント、つまりGCCがコンパイルのために呼び出されたソースファイルの名前、パス番号の後に文字パス@samp{t}が続くツリーパスを示す数字サフィックス （RTLパスの場合は@samp{r}）、最後にパスコードを見つける。たとえば、初期VRPパスダンプは、現在の作業ディレクトリの@file{myfile.c.038t.evrp}という名前のファイルに存在する可能性がある。 数値コードは安定しておらず、GCCのあるバージョンから別のバージョンに変更される可能性があることに注意すること。
@end enumerate

@item -fopt-info
@itemx -fopt-info-@var{options}
@itemx -fopt-info-@var{options}=@var{filename}
@opindex fopt-info
様々な最適化パスからの最適化ダンプを制御する。もし@samp{-@var{options}}形が使われるならば、
@var{option}はダンプ詳細と最適化を選択するための@samp{-}で分割されたオプションキーワードのリストである。

@var{options}は3つのグループに分割できる。
@enumerate
@item
どの種類のメッセージを出力するかを説明するオプション
@item
ダンプの詳細度を説明するオプション、および
@item
どの最適化を含めるかを説明するオプション。
@end enumerate
各グループのオプションは重複しないため、自由に組み合わせることができます。 ただし、競合が発生した場合は、コマンドラインの前のオプションが後のオプションで上書きされます。

以下のオプションがダンプの詳細性を制御する。

@table @samp
@item optimized
最適化が的にように成功したときに情報を出力する。どの情報が関連するかを決定するかはパスまでである。
例えば、ベクトル化パスはベクトル化に成功したループのソースの場所を出力する。
@item missed
外した最適化についての情報を出力する。個々のパスはどの情報が出力に含まれるかを制御する。
@item note
最適化についての、ある変換および決定についてのもっと詳細なメッセージなどの詳細な情報を出力する。
@item all
詳細の最適化情報を出力する。これは@samp{optimized}, @samp{missed}, @samp{note}を含む。
@end table

次のオプションは、ダンプの詳細度を制御します。

@table @samp
@item internals
デフォルトでは、「高レベル」メッセージのみが発行されます。 このオプションにより、GCC開発者のみが関心を持つ可能性が高い、追加のより詳細なメッセージが有効になります。
@end table

以下のオプションキーワードの一つ以上は最適化のグループを描写するために使われる。

@table @samp
@item ipa
全手続間最適化からのダンプを有効にする。
@item loop
全ループ最適化からのダンプを有効にする。
@item inline
全インライン最適化からダンプを有効にする。
@item vec
全ベクトル化最適化からのダンプを有効にする。
@item optall
前最適化からのダンプを有効にする。これは上でリストした最適化グループの上位集合である。
@end table

もし@var{options}が省略されたなら、@samp{optimized-optall}がデフォルトになり、
全パスからの成功した最適化についての情報がすべてダンプされることを意味する。

もし@var{filename}が提供されるなら、すべての適用可能な最適化からのダンプが@var{filename}へと連結される。
複数の@option{-fopt-info}オプションが受理されるが、一つだけが@var{filename}を含むことができる。
もし他のファイル名が提供されるなら、最初以外のすべては無視される。

出力@var{filename}は複数の翻訳単位の場合には上書きされることに注意する。
もし複数の翻訳単位からの結合された出力が望まれるならば、@file{stderr}が代わりに使われるべきである。

以下の例では、最適化情報が@file{stderr}へと出力される。

@smallexample
gcc -O3 -fopt-info
@end smallexample

この例では：
@smallexample
gcc -O3 -fopt-info-missed=missed.all
@end smallexample

@noindent
全パスからの失敗した最適化報告が@file{missed.all}へと出力され、この例では:

@smallexample
gcc -O2 -ftree-vectorize -fopt-info-vec-missed
@end smallexample

@noindent
ベクトル化パスからの失敗した最適化機会についての情報が@file{stderr}へと出力される。
@option{-fopt-info-vec-missed}は@option{-fopt-info-missed-vec}と等価であることに注意する。@option{-fopt-info}の後にリストされた最適化グループ名とメッセージタイプの順序は関係ない。
  

他の例として、
@smallexample
gcc -O3 -fopt-info-inline-optimized-missed=inline.txt
@end smallexample

@noindent
は全インラインパスからの最適化された場所だけでなく失敗した最適化についての情報も@file{inline.txt}へと出力する。

最後に、以下は:

@smallexample
gcc -fopt-info-vec-missed=vec.miss -fopt-info-loop-optimized=loop.opt
@end smallexample

@noindent
ここで一つの出力ファイルのみが許されるので２つの出力ファイル名@file{vec.miss}と@file{loop.opt}は衝突する。
この例では、最初のオプションのみが効果を持ち、後ろのオプションは無視される。したがって、@file{vec.miss}が生成され、
それには失敗した奇怪に関するベクトル化器からのダンプが含まれる。

@item -fsave-optimization-record
@opindex fsave-optimization-record
@option {-fopt-info}をサポートする最適化について、実行された最適化の詳細を示すSRCFILE.opt-record.json.gzファイルを記述します。

このオプションは実験的なものであり、圧縮されたJSONファイル内のデータの形式は変更される可能性があります。

これは、@option{-fopt-info-all}の機械可読バージョンとほぼ同じであり、ソースファイル、行番号、列番号を含むメッセージのコレクションであり、各メッセージについて次の追加データがあります。

@itemize @bullet

@item
最適化されているコードの実行カウント、およびこれが実際のプロファイルデータからのものか、単なる推定値であるかに関するメタデータ。これにより、コンシューマーはコードのホットネスによってメッセージに優先順位を付けることができます。

@item
最適化されるコードの関数名（該当する場合）

@item
最適化されるコードの「インラインチェーン」。これにより、関数がいくつかの異なる場所（インライン化される場合がある）にインライン化されると、リーダーはコピーを区別できます。

@item
式、ステートメント、またはシンボルテーブルノードを参照するメッセージのこれらの部分を識別するオブジェクト、これらのカテゴリのどれであるか、および使用可能な場合はソースコードの場所、

@item
メッセージを発行したGCCパス、および

@item
メッセージが発行されたGCC独自のコード内の場所

@end itemize

さらに、一部のメッセージは他のメッセージ内に論理的にネストされており、最適化パスの実装の詳細を反映しています。

@item -fsched-verbose=@var{n}
@opindex fsched-verbose
命令スケジューリングを使うターゲットで、このオプションはダンプファイルへのスケジューラのデバッグ出力の量を制御する。

ゼロより大きい@var{n}では、@option{-fsched-verbose}は@option{-fdump-rtl-sched1}と@option{-fdump-rtl-sched2}と同じ情報を
出力する。1より大きな@var{n}では、基本ブロック確率、詳細の準備リスト情報、unit/命令情報も出力する。
2より大きな@var{n}では、強制終了点でのRTL、制御フロー、領域情報も含まれる。4より大きな@var{n}では、
@option{-fsched-verbose}は依存情報も含まれる。

@item -fenable-@var{kind}-@var{pass}
@itemx -fdisable-@var{kind}-@var{pass}=@var{range-list}
@opindex fdisable-
@opindex fenable-

これは明示的に最適化パスを無効・有効にするために使われるオプションの集合である。
これらのオプションはGCCをデバッグするために使われる。コンパイラのユーザはパスを有効・無効にするためには
代わりに通常のオプションを使うべきである。

@table @gcctabopt

@item -fdisable-ipa-@var{pass}
IPAパス@var{pass}を無効にする。@var{pass}はパスの名前である。もし同じパスがコンパイラで静的に複数回呼ばれるならば、
パス名は１から始まる順番の番号を加えるべきである。

@item -fdisable-rtl-@var{pass}
@itemx -fdisable-rtl-@var{pass}=@var{range-list}
RTLパス@var{pass}を無効にする。@var{pass}はパス名である。もし同じパスがコンパイラで静的に複数回呼ばれるならば、
パス名は１から始まる順番の番号を加えるべきである。@var{range-list}は関数範囲かアセンブラ名のコンマ区切りのリストである。
それぞれの範囲はコロン区切りのペアである。範囲は両端を含む。もし範囲が自明ならば、数値のペアは単一の数に単純化できる。
もし関数の呼び出しグラフノードの@var{uid}が指定された範囲の一つに入らないならば、@var{pass}はその関数で無効にされる。
@var{uid}はダンプファイルの関数ヘッダに現れ、パス名はオプション@option{-fdump-passes}を使ってダンプできる。

@item -fdisable-tree-@var{pass}
@itemx -fdisable-tree-@var{pass}=@var{range-list}
木パス@var{pass}を無効にする。オプション引数の説明は@option{-fdisable-rtl}を見よ。

@item -fenable-ipa-@var{pass}
IPAパス@var{pass}を有効にする。@var{pass}はパス名である。もし同じパスがコンパイラで静的に複数回呼ばれるならば、
パス名は１から始まる順番の番号を加えるべきである。

@item -fenable-rtl-@var{pass}
@itemx -fenable-rtl-@var{pass}=@var{range-list}
RTLパス@var{pass}を有効にする。オプション引数の説明と例は@option{-fdisable-rtl}を見よ。

@item -fenable-tree-@var{pass}
@itemx -fenable-tree-@var{pass}=@var{range-list}
木パス@var{pass}を有効にする。オプション引数の説明は@option{-fdisable-rtl}を見よ。

@end table

ここにこれらのプションを使用を示す例がいくつかある。

@smallexample

# disable ccp1 for all functions
   -fdisable-tree-ccp1
# disable complete unroll for function whose cgraph node uid is 1
   -fenable-tree-cunroll=1
# disable gcse2 for functions at the following ranges [1,1],
# [300,400], and [400,1000]
# disable gcse2 for functions foo and foo2
   -fdisable-rtl-gcse2=foo,foo2
# disable early inlining
   -fdisable-tree-einline
# disable ipa inlining
   -fdisable-ipa-inline
# enable tree full unroll
   -fenable-tree-unroll

@end smallexample

@item -fchecking
@itemx -fchecking=@var{n}
@opindex fchecking
@opindex fno-checking
内部一貫性チェックを有効にする。デフォルトはコンパイラ設定に依存する。
@option{-fchecking=2}は、コード生成に影響を与える可能性のある内部整合性チェックをさらに有効にします。

@item -frandom-seed=@var{string}
@opindex frandom-seed
このオプションはコンパイルファイルごとに異ならなければならないシンボル名を生成する場所でGCCが使うシードを提供する。
それはカバレッジデータファイルとそれが生成するオブジェクトファイルでの唯一のスタンプを置くためにも使われる。
@option{-frandom-seed}オプションを再現可能な同一のオブジェクトファイルを生成するために使うことができる。

@var{string}が数(10進、8進、16進)か任意の文字列（その場合CRC32を計算することで数に変換される）のどちらかであることができる。

@var{string}はコンパイルするファイルごとに異なるべきである。

@item -save-temps
@opindex save-temps
通常の「一時的な」中間ファイルを永続的に保存します。 @option{-dumpbase}および@option{-dumpdir}で説明されているように、それらに補助出力ファイルとして名前を付けます。

@option{-x}コマンドラインオプションと組み合わせて使ったときは、@option{-save-temps}は十分に賢いので中間ファイルとして同じ拡張子の入力ファイルを上書きするの避ける。対応する中間ファイルは@option{-save-temps}を使う前にソースファイルのリネームをすることで得られるかもしれない。

@itemx -save-temps=cwd
@opindex save-temps
通常の「一時」中間ファイルを永久に保管する。それらを現在のディレクトリでソースファイルに
基づいた名前で置く。したがって、@option{-c -save-temps}で@file{foo.c}でコンパイルすると
ファイル@file{foo.o}だけでなく@file{foo.i}と@file{foo.s}も生成する。
これはたとえ今やコンパイラが統合されたプリプロセッサを使っていてもプリプロセスされた
@file{foo.i}出力ファイルを作る。

@item -save-temps=cwd
@opindex save-temps=cwd
@option{-save-temps -dumpdir ./}と同等です。

@item -save-temps=obj
@opindex save-temps=obj
@option{-save-temps -dumpdir @file{outdir/}}と同等です。ここで、@file{outdir/}は、@option{-o}オプションの後に指定された出力ファイルのディレクトリであり、ディレクトリセパレータを含みます。 @option{-o}オプションが使用されていない場合、@option{-save-temps=obj}スイッチは@option{-save-temps=cwd}のように動作します。

@item -time@r{[}=@var{file}@r{]}
@opindex time
コンパイルシーケンスでの各サブプロセスによって使ったCPU時間を報告する。Cソースファイルでは、
これはコンパイラ自身とアセンブラ（ともしリンクが行われたらリンカ）である。

出力ファイルの指定子なしでは、出力はこのようになる。

@smallexample
# cc1 0.12 0.01
# as 0.00 0.01
@end smallexample

それぞれの行の最初は「ユーザ時間」であり、それはプログラム自身を実行した時間である。
二番目の数は「システム時間」であり、プログラムのためのシステムルーチンを実行した時間である。
両方の数は秒単位である。

出力ファイルの指定ありでは、出力は名前付きファイルに加えられ、以下のようになる。

@smallexample
0.12 0.01 cc1 @var{options}
0.00 0.01 as @var{options}
@end smallexample

「ユーザ時間」と「システム時間」はプログラム名の前に移動し、プログラムに渡されたオプションが表示され、
後でコンパイルされたファイルが何かとどのオプションが使われたかを知ることができる。

@item -fdump-final-insns@r{[}=@var{file}@r{]}
@opindex fdump-final-insns
最終内部表現(RTL)を@var{file}にダンプする。もしオプション引数が省略されたなら（もしくは@var{file}が@code{.}なら）
ファンプファイル名の名前はコンパイル出力ファイル名に@code{.gkd}を加えることで決定される。

@item -fcompare-debug@r{[}=@var{opts}@r{]}
@opindex fcompare-debug
@opindex fno-compare-debug
もしコンパイル中にエラーが起こらなければ、二度コンパイラを走らせ、二度目のコンパイルでは
@var{opts}と@option{-fcompare-debug-second}を引数に加えて渡す。最後のコンパイルで最後の内部表現
をダンプし、異なっていたらエラーを出力うすｒ。

もし等号が省略されたらな、デフォルトの@option{-gtoggle}は使う。

環境変数@env{GCC_COMPARE_DEBUG}が、もし定義されて、空でなくゼロでなければ、
@option{-fcompare-debug}を暗黙の有効する。もし@env{GCC_COMPARE_DEBUG}がダッシュで始まって定義されていたら、
@var{opts}のために使われ、さもなければデフォルトの@option{-gtoggle}が使われる。

等号はあるが@var{opts}のない@option{-fcompare-debug=}は@option{-fno-compare-debug}と等価であり、
最終表現のダンプを無効にして、@env{GCC_COMPARE_DEBUG}さえも効果が出ることを防ぐ。

@option{-fcompare-debug}テストの間、完全なカバーを確かめるために、@option{-fcompare-debug-not-overridden}を言うために、
@env{GCC_COMPARE_DEBUG}をセットし、GCCはそれをがどんな（プリプロセス、アセンブリ・リンクでない）実際のコンパイルでも
不正なオプションとして拒絶する。単に警告を得るには、@env{GCC_COMPARE_DEBUG}に@samp{-w%n-fcompare-debug
not overridden}をセットすることでそうなる。

@item -fcompare-debug-second
@opindex fcompare-debug-second
このオプションは暗黙に@option{-fcompare-debug}によって要求されている第二コンパイル用にコンパイラに渡され、
警告を抑制し、コンパイラーが副作用としてファイルへの出力または標準出力への出力を生成するその他のオプションを省略させる。
ダンプファイルと保存された一時ファイルは、最初によって制し得されたものを上書きするのを防ぐために
第二コンパイルの間は@code{.gk}の追加拡張子を含むように名前を変える。

このオプションをコンパイルドライバに渡したときは、@emph{最初の}コンパイルをスキップさせ、
コンパイラ自身をデバッグするときを除いてあまり役に立たなくする。

@item -gtoggle
@opindex gtoggle
もしそれなしでこのオプションがデバッグ情報を生成するならそれの生成を切り、
さもなければレベル２でオンにする。コマンドラインでのこの引数の位置は問題ではない。
それは他のすべてのオプションが処理された後で効果を持ち、何回与えられたとしても一度だけである。
これは主に@option{-fcompare-debug}と使うことを意図している。

@item -fvar-tracking-assignments-toggle
@opindex fvar-tracking-assignments-toggle
@opindex fno-var-tracking-assignments-toggle
@option{-gtoggle}が@option{-g}を切り替えるのと同じやり方で@option{-fvar-tracking-assignments}を切り替える。

@item -Q
@opindex Q
コンパイラにコンパイルされた関数名ごとに出力するようにさせ、
それぞれのパスについて終わるときに統計を出力する。

@item -ftime-report
@opindex ftime-report
それぞれのパスでそれが終わるときに消費した時間についての統計をコンパイラに出力させる。

@item -ftime-report-details
@opindex ftime-report-details
インフラストラクチャの部品が費やす時間をパスごとに個別に記録する。

@item -fira-verbose=@var{n}
@opindex fira-verbose
統合レジスタ割当器用のダンプファイルの詳細性を制御する。デフォルト値は5である。もし値@var{n}が10以上ならば、
ダンプ出力は@var{n}-10と同じ書式を使って標準エラーへと送られる。

@item -flto-report
@opindex flto-report
リンク時最適化の仕事の内部詳細のある報告を出力する。この報告の内容はあバージョンからバージョンで変化する。
これは(@option{-flto}経由で)LTOモードでのオブジェクトファイルを処理するときにGCC++デベロッパに役立つことを意図している。

デフォルトで無効である。

@item -flto-report-wpa
@opindex flto-report-wpa
@option{-flto-report}と似ているが、リンク時最適化のWPAフェーズのためだけに出力する。

@item -fmem-report
@opindex fmem-report
終了時にコンパイラに永久メモリ割り当てについての統計を出力させる。

@item -fmem-report-wpa
@opindex fmem-report-wpa
コンパイラにWPAフェーズフェーズだけでの永久メモリ割り当てについての統計を出力させる。

@item -fpre-ipa-mem-report
@opindex fpre-ipa-mem-report
@item -fpost-ipa-mem-report
@opindex fpost-ipa-mem-report
コンパイラに手続間最適化の前後での永久メモリ割り当てについての統計を出力させる。

@item -fprofile-report
@opindex fprofile-report
コンパイラに個々のパスの（推測された）プロファイルの一貫性と効果についての統計を出力させる。

@item -fstack-usage
@opindex fstack-usage
プログラムのスタック使用情報を、関数ごとの基準で出力させる。ダンプの大ルメイは@var{auxname}に@file{.su}を加えることで
作られる。@var{auxname}はもし明示的に指定されそれが実行可能でないならば出力ファイルの名前から生成され、
さもなければソースファイルの基底名である。エントリは3つのフィールドで作られる。

@itemize
@item
関数の名前
@item
バイト数
@item
1つ以上の指定子： @code{static}, @code{dynamic}, @code{bounded}
@end itemize

指定子@code{static}は関数がスタックを静的に操作することを意味する。
関数の入り口でフレームに固定長のバイトが割り当てられ、関数の出口で解放される。
関数内では他にはスタックの調整は行われない。第2フィールドはこの固定されたバイト数である。

指定子@code{dynamic}は関数がスタックを動的に操作することを意味する。上で描写された静的割り当てに加えて、
関数の本体で、例えば関数呼び出し周りでの引数のプッシュ・ポップのような関数本体でのスタックの調整がある。
もし指定子@code{bounded}もあるならば、それらの調整の量はコンパイル時に制限され、第2フィールドは関数によって使われる
スタックの合計量の上限である。もしそれが存在しなければ、それらの調整の量はコンパイル時に制限されず、第2フールドは
制限された部分のみを表す。

@item -fstats
@opindex fstats
コンパイルの終わりにフロントエンド処理についての統計を放出する。このオプションはC++フロントエンドでのみサポートされていて、
情報は一般的にはG++の開発チームにのみ役立つ。

@item -fdbg-cnt-list
@opindex fdbg-cnt-list
すべてのデバッグカウンタの名前とカウンタ上限を出力する。

@item -fdbg-cnt=@var{counter-value-list}
@opindex fdbg-cnt
内部デバッグカウンタ上限をセットする。@var{counter-value-list}は
それぞれのデバッグカウンタ@var{name}の上限を@var{value}にセットする@var{name}:@var{value}ペアのコンマで区切られた
リストである。すべてのデバッグカウンタはは初期の上限@code{UINT_MAX}を持っている。したがって、
@code{dbg_cnt}は上限をこのオプションでセットしない限り常に真を返す。
例えば、@option{-fdbg-cnt=dce:10,tail_call:0}で、@code{dbg_cnt(dce)}は最初の10呼び出しだけ真を返す。

@item -print-file-name=@var{library}
@opindex print-file-name
リンク時に使われるライブラリファイル@var{library}の完全絶対名を出力し、他のことは何もしない。
このオプションで、GCCはコンパイルもリンクも何もしない。ファイル名を出力するだけである。

@item -print-multi-directory
@opindex print-multi-directory
コマンドラインに存在する他のスイッチによって選択されるmultilibに対応するディレクトリ名を出力する。
このディレクトリは@env{GCC_EXEC_PREFIX}に存在すると想定される。

@item -print-multi-lib
@opindex print-multi-lib
multilibディレクトリ名からそれをを有効にするコンパイラスイッチへの対応を出力する。ディレクトリ名は
@samp{;}によってスイッチから分離され、それぞれのスイッチは@samp{-}の代わりに@samp{@@}で始まり、
複数のスイッチ間にスペースはない。これはシェル処理を簡易化すると想定される。

@item -print-multi-os-directory
@opindex print-multi-os-directory
選択されたmultilibへのOSライブラリへのパスを@file{lib}サブディレクトリへの相対パスで出力する。
もしOSMOTICライブラリが@file{lib}サブディレクトリにあって、multilibが使われなければ、これは単に@file{.}であり、
もしOSライブラリが@file{lib@var{suffix}}兄弟ディレクトリにあるならば、これは例えば@file{../lib64}, @file{../lib}もしくは
@file{../lib32}を出力し、もしOSライブラリが@file{lib/@var{subdir}}サブディレクトリにあるならば、それは例えば
@file{amd64}、@file{sparcv9}、@file{ev6}を出力する。

@item -print-multiarch
@opindex print-multiarch
選択されたmultiarchのOSライブラリのパスを@file{lib}サブディレクトリからの相対で出力する。

@item -print-prog-name=@var{program}
@opindex print-prog-name
@option{-print-file-name}と似ているが、@command{cpp}のようなプログラムを検索する。

@item -print-libgcc-file-name
@opindex print-libgcc-file-name
@option{-print-file-name=libgcc.a}と同じである。

これは@option{-nostdlib}および@option{-noddefaultlibs}を使うが@file{Libgcc.a}をリンクしたいときに役立つ。
このようにできる。

@smallexample
gcc -nostdlib @var{files}@dots{} `gcc -print-libgcc-file-name`
@end smallexample

@item -print-search-dirs
@opindex print-search-dirs
設定されたインストールディレクトリの名前と@command{gcc}が検索するプログラムとライブラリディレクトリのリストを
出力する。他には何もしない。
これは@command{gcc}はエラーメッセージ@samp{installation problem, cannot exec cpp0: No such file or directory}
を出力したときに役立つ。これを解決するためには@file{cpp0}と他のコンパイラ部品を@command{gcc}が期待する場所におくか、
環境変数@env{GCC_EXEC_PREGIX}をそれらをインストールしたディレクトリにセットする必要がある。末尾に@samp{/}を置くのを忘れないこと。
@xref{Environment Variables}.

@item -print-sysroot
@opindex print-sysroot
コンパイルの間に使われるターゲットsysrootディレクトリを出力する。これは設定時が、多分コンパイルオプションに依存して
追加の接尾辞を付けた@option{--sysroot}オプションを使って指定されたターゲットsysrootである。もしターゲットsysrootが指定されないならば、
このオプションを何も出力しない。

@item -print-sysroot-headers-suffix
@opindex print-sysroot-headers-suffix
ヘッダを検索するときにターゲットsysrootに追加した接尾辞を出力するか、コンパイラがそのような接尾辞を設定されていないならばエラーを出す。
他には何もしない。

@item -dumpmachine
@opindex dumpmachine
コンパイラのターゲット機種（例えば、@samp{i686-pc-linux-gnu}）を出力する。他には何もしない。

@item -dumpversion
@opindex dumpversion
コンパイラのバージョン（@code {3.0}、@code {6.3.0}、@code {7}など）を出力する。他に何もしない。これはファイルシステムのパスと仕様で使用されるコンパイラのバージョンであり、コンパイラの設定方法によっては、単一の数字（メジャーバージョン）、ドットで区切られた2つの数字（メジャーとマイナーバージョン） ドット（メジャー、マイナー、パッチレベルのバージョン）になる。

@item -dumpfullversion
@opindex dumpfullversion
完全なコンパイラバージョンを印刷します。そして他には何もしません常に3つの数字をドット、メジャー、マイナー、パッチレベルで区切る。

@item -dumpspecs
@opindex dumpspecs
コンパイラの組み込みのspecsを出力する。他には何もしない。（これはGCCの自身をビルドするときに使う）  @xref{Spec Files}.
@end table

@node Submodel Options
@section 機種依存オプション
@cindex submodel options
@cindex specifying hardware config
@cindex hardware models and configurations, specifying
@cindex target-dependent options
@cindex machine-dependent options

GCCのによってサポートされているそれぞれのターゲット機種には自身のオプションがある。例えば、
特定のプロセッサ変種やABI向けにコンパイルするか、その機種固有の最適化を制御するために。規約によって、
機種固有のオプションの名前は@samp{-m}で始まる。

コンパイラのある設定は追加のターゲット固有のオプションもサポートし、通常は同じプラットフォームの他のコンパイラとの互換性のためである。

@c This list is ordered alphanumerically by subsection name.
@c It should be the same order and spelling as these options are listed
@c in Machine Dependent Options

@menu
* AArch64 Options::
* Adapteva Epiphany Options::
* AMD GCN Options::
* ARC Options::
* ARM Options::
* AVR Options::
* Blackfin Options::
* C6X Options::
* CRIS Options::
* CR16 Options::
* C-SKY Options::
* Darwin Options::
* DEC Alpha Options::
* eBPF Options::
* FR30 Options::
* FT32 Options::
* FRV Options::
* GNU/Linux Options::
* H8/300 Options::
* HPPA Options::
* IA-64 Options::
* LM32 Options::
* M32C Options::
* M32R/D Options::
* M680x0 Options::
* MCore Options::
* MeP Options::
* MicroBlaze Options::
* MIPS Options::
* MMIX Options::
* MN10300 Options::
* Moxie Options::
* MSP430 Options::
* NDS32 Options::
* Nios II Options::
* Nvidia PTX Options::
* OpenRISC Options::
* PDP-11 Options::
* picoChip Options::
* PowerPC Options::
* PRU Options::
* RISC-V Options::
* RL78 Options::
* RS/6000 and PowerPC Options::
* RX Options::
* S/390 and zSeries Options::
* Score Options::
* SH Options::
* Solaris 2 Options::
* SPARC Options::
* System V Options::
* TILE-Gx Options::
* TILEPro Options::
* V850 Options::
* VAX Options::
* Visium Options::
* VMS Options::
* VxWorks Options::
* x86 Options::
* x86 Windows Options::
* Xstormy16 Options::
* Xtensa Options::
* zSeries Options::
@end menu

@node AArch64 Options
@subsection AArch64オプション
@cindex AArch64 Options

これらのオプションはAArch64実装のために定義されている。

@table @gcctabopt

@item -mabi=@var{name}
@opindex mabi
指定されたデータ・モデルのコードを生成する。許される値はint, long int, ポインタが32ビットであるSys-V風のデータモデル@samp{ilp32}と、
intが32ビットで、long intとポインタが64ビットであるSysV風データモデルの@samp{lp64}である。

デフォルトは指定されたターゲット設定に依存する。LP64とILP32ABIはリンク互換性がないことに注意する。全プログラムを同じABIでコンパイルし、
ライブリの互換性のある集合でリンクしなければならない。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンコードを生成する。これはGCCが@samp{aarch64_be-*-*}ターゲットで設定されているときはデフォルトである。

@item -mgeneral-regs-only
@opindex mgeneral-regs-only
汎用目的レジスタだけを使うコードを生成する。これはコンパイラが符号小数点とAdvanced SIMDレジスタを使うことを防ぐが
アセンブラでの制限は押し付けない。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンコードを生成する。これはGCCは@samp{aarch64-*-*}だが@samp{aarch64_be-*-*}ターゲットでなく
設定されたときのデフォルトである。

@item -mcmodel=tiny
@opindex mcmodel=tiny
極小のコードモデル用のコードを生成する。プログラムと静的に定義されたシンボルはそれぞれ1GB以内でなければならない。
ポインタは64ビットである。プログラムは静的にも動的にもリンクできる。このモデルは完全には実装されていなく、
ほとんど@samp{samll}として扱われる。

@item -mcmodel=small
@opindex mcmodel=small
小さいコードモデル用のコードを生成する。プログラムと静的に定義されたシンボルはそれぞれ4GB以内でなければならない。
ポインタは64ビットである。プログラムは静的にも動的にもリンクできる。これはデフォルトのコードモデルである。

@item -mcmodel=large
@opindex mcmodel=large
大きなコードモデル用のコードを生成する。これはアドレスとセクションにサイズ何の仮定もしない。
ポインタは64ビットである。プログラムは静的にのみリンクできる。@option {-mcmodel = large}オプションは、@ option {-mabi = ilp32}、@ option {-fpic}および@option {-fPIC}と互換性がありません。

@item -mstrict-align
@itemx -mno-strict-align
@opindex mstrict-align
@opindex mno-strict-align
境界の合っていないメモリ参照がシステムで扱われると仮定しない。

@item -momit-leaf-frame-pointer
@itemx -mno-omit-leaf-frame-pointer
@opindex momit-leaf-frame-pointer
@opindex mno-omit-leaf-frame-pointer
末端関数でフレームポインタを省略・保持する。前者の振る舞いがデフォルトである。

@item -mstack-protector-guard=@var{guard}
@itemx -mstack-protector-guard-reg=@var{reg}
@itemx -mstack-protector-guard-offset=@var{offset}
@opindex mstack-protector-guard
@opindex mstack-protector-guard-reg
@opindex mstack-protector-guard-offset
@var{guard}でカナリアを使用してスタック保護コードを生成します。 サポートされている場所は、グローバルカナリアの@samp{global}または適切なシステムレジスタ内のカナリアの@samp{sysreg}です。

さらに後者を選択すると、オプション@option{-mstack-protector-guard-reg=@var{reg}}と@option{-mstack-protector-guard-offset=@var{offset}}が、カナリアを読み取るためのベースレジスタとして、そして、そのベースレジスタからのオフセットから使用するシステムレジスタを指定します。これは完全にLinuxカーネル内で使用するためのものであるため、デフォルトのレジスターやオフセットはありません。

@item -mtls-dialect=desc
@opindex mtls-dialect=desc
TLS変数の動的アクセス用のスレッド局所領域メカニズムとしてTSLディスクリプタを使う。これはデフォルトである。

@item -mtls-dialect=traditional
@opindex mtls-dialect=traditional
TSL変数の動的アクセス用のスレッド局所領域メカニズムとして伝統的なTSLを使う。

@item -mtls-size=@var{size}
@opindex mtls-size
即値TSLをオフセットのビットサイズを指定する。正当な値は12、24、32、48である。このオプションは2.25以降のbinutilsに依存する。

@item -mfix-cortex-a53-835769
@itemx -mno-fix-cortex-a53-835769
@opindex mfix-cortex-a53-835769
@opindex mno-fix-cortex-a53-835769
ARM Cortex-A53エラッタ番号835769用の回避手段を有効・無効にする。これはメモリ命令と64ビット整数乗算演算命令の間にNOP命令を挟むことに関連する。

@item -mfix-cortex-a53-843419
@itemx -mno-fix-cortex-a53-843419
@opindex mfix-cortex-a53-843419
@opindex mno-fix-cortex-a53-843419
ARM Cortex-A53エラッタ843419用の回避手段を有効・無効にする。このエラッタ回避手段はリンク時に行われ、これはリンカに対応するフラグを渡すだけである。

@item -mlow-precision-recip-sqrt
@itemx -mno-low-precision-recip-sqrt
@opindex mlow-precision-recip-sqrt
@opindex mno-low-precision-recip-sqrt
逆数平方根近似を有効または無効にします。 このオプションは、@option {-ffast-math}または@option{-funsafe-math-optimizations}も使用されている場合にのみ効果があります。 これを有効にすると、逆数平方根の結果の精度が単精度の場合は約16ビットに、倍精度の場合は32ビットに減少します。

@item -mlow-precision-sqrt
@itemx -mno-low-precision-sqrt
@opindex -mlow-precision-sqrt
@opindex -mno-low-precision-sqrt
平方根近似を有効または無効にする。このオプションは、@option{-ffast-math}または@option{-funsafe-math-optimizations}を使用する場合にのみ有効である。 これを有効にすると、平方根の精度が単精度の場合は約16ビット、倍精度の場合は32ビットになる。有効な場合は、@option{-mlow-precision-recip-sqrt}を含む。

@item -mlow-precision-div
@itemx -mno-low-precision-div
@opindex -mlow-precision-div
@opindex -mno-low-precision-div
除算近似を有効または無効にする。このオプションは、@option{-ffast-math}または@option{-funsafe-math-optimizations}を使用する場合にのみ有効である。 これを有効にすると、除算結果の精度が単精度の場合は約16ビット、倍精度の場合は32ビットになる。

@item -mtrack-speculation
@itemx -mno-track-speculation
条件付きブランチを介した投機的実行を追跡するための追加コードの生成を有効または無効にします。 @code{__builtin_speculation_safe_copy}への呼び出しを展開するときにコンパイラーが追跡状態を使用して、より効率的なコードシーケンスを生成できます。

@item -moutline-atomics
@itemx -mno-outline-atomics
アトミック操作を実装するための行外ヘルパーの呼び出しを有効または無効にします。 これらのヘルパーは、実行時に、ARMv8.1-AのLSE命令を使用できるかどうかを判断します。 そうでない場合は、ベースARMv8.0 ISAにあるロード/ストア専用の命令を使用します。

このオプションは、基本ARMv8.0命令セット用にコンパイルする場合にのみ適用できます。 より新しいリビジョンを使用している場合、@option{-march=armv8.1-a}または@option{-march=armv8-a+lse}では、ARMv8.1-Atomics命令が直接使用されます。 選択したCPUが@samp{lse}機能をサポートしているときに@option{-mcpu=}を使用する場合も同様です。

@item -march=@var{name}
@opindex march
ターゲットアーキテクチャと、オプションで1つ以上の機能修飾子を指定する。オプションは形式
@option{-march=@var{arch}@r{@{}+@r{[}no@r{]}@var{feature}@r{@}*}}である。

以下の表は、@var{arch}の許容値と、それらがデフォルトで有効にする機能をまとめたものです。

@multitable @columnfractions 0.20 0.20 0.60
@headitem @var{arch} value @tab Architecture @tab Includes by default
@item @samp{armv8-a} @tab Armv8-A @tab @samp{+fp}, @samp{+simd}
@item @samp{armv8.1-a} @tab Armv8.1-A @tab @samp{armv8-a}, @samp{+crc}, @samp{+lse}, @samp{+rdma}
@item @samp{armv8.2-a} @tab Armv8.2-A @tab @samp{armv8.1-a}
@item @samp{armv8.3-a} @tab Armv8.3-A @tab @samp{armv8.2-a}, @samp{+pauth}
@item @samp{armv8.4-a} @tab Armv8.4-A @tab @samp{armv8.3-a}, @samp{+flagm}, @samp{+fp16fml}, @samp{+dotprod}
@item @samp{armv8.5-a} @tab Armv8.5-A @tab @samp{armv8.4-a}, @samp{+sb}, @samp{+ssbs}, @samp{+predres}
@item @samp{armv8.6-a} @tab Armv8.6-A @tab @samp{armv8.5-a}, @samp{+bf16}, @samp{+i8mm}
@item @samp{armv8-r} @tab Armv8-R @tab @samp{armv8-r}
@end multitable

値@samp{native}はネイティブのAArch64 GNU/Linuxで利用可能であり、コンパイラにホストシステムの
アーキテクチャを選ばせる。このオプションはもしコンパイラがホストシステムのアーキテクチャを
認識できないときには効果がない。

@var{feature}の可能な値は@ref{aarch64-feature-modifiers,,@option{-march}と@option{-mcpu}機能修正子}
サブセクションでリストされている。衝突する機能修飾子が指定されたときは、一番右の機能が使われる。

GCCは@var{name}をアセンブリコードを生成するときにどの種類の命令を生成できるかを決定するために使う。
もし@option{-march}が@option{-mtune}か@option{-mcpu}のどちらも指定されていないなら、コードは
ターゲットアーキテクチャを実装しているターゲットプロセッサの範囲にまたがってよく実行されるように調整される。

@item -mtune=@var{name}
@opindex mtune
GCCがコードのパフォーマンスを調整すべきターゲットプロセッサの名前を指定する。このオプションの可能な値以下。
@samp{generic}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a55},
@samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
@samp{cortex-a76}, @samp{cortex-a76ae}, @samp{cortex-a77},
@samp{cortex-a65}, @samp{cortex-a65ae}, @samp{cortex-a34},
@samp{cortex-a78}, @samp{cortex-a78ae}, @samp{cortex-a78c},
@samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
@samp{neoverse-e1}, @samp{neoverse-n1}, @samp{neoverse-n2},
@samp{neoverse-v1}, @samp{qdf24xx}, @samp{saphira},
@samp{phecda}, @samp{xgene1}, @samp{vulcan}, @samp{octeontx},
@samp{octeontx81},  @samp{octeontx83},
@samp{octeontx2}, @samp{octeontx2t98}, @samp{octeontx2t96}
@samp{octeontx2t93}, @samp{octeontx2f95}, @samp{octeontx2f95n},
@samp{octeontx2f95mm},
@samp{a64fx},
@samp{thunderx}, @samp{thunderxt88},
@samp{thunderxt88p1}, @samp{thunderxt81}, @samp{tsv110},
@samp{thunderxt83}, @samp{thunderx2t99}, @samp{thunderx3t110}, @samp{zeus},
@samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
@samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
@samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55},
@samp{cortex-r82}, @samp{cortex-x1}, @samp{native}.

値@samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
@samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
@samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55} はbig.LITTLEシステム用のコードのパフォーマンスを調整すべきだということも指定することができる。

さらにネイティブのAArch64 GNU/Linuxシステムでは値@samp{native}が利用可能である。このオプションは、コンパイラに
アーキテクチャを選択してホストシステムのプロセッサ用のコードのパフォーマンスを調整するようにさせる。
コンパイラはホストシステムのアーキテクチャーを認識することができないならば、このオプションは影響を持たない。

@option{-mtune=}, @option{-mcpu=}, @option{-march=}のどれも指定されないならば、コードはターゲットプロセッサの範囲全体でよく動作するように
調整する。

このオプションは機能修正子を後ろにつけることができない。

@item -mcpu=@var{name}
@opindex mcpu
ターゲットプロセッサの名前を指定し、オプションで１つ以上の機能修正子を後ろにつける。
このオプションは形式@option{-mcpu=@var{cpu}@r{@{}+@r{[}no@r{]}@var{feature}@r{@}*}}を持ち、
ここで@var{cpu}の可能な値は@option{-mtune}で利用可能な値と同じである。@var{feature}の可能な値はサブセクション
@ref{aarch64-feature-modifiers,,@option{-march}と@option{-mcpu}機能修正子}で文書化されている。衝突する機能修正子が指定されたときは、
最も右側の機能が使われる。

GCCは@var{name}を（まるで@option{-march}によってのように）アセンブリコードを生成するときに生成可能な命令の種類を決定するために使う。
このオプションが@option{-march}か@option{-mtune}と組み合わせて使われたときは、それらのオプションは、このオプションの該当する一部に優先する。

@item -moverride=@var{string}
@opindex moverride
@option{-mtune=}スイッチに応じてバックエンドによってなされるチューニング決定を上書きする。
このオプションでの@var{string}の構文、意味、受け入れられる値はリリースを超えて一貫性があるようには保証されない。

このオプションはGCCを開発するときに役立つことだけを意図している。

@item -mverbose-cost-dump
@opindex mverbose-cost-dump
デバッグダンプファイルで詳細なコストモデルのダンプを有効にする。 このオプションは、コンパイラのデバッグに使用するために用意されている。

@item -mpc-relative-literal-loads
@itemx -mno-pc-relative-literal-loads
@opindex mpc-relative-literal-loads
@opindex mno-pc-relative-literal-loads
PC相対のリテラルロードを有効・無効にする。このオプションを使用すると、リテラルプールは単一の命令を使用してアクセスされ、各関数の後に放出される。 これにより、関数の最大サイズが1MBに制限される。これは、@option{-mcmodel=tiny}に対してデフォルトで有効になっている。

@item -msign-return-address=@var{scope}
@opindex msign-return-address
リターンアドレス署名が適用される関数スコープを選択します。 許可される値は、戻りアドレスの署名を無効にする@samp{none}、リーフ関数ではない関数のポインター署名を有効にする@samp{non-leaf}、およびすべての関数のポインター署名を有効にする@samp{all}です。 デフォルト値は@samp{none}です。 このオプションは、-mbranch-protectionによって廃止されました。

@item -mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}+@var{b-key}]|@var{bti}
@opindex mbranch-protection
使用するブランチ保護機能を選択します。 @samp{none}がデフォルトであり、すべてのタイプのブランチ保護をオフにします。 @samp{standard}は、すべてのタイプのブランチ保護機能をオンにします。 機能に追加のチューニングオプションがある場合、@samp{standard}はその機能を標準レベルに設定します。 @samp{pac-ret[+@var{leaf}]}は、戻りアドレスの署名を標準レベルでオンにします。aキーを使用して、戻りアドレスをメモリに保存する署名関数（非リーフ関数は実際には常にこれを行います）。 オプションの引数@samp{leaf}を使用して、リーフ関数を含めるように署名を拡張できます。 オプションの引数@samp{b-key}を使用して、AキーではなくBキーで関数に署名できます。 @samp{bti}はブランチターゲット識別メカニズムをオンにします。

@item -mharden-sls=@var{opts}
@opindex mharden-sls
直線投機（SLS）に対するコンパイラーの強化を有効にします。@var{opts}は、次のオプションのコンマ区切りのリストです。
@table @samp
@item retbr
@item blr
@end table
さらに、@samp{-mharden-sls=all}はすべてのSLS強化を有効にし、@samp{-mharden-sls=none}はすべてのSLS強化を無効にします。

@item -msve-vector-bits=@var{bits}
@opindex msve-vector-bits
SVEベクタレジスタのビット数を指定します。 このオプションは、SVEが有効な場合にのみ効果があります。

GCCは2つの形式のSVEコード生成をサポートします：任意のサイズのベクトルレジスターで機能する「ベクトル長に依存しない」出力と、GCCが最適化のため有用な場合にベクトル長について推測できるようにする「ベクトル長固有」出力。@samp{bits}の可能な値は、@samp{scalable}、@samp{128}、@samp{256}、@samp{512}、@samp{1024}および@samp{2048}です。 @samp{scalable}を指定すると、ベクトル長に依存しない出力が選択されます。 現在、@samp{-msve-vector-bits = 128}はビッグエンディアンターゲットのベクトル長に依存しない出力も生成します。 他のすべての値は、ベクトル長固有のコードを生成します。 これらの値の動作は将来のリリースで変更される可能性があり、@samp {scalable}以外の値は、異なるハードウェアSVEベクトル長にわたって移植可能なコードを生成するために依存すべきではありません。

デフォルトは@samp{-msve-vector-bits=scalable}で、ベクトル長に依存しないコードを生成します。
@end table

@subsubsection @option{-march}と@option{-mcpu}の機能修正子
@anchor{aarch64-feature-modifiers}
@cindex @option{-march} feature modifiers
@cindex @option{-mcpu} feature modifiers
@option{-march}と@option{-mcpu}で使われる機能修正子は以下とその逆@option{no@var{feature}}のどれかである。

@table @samp
@item crc
CRC拡張を有効にする。これは@option{-march=armv8.1-a}のデフォルトである。
@item crypto
Crypto拡張を有効にする。これは拡張SIMDと浮動小数点命令も有効にする。
@item fp
浮動小数点命令を有効にする。これは@option{-march}と@option{-mcpu}オプションのすべての可能な値のデフォルトである。
@item simd
拡張SIMD命令を有効にする。これは浮動小数点命令も有効にする。これは@option{-march}と@option{-mcpu}オプションのすべての可能な値のデフォルトである。
@item sve
Scalable Vector Extension命令を有効にする。 これにより、アドバンストSIMDおよび浮動小数点命令も有効になる。
@item lse
ラージシステム実行命令を有効にする。これは@option{-march=armv8.1-a}のデフォルトである。
@item rdma
Round Double Multiply Accumulate命令を有効にします。 これは、デフォルトでは@option{-march = armv8.1-a}に対して有効になっている。
@item fp16
FP16拡張を有効にする、これは浮動小数点命令も有効にする。
@item fp16fml
FP16 fmla拡張機能を有効にする。 これにより、FP16拡張命令と浮動小数点命令も有効になる。 このオプションは、@option{-march=armv8.4-a}に対してデフォルトで有効になっている。 Armv8.2-Aより前のアーキテクチャでこのオプションを使用することはサポートされていない。
@item rcpc
RcPc拡張機能を有効にする。 これはGCCからのコード生成を変更するのではなく、アセンブラに渡され、インラインasm文がRcPc拡張からの命令を使用できるようにする。
@item dotprod
ドットプロダクト拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。
@item aes
Armv8-aesおよびpmull暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。
@item sha2
Armv8-sha2暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。
@item sha3
sha512およびsha3暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。 Armv8.2-Aより前のアーキテクチャでこのオプションを使用することはサポートされていない。
@item sm4
sm3およびsm4暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。Armv8.2-Aより前のアーキテクチャでこのオプションを使用することはサポートされていない。
@item profile
統計プロファイリング拡張を有効にします。 このオプションは、アセンブラレベルで拡張機能を有効にするためだけのものであり、コード生成には影響しません。
@item rng
Armv8.5-a乱数命令を有効にします。 このオプションは、アセンブラレベルで拡張機能を有効にするためだけのものであり、コード生成には影響しません。
@item memtag
Armv8.5-aメモリタグ拡張機能を有効にします。 Armv8.5-Aより前のアーキテクチャでのこのオプションの使用はサポートされていません。
@item sb
Armv8-a投機バリア命令を有効にします。 このオプションは、アセンブラレベルで拡張機能を有効にするためだけのものであり、コード生成には影響しません。 このオプションは、@option{-march=armv8.5-a}ではデフォルトで有効になっています。
@item ssbs
Armv8-a投機的ストアバイパスセーフ命令を有効にします。 このオプションは、アセンブラレベルで拡張機能を有効にするためだけのものであり、コード生成には影響しません。 このオプションは、@option{-march=armv8.5-a}ではデフォルトで有効になっています。
@item predres
Armv8-a実行およびデータ予測制限命令を有効にします。 このオプションは、アセンブラレベルで拡張機能を有効にするためだけのものであり、コード生成には影響しません。 このオプションは、@option{-march=armv8.5-a}ではデフォルトで有効になっています。
@item sve2
Armv8-a Scalable Vector Extension 2を有効にします。これにより、SVE命令も有効になります。
@item sve2-bitperm
SVE2 bitperm命令を有効にします。 これにより、SVE2命令も有効になります。
@item sve2-sm4
SVE2 sm4命令を有効にします。 これにより、SVE2命令も有効になります。
@item sve2-aes
SVE2 aes命令を有効にします。 これにより、SVE2命令も有効になります。
@item sve2-sha3
SVE2 sha3命令を有効にします。 これにより、SVE2命令も有効になります。
@item tme
Transactional Memory Extensionを有効にします。
@item i8mm
8ビット整数行列乗算命令を有効にします。 これにより、Advanced SIMDおよび浮動小数点命令も有効になります。 このオプションは、@option{-march = armv8.6-a}ではデフォルトで有効になっています。 Armv8.2-Aより前のアーキテクチャでのこのオプションの使用はサポートされていません。
@item f32mm
32ビット浮動小数点行列乗算命令を有効にします。 これにより、SVE命令も有効になります。 Armv8.2-Aより前のアーキテクチャでのこのオプションの使用はサポートされていません。
@item f64mm
64ビット浮動小数点行列乗算命令を有効にします。 これにより、SVE命令も有効になります。 Armv8.2-Aより前のアーキテクチャでのこのオプションの使用はサポートされていません。
@item bf16
brain半精度浮動小数点命令を有効にします。 これにより、Advanced SIMDおよび浮動小数点命令も有効になります。 このオプションは、@option{-march = armv8.6-a}ではデフォルトで有効になっています。 Armv8.2-Aより前のアーキテクチャでのこのオプションの使用はサポートされていません。
@item flagm
フラグ操作命令拡張を有効にします。
@item pauth
ポインタ認証拡張機能を有効にします。

@end table

@option{crypto}は@option{aes}、@option{sha2}、@option{simd}を含み、それは@option{fp}を含む。逆に、
@option{nofp}は@option{nosimd}を含み、それは@option{noctypto}、@option{noaes}、@option{nosha2}を含む。

@node Adapteva Epiphany Options
@subsection Adapteva Epiphanyオプション

これらの@samp{-m}オプションがAdapteva Epiphany用に定義されている。

@table @gcctabopt
@item -mhalf-reg-file
@opindex mhalf-reg-file
範囲@code{r32}@dots{}@code{r63}でレジスタを割り当てない。これはこれらのレジスタがないハードウェア変種でもコードが実行できるようにする。

@item -mprefer-short-insn-regs
@opindex mprefer-short-insn-regs
優先して、短い命令生成を可能にするレジスタを割り当てる。これは命令数を増やし得るので、全体のコードサイズを減らすかもしれないし増やすかもしれない。

@item -mbranch-cost=@var{num}
@opindex mbranch-cost
分岐のコストをだいたい@var{num}「単純」命令にセットする。このコストは反なるヒューリスティックでリリースをまたいで一貫した結果を生み出すことは保証されない。

@item -mcmove
@opindex mcmove
条件付きムーブを生成する。

@item -mnops=@var{num}
@opindex mnops
他のすべての生成された命令の前に@var{num}個のNOPを生成する。

@item -mno-soft-cmpsf
@opindex mno-soft-cmpsf
@opindex msoft-cmpsf
単精度浮動小数点比較の場合、@code{fsub}命令を発行してフラグをテストします。 これはソフトウェアの比較より高速ですが、NaNが存在する場合、または2つの異なる小さな数値が比較され、それらの差がゼロとして計算される場合に、誤った結果が得られる可能性があります。 デフォルトは@option{-msoft-cmpsf}で、低速ですがIEEE準拠のソフトウェア比較を使用します。

@item -mstack-offset=@var{num}
@opindex mstack-offset
スタックのトップとスタックポインタの間のオフセットをセットする。例えば、
値8は範囲@code{sp+0@dots{}sp+7}の8バイトを末端関数によってスタック割り当てなしで使えることを意味する。
@samp{8}および@samp{16}以外の値はテストされておらずおそらく動かない。
このオプションはABIを変更することにも注意する。ライブラリと異なるスタックオフセットでコンパイルした
プログラムは通常は動かない。
これはもし異なるスタックオフセットがコードを良くするかどうかを評価したい時には役立つが、
実際に異なるスタックサイズオフセットで動くプログラムをビルドするためには、
ツールチェーンに適切な@option{--with-stack-offset=@var{num}}オプションを設定することを推奨する。

@item -mno-round-nearest
@opindex mno-round-nearest
@opindex mround-nearest
スケジューラが丸めモードが切り詰めにセットされていると仮定する。デフォルトは@option{-mround-nearest}
である。

@item -mlong-calls
@opindex mlong-calls
もし他に属性で指定されていなければ、すべての呼び出しが@code{b} / @code{bl}命令のオフセット範囲を
超えるかもしれないと仮定し、（さもなければ直接の）呼び出しを実行する前にレジスタに関数アドレスをロードする。
これはデフォルトである。

@item -mshort-calls
@opindex short-calls
もし他に属性で指定されていなければ、すべての直接呼び出しが@code{b} / @code{bl}命令の範囲内であると仮定し、
これらの命令を直接呼び出しに用いる。デフォルトは@option{-mlong-calls}である。

@item -msmall16
@opindex msmall16
アドレスが16ビット符号なし値としてロードできると仮定する。これは@option{-mlong-calls}意味論が
有効の関数アドレスには適用されない。

@item -mfp-mode=@var{mode}
@opindex mfp-mode
浮動小数点ユニットの普通の方法をセットする。
これは関数呼び出しと復帰時に提供され期待される浮動小数点モードを決定する。
このモードを関数の開始で主に必要とするモードと一致させると不必要なモード切り替えを避けることで
プログラムと小さく速くすることができる。

@var{mode}は以下の値のうちの一つをセットすることができる。

@table @samp
@item caller
関数の入り口でどんなモードも有効で、保持され、関数の復帰と他の関数の呼び出しで戻される。
このモードはライブラリをおよび異なる一般のFPUモードでの異なるプログラムに
組み込みたいかもしれない翻訳単位をコンパイルするのに役立ち、
普通のFPUモードの特定の選択で必要になるであろうオーバーヘッドと比較して、
単一のオブジェクトファイルを使うことができる利便性は、追加のモードスイッチのサイズとスピードのオーバーヘッドは上回る。

@item truncate
これは切り捨て（すなわち、0への丸め）丸めモードでの浮動小数点計算で使われるモードである。
これは浮動小数点数から整数への変換を含む。

@item round-nearest
これは最も近い偶数への丸めの丸めモードでの浮動小数点数の計算で使われるモードである。

@item int
これはFPUで整数計算を行うために使われるモードである。例えば、整数乗算および、整数乗加算である。
@end table

デフォルトは@option{-mfp-mode=caller}である。

@item -mno-split-lohi
@itemx -mno-postinc
@itemx -mno-postmodify
@opindex mno-split-lohi
@opindex msplit-lohi
@opindex mno-postinc
@opindex mpostinc
@opindex mno-postmodify
@opindex mpostmodify
それぞれ、32ビットロードの分割、後置インクリメントアドレスの生成、後置修正アドレスの生成を
無効にするコード生成調整。デフォルトは@option{msplit-lohi},
@option{-mpost-inc}, @option{-mpost-modify}。

@item -mnovect-double
@opindex mno-vect-double
優先SIMDモードをSIモードに変更する。デフォルトは@option{-mvect-double}で、
優先SIMDモードとしてDIモードを使う。

@item -max-vect-align=@var{num}
@opindex max-vect-align
SIMDベクタモード型の最大アラインメント。@var{num}は4か8であり、デフォルトは8である。
これは、もし関連する型のサイズとアラインメントに影響を与える場所でSIMDベクトルモード
を使わないならば多くのライブラリ関数インターフェースに影響を与えないにもかかわらず、
ABI変更であることに注意する。

@item -msplit-vecmove-early
@opindex msplit-vecmove-early
リロード前にベクタムーブを単一のワードのムーブへと分割する。理論的には
これはより良いレジスタ割当を与えるはずだが、今までのところは一般的には逆のようである。

@item -m1reg-@var{reg}
@opindex m1reg-
定数@minus{}1を保持するレジスタを指定し、小さな負の定数とあるビットマスクを高速にロードできるようにする。
@var{reg}の可能な値は@samp{r43}と@samp{r63}で、それは固定レジスタとしてのレジスタの私用を指定子、
@samp{none}はこの目的でレジスタを使わないことを意味する。デフォルトは@option{-m1reg-none}である。

@end table

@node AMD GCN Options
@subsection AMD GCNオプション
@cindex AMD GCN Options

これらのオプションは、AMD GCNポート専用に定義されています。

@table @gcctabopt

@item -march=@var{gpu}
@opindex march
@itemx -mtune=@var{gpu}
@opindex mtune
@var {gpu}のアーキテクチャタイプまたはチューニングを設定します。 @var {gpu}でサポートされる値は

@table @samp
@opindex fiji
@item fiji
GCN3 Fijiデバイス（gfx803）用にコンパイルします。

@item gfx900
GCN5 Vega 10デバイス（gfx900）用にコンパイルします。

@item gfx906
GCN5 Vega 20デバイス（gfx906）用にコンパイルします。

@end table

@item -mstack-size=@var{bytes}
@opindex mstack-size
各GPUスレッド（ウェーブフロント）に対して要求されるスタック領域の@var{bytes}の数を指定します。 多くのスレッドがあり、使用可能なメモリが限られている場合があることに注意してください。 スタック割り当てのサイズも、実行時のパフォーマンスに影響を与える可能性があります。 OpenACCまたはOpenMPを使用する場合のデフォルトは32KB、それ以外の場合は1MBです。

@end table

@node ARC Options
@subsection ARCオプション
@cindex ARC options

このオプションはコードをコンパイルするアーキテクチャ変種を制御する。

@c architecture variants
@table @gcctabopt

@item -mbarrel-shifter
@opindex mbarrel-shifter
バレル・シフタによってサポートされる命令を生成する。これは
@option{-mcpu=ARC601}および@samp{-mcpu=ARCEM}が有効でない限りはデフォルトである。

@item -mjli-always
@opindex mjli-alawys
jli_s命令を使用して関数を強制的に呼び出します。 このオプションは、ARCv2アーキテクチャーでのみ有効です。

@item -mcpu=@var{cpu}
@opindex mcpu
@var{cpu}用のアーキテクチャタイプ、レジスタ使用、命令スケジューリングパラメータをセットする。
後方互換と利便性のために利用可能な別名オプションもある。@var{cpu}のサポートされた値は

@table @samp
@opindex mA6
@opindex mARC600
@item arc600
ARC600用にコンパイルする。エイリアス： @option{-mA6}, @option{-mARC600}.

@item arc601
@opindex mARC601
ARC601用にコンパイルする。エイリアス： @option{-mARC601}.

@item arc700
@opindex mA7
@opindex mARC700
ARC700用にコンパイルする。エイリアス： @option{-mA7}, @option{-mARC700}.
これは@option{--with-cpu=arc700}で設定されたときのデフォルトである。

@item arcem
ARC EM用にコンパイルする。

@item archs
ARC HS用にコンパイルする。

@item em
ハードウェア拡張なしのARC EM CPU用にコンパイルする。

@item em4
ARC EM4 CPU用にコンパイルする。

@item em4_dmips
ARC EM4 DMIPS CPU用にコンパイルする。

@item em4_fpus
単精度浮動小数点数を拡張したARC EM4 DMIPS CPU用にコンパイルする。

@item em4_fpuda
単精度浮動小数点および二重支援命令を使用するARC EM4 DMIPS CPU用にコンパイルする。

@item hs
アトミック命令以外のハードウェア拡張機能を持たないARC HS CPU用にコンパイルする。

@item hs34
ARC HS34 CPU用にコンパイルする。

@item hs38
ARC HS38 CPU用にコンパイルする。

@item hs38_linux
すべてのハードウェア拡張がオンのARC HS38 CPU用にコンパイルする。

@item arc600_norm
@code{norm}命令を有効にしてARC 600 CPU用にコンパイルする。

@item arc600_mul32x16
@code{norm}命令と32x16ビット乗算命令を有効にしてARC 600 CPU用にコンパイルする。

@item arc600_mul64
@code{norm}と@code{mul64}族命令を有効にしてARC 600 CPU用にコンパイルする。

@item arc601_norm
@code{norm}命令を有効にしてARC 601 CPU用にコンパイルする。

@item arc601_mul32x16
@code {norm}および32x16ビット乗算命令が有効なARC 601 CPU用にコンパイルする。

@item arc601_mul64
@code{norm}と@code{mul64}族命令を使用してARC 601 CPU用にコンパイルする

@item nps400
NPS400チップ上のARC 700用にコンパイルする。

@item em_mini
レジスタセットを削減したARC EMミニマリスト構成向けにコンパイルします。

@end table

@item -mdpfp
@opindex mdpfp
@itemx -mdpfp-compact
@opindex mdpfp-compact
FPX:倍精度FPX命令を生成し、コンパクト実装用に調整する。

@item -mdpfp-fast
@opindex mdpfp-fast
FPX:倍精度FPX命令を生成し、高速実装用に調整する。

@item -mno-dpfp-lrsr
@opindex mno-dpfp-lrsr
FPX拡張補助レジスタの使用から@code{lr}と@code{sr}命令を無効にする。

@item -mea
@opindex mea
拡張算術命令を生成する。現在は@code{divaw}, @code{adds}, @code{subs},
@code{sat16}のみがサポートされている。これは@option{-mcpu=ARC700}用にはいつも有効である。

@item -mno-mpy
@opindex mno-mpy
ARC700用の@code{mpy}-属命令を生成しない。このオプションは非推奨である。

@item -mmul32x16
@opindex mmul32x16
32x16ビット乗算と乗加算命令を生成する。

@item -mmul64
@opindex mmul64
@code{mul64}と@code{mulu64}命令を生成する。@option{-mcpu=ARC600}でのみ有効である。

@item -mnorm
@opindex mnorm
@code{norm}命令を生成する。これはもし@option{-mcpu=ARC700}が有効ならデフォルトである。

@item -mspfp
@opindex mspfp
@itemx -mspfp-compact
@opindex mspfp-compact
コンパクトな実装用に調整されたFPX:単精度FPX命令を生成する。

@item -mspfp-fast
@opindex mspfp-fast
高速実装用に調整されたFPX:単精度FPX命令を生成する。

@item -msimd
@opindex msimd
ターゲット固有の組み込み関数を経由したARC SIMD命令の生成を有効にする。
@option{-mcpu=ARM700}でのみ有効である。

@item -msoft-float
@opindex msoft-float
このオプションは無視される。これは互換性の目的のためだけに提供される。
ソフトウェア浮動小数点コードはデフォルトで生成され、このデフォルトはFPXオプションで
上書きできる。単精度には@samp{mspfp}, @samp{mspfp-compact}, または@samp{mspfp-fast}、
倍精度には@samp{mdpfp}, @samp{mdpfp-compact}, or @samp{mdpfp-fast}である。

@item -mswap
@opindex mswap
@code{swap}命令を生成する。

@item -matomic
@opindex matomic
これはアトミックメモリ組み込み関数を実装するためにロック・ロードストア条件拡張を有効にする。
ARC 6xxおよびARC EMコアでは利用できない。

@item -mdiv-rem
@opindex mdiv-rem
ARC v2コアのための@code{div}/@code{rem}命令を有効にする。

@item -mcode-density
@opindex mcode-density
ARC EMのコード密度命令を有効にし、ARC HSではデフォルトでオンである。

@item -mll64
@opindex mll64
ARC HSコアのダブルロード・ストア命令を有効にする。

@item -mtp-regno=@var{regno}
@opindex mtp-regno
スレッドポインタレジスタ番号を指定する。

@item -mmpy-option=@var{multo}
@opindex mmpy-option
乗数設計オプションでARCv2コードをコンパイルする。@samp{wlh1}がデフォルト値である。
@var{multo}の認識される値は：

@table @samp
@item 0
@itemx none
利用可能な乗数はなし。

@item 1
@itemx w
乗数オプションはwにセットされる。16x16乗数で完全にパイプライン化される。
以下の命令が有効になる。@code{mpyw}、@code{mpyuw}。

@item 2
@itemx wlh1
乗数オプションはwlh1にセットされる。32x32乗数で、完全にパイプライン化される（1ステージ）。
以下の命令が追加で有効にされる。@code{mpy}, @code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 3
@itemx wlh2
乗数オプションはwlh2にセットされる。32x32乗数で、完全にパイプライン化される（2ステージ）。
以下の命令が追加で有効にされる。@code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 4
@itemx wlh3
乗数オプションはwlh3にセットされる。2つの16x16乗数で、ブロックされ、直列である。
以下の命令が追加で有効にされる。: @code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 5
@itemx wlh4
乗数オプションはwlh4にセットされる。1つの16x16乗数で、ブロックされ、直列である。
以下の命令が追加で有効にされる。 @code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 6
@itemx wlh5
乗数オプションはwlh5にセットされる。1つの32x4乗数で、ブロックされ、直列である。
以下の命令が追加で有効にされる。 @code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 7
@itemx plus_dmpy
ARC HS SIMDサポート。

@item 8
@itemx plus_macd
ARC HS SIMDサポート。

@item 9
@itemx plus_qmacw
ARC HS SIMDサポート。

@end table

このオプションはARCv2コアでのみ利用可能である。

@item -mfpu=@var{fpu}
@opindex mfpu
指定されたARCv2コア用の浮動小数点ハードウェア拡張を有効にする。@var{fpu}のサポートされた値は以下である。

@table @samp

@item fpus
単精度浮動小数点ハードウェア拡張のサポートを有効にする。

@item fpud
倍精度浮動小数点ハードウェア拡張を有効にする。単精度浮動小数点拡張も有効になる。
ARC EMでは利用できない。

@item fpuda
倍精度補助命令を使った倍精度浮動小数点ハードウェア拡張のサポートを有効にする。
単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpuda_div
倍精度補助命令と、単純精度平方根と除算ハードウェア拡張を使った倍精度浮動小数点ハードウェア拡張
のサポートを有効にする。単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpuda_fma
倍精度補助命令と単純精度融合乗加算ハードウェア拡張を使った倍精度浮動小数点ハードウェア拡張
のサポートを有効にする。単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpuda_all
倍精度補助命令とすべての単純精度ハードウェア拡張を使った倍精度浮動小数点ハードウェア拡張
のサポートを有効にする。単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpus_div
単精度浮動小数点、並びに単精度平方根と除算のハードウェア拡張のサポートを有効にする。

@item fpud_div
倍精度浮動小数点、並びに倍精度平方根と除算のハードウェア拡張のサポートを有効にする。
このオプションは@samp{fpus_div}を含む。ARC EMでは利用できない。

@item fpus_fma
単精度浮動小数点、単精度融合乗加算ハードウェア拡張のサポートを有効にする。

@item fpud_fma
倍精度浮動小数点、倍精度融合乗加算ハードウェア拡張のサポートを有効にする。これは@samp{fpus_fma}を含む。
ARC EMでは利用できない。

@item fpus_all
すべての単精度浮動小数点ハードウェア拡張のサポートを有効にする。

@item fpud_all
すべての単精度・倍精度浮動小数点ハードウェア拡張のサポートを有効にする。ARC EMでは利用できない。

@end table

@item -mirq-ctrl-saved=@var{register-range}, @var{blink}, @var{lp_count}
@opindex mirq-ctrl-saved
割り込みの開始と終了時にプロセッサが自動的に保存/復元する汎用レジスタを指定します。 @var{register-range}は、ダッシュで区切られた2つのレジスタとして指定されます。 レジスタ範囲は常に@code{r0}で始まり、上限は@code{fp}レジスタです。@var{blink}と@var{lp_count}はオプションです。 このオプションは、ARC EMおよびARC HSコアでのみ有効です。

@item -mrgf-banked-regs=@var{number}
@opindex mrgf-banked-regs
高速割り込みへのエントリ時に2番目のレジスタバンクに複製されるレジスタの数を指定します。 高速割り込みは、最高の優先度レベルP0の割り込みです。 これらの割り込みは、PCとSTATUS32レジスタのみを保存し、割り込みのエントリシーケンスと終了シーケンス中のメモリトランザクションを回避します。 ARC V2ファミリプロセッサで高速割り込みを使用している場合は、このオプションを使用します。 許可される値は、4、8、16、および32です。

@item -mlpc-width=@var{width}
@opindex mlpc-width
@code{lp_count}レジスタの幅を指定します。 @var{width}の有効な値は、8、16、20、24、28、32ビットです。 デフォルトの幅は32ビットに固定されています。 幅が32未満の場合、@code{lp_count}レジスタが必要なループカウンター値を保持できることがわかっていない限り、コンパイラーはプログラム内のループを変換してゼロ遅延ループメカニズムを使用しようとしません。 指定された幅に応じて、コンパイラとランタイムライブラリはループメカニズムをさまざまなニーズに使用し続ける場合があります。 このオプションは、@var{width}の値を使用してマクロ@code{__ARC_LPC_WIDTH__}を定義します。

@item -mrf16
@opindex mrf16
このオプションは、16エントリのレジスタファイルのコードを生成するようコンパイラーに指示します。 このオプションは、@code{__ARC_RF16__}プリプロセッサマクロを定義します。

@item -mbranch-index
@opindex mbranch-index
ジャンプテーブルを実装するには、@code{bi}または@code{bih}命令の使用を有効にします。

@end table

以下のオプションはアセンブラへと渡され、プリプロセッサのマクロシンボルも定義する。

@c Flags used by the assembler, but for which we define preprocessor
@c macro symbols as well.
@table @gcctabopt
@item -mdsp-packa
@opindex mdsp-packa
DSPパックA拡張を有効にするためにアセンブラに渡される。プリプロセッサシンボル@code{__Xdsp_packa}もセットする。このオプションは廃止予定です。

@item -mdvbf
@opindex mdvbf
二重ビタビ・バタフライ拡張を有効にするためにアセンブラに渡される。プリプロセッサシンボル@code{__Xdvbf}もセットする。このオプションは廃止予定です。

@c ARC700 4.10 extension instruction
@item -mlock
@opindex mlock
ロックロード・ストア条件拡張を有効にするためにアセンブラに渡される。プリプロセッサシンボル@code{__Xlock}もセットする。

@item -mmac-d16
@opindex mmac-d16
アセンブラへ渡される。プリプロセッサシンボル@code{__Xxmac_d16}もセットする。このオプションは廃止予定です。

@item -mmac-24
@opindex mmac-24
アセンブラへ渡される。プリプロセッサシンボル@code{__Xxmac_d24}もセットする。このオプションは廃止予定です。

@c ARC700 4.10 extension instruction
@item -mrtsc
@opindex mrtsc
64ビットタイムスタンプカウンタ拡張命令を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xrtsc}も有効になる。このオプションは廃止予定です。

@c ARC700 4.10 extension instruction
@item -mswape
@opindex mswape
バイト順序反転拡張命令を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xswape}も有効になる。

@item -mtelephony
@opindex mtelephony
電話のための二重・一重イペランド命令を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xtelephony}も有効になる。このオプションは廃止予定です。

@item -mxy
@opindex mxy
XYメモリ拡張を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xxy}も有効になる。

@end table

以下のオプションはどのようにアセンブラコードが注釈されるかを制御する。

@c Assembly annotation options
@table @gcctabopt
@item -misize
@opindex misize
推定されたアドレスでアセンブラ命令を注釈する。

@item -mannotate-align
@opindex mannotate-align
どのアラインメントの考慮が命令を短くするか長くするために決定を導くかを説明する。

@end table

以下のオプションはリンカへと渡される。

@c options passed through to the linker
@table @gcctabopt
@item -marclinux
@opindex marclinux
リンカへと@code{arcliniux}エミュレーションの使用を指定するために渡される。
このオプションはプロファイリングが要求されない@w{@code{arc-linux-uclibc}}と
@w{@code{arceb-linux-uclibc}}ターゲット用にビルドされたツールチェインではデフォルトで有効である。

@item -marclinux_prof
@opindex marclinux_prof
リンカへと@code{arcliniux}エミュレーションの使用を指定するために渡される。
このオプションはプロファイリングが要求される@w{@code{arc-linux-uclibc}}と
@w{@code{arceb-linux-uclibc}}ターゲット用にビルドされたツールチェインではデフォルトで有効である。

@end table

以下のオプションは生成されたコードの意味を制御する。

@c semantically relevant code generation options
@table @gcctabopt
@item -mlong-calls
@opindex mlong-calls
呼び出し命令をレジスタ間接呼び出しとして生成し、したがって完全な32ビット範囲へのアクセスを提供する。

@item -mmedium-calls
@opindex mmedium-calls
呼び出しに、無条件分岐・リンク命令で利用可能なオフセットである25ビット未満のアドレス範囲を使わない。
関す呼び出しの条件付き実行は抑制され、条件付き分岐。リンク命令の21ビット範囲ではなく25ビット範囲が使えるようにする。
これは@w{@code{arc-linux-uclibc}}と@w{@code{arceb-linux-uclibc}}ターゲット用にビルドされたツールチェインの
デフォルトである。

@item -G @var{num}
@opindex G
データが@var{num}バイト以下の場合、外部から見えるデータの定義を小さなデータセクションに配置します。 @var{num}のデフォルト値は、ARC構成の場合は4であり、ロード/ストア操作が2回の場合は8です。

@item -mno-sdata
@opindex mno-sdata
sdata参照を生成しない。これは@w{@code{arc-linux-uclibc}}と@w{@code{arceb-linux-uclibc}}
用にビルドされたツールチェインでのデフォルトである。

@item -mvolatile-cache
@opindex mvolatile-cache
volatile参照に任意のキャッシュされたメモリアクセスを使う。これはデフォルトである。

@item -mno-volatile-cache
@opindex mno-volatile-cache
volatile参照でのキャッシュの迂回を有効にする。

@end table

以下のオプションはコード生成を調整する
@c code generation tuning options
@table @gcctabopt
@item -malign-call
@opindex malign-call
呼び出し命令で境界を最適化しない。

@item -mauto-modify-reg
@opindex mauto-modify-reg
レジスタ置換で前置・後置修正の使用を有効にする。

@item -mbbit-peephole
@opindex mbbit-peephole
bbitピープホールを有効にする。

@item -mno-brcc
@opindex mno-brcc
このオプションは@code{BRcc}命令を生成するための@file{arc_reorg}でのターゲット固有のパスを無効にする。
これは結合子パスによって導出される@code{BRcc}生成には影響しない。

@item -mcase-vector-pcrel
@opindex mcase-vector-pcrel
pc相対switchケーステーブルを使う。これはcase表短縮を有効にする。これは@option{-Os}でのデフォルトである。

@item -mcompact-casesi
@opindex mcompact-casesi
短いcasesiパターンを有効にする。これは@option{-Os}でのデフォルトである。

@item -mno-cond-exec
@opindex mno-cond-exec
条件付き実行命令を生成するためのARCompact固有のパスを無効にする。

遅延スロットスケジューリングおよび、オペランド数、リテラルサイズ、命令長、そして条件付き実行の相互作用のために、
条件付き実行を生成するためのターゲット非依存パスはしばしば存在せず、したがってARCポートは
もっと多くのレジスタ割当、分岐短縮、遅延スロットスケジューリングを見つけようとするための特別なパスを保持している。
このパスは、常にではないが、通常はパフォーマンスとコードサイズを向上させるが追加のコンパイル時間がかかり、
それがオフにするスイッチがある理由である。
もし条件付けされているために許容可能なオフセット範囲を超えた呼び出し命令で問題があるならば、代わりに
@option{-mmedium-calls}を使うことを考えるべきである。

@item -mearly-cbranchsi
@opindex mearly-cbranchsi
cbranchsiパターンのリロード前の使用を有効にする。

@item -mexpand-adddi
@opindex mexpand-adddi
RTL生成時に@code{adddi3}と@code{subdi3}を@code{add.f}、@code{adc}などの展開する。このオプションは廃止予定である。

@item -mindexed-loads
@opindex mindexed-loads
添字ロードの使用を有効にする。これはある最適化器が添字付きストアがあつと仮定してしまい、
それはこの場合には成り立たないので問題になりうる。

@item -mlra
@opindex mlra
ローカルレジスタ割当を有効にする。これはARCではまだ実験的であり、したがって
デフォルトではコンパイラは標準のリロード（すなわち、@option{-mno-lra}）を使う。

@item -mlra-priority-none
@opindex mlra-priority-none
どのターゲットレジスタの優先順位を示さない。

@item -mlra-priority-compact
@opindex mlra-priority-compact
r0..r3 / r12..r15のターゲットレジスタ優先順位を示す。

@item -mlra-priority-noncompact
@opindex mlra-priority-noncompact
r0..r3 / r12..r15のターゲットレジスタ優先順位を減じる。

@item -mmillicode
@opindex mmillicode
(@option{-Os}を使って)サイズの最適化のとき、多数のレジスタの保存と復帰をしなければならない
プロローグとエピローグはしばしばlibgccの特別な関数の呼び出しを使うことで短縮できる。
これは@emph{millicode}呼び出しとして参照される。それらの呼び出しがパフォーマンス問題を持ち出すことがあり、
また・及び非標準でリンクされるときにリンクの問題を引き起こすので、このオプションはmillicode呼び出し生成
を入り切りするために提供される。

@item -mcode-density-frame
@opindex mcode-density-frame
このオプションにより、コンパイラーは@code {enter}および@code {leave}命令を発行できます。 これらの命令は、コード密度機能を備えたCPUにのみ有効です。

@item -mmixed-code
@opindex mmixed-code
レジスタ割当を16ビット命令生成を助けるために調整する。これは通常は命令数を増やす一方、
平均命令長を減らす効果を持つ。

@item -mq-class
@opindex mq-class
"q"命令選択肢を有効にする。これは@option{-Os}ではデフォルトである。

@item -mRcq
@opindex mRcq
Rcq制約の扱いを有効にする。大抵の短いコード生成はこれに依存している。これはデフォルトである。

@item -mRcw
@opindex mRcw
Rcw制約の扱いを有効にする。ccfsm条件実行は大抵はこれに依存している。これはデフォルトである。

@item -msize-level=@var{level}
@opindex msize-level
命令長とアラインメントに関してサイズ最適化を微調整する。@var{level}の認識された値は、以下の通りである：

@table @samp
@item 0
サイズ最適化なし。このレベルは非推奨であり、@samp{1}として扱われる。

@item 1
短い命令がご都合的に使われる。

@item 2
それに加えて、ループとバリアのあとのコードのアラインメントが落とされる。

@item 3
それに加えて、余分なデータアラインメントが落とされ、オプション@option{Os}が有効になる。

@end table

デフォルトは@option{-Os}が効果があるときは@samp{3}である。それ以外のときは、
セットされていないときの振る舞いはレベル@samp{1}と等価である。

@item -mtune=@var{cpu}
@opindex mune
任意の@option{-mcpu=}によって含まれるものを上書きして、命令スケジューリングパラメータを@var{cpu}用にセットする。

@var{cpu}にサポートされる値は以下のとおりである。

@table @samp
@item ARC600
ARC600 CPU用に調整する。

@item ARC601
ARC601 CPU用に調整する。

@item ARC700
標準乗数ブロックのあるARC700 CPU用に調整する。

@item ARC700-xmac
XMACブロックのあるARC700 CPU用に調整する。

@item ARC725D
ARC725D CPU用に調整する。

@item ARC750D
ARC750D用に調整する。

@end table

@item -mmultcost=@var{num}
@opindex mmultcost
乗算命令の推測されたコストで、@samp{4}が通常命令と等しい。

@item -munalign-prob-threshold=@var{probability}
@opindex munalign-prob-threshold
非境界の分岐の確率しきい値をセットする。@samp{ARC700}用に調整され、速度で最適化されているとき、
ディレイスロットが埋まっていない分岐は、プロファイルが分岐の確率が@var{probability}
未満であると示さない限りは、できれば非境界で長く生成される。
@xref{Cross-profiling}。デフォルトは(REG_BR_PROB_BASE/2)、すなわち5000である。

@end table

以下のオプションは後方互換のために維持されているが、今は非推奨であり、将来のリリースでは削除されるだろう。

@c Deprecated options
@table @gcctabopt

@item -margonaut
@opindex margonaut
時代遅れのFPX

@item -mbig-endian
@opindex mbig-endian
@itemx -EB
@opindex EB
ビッグエンディアン・ターゲットでコードをコンパイルする。これらのオプションは今は非推奨である。
ビッグエンディアンコードを望むユーザは、ツールチェインをビルドするときに
@w{@code{arceb-elf32}}と@w{@code{arceb-linux-uclibc}}ターゲットを使うべきであり、
それはビッグエンディアンがデフォエルトである。

@item -mlittle-endian
@opindex mlittle-endian
@itemx -EL
@opindex EL
リトルエンディアン・ターゲットでコードをコンパイルする。これらのオプションは今は非推奨である。
リトルエンディアンコードを望むユーザは、ツールチェインをビルドするときに
@w{@code{arc-elf32}}と@w{@code{arc-linux-uclibc}}ターゲットを使うべきであり、
それはリトルエンディアンがデフォエルトである。

@item -mbarrel_shifter
@opindex mbarrel_shifter
@option{-mbarrel-shifter}で置き換えられた。

@item -mdpfp_compact
@opindex mdpfp_compact
@option{-mdpfp-compact}で置き換えられた。

@item -mdpfp_fast
@opindex mdpfp_fast
@option{-mdpfp-fast}で置き換えられた。

@item -mdsp_packa
@opindex mdsp_packa
@option{-mdsp-packa}で置き換えられた。

@item -mEA
@opindex mEA
@option{-mea}で置き換えられた。

@item -mmac_24
@opindex mmac_24
@option{-mmac-24}で置き換えられた。

@item -mmac_d16
@opindex mmac_d16
@option{-mmac-d16}で置き換えられた。

@item -mspfp_compact
@opindex mspfp_compact
@option{-mspfp-compact}で置き換えられた。

@item -mspfp_fast
@opindex mspfp_fast
@option{-mspfp-fast}で置き換えられた。

@item -mtune=@var{cpu}
@opindex mtune
@var{cpu}の値@samp{arc600}, @samp{arc601}, @samp{arc700}と
@samp{arc700-xmac}はそれぞれ@samp{ARC601}, @samp{ARC700} and @samp{ARC700-xmac}で置き換えられた。

@item -multcost=@var{num}
@opindex multcost
@option{-mmultcost}で置き換えられた。

@end table

@node ARM Options
@subsection ARMオプション
@cindex ARM options

これらの@samp{-m}オプションはARMポートで定義される。

@table @gcctabopt
@item -mabi=@var{name}
@opindex mabi
指定されたABI用のコードを生成する。許可された値は： @samp{apcs-gnu},
@samp{atpcs}, @samp{aapcs}, @samp{aapcs-linux} と@samp{iwmmxt}.

@item -mapcs-frame
@opindex mapcs-frame
全関数に対して、たとえコードの現在の実行には厳密には必要なくてもARM手続き呼び出し標準に準拠した
スタックフレームを生成する。このオプションと@option{-fomit-frame-pointer}を指定すると
リーフ関数用にスタックフレームは生成されない。デフォルトは@option{-mno-apcs-frame}である。
このオプションは非推奨である。

@item -mapcs
@opindex mapcs
これは@option{-mapcs-frame}の同義語であり非推奨である。

@ignore
@c not currently implemented
@item -mapcs-stack-check
@opindex mapcs-stack-check
（実際にいくつかのスタック領域を使用する）すべての関数への入力時に使用可能なスタック領域の量をチェックするコードを生成する。 十分な空き容量がない場合、必要なスタック領域の量に応じて、@code{__rt_stkovf_split_small}関数または@code{__rt_stkovf_split_big}関数が呼び出される。 ランタイムシステムは、これらの機能を提供する必要がある。 デフォルトは@option{-mno-apcs-stack-check}である。これはより小さなコードを生成するためである。

@c not currently implemented
@item -mapcs-reentrant
@opindex mapcs-reentrant
再入可能で位置に依存しないコードを生成します。 デフォルトは@option{-mno-apcs-reentrant}です。
@end ignore

@item -mthumb-interwork
@opindex mthumb-interwork
ARMとThumn命令セット間の呼び出しをサポートするコードを生成する。
このオプションなしでは、v5以前のアーキテクチャでは、2つの命令セットは
一つのプログラム内で信頼してに使うことができない。
デフォルトでは、@option{-mthumb-interwork}が指定されるとわずかに大きなコードが生成されるため、
@option{-mno-thumb-interwork}である。AAPCS設定ではこのオプションは意味を持たない。

@item -mno-sched-prolog
@opindex mno-sched-prolog
関数プロローグでの命令の並べ替え、及び関数の本体での命令とのそれらの命令との併合を防ぐ。
これは全関数が認識可能な命令の集合で始まり（もしくは実際は異なる関数プロローグの小さい集合の中から
一つ選ばれる）、この情報は実行可能ファイルのコード片内で関数の始まりを探すために使うことができる。
デフォルトは@option{-msched-prolog}である。

@item -mfloat-abi=@var{name}
@opindex mfloat-abi
どの浮動小数点ABIを使うかを指定する。可能な値は@samp{soft}, @samp{softfp}と@samp{hard}である。

@samp{soft}を指定するとGCCは浮動小数点操作用のライブラリ呼び出しを含む出力を生成させる。
@samp{softfp}はハードウェア浮動小数点命令を使うコードを生成できるようにするが、
それでもソフト浮動小数点呼び出し規約を使う。@samp{hard}は浮動小数点命令の生成を許可し、
FPU固有の呼び出し規約を使う。

デフォルトは特定のターゲット設定に依存する。ハード浮動小数点とソフト浮動小数点のABI
はリンク互換でないことに注意する。全プログラムを同じABIで、コンパイルし、
互換のあるライブラリの集合とリンクしなければならない。

@item -mgeneral-regs-only
@opindex mgeneral-regs-only
汎用レジスタのみを使用するコードを生成します。 これにより、コンパイラーは浮動小数点レジスターおよびAdvanced SIMDレジスターを使用できなくなりますが、アセンブラーに制限はありません。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンモードで実行するプロセッサ用のコードを生成する。これは
全標準設定のデフォルトである。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンモードで実行するプロセッサ用のコードを生成する。デフォルトは
リトルエンディアンプロセッサ用にコードをコンパイルする。

@item -mbe8
@itemx -mbe32
@opindex mbe8
ビッグエンディアンイメージをリンクするときは、BE8とBE32のフォーマットを選択する。このオプションはリトルエンディアンイメージには効果がなく、無視される。 デフォルトは、選択したターゲットアーキテクチャに依存する。 ARMv6以降のアーキテクチャの場合、デフォルトはBE8である。古いアーキテクチャの場合、デフォルトはBE32である。 BE32形式はARMによって推奨されていない。

@item -march=@var{name}@r{[}+extension@dots{}@r{]}
@opindex march
これはターゲットARMアーキテクチャの名前を指定する。GCCはこの名前をアセンブリコードを生成するときに
生成できる命令の種類を決定するために使う。このオプションは@option{-mcpu=}オプションと一緒に及び代わりに
使うことができる。

可能な名前は以下である： 
@samp{armv4t},
@samp{armv5t}, @samp{armv5te},
@samp{armv6}, @samp{armv6j}, @samp{armv6k}, @samp{armv6kz}, @samp{armv6t2},
@samp{armv6z}, @samp{armv6zk},
@samp{armv7}, @samp{armv7-a}, @samp{armv7ve}, 
@samp{armv8-a}, @samp{armv8.1-a}, @samp{armv8.2-a}, @samp{armv8.3-a},
@samp{armv8.4-a},
@samp{armv8.5-a},
@samp{armv8.6-a},
@samp{armv7-r},
@samp{armv8-r},
@samp{armv6-m}, @samp{armv6s-m},
@samp{armv7-m}, @samp{armv7e-m},
@samp{armv8-m.base}, @samp{armv8-m.main},
@samp{armv8.1-m.main},
@samp{iwmmxt}と@samp{iwmmxt2}.

さらに、Thumbの実行状態をサポートしない次のアーキテクチャは認識されますが、サポートは廃止予定である。
@samp{armv4}

多くのアーキテクチャが拡張をサポートしている。 これらは@samp{+@var{extension}}をアーキテクチャ名に追加することで追加できる。 拡張オプションは順番に処理され、機能が蓄積される。拡張は、それに依存する必要なベース拡張も有効にする。 例えば、@samp{+crypto}拡張は常に@samp{+simd}拡張を有効にする。 @samp{+no@dots {}}という接頭辞が付いた拡張機能は例外である。これらの拡張機能は指定されたオプションと、その拡張機能の存在に依存するその他の拡張機能を無効にする。

たとえば、@samp{-march=armv7-a+simd+nofp+vfpv4}オプションは@samp{+simd}オプションがそれに続くsamp{+nofp}オプションで完全に無効になっているので、@samp{-march=armv7-a+vfpv4}と書くのと等価である。

ほとんどの拡張名には一般的に名前が付けられているが、適用されるアーキテクチャに依存する効果がある。 たとえば、@samp{+ simd}オプションは、@samp{armv7-a}と@samp{armv8-a}の両方のアーキテクチャに適用できるが、@samp{armv7-a}の拡張ARMv7-A Advanced SIMD（Neon）と@samp{armv8-a}のARMv8-Aの拡張が有効になる。

以下の表は、各アーキテクチャでサポートされている拡張機能の一覧です。言及されていないアーキテクチャは、拡張をサポートしていない。

@table @samp
@item armv5te
@itemx armv6
@itemx armv6j
@itemx armv6k
@itemx armv6kz
@itemx armv6t2
@itemx armv6z
@itemx armv6zk
@table @samp
@item +fp
VFPv2浮動小数点命令。拡張@samp{+vfpv2}はこの拡張の別名として使うことができる。

@item +nofp
浮動小数点命令を無効化する。
@end table

@item armv7
ARMv7-A、ARMv7-R、ARMv7-Mアーキテクチャの共通部分集合。
@table @samp
@item +fp
16の倍精度レジスタを持つVFPv3浮動小数点命令。 拡張@samp{+vfpv3-d16}は、この拡張の別名として使用できる。 注意として浮動小数点数は、基本ARMv7-Mアーキテクチャではサポートされていないが、ARMv7-AおよびARMv7-Rアーキテクチャと互換性がある。

@item +nofp
浮動小数点命令を無効化する。
@end table

@item armv7-a
@table @samp
@item +fp
16の倍精度レジスタを持つVFPv3浮動小数点命令。 拡張@samp{+vfpv3-d16}は、この拡張の別名として使用できる。 

@item +sec
セキュリティ拡張。

@item +fp
16個の倍精度レジスタを備えたVFPv3浮動小数点命令。 拡張@samp{+vfpv3-d16}は、この拡張のエイリアスとして使用できます。

@item +simd
Advanced SIMD (Neon) v1とVFPv3浮動小数点命令。拡張@samp{+neon}と@samp{+neon-vfpv3}はこの命令の別名として使用できる。

@item +vfpv3
32の倍精度レジスタを持つVFPv3浮動小数点命令。

@item +vfpv3-d16-fp16
16の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv3-fp16
32の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv4-d16
16の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +vfpv4
32の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +neon-fp16
Advanced SIMD (Neon) v1と半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +neon-vfpv4
Advanced SIMD (Neon) v2とVFPv4浮動小数点命令。

@item +nosimd
Advanced SIMD命令を無効化する（浮動小数点は無効化しない）

@item +nofp
浮動小数点数とAdvanced SIMD命令を無効化する。
@end table

@item armv7ve
仮想化のサポートを持つARMv7-Aアーキテクチャの拡張バージョン。
@table @samp
@item +fp
16の倍精度レジスタを持つVFPv4浮動小数点命令。 拡張@samp{+vfpv4-d16}は、この拡張の別名として使用できる。 

@item +simd
Advanced SIMD (Neon) v2とVFPv4浮動小数点命令。拡張@samp{+neon-vfpv4}はこの命令の別名として使用できる。

@item +vfpv3-d16
16の倍精度レジスタを持つVFPv3浮動小数点命令。

@item +vfpv3
32の倍精度レジスタを持つVFPv3浮動小数点命令。

@item +vfpv3-d16-fp16
16の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv3-fp16
32の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv4-d16
16の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +vfpv4
32の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +neon
Advanced SIMD (Neon) v1とVFPv3浮動小数点命令。拡張@samp{+neon-vfpv3}はこの命令の別名として使用できる。

@item +neon-fp16
Advanced SIMD (Neon) v1と半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +nosimd
Advanced SIMD命令を無効化する（浮動小数点数は無効化しない）

@item +nofp
浮動小数点数とAdvanced SIMD命令を無効化する。
@end table

@item armv8-a
@table @samp
@item +crc
循環冗長検査（CRC）命令。
@item +simd
ARMv8-A Advanced SIMDと浮動小数点命令。
@item +crypto
暗号命令。
@item +nocrypto
暗号命令を無効化する。
@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。
@item +sb
投機バリア命令。
@item +predres
実行およびデータ予測制限命令。
@end table

@item armv8.1-a
@table @samp
@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令。

@item +crypto
暗号命令。これはAdvanced SIMDと浮動小数点命令も有効化する。

@item +nocrypto
暗号命令を無効化する。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。

@item +sb
投機バリア命令。

@item +predres
実行およびデータ予測制限命令。
@end table

@item armv8.2-a
@itemx armv8.3-a
@table @samp
@item +fp16
半精度符号小数点データ処理命令。これはAdvanced SIMDと浮動小数点命令も有効化する。

@item +fp16fml
半精度浮動小数点fmla拡張。これは半精度浮動小数点拡張とAdvanced SIMD、浮動小数点命令も有効化する。

@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令。

@item +crypto
暗号命令。これはAdvanced SIMDと浮動小数点命令も有効化する。

@item +dotprod
内積拡張を有効化する。これは、Advanced SIMD命令も有効化する。

@item +nocrypto
暗号拡張を無効化する。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。

@item +sb
投機バリア命令。

@item +predres
実行およびデータ予測制限命令。

@item +i8mm
8ビット整数行列乗算命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。

@item +bf16
ブレイン半精度浮動小数点命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。
@end table

@item armv8.4-a
@table @samp
@item +fp16
半精度浮動小数点データ処理命令。これはAdvanced SIMD、浮動小数点命令だけでなく、内積拡張と半精度浮動小数点fmla拡張も有効にする。

@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令に加えて内積拡張。

@item +crypto
暗号命令。これはAdvanced SIMD、浮動小数点命令に加えて内積拡張も有効にする。

@item +nocrypto
暗号拡張を無効にする。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。

@item +sb
投機バリア命令。

@item +predres
実行およびデータ予測制限命令。

@item +i8mm
8ビット整数行列乗算命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。

@item +bf16
ブレイン半精度浮動小数点命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。
@end table

@item armv8.5-a
@table @samp
@item +fp16
半精度浮動小数点データ処理命令。これはAdvanced SIMD、浮動小数点命令だけでなく、内積拡張と半精度浮動小数点fmla拡張も有効にする。

@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令に加えて内積拡張。

@item +crypto
暗号命令。これはAdvanced SIMD、浮動小数点命令に加えて内積拡張も有効にする。

@item +nocrypto
暗号拡張を無効にする。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。

@item +i8mm
8ビット整数行列乗算命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。

@item +bf16
ブレイン半精度浮動小数点命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。
@end table

@item armv8.6-a
@table @samp
@item +fp16
半精度浮動小数点データ処理命令。これはAdvanced SIMD、浮動小数点命令だけでなく、内積拡張と半精度浮動小数点fmla拡張も有効にする。

@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令に加えて内積拡張。

@item +crypto
暗号命令。これはAdvanced SIMD、浮動小数点命令に加えて内積拡張も有効にする。

@item +nocrypto
暗号拡張を無効にする。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。

@item +i8mm
8ビット整数行列乗算命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。

@item +bf16
ブレイン半精度浮動小数点命令。
これにより、Advanced SIMDおよび浮動小数点命令も有効になります。
@end table

@item armv7-r
@table @samp
@item +fp.sp
単精度VFPv3浮動小数点命令。拡張@samp{+vfpv3xd}をこの拡張の別名として使用可能である。

@item +fp
16の倍精度レジスタを持つVFPv3浮動小数点命令。拡張@samp{+vfpv3-d16}をこの拡張の別名として使用可能である。

@item +vfpv3xd-d16-fp16
16の倍精度レジスタと半精度の浮動小数点変換演算を備えた単精度VFPv3浮動小数点命令。

@item +vfpv3-d16-fp16
16の倍精度レジスタと半精度の浮動小数点変換演算を備えたVFPv3浮動小数点命令。

@item +nofp
浮動小数点拡張を無効にする。

@item +idiv
ARM状態整数除算命令。

@item +noidiv
ARM状態整数除算拡張を無効化する。
@end table

@item armv7e-m
@table @samp
@item +fp
単精度VFPv4浮動小数点命令。

@item +fpv5
単精度FPv5浮動小数点命令。

@item +fp.dp
単精度・倍精度VFPv5浮動小数点命令。

@item +nofp
浮動小数点拡張を無効化する。
@end table

@item  armv8.1-m.main
@table @samp

@item +dsp
DSP命令。

@item +mve
Mプロファイルベクトル拡張（MVE）整数命令。

@item +mve.fp
Mプロファイルベクトル拡張（MVE）整数および単精度浮動小数点命令。

@item +fp
単精度浮動小数点命令。

@item +fp.dp
単精度・倍精度浮動小数点命令。

@item +nofp
浮動小数点拡張を無効化する。

@item +cdecp0, +cdecp1, ... , +cdecp7
オプションで指定された数値（0〜7）に従って、選択したコプロセッサーでカスタムデータパス拡張（CDE）を有効にします。
@end table

@item  armv8-m.main
@table @samp
@item +dsp
DSP命令。

@item +nodsp
DSP拡張を無効化する。

@item +fp
単精度浮動小数点命令。

@item +fp.dp
単精度・倍精度浮動小数点命令。

@item +nofp
浮動小数点拡張を無効化する。

@item +cdecp0, +cdecp1, ... , +cdecp7
オプションで指定された数値（0〜7）に従って、選択したコプロセッサーでカスタムデータパス拡張（CDE）を有効にします。
@end table

@item armv8-r
@table @samp
@item +crc
循環冗長検査（CRC)命令。
@item +fp.sp
単精度FPv5浮動小数点命令。
@item +simd
ARMv8-A Advanced SIMDと浮動小数点命令。
@item +crypto
暗号命令。
@item +nocrypto
暗号命令を無効化する。
@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。
@end table

@end table

@option{-march=native}はビルドコンピュータのアーキテクチャを自動で検出させる。
現在は、この機能はGNU/Linuxでのみサポートされていて、すべてのアーキテクチャが認識されるわけではない。
もし自動検出が不成功ならばこのオプションはなんの効果もない。

@item -mtune=@var{name}
@opindex mtune
このオプションはGCCはコードのパフォーマンスを調整すべきターゲットARMプロセッサの名前を指定する。
ありARM実装ではこのオプションを使うことでよりよいパフォーマンスを得ることができる。
可能な名前は以下である： @samp{arm7tdmi}, @samp{arm7tdmi-s}, @samp{arm710t},
@samp{arm720t}, @samp{arm740t}, @samp{strongarm}, @samp{strongarm110},
@samp{strongarm1100}, 0@samp{strongarm1110}, @samp{arm8}, @samp{arm810},
@samp{arm9}, @samp{arm9e}, @samp{arm920}, @samp{arm920t}, @samp{arm922t},
@samp{arm946e-s}, @samp{arm966e-s}, @samp{arm968e-s}, @samp{arm926ej-s},
@samp{arm940t}, @samp{arm9tdmi}, @samp{arm10tdmi}, @samp{arm1020t},
@samp{arm1026ej-s}, @samp{arm10e}, @samp{arm1020e}, @samp{arm1022e},
@samp{arm1136j-s}, @samp{arm1136jf-s}, @samp{mpcore}, @samp{mpcorenovfp},
@samp{arm1156t2-s}, @samp{arm1156t2f-s}, @samp{arm1176jz-s}, @samp{arm1176jzf-s},
@samp{generic-armv7-a}, @samp{cortex-a5}, @samp{cortex-a7}, @samp{cortex-a8},
@samp{cortex-a9}, @samp{cortex-a12}, @samp{cortex-a15}, @samp{cortex-a17},
@samp{cortex-a32}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a55},
@samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
@samp{cortex-a76}, @samp{cortex-a76ae}, @samp{cortex-a77},
@samp{cortex-a78}, @samp{cortex-a78ae}, @samp{cortex-a78c},
@samp{ares}, @samp{cortex-r4}, @samp{cortex-r4f},
@samp{cortex-r5}, @samp{cortex-r7}, @samp{cortex-r8}, @samp{cortex-r52},
@samp{cortex-m0}, @samp{cortex-m0plus}, @samp{cortex-m1}, @samp{cortex-m3},
@samp{cortex-m4}, @samp{cortex-m7}, @samp{cortex-m23}, @samp{cortex-m33},
@samp{cortex-m35p}, @samp{cortex-m55}, @samp{cortex-x1},
@samp{cortex-m1.small-multiply}, @samp{cortex-m0.small-multiply},
@samp{cortex-m0plus.small-multiply}, @samp{exynos-m1}, @samp{marvell-pj4},
@samp{neoverse-n1}, @samp{neoverse-n2}, @samp{neoverse-v1}, @samp{xscale},
@samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}, @samp{fa526}, @samp{fa626},
@samp{fa606te}, @samp{fa626te}, @samp{fmp626}, @samp{fa726te}, @samp{xgene1}.

それに加えて、このオプションはGCCがbig.LITTLEシステム用のコードのパフォーマンスを調整すべきかを指定することができる。
可能な名前は以下である：
@samp{cortex-a15.cortex-a7}, @samp{cortex-a17.cortex-a7},
@samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
@samp{cortex-a72.cortex-a35}, @samp{cortex-a73.cortex-a53},
@samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55}

@option{-mtune=generic-@var{arch}}はGCCがアーキテクチャ@var{arch}内のプロセッサの混合用に
パフォーマンスを調整すべきことを指定する。
目的は現在の最も有名なプロセッサでよく走り、その範囲でのあるCPUで有益である最適化の間でバランスを取り、
他のCPUのパフォーマンスの落とし穴を避けることである。このオプションの効果はCPUモデルが出入りするごとに
将来のGCCバージョンでは変化するかもしれない。

@option{-mtune}は@option{-mcpu}と同じ拡張オプションを許可するが、拡張オプションは生成されたコードのチューニングに影響しない。
 
@option{-mtune=native}はコンパイラにCPUを自動検出させる。現在は、この機能はGNU/Linuxでのみサポートされていて、
すべてのアーキテクチャで認識されるわけではない。もし自動検出が不成功ならばこのオプションはなんの効果もない。

@item -mcpu=@var{name}@r{[}+extension@dots{}@r{]}
@opindex mcpu
ターゲットARMプロセッサの名前を指定する。GCCはこの名前を
（まるで@option{-march}で指定されたかのように）ターゲットARMアーキテクチャの名前と
（まるで@option{-mtune}で指定されたかのように）パフォーマンスの調整に用いるARMプロセッサタイプ
を導出するために使う。このオプションが@option{-march}または@option{-mtune}と一緒に使われたときは、
これらのオプションはこのオプションの対応する部分に優先する。

サポートされているCPUの多くは、オプションのアーキテクチャ拡張を実装している。 そうであるところでは、アーキテクチャの拡張は通常、デフォルトで有効になっている。 拡張がない実装が存在する場合、拡張構文を使用して省略された拡張を無効にすることができる。 浮動小数点およびAdvanced SIMD（Neon）命令の場合は、オプション@option{-mfloat-abi}および@option{-mfpu}の設定も考慮する必要がある。浮動小数点およびAdvanced SIMD命令は、@option{-mfloat-abi}は@samp{soft}に設定されていない。 @samp{auto}以外の@option{-mfpu}の設定は、利用可能な浮動小数点命令とSIMD拡張命令を上書きする。

例えば、@samp{cortex-a9}は3つの主要な構成で見つけることができる：整数のみ、浮動小数点ユニットのみ、または浮動小数点とAdvanced SIMD。 デフォルトではすべての命令が有効になるが、拡張@samp{+nosimd}と@samp{+nofp}を使用して、SIMDだけ、またはSIMD命令と浮動小数点命令の両方を無効にすることができる。

このオプションの可能な値は@option{-mtune}のものと同じである。

以下の拡張オプションは、リストされているCPUに共通です。

@table @samp
@item +nodsp
@samp{cortex-m33}, @samp{cortex-m35p}での@samp{cortex-m33}のDSP命令を無効にする。

@item  +nofp
@samp{arm9e}、@samp{arm946e-s}、@samp{arm966e-s}、@samp{arm968e-s}、@samp{arm10e}、@samp{arm1020e}、@samp{arm1022e}、@samp{arm926ej-s}、@samp{arm1026ej-s}、@samp{cortex-r5}、@samp{cortex-r7}、@samp{cortex-r8}、@samp{cortex-m4}、@samp{cortex-m7}、@samp{cortex-m33}、および@samp{cortex-m35p}の浮動小数点命令を無効にします。

@samp{generic-armv7-a}、@samp{cortex-a5}、@samp{cortex-a7}、@samp{cortex-a8}、@samp{cortex-a9}、@samp{cortex-a12}、@samp{cortex-a15}、@samp{cortex-a17}、@samp{cortex-a15.cortex-a7}、@samp{cortex-a17.cortex-a7}、@samp{cortex-a32}、@samp{cortex-a35}、@samp{cortex-a53}、および@samp{cortex-a55}の浮動小数点およびSIMD命令を無効にします 。

@item +nofp.dp
@samp{cortex-r5}, @samp{cortex-r7}, @samp{cortex-r8}, @samp{cortex-r52},
@samp{cortex-m7}における浮動小数点命令の倍精度構成要素を無効化する。

@item +nosimd
@samp{generic-armv7-a}, @samp{cortex-a5}, @samp{cortex-a7}, @samp{cortex-a9}でのSIMD命令を無効化する（が、不動小数点はしない）
 
@item +crypto
@samp{cortex-a32}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a55}, @samp{cortex-a57},
@samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75}, @samp{exynos-m1},
@samp{xgene1}, @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
@samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
@samp{cortex-a75.cortex-a55}で暗号命令を有効化する。
@end table

さらに、@samp{generic-armv7-a}擬似ターゲットは、16倍精度レジスタを持つVFPv3にデフォルト設定されている。次の拡張オプションをサポートしている。@samp{mp}, @samp{sec}, @samp{vfpv3-d16},
@samp{vfpv3}, @samp{vfpv3-d16-fp16}, @samp{vfpv3-fp16},
@samp{vfpv4-d16}, @samp{vfpv4}, @samp{neon}, @samp{neon-vfpv3},
@samp{neon-fp16}, @samp{neon-vfpv4}.  意味は@option{-march=armv7-a}への拡張と同じである。

@option{-mcpu=generic-@var{arch}}も許可され、@option{-march=@var{arch} -mtune=generic-@var{arch}}
と等価である。さらなる情報は@option{-mtune}を見よ。

@option{-mcpu=native}はコンパイラにビルドコンピュータのCPUを自動検出させる。
現在は、この機能はGNU/Linuxでのみサポートされていて、すべてのアーキテクチャが認識されるわけではない。。
もし自動検出が不成功ならば、オプションはなんの効果もない。

@item -mfpu=@var{name}
@opindex mfpu
これはどの浮動小数点ハードウェア（またはハードウェアエミュレーション）がターゲットで利用可能化を指定する。
可能な名前は以下のとおりである： @samp{auto}, @samp{vfpv2}, @samp{vfpv3},
@samp{vfpv3-fp16}, @samp{vfpv3-d16}, @samp{vfpv3-d16-fp16}, @samp{vfpv3xd},
@samp{vfpv3xd-fp16}, @samp{neon-vfpv3}, @samp{neon-fp16}, @samp{vfpv4},
@samp{vfpv4-d16}, @samp{fpv4-sp-d16}, @samp{neon-vfpv4},
@samp{fpv5-d16}, @samp{fpv5-sp-d16},
@samp{fp-armv8}, @samp{neon-fp-armv8}, @samp{crypto-neon-fp-armv8}。
@samp{neon}は@samp{neon-vfpv3}の別名であり、@samp{vfp}は@samp{vfpv2}の別名であることに注意。

設定@samp{auto}がデフォルトであり、これは特別である。それはコンパイラに@option{-mcpu}と@option{-march}の設定に基づいて浮動小数点とAdvanced SIMD命令を選択させる。

もし選択された浮動小数点ハードウェアがNEON拡張（例えば、@option{-mfpuneon})を含むなら、
浮動小数点操作は@option{-funsafe-math-optimizations}も指定しない限りはGCCの自動ベクトル化によっては
生成されない。これはNEONハードウェアが浮動小数点算術がIEEE754標準を完全には実装していないため、
（特に非正規数は０として扱われる）NEON命令の使用は精度の消失を導くかもしれないためである。

@code{target("fpu=")}関数属性(@pxref{ARM Function Attributes})か
プラグマ(@pxref{Function Specific Option Pragmas})を使うことfpu名を設定することもできる。

@item -mfp16-format=@var{name}
@opindex mfp16-format
@code{__fp16}半精度浮動小数点型の書式を指定する。可能な値は@samp{none}, @samp{ieee}, 
@samp{alternative}である。デフォルトは@samp{none}であり、その場合には@code{__fp16}型は定義されない。
さらなる情報は@xref{Half-Precision}参照。

@item -mstructure-size-boundary=@var{n}
@opindex mstructure-size-boundary
全構造体と共用体はこのオプションによってセットされたビットの数の倍数に丸められる。
可能な値は8，32, 64である。デフォルト値はツールチェーンで異なる。COFFターゲットのツールチェーンでは
デフォルト値は8であり。もし基準となるABIがサポートするならばその場合だけ64の値が許される。

大きな数を指定すると、より速くて効率的なコードを生成できるが、プログラムのサイズが大きくなる。
異なる値は潜在的に非互換である。ある値でコンパイルされたコードは、もしそれらが構造体や共用体を使った情報
をやり取りするならば、必ずしも他の値でコンパイルされたコードやライブラリと一緒に動くことは期待できない。

このオプションは廃止予定です。

@item -mabort-on-noreturn
@opindex mabort-on-noreturn
@code{noreturn}関数の終わりで@code{abort}への呼び出しを生成する。これは関数が帰ろうとすれば実行される。

@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
コンパイラに最初にレジスタに関数のアドレスをロードして、
それからこのレジスタでサブルーチン呼び出しを実行することで関数呼出しを実行するように伝える。
このスイッチはターゲット関数がサブルーチン呼び出し命令のオフセットに基づいたバージョンの64メガバイトの
アドレスの範囲の外にあるならば必要である。

このスイッチが有効であるとしても、すべての関数がロング・コールへと変換されるわけではない。
発見法は、静的関数、@code{short_call}属性を持つ関数、
@code{#pragma no_long_calls}ディレクティブのスコープ内の関数、その定義がすでに現在の翻訳単位内で
コンパイルされた関数ははロング・コールへと変換されないことである。この規則の例外は弱い関数定義、
@code{long_call}属性か@code{seciton}属性を持つ関数、@code{#pragma long_calls}ディレクティブのスコープ内の
関数は常にロングコールへと変換されることである。

この機能はデフォルトでは有効にされない。@option{-mno-long-calls}を指定すると、
デフォルトの機能が復元され、@code{#pragma}ディレクティブのスコープ内に関数が置かれたようになる。
これらのスイッチは関数ポインタ経由で関数呼び出しを使うコードをコンパイラがどのように生成するかには関係しない。

@item -msingle-pic-base
@opindex msingle-pic-base
PICアドレス計算に使われるレジスタを、それぞれの関数のプロローグでロードされるのではなく、
読み取り専用として扱う。ランタイムシステムは実行が始まるまえにこのレジスタを適切な値で初期化する責任がある。

@item -mpic-register=@var{reg}
@opindex mpic-register
PICアドレス計算で使われるレジスタを指定する。標準のPICベースの場合には、デフォルトは
コンパイラによって決定される任意の適切なレジスタである。単一のPICベースの場合には、
もしEABIベースであるか、スタックチェックが有効ならば、@samp{R9}であり、
さもなければデフォルトは@samp{R10}である。

@item -mpic-data-is-text-relative
@opindex mpic-data-is-text-relative
それぞれのデータセグメントがロード時のテキストセグメントの相対であると仮定する。
したがって、PC相対命令を使ったデータのアドレス計算を許可する。このオプションは
VxWorksRTP以外のターゲットではデフォルトでオンである。 このようなターゲットで無効のときは、
デフォルトで@option{-msingle-pic-base}が有効になる。

@item -mpoke-function-name
@opindex mpoke-function-name
それぞれの関数の名前をテキストセクションに、関数プロローグの直前に書く。生成されるコードはこれのようになる。

@smallexample
     t0
         .ascii "arm_poke_function_name", 0
         .align
     t1
         .word 0xff000000 + (t1 - t0)
     arm_poke_function_name
         mov     ip, sp
         stmfd   sp!, @{fp, ip, lr, pc@}
         sub     fp, ip, #4
@end smallexample

スタックバックトレースを実行すると金費、コードは@code{fp + 0}に格納された@code{pc}の値を検査することができる。
もしその時トレース関数が場所@code{pc-12}を見て最初の8ビットがセットされているならば、
この場所の直前に関数名が埋め込まれていてその長さが@code{((pc[-3]) & 0xff000000)}であることがわかる。

@item -mthumb
@itemx -marm
@opindex marm
@opindex mthumb

生成するコードが実行する状態をARMとThumb状態での間で選択する。
多くの設定でのデフォルトはARM状態で実行するが、デフォルトは
@option{--with-mode=}@var{state}設定オプションでGCCを設定することで変えることができる。

@code{target("thumb")}と@code{target("arm")}関数属性(@pxref{ARM Function Attributes})および
プラグマ(@pxref{Function Specific Option Pragmas})を使うことでそれぞれの関数で
ARMとThumbモードを上書きすることができる。

@item -mflip-thumb 
@opindex mflip-thumb
交互機能でARM/Thumbモードを切り替えます。 このオプションは、Thumb/ARMコードの混合生成の回帰テスト用に提供されており、コードのコンパイルでの通常の使用を目的としていません。

@item -mtpcs-frame
@opindex mtpcs-frame
全非リーフ関数にThumb手続き呼び出し標準に適合したスタックフレームを生成する。
（リーフ関数は他の関数を呼ばない関数である。）デフォルトは@option{-mno-tpcs-frame}.

@item -mtpcs-leaf-frame
@opindex mtpcs-leaf-frame
すべてのリーフ関数にThumb手続き呼び出し標準に適合したスタックフレームを生成する。
（リーフ関数は他の関数を呼ばない関数である。）デフォルトは@option{-mno-apcs-leaf-frame}

@item -mcallee-super-interworking
@opindex mcallee-super-interworking
関数の残りの部分を実行する前に、Thumbモードに切り替わるARM命令セットヘッダを、
コンパイルされるファイル内のすべての外部から見える関数に渡す。
これはそれらの関数が非連携コードから呼ばれることを可能にする。
このオプションはAAPCS設定では連携がデフォルトで有効になっているために不正である。

@item -mcaller-super-interworking
@opindex mcaller-super-interworking
関数ポインタ（仮想関数を含む）経由での呼び出しがターゲットコードが連携ありで
コンパイルされたかどうかにかかわらず正しく実行できるようにする。このオプションが有効ならば
関数ポインタの実行のコストには小さなオーバーヘッドがある。このオプションはAAPCS設定では
連携がデフォルトで有効になっているので不正である。

@item -mtp=@var{name}
@opindex mtp
スレッドローカル領域ポインタ用のアクセスモデルをシチエする。正当な値は、
@code{_aeabi_read_tp}への呼び出しを生成する@samp{soft}と、
(arm6kアーキテクチャでサポートされた）直接@code{cp15}からスレッドポインタを取る
@samp{cp15}、選択されたプロセッサで利用可能な最善の方法を使う@samp{auto}である。

@item -mtls-dialect=@var{dialect}
@opindex mtls-dialect
スレッドローカル領域にアクセスする方法の変種を指定する。2つの
@var{dialect}がサポートされている。@samp{gnu}と@samp{gnu2}である。
@samp{gnu}変種はローカルとグローバルの動的TLSモデルをサポートするもともとのGNUのスキームを選択する。
@samp{gnu2}変種はGNUディスクリプタスキームを選択肢、それは共有ライブラリでよりよいパフォーマンスを提供する。
GNUディスクリプタスキーマはもともとのスキームと互換性があるが、新しいアセンブラ、リンカとライブラリの
サポートが必要である。初期とローカルの実行のTSLモデルはこのオプションには影響されず、
もともとのスキームが常に使われる。

@item -mword-relocations
@opindex mword-relocations
ワード長の値(すなわち、R_ARM_ABS32)で絶対再割当てのみを生成する。
これはランタイムローダーがこの制限を課しているターゲット（uClinux, SymbianOS）で、
@option{-fpic}及び@option{-fPIC}が指定されているときにデフォルトで有効である。

@item -mfix-cortex-m3-ldrd
@opindex mfix-cortex-m3-ldrd
あるCortex-M3コアは@code{ldrd}命令が重なったデスティネーションとベースレジスタが使われたときに、
データ破壊を引き起こしうる。このオプションはこれらの命令の生成を酒雨r。このオプションは
@option{-mcpu=cortex-m3}が指定されたときにデフォルトで有効である。

@item -munaligned-access
@itemx -mno-unaligned-access
@opindex munaligned-access
@opindex mno-unaligned-access
16及び32ビットに合わせていないアドレスからの16及び32ビット値の読み書きを有効（無効）にする。
デフォルトでは、非境界のアクセスはARMv6より前すべてとARMv6-M全アーキテクチャで無効であり、
他のすべてのアーキテクチャで有効である。境界のあっていないアクセスは有効でないならば、
詰められたデータ構造でのワードは一度に1バイトアクセスされる。

ARM属性@code{Tag_CPU_unaligned_access}がこのオプションの設定に依存して、
生成されたオブジェクトファイルに真か偽でセットされる。もし非境界のアクセスが有効ならば、、
プリプロセッサシンボル@code{__ARM_FEATURE_UNALIGNED}も定義される。

@item -mneon-for-64bits
@opindex mneon-for-64bits
スカラー64ビット操作を扱うためにNeonを使う。これは、コアレジスタからNeonへのデータの移動コストが高いため、
デフォルトでは無効である。

@item -mslow-flash-data
@opindex mslow-flash-data
flashからのデータの読み込みが命令の取得よりも遅いと仮定する。したがって、パフォーマンス向上のために
定数のロードは最小化される。このオプションはARMv7 Mプロファイル用にコンパイルした時だけサポートされ、
デフォルトではオフである。

@item -masm-syntax-unified
@opindex masm-syntax-unified
インラインアセンブラは統一asm構文を使っているとか定数r。デフォルトは現在はオフであり、分割構文を意味する。
このオプションはThumb2では効果がない。しかし、これはGCCはの将来のリリースではカラルかもしれない。
分割構文は非推奨とみなされるべきである。

@item -mrestrict-it
@opindex mrestrict-it
ARMv8-Aの規則に適合するためにITブロックの生成を制限する。ITブロックは命令の選択された集合からの
単一の16ビット命令のみを含むことができる。このオプションはARMv8-A Thumbモードではデフォルトでオンである。

@item -mprint-tune-info
@opindex mprint-tune-info
アセンブラファイルでのコメントとしてCPU調整情報を出力する。これはコンパイラの退行試験用のみに使われるオプションであり、
コードをコンパイルする通常の使用は意図していない。このオプションはデフォルトで無効である。

@item -mverbose-cost-dump
@opindex mverbose-cost-dump
デバッグダンプファイルで詳細なコストモデルのダンプを有効にする。 このオプションは、コンパイラのデバッグに使用するために用意されている。

@item -mpure-code
@opindex mpure-code
コードセクションに定数データを配置しない。さらに、ELFオブジェクト形式用にコンパイルするとき、すべてのテキストセクションにELFプロセッサ固有のセクション属性@code{SHF_ARM_PURECODE}が与えられる。 このオプションは、MOVT命令を使用してM-プロファイルターゲット用に非picコードを生成する場合にのみ使用できる。

@item -mcmse
@opindex mcmse
「ARMv8-Mセキュリティ拡張機能：開発ツールのエンジニアリング仕様に関する要件」に従って、セキュアなコードを生成する。この文書は
@url{http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf}にある。

@item -mfdpic
@itemx -mno-fdpic
@opindex mfdpic
@opindex mno-fdpic
64ビット関数記述子を使用して関数へのポインタを表すFDPIC ABIを選択します。 コンパイラーが@code{arm-*-uclinuxfdpiceabi}ターゲット用に構成されている場合、このオプションはデフォルトでオンになり、PIC / PIE関連のオプションが提供されない場合は@option{-fPIE}を暗黙指定します。 他のターゲットでは、FDPIC固有のコード生成機能のみを有効にし、ユーザーは必要に応じてPIC / PIE関連のオプションを明示的に提供する必要があります。

静的リンクは、プログラムが自己再配置するときに動的リンカーがまだ含まれるため、サポートされていないことに注意してください。 そのような動作が許容できる場合は、-staticおよび-Wl、-dynamic-linkerオプションを使用してください。

反対の@option{-mno-fdpic}オプションは、ユーザーランドプログラムのビルドに使用したものと同じ（@code {arm-*-uclinuxfdpiceabi}）ツールチェーンを使用してLinuxカーネルをビルドするのに役立ちます（必要です）。

@end table

@node AVR Options
@subsection AVRオプション
@cindex AVR Options

これらのオプションはAVR実装用に定義されている。

@table @gcctabopt
@item -mmcu=@var{mcu}
@opindex mmcu
Atmel AVR命令セットアーキテクチャ(ISA)かMCUタイプを指定する。

このオプションのデフォルトは@tie{}@samp{avr2}である。

GCCは以下のAVRデバイスとISAをサポートしている。

@include avr-mmcu.texi

@item -mabsdata
@opindex mabsdata
スタティックストレージ内のすべてのデータにLDS / STS命令でアクセスできると仮定する。 このオプションは、ATtiny40のようなTinyデバイスの縮小にのみ影響する。
@code{absdata} @ref{AVR Variable Attributes,variable attribute}も見よ。

@item -maccumulate-args
@opindex maccumulate-args
関数のプロローグ/エピローグで、出力関数の引数を累積し、出力関数の引数に必要なスタック領域を取得/解放する。 このオプションがなければ、発信引数はプッシュされてから関数が呼び出され、後でポップされる。

関数呼び出し後に引数をポップすると、AVR上でコストがかかることがある。そのような関数呼び出し後に引数をスタックから削除する必要がないため、スタック領域を累積すると実行可能ファイルが少なくなる可能性がある。

このオプションは、printfのような関数への呼び出しのように引数をスタックに渡す関数へのいくつかの呼び出しを行う関数のコードサイズを減らすことができる。

@item -mbranch-cost=@var{cost}
@opindex mbranch-cost
条件付き分岐命令の分岐コストを@var{cost}に設定する。 @var{cost}の合理的な値は、小さな負でない整数である。 デフォルトの分岐コストは0である。

@item -mcall-prologues
@opindex mcall-prologues
関数プロローグ/エピローグは、適切なサブルーチンへの呼び出しとして展開される。 コードサイズが小さくなる。

@item -mdouble=@var{bits}
@itemx -mlong-double=@var{bits}
@opindex mdouble
@opindex mlong-double
@code{double}タイプまたは@code{long double}タイプのサイズ（ビット単位）をそれぞれ設定します。 @var{bits}の可能な値は32および64です。@var{bits}の特定の値が許可されるかどうかは@code{-with-double=}および@code{-with-long-double=} @w{@uref{https://gcc.gnu.org/install/configure.html#avr,configure options}}、およびオプションのデフォルト値にも同じことが適用されます。

@item -mgas-isr-prologues
@opindex mgas-isr-prologues
割り込みサービスルーチン（ISR）は、GNU Binutilsでサポートされている@code{__gcc_isr}疑似命令を使用できます。
このオプションがオンの場合でも、@ref{AVR Function Attributes,,@code{no_gccisr}}関数属性を使用して、個々のISRの機能を無効にすることができます。 この機能は、最適化がオン（@option{-Og}、@pxref{Optimize Options}を除く）で、GNU Binutilsが@w{@uref {https://sourceware.org/PR21683,PR21683}}をサポートしている場合、デフォルトでアクティブになります。 

@item -mint8
@opindex mint8
@code{int}が8ビット整数であると仮定する。 @code{char}は1バイト、@code{int}は1バイト、@code{long}は2バイト、@code{long long}は4バイトである。 このオプションはC標準に準拠していないが、コードサイズは小さくなる。
size.

@item -mmain-is-OS_task
@opindex mmain-is-OS_task
@code{main}にレジスタを保存しない。 効果は、属性@ref{AVR Function Attributes,,@code{OS_task}}を@code{main}にアタッチするのと同じです。 最適化がオンの場合、デフォルトでアクティブになります。

@item -mn-flash=@var{num}
@opindex mn-flash
フラッシュメモリサイズが64@tie{}KiBの@var{num}倍と仮定する。

@item -mno-interrupts
@opindex mno-interrupts
ハードウェア割り込みと互換性のないコードを生成する。コードサイズが小さくなる。

@item -mrelax
@opindex mrelax
可能なら@code{CALL}、@code{JMP}命令をそれぞれより短い@code{RCALL}、@code{RJMP}命令で置き換えようとする。
@option{-mrelax}の設定は単にアセンブラのコマンド行に@option{mrelax}を加え、リンカのコマンド行に@option{--relax}オプションを加える。

ジャンプ・リラックスは、ジャンプオフセットがコードが配置される前には既知でないので、リンカによって実行される。したがって、アセンブラコードは、コンパイラは同じだが、実行可能ファイル内の命令は、アセンブラコードの命令とは異る。

リンカスタブが必要な場合は、リラクシングをオンにする必要があります。
以下の@code {EIND}セクションとリンカスタブのセクションを参照すること。

@item -mrmw
@opindex mrmw
デバイスが読み込み・修正・書き込み命令@code{XCH}、@code{LAC}、@code{LAS}、@code{LAT}をサポートしていると仮定する。

@item -mshort-calls
@opindex mshort-calls

@code{RJMP}と@code{RCALL}がプログラムメモリ全体をターゲットにできると仮定します。

このオプションは、マルチライブラリを選択するために内部的に使用されます。 これは最適化オプションではないため、手動で設定する必要はありません。

@item -msp8
@opindex msp8
スタックポインタレジスタと8ビットレジスタとして扱う。すなわち、スタックポインタの上位ビットを0と仮定する。一般的には、手でこのオプションを設定する必要はない。

このオプションは、コンパイラによって内部的に使用され、@code{avr2}と@code{avr25}アーキテクチャ用のマルチビルドを構築する。これらのアーキテクチャは、@code{SPH}の有無にかかわらずデバイスを混在させる。@option{-mmcu=avr2}または@option{-mmcu=avr25}以外の設定では、コンパイラはこのオプションをコンパイラ固有のコマンドラインから追加または削除する。これは、コンパイラがデバイスまたはアーキテクチャに8-bitスタックポインタを使用していて、@code{SPH}レジスタがあるかどうかを知っているためである。

@item -mstrict-X
@opindex mstrict-X
ハードウェアによって提案された方法でアドレスレジスタ@code{X}を使用する。 つまり、@code{X}は、間接、後置インクリメント、またはプリデクリメントのアドレッシングでのみ使用される。

このオプションがなければ、@code{X}レジスタは@code{Y}または@code{Z}と同じ方法で使用されるかもしれず、そのときは追加の命令によってエミュレートされる。たとえば、レジスタ@var{Rn}に負でない@code{const <64}という小さな負の@code{X + const}で値をロードすると、次のように実行される。

@example
adiw r26, const   ; X += const
ld   @var{Rn}, X        ; @var{Rn} = *X
sbiw r26, const   ; X -= const
@end example

@item -mtiny-stack
@opindex mtiny-stack
スタックポインタの下位8ビットのみ変更する。

@item -mfract-convert-truncate
@opindex mfract-convert-truncate
固定小数点型で、ゼロに丸める代わりに切り捨てを使用する。

@item -nodevicelib
@opindex nodevicelib
AVR-LibCのデバイス固有ライブラリ@code{lib<mcu>.a}にはリンクしない。

@item -nodevicespecs
@opindex nodevicespecs
コンパイラドライバのコマンドラインに@option{-specs=device-specs/specs-@var{mcu}}を追加しない。 ユーザーは、適切なコンパイラー、アセンブラー、リンカーなどのサブプロセスに適切なコマンドラインオプションを提供する責任があります。 つまり、ユーザーは@option{-specs=@var{path-to-specs-file}}を使用してプライベートデバイスのスペックファイルを提供する必要があります。 オプション@option{-mmcu=@var{mcu}}はもう必要ありません。

このオプションは、@option{-B @var{some-path}}が@code {specs-@var{mcu}}という名前のスペックファイルを含む@code{device-specs}という名前のフォルダーを含むディレクトリを指す必要があるカスタムのデバイス仕様ファイルを指定する以前の方法の代わりとしても使用できます。@var{mcu}は@option{-mmcu=@var{mcu}}で指定されています。

@item -Waddr-space-convert
@opindex Waddr-space-convert
結果のアドレススペースが受信アドレススペースに含まれていない場合のアドレススペース間の変換について警告する。

@item -Wmisspelled-isr
@opindex Wmisspelled-isr
ISRのスペルが間違っている場合、つまり__vectorプレフィックスがない場合に警告する。
デフォルトでは有効である。
@end table

@subsubsection @code{EIND}と128Kiバイト以上のフラッシュを持つデバイス
@cindex @code{EIND}
実装のポインタは16ビット幅である。関数またはラベルのアドレスはワードアドレスとして表されるので、間接ジャンプおよび呼び出しは64@tie{}Kiワードの範囲内の任意のコードアドレスを対象とすることができる。

128@tie{}Kiバイトを超えるプログラムメモリ空間を持つデバイスの間接ジャンプを容易にするために、@code{EICALL}及び@code{EIJMP}命令が使用されるときにターゲットアドレスの最も重要な部分として機能する@code{EIND}という特別な機能レジスタがある。

これらのデバイスでの間接ジャンプと呼び出しは、コンパイラによって次のように処理され、いくつかの制限がある。

@itemize @bullet

@item
コンパイラは決して@code{EIND}をセットしない。

@item
コンパイラは、@code{EICALL}/@code{EIJMP}で暗黙的に@code{EIND}を使うかもしれず、@code{RET}命令を使って間接的な呼び出し/ジャンプをエミュレートするために@code {EIND}を直接読むかもしれない。

@item
コンパイラは、起動コード中またはアプリケーション中に@code{EIND}が変更されないとみなす。 特に、@code{EIND}は、関数や割り込みサービスルーチンのプロローグ/エピローグでは保存/復元されない。

@item
関数間接呼び出しと計算されたgotoの場合、リンカは@emph{スタブ}を生成する。 スタブは時には@emph{トランポリン}と呼ばれるジャンプパッドである。 したがって、間接コール/ジャンプはそのようなスタブにジャンプする。
スタブには、目的のアドレスへの直接ジャンプが含まれている。

@item
すべての状況でリンカがスタブを正しく生成できるように、リンカの緩和をオンにする必要がある。 コンパイラオプション@option{-mrelax}とリンカオプション@option{--relax}を参照せよ。リンカがスタブを生成するが、緩和せずに役立つエラーメッセージが表示されずに終了する特殊な状況がある。

@item
デフォルトのリンカースクリプトは、@code{EIND = 0}のコード用に配置されている。コードが@code{EIND != 0}で設定されている場合、カスタムリンカースクリプトを使用して、@code{.trampolines}で始まるセクションを@code{EIND}が指し示す。

@item
libgccの起動コードは@code{EIND}を設定しない。起動コードは、libgccとAVR-LibCのコードの組み合わせであることに注意せよ。AVR-LibCが@code{EIND}に与える影響については、
@w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC user manual}}を見よ

@item
@code{.init3}セクションにある初期化コードなどを使用して、@code{EIND}を早期に設定することは、ユーザー固有のスタートアップコードにとって正当である。 このようなコードは、RAMを初期化してコンストラクタを呼び出す一般的な起動コードの前に実行されるが、AVR-LibCの起動コードのビットの後に、@code{EIND}をベクトルテーブルがあるセグメントに設定する
@example
#include <avr/io.h>

static void
__attribute__((section(".init3"),naked,used,no_instrument_function))
init3_set_eind (void)
@{
  __asm volatile ("ldi r24,pm_hh8(__trampolines_start)\n\t"
                  "out %i0,r24" :: "n" (&EIND) : "r24","memory");
@}
@end example

@noindent
@code{__trampolines_start}シンボルはリンカスクリプトで定義される。

@item
次の2つの条件が満たされている場合、リンカーによって自動的にスタブが生成される。
@itemize @minus

@item ラベルのアドレスは、@code{gs}修飾子（@emph{generate stubs}の略語）によって次のように取得される。
@example
LDI r24, lo8(gs(@var{func}))
LDI r25, hi8(gs(@var{func}))
@end example
@item そのラベルの最終的な位置は、スタブがあるセグメントのコードセグメントの@emph{外側}にある。
@end itemize

@item
コンパイラは、以下のような場合にコードラベルのための@code{gs}修飾子を発行する：
@itemize @minus
@item 関数及びコードラベルのアドレスと取る
@item 計算goto
@item プロローグ保存の関数が使われたとき、@option{-mcall-prologues}コマンド行オプション参照
@item switch/case分岐テーブル。このような分岐テーブルを必要としない場合は、@option {-fno-jump-tables}コマンドラインオプションを指定することができる。
@item スタートアップ・シャットダウン中に呼ばれるCとC++のコンストラクタ・デストラクタ
@item もしツールが上で説明した@code{gs()}修飾子に当たったとき
@end itemize

@item
このような非シンボルアドレスへのジャンプはサポートされ@emph{_ない_}

@example
int main (void)
@{
    /* Call function at word address 0x2 */
    return ((int(*)(void)) 0x2)();
@}
@end example

代わりに、スタブをセットアップしなければならない。すなわち、関数はシンボル（例では@code{func_4}）
を通じて呼ばなくてはならない。

@example
int main (void)
@{
    extern int func_4 (void);

    /* Call function at byte address 0x4 */
    return func_4();
@}
@end example

アプリケーションは@option{-Wl,--defsym,func_4=0x4}でリンクされる。あるいは、リンカスクリプトで@code{func_4}を定義することもできる。
@end itemize

@subsubsection @code{RAMPD}, @code{RAMPX}, @code{RAMPY}, @code{RAMPZ}特別関数レジスタの扱い
@cindex @code{RAMPD}
@cindex @code{RAMPX}
@cindex @code{RAMPY}
@cindex @code{RAMPZ}
いくつかのAVRデバイスは、16ビットポインタでアクセスできる64@tie{}KiBの範囲を超えるメモリをサポートしている。 この64@tie{}KiB範囲外のメモリ位置にアクセスするには、@code{RAMP}レジスタの内容がアドレスの上位部分として使用される。@code{RAM}、@code{RAMPY}、@code{RAMPZ}特殊関数レジスタとそれぞれ連結され、@code{X}、@code{Y}、@code{Z}アドレスレジスタがそれぞれワイドアドレスを得るために@code{RAMPX}, @code{RAMPY}, @code{RAMPZ}特別関数レジスタと連結される。 同様に、@code{RAMPD}はダイレクトアドレッシングと一緒に使用される。

@itemize
@item
起動コードは、@code{RAMP}特殊関数レジスタをゼロで初期化する。

@item
@ref{AVR Named Address Spaces,名前付き関数空間}が汎用または@code{__ flash}の他に使用されると、操作の前に必要に応じて@code{RAMPZ}が設定される。

@item
デバイスが64@tie{}KiBより大きいRAMをサポートし、コンパイラが操作を実行するために@code{RAMPZ}を変更する必要がある場合、@code{RAMPZ}は操作後に0にリセットされる。

@item
デバイスに特定の@code{RAMP}レジスタが付いている場合、ISRプロローグ/エピローグはそのSFRを保存/復元し、ISRコードが（暗黙的に）使用する場合はゼロで初期化する。

@item
64 KiBを超えるRAMは、AVRターゲットのGCCではサポートされていない。インラインアセンブラを使用して16ビットのアドレス範囲外の場所から読み取り、@code{RAMP}レジスタの1つを変更する場合は、アクセス後に0にリセットする必要がある。

@end itemize

@subsubsection AVR組み込みマクロ

GCCは、ユーザーコードが機能の有無をテストできるように、いくつかのビルトインマクロを定義している。 次の組み込みマクロのほとんどは、デバイスの機能から導き出され、@option{-mmcu=}コマンドラインオプションによってトリガされる。

さらなるAVR固有のマクロは@ref{AVR Named Address Spaces}と@ref{AVR Built-in Functions}。

@table @code

@item __AVR_ARCH__
@option{-mmcu=@var{mcu}}オプションに依存する、アーキテクチャを識別する10進数に解決される組み込みマクロ。
可能な値は次のとおり。

@code{2}, @code{25}, @code{3}, @code{31}, @code{35},
@code{4}, @code{5}, @code{51}, @code{6}

はそれぞれ@var{mcu}=@code{avr2}, @code{avr25}, @code{avr3}, @code{avr31},
@code{avr35}, @code{avr4}, @code{avr5}, @code{avr51}, @code{avr6}であり、

@code{100}, @code{102}, @code{103}, @code{104},
@code{105}, @code{106}, @code{107}

はそれぞれ@var{mcu}=@code{avrtiny}, @code{avrxmega2}, @code{avrxmega3}, @code{avrxmega4},
@code{avrxmega5}, @code{avrxmega6}, @code{avrxmega7}である。
@var{mcu}がデバイスを指定する場合、この組み込みマクロはそれに応じて設定される。 たとえば、@option{-mmcu=atmega8}の場合、マクロは@code {4}に定義される。

@item __AVR_@var{Device}__
@option{-mmcu=@var{device}}を設定すると、この組み込みマクロが定義され、デバイスの名前が反映される。 たとえば、@option{-mmcu=atmega8}は組み込みマクロ@code{__AVR_ATmega8__}を定義し、@option{-mmcu=attiny261a}は@code{__AVR_ATtiny261A__}などを定義する。

組み込みマクロの名前は、@code{__AVR_@var{Device}__}というスキームに従う。ここで、@var{Device}はAVRユーザーマニュアルのデバイス名である。 組み込みマクロの@var{Device}と@option{-mmcu=@var{device}}の@var{device}の違いは、後者は常に小文字であることである。

@var{device}がデバイスではなく、@samp{avr51}のようなコアアーキテクチャのみである場合、このマクロは定義されていない。

@item __AVR_DEVICE_NAME__
@option{-mmcu=@var{device}}を設定すると、この組み込みマクロがデバイス名に定義される。 たとえば、@option{-mmcu=atmega8}の場合、マクロは@code{atmega8}と定義される。

@var{device}がデバイスではなく、@samp {avr51}のようなコアアーキテクチャのみである場合、このマクロは定義されない。

@item __AVR_XMEGA__
デバイス/アーキテクチャは、XMEGAファミリのデバイスに属す。

@item __AVR_HAVE_ELPM__
デバイスには@code{ELPM}命令がある。

@item __AVR_HAVE_ELPMX__
デバイスには、@code{ELPM R @var{n}, Z}と@code{ELPM R @var{n},Z+}命令がある。

@item __AVR_HAVE_MOVW__
デバイスには、16ビットのレジスタレジスタの移動を実行するための@code{MOVW}命令がある。

@item __AVR_HAVE_LPMX__
デバイスには、@code{LPM R @var{n},Z}と@code {LPM R@var{n},Z+}命令がある。

@item __AVR_HAVE_MUL__
デバイスには、ハードウェア乗算器がある。

@item __AVR_HAVE_JMP_CALL__
デバイスには@code {JMP}と@code {CALL}命令がある。これは、プログラムメモリの少なくとも8KiBを持つデバイスの場合である。

@item __AVR_HAVE_EIJMP_EICALL__
@itemx __AVR_3_BYTE_PC__
デバイスには、@code{EIJMP}と@code{EICALL}命令がある。128@tie{}KiB以上のプログラムメモリを持つデバイスの場合であり、プログラムカウンタ（PC）が3バイト幅であることも意味する。

@item __AVR_2_BYTE_PC__
プログラムカウンタ（PC）は2バイト幅。 これは、最大128@tie{}KiBのプログラムメモリを持つデバイスの場合である。

@item __AVR_HAVE_8BIT_SP__
@itemx __AVR_HAVE_16BIT_SP__
スタックポインタ（SP）レジスタは、コンパイラによって8ビットおよび16ビットのレジスタとして扱われる。
これらのマクロの定義は@option {-mtiny-stack}の影響を受ける。

@item __AVR_HAVE_SPH__
@itemx __AVR_SP8__
デバイスは、SPH（スタックポインタの上位部分）特殊機能レジスタを持っているか、8ビットのスタックポインタを持っている。これらのマクロの定義は、@option{-mmcu=}と@option{-mmcu=avr2}と@option{-mmcu=avr25}の場合も@option{-msp8}の影響を受ける。

@item __AVR_HAVE_RAMPD__
@itemx __AVR_HAVE_RAMPX__
@itemx __AVR_HAVE_RAMPY__
@itemx __AVR_HAVE_RAMPZ__
デバイスには、それぞれ@code{RAMPD}、@code{RAMPX}、@code{RAMPY}、@code{RAMPZ}特殊関数レジスタがある。

@item __NO_INTERRUPTS__
このマクロは@option {-mno-interrupts}コマンドラインオプションを反映する。

@item __AVR_ERRATA_SKIP__
@itemx __AVR_ERRATA_SKIP_JMP_CALL__
一部のAVRデバイス（AT90S8515、ATmega103）は、ハードウェアエラッタのために32ビット命令をスキップしてはならない。 スキップ命令は@code{SBRS}、@code{SBRC}、@code{SBIS}、@code{SBIC}および@code{CPSE}である。
2番目のマクロは、@code{__ AVR_HAVE_JMP_CALL__}も設定されている場合にのみ定義される。

@item __AVR_ISA_RMW__
このデバイスには、リード・モディファイ・ライト命令（XCH、LAC、LAS、LAT）がある。

@item __AVR_SFR_OFFSET__=@var{offset}
@code{IN}、@code{OUT}、@code{SBI}などのようなI / O特殊機能レジスタに直接対処できる命令は、@code{LD}または@code{STS}のようなRAMにアクセスする命令によってアドレス指定された場合とは異なるアドレスを使用することがある。 このオフセットはデバイスのアーキテクチャに依存し、それぞれのI / Oアドレスを得るためにRAMアドレスから減算する必要がある。

@item __AVR_SHORT_CALLS__
@option {-mshort-calls}コマンドラインオプションが設定されています。

@item __AVR_PM_BASE_ADDRESS__=@var{addr}
一部のデバイスは、@code{LD *}命令によるフラッシュメモリからの読み取りをサポートしています。 フラッシュメモリは、@code{__AVR_PM_BASE_ADDRESS__}のオフセットでデータアドレス空間に表示されます。 このマクロが定義されていない場合、この機能は使用できません。 定義されている場合、アドレス空間は線形であり、@code{.rodata}をRAMに配置する必要はありません。 これはデフォルトのリンカ記述ファイルによって処理され、現在@code{avrtiny}および@code{avrxmega3}で使用できます。 さらに便利なのは、@code{__flash}のようなアドレス空間や、属性@code{progmem}や@code{pgm_read_*}のような機能を使用する必要がないことです。

@item __WITH_AVRLIBC__
コンパイラは、AVR-Libcと一緒に使用するように構成されています。
@option{-with-avrlibc}設定オプションを参照せよ。

@item __HAVE_DOUBLE_MULTILIB__
@option{-mdouble=}がmultilibオプションとして機能する場合に定義されます。

@item __HAVE_DOUBLE32__
@itemx __HAVE_DOUBLE64__
コンパイラがそれぞれ、32ビット、64ビットのdoubleをサポートするかどうかを定義します。
実際のレイアウトはオプション@option{-mdouble=}で指定されます。

@item __DEFAULT_DOUBLE__
@option{-mdouble=}が設定されていない場合の@code{double}のビットサイズ。 プログラムで@code{double}のレイアウトをテストするには、組み込みマクロ@code{__SIZEOF_DOUBLE__}を使用します。

@item __HAVE_LONG_DOUBLE32__
@itemx __HAVE_LONG_DOUBLE64__
@itemx __HAVE_LONG_DOUBLE_MULTILIB__
@itemx __DEFAULT_LONG_DOUBLE__
上記と同じですが、@code{double}の代わりに@code{long double}を使用します。

@item __WITH_DOUBLE_COMPARISON__
@code{--with-double-comparison=@{tristate|bool|libf7@}} @/@w{@uref{https://gcc.gnu.org/install/configure.html#avr,構成オプション}}を反映しています。@code{2}または@code{3}に定義されます。

@item __WITH_LIBF7_LIBGCC__
@itemx __WITH_LIBF7_MATH__
@itemx __WITH_LIBF7_MATH_SYMBOLS__
@code{--with-libf7=@{libgcc|math|math-symbols@}}
@*@w{@uref{https://gcc.gnu.org/install/configure.html#avr,構成オプション}}を反映しています。
@end table

@node Blackfin Options
@subsection Blackfinオプション
@cindex Blackfin Options

@table @gcctabopt
@item -mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]}
@opindex mcpu=
ターゲットBlackfinプロセッサの名前を指定する。現在、@var{cpu}は
@samp{bf512}, @samp{bf514}, @samp{bf516}, @samp{bf518},
@samp{bf522}, @samp{bf523}, @samp{bf524}, @samp{bf525}, @samp{bf526},
@samp{bf527}, @samp{bf531}, @samp{bf532}, @samp{bf533},
@samp{bf534}, @samp{bf536}, @samp{bf537}, @samp{bf538}, @samp{bf539},
@samp{bf542}, @samp{bf544}, @samp{bf547}, @samp{bf548}, @samp{bf549},
@samp{bf542m}, @samp{bf544m}, @samp{bf547m}, @samp{bf548m}, @samp{bf549m},
@samp{bf561}, @samp{bf592}の一つにできる。

オプションの@var{sirevision}は、ターゲットのBlackfinプロセッサのシリコンリビジョンを指定する。 対象のシリコンリビジョンで使用可能な回避策がすべて有効になる。 @var{sirevision}が@samp{none}の場合、回避策は有効にならない。@var{sirevision}が@samp{any}の場合、ターゲットプロセッサのすべての回避策が有効になる。 @code{__ SILICON_REVISION__}マクロは、シリコンリビジョンのメジャー番号とマイナー番号を表す2桁の16進数で定義されている。 @var{sirevision}が@samp{none}の場合、@code{__ SILICON_REVISION__}は定義されない。 @var{sirevision}が@samp{any}の場合、@code{__ SILICON_REVISION__}は@code {0xffff}と定義されている。 このオプションの@var{sirevision}を使用しない場合、GCCは対象となるBlackfinプロセッサの最新のシリコンリビジョンを想定する。

GCCは、指定された@var{cpu}のプリプロセッサマクロを定義する。@samp{bfin-elf}ツールチェーンの場合、このオプションを指定すると、@option{-msim}が指定されていない場合、libglossによって提供されるハードウェアBSPがリンクされる。

このオプションがなければ、@samp{bf532}がプロセッサーとしてデフォルトで使用される。

@samp{bf561}のサポートは不完全であることに注意する。 @samp{bf561}の場合、プリプロセッサマクロのみが定義されている。

@item -msim
@opindex msim
プログラムをシミュレータ上で実行することを指定する。 これにより、libglossが提供するシミュレータBSPがリンクされる。このオプションは@samp{bfin-elf} toolchainにのみ有効である。 @option{-mid-shared-library}や@option{-mfdpic}などの特定のオプションは、@option{-msim}を意味する。

@item -momit-leaf-frame-pointer
@opindex momit-leaf-frame-pointer
リーフ時間数用のレジスタにフレームポインタを保持しない。 これにより、命令がフレームポインタのセーブ、セットアップ、および復元を回避し、リーフ関数で余分なレジスタを利用できるようになる。

@item -mspecld-anomaly
@opindex mspecld-anomaly
有効にすると、コンパイラは、ジャンプ命令の後に生成されたコードに投機的なロードが含まれないようにする。 このオプションを使用すると、@code{__ WORKAROUND_SPECULATIVE_LOADS}が定義される。

@item -mno-specld-anomaly
@opindex mno-specld-anomaly
投機的なロードが発生しないようにするための特別なコードを生成しない。

@item -mcsync-anomaly
@opindex mcsync-anomaly
有効にすると、コンパイラは、生成されたコードに条件分岐後すぐにCSYNCまたはSSYNC命令が含まれないようにする。このオプションを使用すると、@code{__ WORKAROUND_SPECULATIVE_SYNCS}が定義される。

@item -mno-csync-anomaly
@opindex mno-csync-anomaly
条件分岐後にCSYNCまたはSSYNC命令があまりに早く発生するのを防ぐための余分なコードを生成しない。

@item -mlow64k
@opindex mlow64k
有効にすると、コンパイラは、プログラム全体が低メモリ64kに収まるという知識を自由に利用できる。

@item -mno-low64k
@opindex mno-low64k
プログラムが任意に大きいと仮定する。 これがデフォルトである。

@item -mstack-check-l1
@opindex mstack-check-l1
uClinuxカーネルによってL1スクラッチパッドメモリに配置された情報を使用してスタックチェックを実行する。

@item -mid-shared-library
@opindex mid-shared-library
ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成する。
これにより、仮想メモリ管理のない環境で、直接実行や共有ライブラリを実行することができる。 このオプションは@option{-fPIC}を意味する。 @samp{bfin-elf}ターゲットの場合、このオプションは@option{-msim}を意味する。

@item -mno-id-shared-library
@opindex mno-id-shared-library
IDベースの共有ライブラリが使用されていることを前提としないコードを生成する。これがデフォルトである。

@item -mleaf-id-shared-library
@opindex mleaf-id-shared-library
ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成し、このライブラリまたは実行可能ファイルは他のID共有ライブラリとリンクしていないものと想定する。 これにより、コンパイラはジャンプと呼び出しのためのより高速なコードを使用できる。

@item -mno-leaf-id-shared-library
@opindex mno-leaf-id-shared-library
コンパイル中のコードがID共有ライブラリとリンクしないと仮定しない。 jumpおよびcall 命令のコードがより遅く生成される。

@item -mshared-library-id=n
@opindex mshared-library-id
コンパイルされるIDベースの共有ライブラリの識別番号を指定する。 0の値を指定すると、よりコンパクトなコードが生成される。 他の値を指定すると、その番号を現在のライブラリに強制的に割り当てることができるが、このオプションを省略するよりもスペースや時間効率が向上しない。

@item -msep-data
@opindex msep-data
データセグメントをテキストセグメントとは異なるメモリ領域に配置できるようにするコードを生成する。 これにより、テキストセクションに対する再配置を排除することにより、仮想メモリ管理のない環境での実行が可能になる。

@item -mno-sep-data
@opindex mno-sep-data
データセグメントがテキストセグメントに続くことを前提とするコードを生成する。これがデフォルトです。

@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
関数のアドレスをレジスタにロードし、次にこのレジスタでサブルーチン呼び出しを実行することによって、関数呼び出しを実行するようにコンパイラに指示する。 このスイッチは、ターゲット関数がサブルーチン呼び出し命令のオフセットベースバージョンの24ビットアドレッシング範囲外にある場合に必要である。

この機能はデフォルトでは有効になっていない。 @option{-mno-long-calls}を指定すると、デフォルト動作が復元される。 これらのスイッチは、コンパイラが関数ポインタを介して関数呼び出しを処理するコードを生成する方法には影響しないことに注意すること。

@item -mfast-fp
@opindex mfast-fp
高速浮動小数点ライブラリにリンクする。 このライブラリは、パフォーマンスの観点から、非数値（NAN）に対して入力をチェックするIEEE浮動小数点標準の規則のいくつかを緩和する。

@item -minline-plt
@opindex minline-plt
ローカルにバインドされていない関数に対する関数呼び出しのPLTエントリのインライン化を有効にする。 @option{-mfdpic}なしでは効果はない。

@item -mmulticore
@opindex mmulticore
マルチコアBlackfinプロセッサ用のスタンドアロンアプリケーションを構築する。このオプションを使用すると、適切な起動ファイルと、マルチコアをサポートするリンクスクリプトが使用され、マクロ@code {__ BFIN_MULTICORE}が定義される。これは@option{-mcpu=bf561@r{[}-@var{sirevision}@r{]}}でのみ使用できる。

このオプションは、@option{-mcorea}または@option{-mcoreb}とともに使用できる。このオプションは、1アプリケーション/コアのプログラミングモデルを選択する。 @option{-mcorea}または@option{-mcoreb}を使用しない場合は、シングルアプリケーション/デュアルコアプログラミングモデルが使用される。 このモデルでは、コアBの主な機能は@code{coreb_main}と命名されるべきである。

このオプションを使用しない場合は、シングルコアアプリケーションプログラミングモデルが使用される。

@item -mcorea
@opindex mcorea
1アプリケーション/コアプログラミングモデルを使用する場合、BF561のコアA用のスタンドアローンアプリケーションを構築する。 適切な開始ファイルとリンクスクリプトは、コアAをサポートするために使用され、マクロ@code{__ BFIN_COREA}が定義される。このオプションは@option{-mmulticore}と組み合わせてのみ使用できる。

@item -mcoreb
@opindex mcoreb
1アプリケーション/コアプログラミングモデルを使用する場合は、BF561のコアB用のスタンドアロンアプリケーションを作成する。 適切な開始ファイルとリンクスクリプトは、コアBをサポートするために使用され、マクロ@code{__ BFIN_COREB}が定義される。 このオプションを使用するときは、@code{main}の代わりに@code{coreb_main}を使用する必要がある。このオプションは@option {-mmulticore}と組み合わせてのみ使用できる。

@item -msdram
@opindex msdram
SDRAM用のスタンドアロンアプリケーションを構築する。 適切な開始ファイルとリンクスクリプトを使用してアプリケーションをSDRAMに入れ、マクロ@code{__ BFIN_SDRAM}を定義する。ローダーはアプリケーションをロードする前にSDRAMを初期化する必要がある。

@item -micplb
@opindex micplb
実行時にICPLBが有効になっていると仮定する。 これは、特定の異常回避策に影響する。 Linuxターゲットの場合、デフォルトはICPLBが有効であると仮定する。 スタンドアロンアプリケーションの場合、デフォルトはオフである。
@end table

@node C6X Options
@subsection C6Xオプション
@cindex C6X Options

@table @gcctabopt
@item -march=@var{name}
@opindex march
これは、ターゲットアーキテクチャの名前を指定する。 GCCはこの名前を使用して、アセンブリコードを生成するときにどのような命令を発行できるかを判断する。 許可される名前は @samp{c62x},
@samp{c64x}, @samp{c64x+}, @samp{c67x}, @samp{c67x+}, @samp{c674x}である。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンターゲット用のコードを生成する。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンターゲット用のコードを生成する。これはデフォルトである。

@item -msim
@opindex msim
シミュレータに適した起動ファイルとリンカスクリプトを選択する。

@item -msdata=default
@opindex msdata=default
@code{.neardata}セクションに小規模のグローバルデータと静的データを配置する。これはレジスタ@code{B14}によって指し示される。 小さな初期化されていないグローバルデータと静的データを@code{.bss}セクションに置く。これは@code{.neardata}セクションに隣接している。 読み込み専用の小さなデータを@code{.rodata}セクションに置く。 大量のデータに使用される対応するセクションは、@code{.fardata}、@code{.far}、@code{.const}である。

@item -msdata=all
@opindex msdata=all
小規模なデータ用に予約されたセクションには、小さなオブジェクトだけでなく、すべてのデータを格納し、アクセスするために@code{B14}レジスタを基準にしたアドレス指定を使用する。

@item -msdata=none
@opindex msdata=none
小さなデータ用に予約されたセクションを使用せず、絶対アドレスを使用してすべてのデータにアクセスする。 すべての初期化されたグローバルおよび静的データを@code{.fardata}セクションに入れ、すべての初期化されていないデータを@code{.far}セクションに置く。 すべての定数データを@code{.const}セクションに入れる。

@end table

@node CRIS Options
@subsection CRISオプション
@cindex CRIS Options

これらのオプションは、CRISポート専用に定義されている。

@table @gcctabopt
@item -march=@var{architecture-type}
@itemx -mcpu=@var{architecture-type}
@opindex march
@opindex mcpu
指定されたアーキテクチャのコードを生成する。 @var{architecture-type}の選択肢は、@samp{v3}、@samp{v8}、@samp{v10}である。それぞれ、ETRAX@w{ }4、ETRAX@w{ }100、およびETRAX@w{ }100@w{ }LXである。
デフォルトはcris-axis-linux-gnuを除き、@samp{v0}であり、その場合は@samp{v10}である。

@item -mtune=@var{architecture-type}
@opindex mtune
ABIと使用可能な命令のセットを除いて、@var{architecture-type}に合わせて生成されたコードに関するすべてのものを調整する。 @var{architecture-type}の選択肢は、@option{-march=@var{architecture-type}}と同じである。

@item -mmax-stack-frame=@var{n}
@opindex mmax-stack-frame
関数のスタックフレームが@var{n}バイトを超えたときに警告する。

@item -metrax4
@itemx -metrax100
@opindex metrax4
@opindex metrax100
オプション@option {-metrax4}と@option{-metrax100}は、それぞれ@option{-march = v3}と@option{-march = v8}の同義語である。

@item -mmul-bug-workaround
@itemx -mno-mul-bug-workaround
@opindex mmul-bug-workaround
@opindex mno-mul-bug-workaround
それが適用されるCPUモデルの@code{muls}と@code{mulu}命令のバグを回避する。 このオプションは、デフォルトで有効である。

@item -mpdebug
@opindex mpdebug
CRIS固有の詳細なデバッグ関連情報をアセンブリコードで有効にする。 このオプションは、@samp{#NO_APP}フォーマットコードインジケータをアセンブラファイルの先頭でアセンブラに表示しないようにする効果もある。

@item -mcc-init
@opindex mcc-init
前の命令の条件コード結果を使用しない。 条件コードを使用する前に、常に比較とテストの命令を出す。

@item -mno-side-effects
@opindex mno-side-effects
ポストインクリメント以外のアドレッシングモードで副作用のある命令を生成しない。

@item -mstack-align
@itemx -mno-stack-align
@itemx -mdata-align
@itemx -mno-data-align
@itemx -mconst-align
@itemx -mno-const-align
@opindex mstack-align
@opindex mno-stack-align
@opindex mdata-align
@opindex mno-data-align
@opindex mconst-align
@opindex mno-const-align
これらのオプション（@samp{no-}オプション）は、選択したCPUモデルの最大単一データアクセスサイズに合わせて、スタックフレーム、個々のデータと定数を整列（配置を取り除く）する。 デフォルトでは、32ビットのアライメントを調整する。 構造レイアウトなどのABIの詳細は、これらのオプションの影響を受けない。

@item -m32-bit
@itemx -m16-bit
@itemx -m8-bit
@opindex m32-bit
@opindex m16-bit
@opindex m8-bit
上記のstack-data-およびconst-alignオプションと同様に、これらのオプションは、スタックフレーム、書き込み可能なデータおよび定数をすべて32ビット、16ビットまたは8ビットに整列させるように配置する。 デフォルトは32ビット境界である。

@item -mno-prologue-epilogue
@itemx -mprologue-epilogue
@opindex mno-prologue-epilogue
@opindex mprologue-epilogue
@option{-mno-prologue-epilogue}では、スタックフレームを設定する通常の関数プロローグとエピローグは省略され、戻り命令や戻りシーケンスはコード内に生成されない。 このオプションは、コンパイルされたコードの目視検査と一緒にのみ使用すること。コールセーブされたレジスタを保存する必要がある場合、またはローカル変数の格納領域を割り当てる必要がある場合は、警告もエラーも生成されない。

@item -mno-gotplt
@itemx -mgotplt
@opindex mno-gotplt
@opindex mgotplt
@option{-fpic}と@option{-fPIC}と一緒に使用すると、PLTへの（他のアーキテクチャでは従来の）呼び出しではなく、GOTのPLT部分から関数のアドレスをロードする命令シーケンスを生成しない（する）。 デフォルトは@option{-mgotplt}である。

@item -melf
@opindex melf
cris-axis-elfおよびcris-axis-linux-gnuターゲットでのみ認識される旧式の何もしないオプション。

@item -mlinux
@opindex mlinux
cris-axis-linux-gnuターゲットでのみ認識される旧式の何もしないオプション。

@item -sim
@opindex sim
このオプションは、cris-axis-elf用にのみ認識され、シミュレータ・ライブラリからの入出力関数とリンクする。 コード、初期化データ、ゼロ初期化データは連続して割り当てられる。

@item -sim2
@opindex sim2
@option{-sim}と似ているが、初期化されたデータを0x40000000に配置し、ゼロ初期化データを0x80000000に配置すいるようにリンカオプションを渡す。

@end table

@node CR16 Options
@subsection CR16オプション
@cindex CR16 Options

これらのオプションは、CR16ポート専用に定義されている。

@table @gcctabopt

@item -mmac
@opindex mmac
乗算累算命令の使用を有効にする。 デフォルトでは無効である。

@item -mcr16cplus
@itemx -mcr16c
@opindex mcr16cplus
@opindex mcr16c
CR16CまたはCR16C+アーキテクチャ用のコードを生成する。 CR16C+アーキテクチャはデフォルトである。

@item -msim
@opindex msim
シミュレータと互換性のあるライブラリlibsim.aをリンクする。 ELFコンパイラにのみ適用される。

@item -mint32
@opindex mint32
整数型に32ビット長を選ぶ。

@item -mbit-ops
@opindex mbit-ops
ビット操作に@code{sbit}/@code{cbit}命令を生成する。

@item -mdata-model=@var{model}
@opindex mdata-model
データモデルを選択する。 @var{model}の選択肢は@samp{near}、@samp{far}または@samp{medium}である。 @samp{medium}はデフォルトである。ただし、@samp{far}は@option{-mcr16c}では有効ではない。これは、CR16Cアーキテクチャがfarデータモデルをサポートしていないためである。
@end table

@node C-SKY Options
@subsection C-SKY Options
@cindex C-SKY Options

GCCは、C-SKY V2プロセッサー用にコンパイルするときにこれらのオプションをサポートします。

@table @gcctabopt

@item -march=@var{arch}
@opindex march=
C-SKYターゲットアーキテクチャを指定します。 @var{arch}の有効な値は次のとおりです。
@samp{ck801}、@samp{ck802}、@samp{ck803}、@samp{ck807}、および@samp{ck810}。 デフォルトは@samp{ck810}です。

@item -mcpu=@var{cpu}
@opindex mcpu=
C-SKYターゲットプロセッサを指定します。 @var {cpu}の有効な値は次のとおりです。
@samp{ck801}, @samp{ck801t},
@samp{ck802}, @samp{ck802t}, @samp{ck802j},
@samp{ck803}, @samp{ck803h}, @samp{ck803t}, @samp{ck803ht},
@samp{ck803f}, @samp{ck803fh}, @samp{ck803e}, @samp{ck803eh},
@samp{ck803et}, @samp{ck803eht}, @samp{ck803ef}, @samp{ck803efh},
@samp{ck803ft}, @samp{ck803eft}, @samp{ck803efht}, @samp{ck803r1},
@samp{ck803hr1}, @samp{ck803tr1}, @samp{ck803htr1}, @samp{ck803fr1},
@samp{ck803fhr1}, @samp{ck803er1}, @samp{ck803ehr1}, @samp{ck803etr1},
@samp{ck803ehtr1}, @samp{ck803efr1}, @samp{ck803efhr1}, @samp{ck803ftr1},
@samp{ck803eftr1}, @samp{ck803efhtr1},
@samp{ck803s}, @samp{ck803st}, @samp{ck803se}, @samp{ck803sf},
@samp{ck803sef}, @samp{ck803seft},
@samp{ck807e}, @samp{ck807ef}, @samp{ck807}, @samp{ck807f},
@samp{ck810e}, @samp{ck810et}, @samp{ck810ef}, @samp{ck810eft},
@samp{ck810}, @samp{ck810v}, @samp{ck810f}, @samp{ck810t}, @samp{ck810fv},
@samp{ck810tv}, @samp{ck810ft}, @samp{ck810ftv}.

@item -mbig-endian
@opindex mbig-endian
@itemx -EB
@opindex EB
@itemx -mlittle-endian
@opindex mlittle-endian
@itemx -EL
@opindex EL

ビッグエンディアンコードまたはリトルエンディアンコードを選択します。 デフォルトはリトルエンディアンです。

@item -mfloat-abi=@var{name}
@opindex mfloat-abi
使用する浮動小数点ABIを指定します。 許容値は、@samp{soft}、@samp{softfp}、および@samp{hard}です。

@samp{soft}を指定すると、GCCは浮動小数点演算のライブラリ呼び出しを含む出力を生成します。 @samp{softfp}を使用すると、ハードウェア浮動小数点命令を使用してコードを生成できますが、それでもソフト浮動小数点呼び出し規約を使用します。 @samp{hard}は、浮動小数点命令の生成を可能にし、FPU固有の呼び出し規約を使用します。

デフォルトは、特定のターゲット構成によって異なります。 ハードフロートとソフトフロートのABIはリンク互換ではないことに注意してください。 プログラム全体を同じABIでコンパイルし、互換性のあるライブラリのセットとリンクする必要があります。

@item -mhard-float
@opindex mhard-float
@itemx -msoft-float
@opindex msoft-float

ハードウェアまたはソフトウェアの浮動小数点実装を選択します。デフォルトはソフトフロートです。

@item -mdouble-float
@itemx -mno-double-float
@opindex mdouble-float
@option{-mhard-float}が有効な場合、倍精度浮動小数点命令の生成を有効にします。 これは、CK803用にコンパイルする場合を除いて、デフォルトです。

@item -mfdivdu
@itemx -mno-fdivdu
@opindex mfdivdu
@option{-mhard-float}が有効な場合、@code{frecipd}、@code{fsqrtd}、および@code{fdivd}命令の生成を有効にします。 これは、CK803用にコンパイルする場合を除いて、デフォルトです。

@item -mfpu=@var{fpu}
@opindex mfpu=
浮動小数点プロセッサを選択します。 このオプションは、@option{-mhard-float}と組み合わせてのみ使うことができます。 @var{fpu}の値は@samp{fpv2_sf}（@samp{-mno-double-float -mno-fdivdu}と同等）、@samp{fpv2}（@samp{-mdouble-float -mno-divdu} ）、@samp{fpv2_divd}（@samp{-mdouble-float -mdivdu}）。

@item -melrw
@itemx -mno-elrw
@opindex melrw
拡張@code {lrw}命令を有効にします。 このオプションのデフォルトは、CK801の場合はオン、それ以外の場合はオフです。

@item -mistack
@itemx -mno-istack
@opindex mistack
割り込みスタック命令を有効にします。 デフォルトはオフです。

@code{interrupt}および@code{isr}関数属性（@pxref{C-SKY Function Attributes}）を処理するには、@option {-mistack}オプションが必要です。

@item -mmp
@opindex mmp
マルチプロセッサ命令を有効にします。 デフォルトはオフです。

@item -mcp
@opindex mcp
コプロセッサー命令を有効にします。 デフォルトはオフです。

@item -mcache
@opindex mcache
コプロセッサー命令を有効にします。 デフォルトはオフです。

@item -msecurity
@opindex msecurity
C-SKYセキュリティ指示を有効にします。 デフォルトはオフです。

@item -mtrust
@opindex mtrust
C-SKYトラスト命令を有効にします。 デフォルトはオフです。

@item -mdsp
@opindex mdsp
@itemx -medsp
@opindex medsp
@itemx -mvdsp
@opindex mvdsp
C-SKY DSP、拡張DSP、またはベクトルDSP命令をそれぞれ有効にします。 これらのオプションはすべてデフォルトでオフになっています。

@item -mdiv
@itemx -mno-div
@opindex mdiv
除算命令を生成します。 デフォルトはオフです。

@item -msmart
@itemx -mno-smart
@opindex msmart
16ビット命令を使用できるように0〜7の番号が付いたレジスタのみを使用して、スマートモードのコードを生成します。 このオプションは、必要な動作であるCK801では無視され、CK802ではデフォルトでオンになります。 他のターゲットの場合、デフォルトはオフです。

@item -mhigh-registers
@itemx -mno-high-registers
@opindex mhigh-registers
16〜31の番号が付けられた上位レジスタを使用してコードを生成します。 このオプションは、CK801、CK802、またはCK803ではサポートされておらず、他のプロセッサーではデフォルトで有効になっています。

@item -manchor
@itemx -mno-anchor
@opindex manchor
グローバルアンカーシンボルアドレスを使用してコードを生成します。

@item -mpushpop
@itemx -mno-pushpop
@opindex mpushpop
@code{push}および@code{pop}命令を使用してコードを生成します。 このオプションのデフォルトはオンです。

@item -mmultiple-stld
@itemx -mstm
@itemx -mno-multiple-stld
@itemx -mno-stm
@opindex mmultiple-stld
@code{stm}および@code{ldm}命令を使用してコードを生成します。 このオプションはCK801ではサポートされていませんが、他のプロセッサではデフォルトで有効になっています。

@item -mconstpool
@itemx -mno-constpool
@opindex mconstpool
アセンブラーに延期するのではなく、コンパイラーで定数プールを作成します。 このオプションはデフォルトであり、CK801およびCK802での正しいコード生成に必要であり、他のプロセッサーではオプションです。

@item -mstack-size
@item -mno-stack-size
@opindex mstack-size
アセンブリ出力の各関数に対して@code {.stack_size}ディレクティブを発行します。 このオプションのデフォルトはオフです。

@item -mccrt
@itemx -mno-ccrt
@opindex mccrt
libgccの代わりにC-SKYコンパイラランタイムのコードを生成します。 このオプションのデフォルトはオフです。

@item -mbranch-cost=@var{n}
@opindex mbranch-cost=
ブランチのコストをおおよそ@code {n}命令に設定します。 デフォルトは1です。

@item -msched-prolog
@itemx -mno-sched-prolog
@opindex msched-prolog
関数のプロローグとエピローグのシーケンスのスケジューリングを許可します。 このオプションを使用すると、C-SKY V2 ABIプロローグ要件に準拠せず、デバッグまたはバックトレースできないコードになる可能性があります。 デフォルトでは無効になっています。

@end table

@node Darwin Options
@subsection Darwinオプション
@cindex Darwin options

これらのオプションは、Darwinオペレーティングシステムを実行しているすべてのアーキテクチャで定義されています。

DarwinのFSF GCCは、「fat」オブジェクトファイルを作成しない。 GCCがターゲットとする構築された単一アーキテクチャ用のオブジェクトファイルを作成する。 AppleのGCCは、複数の@option{-arch}オプションが使用されている場合、 「fat」ファイルを作成する。 コンパイラーやリンカーを複数回実行し、結果を@file{lipo}と一緒に結合することでそうする。

（@samp{ppc7400}や@samp{ppc970}や@samp{i686}のような）作成されるファイルのサブタイプは、GCCがターゲットとするISAを指定するフラグ@option{-mcpu}や@option{-march}で決定される。これを無効にするには、 @option{-force_cpusubtype_ALL}オプションを使用できる。

Darwinのツールは、ISAの不一致がある場合の動作が異なる。 アセンブラ@file{as}は、生成しているファイルのサブタイプに有効な命令のみを使用できるため、64ビット命令を@samp{ppc750}オブジェクトファイルに入れることはできない。 共有ライブラリのリンカー@file{/usr/bin/libtool}は、入力ファイルよりも制限の少ないサブタイプで共有ライブラリを作成するように要求された場合に失敗し、エラーを表示する。（例えば、@samp{ppc970}オブジェクトファイルを@samp{ppc7400}ライブラリに置こうとすると）。実行可能ファイルのリンカー@command{ld}は、実行可能ファイルに入力ファイルの中で最も制限的なサブタイプを静かに提供する。

@table @gcctabopt
@item -F@var{dir}
@opindex F
フレームワークディレクトリ@var{dir}をリストの先頭に追加するヘッダファイルを検索するディレクトリ。これらのディレクトリは@option{-I}オプションで指定されたものに差し挟まれ、左から右の順序でスキャンされる。

フレームワークディレクトリは、フレームワークを持つディレクトリである。フレームワークとは、@file{.framework}で終わる@file{Headers}や@file{PrivateHeaders}ディレクトリが直接入っているディレクトリである。フレームワークの名前は、@file{.framework}を除いたこのディレクトリの名前である。フレームワークに関連付けられたヘッダーは、@file{Headers}が最初に検索される2つのディレクトリのうちの1つにある。サブフレームワークは、フレームワークの@file{Frameworks}ディレクトリにあるフレームワークディレクトリである。サブフレームワークヘッダーのインクルードは、サブフレームワークを含むフレームワークのヘッダーにのみ、または兄弟サブフレームヘッダーにのみ表示できる。 2つのサブフレームワークは、同じフレームワーク内に存在する場合、兄弟である。サブフレームワークはフレームワークと同じ名前であってはならない。これに違反すると警告が出る。現在、サブフレームワークはサブフレームワークを持つことができない。将来、このメカニズムを拡張することができるだろう。標準のフレームワークは@file{/System/Library/Frameworks}と@file{/Library/Frameworks}にある。例のincludeは@code{#include<Framework/header.h>}のように見え、@file{Framework}はフレームワークの名前を表し、@file{header.h}は@file{PrivateHeaders}や@file{Headers}ディレクトリを表す。

@item -iframework@var{dir}
@opindex iframework
@option {-F}と似ているが、ディレクトリはシステムディレクトリとして扱われる。 この@option{-iframework}と@option{-F}の主な違いは、@option{-iframework}の場合、コンパイラは@var{dir}を介して見つかるヘッダファイルに含まれている構文について警告しないということである。 このオプションはC言語族の言語でのみ有効である。

@item -gused
@opindex gused
使用されているシンボルのデバッグ情報を出力する。 stabsデバッグ形式では、これは@option{-feliminate-unused-debug-symbols}を有効にする。これは、デフォルトでONになっている。

@item -gfull
@opindex gfull
すべてのシンボルとタイプのデバッグ情報を出力する。

@item -mmacosx-version-min=@var{version}
この実行可能ファイルが実行されるMacOS Xの最も古いバージョンは@var{version}である。 @var{version}の典型的な値は@code{10.1}、@code{10.2}、@code{10.3.9}である。

コンパイラがデフォルトでシステムのヘッダーを使用するように構築されている場合、このオプションのデフォルトはコンパイラが実行されているシステムのバージョンである。それ以外の場合、デフォルトはできるだけ多くのシステムおよびコードベースと互換性がある。

@item -mkernel
@opindex mkernel
カーネル開発モードを有効にする。 @option{-mkernel}は@option{-static}, @option{-fno-common}, @option{-fno-use-cxa-atexit},
@option{-fno-exceptions}, @option{-fno-non-call-exceptions},
@option{-fapple-kext}, @option{-fno-weak}, @option{-fno-rtti}を適用可能な場所で有効にする。
このモードはさらにPowerPCターゲットでは@option{-mno-altivec},
@option{-msoft-float}, @option{-fno-builtin}と
@option{-mlong-branch}を有効にする。

@item -mone-byte-bool
@opindex mone-byte-bool
@code{sizeof(bool)=1}のように、@code{bool}のデフォルトを上書きする。デフォルトでは、Darwin/PowerPC用にコンパイルするときは@code{sizeof(bool)}は@code{4}、Darwin/x86用にコンパイルするときは@code{1}なので、このオプションはx86には影響しない。

@strong{警告:} @option{-mone-byte-bool}スイッチは、GCCに、そのスイッチなしで生成されたコードとバイナリ互換性のないコードを生成させる。 このスイッチを使用するには、システムライブラリを含むプログラム内の他のすべてのモジュールを再コンパイルする必要がある。 このスイッチを使用して、デフォルト以外のデータモデルに準拠させる。

@item -mfix-and-continue
@itemx -ffix-and-continue
@itemx -findirect-data
@opindex mfix-and-continue
@opindex ffix-and-continue
@opindex findirect-data
GDBが既に実行中のプログラムに@file{.o}ファイルを動的にロードできるように、高速ターンアラウンド開発に適したコードを生成する。 下位互換性のために@option{-findirect-data}と@option{-ffix-and-continue}が提供されている。

@item -all_load
@opindex all_load
静的アーカイブライブラリのすべてのメンバーを読み込む。詳細は、man ld（1）を参照せよ。

@item -arch_errors_fatal
@opindex arch_errors_fatal
誤ったアーキテクチャを持つファイルと関係しているエラーは致命的なものにする。

@item -bind_at_load
@opindex bind_at_load
ファイルがロードまたは起動されたときに、ダイナミックリンカが定義されていないすべての参照をバインドするように、出力ファイルにマークを付ける。

@item -bundle
@opindex bundle
Mach-oバンドル形式ファイルを作成する。詳細は、man ld（1）を参照せよ。

@item -bundle_loader @var{executable}
@opindex bundle_loader
このオプションはリンクされているビルド出力ファイルをロードする@var{executable}を指定する。 詳細は、man ld（1）を参照せよ。

@item -dynamiclib
@opindex dynamiclib
このオプションを渡すと、GCCはDarwinの@file{libtool}コマンドを使用して、リンク時に実行可能ファイルではなく動的ライブラリを生成する。

@item -force_cpusubtype_ALL
@opindex force_cpusubtype_ALL
これにより、GCCの出力ファイルは、@option {-mcpu}または@option{-march}オプションで制御されるものではなく、@samp{ALL}サブタイプになります。

@item -allowable_client  @var{client_name}
@itemx -client_name
@itemx -compatibility_version
@itemx -current_version
@itemx -dead_strip
@itemx -dependency-file
@itemx -dylib_file
@itemx -dylinker_install_name
@itemx -dynamic
@itemx -exported_symbols_list
@itemx -filelist
@need 800
@itemx -flat_namespace
@itemx -force_flat_namespace
@itemx -headerpad_max_install_names
@itemx -image_base
@itemx -init
@itemx -install_name
@itemx -keep_private_externs
@itemx -multi_module
@itemx -multiply_defined
@itemx -multiply_defined_unused
@need 800
@itemx -noall_load
@itemx -no_dead_strip_inits_and_terms
@itemx -nofixprebinding
@itemx -nomultidefs
@itemx -noprebind
@itemx -noseglinkedit
@itemx -pagezero_size
@itemx -prebind
@itemx -prebind_all_twolevel_modules
@itemx -private_bundle
@need 800
@itemx -read_only_relocs
@itemx -sectalign
@itemx -sectobjectsymbols
@itemx -whyload
@itemx -seg1addr
@itemx -sectcreate
@itemx -sectobjectsymbols
@itemx -sectorder
@itemx -segaddr
@itemx -segs_read_only_addr
@need 800
@itemx -segs_read_write_addr
@itemx -seg_addr_table
@itemx -seg_addr_table_filename
@itemx -seglinkedit
@itemx -segprot
@itemx -segs_read_only_addr
@itemx -segs_read_write_addr
@itemx -single_module
@itemx -static
@itemx -sub_library
@need 800
@itemx -sub_umbrella
@itemx -twolevel_namespace
@itemx -umbrella
@itemx -undefined
@itemx -unexported_symbols_list
@itemx -weak_reference_mismatches
@itemx -whatsloaded
@opindex allowable_client
@opindex client_name
@opindex compatibility_version
@opindex current_version
@opindex dead_strip
@opindex dependency-file
@opindex dylib_file
@opindex dylinker_install_name
@opindex dynamic
@opindex exported_symbols_list
@opindex filelist
@opindex flat_namespace
@opindex force_flat_namespace
@opindex headerpad_max_install_names
@opindex image_base
@opindex init
@opindex install_name
@opindex keep_private_externs
@opindex multi_module
@opindex multiply_defined
@opindex multiply_defined_unused
@opindex noall_load
@opindex no_dead_strip_inits_and_terms
@opindex nofixprebinding
@opindex nomultidefs
@opindex noprebind
@opindex noseglinkedit
@opindex pagezero_size
@opindex prebind
@opindex prebind_all_twolevel_modules
@opindex private_bundle
@opindex read_only_relocs
@opindex sectalign
@opindex sectobjectsymbols
@opindex whyload
@opindex seg1addr
@opindex sectcreate
@opindex sectobjectsymbols
@opindex sectorder
@opindex segaddr
@opindex segs_read_only_addr
@opindex segs_read_write_addr
@opindex seg_addr_table
@opindex seg_addr_table_filename
@opindex seglinkedit
@opindex segprot
@opindex segs_read_only_addr
@opindex segs_read_write_addr
@opindex single_module
@opindex static
@opindex sub_library
@opindex sub_umbrella
@opindex twolevel_namespace
@opindex umbrella
@opindex undefined
@opindex unexported_symbols_list
@opindex weak_reference_mismatches
@opindex whatsloaded
これらのオプションはDarwinリンカーに渡される。 Darwinのリンカのmanページに詳細が記述されている。
@end table

@node DEC Alpha Options
@subsection DEC Alpha オプション

これらの@samp{-m}オプションは、DEC Alphaの実装で定義されている。

@table @gcctabopt
@item -mno-soft-float
@itemx -msoft-float
@opindex mno-soft-float
@opindex msoft-float
浮動小数点演算には、ハードウェア浮動小数点命令を使用する（しない）。 @option{-msoft-float}を指定すると、@file{libgcc.a}の関数が浮動小数点演算の実行に使用される。 浮動小数点演算をエミュレートするルーチンに置き換えられたり、エミュレーションルーチンを呼び出すようにコンパイルされたりしない限り、これらのルーチンは浮動小数点演算を発行する。 浮動小数点演算を使用せずにAlpha用にコンパイルする場合は、ライブラリが呼び出されないようにビルドされていることを確認する必要がある。

浮動小数点演算を使用しないAlphaの実装では、浮動小数点レジスタが必要であることに注意。

@item -mfp-reg
@itemx -mno-fp-regs
@opindex mfp-reg
@opindex mno-fp-regs
浮動小数点レジスタセットを使用する（しない）コードを生成する。 @option{-mno-fp-regs}は、@option{-msoft-float}を含む。 浮動小数点レジスタセットが使用されていない場合、浮動小数点オペランドは整数であるかのように整数レジスタに渡され、浮動小数点の結果は@code{$f0}の代わりに@code{$0}に渡される。 これは非標準呼び出しシーケンスなので、@option{-mno-fp-regs}でコンパイルされたコードで呼び出される浮動小数点引数または戻り値を持つ関数も、そのオプションでコンパイルする必要がある。

このオプションの典型的な使用方法は、浮動小数点レジスタを使用しないため、浮動小数点レジスタを保存および復元する必要がないカーネルを構築することである。

@item -mieee
@opindex mieee
Alphaアーキテクチャは、パフォーマンスを最大限に高めるように最適化された浮動小数点ハードウェアを実装する。 これは、ほとんどIEEE浮動小数点標準に準拠している。 ただし、完全な準拠のためには、ソフトウェアの補助が必要である。 このオプションは、@var{inexact-flag}が維持されていないことを@emph{除いては}完全にIEEE準拠のコードを生成する（下記参照）。 このオプションをオンにすると、プリプロセッサマクロ@code{_IEEE_FP}がコンパイル時に定義される。 結果として生成されるコードの効率は低下するが、正規化されていない数値や、非数やプラスマイナスの無限大などの例外的なIEEE値を正しくサポートすることができる。 他のAlphaコンパイラはこのオプションを@option{-ieee_with_no_inexact}と呼んでいる。

@item -mieee-with-inexact
@opindex mieee-with-inexact
これは@option{-mieee}と似ているが、生成されたコードはIEEE@var{inexact-flag}も維持される。 このオプションをオンにすると、生成されたコードは完全準拠のIEEE演算を実装する。 @code{_IEEE_FP}に加えて、@code{_IEEE_FP_EXACT}はプリプロセッサマクロとして定義される。 一部のAlpha実装では、生成されるコードはデフォルトで生成されるコードよりも大幅に遅く実行されることがある。 @var{inexact-flag}に依存するコードはごくわずかなので、通常はこのオプションを指定するべきではない。 他のAlphaコンパイラはこのオプションを@option{-ieee_with_inexact}と呼んでいる。

@item -mfp-trap-mode=@var{trap-mode}
@opindex mfp-trap-mode
このオプションは、浮動小数点関連のトラップを有効にするかどうかを制御する。他のAlphaコンパイラはこのオプションを@option{-fptm @var{trap-mode}}と呼んでいる。トラップモードは、次の4つの値のいずれかに設定できる。

@table @samp
@item n
これがデフォルト（通常）の設定である。 有効にされる唯一のトラップは、ソフトウェアで無効にすることができないトラップ（例えば、ゼロトラップによる除算）である。

@item u
@samp{n}によって有効にされたトラップに加えて、アンダーフロートラップも有効である。

@item su
@samp{u}と似ているが、ソフトウェアの完了時に命令が安全であるとマークされる。（詳細はAlphaアーキテクチャのマニュアルを参照）。

@item sui
@samp{su}と似ていますが、不正確なトラップも有効である。
@end table

@item -mfp-rounding-mode=@var{rounding-mode}
@opindex mfp-rounding-mode
IEEE丸めモードを選択する。 他のAlphaコンパイラはこのオプションを@option{-form @var{rounding-mode}}と呼んでいる。 @var{rounding-mode}は次のいずれかである：

@table @samp
@item n
通常のIEEE丸めモード。 浮動小数点数は、最も近いマシン番号に向かって丸められ、または同数の場合は均等なマシン番号に丸めらる。

@item m
負の無限大に向かって丸められる。

@item c
切り捨て丸めモード。浮動小数点は0に向かって丸められる。

@item d
動的丸めモード。 浮動小数点制御レジスタのフィールド（@var{fpcr}、Alphaアーキテクチャのリファレンスマニュアルを参照）は、有効な丸めモードを制御する。 Cライブラリは正の無限大に丸められるようにこのレジスタを初期化する。 したがって、プログラムが@var{fpcr}を変更しない限り、@samp{d}は+無限大に丸める。
@end table

@item -mtrap-precision=@var{trap-precision}
@opindex mtrap-precision
Alphaアーキテクチャでは、浮動小数点トラップは不正確である。 これは、ソフトウェアの支援なしでは、浮動小数点トラップから回復することは不可能であり、プログラムの実行は通常終了する必要があることを意味する。 GCCは、オペレーティングシステムのトラップハンドラが浮動小数点トラップの原因となった正確な位置を特定する際に役立つコードを生成することができる。 アプリケーションの要件に応じて、さまざまなレベルの精度を選択できます。
@table @samp
@item p
プログラム精度。 このオプションはデフォルトであり、トラップハンドラが浮動小数点例外を発生させたプログラムのみを識別できることを意味する。

@item f
関数精度。 トラップハンドラは、浮動小数点例外の原因となった関数を判別できる。

@item i
命令精度。 トラップハンドラは、浮動小数点例外の原因となった正確な命令を判別できる。
@end table

他のAlphaコンパイラには、@option{-scope_safe}と@option{-resumption_safe}という同等のオプションがある。

@item -mieee-conformant
@opindex mieee-conformant
このオプションは、生成されたコードをIEEE準拠としてマークする。 @option{-mtrap-precision=i}と@option{-mfp-trap-mode=su}または@option{-mfp-trap-mode=sui}を指定しない限り、このオプションを使用してはならない。 その唯一の効果は、生成されたアセンブリファイルの関数プロローグで@samp{.eflag 48}という行を出力することである。

@item -mbuild-constants
@opindex mbuild-constants
通常、GCCは32ビットまたは64ビット整数定数を調べて、2つまたは3つの命令で小さな定数から構造体を構築できるかどうかを調べる。 できない場合は定数をリテラルとして出力し、実行時にデータセグメントからロードするコードを生成する。

このオプションを使用すると、たとえより多くの命令を使ったとしても（最大で6）GCCが@emph{すべての}整数定数をコードを使って構築するように要求する。

通常、このオプションを使用して共有ライブラリの動的ローダを構築する。 共有ライブラリそのものでは、変数と定数を自分のデータセグメントで見つける前に、メモリ内で自身を再配置する必要がある。

@item -mbwx
@itemx -mno-bwx
@itemx -mcix
@itemx -mno-cix
@itemx -mfix
@itemx -mno-fix
@itemx -mmax
@itemx -mno-max
@opindex mbwx
@opindex mno-bwx
@opindex mcix
@opindex mno-cix
@opindex mfix
@opindex mno-fix
@opindex mmax
@opindex mno-max
GCCがオプションのBWX、CIX、FIX、およびMAX命令セットを使用するコードを生成する必要があるかどうかを示す。 デフォルトでは、@option{-mcpu=}オプションで指定されたCPUタイプでサポートされている命令セット、または何も指定されていない場合はGCCが構築されたCPUのものが使用される。

@item -mfloat-vax
@itemx -mfloat-ieee
@opindex mfloat-vax
@opindex mfloat-ieee
IEEE単精度および倍精度の代わりにVAX FおよびG浮動小数点演算を使用する（しない）コードを生成する。

@item -mexplicit-relocs
@itemx -mno-explicit-relocs
@opindex mexplicit-relocs
@opindex mno-explicit-relocs
以前のAlphaアセンブラは、アセンブラマクロ以外ではシンボルの再配置を生成できなかった。 これらのマクロを使用しても、最適な命令スケジューリングはできない。 バージョン2.12のGNU binutilsは、コンパイラがどの命令にどの再配置を適用すべきかを明示的に示すことを可能にする新しい構文をサポートしている。 このオプションは、GCCがビルド時にアセンブラの機能を検出し、それに応じてデフォルトを設定するため、デバッグに最も役立つ。

@item -msmall-data
@itemx -mlarge-data
@opindex msmall-data
@opindex mlarge-data
@option{-mexplicit-relocs}が有効な場合、静的データは@dfn{gp-relative}再配置によってアクセスされる。 @option{-msmall-data}を使用すると、長さが8バイト以下のオブジェクトが@dfn{小データ領域}（@code{.sdata}セクションと@code{.sbss}セクション）に配置され、 @code{$gp}レジスタからの16ビット再配置経由でアクセスされる。 これにより、小さなデータ領域のサイズが64KBに制限されるが、変数には単一の命令で直接アクセスすることができる。

デフォルトは@option{-mlarge-data}である。 このオプションを使用すると、データ領域が2GB未満に制限される。 2GBを超えるデータを必要とするプログラムでは、プログラムのデータセグメントではなく、ヒープ内のデータを割り当てるために、@code{malloc}または@code{mmap}を使用する必要がある。

共有ライブラリ用のコードを生成する場合、@option{-fpic}は@option{-msmall-data}を意味し、@option{-fPIC}は@option{-mlarge-data}を意味する。

@item -msmall-text
@itemx -mlarge-text
@opindex msmall-text
@opindex mlarge-text
@option {-msmall-text}を使用すると、コンパイラはプログラム全体（または共有ライブラリ）のコードが4MBに収まり、分岐命令で到達可能であるとみなす。 @option{-msmall-data}を使用すると、コンパイラはすべてのローカルシンボルが同じ@code{$gp}値を共有しているとみなし、関数呼び出しに必要な命令数を4から1に減らすことができる。

デフォルトは@option{-mlarge-text}です。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var{cpu_type}の命令セットと命令スケジューリングパラメータを設定する。 @samp{EV}スタイル名または対応するチップ番号を指定できる。 GCCは、EV4、EV5、EV6ファミリプロセッサのスケジューリングパラメータをサポートし、指定したプロセッサから命令セットのデフォルト値を選択する。 プロセッサタイプを指定しない場合、GCCのデフォルトはコンパイラが構築されたプロセッサである。

@var {cpu_type}にサポートされている値は

@table @samp
@item ev4
@itemx ev45
@itemx 21064
EV4としてスケジュールし、命令セット拡張を持たない。

@item ev5
@itemx 21164
EV5としてスケジュールし、命令セット拡張はない。

@item ev56
@itemx 21164a
EV5としてスケジューリングし、BWX拡張をサポートする。

@item pca56
@itemx 21164pc
@itemx 21164PC
EV5としてスケジューリングし、BWXおよびMAX拡張をサポートする。

@item ev6
@itemx 21264
EV6としてスケジューリングし、BWX、FIX、およびMAX拡張をサポートします。

@item ev67
@itemx 21264a
EV6としてスケジュールし、BWX、CIX、FIX、およびMAX拡張をサポートします。
@end table

ネイティブツールチェーンは、@samp{native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。GCCがプロセッサを認識しない場合、@option{-mcpu=native}は効果がない。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var{cpu_type}の命令スケジューリングパラメータのみを設定する。 命令セットは変更されない。

ネイティブツールチェーンは、@samp {native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。 GCCがプロセッサを認識しない場合は、@option{-mtune = native}は効果がない。

@item -mmemory-latency=@var{time}
@opindex mmemory-latency
スケジューラがアプリケーションによって見られる典型的なメモリ参照に対して想定するレイテンシを設定する。 この数値は、アプリケーションで使用されるメモリアクセスパターンとマシン上の外部キャッシュのサイズに大きく依存する。

@var{time}の有効なオプションは

@table @samp
@item @var{number}
クロックサイクルを表す10進数。

@item L1
@itemx L2
@itemx L3
@itemx main
コンパイラには、レベル1,2、および3のキャッシュ（Dcache、Scache、およびBcacheとも呼ばれる）のための「典型的な」EV4およびEV5ハードウェアのためのクロックサイクル数の推定値とメインメモリが含まれている。 L3はEV5にのみ有効である。

@end table
@end table

@node eBPF Options
@subsection eBPFオプション
@cindex eBPF Options

@table @gcctabopt
@item -mframe-limit=@var{bytes}
フレームサイズのハード制限をバイト単位で指定します。 現在、指定できる値は@samp {32767}以下でなければなりません。 デフォルトでは、対象となるLinuxカーネルのバージョンによって課される制限が適用されます。

@item -mkernel=@var{version}
@opindex mkernel
これは、コンパイルされたプログラムを実行するカーネルの最小バージョンを指定します。 GCCはこのバージョンを使用して、使用する命令、許可するカーネルヘルパーなどを決定します。  現在、
@var{version}は@samp{4.0}, @samp{4.1}, @samp{4.2},
@samp{4.3}, @samp{4.4}, @samp{4.5}, @samp{4.6}, @samp{4.7},
@samp{4.8}, @samp{4.9}, @samp{4.10}, @samp{4.11}, @samp{4.12},
@samp{4.13}, @samp{4.14}, @samp{4.15}, @samp{4.16}, @samp{4.17},
@samp{4.18}, @samp{4.19}, @samp{4.20}, @samp{5.0}, @samp{5.1},
@samp{5.2}, @samp{latest}, @samp{native}のひとつです。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンターゲットのコードを生成します。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンターゲットのコードを生成します。 これがデフォルトです。
@end table

@item -mxbpf
BPFの拡張バージョンのコードを生成します。これにより、BPFアーキテクチャによって課せられる制限の一部が緩和されます。
@itemize @minus
@item 関数の開始時と終了時に、呼び出し先が保存したレジスタをそれぞれ保存および復元します。
@end itemize
@end table

@node FR30 Options
@subsection FR30オプション
@cindex FR30 Options

これらのオプションは、FR30ポート専用に定義されている。

@table @gcctabopt

@item -msmall-model
@opindex msmall-model
小さなアドレス空間モデルを使用する。 これにより、より小さなコードが生成されるが、すべてのシンボリックな値とアドレスが20ビットの範囲に収まると仮定する。

@item -mno-lsim
@opindex mno-lsim
実行時サポートが提供されていると仮定して、シミュレータライブラリ（@file{libsim.a}）をリンカコマンドラインに含める必要をなくす。

@end table

@node FT32 Options
@subsection FT32オプション
@cindex FT32 Options

これらのオプションは、FT32ポート専用に定義されている。

@table @gcctabopt

@item -msim
@opindex msim
プログラムをシミュレータ上で実行することを指定する。 これにより、別のランタイム起動とライブラリがリンクされる。 実際のハードウェア上で動作するプログラムを生成するときは、このオプションを使用してはならない。 どのI/O関数が必要なのかに関わらず、独自のランタイムライブラリを用意する必要がある。

@item -mlra
@opindex mlra
ローカルレジスタ割り付けを有効にする。 これはFT32ではまだ実験的なので、デフォルトでコンパイラは標準リロードを使用する。

@item -mnodiv
@opindex mnodiv
divとmod命令を使わない。

@item -mft32b
@opindex mft32b
FT32Bプロセッサの拡張命令の使用を有効にします。

@item -mcompress
@opindex mcompress
Ft32Bコード圧縮スキームを使用してすべてのコードを圧縮します。

@item -mnopm
@opindex  mnopm
プログラムメモリを読み取るコードを生成しない。

@end table

@node FRV Options
@subsection FRVオプション
@cindex FRV Options

@table @gcctabopt
@item -mgpr-32
@opindex mgpr-32

最初の32個の汎用レジスタのみを使用する。

@item -mgpr-64
@opindex mgpr-64

64個の汎用レジスタをすべて使用する。

@item -mfpr-32
@opindex mfpr-32

最初の32個の浮動小数点レジスタのみを使用する。

@item -mfpr-64
@opindex mfpr-64

64個の浮動小数点レジスタをすべて使用する。

@item -mhard-float
@opindex mhard-float

浮動小数点演算にはハードウェア命令を使用する。

@item -msoft-float
@opindex msoft-float

浮動小数点演算にはライブラリルーチンを使用する。

@item -malloc-cc
@opindex malloc-cc

条件コードレジスタを動的に割り当てる。

@item -mfixed-cc
@opindex mfixed-cc

条件コードレジスタを動的に割り当てようとはせず、@code{icc0}と@code{fcc0}だけを使用する。

@item -mdword
@opindex mdword

ダブルワード命令を使用するようにABIを変更する。

@item -mno-dword
@opindex mno-dword

ダブルワード命令は使用しない。

@item -mdouble
@opindex mdouble

浮動小数点の倍精度命令を使用する。

@item -mno-double
@opindex mno-double

浮動小数点の倍精度命令を使用しない。

@item -mmedia
@opindex mmedia

メディア命令を使う。

@item -mno-media
@opindex mno-media

メディア命令を使わない。

@item -mmuladd
@opindex mmuladd

乗加算・乗減算命令を使う。

@item -mno-muladd
@opindex mno-muladd

乗加算・乗減算命令を使わない。

@item -mfdpic
@opindex mfdpic

関数へのポインタを表すために関数記述子を使用するFDPIC ABIを選択する。 PIC/PIE関連のオプションがなければ、それは@option{-fPIE}を意味する。 @option{-fpic}または@option{-fpie}を使用すると、GOTエントリと小データがGOTベースアドレスから12ビットの範囲内にあるとみなされる。 @option{-fPIC}または@option{-fPIE}を指定すると、GOTオフセットは32ビットで計算される。@samp{bfin-elf}ターゲットの場合、このオプションは@option{-msim}を意味する。

@item -minline-plt
@opindex minline-plt

ローカルにバインドされていない関数に対する関数呼び出しのPLTエントリのインライン化を有効にする。 @option{-mfdpic}なしでは効果はない。共有ライブラリ（つまり、@option{-fPIC}や@option{-fpic}）用に速度でコンパイルされるか、@option{-O3}以上のような最適化が有効の場合はデフォルトで有効である。

@item -mTLS
@opindex mTLS

スレッドローカルコードを生成するときは、大きなTLSセグメントを仮定する。

@item -mtls
@opindex mtls

スレッドローカルコードを生成するときに大きなTLSセグメントを想定しない。

@item -mgprel-ro
@opindex mgprel-ro

読取り専用セクションにあることが知られているデータについては、FDPIC ABIの@code{GPREL}再配置の使用を有効にする。 @option{-fpic}または@option{-fpie}を除いて、デフォルトで有効になっている。グローバルオフセットテーブルを小さくするのに役立つかもしれないが、１命令を4つに変える。@option{-fPIC}または@option{-fPIE}では、3命令を4に変え、そのうちの1つを複数のシンボルで共有することができ、参照シンボルのGOTエントリが不要になるため、勝つ可能性が高くなる。 そうでない場合は、@option{-mno-gprel-ro}を使用して無効にすることができる。

@item -multilib-library-pic
@opindex multilib-library-pic

（FDでなく、ライブラリの）picライブラリにリンクする。 これは、@option{-mlibrary-pic}と、@option{-fPIC}と@option{-fpic}（@option{-mfdpic}なし）によって暗示されている。 明示的に使用する必要はない。

@item -mlinked-fp
@opindex mlinked-fp

スタックフレームが割り当てられるたびに必ずフレームポインタを作成するというEABIの要求に従う。 このオプションはデフォルトで有効になっており、@option{-mno-linked-fp}で無効にすることができる。

@item -mlong-calls
@opindex mlong-calls

間接アドレッシングを使用して、現在のコンパイル単位の外にある関数を呼び出す。 これにより、関数を32ビットアドレス空間のどこにでも配置することができる。

@item -malign-labels
@opindex malign-labels

前のパケットにNOPを挿入して、ラベルを8バイトの境界に揃える。 このオプションは、VLIWパッキングが有効な場合にのみ有効である。 新しいパケットは作成されない。 単に既存のものにNOPを追加するだけである。

@item -mlibrary-pic
@opindex mlibrary-pic

位置独立のEABIコードを生成する。

@item -macc-4
@opindex macc-4

最初の4メディアアクセレーターレジスタのみを使う。

@item -macc-8
@opindex macc-8

全８メディアアクセレーターレジスタを使う。

@item -mpack
@opindex mpack

VLIW命令を詰める。

@item -mno-pack
@opindex mno-pack

VLIW命令を詰めない。

@item -mno-eflags
@opindex mno-eflags

e_flags内でABIスイッチをマークしない。

@item -mcond-move
@opindex mcond-move

条件ムーブ命令の使用を有効にする（デフォルト）。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-cond-move
@opindex mno-cond-move

条件ムーブ命令の使用を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mscc
@opindex mscc

条件付きセット命令の使用を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-scc
@opindex mno-scc

条件付きセット命令の使用を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mcond-exec
@opindex mcond-exec

条件付き実行の使用を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-cond-exec
@opindex mno-cond-exec

条件付き実行の使用を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mvliw-branch
@opindex mvliw-branch

分岐をVLIW命令に詰めるパスを走らせる。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-vliw-branch
@opindex mno-vliw-branch

分岐をVLIW命令に詰めるパスを走らせない。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mmulti-cond-exec
@opindex mmulti-cond-exec

@code{&&}と@code{||}の条件付き実行での最適化を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-multi-cond-exec
@opindex mno-multi-cond-exec

@code{&&}と@code{||}の条件付き実行での最適化を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mnested-cond-exec
@opindex mnested-cond-exec

入れ子条件付き実行最適化を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-nested-cond-exec
@opindex mno-nested-cond-exec

入れ子条件付き実行最適化を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -moptimize-membar
@opindex moptimize-membar

このスイッチは冗長な@code{membar}命令をコンパイラが生成したコードから取り除く。デフォルトで有効である。

@item -mno-optimize-membar
@opindex mno-optimize-membar

このスイッチは生成されたコードから冗長な@code{membar}を自動的に除去するのを無効にする。

@item -mtomcat-stats
@opindex mtomcat-stats

gasにtomcat統計を出力させる。

@item -mcpu=@var{cpu}
@opindex mcpu

生成コードのプロセッサタイプを指定する。可能な値は
@samp{frv}, @samp{fr550}, @samp{tomcat}, @samp{fr500}, @samp{fr450},
@samp{fr405}, @samp{fr400}, @samp{fr300} と@samp{simple}である。

@end table

@node GNU/Linux Options
@subsection GNU/Linuxオプション

これらの@samp{-m}オプションはGNU / Linuxターゲットに対して定義されています：

@table @gcctabopt
@item -mglibc
@opindex mglibc
GNU Cライブラリを使う。これは@samp{*-*-linux-*uclibc*}, @samp{*-*-linux-*musl*}, 
@samp{*-*-linux-*android*}ターゲット以外でのデフォルトである。

@item -muclibc
@opindex muclibc
uClibc Cライブラリを使う。これは@samp{*-*-linux-*uclibc*}ターゲットでのデフォルトである。

@item -mmusl
@opindex mmusl
musl Cライブラリを使う。これは@samp{*-*-linux-*musl*}ターゲットでのデフォルトである。

@item -mbionic
@opindex mbionic
Bionic Cライブラリを使う。これは@samp{*-*-linux-*android*}ターゲットでのデフォルトである。

@item -mandroid
@opindex mandroid
Andriodプラットフォームで互換性のあるコードをコンパイルする。これは@samp{*-*-linux-*android*}ターゲットでのデフォルトである。

コンパイル時には、デフォルトで@option{-mbionic}、@option{-fPIC}、@option{-fno-exceptions}、@option{-fno-rtti}を有効にする。 リンクするとき、このオプションはGCCドライバがAndroid固有のオプションをリンカに渡すようにする。 最後に、このオプションはプリプロセッサマクロ@code{__ ANDROID__}を定義させます。

@item -tno-android-cc
@opindex tno-android-cc
@option{-mandroid}のコンパイル効果を無効にする。つまり、デフォルトでは、@option{-mbionic}、@option{-fPIC}、@option{-fno-exceptions}、@option{-fno-rtti}を有効にしない。

@item -tno-android-ld
@opindex tno-android-ld
@option{-mandroid}のリンク効果を無効にします。つまり、標準のLinuxリンクオプションをリンカーに渡す。

@end table

@node H8/300 Options
@subsection H8/300 オプション

これらの@samp{-m}オプションは、H8/300実装で定義されている。

@table @gcctabopt
@item -mrelax
@opindex mrelax
可能であれば、リンク時にいくつかのアドレス参照を短くする。 リンカオプション@option{-relax}を使用する。 完全な記述のために@xref{H8/300,, @code{ld}とH8/300,ld, Using ld}を参照。

@item -mh
@opindex mh
H8/300H用のコードを生成する。

@item -ms
@opindex ms
H8S用のコードを生成する。

@item -mn
@opindex mn
H8SおよびH8/300H用のコードを通常モードで生成します。 このスイッチは、@option{-mh}または@option{-ms}のいずれかと一緒に使用する必要がある。

@item -ms2600
@opindex ms2600
H8S/2600用のコードを生成する。このスイッチは@option{-ms}と一緒に使用する必要がある。

@item -mexr
@opindex mexr
拡張レジスタは、monitor属性を持つfunctionを実行する前にスタックに格納される。 デフォルトのオプションは@option{-mexr}である。このオプションはH8Sターゲットに対してのみ有効である。

@item -mno-exr
@opindex mno-exr
モニタ属性のある関数を実行する前に、拡張レジスタはスタックに格納されない。 デフォルトのオプションは@option{-mno-exr}である。 このオプションは、H8Sターゲットに対してのみ有効である。

@item -mint32
@opindex mint32
@code{int}データをデフォうとで32ビットにする。

@item -malign-300
@opindex malign-300
H8/300HおよびH8Sでは、H8/300と同じアライメント規則を使用する。 H8/300HおよびH8Sのデフォルトでは、longおよびfloatを4バイトの境界に揃えることができる。 @option{-malign-300}は、それらを2バイトの境界に整列させる。 このオプションはH8/300には影響しない。
@end table

@node HPPA Options
@subsection HPPAオプション
@cindex HPPA Options

これらの@samp {-m}オプションは、HPPAファミリのコンピュータに対して定義されている。

@table @gcctabopt
@item -march=@var{architecture-type}
@opindex march
指定されたアーキテクチャのコードを生成する。 @var{architecture-type}の選択肢は、PA 1.0では@samp{1.0}、PA 1.1では@samp{1.1}、PA 2.0プロセッサでは@samp{2.0}である。 使用のマシンに適したアーキテクチャー・オプションを判別するには、HP-UXシステムの@file{/usr/lib/sched.models}を参照せよ。 低い番号のアーキテクチャ用にコンパイルされたコードは、高い番号のアーキテクチャ上で実行されるが、それ以外の方法では実行されない。

@item -mpa-risc-1-0
@itemx -mpa-risc-1-1
@itemx -mpa-risc-2-0
@opindex mpa-risc-1-0
@opindex mpa-risc-1-1
@opindex mpa-risc-2-0
@option{-march=1.0}、@option{-march=1.1}、@option{-march=2.0}の同義語である。

@item -mcaller-copies
@opindex mcaller-copies
呼び出し元は、隠し参照によって渡された関数引数をコピーする。 このオプションは、デフォルトの32ビット・ランタイムと互換性がないため、注意して使用する必要がある。 ただし、8バイトを超える集約のみが非表示の参照で渡され、このオプションはOpenMPとの互換性が向上する。

@item -mjump-in-delay
@opindex mjump-in-delay
このオプションは無視され、互換性の目的でのみ提供される。

@item -mdisable-fpregs
@opindex mdisable-fpregs
任意の方法で浮動小数点レジスタが使用されないようにする。 これは、浮動小数点レジスタの遅延コンテキスト切り替えを実行するカーネルをコンパイルするために必要である。 このオプションを使用して浮動小数点演算を実行しようとすると、コンパイラは異常終了する。

@item -mdisable-indexing
@opindex mdisable-indexing
コンパイラがインデックスアドレスモードを使用しないようにする。 これにより、MACHの下でMIG生成コードをコンパイルするときに、あまり目立たない問題が回避される。

@item -mno-space-regs
@opindex mno-space-regs
ターゲットにスペースレジスタがないことを前提としたコードを生成する。 これにより、GCCはより高速の間接呼び出しを生成し、スケーリングされていないインデックスアドレスモードを使用できる。

このようなコードはレベル0のPAシステムとカーネルに適している。

@item -mfast-indirect-calls
@opindex mfast-indirect-calls
コールがスペース境界を越えることがないと想定するコードを生成する。 これにより、GCCはより高速な間接呼び出しを実行するコードを発行することができる。

このオプションは、共有ライブラリまたはネストされた関数が存在する場合は機能しない。

@item -mfixed-range=@var{register-range}
@opindex mfixed-range
与えられたレジスタ範囲を固定レジスタとして扱うコードを生成する。 固定レジスタは、レジスタアロケータが使用できないレジスタである。 カーネルコードをコンパイルするときに便利である。 レジスタ範囲は、ダッシュで区切られた2つのレジスタとして指定される。 カンマで区切って複数のレジスタ範囲を指定することができる。

@item -mlong-load-store
@opindex mlong-load-store
HP-UX 10リンカで時々必要となる3命令ロードおよびストアシーケンスを生成する。 これはHPコンパイラの@samp{+k}オプションと同じである。

@item -mportable-runtime
@opindex mportable-runtime
ELFシステムには、HPが提案した移植性呼び出し規則を使用する。

@item -mgas
@opindex mgas
GASだけが理解できるアセンブラディレクティブの使用を有効にする。

@item -mschedule=@var{cpu-type}
@opindex mschedule
機種@var{cpu-type}の制約に従ってコードをスケジュールする。 @var{cpu-type}の選択肢は、@samp{700} @samp{7100}、@samp{7100LC}、@samp{7200}、@samp{7300}、@samp{8000}である。 使用のマシンに適したスケジューリング・オプションを判別するには、HP-UXシステムの@file{/usr/lib/sched.models}を参照せよ。 デフォルトのスケジューリングは@samp{8000}である。

@item -mlinker-opt
@opindex mlinker-opt
HP-UXリンカで最適化パスを有効にするい。 これによりシンボリックデバッグが不可能になることに注意すること。 また、HP-UX 8およびHP-UX 9リンカでは、いくつかのプログラムをリンクするときに偽のエラーメッセージを表示するバグが発生する。

@item -msoft-float
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含む出力を生成する。
@strong{警告：}必要なライブラリは、すべてのHPPAターゲットで利用できるわけではない。 通常、マシンの通常のCコンパイラの機能が使用されるが、これはクロスコンパイルで直接行うことはできない。 クロスコンパイルに適したライブラリ関数を提供するために、独自の手配をしなければならない。

@option {-msoft-float}は、出力ファイルの呼び出し規約を変更する。 したがって、このオプションでプログラムの@emph{すべて}をコンパイルする場合にのみ有用である。 特に、GCCに付属のライブラリである@file{libgcc.a}を@option{-msoft-float}とコンパイルする必要がある。

@item -msio
@opindex msio
サーバーIOの事前定義、@code{_SIO}を生成する。 デフォルトは@option{-mwsio}である。 これにより、ワークステーションIOの事前定義、@code{__hp9000s700}、@code{__hp9000s700__}および@code{_WSIO}が生成される。 これらのオプションは、HP-UXおよびHI-UXの下で使用できる。

@item -mgnu-ld
@opindex mgnu-ld
GNU @command{ld}に固有のオプションを使用する。共有ライブラリを構築するときに、@option{-shared}を@command{ld}に渡す。 GCCが明示的または暗黙的にGNUリンカーで設定されている場合は、これがデフォルトである。 このオプションは、どの@command{ld}が呼び出されるかには影響しない。 その@command{ld}に渡されるパラメータだけが変更される。 呼び出される@command{ld}は、@option{-with-ld}設定オプション、GCCのプログラム検索パス、最後にユーザの@env{PATH}によって決まる。 GCCで使用されるリンカーは@samp{which `gcc -print-prog-name=ld`}を使用して出力できる。 このオプションは、64ビットHP-UX GCCでのみ使用できる。つまり、@samp{hppa*64*-*-hpux*}で構成されている場合。

@item -mhp-ld
@opindex mhp-ld
HP @command{ld}に固有のオプションを使用する。共有ライブラリをビルドするときに@option{-b}を@command{ld}に渡し、すべてのリンクで@option{+Accept TypeMismatch}を@command{ld}に渡します。 GCCが明示的または暗黙的にHPリンカーで設定されている場合は、これがデフォルトである。このオプションは、どの@command{ld}が呼び出されるかには影響しない。 その@command{ld}に渡されるパラメータだけが変更される。 呼び出される@command{ld}は、@option{-with-ld}設定オプション、GCCのプログラム検索パス、最後にユーザの@env{PATH}によって決まる。 GCCで使用されるリンカーは@samp{which `gcc -print-prog-name=ld`}を使用して出力できる。 このオプションは、64ビットHP-UX GCCでのみ使用できる。つまり、@samp{hppa*64*-*-hpux*}で構成されている場合。

@item -mlong-calls
@opindex mno-long-calls
ロング・コールシーケンスを使用するコードを生成する。これにより、呼び出しが常にリンカによって生成されたスタブに到達できるようになる。デフォルトでは、コールサイトから関数または変換ユニットの先頭までの距離が、使用されているブランチタイプによって設定された事前定義された制限を超える場合にのみ、ロング・コールを生成する。通常のコールの制限は、PA 2.0およびPA 1.Xアーキテクチャでそれぞれ7,600,000と240,000バイトである。 Sibcallsは常に240,000バイトに制限されている。

距離は、@option{-ffunction-sections}オプションを使用するとき、またはSOMリンカーのあるHP-UXで@option{-mgas}オプションと@option{-mno-portable-runtime}オプションを一緒に使用するとき、関数の始めから測られる。

パフォーマンスを低下させるので、通常このオプションを使用することは望ましくない。 ただし、大規模なアプリケーションでは、特に部分的なリンクを使用してアプリケーションを構築する場合に役立つ。

使用されるロング・コールの種類は、アセンブラとリンカの機能、および生成されるコードの種類によって異なる。 ロング絶対コール、長いピクチャシンボル差分、またはPC相対コールをサポートするシステムへの影響は比較的小さいはずである。 しかし、間接呼び出しは、32ビットELFシステムではpicコードで使用されており、かなり長い。

@item -munix=@var{unix-std}
@opindex march
コンパイラ前定義を生成し、指定されたUNIX標準の開始ファイルが選択される。 @var{unix-std}の選択肢は@samp{93}、@samp{95}、@samp{98}である。 @samp{93}は、すべてのHP-UXバージョンでサポートされている。 @samp{95}は、HP-UX 10.10以降で使用できる。 @samp{98}は、HP-UX 11.11以降で使用できる。デフォルト値は、HP-UX 10.00では@samp{93}、HP-UX 10.10から11.00では@samp{95}、HP-UX 11.11以降では@samp{98}である。

@option{-munix=93}は、GCC 3.3と3.4と同じ事前定義を提供する。 @option{-munix=95}は、@code{XOPEN_UNIX}と@code{_XOPEN_SOURCE_EXTENDED}、および@file{unix95.o}の開始ファイルに追加の事前定義を提供する。
@option{-munix=98}は、@code{_XOPEN_UNIX}、@code{_XOPEN_SOURCE_EXTENDED}、@code{_INCLUDE__STDC_A1_SOURCE}、@code{_INCLUDE_XOPEN_SOURCE_500}、および開始ファイル@file{unix98.o}の追加定義を提供する。

このオプションは、さまざまなライブラリルーチンのインターフェイスを変更することに注意することが@emph{_重要_}である。 また、Cライブラリの動作上の動作にも影響する。 したがって、このオプションの使用には@emph{_細心_}の注意が必要です。

複数のUNIX標準で動作するライブラリコードは、必要に応じて変数@code{__ xpg4_extended_mask}をテスト、設定、復元する必要がある。 ほとんどのGNUソフトウェアはこの機能を提供していない。

@item -nolibdld
@opindex nolibdld
HP-UX 10以降で@option{-static}オプションが指定されている場合、libdld.slを検索するリンクオプションの生成を抑制する。

@item -static
@opindex static
libcのsetlocaleのHP-UX実装は、libdld.slに依存している。 libdld.slのアーカイブバージョンはない。 したがって、@option{-static}オプションを指定すると、この依存関係を解決するために特別なリンクオプションが必要になる。

HP-UX 10以降では、@option {-static}オプションが指定されている場合、GCCドライバはlibdld.slとリンクするために必要なオプションを追加する。これにより結果のバイナリが動的になる。 64ビットポートでは、リンカはどのような場合でもデフォルトで動的バイナリを生成する。 @option{-nolibdld}オプションは、GCCドライバがこれらのリンクオプションを追加しないようにするために使用できる。

@item -threads
@opindex threads
HP-UXの@dfn{dce thread}ライブラリを使用して、マルチスレッドのサポートを追加する。 このオプションは、プリプロセッサとリンカの両方のフラグを設定する。
@end table

@node IA-64 Options
@subsection IA-64 Options
@cindex IA-64 Options

これらは、インテルIA-64アーキテクチャーのために定義される@samp{-m}オプションである。

@table @gcctabopt
@item -mbig-endian
@opindex mbig-endian
ビッグエンディアン・ターゲットのコードを生成する。これは、HP-UXのデフォルトである。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアン・ターゲットのコードを生成する。これは、AIX5とGNU/Linuxのデフォルトである。

@item -mgnu-as
@itemx -mno-gnu-as
@opindex mgnu-as
@opindex mno-gnu-as
GNUアセンブラのコードを生成する（しない）。これは、デフォルトである。
@c Also, this is the default if the configure option @option{--with-gnu-as}
@c is used.

@item -mgnu-ld
@itemx -mno-gnu-ld
@opindex mgnu-ld
@opindex mno-gnu-ld
GNUリンカーのコードを生成します（または生成しません）。 これがデフォルトです。
@c Also, this is the default if the configure option @option{--with-gnu-ld}
@c is used.

@item -mno-pic
@opindex mno-pic
グローバルなポインタ・レジスタを使わないコードを生成する。結果は位置独立したコードでなく、IA-64 ABIに違反する。

@item -mvolatile-asm-stop
@itemx -mno-volatile-asm-stop
@opindex mvolatile-asm-stop
@opindex mno-volatile-asm-stop
揮発性のasm文の直前・直後にストップ・ビットを生成する（しない）。

@item -mregister-names
@itemx -mno-register-names
@opindex mregister-names
@opindex mno-register-names
スタックされたレジスタ用の@samp{in}、@samp{loc}と@samp{out}レジスタ名前を生成する（しない）。
これは、アセンブラ出力をより読みやすくするかもしれない。

@item -mno-sdata
@itemx -msdata
@opindex mno-sdata
@opindex msdata
小さいデータセクションを使う最適化を無（有）効にする。これは、オプティマイザのバグの回避策に役立つかもしれない。

@item -mconstant-gp
@opindex mconstant-gp
単一の定数グローバルポインタ値を使用するコードを生成する。 これはカーネルコードをコンパイルするときに便利である。

@item -mauto-pic
@opindex mauto-pic
自己再配置可能なコードを生成する。これは@option{-mconstant-gp}を意味する。これは、ファームウェアコードをコンパイルするときに便利である。

@item -minline-float-divide-min-latency
@opindex minline-float-divide-min-latency
最小レイテンシアルゴリズムを使用して、浮動小数点値のインライン除算のコードを生成する。

@item -minline-float-divide-max-throughput
@opindex minline-float-divide-max-throughput
最大スループットアルゴリズムを使用して、浮動小数点値のインライン除算のコードを生成する。

@item -mno-inline-float-divide
@opindex mno-inline-float-divide
浮動小数点値の除算にインラインコードを生成しない。

@item -minline-int-divide-min-latency
@opindex minline-int-divide-min-latency
最小レイテンシアルゴリズムを使用して、整数値のインライン除算のコードを生成する。

@item -minline-int-divide-max-throughput
@opindex minline-int-divide-max-throughput
最大スループットアルゴリズムを使用して、整数値のインライン除算のコードを生成する。

@item -mno-inline-int-divide
@opindex mno-inline-int-divide
整数値の除算にはインラインコードを生成しない。

@item -minline-sqrt-min-latency
@opindex minline-sqrt-min-latency
最小レイテンシアルゴリズムを使用してインライン平方根のコードを生成する。

@item -minline-sqrt-max-throughput
@opindex minline-sqrt-max-throughput
最大スループットアルゴリズムを使用してインライン平方根のコードを生成する。

@item -mno-inline-sqrt
@opindex mno-inline-sqrt
@code{sqrt}のインラインコードを生成しない。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
融合乗加算または乗減算命令を使用するコードを生成する（しない）。デフォルトでは、これらの命令が使用される。

@item -mno-dwarf2-asm
@itemx -mdwarf2-asm
@opindex mno-dwarf2-asm
@opindex mdwarf2-asm
DWARF行番号デバッグ情報用のアセンブラコードを生成しない（する）。 これは、GNUアセンブラを使用しない場合に便利である。

@item -mearly-stop-bits
@itemx -mno-early-stop-bits
@opindex mearly-stop-bits
@opindex mno-early-stop-bits
ストップビットが、ストップビットをトリガした命令の直前に配置することを許可する。 これは命令スケジューリングを改善することができるが、必ずしもそうであるとは限らない。

@item -mfixed-range=@var{register-range}
@opindex mfixed-range
与えられたレジスタ範囲を固定レジスタとして扱うコードを生成する。 固定レジスタは、レジスタアロケータが使用できないレジスタである。 カーネルコードをコンパイルするときに便利である。 レジスタ範囲は、ダッシュで区切られた2つのレジスタとして指定される。 カンマで区切って複数のレジスタ範囲を指定することができる。

@item -mtls-size=@var{tls-size}
@opindex mtls-size
即時TLSオフセットのビットサイズを指定します。 有効な値は14、22、および64。

@item -mtune=@var{cpu-type}
@opindex mtune
特定のCPUの命令スケジューリングを調整する。有効な値は@samp{itanium}、@samp{itanium1}、@samp{merced}、@samp{itanium2}、@samp{mckinley}である。

@item -milp32
@itemx -mlp64
@opindex milp32
@opindex mlp64
32ビットまたは64ビット環境用のコードを生成する。 32ビット環境はint、long、およびポインタを32ビットへ設定する。 64ビット環境ではintを32ビット長、longとポインタを64ビットに設定する。 これらはHP-UX固有のフラグである。

@item -mno-sched-br-data-spec
@itemx -msched-br-data-spec
@opindex mno-sched-br-data-spec
@opindex msched-br-data-spec
リロードする前にデータ推測スケジューリングを無（有）効にする。その結果、@code{ld.a}命令とそれに対応するチェック命令（@code{ld.c} / @code{chk.a}）が生成される。 デフォルト設定は無効です。

@item -msched-ar-data-spec
@itemx -mno-sched-ar-data-spec
@opindex msched-ar-data-spec
@opindex mno-sched-ar-data-spec
リロード後にデータ推測スケジューリングを有（無）効にする。その結果、@code{ld.a}命令とそれに対応するチェック命令（@code{ld.c} / @code{chk.a}）が生成される。デフォルト設定は有効である。

@item -mno-sched-control-spec
@itemx -msched-control-spec
@opindex mno-sched-control-spec
@opindex msched-control-spec
制御投機的スケジューリングを無（有）効にする。 この機能は、領域スケジュール設定時にのみ使用できる（すなわち、リロード前）。 これにより、@code{ld.s}命令とそれに対応するチェック命令@code{chk.s}が生成される。デフォルト設定は無効である。

@item -msched-br-in-data-spec
@itemx -mno-sched-br-in-data-spec
@opindex msched-br-in-data-spec
@opindex mno-sched-br-in-data-spec
リロード前にデータ投機的ロードに依存する命令の投機的スケジューリングを有（無）効にする。 これは、@option{-msched-br-data-spec}を有効にした場合にのみ有効である。 デフォルト設定は有効である。

@item -msched-ar-in-data-spec
@itemx -mno-sched-ar-in-data-spec
@opindex msched-ar-in-data-spec
@opindex mno-sched-ar-in-data-spec
リロード後のデータ投機的ロードに依存する命令の投機的スケジューリングを有（無）効にする。 これは、@option{-msched-ar-data-spec}を有効にした場合にのみ有効である。デフォルト設定は有効である。

@item -msched-in-control-spec
@itemx -mno-sched-in-control-spec
@opindex msched-in-control-spec
@opindex mno-sched-in-control-spec
制御投機的負荷に依存する命令の投機的スケジューリングを有（無）効にする。これは、@option{-msched-control-spec}が有効な場合にのみ有効である。デフォルト設定は有効である。

@item -mno-sched-prefer-non-data-spec-insns
@itemx -msched-prefer-non-data-spec-insns
@opindex mno-sched-prefer-non-data-spec-insns
@opindex msched-prefer-non-data-spec-insns
このオプションが有効になっていると、その時点で他の選択肢がない場合にのみ、スケジュールでデータの投機的な命令が選択される。 これは、データ推測の使用をはるかに控えめにする。 デフォルト設定は無効である。

@item -mno-sched-prefer-non-control-spec-insns
@itemx -msched-prefer-non-control-spec-insns
@opindex mno-sched-prefer-non-control-spec-insns
@opindex msched-prefer-non-control-spec-insns
有効にすると、現時点で他の選択肢がない場合にのみ、スケジュールで制御投機的命令が選択されます。 これは、制御推測の使用をより控えめにする。 デフォルト設定は無効である。

@item -mno-sched-count-spec-in-critical-path
@itemx -msched-count-spec-in-critical-path
@opindex mno-sched-count-spec-in-critical-path
@opindex msched-count-spec-in-critical-path
有効にすると、命令の優先順位の計算中に投機的な依存関係が考慮される。 これにより、推測の使用は少し控えめになる。デフォルト設定は無効である。

@item -msched-spec-ldc
@opindex msched-spec-ldc
簡単なデータの推測チェックを使用する。 このオプションは、デフォルトでオンになっている。

@item -msched-control-spec-ldc
@opindex msched-spec-ldc
コントロールの推測のための簡単なチェックを使用する。 このオプションは、デフォルトでオンになっている。

@item -msched-stop-bits-after-every-cycle
@opindex msched-stop-bits-after-every-cycle
スケジューリングの際には、各サイクルの後にストップビットを配置する。 このオプションは、デフォルトでオンになっている。

@item -msched-fp-mem-deps-zero-cost
@opindex msched-fp-mem-deps-zero-cost
浮動小数点ストアとロードは、同じ命令グループに配置されたときに競合を引き起こす可能性が低いと仮定する。 このオプションはデフォルトで無効になっている。

@item -msel-sched-dont-check-control-spec
@opindex msel-sched-dont-check-control-spec
選択的スケジューリングで制御の推測のチェックを生成する。このフラグは、デフォルトでは無効になっている。

@item -msched-max-memory-insns=@var{max-insns}
@opindex msched-max-memory-insns
命令グループごとのメモリインinsの数を制限し、同じ命令グループ内でスケジューリングを試みる後続のメモリインシュランスを優先させる。 キャッシュバンクの競合を防止するために頻繁に役立つ。 デフォルト値は1である。

@item -msched-max-memory-insns-hard-limit
@opindex msched-max-memory-insns-hard-limit
@option{msched-max-memory-insns}で指定された制限をハードリミットにし、その数を命令グループ内で禁止する。
それ以外の場合、制限は「ソフト」である。つまり、制限に達すると非メモリー操作が優先されるが、メモリー操作は引き続きスケジュールされる。

@end table

@node LM32 Options
@subsection LM32オプション
@cindex LM32 options

これらの@option{-m}オプションは、LatticeMico32アーキテクチャ用に定義されている。

@table @gcctabopt
@item -mbarrel-shift-enabled
@opindex mbarrel-shift-enabled
バレルシフト命令を有効にする。

@item -mdivide-enabled
@opindex mdivide-enabled
除算と剰余命令を有効にする。

@item -mmultiply-enabled
@opindex multiply-enabled
乗算命令を有効にする。

@item -msign-extend-enabled
@opindex msign-extend-enabled
符号拡張命令を有効にする。

@item -muser-enabled
@opindex muser-enabled
ユーザー定義の命令を有効にする。

@end table

@node M32C Options
@subsection M32Cオプション
@cindex M32C options

@table @gcctabopt
@item -mcpu=@var{name}
@opindex mcpu=
コードが生成されるCPUを選択する。 @var{name}は、R8C/Tinyシリーズでは@samp{r8c}、M16Cシリーズ（/60まで）では@samp{m16c}、M16C/80シリーズでは@samp{m32cm}、 @samp{m32c}はM32C/80シリーズ用である。

@item -msim
@opindex msim
プログラムをシミュレータ上で実行することを指定する。 これにより、ファイルI/Oなどをサポートする別のランタイムライブラリがリンクされる。 実際のハードウェア上で動作するプログラムを生成するときは、このオプションを使用してはならない。 どのI/O関数が必要なのかに関わらず、独自のランタイムライブラリを用意する必要がある。

@item -memregs=@var{number}
@opindex memregs=
コード生成時にGCCが使用するメモリベースの擬似レジスタの数を指定する。 これらの擬似レジスタは実レジスタのように使用されるため、GCCのコードを使用可能なレジスタに収める能力と、レジスタの代わりにメモリを使用する際のパフォーマンス上のペナルティがある。 このオプションには、プログラム内のすべてのモジュールを同じ値でコンパイルする必要がある。 そのため、GCCのデフォルトのランタイムライブラリではこのオプションを使用してはならない。

@end table

@node M32R/D Options
@subsection M32R/D オプション
@cindex M32R/D options

これらの@option{-m}オプションは、ルネサスM32R/Dのアーキテクチャで定義されています。

@table @gcctabopt
@item -m32r2
@opindex m32r2
M32R/2用のコードを生成する。

@item -m32rx
@opindex m32rx
M32R/X用のコードを生成する。

@item -m32r
@opindex m32r
M32R/R用のコードを生成する。これはデフォルトである。

@item -mmodel=small
@opindex mmodel=small
すべてのオブジェクトがメモリの下位16MBにあると仮定し、（そのアドレスは@code{ld24}命令でロードできるようになる）、すべてのサブルーチンは@code{bl}命令で到達可能であると仮定する。 これがデフォルトである。

特定のオブジェクトのアドレス可能性は@code{model}属性で設定できる。

@item -mmodel=medium
@opindex mmodel=medium
オブジェクトが32ビットアドレス空間のどこにもあるかもしれないと仮定し、（コンパイラがアドレスをロードするために@code{seth/add3}命令を生成する）、すべてのサブルーチンが@code{bl}命令で到達可能であると仮定する。

@item -mmodel=large
@opindex mmodel=large
オブジェクトが32ビットアドレス空間のどこにもあるかもしれないと仮定し、（コンパイラがアドレスをロードするために@code{seth/add3}命令を生成する）、@code{bl}命令でサブルーチンに到達できないと仮定する。（コンパイラははるかに遅い@code{seth/add3/jl}命令シーケンスを生成する）

@item -msdata=none
@opindex msdata=none
小さなデータ領域の使用を無効にする。 変数は（@code{section}属性が指定されていない限り）@code{.data}、@code{.bss}、@code{.rodata}のいずれかに入れられる。 これがデフォルトである。

小さなデータ領域は、セクション@code{.sdata}と@code{.sbss}で構成されている。 オブジェクトは、これらのセクションの1つを使用して、@code{section}属性を持つ小さなデータ領域に明示的に置くことができる。

@item -msdata=sdata
@opindex msdata=sdata
小規模なデータ領域に小さなグローバルおよび静的データを入れるが、それらを参照する特別なコードは生成しない。

@item -msdata=use
@opindex msdata=use
小規模なデータ領域に小さなグローバルおよび静的データを入れ、それを参照する特別な命令を生成する。

@item -G @var{num}
@opindex G
@cindex smaller data references
@var{num}バイト以下のグローバルおよび静的オブジェクトを、通常のデータまたはBSSセクションの代わりに、小さなデータまたはBSSセクションに配置する。 @var{num}のデフォルト値は8である。@option{-msdata}オプションは、@samp{sdata}または@samp{use}のいずれかに設定する必要がある。

すべてのモジュールは同じ@option{-G @var{num}}値でコンパイルする必要がある。 異なる値の@var{num}を使ってコンパイルすると、うまく動作しない場合がある。 リンカーがエラーメッセージを表示しない場合、間違ったコードは生成されない。

@item -mdebug
@opindex mdebug
コンパイラ内のM32R固有のコードで、プログラムのデバッグに役立ついくつかの統計情報が表示される。

@item -malign-loops
@opindex malign-loops
すべてのループを32バイト境界に揃えます。

@item -mno-align-loops
@opindex mno-align-loops
ループに32バイトのアライメントを強制しない。 これがデフォルトである。

@item -missue-rate=@var{number}
@opindex missue-rate=@var{number}
サイクルごとに@var{number}命令を発行する。 @var{number}は1または2しか指定できない。

@item -mbranch-cost=@var{number}
@opindex mbranch-cost=@var{number}
@var{number}は1または2しか指定できない。1の場合は条件コードよりも分岐が優先され、2の場合は逆が適用される。

@item -mflush-trap=@var{number}
@opindex mflush-trap=@var{number}
キャッシュをフラッシュするために使用するトラップ番号を指定する。 デフォルトは12である。有効な数値は0から15である。

@item -mno-flush-trap
@opindex mno-flush-trap
トラップを使用してキャッシュをフラッシュできないことを指定する。

@item -mflush-func=@var{name}
@opindex mflush-func=@var{name}
キャッシュをフラッシュするために呼び出すオペレーティングシステム関数の名前を指定する。 デフォルトは@samp{_flush_cache}であるが、関数呼び出しはトラップが利用できない場合にのみ使用される。

@item -mno-flush-func
@opindex mno-flush-func
キャッシュをフラッシュするためのOS機能がないことを示す。

@end table

@node M680x0 Options
@subsection M680x0オプション
@cindex M680x0 options

これらは、M680x0とColdFireプロセッサーで定義された@samp{-m}オプションである。デフォルト設定は、コンパイラの設定時に選択されたアーキテクチャによって異なる。 最も一般的な選択肢のデフォルトが以下に示されている。

@table @gcctabopt
@item -march=@var{arch}
@opindex march
特定のM680x0またはColdFire命令セットアーキテクチャ用のコードを生成する。M680x0アーキテクチャ用の@var{arch}の許容値は次のとおりである。@samp{68000}、@samp{68010}、@samp{68020}、@samp{68030}、@samp{68040}、@samp{68060}、@samp{cpu32}である。ColdFireアーキテクチャはFreescaleのISA分類に従って選択され、許容値は@samp{isaa}、@samp{isaaplus}、@samp{isab}、@samp{isac}である。

GCCは、ColdFireターゲット用のコードを生成しているときは常に、マクロ@code{__ mcf@var{arch}__}を定義する。 このマクロの@var{arch}は、上記の@option{-march}引数の1つである。

@option{-march}と@option{-mtune}を併用すると、類似のプロセッサファミリで実行されるが特定のマイクロアーキテクチャに最適化されたコードを選択する。

@item -mcpu=@var{cpu}
@opindex mcpu
特定のM680x0またはColdFireプロセッサ用のコードを生成する。M680x0 @var{cpu}は次のとおりである：@samp{68000}、@samp{68010}、@samp{68020}、@samp{68030}、@samp{68040}、@samp{68060}、@samp{68302}、@samp{68332}
@samp{cpu32}である。ColdFire@var{cpu}は、以下の表で与えられる。この表はまた、CPUをファミリに分類する。

@multitable @columnfractions 0.20 0.80
@item @strong{Family} @tab @strong{@samp{-mcpu} arguments}
@item @samp{51} @tab @samp{51} @samp{51ac} @samp{51ag} @samp{51cn} @samp{51em} @samp{51je} @samp{51jf} @samp{51jg} @samp{51jm} @samp{51mm} @samp{51qe} @samp{51qm}
@item @samp{5206} @tab @samp{5202} @samp{5204} @samp{5206}
@item @samp{5206e} @tab @samp{5206e}
@item @samp{5208} @tab @samp{5207} @samp{5208}
@item @samp{5211a} @tab @samp{5210a} @samp{5211a}
@item @samp{5213} @tab @samp{5211} @samp{5212} @samp{5213}
@item @samp{5216} @tab @samp{5214} @samp{5216}
@item @samp{52235} @tab @samp{52230} @samp{52231} @samp{52232} @samp{52233} @samp{52234} @samp{52235}
@item @samp{5225} @tab @samp{5224} @samp{5225}
@item @samp{52259} @tab @samp{52252} @samp{52254} @samp{52255} @samp{52256} @samp{52258} @samp{52259}
@item @samp{5235} @tab @samp{5232} @samp{5233} @samp{5234} @samp{5235} @samp{523x}
@item @samp{5249} @tab @samp{5249}
@item @samp{5250} @tab @samp{5250}
@item @samp{5271} @tab @samp{5270} @samp{5271}
@item @samp{5272} @tab @samp{5272}
@item @samp{5275} @tab @samp{5274} @samp{5275}
@item @samp{5282} @tab @samp{5280} @samp{5281} @samp{5282} @samp{528x}
@item @samp{53017} @tab @samp{53011} @samp{53012} @samp{53013} @samp{53014} @samp{53015} @samp{53016} @samp{53017}
@item @samp{5307} @tab @samp{5307}
@item @samp{5329} @tab @samp{5327} @samp{5328} @samp{5329} @samp{532x}
@item @samp{5373} @tab @samp{5372} @samp{5373} @samp{537x}
@item @samp{5407} @tab @samp{5407}
@item @samp{5475} @tab @samp{5470} @samp{5471} @samp{5472} @samp{5473} @samp{5474} @samp{5475} @samp{547x} @samp{5480} @samp{5481} @samp{5482} @samp{5483} @samp{5484} @samp{5485}
@end multitable

@var{arch}が@var{cpu}と互換性がある場合、@option{-mcpu=@var{cpu}}は@option{-march=@var{arch}}をオーバーライドする。 @option{-mcpu}と@option{-march}の他の組み合わせは拒否される。

GCCは、ColdFireターゲット@var{cpu}が選択されているときにマクロ@code {__mcf_cpu_@var{cpu}}を定義する。また、@code{__mcf_family_@var{family}}を定義する。ここで、@var{family}の値は上記の表によって与えられる。

@item -mtune=@var{tune}
@opindex mtune
@option {-march}と@option {-mcpu}で設定された制約内で、特定のマイクロアーキテクチャのコードをチューニングする。M680x0マイクロアーキテクチャは、@samp{68000}、@samp{68010}、@samp{68020}、@samp{68030}、@samp{68040}、@samp{68060}、@samp{cpu32}である。ColdFireのマイクロアーキテクチャは、@samp{cfv1}、@samp{cfv2}、@samp{cfv3}、@samp{cfv4}、@samp{cfv4e}である。

68020、68030、および68040のターゲットで比較的よく動作する必要のあるコードには、@option{-mtune=68020-40}を使用することもできる。@option{-mtune=68020-60}は似ていますが、68060個のターゲットも含む。 これらの2つのオプションは、それぞれ@option{-m68020-40}と@option{-m68020-60}と同じチューニングの決定を選択する。

GCCは680x0アーキテクチャ@var{arch}をチューニングするとき、マクロ@code{__mc@var{arch}}と@code{__mc@var{arch}__}を定義します。また、@option{-ansi}またはGNU以外の@option{-std}オプションを使用しない限り、@code{mc@var{arch}}も定義する。GCCが@option{-mtune=68020-40}または@option{-mtune=68020-60}で選択されたアーキテクチャの範囲に対してチューニングを行っている場合、GCCは範囲内のすべてのアーキテクチャのマクロを定義する。

GCCはColdFireマイクロアーキテクチャ@var{uarch}のチューニングの際に@code{__m@var{uarch}__}マクロも定義する。ここで、@var{uarch}は上記の引数の1つである。

@item -m68000
@itemx -mc68000
@opindex m68000
@opindex mc68000
68000の出力を生成する。これは、コンパイラが68000ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=68000}と同じである。

68008、68302、68306、68307、68322、68328、および68356を含む68000またはEC000コアを搭載したマイクロコントローラには、このオプションを使用する。

@item -m68010
@opindex m68010
68010の出力を生成する。これは、コンパイラが68010ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=68010}と同等である。

@item -m68020
@itemx -mc68020
@opindex m68020
@opindex mc68020
68020の出力を生成する。これは、コンパイラが68020ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=68020}と同等である。

@item -m68030
@opindex m68030
68030の出力を生成する。これは、コンパイラが68030ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=68030}と同等である。

@item -m68040
@opindex m68040
68040の出力を生成する。これは、コンパイラが68040ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=68040}と同等です。

このオプションは、68040のソフトウェアでエミュレートする必要がある68881/68882命令の使用を禁止する。68040にこれらの命令をエミュレートするコードがない場合は、このオプションを使用する。

@item -m68060
@opindex m68060
68060の出力を生成する。これは、コンパイラが68060ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=68060}と同等である。

このオプションは、68060のソフトウェアでエミュレートする必要のある68020および68881/68882命令の使用を禁止する。68060にこれらの命令をエミュレートするコードがない場合は、このオプションを使用する。

@item -mcpu32
@opindex mcpu32
CPU32の出力を生成する。 コンパイラがCPU32ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=cpu32}と同等である。

68330、68331、68332、68333、68334、68336、68340、68341、68349、68360を含むCPU32またはCPU32 +コアを搭載したマイクロコントローラには、このオプションを使用する。

@item -m5200
@opindex m5200
520X ColdFire CPU用の出力を生成する。 これは、コンパイラが520Xベースのシステム用に設定されている場合のデフォルトである。これは@option{-mcpu=5206}と同等で、現在はそのオプションの方がいいために非推奨である。

MCF5202、MCF5203、MCF5204、MCF5206を含む5200コアのマイクロコントローラには、このオプションを使用する。

@item -m5206e
@opindex m5206e
5206e ColdFire CPU用の出力を生成します。 このオプションは現在非推奨で、対応する@option{-mcpu=5206e}を使用する。

@item -m528x
@opindex m528x
ColdFire 528X族のメンバ用の出力を生成する。 このオプションは現在非推奨で、対応する@option{-mcpu=5206e}を使用する。

@item -m5307
@opindex m5307
ColdFire 5307 CPU用の出力を生成します。このオプションは非推奨になり、対応する@option{-mcpu=5307}を使用する。

@item -m5407
@opindex m5407
ColdFire 5407 CPU用の出力を生成します。このオプションは非推奨になり、対応する@option{-mcpu=5407}を使用する。

@item -mcfv4e
@opindex mcfv4e
ColdFire V4e族CPU用（例えば547x/548x）の出力を生成する。このオプションは@option{-mcpu=547x}と同等で、そのオプションの方がいいために非推奨である。

@item -m68020-40
@opindex m68020-40
新しい命令を使用せずに、68040の出力を生成する。 これにより、68020/68881または68030または68040で比較的効率的に実行できるコードが生成される。生成されたコードでは、68040でエミュレートされる68881命令が使用される。

このオプションは、@option{-march=68020} @option{-mtune=68020-40}と同等である。

@item -m68020-60
@opindex m68020-60
新しい命令を使用せずに、68060の出力を生成する。 これにより、68020/68881または68030または68040で比較的効率的に実行できるコードが生成される。生成されたコードでは、68060でエミュレートされる68881命令が使用される。

このオプションは、@option{-march=68020} @option{-mtune=68020-60}と同等である。

@item -mhard-float
@itemx -m68881
@opindex mhard-float
@opindex m68881
浮動小数点命令を生成する。 これは、68020以上の場合、およびFPUがあるColdFireデバイスの場合はデフォルトである。 これは、M680x0ターゲットでマクロ@code{__HAVE_68881__}、ColdFireターゲットで@code{__mcffpu__}を定義する。

@item -msoft-float
@opindex msoft-float
浮動小数点命令を生成しない。 代わりにライブラリ呼び出しを使用する。これは、68000、68010、および68832ターゲットのデフォルトである。 FPUを持たないColdFireデバイスのデフォルト値でもある。

@item -mdiv
@itemx -mno-div
@opindex mdiv
@opindex mno-div
ColdFireのハードウェア除算および剰余命令を生成する（生成しない）。@option{-mcpu}を使用せずに@option{-march}を使用すると、デフォルトはColdFireアーキテクチャでは「オン」、M680x0アーキテクチャでは「オフ」になる。
それ以外の場合、デフォルトはターゲットCPU（デフォルトCPUか@option{-mcpu}で指定されたCPU）から取得される。  たとえば、デフォルトは、@option{-mcpu=5206}では「オフ」、@option{-mcpu=5206e}では「オン」である。

GCCは、このオプションを有効にするとマクロ@code{__mcfhwdiv__}を定義する。

@item -mshort
@opindex mshort
@code{int}型は、@code{short int}のように、16ビット幅であるとみなす。さらに、スタック上で渡されるパラメータは、APIが32ビットへの昇格を要求するターゲットであっても、16ビット境界にアライメントされる。

@item -mno-short
@opindex mno-short
@code{int}型を16ビット幅とみなさない。 これがデフォルトである。

@item -mnobitfield
@itemx -mno-bitfield
@opindex mnobitfield
@opindex mno-bitfield
ビットフィールド命令は使用しない。 @option{-m68000}、@option{-mcpu32}、@option{-m5200}のオプションは@w{@option{-mnobitfield}}を含む。

@item -mbitfield
@opindex mbitfield
ビットフィールド命令を使用する。 @option{-m68020}オプションは、@option{-mbitfield}を含む。これは、68020用に設計された構成を使用する場合のデフォルトである。

@item -mrtd
@opindex mrtd
異なる関数呼び出し規約を使い、引数の数が固定されている関数が@code{rtd}命令で返されるようにする。 これにより、引数をポップする必要がないため、呼び出し元に1つの命令が節約される。

この呼び出し規約は、Unixで通常使用されているものとは互換性がないため、Unixコンパイラでコンパイルされたライブラリを呼び出す必要がある場合は使用できない。

また、可変数の引数（@code{printf}を含む）をとるすべての関数の関数プロトタイプを提供する必要がある。 さもなければ、それらの関数への呼び出しに対して誤ったコードが生成される。

さらに、あまりにも多くの引数を指定して関数を呼び出すと、コードが誤って不正確になる。 （通常、余分な引数は無害に無視される。）

@code{rtd}命令は、68010、68020、68030、68040、68060、およびCPU32プロセッサで動作するが、68000または5200では動作しない。

@item -mno-rtd
@opindex mno-rtd
@option{-mrtd}によって選択された呼び出し規約を使用しない。これがデフォルトである。

@item -malign-int
@itemx -mno-align-int
@opindex malign-int
@opindex mno-align-int
GCCが@code{int}、@code{long}、@code{long long}、@code{float}、@code{double}、@code{long double}を32ビット境界にするか（@option{-mnn-align-int}）および16ビット境界にするか（@option{-mine-align-int}）を指定する。32ビット境界で変数を調整すると、32ビットバスのプロセッサでより高速に実行されるコードが生成され、メモリが増える。

@strong{警告：} @option{-malign-int}スイッチを使用すると、GCCは、上記の型を含む構造体を、m68kの公開アプリケーションバイナリインタフェース仕様とは異なる方法で整列する。

@opindex mpcrel
グローバルオフセットテーブルを使用する代わりに、68000のpc相対アドレッシングモードを直接使用する。 現在のところ、このオプションは@option{-fpic}を意味し、PC相対アドレッシングでは最大16ビットのオフセットが可能である。 @option{-fPIC}は現在、@option{-mpcrel}でサポートされていないが、これは68020以上のプロセッサでサポートされる可能性がある。

@item -mno-strict-align
@itemx -mstrict-align
@opindex mno-strict-align
@opindex mstrict-align
アライメントされていないメモリ参照がシステムによって処理されるとは仮定しない（する）。

@item -msep-data
データセグメントをテキストセグメントとは異なるメモリ領域に配置できるようにするコードを生成する。これにより、仮想メモリ管理のない環境での実行が可能になる。 このオプションは@option{-fPIC}を含む。

@item -mno-sep-data
データセグメントがテキストセグメントに続くことを前提とするコードを生成する。 これがデフォルトである。

@item -mid-shared-library
ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成する。これにより、仮想メモリー管理のない環境で、現場で実行されたライブラリーおよび共用ライブラリーが可能になる。 このオプションは@option{-fPIC}を含む。

@item -mno-id-shared-library
IDベースの共有ライブラリが使用されていることを前提としないコードを生成します。これがデフォルトである。

@item -mshared-library-id=n
コンパイルされるIDベースの共有ライブラリの識別番号を指定する。 0の値を指定すると、よりコンパクトなコードが生成される。 他の値を指定すると、その番号を現在のライブラリに強制的に割り当てることができるが、このオプションを省略するよりもスペースや時間効率が高くならない。

@item -mxgot
@itemx -mno-xgot
@opindex mxgot
@opindex mno-xgot
ColdFireの位置非依存コードを生成する場合、GOTに8192を超えるエントリがある場合に動作するコードを生成する。 このコードは、このオプションを指定せずに生成されたコードよりも大きく、処理速度が遅くなる。 M680x0プロセッサでは、このオプションは不要である。 @option{-fPIC}で十分である。

GCCは通常、単一の命令を使用してGOTから値をロードする。これは比較的効率的だが、GOTが約64kより小さい場合にのみ機能する。 大きな値を指定すると、リンカーは次のようなエラーを報告する。

@cindex relocation truncated to fit (ColdFire)
@smallexample
relocation truncated to fit: R_68K_GOT16O foobar
@end smallexample

このような場合は、コードを@option{-mxgot}で再コンパイルする必要がある。それは非常に大きなGOTで動作するはずである。 しかし、@option{-mxgot}で生成されたコードは、大域シンボルの値をフェッチするために4つの命令を必要とするため、あまり効率的ではない。

GNUリンカの新しいバージョンを含むいくつかのリンカは、複数のGOTを作成してGOTエントリをソートできることに注意すること。 このようなリンカーがある場合は、8192個を超えるGOTエントリにアクセスする単一のオブジェクトファイルをコンパイルするときに@option{-mxgot}を使用するだけで済む。 それをするのは非常に少ない。

GCCが位置に依存しないコードを生成していない限り、これらのオプションは効果がない。

@item -mlong-jump-table-offsets
@opindex mlong-jump-table-offsets
@code{switch}テーブルでは32ビットのオフセットを使用する。 デフォルトでは、16ビットのオフセットが使用される。

@end table

@node MCore Options
@subsection MCoreオプション 
@cindex MCore options

これらはMotorola M*Coreプロセッサ用に定義された@samp{-m}オプションである。

@table @gcctabopt

@item -mhardlit
@itemx -mno-hardlit
@opindex mhardlit
@opindex mno-hardlit
2命令以下で実行できる場合は、コードストリームへ定数をインライン化する。

@item -mdiv
@itemx -mno-div
@opindex mdiv
@opindex mno-div
除算命令を使う。（デフォルトで有効である）

@item -mrelax-immediate
@itemx -mno-relax-immediate
@opindex mrelax-immediate
@opindex mno-relax-immediate
ビット操作での任意サイズの定数を許可する。

@item -mwide-bitfields
@itemx -mno-wide-bitfields
@opindex mwide-bitfields
@opindex mno-wide-bitfields
常にビットフィールドを@code{int}のサイズとして扱う。

@item -m4byte-functions
@itemx -mno-4byte-functions
@opindex m4byte-functions
@opindex mno-4byte-functions
強制的に全関数を4バイト境界に揃えさせる。

@item -mcallgraph-data
@itemx -mno-callgraph-data
@opindex mcallgraph-data
@opindex mno-callgraph-data
コールグラフ情報を生成する。

@item -mslow-bytes
@itemx -mno-slow-bytes
@opindex mslow-bytes
@opindex mno-slow-bytes
バイト数を読み取るときは、ワードアクセスを優先する。

@item -mlittle-endian
@itemx -mbig-endian
@opindex mlittle-endian
@opindex mbig-endian
リトルエンディアンターゲットのコードを生成する。

@item -m210
@itemx -m340
@opindex m210
@opindex m340
210プロセッサ用のコードを生成する。

@item -mno-lsim
@opindex mno-lsim
実行時のサポートが提供されていると仮定し、リンカのコマンドラインからシミュレータライブラリ（@file{libsim.a}）を省略する。

@item -mstack-increment=@var{size}
@opindex mstack-increment
単一のスタック増分操作の最大量を設定する。 大きな値を指定すると、大量のスタック領域を必要とする関数を含むプログラムの速度が向上する可能性があるが、スタックがあまりにも長くなると、セグメンテーション違反が発生する可能性がある。 デフォルト値は0x1000である。

@end table

@node MeP Options
@subsection MePオプション
@cindex MeP options

@table @gcctabopt

@item -mabsdiff
@opindex mabsdiff
2つのレジスタ間の絶対差である@code{abs}命令を有効にする。

@item -mall-opts
@opindex mall-opts
すべてのオプション命令（平均、乗算、除算、ビット演算、先行ゼロ、絶対差、最小/最大、クリップ、および彩度）を有効にする。

@item -maverage
@opindex maverage
2つのレジスタの平均を計算する@code{ave}命令を有効にする。

@item -mbased=@var{n}
@opindex mbased=
@var{n}バイト以下の変数は、デフォルトで@code{.based}セクションに置かれる。 ベースの変数はベースレジスタとして@code{$tp}レジスタを使い、@code{.based}セクションには128バイトの制限がある。

@item -mbitops
@opindex mbitops
ビット操作命令を有効にする。ビットテスト（@code{btstm}）、セット（@code{bsetm}）、クリア（@code{bclrm}）、反転（@code{bnotm}）、テスト・アンド・セット（@code{tas}）。

@item -mc=@var{name}
@opindex mc=
どのセクションの定数データが配置されるかを選択する。 @var{name}は@samp{tiny}、@samp{near}、@samp{far}である。

@item -mclip
@opindex mclip
@code{clip}命令を有効にする。 @option{-mclips}は、@option{-mminmax}も指定しないと便利ではないことに注意する。

@item -mconfig=@var{name}
@opindex mconfig=
組み込みコア構成の1つを選択する。各MePチップには1つ以上のモジュールがある。 各モジュールには、コアCPUと、さまざまなコプロセッサ、オプションの命令、および周辺機能がある。GCCの一部ではない@code{MeP-Integrator}ツールは、このオプションを通してこれらの設定を提供する。 このオプションを使用することは、対応するすべてのコマンドラインオプションを使用することと同じである。デフォルト設定は@samp{default}である。

@item -mcop
@opindex mcop
コプロセッサ命令を有効にする。 デフォルトでは、これは32ビットコプロセッサです。 コプロセッサは、通常、@option{-mconfig=}オプションで有効になることに注意。

@item -mcop32
@opindex mcop32
32ビットコプロセッサの命令を有効にする。

@item -mcop64
@opindex mcop64
64ビットコプロセッサの命令を有効にする。

@item -mivc2
@opindex mivc2
IVC2スケジューリングを有効にする。 IVC2は64ビットVLIWコプロセッサである。

@item -mdc
@opindex mdc
定数変数を@code {.near}セクションに配置する。

@item -mdiv
@opindex mdiv
@code{div}命令と@code{divu}命令を有効にする。

@item -meb
@opindex meb
ビッグエンディアンコードを生成する。

@item -mel
@opindex mel
リトルエンディアンコードを生成する。

@item -mio-volatile
@opindex mio-volatile
@code{io}属性でマークされた変数がvolatileとみなされることをコンパイラに伝える。

@item -ml
@opindex ml
デフォルトで@code{.far}セクションに変数を代入する。

@item -mleadz
@opindex mleadz
@code{leadz}（リーディングゼロ）命令を有効にする。

@item -mm
@opindex mm
デフォルトで@code{.near}セクションに変数を割り当てるようにする。

@item -mminmax
@opindex mminmax
@code{min}命令と@code{max}命令を有効にする。

@item -mmult
@opindex mmult
乗算命令と積和命令を有効にする。

@item -mno-opts
@opindex mno-opts
@option {-mall-opts}で有効になっているすべてのオプション命令を無効にする。

@item -mrepeat
@opindex mrepeat
低オーバーヘッドループで使用される@code{repeat}と@code{erepeat}命令を有効にする。

@item -ms
@opindex ms
すべての変数をデフォルトで@code{.tiny}セクションにする。このセクションには65536バイトの制限があることに注意。これらの変数へのアクセスは、@code{%gp}ベースレジスタを使用する。

@item -msatur
@opindex msatur
飽和命令を有効にする。 コンパイラは現在これ自身を生成しないが、このオプションは@code{as}のような他のツールとの互換性のために含まれている。

@item -msdram
@opindex msdram
既定のROMベースのランタイムの代わりにSDRAMベースのランタイムをリンクする。

@item -msim
@opindex msim
シミュレータランタイムライブラリをリンクする。

@item -msimnovec
@opindex msimnovec
シミュレータランタイムライブラリをリンクするが、リセットおよび例外ベクタとテーブルのビルトインサポートは除く。

@item -mtf
@opindex mtf
すべての関数をデフォルトで@code{.far}セクションにする。このオプションがなければ、関数はデフォルトで@code {.near}セクションになる。

@item -mtiny=@var{n}
@opindex mtiny=
@var{n}バイト以下の変数は@code{.tiny}セクションに割り当てられる。 これらの変数は、@code{$gp}ベースレジスタを使用する。このオプションのデフォルトは4だが、@code{.tiny}セクションには65536バイトの制限がある。

@end table

@node MicroBlaze Options
@subsection MicroBlazeオプション
@cindex MicroBlaze Options

@table @gcctabopt

@item -msoft-float
@opindex msoft-float
浮動小数点用のソフトウェアエミュレーションを使用する（デフォルト）。

@item -mhard-float
@opindex mhard-float
ハードウェア浮動小数点命令を使用します。

@item -mmemcpy
@opindex mmemcpy
ブロック・ムーブを最適化せず、@code{memcpy}を使う。

@item -mno-clearbss
@opindex mno-clearbss
このオプションは非推奨である。代わりに@option{-fno-zero-initialized-in-bss}を使うこと。

@item -mcpu=@var{cpu-type}
@opindex mcpu=
指定されたCPUの機能を使用し、そのCPUのスケジュールを設定する。サポートされている値は@samp{v@var{X}.@var{YY}.@var{Z}}の形式である。@var{X}はメジャーバージョン、@var{YY}はマイナーバージョン、 @var{Z}は互換コードである。値の例は、@samp{v3.00.a}, @samp{v4.00.b}, @samp{v5.00.a}, @samp{v5.00.b}, @samp{v5.00.b}, @samp{v6.00.a}。

@item -mxl-soft-mul
@opindex mxl-soft-mul
ソフトウェアの乗算エミュレーションを使用する。（デフォルト）

@item -mxl-soft-div
@opindex mxl-soft-div
ソフトウェアの除算エミュレーションを使用する。（デフォルト）

@item -mxl-barrel-shift
@opindex mxl-barrel-shift
ハードウェアのバレル・シフタを使う。

@item -mxl-pattern-compare
@opindex mxl-pattern-compare
パターン比較命令を使う。

@item -msmall-divides
@opindex msmall-divides
小さい符号付き整数除算にテーブル引き最適化を使う。

@item -mxl-stack-check
@opindex mxl-stack-check
このオプションは非推奨である。代わりに@option{-fstack-check}を使うこと。

@item -mxl-gp-opt
@opindex mxl-gp-opt
GP相対の@code{.sdata}/@code{.sbss}セクションを使用する。

@item -mxl-multiply-high
@opindex mxl-multiply-high
32x32乗算の上位部分には、高位乗算命令を使用する。

@item -mxl-float-convert
@opindex mxl-float-convert
ハードウェア浮動小数点変換命令を使う。

@item -mxl-float-sqrt
@opindex mxl-float-sqrt
ハードウェア浮動小数点平方根命令を使う。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンターゲット用のコードを生成する。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンターゲット用のコードを生成する。

@item -mxl-reorder
@opindex mxl-reorder
並べ替え命令（swapとバイト反転ロード・ストア）を使う。

@item -mxl-mode-@var{app-model}
アプリケーションモデル@var{app-model}を選択する。妥当な値は
@table @samp
@item executable
通常の実行ファイル（デフォルト）、スタートアップコード@file{crt0.o}を使う。

@item -mpic-data-is-text-relative
@opindex mpic-data-is-text-relative
テキストセグメントとデータセグメント間の変位が静的リンク時に固定されていると仮定します。 これにより、PC相対アドレス指定がサポートされていないため、GOTではなくテキストアドレスの先頭からのオフセットでデータを参照できます。

@item xmdstub
xmdstubと呼ばれるザイリンクスマイクロプロセッサデバッガ（XMD）ベースのソフトウェア侵入型デバッグエージェントで使用できる。これは、スタートアップファイル@file{crt1.o}を使用し、プログラムの開始アドレスを0x800に設定する。

@item bootstrap
ブートローダーを使用してロードされるアプリケーション向け。このモデルでは、プロセッサリセットベクトルハンドラを含まない起動ファイル@file{crt2.o}を使用している。これは、アプリケーションではなくブートローダへのプロセッサリセットの制御を転送するのに適している。

@item novectors
MicroBlazeベクタを必要としないアプリケーション向け。 このオプションは、監視アプリケーション内で実行されているアプリケーションに役立つ場合がある。 このモデルでは、@file{crt3.o}をスタートアップファイルとして使用する。
@end table

オプション@option{-xl-mode-@var{app-model}}は、@option {-mxl-mode-@var {app-model}}の非推奨エイリアスである。

@end table

@node MIPS Options
@subsection MIPSオプション
@cindex MIPS options

@table @gcctabopt

@item -EB
@opindex EB
ビッグエンディアンコードを生成する。

@item -EL
@opindex EL
リトルエンディアンコードを生成する。これは@samp{mips*el-*-*}構成でのデフォルトである。

@item -march=@var{arch}
@opindex march
@var{arch}で走るコードを生成し、それは汎用MIPS ISの名前であるか、特定のプロセッサ名である。ISA名は
@samp{mips1}, @samp{mips2}, @samp{mips3}, @samp{mips4},
@samp{mips32}, @samp{mips32r2}, @samp{mips32r3}, @samp{mips32r5},
@samp{mips32r6}, @samp{mips64}, @samp{mips64r2}, @samp{mips64r3},
@samp{mips64r5}, @samp{mips64r6}。プロセッサ名は
@samp{4kc}, @samp{4km}, @samp{4kp}, @samp{4ksc},
@samp{4kec}, @samp{4kem}, @samp{4kep}, @samp{4ksd},
@samp{5kc}, @samp{5kf},
@samp{20kc},
@samp{24kc}, @samp{24kf2_1}, @samp{24kf1_1},
@samp{24kec}, @samp{24kef2_1}, @samp{24kef1_1},
@samp{34kc}, @samp{34kf2_1}, @samp{34kf1_1}, @samp{34kn},
@samp{74kc}, @samp{74kf2_1}, @samp{74kf1_1}, @samp{74kf3_2},
@samp{1004kc}, @samp{1004kf2_1}, @samp{1004kf1_1},
@samp{i6400},
@samp{interaptiv},
@samp{loongson2e}, @samp{loongson2f}, @samp{loongson3a},
@samp{m4k},
@samp{m14k}, @samp{m14kc}, @samp{m14ke}, @samp{m14kec},
@samp{m5100}, @samp{m5101},
@samp{octeon}, @samp{octeon+}, @samp{octeon2}, @samp{octeon3},
@samp{orion},
@samp{p5600},
@samp{r2000}, @samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{r4400},
@samp{r4600}, @samp{r4650}, @samp{r4700}, @samp{r6000}, @samp{r8000},
@samp{rm7000}, @samp{rm9000},
@samp{r10000}, @samp{r12000}, @samp{r14000}, @samp{r16000},
@samp{sb1},
@samp{sr71000},
@samp{vr4100}, @samp{vr4111}, @samp{vr4120}, @samp{vr4130}, @samp{vr4300},
@samp{vr5000}, @samp{vr5400}, @samp{vr5500},
@samp{xlr}, @samp{xlp}.
特別な値@samp{from-abi}は、選択されたABI（つまり、32ビットABIでは@samp{mips1}、64ビットABIでは@samp{mips3}）に対して最も互換性の高いアーキテクチャを選択する。

ネイティブのLinux/GNUツールチェーンは、@samp{native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。gccがプロセッサを認識しない場合、@option{-march=native}は効果がない。

プロセッサ名では、最終的な@samp{000}を@samp{k}と省略することができる（たとえば、@option{-march=r2k}）。 接頭辞はオプションで、@samp{vr}は@samp{r}と書くことができる。

@samp{@var{n}f2_1}という形式の名前は、コアの半分の速度でクロックされるFPUを持つプロセッサを指し、@samp{@var{n}f1_1}形式の名前は、コアと同じ速度でクロックされるFPUを持つプロセッサを指し、@samp{@var{n}f3_2}の形式の名前は、コアに対してFPUが3：2でクロックされているプロセッサを指す。互換性のため、@samp{@var{n}f}は@samp{@var{n}f2_1}の同義語として受け入れられ、@samp{@var{n}x}と@samp{@var{fx}}は@samp{@var{n}f1_1}の同義語として受け入れられる。

GCCは、このオプションの値に基づいて2つのマクロを定義する。最初は@code{_MIPS_ARCH}で、ターゲットアーキテクチャの名前を文字列で示す。2番目の形式は@code{_MIPS_ARCH_@var{foo}}の形式で、ここで@var{foo}は@code{_MIPS_ARCH}の大文字の値である。たとえば、@option{-march=r2000}は@code{_MIPS_ARCH}を@code{"r2000"}に設定し、マクロ@code{_MIPS_ARCH_R2000}を定義する。

@code {_MIPS_ARCH}マクロは、上記のプロセッサ名を使用することに注意せよ。つまり、完全な接頭辞を持ち、@samp{000}を@samp{k}と省略しない。@samp{from-abi}の場合、マクロは解決されたアーキテクチャ（@code{"mips1"}または@code{"mips3"}）に名前を付けます。それは@option{-march}オプションが指定されていない場合のデフォルトアーキテクチャに名前を与える。

@item -mtune=@var{arch}
@opindex mtune
@var{arch}のために最適化する。 とりわけ、このオプションは、命令のスケジューリング方法と、算術演算の知覚されるコストを制御する。 @var{arch}値のリストは、@option{-march}と同じである。

このオプションを使用しないと、GCCは@option{-march}で指定されたプロセッサに対して最適化する。 @option{-march}と@option {-mtune}を一緒に使用することで、プロセッサファミリ上で動作するが、そのファミリの特定のメンバのコードに最適化するコードを生成できる。

@option{-mtune}はマクロ@code {_MIPS_TUNE}と@code{_MIPS_TUNE_@var{foo}}を定義する。これらは上記の@option{-march}と同様に動作する。

@item -mips1
@opindex mips1
@option{-march=mips1}と等価である。

@item -mips2
@opindex mips2
@option{-march=mips2}と等価である。

@item -mips3
@opindex mips3
@option{-march=mips3}と等価である。

@item -mips4
@opindex mips4
@option{-march=mips4}と等価である。

@item -mips32
@opindex mips32
@option{-march=mips32}と等価である。

@item -mips32r3
@opindex mips32r3
@option{-march=mips32r3}と等価である。

@item -mips32r5
@opindex mips32r5
@option{-march=mips32r5}と等価である。

@item -mips32r6
@opindex mips32r6
@option{-march=mips32r6}と等価である。

@item -mips64
@opindex mips64
@option{-march=mips64}と等価である。

@item -mips64r2
@opindex mips64r2
@option{-march=mips64r2}と等価である。

@item -mips64r3
@opindex mips64r3
@option{-march=mips64r3}と等価である。

@item -mips64r5
@opindex mips64r5
@option{-march=mips64r5}と等価である。

@item -mips64r6
@opindex mips64r6
@option{-march=mips64r6}と等価である。

@item -mips16
@itemx -mno-mips16
@opindex mips16
@opindex mno-mips16
MIPS16コードを生成する（しない）。GCCがMIPS32またはMIPS64アーキテクチャをターゲットにしている場合は、MIPS16e ASEを使用する。

MIPS16コードの生成は、@code{mips16}属性と@code{nomips16}属性を使用して、関数ごとに制御することもできる。さらなる情報は@xref{Function Attributes}.

@item -mflip-mips16
@opindex mflip-mips16
交代関数でMIPS16コードを生成する。 このオプションは、MIPS16/非MIPS16混在コード生成の回帰テスト用に提供されていて、ユーザーコードのコンパイルでは通常の使用を意図したものではない。

@item -minterlink-compressed
@itemx -mno-interlink-compressed
@opindex minterlink-compressed
@opindex mno-interlink-compressed
標準（非圧縮）MIPS ISAを使用してそのコードをMIPS16およびmicroMIPSコードとリンク互換にすることを要求する（しない）。

たとえば、標準のISAエンコーディングを使用するコードは、MIPS16またはmicroMIPSコードに直接ジャンプすることはできない。 コールまたは間接ジャンプを使用する必要がある。@option{-minterlink-compressed}はジャンプのターゲットが圧縮されていないことをGCCが知っていない限り直接ジャンプを無効にする。

@item -minterlink-mips16
@itemx -mno-interlink-mips16
@opindex minterlink-mips16
@opindex mno-interlink-mips16
@option{-minterlink-compressed}と@option{-mno-interlink-compressed}の別名。 これらのオプションは、microMIPS ASEより前からあり、下位互換性のために保持されている。

@item -mabi=32
@itemx -mabi=o64
@itemx -mabi=n32
@itemx -mabi=64
@itemx -mabi=eabi
@opindex mabi=32
@opindex mabi=o64
@opindex mabi=n32
@opindex mabi=64
@opindex mabi=eabi
与えられたABI用のコードを生成する。

EABIには32ビット版と64ビット版がある。 GCCは通常、64ビットアーキテクチャを選択すると64ビットコードを生成するが、代わりに@option{-mgp32}を使用して32ビットコードを得ることができる。

O64ABIについては@uref{http://gcc.gnu.org/@/projects/@/mipso64-abi.html}参照。

GCCは浮動小数点レジスタが32ビット幅ではなく64ビットであるo32 ABIの変形をサポートしている。 この組み合わせは、@option{-mabi=32} @option{-mfp64}で選択できる。 このABIは@code{mthc1}命令と@code{mfhc1}命令に依存しているため、MIPS32R2、MIPS32R3、MIPS32R5プロセッサでのみサポートされている。

引数と戻り値のレジスタ割り当ては同じだが、各スカラー値は1組の32ビットレジスタではなく1つの64ビットレジスタに渡される。 たとえば、スカラー浮動小数点値は@samp{$f0}/@samp{$f1}のペアではなく、@samp{$f0}にのみ返される。 また、偶数番号の倍精度レジスタが保存されるため、コールセーブされたレジスタのセットは同じままである。

32ビットから64ビットのレジスタへの遷移を可能にするために、o32 ABIの2つの追加の変種がサポートされている。 FPXX（@option{-mfpxx}）とFP64A（@option{-mfp64} @option {-mno-odd-spreg}）である。
FPXX拡張機能では、32ビットまたは64ビットのレジスタを使用して実行する場合、すべてのコードを正しく実行する必要がある。 コードは、FP32またはFP64のいずれかで相互にリンクできるが、両方ではリンクできない。FP64A拡張はFP64拡張と似ているが、奇数番号の単精度レジスタは使用できない。 これは、MIPS32R5プロセッサのFPUの@code{FRE}モードと組み合わせて使用することができ、FP32とFP64Aの両方のコードをFPUモードを変更せずに同じプロセスで相互リンクして実行することができる。

@item -mabicalls
@itemx -mno-abicalls
@opindex mabicalls
@opindex mno-abicalls
SVR4スタイルの動的オブジェクトに適したコードを生成する（しない）。 @option{-mabicalls}はSVR4ベースのシステムのデフォルトである。

@item -mshared
@itemx -mno-shared
完全な位置に依存せず、したがって共有ライブラリにリンクできるコードを生成する（しない）。 このオプションは@option{-mabicalls}にのみ影響する。

すべての@option{-mabicalls}コードは、@option{-fPIC}や@option {-fpic}のようなオプションにかかわらず、伝統的に位置に依存しなかった。 しかし、拡張として、GNUツールチェーンは、実行可能ファイルがローカルバインディングシンボルに絶対アクセスを使用できるようにする。 より短いGP初期化シーケンスを使用して、ローカル定義関数への直接呼び出しを生成することもできる。 このモードは、@option{-mno-shared}によって選択されます。

@option{-mno-shared}はbinutils 2.16以降に依存し、GNUリンカーによってのみリンクできるオブジェクトを生成する。 ただし、このオプションは最終実行可能ファイルのABIには影響しない。 再配置可能オブジェクトのABIにのみ影響する。 @option{-mno-shared}を使うと、一般的に実行ファイルのサイズが小さくなり、速くなる。

@option{-mshared}がデフォルトである。

@item -mplt
@itemx -mno-plt
@opindex mplt
@opindex mno-plt
静的リンカーと動的リンカーがPLTとコピーの再配置をサポートしていると仮定する（しない）。 このオプションは@option{-mno-shared -mabicalls}にのみ影響する。 n64 ABIの場合、このオプションは@option{-msym32}なしでは効果がない。

@option{-with-mips-plt}でGCCを構成することで、@option{-mplt}をデフォルトにすることができる。デフォルトは、@option{-mno-plt}である。

@item -mxgot
@itemx -mno-xgot
@opindex mxgot
@opindex mno-xgot
グローバルオフセットテーブルのサイズに関する通常の制限を持ち上る（持ち上げない）。

GCCは通常、単一の命令を使用してGOTから値をロードする。これは比較的効率的だが、GOTが約64kより小さい場合にのみ機能する。 大きな値を指定すると、リンカーは次のようなエラーを報告する。

@cindex relocation truncated to fit (MIPS)
@smallexample
relocation truncated to fit: R_MIPS_GOT16 foobar
@end smallexample

このような場合は、コードを@option{-mxgot}で再コンパイルする必要がある。これは非常に大きなGOTで動作するが、グローバルシンボルの値をフェッチするには3つの命令が必要なため、コードの効率も悪い。

いくつかのリンカは複数のGOTを作成できることに注意せよ。 このようなリンカーがある場合は、単一のオブジェクトファイルが64kを超えるGOTエントリにアクセスする場合にのみ、@option{-mxgot}を使用する必要がある。非常に少ない。

GCCが位置独立コードを生成しない限り、これらのオプションは効果がない。

@item -mgp32
@opindex mgp32
汎用目的レジスタが32ビット長であると仮定する。

@item -mgp64
@opindex mgp64
汎用目的レジスタが64ビット長であると仮定する。

@item -mfp32
@opindex mfp32
浮動小数点レジスタが32ビット長であると仮定する。

@item -mfp64
@opindex mfp64
浮動小数点レジスタが64ビット長であると仮定する。

@item -mfpxx
@opindex mfpxx
浮動小数点レジスタの幅を仮定しない。

@item -mhard-float
@opindex mhard-float
浮動小数点コプロセッサ命令を使う。

@item -msoft-float
@opindex msoft-float
浮動小数点コプロセッサ命令を使わない。代わりにライブラリ呼び出しを使って浮動小数点計算を実装する。

@item -mno-float
@opindex mno-float
@option{-msoft-float}と同等だが、コンパイルされるプログラムが浮動小数点演算を実行しないことをさらに主張する。このオプションは現在、一部のベアメタルMIPS構成でのみサポートされている。ここでは、すべての浮動小数点サポート（浮動小数点@code{printf}形式など）が不足している特別なライブラリセットを選択できる。@option{-mno-float}でコンパイルされたコードに、誤って浮動小数点演算が含まれていると、リンク時または実行時にエラーが発生する可能性がある。

@item -msingle-float
@opindex msingle-float
単精度操作のみをサポートする浮動小数点コプロセッサを仮定する。

@item -mdouble-float
@opindex mdouble-float
倍精度操作をサポートする浮動小数点コプロセッサを仮定する。これはデフォルトである。

@item -modd-spreg
@itemx -mno-odd-spreg
@opindex modd-spreg
@opindex mno-odd-spreg
o32 ABIに奇数番号の単精度浮動小数点レジスタを使用可能にする。 これは、これらのレジスタをサポートすることが知られているプロセッサのデフォルトである。 o32 FPXX ABIを使用する場合、デフォルトで@option{-mno-odd-spreg}が設定される。

@item -mabs=2008
@itemx -mabs=legacy
@opindex mabs=2008
@opindex mabs=legacy
これらのオプションは、特別な非数（NaN）IEEE 754浮動小数点データの処理を、@code{abs.@i{fmt}}および@code{neg.@i{fmt}}マシン命令で制御する。

デフォルトで、または@option{-mabs=legacy}を使用すると、従来の処置が選択される。 この場合、これらの命令は算術演算とみなされ、入力オペランドがNaNかもしれず、正しい演算が必要な場合は避けてるべきである。 @option{-ffinite-math-only}オプションも指定されていない限り、手動で浮動小数点データの符号ビットを操作するより長い一連の命令が代わりに使用される。

@option{-mabs=2008}オプションは、IEEE 754-2008処理を選択する。 この場合、これらの命令は非算術とみなされ、したがって、特に入力オペランドがNaNの場合を含むすべての場合において正しく動作する。 したがって、これらの命令は、それぞれの操作に常に使用される。

@item -mnan=2008
@itemx -mnan=legacy
@opindex mnan=2008
@opindex mnan=legacy
これらのオプションは、特殊非数（NaN）IEEE 754浮動小数点データのエンコードを制御する。

@option{-mnan=legacy}オプションは、レガシーエンコーディングを選択する。 この場合、静かなNaN（qNaNs）は、後続の仮数フィールドの最初のビットが0であると示され、シグナリングNaN（sNaNs）は、後続の仮数フィールドの最初のビットが1で表される。

@option{-mnan=2008}オプションは、IEEE 754-2008エンコーディングを選択する。 この場合、qNaNsは、後続の仮数フィールドの最初のビットが1であり、sNaNsは、後続の仮数フィールドの最初のビットが0であることによって示される。

GCCが@option{-with-nan=2008}で構成されていない限り、デフォルトは@option{-mnan=legacy}である。

@item -mllsc
@itemx -mno-llsc
@opindex mllsc
@opindex mno-llsc
アトミックメモリの組み込み関数を実装するために、@samp{ll}、@samp{sc}、@samp{sync}命令を使用しない。いずれのオプションも指定されていない場合、GCCはターゲットアーキテクチャがそれらをサポートしていればその命令を使用する。

@option{-mllsc}は、ランタイム環境で命令をエミュレートできる場合に便利である。また、非標準のISA用にコンパイルする場合は、@option{-mno-llsc}を使用すると便利である。 GCCを@option{-with-llsc}と@option{-without-llsc}でそれぞれ構成することで、いずれかのオプションをデフォルトにすることができる。 @option{-with-llsc}はいくつかの設定ではデフォルトである。 詳細については、インストールマニュアルを参照せよ。

@item -mdsp
@itemx -mno-dsp
@opindex mdsp
@opindex mno-dsp
MIPS DSP ASEのリビジョン1を使用する（しない）。@xref{MIPS DSP Built-in Functions}
このオプションはプリプロセッサマクロ@code{__mips_dsp}を定義する。 また、@code{__mips_dsp_rev}を1に定義する。

@item -mdspr2
@itemx -mno-dspr2
@opindex mdspr2
@opindex mno-dspr2
MIPS DSP ASEのリビジョン2を使用する（しない）。@xref{MIPS DSP Built-in Functions}
このオプションはプリプロセッサマクロ@code{__mips_dsp}を定義する。 また、@code{__mips_dsp_rev}を2に定義する。

@item -msmartmips
@itemx -mno-smartmips
@opindex msmartmips
@opindex mno-smartmips
MIPS SmartMIPS ASEを使用する（しない）。

@item -mpaired-single
@itemx -mno-paired-single
@opindex mpaired-single
@opindex mno-paired-single
組単精度命令を使用する（しない）。@xref{MIPS Paired-Single Support} このオプションはハードウェア浮動小数点サポートを有効にする必要がある。

@item -mdmx
@itemx -mno-mdmx
@opindex mdmx
@opindex mno-mdmx
MIPSデジタルメディア拡張命令を使用する（しない）。このオプションは64ビットコードを生成し、ハードウェア浮動小数点サポートを有効にする必要がある。

@item -mips3d
@itemx -mno-mips3d
@opindex mips3d
@opindex mno-mips3d
MIPS-3D ASEを使用する（しない）。@xref{MIPS-3D Built-in Functions} オプション@option{-mips3d}は@option{-mpaired-single}を含む。

@item -mmicromips
@itemx -mno-micromips
@opindex mmicromips
@opindex mno-mmicromips
microMIPSコードを生成する（しない）。

microMIPSコードの生成は、@code{micromips}属性と@code {nomicromips}属性を使用して、関数ごとに制御することもできる。
さらなる情報は、@xref{Function Attributes}

@item -mmt
@itemx -mno-mt
@opindex mmt
@opindex mno-mt
MTマルチスレッド命令を使用する（しない）。

@item -mmcu
@itemx -mno-mcu
@opindex mmcu
@opindex mno-mcu
MIPS MCU ASE命令を使用する（しない）。

@item -meva
@itemx -mno-eva
@opindex meva
@opindex mno-eva
MIPS拡張仮想アドレス命令を使用する（しない）。

@item -mvirt
@itemx -mno-virt
@opindex mvirt
@opindex mno-virt
MIPS仮想化(VZ)命令を使用する（しない）。

@item -mxpa
@itemx -mno-xpa
@opindex mxpa
@opindex mno-xpa
MIPS拡張物理アドレス（XPA）命令を使用する（しない）。

@item -mcrc
@itemx -mno-crc
@opindex mcrc
@opindex mno-crc
MIPS巡回冗長検査（CRC）命令を使用します（しません）。

@item -mginv
@itemx -mno-ginv
@opindex mginv
@opindex mno-ginv
MIPSグローバルINValidate（GINV）命令を使用します（しません）。

@item -mloongson-mmi
@itemx -mno-loongson-mmi
@opindex mloongson-mmi
@opindex mno-loongson-mmi
MIPS Loongson MultiMedia Extensions Instructions（MMI）を使用します（しません）。

@item -mloongson-ext
@itemx -mno-loongson-ext
@opindex mloongson-ext
@opindex mno-loongson-ext
MIPS Loongson EXTensions（EXT）命令を使用します（しません）。

@item -mloongson-ext2
@itemx -mno-loongson-ext2
@opindex mloongson-ext2
@opindex mno-loongson-ext2
MIPS Loongson EXTensions r2（EXT2）命令を使用する（しません）。

@item -mlong64
@opindex mlong64
@code{long}型を64ビット長に強制する。デフォルトの説明とポインタサイズの決定方法は
@option{-mlong32}を見よ。

@item -mlong32
@opindex mlong32
@code{long}, @code{int}, ポインタサイズを32ビット長に強制する。

@code{int}と@code{long}のデフォルトサイズはABIに依存する。サポートされている全ABIは32ビットの@code{int}を使う。n64 ABIは64ビットの@code{long}を使う、EABIもそうする。他は32ビットの@code{long}を使う。ポインタは@code{long}と同じサイズか、整数レジスタと同じサイズの、小さい方である。

@item -msym32
@itemx -mno-sym32
@opindex msym32
@opindex mno-sym32
全シンボルが、選択されたABIにかかわらず、32ビット値を持つと仮定する（しない）。このオプションは、@option{-mabi=64}と@option{-mno-abicalls}と組み合わせて使用すると、GCCがシンボリックアドレスへのより短い、より速い参照を生成できるので便利である。

@item -G @var{num}
@opindex G
そのデータが@var{num}バイトより大きくない場合は、外部データの定義を小さなデータセクションに置く。 GCCは、データへのより効率的なアクセスを生成することができる。 詳細は@option{-mgpopt}を参照。

デフォルトの@option{-G}オプションは構成によって異なる。

@item -mlocal-sdata
@itemx -mno-local-sdata
@opindex mlocal-sdata
@opindex mno-local-sdata
@option{-G}の振る舞いをCの静的変数など、ローカルデータにも拡張する（しない）。 @option{-mlocal-sdata}はすべての構成のデフォルトである。

リンカーが、アプリケーションが小さすぎるデータを使用していると不平を言う場合は、@option{-mno-local-sdata}を使用してパフォーマンスが重要でない部分を再構築したいかもしれない。 また、@option{-mno-local-sdata}を使用して大きなライブラリを構築して、ライブラリがメインプログラムのための余地を残したかもしれない。

@item -mextern-sdata
@itemx -mno-extern-sdata
@opindex mextern-sdata
@opindex mno-extern-sdata
そのデータのサイズが@option{-G}の範囲内にある場合、外部定義されたデータが小さなデータセクションにあると仮定する（しない）。@option{-mextern-sdata}はすべての構成のデフォルトである。

@option{-mextern-sdata} @option{-G @var{num}} @option{-mgpopt}でモジュール@var{Mod}をコンパイルし、@var{Mod}が@var{num}バイトより大きくない変数@var{Var}を参照しているならば、@var{Var}が小さなデータセクションに配置されていることを確認する必要がある。 @var{Var}が別のモジュールで定義されている場合は、十分な大きい@option{-G}設定でモジュールをコンパイルするか、@var{Var}の定義に@code{section}属性を付加する必要がある。 @var{Var}が共通の場合は、アプリケーションを十分な大きさの@option{-G}設定でリンクする必要がある。

これらの制限を満たす最も簡単な方法は、すべてのモジュールを同じ@option{-G}オプションでコンパイルしてリンクすることである。 ただし、いくつかの小さなデータ制限をサポートするライブラリを構築することもできる。 サポートされている最高の@option{-G}設定を使用してライブラリをコンパイルし、さらに@option{-mno-extern-sdata}を使用して、ライブラリが外部定義データに関する前提を作成するのを止めることで、これを行うことができる。

@item -mgpopt
@itemx -mno-gpopt
@opindex mgpopt
@opindex mno-gpopt
小さなデータセクションにあることが分かっているシンボルには、GP相対アクセスを使用する（しない）。 @option {-G}、@option{-mlocal-sdata}、@option{-mextern-sdata}参照。 @option {-mgpopt}はすべての構成のデフォルトである。

@option{-mno-gpopt}は、@code{$gp}レジスタが@code{_gp}の値を保持しない場合に便利である。 たとえば、コードがブートモニターで使用されるライブラリーの一部である場合、ブートモニタールーチンを呼び出すプログラムは、未知の値を@code{$gp}に渡す。（このような状況では、通常ブートモニター自体は@option{-G0}でコンパイルされる）。

@option{-mno-gpopt}は@option{-mno-local-sdata}と@option{-mno-extern-sdata}を含む。

@item -membedded-data
@itemx -mno-embedded-data
@opindex membedded-data
@opindex mno-embedded-data
可能であれば、読み取り専用データセクションに変数を割り当て、可能であれば小さなデータセクションに次に変数を割り当て、それ以外の場合はデータに割り当てる。 これは、デフォルトよりもわずかに遅いコードを提供するが、実行時に必要なRAMの量が減るため、一部の組み込みシステムでは望ましいことがある。

@item -muninit-const-in-rodata
@itemx -mno-uninit-const-in-rodata
@opindex muninit-const-in-rodata
@opindex mno-uninit-const-in-rodata
読み込み専用データセクションに初期化されていない@code{const}変数を入れる。このオプションは@option{-membedded-data}との組み合わせでのみ意味がある。

@item -mcode-readable=@var{setting}
@opindex mcode-readable
GCCが実行可能セクションから読み込むコードを生成するかどうかを指定する。可能な設定は3つある。

@table @gcctabopt
@item -mcode-readable=yes
命令は自由に実行可能セクションにアクセスできる。これはデフォルトの設定である。

@item -mcode-readable=pcrel
MIPS16 PC相対ロード命令は実行可能セクションにアクセスできるが、他の命令ではできない。 このオプションは、コードTLBに読み取り禁止ビットが設定されている場合、4KScおよび4KSdプロセッサで有効である。 また、デュアル命令/データSRAMインタフェースを持つように構成することができ、M4Kと同様に、PC相対ロードを自動的に命令RAMにリダイレクトするプロセッサでも便利である。

@item -mcode-readable=no
命令は実行可能セクションにアクセスしてはならない。 このオプションは、デュアル命令/データSRAMインタフェースを持つように構成されているターゲットで有効だが、M4Kとは異なり、PC相対ロードを自動的に命令RAMにリダイレクトしない。
@end table

@item -msplit-addresses
@itemx -mno-split-addresses
@opindex msplit-addresses
@opindex mno-split-addresses
@code{%hi()}および@code{%lo()}アセンブラ再配置演算子の使用を有効（無効）化する。 このオプションは@option{-mexplicit-relocs}に取って代わられたが、下位互換性のために残されている。

@item -mexplicit-relocs
@itemx -mno-explicit-relocs
@opindex mexplicit-relocs
@opindex mno-explicit-relocs
シンボリックアドレスを扱う場合は、アセンブラ再配置演算子を使用する（しない）。 @option{-mno-explicit-relocs}で選択された代替は、代わりにアセンブラマクロを使用することである。

再配置オペレータをサポートするアセンブラを使用するようにGCCを設定した場合、@option{-mexplicit-relocs}がデフォルトである。

@item -mcheck-zero-division
@itemx -mno-check-zero-division
@opindex mcheck-zero-division
@opindex mno-check-zero-division
ゼロによる整数除算をトラップする（しない）。

デフォルトは@option{-mcheck-zero-division}である。

@item -mdivide-traps
@itemx -mdivide-breaks
@opindex mdivide-traps
@opindex mdivide-breaks
MIPSシステムは、条件付きトラップまたはブレーク命令のいずれかを生成することによってゼロ除算をチェックする。 トラップを使用すると、コードが小さくなるが、MIPS II以降でのみサポートされている。 また、Linuxカーネルのバージョンによっては、トラップが適切なシグナル（@code{SIGFPE}）を生成できないバグがある。 @option{-mdivide-traps}を使用すると、それらをサポートするアーキテクチャの条件付きトラップを許可し、@option{-mdivide-breaks}は強制的にブレークを使用できる。

デフォルトは通常@option{-mdivide-traps}だが、構成時に@option{-with-divide=breaks}を使用して上書きすることができる。
ゼロ除算は、@option{-mno-check-zero-division}を使用して完全に無効にすることができる。

@item -mload-store-pairs
@itemx -mno-load-store-pairs
@opindex mload-store-pairs
@opindex mno-load-store-pairs
ロード/ストア結合を有効にするために連続したロード命令またはストア命令をペアにする最適化を有効（無効）化する。 このオプションはデフォルトで有効になっているが、選択したアーキテクチャがボンディングをサポートすることがわかっている場合にのみ効果がある。

@item -mmemcpy
@itemx -mno-memcpy
@opindex mmemcpy
@opindex mno-memcpy
@code{memcpy}の使用が非自明なブロック移動になるよう強制する（しない）。 デフォルトは@option{-mno-memcpy}で、これはGCCがほとんど一定のサイズのコピーをインライン化することを可能にする。

@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
@code{jal}命令の使用を無効にする（しない）。 @code{jal}を使って関数を呼び出すほうが効率的だが、呼び出し元と呼び出し先が同じ256メガバイトのセグメントに存在する必要がある。

このオプションはabicallsコードには影響しない。 デフォルトは@option{-mno-long-calls}である。

@item -mmad
@itemx -mno-mad
@opindex mmad
@opindex mno-mad
R4650 ISAによって提供されている@code{mad}, @code{madu}, @code{mul}の使用を有効（無効）化する。

@item -mimadd
@itemx -mno-imadd
@opindex mimadd
@opindex mno-imadd
@code{madd}と@code{msub}整数命令の使用を有効（無効）化する。デフォルトは@code{madd}と@code{msub}をサポートするアーキテクチャでは@code{-mimadd}だが、例外は74kアーキテクチャで、そこではより遅いコードを生成することがわかっている。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
利用可能な場所では、浮動小数点乗加算命令の使用を有効（無効）化する。デフォルトでは@option{-mfused-madd}。

乗算累算命令が使用されている場合のR8000 CPUでは、中間積は無限精度に計算され、FCSRゼロからゼロへのビットの影響を受けない。 これは、場合によっては望ましくないことがある。 他のプロセッサでは、結果は、別々の乗算、加算、減算、および否定命令を使用した同等の計算と数値的に同じである。

@item -nocpp
@opindex nocpp
MIPSアセンブラにアセンブラを実行する前に、ユーザ・アセンブラ・ファイル（@samp{.s}接尾辞付き）に対してプリプロセッサを実行しないように指示する。

@item -mfix-24k
@itemx -mno-fix-24k
@opindex mfix-24k
@opindex mno-fix-24k
24K E48（リフィル中のストアでのデータ喪失）エラッタを回避する。回避策はGCCではなくアセンブラで実装されている。

@item -mfix-r4000
@itemx -mno-fix-r4000
@opindex mfix-r4000
@opindex mno-fix-r4000
いくつかのR4000 CPUでのエラッタを回避する。
@itemize @minus
@item
整数除算を開始した直後にダブルワードまたは可変シフトを実行すると、不正な結果が返されることがある。
@item
整数乗算が実行されている間にダブルワードまたは可変シフトが実行されると、不正な結果が返されることがある。
@item
分岐の分岐やジャンプの遅延スロットで開始された場合、整数除算で不正な結果が得られることがある。
@end itemize

@item -mfix-r4400
@itemx -mno-fix-r4400
@opindex mfix-r4400
@opindex mno-fix-r4400
いくつかのR4400 CPUでのエラッタを回避する。
@itemize @minus
@item
整数除算を開始した直後にダブルワードまたは可変シフトを実行すると、不正な結果が返されることがある。
@end itemize

@item -mfix-r10000
@itemx -mno-fix-r10000
@opindex mfix-r10000
@opindex mno-fix-r10000
いくつかのR10000 CPUでのエラッタを回避する。
@itemize @minus
@item
@code{ll}/@code{sc}シーケンスは、3.0より前のリビジョンではアトミックに動作しない。 2.6以前のリビジョンではデッドロックする可能性がある。
@end itemize

このオプションは、ターゲットアーキテクチャが分岐予測命令をサポートしている場合にのみ使用できる。 @option{-march=r10000}を使用すると、@option{-mfix-r10000}がデフォルトである。 そうでない場合、@option{-mno-fix-r10000}がデフォルトである。

@item -mfix-r5900
@itemx -mno-fix-r5900
@opindex mfix-r5900
6命令以下の短いループの最後に配置された分岐命令の遅延スロットに先行する命令をスケジュールしようとしないでください。代わりに、常に@code{nop}命令をスケジュールしてください。 R5900チップのハードウェアのバグが原因で、特定の条件下での短いループのバグにより、ループが1回または2回だけ実行されます。 回避策は、GCC @ではなくアセンブラによって実装されます。

@item -mfix-rm7000
@itemx -mno-fix-rm7000
@opindex mfix-rm7000
RM7000 @code{dmult}/@code{dmultu}エラッタを回避する。 回避策はGCCではなくアセンブラで実装されている。

@item -mfix-vr4120
@itemx -mno-fix-vr4120
@opindex mfix-vr4120
特定のVR4120エラッタを回避する：
@itemize @minus
@item
@code{dmultu}は必ずしも正しい結果を出すとは限らない。
@item
オペランドの1つが負の場合、@code{div}と@code{ddiv}は常に正しい結果を生成するとは限らない。
@end itemize
除算のエラッタの回避策は@file{libgcc.a}の特別な機能に依存している。 現在のところ、これらの関数は@code{mips64vr*-elf}の構成によってのみ提供される。

他のVR4120のエラッタでは、特定の命令ペアの間にNOPを挿入する必要がある。これらのエラッタはGCC自身ではなく、アセンブラで処理される。

@item -mfix-vr4130
@opindex mfix-vr4130
VR4130 @code{mflo}/@code{mfhi}エラッタを回避する。 回避策は、GCCではなくアセンブラで実装されているが、代わりにVR4130 @code{macc}、@code{macchi}、@code{dmacc}、@code{dmacchi}命令が利用可能な場合には、GCCは@code{mflo}と@code{mfhi}の使用を避ける。

@item -mfix-sb1
@itemx -mno-fix-sb1
@opindex mfix-sb1
特定のSB-1 CPUコアエラッタを回避する。（このフラグは現在、SB-1リビジョン2の 「F1」と 「F2」の浮動小数点エラッタで動作する）。

@item -mr10k-cache-barrier=@var{setting}
@opindex mr10k-cache-barrier
R10Kプロセッサで投機の副作用を避けるために、GCCがキャッシュバリアを挿入するかどうかを指定する。

多くのプロセッサーと共通して、R10Kは条件付き分岐の結果を予測し、 「取られた」分岐からの命令を投機的に実行しようとする。予測結果が間違っている場合は、後でこれらの命令を中止する。しかし、R10Kでは、中断された命令でさえも副作用が生じる可能性がある。

この問題はカーネルストアにのみ影響し、システムに応じてカーネルがロードされる。 一例として、投機的に実行されるストアは、ターゲットメモリをキャッシュにロードし、ストア自体が後で中断されたとしても、キャッシュラインを汚れたとマークし得る。 「汚れた」行がフラッシュされる前にDMA操作が同じメモリー領域に書き込むと、キャッシュされたデータはDMAされたデータを上書きする。 その他の潜在的な問題も含め、詳細な説明はR10Kプロセッサのマニュアルを参照せよ。

回避策の1つは、投機的に実行され、中止されても副作用を持つかもしれないメモリアクセスの前にキャッシュバリア命令を挿入することである。 @option{-mr10k-cache-barrier=@var{setting}}は、この回避策のGCC実装を制御する。次の領域のバイトへの中止されたアクセスには副作用がないものとする。

@enumerate
@item
現在の関数のスタックフレームが占めるメモリ。

@item
入ってくるスタック引数が占めるメモリ。

@item
リンク時定数アドレスのあるオブジェクトが占めるメモリ。
@end enumerate

これらの領域への投機的なアクセスが実際に安全であることを保証するのは、カーネルの責任である。

入力プログラムに次のような関数宣言が含まれているとする。

@smallexample
void foo (void);
@end smallexample

そのとき@code{foo}の実装は@code{j foo}と@code{jal foo}が投機的に実行されるようにする必要がある。 GCCはコンパイルする関数に対してこの制限を認めている。 GCC以外の関数（手書きのアセンブリコードなど）も同じことを期待する。

オプションは3形式ある。

@table @gcctabopt
@item -mr10k-cache-barrier=load-store
投機的に実行され、中止されても副作用を伴うかもしれないロードまたはストアの前にキャッシュ・バリアーを挿入する。

@item -mr10k-cache-barrier=store
投機的に実行され、中止されても副作用を伴うかもしれないストアの前にキャッシュ・バリアーを挿入する。

@item -mr10k-cache-barrier=none
キャッシュバリアの挿入を無効にする。 これがデフォルト設定である。
@end table

@item -mflush-func=@var{func}
@itemx -mno-flush-func
@opindex mflush-func
IおよびDキャッシュをフラッシュするために呼ぶ関数を指定するか、またはそのような関数を呼び出さないように指定する。 呼び出された場合、関数は共通の@code{_flush_func}と同じ引数、つまりキャッシュがフラッシュされるメモリ範囲のアドレス、メモリ範囲のサイズ、 両方のキャッシュ）。 デフォルトはターゲットGCCが設定されているかどうかによって異なるが、通常は@code{_flush_func}または@code{__cpu_flush}である。

@item mbranch-cost=@var{num}
@opindex mbranch-cost
おおまかに@var{num}の「単純な」命令にブランチのコストを設定する。このコストはヒューリスティックであり、リリース間で一貫した結果を保証するものではない。 ゼロコストは、@option {-mtune}設定に基づくデフォルトを重複して選択する。

@item -mbranch-likely
@itemx -mno-branch-likely
@opindex mbranch-likely
@opindex mno-branch-likely
選択したアーキテクチャのデフォルトにかかわらず、分岐可能命令の使用を有効または無効にする。 デフォルトでは、選択されたアーキテクチャでサポートされている場合、分岐可能命令が生成されることがある。これらのアーキテクチャを実装するMIPS32およびMIPS64アーキテクチャとプロセッサは例外である。 MIPS32およびMIPS64アーキテクチャは特にその使用を非推奨にするため、分岐可能命令はデフォルトで生成されない

@item -mcompact-branches=never
@itemx -mcompact-branches=optimal
@itemx -mcompact-branches=always
@opindex mcompact-branches=never
@opindex mcompact-branches=optimal
@opindex mcompact-branches=always
これらのオプションは、生成される分岐の形式を制御する。 デフォルトは@option{-mcompact-branches=optimal}である。

@option{-mcompact-branches=never}オプションはコンパクトブランチ命令が生成されることがないことを保証する。
@option{-mcompact-branches=always}オプションを指定すると、使用可能なコンパクトブランチ命令が生成される。 コンパクト分岐命令が利用可能でない場合、代わりに分岐の遅延スロット形式が使用される。

このオプションは、MIPSリリース6以降でサポートされている。

@option{-mcompact-branches=optimal}オプションを指定すると、現在のISAで利用可能な遅延スロットがあれば、遅延スロットブランチが使用され、遅延スロットは正常に埋められる。 遅延スロットが満たされていない場合、使用可能なコンパクトブランチが選択される。

@item -mfp-exceptions
@itemx -mno-fp-exceptions
@opindex mfp-exceptions
FP例外を有効にするかどうかを指定する。 これは、FP命令がいくつかのプロセッサーにスケジュールされる方法に影響する。 デフォルトでは、FP例外が有効になっている。

たとえば、SB-1では、FP例外を無効にして64ビットコードを発行している場合は、両方のFPパイプを使用できる。 それ以外の場合は、FPパイプは1つしか使用できない。

@item -mvr4130-align
@itemx -mno-vr4130-align
@opindex mvr4130-align
VR4130パイプラインは2ウェイスーパスカラだが、最初のパイプラインが8バイトアライメントの場合は、2つの命令のみを発行できる。  このオプションを有効にすると、GCCは並列に実行する必要があると考えられる命令のペアを整列させる。

このオプションは、VR4130を最適化する場合にのみ有効である。通常はコードを高速化するが、コードの大きさは犠牲になる。デフォルトでは、最適化レベルの@option{-O3}で有効になる。

@item -msynci
@itemx -mno-synci
@opindex msynci
サポートするアーキテクチャで@code{synci}命令の生成を有効（無効）にする。 @code{__builtin___clear_cache}をコンパイルすると、@code{synci}命令（使用可能な場合）が生成される。

このオプションのデフォルトは@option{-mno-synci}だが、デフォルトはGCCを@option{-with-synci}で構成することで上書きすることができる。

シングルプロセッサシステム用のコードをコンパイルするときは、一般的に@code{synci}を使用しても安全である。 ただし、多くのマルチコア（SMP）システムでは、すべてのコアの命令キャッシュを無効にすることはなく、未定義の動作につながる可能性がある。

@item -mrelax-pic-calls
@itemx -mno-relax-pic-calls
@opindex mrelax-pic-calls
通常は@code{$25}のレジスタを使って直接呼び出されるPICコールをダイレクトコールにするようにする。 リンカがリンク時に宛先を解決でき、宛先が直接呼び出しの範囲内にある場合にのみ可能である。

GCCが@code{.reloc}アセンブリディレクティブをサポートし、@option{-mexplicit-relocs}が有効であるアセンブラとリンカを使用するように設定されている場合、@option{-mrelax-pic-calls}がデフォルトである。@option{-mno-explicit-relocs}を使用すると、コンパイラの助けを借りずにアセンブラとリンカだけでこの最適化を実行できる。

@item -mmcount-ra-address
@itemx -mno-mcount-ra-address
@opindex mmcount-ra-address
@opindex mno-mcount-ra-address
@code{_mcount}が呼び出し関数の戻りアドレスを変更できるようにするコードを発行する（しない）。このオプションを有効にすると、通常の@code{_count}インターフェイスが新しい@var{ra-address}パラメータで拡張される。このパラメータは、@code{intptr_t *}タイプであり、レジスタ@code{$ 2}に渡される。 @code{_mcount}は、次の両方を実行して戻りアドレスを変更できる。
@itemize
@item
新しいアドレスを登録する@code{$31}。
@item
@var{ra-address}がNULLでない場合、新しいアドレスを@code{*@ var{ra-address}}に格納する。
@end itemize

デフォルトは@option{-mno-mcount-ra-address}である。

@item -mframe-header-opt
@itemx -mno-frame-header-opt
@opindex mframe-header-opt
o32 ABIでフレームヘッダーの最適化を有効（無効）にする。o32 ABIを使用する場合、呼び出し関数は呼び出された関数のスタックに16バイトを割り当ててレジスタの引数を書き出す。この最適化を有効にすると、フレームヘッダーが未使用であると判断できる場合、この最適化によってフレームヘッダーの割り当てが抑制される。

この最適化は、デフォルトではすべての最適化レベルでオフになっている。

@item -mlxc1-sxc1
@itemx -mno-lxc1-sxc1
@opindex mlxc1-sxc1
該当する場合は、@code{lwxc1}、@code{swxc1}、@code{ldxc1}、@code{sdxc1}命令の生成を有効（無効）にする。 デフォルトでは有効である。

@item -mmadd4
@itemx -mno-madd4
@opindex mmadd4
該当する場合、4オペランド@code{madd.s}、@code{madd.d}および関連する命令の生成を有効（無効）にする。 デフォルトでは有効である。

@end table

@node MMIX Options
@subsection MMIXオプション
@cindex MMIX Options

これらのオプションは、MMIXに対して定義されている。

@table @gcctabopt
@item -mlibfuncs
@itemx -mno-libfuncs
@opindex mlibfuncs
@opindex mno-libfuncs
サイズに関係なく、すべての値をレジスタで渡し、組み込みライブラリ関数がコンパイルされると指定する。

@item -mepsilon
@itemx -mno-epsilon
@opindex mepsilon
@opindex mno-epsilon
@code{rE}イプシロンレジスタに関して比較する浮動小数点比較命令を生成する。

@item -mabi=mmixware
@itemx -mabi=gnu
@opindex mabi=mmixware
@opindex mabi=gnu
関数のパラメータを渡し、グローバルレジスタ@code{$231}以上を使用するGNU ABIとは対照的に（呼び出された関数内の）値をレジスタ@code{$0}以上で返すコードを生成する。

@item -mzero-extend
@itemx -mno-zero-extend
@opindex mzero-extend
@opindex mno-zero-extend
64ビットより短いサイズのメモリからデータを読み込むときは、符号拡張するのではなく、ゼロ拡張のロード命令をデフォルトで使用するい（しない）。

@item -mknuthdiv
@itemx -mno-knuthdiv
@opindex mknuthdiv
@opindex mno-knuthdiv
残余を生じる除算の結果を除数と同じ符号にする。 デフォルトの@option{-mno-knuthdiv}では、残りの符号は被除数の符号に従う。 両方の方法は算術的に有効であり、後者はほぼ独占的に使用される。

@item -mtoplevel-symbols
@itemx -mno-toplevel-symbols
@opindex mtoplevel-symbols
@opindex mno-toplevel-symbols
アセンブラコードを@code{PREFIX}アセンブリディレクティブと一緒に使用できるように、@samp{:}をすべてのグローバルシンボルの前に追加する（しない）。

@item -melf
@opindex melf
@command{mmix}シミュレータで使用されるデフォルトの@samp{mmo}フォーマットではなく、ELFフォーマットで実行可能ファイルを生成する。

@item -mbranch-predict
@itemx -mno-branch-predict
@opindex mbranch-predict
@opindex mno-branch-predict
静的分岐予測が分岐の可能性が高いことを示す場合に、分岐可能命令を使用する（しない）。

@item -mbase-addresses
@itemx -mno-base-addresses
@opindex mbase-addresses
@opindex mno-base-addresses
@emph{ベースアドレス}を使用するコードを生成する（しない）。ベースアドレスを使用すると、定数がグローバルレジスタに設定されるための要求（アセンブラとリンカによって処理される）が自動的に生成される。レジスタは、レジスタに保持されている値から0〜255の範囲内の1つ以上のベースアドレス要求に対して使用される。一般的に短くて速いコードにつながるが、対処できるさまざまなデータ項目の数は限られている。つまり、多くの静的データを使用するプログラムでは、@option{-mno-base-addresses}が必要になる場合がある。

@item -msingle-exit
@itemx -mno-single-exit
@opindex msingle-exit
@opindex mno-single-exit
生成されたコードに各関数の単一の終了点を強制する（しない）。
@end table

@node MN10300 Options
@subsection MN10300オプション
@cindex MN10300 options

これらの@option{-m}オプションは、Matsushita MN10300アーキテクチャ用に定義されている。

@table @gcctabopt
@item -mmult-bug
@opindex mmult-bug
MN10300プロセッサの乗算命令のバグを回避するコードを生成する。 これがデフォルトである。

@item -mno-mult-bug
@opindex mno-mult-bug
MN10300プロセッサの乗算命令のバグを回避するコードを生成しない。

@item -mam33
@opindex mam33
AM33プロセッサ固有の機能を使用してコードを生成する。

@item -mno-am33
@opindex mno-am33
AM33プロセッサ固有の機能を使用してコードを生成しない。 これがデフォルトである。

@item -mam33-2
@opindex mam33-2
AM33/2.0プロセッサ固有の機能を使用してコードを生成する。

@item -mam34
@opindex mam34
AM34プロセッサ固有の機能を使用してコードを生成する。

@item -mtune=@var{cpu-type}
@opindex mtune
命令をスケジューリングするときは、指定されたCPUタイプのタイミング特性を使用する。 これは、対象のプロセッサタイプを変更しない。 CPUタイプは@samp{mn10300}、@samp{am33}、@samp{am33-2}、@samp{am34}のいずれかでなければならない。

@item -mreturn-pointer-on-d0
@opindex mreturn-pointer-on-d0
ポインタを返す関数を生成するときは、ポインタを@code{a0}と@code{d0}の両方に返す。 そうでなければ、ポインタは@code{a0}でのみ返され、プロトタイプなしでそのような関数を呼び出そうとするとエラーが発生する。 このオプションはデフォルトでオンになっている。 @option{-mno-return-pointer-on-d0}を使用して無効にする。

@item -mno-crt0
@opindex mno-crt0
Cランタイム初期化オブジェクトファイルにはリンクしない。

@item -mrelax
@opindex mrelax
分岐、呼び出し、および絶対メモリアドレスを短縮するリラクゼーション最適化パスを実行する必要があることをリンカーに示す。 このオプションは、最終リンクステップのコマンドライン使用でのみ効果がある。

このオプションはシンボリックデバッグを不可能にする。

@item -mliw
@opindex mliw
ターゲットが@samp {AM33}以上の場合、コンパイラが@emph{ロング命令ワード}命令を生成できるようにする。 これがデフォルトである。 このオプションはプリプロセッサマクロ@code{__LIW__}を定義する。

@item -mnoliw
@opindex mnoliw
コンパイラが@emph{ロング命令ワード}命令を生成することを許可しない。 このオプションはプリプロセッサマクロ@code{__NO_LIW__}を定義する。

@item -msetlb
@opindex msetlb
ターゲットが@samp{AM33}以降の場合、コンパイラが@emph{SETLB}命令と@emph{Lcc}命令を生成できるようにする。 これがデフォルトである。 このオプションはプリプロセッサマクロ@code{__SETLB__}を定義する。

@item -mnosetlb
@opindex mnosetlb
コンパイラが@emph{SETLB}命令または@emph{Lcc}命令を生成することを許可しない。 このオプションはプリプロセッサマクロ@code{__NO_SETLB__}を定義します。

@end table

@node Moxie Options
@subsection Moxieオプション
@cindex Moxie Options

@table @gcctabopt

@item -meb
@opindex meb
ビッグエンディアンコードを生成する。 これは@samp{moxie-*-*}構成のデフォルトである。

@item -mel
@opindex mel
リトルコードを生成する。

@item -mmul.x
@opindex mmul.x
mul.xとumul.x命令を生成する。 これは@samp{moxiebox-*-*}構成のデフォルトである。

@item -mno-crt0
@opindex mno-crt0
Cランタイム初期化オブジェクトファイルにはリンクしない。

@end table

@node MSP430 Options
@subsection MSP430オプション
@cindex MSP430 Options

これらのオプションは、MSP430用に定義されている。

@table @gcctabopt

@item -masm-hex
@opindex masm-hex
アセンブリの出力に常に16進定数を使用するように強制する。 通常、このような定数は符号付き10進数だが、このオプションはテストスイートや審美的な目的で利用できる。

@item -mmcu=
@opindex mmcu=
対象とするMCUを選択する。これはMCU名に基づいてCプリプロセッサシンボルを作成し、大文字に変換し、@samp{__}で前後に置く。 これは、@file{msp430.h}ヘッダファイルによってMCU固有の補助ヘッダファイルを選択するために使用される。

このオプションは、使用するISAも設定する。 MCU名が430 ISAのみをサポートすることがわかっているものであれば、それが選択され、そうでなければ430X ISAが選択される。 @samp{msp430}の汎用MCU名を使用して430 ISAを選択することもできる。 同様に、一般的な@samp{msp430x} MCU名は430X ISAを選択する。

さらに、MCU固有のリンカスクリプトがリンカコマンドラインに追加される。 スクリプトの名前は、@file{.ld}が付加されたMCUの名前である。@command{gcc}コマンドラインで@option{-mmcu=xxx}を指定すると、Cプリプロセッサシンボル@code{__XXX__}が定義され、リンカは@file{xxx.ld}というスクリプトを検索する。

異なるMCUに対してサポートされているISAおよびハードウェア乗算は、GCCにハードコードされています。 ただし、外部の@samp {devices.csv}ファイルを使用して、ハードコードされたものを超えてデバイスサポートを拡張できます。

GCCは@samp {devices.csv}ファイルを特定の優先順位で次のメソッドを使用して検索します。最初のメソッドは2番目より優先され、2番目は3番目より優先されます。このオプションはアセンブラにも渡される。

@table @asis
@item @code{-I}および@code{-L} @samp{devices.csv}で指定されたインクルードパスは、インクルードパスおよびリンカーライブラリ検索パスで指定された各ディレクトリで検索されます。
@item 環境変数@samp{MSP430_GCC_INCLUDE_DIR}で指定されたパスグローバル環境変数@samp{MSP430_GCC_INCLUDE_DIR}の値を、devices.csvを含むディレクトリへのフルパスに定義すると、GCCがこのディレクトリでdevices.csvを検索します。 devices.csvが見つかった場合、このディレクトリもインクルードパスおよびリンカーライブラリパスとして登録されます。 したがって、このディレクトリのヘッダーファイルとリンカースクリプトは、コマンドラインで@code{-I}と@code{-L}を手動で指定しなくても使用できます。
@item @samp{msp430-elf@{,bare@}/include/devices}ディレクトリ
最後に、GCCはツールチェーンのルートディレクトリから@samp{msp430-elf@{,bare@}/include/devices}を調べます。 このディレクトリはデフォルトのインストールには存在しませんが、ユーザーがそれを作成してそこに@samp{devices.csv}をコピーした場合、MCUデータが読み取られます。 上記のように、このディレクトリはインクルードパスおよびリンカーライブラリパスとしても登録されます。

@end table
上記の検索方法で@samp{devices.csv}が見つからない場合は、ハードコードされたMCUデータが使用されます。

@item -mwarn-mcu
@itemx -mno-warn-mcu
@opindex mwarn-mcu
@opindex mno-warn-mcu
このオプションは、@option{-mmcu}オプションで指定したMCU名と@option{-mcpu}オプションで設定したISA間の競合や、@option{-mhwmult}オプションで設定したハードウェア多重サポートを無効にするかどうかの警告を有効または無効にする。 また、認識されないMCU名についての警告を切り替える。 このオプションは、デフォルトでオンになっている。

@item -mcpu=
@opindex mcpu=
使用するISAを指定する。 受け入れられる値は@samp{msp430}、@samp{msp430x}、@samp{msp430xv2}である。 このオプションは非推奨である。@option{-mmcu=}オプションを使用してISAを選択する必要がある。

@item -msim
@opindex msim
シミュレータランタイムライブラリとリンカスクリプトにリンクする。 @option{-mmcu=}オプションで選択されるスクリプトを上書きする。

@item -mlarge
@opindex mlarge
ラージモデルのアドレスを使う。（20ビットポインタ、32ビット@code{size_t}）

@item -msmall
@opindex msmall
スモールモデルのアドレスを使う。（16ビットポインタ、16ビットの@code{size_t}）

@item -mrelax
@opindex mrelax
このオプションはアセンブラとリンカに渡され、リンカは最終的なリンクまで実行できない特定の最適化を実行できるようにする。

@item mhwmult=
@opindex mhwmult=
ターゲットによってサポートされているハードウェア乗算の種類を記述する。受け入れられた値は、ハードウェア乗算がない場合は@samp{none}、初期MCUがサポートする元の16ビットのみ乗算では@samp{16bit}である。それ以降のMCUで16/32ビット乗算でサポートされる@samp{32bit}と、F5シリーズMCUで16/32ビット乗算でサポートされる@samp{f5series}がある。
@samp{auto}の値も与えられる。これは、GCCに、@option{-mmcu}オプションによって提供されるMCU名に基づいてハードウェア乗算サポートを推測するように指示する。@option{-mmcu}オプションが指定されていない場合、またはMCU名が認識されない場合、ハードウェア乗算サポートは想定されない。 @code{auto}がデフォルト設定である。

ハードウェア乗算は、通常、ライブラリルーチンを呼び出すことによって実行される。 これにより、生成されたコードの領域が節約される。 @option{-O3}以上でコンパイルすると、ハードウェア乗数がインラインで呼び出される。 これは、より大きいが速いコードになる。

ハードウェア乗算ルーチンは、終了時に以前の割り込み状態を実行して復元しながら割り込みを無効にする。 これにより、通常のコードと同様に、内部の割り込みハンドラを安全に使用することができる。

@item -minrt
@opindex minrt
静的な初期化子やコンストラクタなしで、最小限の実行時環境を使用できるようにする。 これはメモリが制約されたデバイスを対象としている。 コンパイラには、リンカとランタイムにコードフラグメントが必要であることを伝える、いくつかのオブジェクトに特殊なシンボルが含まれている。

@item -mtiny-printf
@opindex mtiny-printf
コードサイズを縮小した@code{printf}および@code{puts}ライブラリ関数を有効にします。 これらの関数の@samp{tiny}実装は再入可能ではないため、マルチスレッドアプリケーションでは注意して使用する必要があります。

ストリームのサポートが削除され、出力される文字列は常に@code{write}システムコールを介してstdoutに送信されます。 文字列は、書き込みに送信される前にバッファリングされません。

このオプションにはNewlib Nano IOが必要であるため、GCCは@samp{-enable-newlib-nano-formatted-io}で構成する必要があります。

@item -mcode-region=
@itemx -mdata-region=
@opindex mcode-region
@opindex mdata-region
これらのオプションは、@code{lower}、@code{upper}、@code{either}、または@code{section}属性のいずれも持たない関数とデータの配置場所をコンパイラに指示する。 可能な値は@code{lower}、@code{upper}、@code{either}または@code{any}である。 最初の3つは、対応する属性のように動作する。 4番目に可能な値 - @code{any} - がデフォルトである。 これは、リンカスクリプト全体と、標準セクション（@code{.text}、@code{.data}など）をメモリ領域に割り当てる方法で完全に置く。

@item -msilicon-errata=
@opindex msilicon-errata
このオプションは、指定されたシリコンエラッタの修正を有効にするためにアセンブラに要求を渡す。

@item -msilicon-errata-warn=
@opindex msilicon-errata-warn
このオプションは、シリコンエラッタを適用する必要がある場合に警告メッセージを有効にするように、アセンブラに要求を渡す。

@item -mwarn-devices-csv
@itemx -mno-warn-devices-csv
@opindex mwarn-devices-csv
@opindex mno-warn-devices-csv
@samp{devices.csv}が見つからないか、解析に問題がある場合に警告します（デフォルト：オン）。

@end table

@node NDS32 Options
@subsection NDS32オプション
@cindex NDS32 Options

これらのオプションは、NDS32実装で定義されている。

@table @gcctabopt

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンモードでコードを生成する。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンモードでコードを生成する。

@item -mreduced-regs
@opindex mreduced-regs
レジスタ割当に縮小セットレジスタを使う。

@item -mfull-regs
@opindex mfull-regs
レジスタ割当に完全セットレジスタを使う。

@item -mcmov
@opindex mcmov
条件付きムーブ命令を生成する。

@item -mno-cmov
@opindex mno-cmov
条件付きムーブ命令を生成しない。

@item -mext-perf
@opindex mperf-ext
パフォーマンス拡張命令を生成する。

@item -mno-ext-perf
@opindex mno-perf-ext
パフォーマンス拡張命令を生成しない。

@item -mext-perf2
@opindex mperf-ext
パフォーマンス拡張２命令を生成する。

@item -mno-ext-perf2
@opindex mno-perf-ext
パフォーマンス拡張２命令を生成しない。

@item -mext-string
@opindex mperf-ext
文字列拡張命令を生成する。

@item -mno-ext-string
@opindex mno-perf-ext
文字列拡張命令を生成しない。

@item -mv3push
@opindex mv3push
v3 push25/pop25命令を生成する。

@item -mno-v3push
@opindex mno-v3push
push25/pop25命令を生成しない。

@item -m16-bit
@opindex m16-bit
16ビット命令を生成する。

@item -mno-16-bit
@opindex mno-16-bit
16ビット命令を生成しない。

@item -misr-vector-size=@var{num}
@opindex misr-vector-size
割り込みベクタごとのサイズを指定する。4か16でなければならない。

@item -mcache-block-size=@var{num}
@opindex mcache-block-size
キャッシュブロックごとのサイズを指定する。4から512までの2のベキ乗でなければならない。

@item -march=@var{arch}
@opindex march
ターゲットアーキテクチャの名前を指定する。

@item -mcmodel=@var{code-model}
@opindex mcmodel
キャッシュモデルは以下の中からセットする。
@table @asis
@item @samp{small}
すべてのデータおよび読み取り専用データセグメントは、512KBのアドレス空間内になければならない。テキストセグメントは16MBのアドレス空間内になければならない。
@item @samp{medium}
データセグメントは512KB以内でなければならず、読み取り専用データセグメントは4GBアドレス空間内にある必要がある。 テキストセグメントは16MB以内でなければならない
@item @samp{large}
すべてのテキストとデータセグメントは4GBのアドレス空間内に置ける。
@end table

@item -mctor-dtor
@opindex mctor-dtor
コンストラクタ・デストラクタの機能を有効にする。

@item -mrelax
@opindex mrelax
リンカに命令を緩和するように示す。

@end table

@node Nios II Options
@subsection Nios IIオプション
@cindex Nios II options
@cindex Altera Nios II options

これらは、アルテラのNios IIプロセッサ用に定義されたオプションである。

@table @gcctabopt

@item -G @var{num}
@opindex G
@cindex smaller data references
@var{num}バイト以下のグローバルおよび静的オブジェクトを、通常のデータまたはBSSセクションではなく小データまたはBSSセクションに配置する。 @var{num}のデフォルト値は8である。

@item -mgpopt=@var{option}
@itemx -mgpopt
@itemx -mno-gpopt
@opindex mgpopt
@opindex mno-gpopt
GP相対アクセスを生成する（しない）。以下の@var{option}名が認識される。

@table @samp

@item none
GP相対アクセスを生成しない。

@item local
外部、弱い、または初期化されていない共通シンボルではない小さなデータオブジェクトに対して、GP相対アクセスを生成する。また、小さなデータセクションに明示的に配置されたオブジェクトには、@code{section}属性でGP相対アドレス指定を使用する。

@item global
@samp{local}と同様に、外部、弱い、または共通の小さなデータオブジェクトに対するGP相対アクセスも生成する。 このオプションを使用する場合は、プログラムのすべての部分（ライブラリを含む）が同じ@option{-G}設定でコンパイルされていることを確認する必要がある。

@item data
プログラム内のすべてのデータオブジェクトに対するGP相対アクセスを生成する。 このオプションを使用する場合は、プログラムのデータおよびBSSセグメント全体が64Kのメモリに収まる必要があり、適切なリンカスクリプトを使用してグローバルポインタのアドレス指定可能な範囲内に割り当てる必要がある。

@item all
関数ポインタとデータポインタのGP相対アドレスを生成する。 このオプションを使用する場合は、プログラムのテキスト、データ、およびBSSセグメント全体が64Kのメモリに収まる必要があり、適切なリンカスクリプトを使用して、グローバルポインタのアドレス指定可能な範囲内に適切なリンカスクリプトを割り当てる必要がある。

@end table

@option{-mgpopt}は@option{-mgpopt=local}と同等で、@option{-mno-gpopt}は@option{-mgpopt=none}と同じである。

位置非依存コードを生成するために@option{-fpic}または@option{-fPIC}が指定されている場合を除いて、デフォルトは@option{-mgpopt}である。Nios II ABIでは、共有ライブラリからのGP相対アクセスは許可されていない。

大規模なGOTデータセクションを含む大量の小さなデータを含むプログラムを構築する場合は、明示的に@option{-mno-gpopt}を指定する必要がある。 この場合、GP相対アドレス指定のための16ビットオフセットは、小さなデータセクション全体にアクセスするのに十分なほど大きくないことがある。

@item -mgprel-sec=@var{regexp}
@opindex mgprel-sec
このオプションは、GP相対アドレス指定を介してアクセスできる追加のセクション名を指定します。 これは、変数宣言の@code{section}属性（@pxref{Common Variable Attributes}）およびカスタムリンカースクリプトと組み合わせて使用すると最も役立ちます。 @var{regexp}はPOSIX拡張正規表現です。

このオプションは@option{-G}オプションの動作には影響しません。また、指定されたセクションは、@option{-mgpopt}によって認識される標準の@code{.sdata}および@code{.sbss}小データセクションに追加されます 

@item -mr0rel-sec=@var{regexp}
@opindex mr0rel-sec
このオプションは、@code{r0}からの16ビットのオフセットを介してアクセスできるセクションの名前を指定します。 つまり、32ビットアドレス空間の下位32Kまたは上位32Kです。 これは、変数宣言の@code{section}属性（@pxref{Common Variable Attributes}）およびカスタムリンカースクリプトと組み合わせて使用すると最も役立ちます。 @var{regexp}はPOSIX拡張正規表現です。

小さなデータにGP相対アドレッシングを使用するのとは対照的に、ゼロベースのアドレッシングはデフォルトでは生成されず、メモリの低領域または高領域のセクションの標準リンカースクリプトで使用される従来のセクション名はありません。

@item -mel
@itemx -meb
@opindex mel
@opindex meb
それぞれリトルエンディアン（デフォルト）またはビッグエンディアン（実験的）コードを生成する。

@item -march=@var{arch}
@opindex march
ターゲットNios IIアーキテクチャの名前を指定する。 GCCはこの名前を使用して、アセンブリコードを生成するときにどのような命令を発行できるかを判断する。 許可される名前は@samp{r1}、@samp{r2}である。

プリプロセッサマクロの@code{__ nios2_arch__}は、ターゲットISAレベルを示す値1または2のプログラムで使用できる。

@item -mbypass-cache
@itemx -mno-bypass-cache
@opindex mno-bypass-cache
@opindex mbypass-cache
命令のI/Oバリアントを使用して、すべてのロードおよびストア命令が常にキャッシュをバイパスするようにする。 デフォルトでは、キャッシュをバイパスしない。

@item -mno-cache-volatile 
@itemx -mcache-volatile       
@opindex mcache-volatile 
@opindex mno-cache-volatile
揮発性メモリアクセスは、ロードおよびストア命令のI / Oバリアントを使用してキャッシュをバイパスします。 デフォルトでは、キャッシュをバイパスしない。

@item -mno-fast-sw-div
@itemx -mfast-sw-div
@opindex mno-fast-sw-div
@opindex mfast-sw-div
小さい数に対してはテーブルベースの高速除算を使用する。 デフォルトでは、@option{-O3}以上の高速除算が使用される。

@item -mno-hw-mul
@itemx -mhw-mul
@itemx -mno-hw-mulx
@itemx -mhw-mulx
@itemx -mno-hw-div
@itemx -mhw-div
@opindex mno-hw-mul
@opindex mhw-mul
@opindex mno-hw-mulx
@opindex mhw-mulx
@opindex mno-hw-div
@opindex mhw-div
コンパイラが@code{mul}、@code{mulx}、@code{div}命令ファミリを有効または無効にする。 デフォルトでは、@code{mul}を発行し、@code{div}と@code{mulx}は発行しない。

@item -mbmx
@itemx -mno-bmx
@itemx -mcdx
@itemx -mno-cdx
Nios II R2 BMX（ビット操作）およびCDX（コード密度）命令の生成を有効または無効にする。 これらの命令を有効にするには、@option{-march=r2}も必要である。これらの命令はR2アーキテクチャのオプションの拡張であるため、デフォルトではそれらを発行しない。

@item -mcustom-@var{insn}=@var{N}
@itemx -mno-custom-@var{insn}
@opindex mcustom-@var{insn}
@opindex mno-custom-@var{insn}
各@option{-mcustom-@var{insn}=@var{N}}オプションは、@var{insn}を使用するコードを生成するときに@var{N}をエンコードするカスタム命令の使用を可能にする。たとえば、@option{-mcustom-fadds=253}は、ライブラリ呼び出しを使用するデフォルトの動作ではなく、単精度浮動小数点加算演算用のカスタム命令253を生成する。

@var{insn}の以下の値がサポートされている。 特に明記されていない限り、浮動小数点演算は通常のIEEE 754セマンティクスで実装され、C演算子または同等のGCC組み込み関数（@pxref {Other Builtins}）に直接対応している。

単精度浮動小数点数：
@table @asis

@item @samp{fadds}, @samp{fsubs}, @samp{fdivs}, @samp{fmuls}
二項算術命令

@item @samp{fnegs}
単項否定

@item @samp{fabss}
単項絶対値

@item @samp{fcmpeqs}, @samp{fcmpges}, @samp{fcmpgts}, @samp{fcmples}, @samp{fcmplts}, @samp{fcmpnes}
比較操作

@item @samp{fmins}, @samp{fmaxs}
浮動小数点最小・最大。これらの命令は@option{-ffinite-math-only}が指定されたときのみ生成される。

@item @samp{fsqrts}
単項平方根命令。

@item @samp{fcoss}, @samp{fsins}, @samp{ftans}, @samp{fatans}, @samp{fexps}, @samp{flogs}
浮動小数点数三角関数と指数関数。 これらの命令は、@option{-funsafe-math-optimizations}も指定されている場合にのみ生成される。

@end table

倍精度浮動小数点数：
@table @asis

@item @samp{faddd}, @samp{fsubd}, @samp{fdivd}, @samp{fmuld}
二項算術命令

@item @samp{fnegd}
単項否定

@item @samp{fabsd}
単項絶対値

@item @samp{fcmpeqd}, @samp{fcmpged}, @samp{fcmpgtd}, @samp{fcmpled}, @samp{fcmpltd}, @samp{fcmpned}
比較操作

@item @samp{fmind}, @samp{fmaxd}
倍精度最小・最大。これらの命令は@option{-ffinite-math-only}が指定されたときのみ生成される。

@item @samp{fsqrtd}
単項平方根命令。

@item @samp{fcosd}, @samp{fsind}, @samp{ftand}, @samp{fatand}, @samp{fexpd}, @samp{flogd}
倍精度三角関数と指数関数。 これらの命令は、@option{-funsafe-math-optimizations}も指定されている場合にのみ生成される。

@end table

変換：
@table @asis
@item @samp{fextsd}
単精度から倍精度への変換

@item @samp{ftruncds}
倍精度から単精度への変換
Conversion from double precision to single precision.

@item @samp{fixsi}, @samp{fixsu}, @samp{fixdi}, @samp{fixdu}
浮動小数点数から符号付き・符号なし整数への0への切り詰めによる変換。

@item @samp{round}
単精度浮動小数点数から符号付き整数への、0から遠い方向への最近接丸め。
これは@option{-fno-math-errno}が使われたときには@code{__builtin_lroundf}関数に対応する。

@item @samp{floatis}, @samp{floatus}, @samp{floatid}, @samp{floatud}
符号付きまたは符号なし整数型から浮動小数点型への変換。

@end table

さらに、倍精度浮動小数点命令のいずれかを使用するには、内部レジスタXおよびYの次の転送命令をすべて提供する必要がある。 2つの倍精度ソース・オペランドを取るカスタム命令は、64ビット・レジスタXの最初のオペランドを必要とする。他のオペランド（または単項演算のオペランドのみ）は、ソースレジスタ@var{src1}の最下位半分と@var {src2}の最上位半分を持つカスタム算術命令に与えられる。倍精度結果を返すカスタム命令は、デスティネーションレジスタの最上位32ビットと32ビットレジスタYの残りの半分を返す。倍精度浮動小数点命令が使用される場合、GCCは自動的にレジスタXおよび/またはレジスタYを書き込むために必要なコードシーケンスを生成する。

@table @asis

@item @samp{fwrx}
@var{src1}をXの最下位半分に、@var{src2}をXの最上位半分に書き出す。

@item @samp{fwry}
@var{src1}をYへと書き出す。

@item @samp{frdxhi}, @samp{frdxlo}
Xの最上位または最下位（それぞれ）を読み、それを@var{dest}に格納する。

@item @samp{frdy}
Yの値を読み@var{dest}に格納する。
@end table

@code{target("custom@var{insn}=@var{N}")}と@code{target("no-custom-@var{insn}")}関数属性（@pxref{Function Attributes}）またはプラグマ（@pxref{Function Specific Option Pragmas}）を使用してNios IIカスタム命令の生成をローカルで制御することができる。

@item -mcustom-fpu-cfg=@var{name}
@opindex mcustom-fpu-cfg

このオプションは、あらかじめ定義されたカスタム命令エンコーディングのセットを有効にする（上記の@option{-mcustom-@var{insn}}参照）。現在、以下のセットが定義されています。

@option{-mcustom-fpu-cfg=60-1}は以下と同等である。
@gccoptlist{-mcustom-fmuls=252 
-mcustom-fadds=253 
-mcustom-fsubs=254 
-fsingle-precision-constant}

@option{-mcustom-fpu-cfg=60-2}は以下と同等である。
@gccoptlist{-mcustom-fmuls=252 
-mcustom-fadds=253 
-mcustom-fsubs=254 
-mcustom-fdivs=255 
-fsingle-precision-constant}

@option{-mcustom-fpu-cfg=72-3}は以下と同等である。
@gccoptlist{-mcustom-floatus=243 
-mcustom-fixsi=244 
-mcustom-floatis=245 
-mcustom-fcmpgts=246 
-mcustom-fcmples=249 
-mcustom-fcmpeqs=250 
-mcustom-fcmpnes=251 
-mcustom-fmuls=252 
-mcustom-fadds=253 
-mcustom-fsubs=254 
-mcustom-fdivs=255 
-fsingle-precision-constant}

個別の@option{-mcustom-@var{insn}=}オプションで指定されたカスタム命令の割り当ては、コマンドラインでのオプションの順序にかかわらず、@option{-mcustom-fpu-cfg=}で指定されたものを上書きする。

@code{target("custom-fpu-cfg=@var{name}")}関数の属性（@pxref {Function Attributes}）やプラグマ（@pxref{Function Specific Option Pragmas}）を使用することで、FPU構成の選択をより詳細に制御できる。

@end table

これらの追加の@samp {-m}オプションは、アルテラのNios II ELF（ベアメタル）ターゲットで使用できます。

@table @gcctabopt

@item -mhal
@opindex mhal
HAL BSPとのリンク。 これにより、GCC提供のCランタイムスタートアップコードと終了コードとのリンクが抑制され、通常はHAL BSPによって提供される代替起動コードの場所を指定するために@option{-msys-crt0=}と組み合わせて使用される。

@item -msmallc
@opindex msmallc
Newlibではなく、Cライブラリの制限されたバージョンである@option{-lsmallc}とリンクする。

@item -msys-crt0=@var{startfile}
@opindex msys-crt0
@var{startfile}は、リンク時に使用する開始ファイル（crt0）のファイル名である。 このオプションは@option{-mhal}と組み合わせて使用すると便利である。

@item -msys-lib=@var{systemlib}
@opindex msys-lib
@var{systemlib}は、Cライブラリが必要とする低レベルのシステムコールを提供するライブラリのライブラリ名である。例えば、@code{read}と@code {write}である。このオプションは通常、HAL BSPによって提供されるライブラリとリンクするために使用される。

@end table

@node Nvidia PTX Options
@subsection Nvidia PTXオプション
@cindex Nvidia PTX options
@cindex nvptx options

これらのオプションは、Nvidia PTX用に定義されている。

@table @gcctabopt

@item -m32
@itemx -m64
@opindex m32
@opindex m64
32ビットまたは64ビットABI用のコードを生成する。

@item -misa=@var{ISA-string}
@opindex march
指定されたPTXISAのコードを生成します（例：@samp{sm_35}）。 ISA文字列は小文字である必要があります。 有効なISA文字列には、@samp{sm_30}と@samp{sm_35}が含まれます。 デフォルトのISAはsm_35です。

@item -mmainkernel
@opindex mmainkernel
__mainカーネルのコードをリンクする。 これは、オフロード実行ではなくスタンドアロン用である。

@item -moptimize
@opindex moptimize
パーティション化された実行最適化を適用する。 これは、最適化のレベルが選択されている場合のデフォルトである。

@item -msoft-stack
@opindex msoft-stack
スタック格納のために@code{.local}メモリを直接使用しないコードを生成する。 代わりに、ワープごとのスタックポインタが明示的に保持される。 これにより、可変長配列の割り当て（可変長配列または@code{alloca}）が可能になる。グローバルメモリを基になるストレージに使用すると、他のスレッドやアトミック命令から自動変数にアクセスすることができる。 このコード生成バリアントはOpenMPオフロードに使用されるが、オプションはコンパイラをテストするために単独で公開されている。 OpenMPオフロードを使用してプログラムにリンクするのに適したコードを生成するには、オプション@option{-mgomp}を使用する。

@item -muniform-simt
@opindex muniform-simt
あたかも1つのスレッドしかOpenMP SIMD領域外でアクティブであるかのようにメモリ状態と副作用を維持しながら、各ワープ内のすべてのスレッドを実行できるコード生成バリアントに切り替える。 すべてのアトミック操作とランタイム呼び出し（malloc、free、vprintf）は条件付きで実行される（現在のレーンインデックスがマスタレーンインデックスと等しい場合）。割り当てられるレジスタはマスターレーンからのシャッフル命令によってコピーされる。 SIMD領域の外側では、レーン0がマスタである。 内部では、各スレッドはマスターとして自分自身を見る。 共有メモリ配列@code{int __nvptx_uni[]}は、現在のモード（SIMD領域外の0）を示す、各ワープのすべて0またはすべて1のビットマスクを格納する。 各スレッドはビットごとに、ビットマップは@code{tid.y}にあり、現在のレーンインデックスでマスターレーンインデックスを計算できる。

@item -mgomp
@opindex mgomp
OpenMPオフロードで使用するコードを生成する：@option{-msoft-stack}と@option{-muniform-simt}オプションを有効にし、対応するmultilibバリアントを選択する。

@end table

@node OpenRISC Options
@subsection OpenRISCオプション
@cindex OpenRISC Options

これらのオプションはOpenRISC用に定義されています。

@table @gcctabopt

@item -mboard=@var{name}
@opindex mboard
ボード固有のランタイムを構成します。 これは、newlibボードライブラリリンクのリンカーに渡されます。 デフォルトは@code {or1ksim}です。

@item -mnewlib
@opindex mnewlib
このオプションは無視されます。 互換性のためだけにあります。 これは、newlibで使用するリンカおよびプリプロセッサオプションを選択するために使用されていました。

@item -msoft-div
@itemx -mhard-div
@opindex msoft-div
@opindex mhard-div
ソフトウェアまたはハードウェアの除算（@code{l.div}、@code{l.divu}）命令を選択します。 このデフォルトはハードウェア除算です。

@item -msoft-mul
@itemx -mhard-mul
@opindex msoft-mul
@opindex mhard-mul
ソフトウェアまたはハードウェアの乗算（@code{l.mul}、@code{l.muli}）命令を選択します。 このデフォルトはハードウェア乗算です。

@item -msoft-float
@itemx -mhard-float
@opindex msoft-float
@opindex mhard-float
浮動小数点演算のソフトウェアまたはハードウェアを選択します。 デフォルトはソフトウェアです。

@item -mdouble-float
@opindex mdouble-float
@option{-mhard-float}が選択されている場合、倍精度浮動小数点命令の生成を有効にします。 デフォルトでは、@file{libgcc}の関数を使用して、倍精度浮動小数点演算を実行します。

@item -munordered-float
@opindex munordered-float
@option{-mhard-float}が選択されている場合、非順序浮動小数点比較およびフラグ設定（@code{lf.sfun *}）命令の生成を有効にします。 デフォルトでは、@file{libgcc}の関数を使用して、非順序浮動小数点比較およびフラグ設定操作を実行します。

@item -mcmov
@opindex mcmov
条件付き移動（@code{l.cmov}）命令の生成を有効にします。 デフォルトでは、同等のものはセットとブランチを使用して生成されます。

@item -mror
@opindex mror
右回転（@code{l.ror}）命令の生成を有効にします。 デフォルトでは、@file{libgcc}の関数を使用して右回転操作を実行します。

@item -mrori
@opindex mrori
即時の（@code{l.rori}）命令で右回転の生成を有効にします。 デフォルトでは、@file{libgcc}の関数を使用して、即時操作で右回転を実行します。

@item -msext
@opindex msext
符号拡張（@code{l.ext*}）命令の生成を有効にします。 デフォルトでは、メモリ拡張が符号拡張を実行するために使用されます。

@item -msfimm
@opindex msfimm
比較の生成を有効にし、即時（@code{l.sf*i}）命令でフラグを設定します。 デフォルトでは、追加の命令が生成され、イミディエイトを最初にレジスタに格納します。

@item -mshftimm
@opindex mshftimm
即時（@code{l.srai}、@code{l.srli}、@code{l.slli}）命令でシフトの生成を有効にします。 デフォルトでは、追加の命令が生成され、イミディエイトを最初にレジスタに格納します。


@end table

@node PDP-11 Options
@subsection PDP-11オプション
@cindex PDP-11 Options

これらのオプションは、PDP-11用に定義されている

@table @gcctabopt
@item -mfpu
@opindex mfpu
ハードウェアFPP浮動小数点を使用します。 これがデフォルトである。（PDP-11/40上のFIS浮動小数点はサポートされていない。）-m45を含みます。

@item -msoft-float
@opindex msoft-float
ハードウェア浮動小数点を使用しない。

@item -mac0
@opindex mac0
浮動小数点の結果をac0（UNIXアセンブラの構文ではfr0）で返す。

@item -mno-ac0
@opindex mno-ac0
浮動小数点の結果をメモリに返します。 これがデフォルトである。

@item -m40
@opindex m40
PDP-11/40用コードを生成する。

@item -m45
@opindex m45
PDP-11/45用コードを生成する。 これがデフォルトである。

@item -m10
@opindex m10
PDP-11/10用コードを生成する。

@item -mint16
@itemx -mno-int32
@opindex mint16
@opindex mno-int32
16ビットの@code{int}を使う。これがデフォルトである。

@item -mint32
@itemx -mno-int16
@opindex mint32
@opindex mno-int16
32ビットの@code{int}を使う。

@item -msplit
@opindex msplit
ターゲットに分割された命令とデータスペースがあります。 -m45を含みます。

@item -munix-asm
@opindex munix-asm
Unixアセンブラ構文を使う。

@item -mdec-asm
@opindex mdec-asm
DECアセンブラ構文を使う。

@item -mgnu-asm
@opindex mgnu-asm
GNUアセンブラ構文を使用します。 これがデフォルトです。

@item -mlra
@opindex mlra
新しいLRAレジスタアロケータを使用します。 デフォルトでは、古い「リロード」アロケーターが使用されます。
@end table

@node picoChip Options
@subsection picoChipオプション
@cindex picoChip options

これらの@samp {-m}オプションは、picoChip実装用に定義されている。

@table @gcctabopt

@item -mae=@var{ae_type}
@opindex mcpu
配列要素型@var{ae_type}の命令セット、レジスタセット、および命令スケジューリングパラメータを設定する。 @var{ae_type}にサポートされる値は@samp{ANY}、@samp{MUL}、@samp{MAC}である。

@option{-mae=ANY}は、完全な汎用AEタイプを選択する。 このオプションで生成されるコードは、他のAEタイプのいずれかで実行される。 コードは、特定のAEタイプ用にコンパイルされた場合ほど効率的でなく、いくつかのタイプの操作（例えば、乗算）は、すべてのタイプのAEで適切に機能しない。

@option{-mae=MUL}はMUL AEタイプを選択する。 これは、コンパイルされたコードで最も有用なAEタイプであり、デフォルトである。

@option{-mae=MAC}はDSPスタイルのMAC AEを選択する。 このオプションでコンパイルされたコードは、バイトA/D変換がバイトロード/ストアのハードウェアサポートを提供しないため、バイト（char）操作のパフォーマンスが低下する可能性がある。

@item -msymbol-as-address
コンパイラがロード/ストア命令のアドレスとしてシンボル名を直接使用し、最初にレジスタにロードすることはないようにさせる。 通常、このオプションを使用するとより大きなプログラムが生成され、オプションを使用しない場合よりも速く実行される。 ただし、結果はプログラムによって異なるので、永続的に有効にするのではなく、ユーザーオプションとして残してある。

@item -mno-inefficient-warnings
非効率なコードの生成に関する警告を無効にする。 これらの警告は、たとえば、MAC AEタイプでバイトレベルのメモリ操作を実行するコードをコンパイルするときに生成される。 MAC AEには、バイトレベルのメモリ操作に対するハードウェアサポートがないため、すべてのバイトロード/ストアをワードロード/ストア操作から合成する必要がある。 これは非効率的であり、バイト操作を避けるためにコードを書き直す必要があることを示す警告が生成されるか、または必要なハードウェアサポートを持つAEタイプをターゲットにするよう警告が生成される。 このオプションは、これらの警告を無効にする。

@end table

@node PowerPC Options
@subsection PowerPCオプション
@cindex PowerPC options

@xref{RS/6000 and PowerPC Options}で挙げられている。

node PRU Options
@subsection PRUオプション
@cindex PRU Options

これらのコマンドラインオプションは、PRUターゲットに対して定義されます。

@table @gcctabopt
@item -minrt
@opindex minrt
静的な初期化子とコンストラクタをサポートせずに、最小限のランタイム環境とリンクします。 このオプションを使用すると、最終的なELFバイナリのサイズを大幅に削減できます。 コンパイラーは静的初期化子とコンストラクターを使用してコードを生成できることに注意してください。 ソースプログラムがこれらの機能を使用しないようにするのはプログラマの責任です。

@item -mmcu=@var{mcu}
@opindex mmcu
使用するPRU MCUバリアントを指定します。 サポートされているMCUの正確なリストについては、Newlibを確認してください。

@item -mno-relax
@opindex mno-relax
GCCが@option{--relax}オプションの代わりに@option {-no-relax}コマンドラインオプションをリンカーに渡すようにします。

@item -mloop
@opindex mloop
GCCがLOOP命令を使用することを許可します。（または許可しません）

@item -mabi=@var{variant}
@opindex mabi
コードを出力するABIバリアントを指定します。 @option{-mabi=ti}は変更されていないTI ABIを選択し、@option{-mabi=gnu}は特定のGCC仮定により自然に対応するGNUバリアントを選択します。 これらは違いです：

@table @samp
@item 関数ポインタサイズ
TI ABIは、関数（コード）ポインターが16ビットであることを指定していますが、GNUは32ビットのデータとコードポインターのみをサポートしています。

@item オプションの戻り値ポインタ
64ビットを超える関数の戻り値は、関数の最初の引数として非表示のポインターを使用して渡されます。 ただし、TI ABIは、呼び出し元が戻り値を使用していない場合に備えて、ポインターをNULLにすることを義務付けています。 GNUは常に有効な戻り値ポインタを渡し、期待します。

@end table

現在の@option{-mabi=ti}の実装では、上記のコード構造のいずれかが検出されたときにコンパイルエラーが発生します。 結果として、標準Cライブラリはビルドできず、@option{-mabi=ti}でリンクするときに省略されます。

緩和はGNUの機能であり、@option{-mabi=ti}を使用すると安全上の理由から無効になります。 TIツールチェーンはQBBx命令の再配置を発行しないため、GNUリンカーは隣接するLDI32疑似命令を短縮するときにそれらを調整できません。

@end table

@node RISC-V Options
@subsection RISC-Vオプション
@cindex RISC-V Options

これらのコマンドラインオプションは、RISC-Vターゲットに対して定義されている。

@table @gcctabopt
@item -mbranch-cost=@var{n}
@opindex mbranch-cost
分岐のコストをおおよそ@var{n}命令に設定する。

@item -mplt
@itemx -mno-plt
@opindex plt
PICコードを生成するときは、PLTを使用を許可・禁止する。非PICの場合は無視される。デフォルトは@option{-mplt}である。

@item -mabi=@var{ABI-string}
@opindex mabi
整数と浮動小数点の呼び出し規約を指定する。 @var{ABI-string}は、整数型のサイズと浮動小数点型に使用されるレジスタの2つの部分を含んでいる。 たとえば、@samp{-march=rv64ifd -mabi=lp64d}は、@samp{long}とポインタが64ビット（暗黙的に@samp{int}を32ビットと定義している）を意味し、その浮動小数点値は64ビット幅がFレジスタで渡される。 これを@samp{-march=rv64ifd -mabi=lp64f}と比較すると、それではコンパイラはFとDの拡張機能を使用するコードを生成できる、最大32ビットの浮動小数点値のみをレジスタに渡すことができる。 もしくは、@samp{-march=rv64ifd -mabi=lp64}のとき、浮動小数点引数はレジスタに渡されない。

この引数のデフォルトはシステムに依存するが、特定の呼び出し規約を使用するユーザーは明示的に指定する必要がある。 有効な呼び出し規約は、@samp{ilp32}、@samp{ilp32f}、@samp{ilp32d}、@samp{lp64}、@samp{lp64f}、@samp{lp64d}である。一部の呼び出し規約は一部のISAでは実装できない。例えば、@samp{-march=rv32if -mabi=ilp32d}は、 ABIでは64ビットの値をFレジスタに渡す必要があるが、Fレジスタは32ビット幅しかないためは無効である。

@item -mfdiv
@itemx -mno-fdiv
@opindex mfdiv
ハードウェア浮動小数点除算および平方根命令は使用するかしない。これには、浮動小数点レジスタのFまたはD拡張が必要である。 デフォルトでは、指定されたアーキテクチャにこれらの命令がある場合は、それらを使用する。

@item -mdiv
@itemx -mno-div
@opindex mdiv
整数除算にハードウェア命令を使用するかしない。これにはM拡張が必要である。 デフォルトでは、指定されたアーキテクチャにこれらの命令がある場合は、それらを使用する。
   
@item -march=@var{ISA-string}
@opindex march
与えられたRISC-V ISAのコードを生成する（@samp{rv64im}など）。 ISA文字列は小文字でなければならない。 例には、@samp{rv64i}、@samp{rv32g}、@samp{rv32imaf}がある。

@option{-march=}が指定されていない場合は、@option{-mcpu}の設定を使用してください。

@option{-march}と@option{-mcpu=}の両方が指定されていない場合、この引数のデフォルトはシステムに依存します。特定のアーキテクチャ拡張が必要なユーザーは、明示的に指定する必要があります。

@item -mcpu=@var{processor-string}
@opindex mcpu
特定のCPU名で指定された特定のプロセッサのアーキテクチャを使用し、出力を最適化します。
このオプションの許容値は、@samp{sifive-e20}、@samp{sifive-e21}、@samp{sifive-e24}、@samp{sifive-e31}、@samp{sifive-e34}、@samp{sifive-e76}、@samp{sifive-s21}、@samp{sifive-s51}、@samp{sifive-s54}、@samp{sifive-s76}、@samp{sifive-u54}、および@samp{sifive-u74}です。

@item -mtune=@var{processor-string}
@opindex mtune
マイクロアーキテクチャー名で指定された特定のプロセッサーの出力を最適化します。 このオプションの許容値は、@samp{rocket}、@samp{sifive-3-series}、@samp{sifive-5-series}、@samp{sifive-7-series}、および@samp{size}です。

@option{-mtune=}が指定されていない場合、デフォルトは@samp{rocket}です。

@samp{size}の選択は、エンドユーザーによる使用を目的としていません。 これは、@option{-Os}が指定されている場合に使用されます。 @option{-mtune=}によって提供される命令コスト情報はオーバーライドしますが、パイプライン情報はオーバーライドしません。 これにより、コードサイズを削減しながら、優れたパフォーマンスを実現できます。

@item -mpreferred-stack-boundary=@var{num}
@opindex mpreferred-stack-boundary
スタック境界を2から@var{num}バイトに引き上げた境界に揃えようとします。 @option{-mpreferred-stack-boundary}が指定されていない場合、デフォルトは4（16バイトまたは128ビット）です。

@strong{警告:} このスイッチを使用する場合は、ライブラリを含め、すべてのモジュールを同じ値でビルドする必要があります。 これには、システムライブラリとスタートアップモジュールが含まれます。

@item -msmall-data-limit=@var{n}
@opindex msmall-data-limit
@var{n}バイトよりも小さいグローバルデータと静的データを（特定のターゲット上では）特別なセクションに入れる。

@item -msave-restore
@itemx -mno-save-restore
@opindex msave-restore
ライブラリー関数呼び出しを使用するより小さいがより遅いプロローグとエピローグのコードを使用するかしない。 デフォルトでは、高速インラインプロローグとエピローグを使用する。

@item -mshorten-memrefs
@itemx -mno-shorten-memrefs
@opindex mshorten-memrefs
'base register + large offset'のロード/ストアを 'new base + small offset'の新しいロード/ストアに置き換えることにより、圧縮されたロード/ストア命令をさらに利用しようとするかしないでください。 新しいベースが圧縮レジスタに格納される場合、新しいロード/ストアを圧縮できます。 現在、32ビット整数のロード/ストアのみを対象としています。

@item -mstrict-align
@itemx -mno-strict-align
@opindex mstrict-align
アラインされていないメモリアクセスを生成しないかする。 デフォルトは、最適化しているプロセッサが高速のアラインされていないアクセスをサポートしているかどうかによって設定される。
 
@item -mcmodel=medlow
@opindex mcmodel=medlow
中低コードモデル用のコードを生成する。 プログラムとその静的に定義されたシンボルは、単一の2GiBアドレス範囲内になければならず、絶対アドレス@minus{}2 GiBと+2 GiBの間になければならない。 プログラムは静的または動的にリンクできる。 これがデフォルトコードモデルである。
 
@item -mcmodel=medany
@opindex mcmodel=medany
medium-anyコードモデル用のコードを生成する。 プログラムとその静的に定義されたシンボルは、任意の単一の2GiBアドレス範囲内になければならない。 プログラムは静的または動的にリンクできる。

@item -mexplicit-relocs
@itemx -mno-exlicit-relocs
シンボリックアドレスを扱うときは、アセンブラ再配置演算子を使用するか使用しない。 代わりにアセンブラマクロを使用することができる、最適化を制限することがある。

@item -mrelax
@itemx -mno-relax
リンカ緩和を利用して、シンボルアドレスを具体化するために必要な命令の数を減らします。 デフォルトでは、リンカーの緩和を利用します。

@item -memit-attribute
@itemx -mno-emit-attribute
ELFオブジェクトに追加情報を記録するためにRISC-V属性を放出します（放出しません）。 この機能には、少なくともbinutils 2.32が必要です。

@item -malign-data=@var{type}
@opindex malign-data
GCCが配列、構造体、または共用体型の変数と定数を整列する方法を制御します。 @var{type}でサポートされる値は、xレジスタの幅をアライメント値として使用する@samp{xlen}と、ナチュラルアライメントを使用する@samp{natural}です。 @samp{xlen}がデフォルトです。

@item -mstack-protector-guard=@var{guard}
@itemx -mstack-protector-guard-reg=@var{reg}
@itemx -mstack-protector-guard-offset=@var{offset}
@opindex mstack-protector-guard
@opindex mstack-protector-guard-reg
@opindex mstack-protector-guard-offset
@var{guard}でカナリアを使用してスタック保護コードを生成します。 サポートされている場所は、グローバルカナリアの場合は@samp{global}、TLSブロックのスレッドごとのカナリアの場合は@samp{tls}です。

後者の選択では、オプション@option{-mstack-protector-guard-reg=@var{reg}}および@option{-mstack-protector-guard-offset=@var{offset}}は、使用するレジスタをさらに指定します。 カナリアを読み取るためのベースレジスタ、およびそのベースレジスタからのオフセット。 これは完全にLinuxカーネル内で使用するためのものであるため、デフォルトのレジスタまたはオフセットはありません。
@end table

@node RL78 Options
@subsection RL78オプション
@cindex RL78 Options

@table @gcctabopt

@item -msim
@opindex msim
シミュレータ内の操作をサポートするための追加のターゲットライブラリ内のリンク。

@item -mmul=none
@itemx -mmul=g10
@itemx -mmul=g13
@itemx -mmul=g14
@itemx -mmul=rl78
@opindex mmul
使用するハードウェア乗算および除算サポートのタイプを指定する。 最も簡単なのは、乗算と除算の両方にソフトウェアを使用する@code{none}である。 これがデフォルトである。 値@code{g13}は、RL78/G13（S2コア）ターゲットで検出されたハードウェア乗除算周辺機器の値である。 値@code{g14}は、RL78/G14（S3コア）でサポートされている乗算命令と除算命令の使用を選する。 @code{rl78}は@code{g14}の別名で、@code{mg10}は@code{none}の別名である。

さらに、このオプションの設定に基づいて、Cプリプロセッサマクロが定義されている。 可能な値は、@code{__RL78_MUL_NONE__}、@code{__RL78_MUL_G13__}または@code {__RL78_MUL_G14__}である。

@item -mcpu=g10
@itemx -mcpu=g13
@itemx -mcpu=g14
@itemx -mcpu=rl78
@opindex mcpu
ターゲットにするRL78コアを指定する。デフォルトはG14コアで、S3コアまたはRL78とも呼ばれる。 G13またはS2コアは、乗算および除算命令を持たず、代わりにこれらの操作にハードウェア周辺機器を使用する。 G10またはS1コアにはレジスタバンクがないため、別の呼び出し規約が使用される

このオプションが設定されている場合は、コマンドラインの明示的な@option{-mmul=none}オプションで上書きされない限り、使用するハードウェア乗算サポートのタイプも選択される。したがって、@option{-mcpu=g13}を指定すると、G13ハードウェア乗算周辺機能を使用できる。また、@option{-mcpu=g10}を指定すると、ハードウェア乗算の使用が完全に無効になる。

コマンドラインで@option{-mcpu=g14}または@option{-mcpu=rl78}を指定すると、G4のハードウェア乗算サポートも有効になるため、RL78/G14コアはデフォルトのターゲットだが、ツールチェーンの動作は変更される。これらのオプションがコマンドラインで指定されていない場合、コードがRL78コアをターゲットにしていても、ソフトウェア乗算ルーチンが使用される。これは、ハードウェア乗算および除算サポートを持たない古いツールチェーンとの下位互換性のためである。

さらに、このオプションの設定に基づいて、Cプリプロセッサマクロが定義されている。可能な値は、@code{__RL78_G10__}、@code{__RL78_G13__}または@code{__RL78_G14__}である。

@item -mg10
@itemx -mg13
@itemx -mg14
@itemx -mrl78
@opindex mg10
@opindex mg13
@opindex mg14
@opindex mrl78
これらは対応する@option{-mcpu=}オプションの別名である。 後方互換性のために提供されている。

@item -mallregs
@opindex mallregs
コンパイラが使用可能なすべてのレジスタを使用できるようにする。 デフォルトでは、レジスタ@code{r24..r31}は割り込みハンドラで使用するために予約されている。 このオプションを有効にすると、これらのレジスタは通常の関数でも使用できる。

@item -m64bit-doubles
@itemx -m32bit-doubles
@opindex m64bit-doubles
@opindex m32bit-doubles
@code{double}データ型を64ビット（@option{-m64bit-doubles}）または32ビット（@option{-m32bit-doubles}）のサイズにする。 デフォルトは@option{-m32bit-doubles}である。

@item -msave-mduc-in-interrupts
@itemx -mno-save-mduc-in-interrupts
@opindex msave-mduc-in-interrupts
@opindex mno-save-mduc-in-interrupts
割り込みハンドラ関数がMDUCレジスタを保持する必要があることを指定する。 これは、通常のコードがMDUCレジスタを使用する場合にのみ必要である。たとえば、乗算と除算を実行するため。 デフォルトでは、MDUCレジスタは無視されるため、割り込みハンドラが高速になる。 この機能はG13ターゲット（S2コア）でのみ使用できるため、ターゲットオプション-mg13を渡す必要がある。 MDUCレジスタは、割り込みハンドラが乗算または除算演算を実行するか、または別の関数を呼び出す場合にのみ保存される。

@end table

@node RS/6000 and PowerPC Options
@subsection IBM RS/6000とPowerPCのオプション
@cindex RS/6000 and PowerPC Options
@cindex IBM RS/6000 and PowerPC Options

これらの@samp {-m}オプションは、IBM RS/6000とPowerPC用に定義されている。
@table @gcctabopt
@item -mpowerpc-gpopt
@itemx -mno-powerpc-gpopt
@itemx -mpowerpc-gfxopt
@itemx -mno-powerpc-gfxopt
@need 800
@itemx -mpowerpc64
@itemx -mno-powerpc64
@itemx -mmfcrf
@itemx -mno-mfcrf
@itemx -mpopcntb
@itemx -mno-popcntb
@itemx -mpopcntd
@itemx -mno-popcntd
@itemx -mfprnd
@itemx -mno-fprnd
@need 800
@itemx -mcmpb
@itemx -mno-cmpb
@itemx -mhard-dfp
@itemx -mno-hard-dfp
@opindex mpowerpc-gpopt
@opindex mno-powerpc-gpopt
@opindex mpowerpc-gfxopt
@opindex mno-powerpc-gfxopt
@opindex mpowerpc64
@opindex mno-powerpc64
@opindex mmfcrf
@opindex mno-mfcrf
@opindex mpopcntb
@opindex mno-popcntb
@opindex mpopcntd
@opindex mno-popcntd
@opindex mfprnd
@opindex mno-fprnd
@opindex mcmpb
@opindex mno-cmpb
@opindex mhard-dfp
@opindex mno-hard-dfp
これらのオプションを使用して、使用しているプロセッサで使用可能な命令を指定する。 これらのオプションのデフォルト値は、GCCを設定するときに決定される。 @option{-mcpu=@var{cpu_type}}を指定すると、これらのオプションの指定が上書きされる。 上記のオプションではなく、@option{-mcpu=@var{cpu_type}}オプションを使用することを推奨する。

@option{-mpowerpc-gpopt}を指定すると、GCCは、汎用目的のグループ（浮動小数点平方根を含む）でオプションのPowerPCアーキテクチャ命令を使用することができる。 @option{-mpowerpc-gfxopt}を指定すると、GCCはグラフィックスグループ内のオプションのPowerPCアーキテクチャ命令（浮動小数点選択を含む）を使用することができる。

@option{-mmfcrf}オプションを使用すると、GCCはPOWER4プロセッサーおよびPowerPC V2.01アーキテクチャーをサポートする他のプロセッサーで実装された条件レコード・フィールド命令からの移動を生成することができる。
@option{-mpopcntb}オプションを使用すると、GCCはPOWER5プロセッサーおよびPowerPC V2.02アーキテクチャーをサポートする他のプロセッサーで実装されたpopcountおよび倍精度のFP逆数推定命令を生成できる。
@option{-mpopcntd}オプションを使用すると、GCCはPOWER7プロセッサーとPowerPC V2.06アーキテクチャーをサポートする他のプロセッサーで実装されたpopcount命令を生成することができる。
@option{-mfprnd}オプションを使用すると、GCCはPOWER5+プロセッサとPowerPC V2.03アーキテクチャをサポートする他のプロセッサで実装されたFP命令の整数命令を生成することができる。
@option{-mcmpb}オプションを使用すると、GCCはPower6プロセッサーとPowerPC V2.05アーキテクチャーをサポートする他のプロセッサーで実装された比較バイト命令を生成することができる。
@option{-mhard-dfp}オプションを使用すると、GCCは一部のPOWERプロセッサで実装された10進浮動小数点命令を生成できる。

@option{-mpowerpc64}オプションを使用すると、GCCは完全なPowerPC64アーキテクチャにある追加の64ビット命令を生成し、GPRを64ビットのダブルワード数として扱うことができる。 GCCのデフォルトは@option{-mno-powerpc64}である。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var{cpu_type}のアーキテクチャタイプ、レジスタ使用法、および命令スケジューリングパラメータを設定する。@var{cpu_type}のサポートされている値は@samp{401}, @samp{403},
@samp{405}, @samp{405fp}, @samp{440}, @samp{440fp}, @samp{464}, @samp{464fp},
@samp{476}, @samp{476fp}, @samp{505}, @samp{601}, @samp{602}, @samp{603},
@samp{603e}, @samp{604}, @samp{604e}, @samp{620}, @samp{630}, @samp{740},
@samp{7400}, @samp{7450}, @samp{750}, @samp{801}, @samp{821}, @samp{823},
@samp{860}, @samp{970}, @samp{8540}, @samp{a2}, @samp{e300c2},
@samp{e300c3}, @samp{e500mc}, @samp{e500mc64}, @samp{e5500},
@samp{e6500}, @samp{ec603e}, @samp{G3}, @samp{G4}, @samp{G5},
@samp{titan}, @samp{power3}, @samp{power4}, @samp{power5}, @samp{power5+},
@samp{power6}, @samp{power6x}, @samp{power7}, @samp{power8},
@samp{power9}, @samp{future}, @samp{powerpc}, @samp{powerpc64}, 
@samp{powerpc64le}, @samp{rs64}, @samp{native}である。

@option{-mcpu=powerpc}, @option{-mcpu=powerpc64}, @option{-mcpu=powerpc64le}は純粋な32ビットPowerPC（エンディアン）、64ビットビッグエンディアンPowerPCおよび64ビットリトルエンディアンPowerPCアーキテクチャの機種を指定し、適切な汎用プロセッサモデルをスケジューリングの目的で使用する。 

cpuタイプとして@samp{native}を指定すると、コンパイルを実行するシステムのホストプロセッサに対応するアーキテクチャオプションが検出され、選択される。 GCCがプロセッサを認識しない場合、@option{-mcpu=native}は効果がない。

他のオプションは、特定のプロセッサを指定する。 これらのオプションで生成されたコードは、そのプロセッサ上で最適に実行され、他のプロセッサ上ではまったく動作しない可能性がある。

@option{-mcpu}オプションは、自動的に次のオプションを有効または無効にする。

@gccoptlist{-maltivec  -mfprnd  -mhard-float  -mmfcrf  -mmultiple 
-mpopcntb  -mpopcntd  -mpowerpc64 
-mpowerpc-gpopt  -mpowerpc-gfxopt 
-mmulhw  -mdlmzb  -mmfpgpr  -mvsx 
-mcrypto  -mhtm  -mpower8-fusion  -mpower8-vector 
-mquad-memory  -mquad-memory-atomic  -mfloat128 
-mfloat128-hardware -mprefixed -mpcrel -mmma}

特定のCPUに設定される特定のオプションは、そのCPUに最適なコードを生成するような設定に応じて、コンパイラのバージョンによって異なる。 実際のハードウェアの機能を必ずしも反映しているとは限らない。 個々のオプションを特定の値に設定したい場合は、@option{-mcpu=970 -mno-altivec}のように@option{-mcpu}オプションの後に指定することができる。

AIXでは、@option{-maltivec}および@option{-mpowerpc64}オプションは、AIXがこれらのオプションを完全にサポートしていないため、現在のところ@option{-mcpu}オプションによって使用可能または使用不可にされていない。 あなたの環境で動作することが確実であれば、それらを個別に有効または無効にすることができる。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var{cpu_type}の命令スケジューリングパラメータを設定するが、@option{-mcpu=@var{cpu_type}}のようにアーキテクチャタイプやレジスタの使用方法は設定しない。 @option{-mcpu}と同じ@var{cpu_type}の値が@option{-mtune}に使用される。 どちらも指定されていれば、@option{-mcpu}で設定されたアーキテクチャとレジスタが使用されるが、@option{-mtune}で設定されたスケジューリングパラメータが使用される。

@item -mcmodel=small
@opindex mcmodel=small
小さなモデル用のPowerPC64コードを生成する：TOCは64kに制限されている。

@item -mcmodel=medium
@opindex mcmodel=medium
中間モデル用のPowerPC64コードを生成する：TOCとその他の静的データは合計で4Gまでである。 これは64ビットLinuxのデフォルトです。

@item -mcmodel=large
@opindex mcmodel=large
大型モデルのPowerPC64コードを生成する：TOCのサイズは最大4Gである。 他のデータとコードは、64ビットのアドレス空間によってのみ制限される。

@item -maltivec
@itemx -mno-altivec
@opindex maltivec
@opindex mno-altivec
AltiVec命令を使用する（使用しない）コードを生成し、AltiVec命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にする。 現在のABIをAltiVec ABI拡張で調整するには、@option{-mabi=altivec}を設定する必要がある。

@option{-maltivec}を使用すると、@code{vec_splat}や@code{vec_extract}などのAltiVec組み込み関数の要素の順序は、 および@code{vec_insert}は、ターゲットのエンディアンに対応する配列要素の順序に一致する。 つまり、要素ゼロは、ビッグエンディアンプラットフォームをターゲットにするときにベクトルレジスタの最も左の要素を識別し、リトルエンディアンプラットフォームをターゲットにするときにベクトルレジスタの最も右の要素を識別する。

@item -mvrsave
@itemx -mno-vrsave
@opindex mvrsave
@opindex mno-vrsave
AltiVecコードを生成するときにVRSAVE命令を生成する。

@item -msecure-plt
@opindex msecure-plt
@command{ld}と@command{ld.so}が実行不可能な@code{.plt}セクションと@code{.got}セクションで実行可能ファイルと共有ライブラリをビルドできるようなコードを生成する。 これはPowerPC 32ビットSYSV ABIオプションである。

@item -mbss-plt
@opindex mbss-plt
@command{ld.so}が書き込むBSS@code {.plt}セクションを使用するコードを生成し、書き込み可能で実行可能な@code{.plt}セクションと@code{.got}セクションを要求する。 これはPowerPC 32ビットSYSV ABIオプションである。

@item -misel
@itemx -mno-isel
@opindex misel
@opindex mno-isel
このスイッチは、ISEL命令の生成を有効または無効にする。

@item -mvsx
@itemx -mno-vsx
@opindex mvsx
@opindex mno-vsx
ベクトル/スカラー（VSX）命令を使用する（しない）コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にする。

@item -mcrypto
@itemx -mno-crypto
@opindex mcrypto
@opindex mno-crypto
PowerPC ISAのバージョン2.07で追加された暗号化命令に直接アクセスできる組み込み関数の使用を有効（無効）にする。

@item -mhtm
@itemx -mno-htm
@opindex mhtm
@opindex mno-htm
PowerPC ISAのバージョン2.07で追加されたハードウェアトランザクションメモリ（HTM）命令に直接アクセスできる組み込み関数の使用を有効（無効）にする。

@item -mpower8-fusion
@itemx -mno-power8-fusion
@opindex mpower8-fusion
@opindex mno-power8-fusion
Power8以降のプロセッサで命令を融合させるために、整数演算を隣接して保持するコードを生成する。

@item -mpower8-vector
@itemx -mno-power8-vector
@opindex mpower8-vector
@opindex mno-power8-vector
PowerPC ISAのバージョン2.07で追加されたベクトルおよびスカラー命令を使用する（しない）コードを生成する。 また、ベクトル命令へのより直接的なアクセスを可能にする組み込み関数の使用を可能にする。

@item -mquad-memory
@itemx -mno-quad-memory
@opindex mquad-memory
@opindex mno-quad-memory
非アトミック・クワッドワードメモリ命令を使用する（しない）コードを生成する。 @option{-mquad-memory}オプションを使用するには、64ビットモードを使用する必要がある。

@item -mquad-memory-atomic
@itemx -mno-quad-memory-atomic
@opindex mquad-memory-atomic
@opindex mno-quad-memory-atomic
アトミッククワッドワードメモリ命令を使用する（しない）コードを生成する。 @option{-mquad-memory-atomic}オプションを使用するには、64ビットモードを使用する必要がある。

@item -mfloat128
@itemx -mno-float128
@opindex mfloat128
@opindex mno-float128
ソフトウェアエミュレーションまたはハードウェア命令を使用したIEEE 128ビット浮動小数点の@var{__float128}キーワードを有効/無効にする。

IEEE 128ビット浮動小数点サポートを使用するには、VSX命令セット（@option{-mvsx}、@option{-mcpu=power7}、@option{-mcpu=power8}）または@option{-mcpu=power9}を有効にする必要がある。IEEE 128ビット浮動小数点サポートは、PowerPC Linuxシステムでのみ動作する。
 
@option{-mfloat128}のデフォルトは、VSX命令セットを使用するPowerPC Linuxシステムで有効になり、他のシステムでは無効になる。
 
64ビットシステムでISA 3.0命令セット（@option{-mpower9-vector}または@option{-mcpu=power9}）を使用すると、IEEE 128ビット浮動小数点サポートによってISA 3.0 IEEE 128ビット浮動小数点命令の生成も有効になる。 それ以外の場合、ISA 3.0命令の生成を指定していない場合、または32ビットビッグエンディアンシステムをターゲットにしている場合は、IEEE 128ビット浮動小数点がソフトウェアエミュレーションで行われる。

@item -mfloat128-hardware
@itemx -mno-float128-hardware
@opindex mfloat128-hardware
@opindex mno-float128-hardware
@var{__float128}データ型をサポートするためにISA 3.0ハードウェア命令を有効/無効にする。

@option {-mfloat128-hardware}のデフォルトは、ISA 3.0命令セットを使用するPowerPC Linuxシステムで有効になり、他のシステムでは無効になる。

@item -m32
@itemx -m64
@opindex m32
@opindex m64
DarwinおよびSVR4ターゲット（GNU/Linuxを含む）の32ビットまたは64ビット環境用のコードを生成する。 32ビット環境は、int、long、および32ビットへのポインタを設定し、任意のPowerPCバリアントで実行されるコードを生成する。 64ビット環境では、intを32ビット、longとポインタを64ビットに設定し、PowerPC64用のコードを@option{-mpowerpc64}と同様に生成する。

@item -mfull-toc
@itemx -mno-fp-in-toc
@itemx -mno-sum-in-toc
@itemx -mminimal-toc
@opindex mfull-toc
@opindex mno-fp-in-toc
@opindex mno-sum-in-toc
@opindex mminimal-toc
実行可能ファイルごとに作成されるTOC（目次）の生成を変更する。 @option{-mfull-toc}オプションはデフォルトで選択されている。その場合、GCCはプログラム内の一意の非自動変数参照ごとに少なくとも1つのTOCエントリを割り当てる。 GCCは浮動小数点定数もTOCに配置する。ただし、TOCでは16,384エントリしか利用できない。


使用可能なTOC領域がオーバーフローしたというリンカーエラーメッセージが表示された場合は、@option{-mno-fp-in-toc}および@option{-mno-sum-in}で使用されるTOC領域の量を減らすことができる。@option{-mno-fp-in-toc}は、GCCが浮動小数点定数をTOCに入れないようにし、@option{-mno-sum-in-toc}はGCCにアドレスと その合計をTOCに入れるのではなく、実行時に定数を返す。これらのオプションの1つまたは両方を指定することができる。それぞれは、TOCのスペースを節約する代わりに、GCCに非常にわずかに遅く大きなコードを生成させる。

これらのオプションの両方を指定してもTOCのスペースが足りなくなった場合は、代わりに@option{-mminimal-toc}を指定する。 このオプションを指定すると、GCCはすべてのファイルに対してTOCエントリを1つだけ作成する。 このオプションを指定すると、GCCはコードの生成速度が遅くなるが、TOCの容量はごくわずかになる。 このオプションは、実行頻度の低いコードを含むファイルに対してのみ使用したいかもしれない。

@item -maix64
@itemx -maix32
@opindex maix64
@opindex maix32
64ビットのAIX ABIおよび呼び出し規約：64ビット・ポインタ、64ビットの@code{long}タイプ、およびそれらをサポートするために必要なインフラストラクチャを有効にする。@option{-maix64}は@option{-mpowerpc64}を含み、@option{-maix32}は64ビットABIを無効にし、@option{-mno-powerpc64}を含む。 GCCのデフォルトは@option{-maix32}である。

@item -mxl-compat
@itemx -mno-xl-compat
@opindex mxl-compat
@opindex mno-xl-compat
AIX互換のABIを使用している場合、IBM XLコンパイラのセマンティクスに準拠したコードを生成する。引数FPRに加えて、スタック上のレジスタ退避領域（RSA）を超えてプロトタイプ関数に浮動小数点引数を渡す。値を比較してdoubleに変換するとき、128ビットlong double値の最も重要なdoubleが適切に丸められていると仮定しない。long doubleサポート・ルーチンにはXLシンボル名を使用する。

AIXの呼び出し規約は拡張されたが、宣言された引数よりも引数が少ない引数のアドレスを取る関数を呼び出すK＆R Cの不明確なケースを処理するために、最初は文書化されていなかった。IBM XLコンパイラは、サブルーチンが最適化されずにコンパイルされたときにスタックからRSAに収まらない浮動小数点引数にアクセスする。スタックに常に浮動小数点引数を格納するのは非効率的で、めったに必要ないので、このオプションはデフォルトでは有効になっていなく、最適化せずにIBM XLコンパイラでコンパイルされたサブルーチンを呼び出すときにのみ必要である。

@item -mpe
@opindex mpe
@dfn{IBM RS/6000 SP} @dfn{Parallel Environment}（PE）をサポートする。 特別なスタートアップコードでメッセージパッシングを使用するように記述されたアプリケーションをリンクして、アプリケーションを実行できるようにする。 システムはPEを標準の場所（@file{/usr/lpp/ppe.poe/}）にインストールする必要がある。また、適切なディレクトリの場所を指定するために@file{specs}ファイルを@option{-specs=}オプションで上書きする必要がある。 パラレル環境はスレッドをサポートしないため、@option{-mpe}オプションと@option{-pthread}オプションは互換性がない。

@item -malign-natural
@itemx -malign-power
@opindex malign-natural
@opindex malign-power
AIX、32ビットDarwin、および64ビットPowerPC GNU/Linuxの場合、オプション@option{-malign-natural}は浮動小数点倍精度型のような自然なサイズベースの境界より大きな型でのABI定義の整列をオーバーライドする。オプション@option{-malign-power}は、GCCにABI指定のアラインメント規則に従うよう指示しする。 GCCのデフォルトは、ABIで定義されている標準的な配置である。

64ビットDarwinでは、自然な配置がデフォルトであり、@option{-malign-power}はサポートされていない。

@item -msoft-float
@itemx -mhard-float
@opindex msoft-float
@opindex mhard-float
浮動小数点レジスタセットを使用しない（する）コードを生成します。@option{-msoft-float}オプションを使用するとソフトウェア浮動小数点エミュレーションが提供され、リンク時にGCCにオプションが渡される。

@item -mmultiple
@itemx -mno-multiple
@opindex mmultiple
@opindex mno-multiple
複数ワードのロード命令とストアの複数ワード命令を使用する（しない）コードを生成する。これらの命令は、デフォルトではPOWERシステムで生成され、PowerPCシステムでは生成されない。リトルエンディアンのPowerPCシステムでは、これらの命令がプロセッサがリトルエンディアンモードの時は動作しないため、@option{-multiple}は使用しないこと。例外は、リトルエンディアンモードでこれらの命令を許可するPPC740とPPC750である。

@item -mupdate
@itemx -mno-update
@opindex mupdate
@opindex mno-update
ベースレジスタを計算されたメモリ位置のアドレスに更新するロードまたはストア命令を使用する（しない）コードを生成する。これらの命令は、デフォルトで生成される。 @option{-mno-update}を使用すると、スタックポインタが更新されてから前のフレームのアドレスが格納されるまでの間に小さなウィンドウが表示され、それはスタックフレームを割り込みまたは信号を迂回して歩くコードは破損したデータを取得する可能性があることを意味する。

@item -mavoid-indexed-addresses
@itemx -mno-avoid-indexed-addresses
@opindex mavoid-indexed-addresses
@opindex mno-avoid-indexed-addresses
インデックス付きのロードまたはストア命令の使用を回避する（しない）コードを生成する。 これらの命令は、16M境界を横切る大きなアレイをステップ実行する場合など、特定の状況でPower6プロセッサでパフォーマンスの低下を招く可能性がある。 このオプションは、Power6をターゲットに設定するとデフォルトで有効になり、それ以外の場合は無効になる。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点乗加算命令を使用する（しない）コードを生成する。 ハードウェア浮動小数点が使用されている場合、これらの命令はデフォルトで生成される。 マシンに依存する@option{-mfused-madd}オプションは、マシンに依存しない@option{-ffp-contract=fast}オプションにマップされ、@option{-mno-fused-madd}は@option{-ffp-contract=off}にマップされる。

@item -mmulhw
@itemx -mno-mulhw
@opindex mmulhw
@opindex mno-mulhw
IBM 405,440,464、および476プロセッサ上のハーフワード乗算命令および乗加算命令を使用する（しない）コードを生成する。これらの命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item -mdlmzb
@itemx -mno-dlmzb
@opindex mdlmzb
@opindex mno-dlmzb
IBM 405、440、464、および476プロセッサーで文字列検索@samp{dlmzb}命令を使用する（しない）コードを生成する。この命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item -mno-bit-align
@itemx -mbit-align
@opindex mno-bit-align
@opindex mbit-align
System V.4および組み込みPowerPCシステムでは、ビットフィールドを含む構造体および共用体をビットフィールドの基本型にアラインメントさせない（させる）。

例えば、デフォルトでは、長さ1の8個の@code{unsigned}ビットフィールドを含む構造体は、4バイト境界にアライメントされ、4バイトのサイズを持つ。 @option{-mno-bit-align}を使用すると、構造体は1バイトの境界に揃えられ、1バイトのサイズになる。

@item -mno-strict-align
@itemx -mstrict-align
@opindex mno-strict-align
@opindex mstrict-align
System V.4および組み込みPowerPCシステムでは、アライメントされていないメモリ参照がシステムによって処理されるとは想定しない。

@item -mrelocatable
@itemx -mno-relocatable
@opindex mrelocatable
@opindex mno-relocatable
実行時に静的な実行可能ファイルを別のアドレスに再配置できるようにする（しない）コードを生成する。 単純な組み込みPowerPCシステムローダーは、@code{.got2}の全内容と、このオプションによって生成された32ビットアドレスのテーブルである@code{.fixup}セクションにリストされている4バイトの場所を再配置する必要がある。 これを行うには、リンクされたすべてのオブジェクトを、@option{-mrelocatable}または@option{-mrelocatable-lib}でコンパイルする必要がある。

@item -mrelocatable-lib
@itemx -mno-relocatable-lib
@opindex mrelocatable-lib
@opindex mno-relocatable-lib
@option{-mrelocatable-lib}は@option{-mrelocatable}と同様に、実行時に静的実行ファイルを再配置できるように@code{.fixup}セクションを生成するが、@option {-mrelocatable-lib}は、@option {-mrelocatable}の小さなスタックアライメントを使用しない。 @option{-mrelocatable-lib}でコンパイルされたオブジェクトは、@option{-mrelocatable}オプションの任意の組み合わせでコンパイルされたオブジェクトとリンクできる。

@item -mno-toc
@itemx -mtoc
@opindex mno-toc
@opindex mtoc
System V.4および組み込みPowerPCシステムでは、レジスタ2に、プログラムで使用されているアドレスを指すグローバル領域へのポインタが含まれているとは想定しない。

@item -mlittle
@itemx -mlittle-endian
@opindex mlittle
@opindex mlittle-endian
System V.4および組み込みPowerPCシステムでは、プロセッサのコードをリトルエンディアンモードでコンパイルする。@option{-mlittle-endian}オプションは@option{-mlittle}と同じである。

@item -mbig
@itemx -mbig-endian
@opindex mbig
@opindex mbig-endian
System V.4および組み込みPowerPCシステムでは、プロセッサのコードをビッグエンディアンモードでコンパイルする。@option{-big-endian}オプションは@option{-mbig}と同じである。

@item -mdynamic-no-pic
@opindex mdynamic-no-pic
DarwinとMac OS Xシステムでは、再配置可能ではないはその外部参照が再配置可能になるようにコードをコンパイルする。 結果のコードは、アプリケーションには適しているが、共有ライブラリには適していない。

@item -msingle-pic-base
@opindex msingle-pic-base
PICアドレッシングに使用するレジスタは、各関数のプロローグに読み込むのではなく、読み取り専用として扱う。 ランタイムシステムは、実行を開始する前にこのレジスタを適切な値で初期化する必要がある。

@item -mprioritize-restricted-insns=@var{priority}
@opindex mprioritize-restricted-insns
このオプションは、2回目のスケジューリングパスでディスパッチスロット制限付き命令に割り当てられる優先度を制御する。 引数@var{priority}は、ディスパッチスロット制限付き命令にno、highest、またはsecond（最高）の優先度を割り当てるために、値@samp{0}、@samp{1}、または@samp{2}をとる。

@item -msched-costly-dep=@var{dependence_type}
@opindex msched-costly-dep
このオプションは、命令スケジューリング中にターゲットによって高価とみなされる依存関係を制御する。 引数@var{dependence_type}は、次のいずれかの値をとる。

@table @asis
@item @samp{no}
どの依存性も高価ではない。

@item @samp{all}
全依存性は高価である。

@item @samp{true_store_to_load}
ストアからロードへの真の依存性が高価である。

@item @samp{store_to_load}
ストアからロードへの全依存性が高価である。

@item @var{number}
レイテンシが@var{number}以上の依存関係は高価である。
@end table

@item -minsert-sched-nops=@var{scheme}
@opindex minsert-sched-nops
このオプションは、2回目のスケジューリングパスで使用されるNOP挿入方式を制御する。 引数@var{scheme}は、次の値のいずれかをとる：

@table @asis
@item @samp{no}
NOPを挿入しない。

@item @samp{pad}
スケジューラのグルーピングに従って、発行スロットが空いているディスパッチグループをNOPで埋める。

@item @samp{regroup_exact}
NOPを挿入して、高価な依存命令を別々のグループに強制する。 推定されたプロセッサグループに従って、命令を新しいグループに強制するために必要な数だけ正確にNOPを挿入する。

@item @var{number}
NOPを挿入して、高価な依存命令を別々のグループに強制する。 @var{number}NOPを挿入して命令を新しいグループに強制する。
@end table

@item -mcall-sysv
@opindex mcall-sysv
System V.4および組み込みPowerPCシステムでは、System V Application Binary InterfaceのPowerPCプロセッサ補足の1995年3月のドラフトを遵守した呼び出し規約を使用してコードをコンパイルする。@samp {powerpc-*-eabiaix}を使ってGCCを設定していない限り、これがデフォルトである。

@item -mcall-sysv-eabi
@itemx -mcall-eabi
@opindex mcall-sysv-eabi
@opindex mcall-eabi
@option{-mcall-sysv}と@option{-meabi}の両方のオプションを指定する。

@item -mcall-sysv-noeabi
@opindex mcall-sysv-noeabi
@option{-mcall-sysv}と@option{-mno-eabi}の両方のオプションを指定する。

@item -mcall-aixdesc
@opindex m
System V.4および組み込みPowerPCシステムで、AIXオペレーティング・システムのコードをコンパイルする。

@item -mcall-linux
@opindex mcall-linux
System V.4および組み込みPowerPCシステムで、LinuxベースのGNUシステムのコードをコンパイルする。

@item -mcall-freebsd
@opindex mcall-freebsd
System V.4および組み込みPowerPCシステムで、FreeBSDオペレーティングシステムのコードをコンパイルする。

@item -mcall-netbsd
@opindex mcall-netbsd
System V.4および組み込みPowerPCシステムで、NetBSDオペレーティングシステムのコードをコンパイルする。

@item -mcall-openbsd
@opindex mcall-netbsd
System V.4および組み込みPowerPCシステムで、OpenBSDオペレーティングシステムのコードをコンパイルする。

@item -mtraceback=@var{traceback_type}
@opindex mtraceback
Select the type of traceback table. Valid values for @var{traceback_type}
are @samp{full}, @samp{part}, and @samp{no}.

@item -maix-struct-return
@opindex maix-struct-return
メモリ内にすべての構造体を返す（AIX ABIで指定）。

@item -msvr4-struct-return
@opindex msvr4-struct-return
8バイトより小さい構造体をレジスタで返す（SVR4 ABIで指定）。

@item -mabi=@var{abi-type}
@opindex mabi
現在のABIを特定の拡張を追加するか、そのような拡張を削除する。可能な値は、@samp{altivec}, @samp{no-altivec}, @samp{spe}, @samp{no-spe}, @samp{ibmlongdouble}, @samp{ieeelongdouble}, @samp{elfv1}, @samp{elfv2}。

@item -mabi=ibmlongdouble
@opindex mabi=ibmlongdouble
現在のABIをIBM拡張精度のlong doubleを使用するように変更する。 これは、システムがデフォルトでIEEE拡張精度long doubleを使用している場合にはうまくいかない可能性がある。 long double型をIEEE拡張精度から変更すると、コンパイラは@option{-Wno-psabi}オプションを使用しないかぎり警告を発行する。

@item -mabi=ieeelongdouble
@opindex mabi=ieeelongdouble
現在のABIをIEEE拡張精度のlong doubleを使用するように変更します。 これは、システムがデフォルトでIBM拡張精度のlong doubleを使用する場合にはうまくいかない可能性がある。 long double型をIBM拡張精度から変更すると、コンパイラは@option{-Wno-psabi}オプションを使用しないかぎり警告を発行する。

@item -mabi=elfv1
@opindex mabi=elfv1
現在のABIをELFv1 ABIを使用するように変更する。これは、ビッグエンディアンのPowerPC 64ビットLinuxのデフォルトのABIである。デフォルトのABIを無効にするには特別なシステムサポートが必要で、壮大な方法で失敗する可能性がある。

@item -mabi=elfv2
@opindex mabi=elfv2
現在のABIをELFv2 ABIを使用するように変更する。これは、ビッグエンディアンのPowerPC 64ビットLinuxのデフォルトのABIである。デフォルトのABIを無効にするには特別なシステムサポートが必要で、壮大な方法で失敗する可能性がある。

@item -mgnu-attribute
@itemx -mno-gnu-attribute
@opindex mgnu-attribute
@opindex mno-gnu-attribute
.gnu_attributeアセンブリディレクティブを発行して、関数パラメータまたは戻り値のABIバリエーションを指定する.gnu.attributesセクションのタグ/値ペアを設定する。

@item -mprototype
@itemx -mno-prototype
@opindex mprototype
@opindex mno-prototype
System V.4および組み込みPowerPCシステムでは、可変引数関数へのすべての呼び出しが適切にプロトタイプ化されていることを前提としている。 それ以外の場合は、コンパイラは、プロトタイプ化されていないすべての呼び出しの前に、条件コードレジスタ(@code{CR})のビット6を設定またはクリアして関数が可変引数をとる場合に浮動小数点値を浮動小数点レジスタに渡すかどうかを示す命令を挿入する必要がある。 @option{-mprototype}では、プロトタイプの可変引数関数への呼び出しだけがビットを設定またはクリアする。

@item -msim
@opindex msim
組み込みPowerPCシステムで、起動モジュールは@file{sim-crt0.o}と呼ばれ、標準Cライブラリは@file{libsim.a}と@file{libc.a}であると仮定する。これは@samp{powerpc-*-eabisim}設定のデフォルトである。

@item -mmvme
@opindex mmvme
組み込みPowerPCシステムで、起動モジュールは@file{crt0.o}と呼ばれ、標準Cライブラリは@file{libmvme.a}と@file{libc.a}であると仮定する。

@item -mads
@opindex mads
組み込みPowerPCシステムで、起動モジュールが@file{crt0.o}と呼ばれ、標準Cライブラリは@file{libads.a}と@file{libc.a}であると仮定する。

@item -myellowknife
@opindex myellowknife
組み込みPowerPCシステムで、起動モジュールは@file{crt0.o}と呼ばれ、標準Cライブラリは@file{libyk.a}と@file{libc.a}であると仮定する。

@item -mvxworks
@opindex mvxworks
System V.4および組み込みPowerPCシステムでは、VxWorksシステム用にコンパイルすることを指定する。

@item -memb
@opindex memb
埋め込みPowerPCシステムでは、ELFフラグヘッダーの@code{PPC_EMB}ビットを設定して、@samp{eabi}拡張再配置が使用されていることを示す。

@item -meabi
@itemx -mno-eabi
@opindex meabi
@opindex mno-eabi
System V.4および組み込みPowerPCシステムで、System V.4仕様の変更セットであるEmbedded Applications Binary Interface（EABI）に準拠する（しない）。@option {-meabi}を選択すると、スタックが8バイトの境界に揃えられ、関数@code{__eabi}が@code{main}から呼び出されてEABI環境が設定され、@option{-msdata} オプションは、@code{r2}と@code{r13}の両方を使用して、2つの別々の小さなデータ領域を指し示すことができる。@option{-mno-eabi}を選択すると、スタックが16バイトの境界に揃えられ、EABI初期化関数は@code{main}から呼び出されず、@option{-msdata}オプションは、単一の小さなデータ領域を指すために@code {r13}だけを使用するようになる。@samp{powerpc*-*-eabi*}オプションの1つを使ってGCCを設定した場合、@option{-meabi}オプションはデフォルトでオンになっている。

@item -msdata=eabi
@opindex msdata=eabi
System V.4および組み込みPowerPCシステムで、小さな初期化された@code{const}グローバルデータと静的データを@code{.sdata2}セクションに置く。このセクションは、@code {r2}によって参照される。 小さな初期化された非@code{const}グローバルデータと静的データを@code{.sdata}セクションに置いてください。これはレジスタ@code{r13}によって指されている。 @code{.sdss}セクションに隣接する@code{.sbss}セクションに、小さな初期化されていないグローバルデータと静的データを配置する。 @option{-msdata=eabi}オプションは、@option{-mrelocatable}オプションと互換性がない。 @option{-msdata=eabi}オプションは@option{-memb}オプションも設定する。

@item -msdata=sysv
@opindex msdata=sysv
System V.4および組み込みPowerPCシステムで、小規模のグローバルおよび静的データを@code{.sdata}セクションに配置する。これは、レジスタ @code{r13}によって指し示される。小さな初期化されていないグローバルデータと静的データを、 @code{.sdss}セクションに隣接する@code{.sbss}セクションに配置する。 @option{-msdata=sysv}オプションは、@option{-mrelocatable}オプションと互換性がない。

@item -msdata=default
@itemx -msdata
@opindex msdata=default
@opindex msdata
System V.4および組み込みPowerPCシステムで、@option{-meabi}を使用する場合、@option{-msdata=eabi}と同じコードをコンパイルする。そうでない場合は、@option{-msdata=sysv}と同じコードをコンパイルする。

@item -msdata=data
@opindex msdata=data
System V.4および組み込みPowerPCシステムで、小さなグローバルデータを@code{.sdata}セクションに配置する。 小さな初期化されていないグローバルデータを@code{.sbss}セクションに入れる。 しかし、小さなデータに対処するためにレジスタ@code{r13}を使用しない。 他の@option{-msdata}オプションを使用しない限り、これはデフォルトの動作である。

@item -msdata=none
@itemx -mno-sdata
@opindex msdata=none
@opindex mno-sdata
組み込みPowerPCシステムで、初期化されたグローバルデータと静的データを@code{.data}セクションに、初期化されていないすべてのデータを@code{.bss}セクションに配置する。

@item -mreadonly-in-sdata
@itemx -mreadonly-in-sdata
@opindex mreadonly-in-sdata
@opindex mno-readonly-in-sdata
@code{.sdata}セクションにも読み取り専用オブジェクトを配置します。 これがデフォルトです。

@item -mblock-move-inline-limit=@var{num}
@opindex mblock-move-inline-limit
@var{num}バイト以下のすべてのブロック移動（@code{memcpy}や構造体コピーの呼び出しなど）をインライン化する。 @var{num}の最小値は、32ビット・ターゲットでは32バイト、64ビット・ターゲットでは64バイトである。 デフォルト値はターゲット固有である。

@item -mblock-compare-inline-limit=@var{num}
@opindex mblock-compare-inline-limit
@var{num}バイト以下のすべてのブロック比較（@code{memcmp}への呼び出しや構造比較など）の非ループインラインコードを生成します。 @var{num}が0の場合、ブロック比較のすべてのインライン展開（非ループおよびループ）は無効になります。 デフォルト値はターゲット固有です。

@item -mblock-compare-inline-loop-limit=@var{num}
@opindex mblock-compare-inline-loop-limit
@var{num}バイト以下で、ループ以外のインラインブロック比較拡張の制限を超えるすべてのブロック比較のループコードを使用して、インライン拡張を生成します。 ブロック長が一定でない場合、@code{memcmp}が呼び出されてブロックの残りの部分が比較される前に、最大で@var{num}バイトが比較されます。 デフォルト値はターゲット固有です。

@item -mstring-compare-inline-limit=@var{num}
@opindex mstring-compare-inline-limit
文字列をインラインで比較するために、最大で@var{num}ペアのロード命令を生成します。 インラインの終わりに文字列の違いまたは終わりが見つからない場合は、@code{strcmp}または@code{strncmp}の呼び出しが残りの比較を処理します。 デフォルトは8ペアのロードで、64ビットターゲットの64バイトと32ビットターゲットの32バイトを比較します。

@item -G @var{num}
@opindex G
@cindex smaller data references (PowerPC)
@cindex .sdata/.sdata2 references (PowerPC)
埋め込みPowerPCシステムで、@var{num}バイト以下のグローバルおよび静的アイテムを、通常のデータまたはBSSセクションではなく、小データまたはBSSセクションに配置する。 デフォルトでは、@var{num}は8である。@option{-G @var{num}}スイッチもリンカに渡される。 すべてのモジュールは同じ@option{-G @var{num}}値でコンパイルする必要がある。

@item -mregnames
@itemx -mno-regnames
@opindex mregnames
@opindex mno-regnames
System V.4および組み込みPowerPCシステムでは、シンボリックフォームを使用してアセンブリ言語出力のレジスタ名を発行する（しない）。

@item -mlongcall
@itemx -mno-longcall
@opindex mlongcall
@opindex mno-longcall
デフォルトでは、すべてのコールが遠く離れているため、より長くより高価なコールシーケンスが必要になると想定する。 これは、現在の場所から32メガバイト（33,554,432バイト）を超えた呼び出しに必要である。コンパイラーがその呼び出しを遠くにすることができないことを知っている場合、短い呼び出しが生成される。 この設定は、@code{shortcall}関数の属性、または@code{#pragma longcall(0}によって無効にすることができる。

いくつかのリンカは、範囲外のコールを検出し、その場でグルーコードを生成することができる。 これらのシステムでは、長い呼び出しは不要で、より遅いコードを生成する。 この記事の執筆時点では、PowerPC/64のGNUリンカーと同様に、AIXリンカーがこれを行うことができる。 この機能を32ビットPowerPCシステムのGNUリンカに追加する予定である。

Darwin/PPCシステムでは、@code{#pragma longcall}は@code{jbsr callee, L42}と@dfn{branch island}（分岐島）（グルーコード）を生成する。 2つのターゲットアドレスは、呼び出し先と分岐島を表します。 Darwin/PPCリンカは、最初のアドレスを優先し、PPC @code{bl}命令が呼び出し先に直接到達すると、@code{bl callee}を生成する。 それ以外の場合、リンカーは分岐島を呼び出すために@code {bl L42}を生成する。分岐島は呼び出し関数の本体に追加される。 呼び出し先の全32ビットアドレスを計算し、そのアドレスにジャンプする。

Mach-O（Darwin）システムでは、このオプションは直接呼び出しごとにコンパイラに前直接呼び出しのグルーを生成するように指示し、Darwinリンカーはそれを使用するか廃棄するかを決定する。

将来、GCCは、リンカーがグルーを生成することが知られている場合、すべてのロングコール仕様を無視するかもしれない。

@item -mpltseq
@itemx -mno-pltseq
@opindex mpltseq
@opindex mno-pltseq
遅延リンクとdlopenされた共有ライブラリ内の関数への長い呼び出しをサポートするインラインPLT呼び出しシーケンスを使用して、-fno-pltと長い呼び出しを実装します（実装しません）。 インラインPLT呼び出しは、PowerPC64 ELFv2および新しいGNUリンカーを備えた32ビットPowerPCシステムでのみサポートされ、GCCの構成時にサポートが検出された場合、32ビットPowerPCの場合、GCCが@option{-enable-secureplt}で構成されている場合、デフォルトで有効になります。 @option{-mpltseq}コードと@option{-mbss-plt} 32ビットPowerPC再配置可能オブジェクトはリンクされない場合があります。

@item -mtls-markers
@itemx -mno-tls-markers
@opindex mtls-markers
@opindex mno-tls-markers
@code{__tls_get_addr}への呼び出しには、関数の引数を指定して再配置を行う（行わない）。 再配置により、リンカーは関数呼び出しをTLS最適化の引数設定命令に確実に関連付けることができ、これによりGCCはシーケンスをよりよくスケジューリングできるようになる。

@item -mrecip
@itemx -mno-recip
@opindex mrecip
このオプションを使用すると、除算または平方根を実行する代わりに、追加のニュートンラフソンステップを逆数推定と逆平方根推定命令を使用して、精度を上げ浮動小数点引数を除算することができる。 @option{-mrecip}を使うときは、@option{-fastsafe-math-optimizations}、@option{-ffinite-math-only}、@option{-freciprocal-math}と@option{-fno-trapping-math}）を指定する。 シーケンスのスループットは一般に非相反命令のスループットよりも高いが、シーケンスの精度は、逆平方根に対して最大2ulp（すなわち、逆数1.0は0.99999994に等しい）減少させることがありうることに留意すること。

@item -mrecip=@var{opt}
@opindex mrecip=opt
このオプションは、どの逆算見積り命令を使用するかを制御する。 @var{opt}はコンマで区切られたオプションのリストである。オプションの前に@code{!}を付けてオプションを反転することができる：

@table @samp

@item all
すべての見積もり命令を有効にする。

@item default 
@option{-mrecip}と同じデフォルトの命令を有効にする。

@item none 
@option{-mno-recipe}と同等の、すべての見積もり命令を無効にする。

@item div 
単精度と倍精度の両方の逆数近似命令を有効にする。

@item divf 
単精度の逆数近似命令を有効にする。

@item divd 
倍精度の逆数近似命令を有効にする。

@item rsqrt
単精度と倍精度の両方で逆平方根近似命令を有効にする。 

@item rsqrtf 
単精度の逆数平方根近似命令を有効にする。

@item rsqrtd 
倍精度の逆数平方根近似命令を有効にする。

@end table

たとえば、@option{-mrecip=all,!rsqrtd}は倍精度逆数平方根の計算を扱う@code{FRSQRTE}、@code{XSRSQRTEDP}、@code{XVRSQRTEDP}の命令を除いてすべての逆数見積もり命令を有効にする。

@item -mrecip-precision
@itemx -mno-recip-precision
@opindex mrecip-precision
逆数見積もり命令がPowerPC ABIよりも高い精度の見積もりを提供すると仮定する（しない）。@option{-mcpu=power6}、@option{-mcpu=power7}または@option{-mcpu=power8}を選択すると、自動的に@option{-mrecip-precision}が選択される。2倍精度平方根推定命令は、3ステップ後に収束する推定値を提供しないため、低精度機械ではデフォルトで生成されない。

@item -mveclibabi=@var{type}
@opindex mveclibabi
外部ライブラリを使用して組み込み関数をベクトル化するために使用するABIタイプを指定する。 現在サポートされているタイプは@samp{mass}のみで、外部ライブラリを使用して組み込み関数をベクトル化するためにIBMのMASS（Mathematical Acceleration Subsystem）ライブラリを使用することを指定する。GCCは現在、power7のコードを生成するときに、@code{acosd2}, @code{acosf4}, @code{acoshd2}, @code{acoshf4}, @code{asind2}, @code{asinf4},
@code{asinhd2}, @code{asinhf4}, @code{atan2d2}, @code{atan2f4}, @code{atand2}, @code{atanf4}, @code{atanhd2}, @code{atanhf4}, @code{cbrtd2}, @code{cbrtf4}, @code{cosd2}, @code{cosf4}, @code{coshd2}, @code{coshf4}, @code{erfcd2}, @code{erfcf4}, @code{erfd2}, @code{erff4}, @code{exp2d2}, @code{exp2f4}, @code{expd2}, @code{expf4}, @code{expm1d2}, @code{expm1f4}, @code{hypotd2}, @code{hypotf4}, @code{lgammad2}, @code{lgammaf4}, @code{log10d2}, @code{log10f4}, @code{log1pd2}, @code{log1pf4}, @code{log2d2}, @code{log2f4}, @code{logd2}, @code{logf4}, @code{powd2}, @code{powf4}, @code{sind2}, @code{sinf4}, @code{sinhd2}, @code{sinhf4}, @code{sqrtd2}, @code{sqrtf4}, @code{tand2}, @code{tanf4}, @code{tanhd2}, and @code{tanhf4}への呼び出しを生成する。@option{-ftree-vectorize}と@option{-funsafe-math-optimizations}も有効にする必要がある。 MASSライブラリは、リンク時に指定する必要がある。

@item -mfriz
@itemx -mno-friz
@opindex mfriz
@option{-funsafe-math-optimizations}オプションを使用して浮動小数点値の64ビット整数への丸めを最適化し、浮動小数点に戻すときに、@code{friz}命令を生成する（しない）。 浮動小数点数が大きすぎて整数に収まらない場合、@code{friz}命令は同じ値を返さない。

@item -mpointers-to-nested-functions
@itemx -mno-pointers-to-nested-functions
@opindex mpointers-to-nested-functions
関数ポインタが、関数ポインタを与える3ワード・ディスクリプタ、レジスタ@code{r2}にロードされるTOC値、レジスタ@code{r11}にロードされる静的チェーン値を指すAIXと64ビットLinuxシステムでポインタを通して呼び出したとき、静的チェーンレジスタ（@code{r11}）をロードするコードを生成する（しない）。@option{-mpointers-to-nested-functions}はデフォルトでオンになっている。 @option{-mno-pointer-to-nested-functions}を使用すると、ネストした関数へのポインタや静的チェーンを使用する他の言語でコンパイルされた関数へのポインタを呼び出すことはできない。

@item -msave-toc-indirect
@itemx -mno-save-toc-indirect
@opindex msave-toc-indirect
関数がAIXおよび64ビットLinuxシステム上のポインターを呼び出す場合、関数プロローグの予約済みスタック位置にTOC値を保存するコードを生成する（しない）。 TOC値がプロローグに保存されていない場合は、ポインターを呼び出す直前に保存される。 @option{-mno-save-toc-indirect}オプションがデフォルトである。

@item -mcompat-align-parm
@itemx -mno-compat-align-parm
@opindex mcompat-align-parm
GCCの古いバージョンとの互換性のために、最大64ビットのアライメントで構造体パラメータを渡すコードを生成する（しない）。

古いバージョンのGCC（4.9.0より前）では、構造体が128ビット境界を必要とするメンバを含んでいた場合、構造体パラメータが128ビット境界上に正しく配置されなかった。 これはGCCの最近のバージョンで修正されている。 このオプションは、GCCの古いバージョンでコンパイルされた関数と互換性のあるコードを生成するために使用されていない。

@option {-mno-compat-align-parm}オプションがデフォルトである。

@item -mstack-protector-guard=@var{guard}
@itemx -mstack-protector-guard-reg=@var{reg}
@itemx -mstack-protector-guard-offset=@var{offset}
@itemx -mstack-protector-guard-symbol=@var{symbol}
@opindex mstack-protector-guard
@opindex mstack-protector-guard-reg
@opindex mstack-protector-guard-offset
@opindex mstack-protector-guard-symbol
@var{guard}にカナリアを使用してスタック保護コードを生成します。 サポートされている場所は、TLSブロック（GNU libcバージョン2.4以降のデフォルト）でグローバルカナリアンの場合は@samp{global}、スレッドごとカナリアンの場合は@samp{tls}である。

後者のオプションでは、@option{-mstack-protector-guard-reg=@var{reg}}オプションと@option{-mstack-protector-guard-offset=@var{offset}}オプションは、 カナリアを読み取るためのベースレジスタと、そのベースレジスタからのどのオフセットからのものかを示します。 これらのデフォルトは、関連するABIで指定されている。@option{-mstack-protector-guard-symbol=@var{symbol}}は、TLSブロックのカナリアへのシンボル参照でオフセットを上書きする。

@item -mpcrel
@itemx -mno-pcrel
@opindex mpcrel
@opindex mno-pcrel
オプション@option{-mcpu=future}が使用されている場合、PC相対アドレスを生成します（生成しません）。@option{-mpcrel}オプションでは、中コードモデル（@option{-mcmodel=medium}）およびプレフィックスアドレス指定（@option{-mprefixed}）オプションが有効になっている必要があります。

@item -mprefixed
@itemx -mno-prefixed
@opindex mprefixed
@opindex mno-prefixed
オプション@option{-mcpu=future}が使用されている場合、接頭辞付きのロードおよびストア命令を使用してアドレッシングモードを生成します（生成しません）。

@item -mmma
@itemx -mno-mma
@opindex mmma
@opindex mno-mma
オプション@option{-mcpu=future}が使用されている場合、MMA命令を生成します（しません）。

@item -mblock-ops-unaligned-vsx
@itemx -mno-block-ops-unaligned-vsx
@opindex block-ops-unaligned-vsx
@opindex no-block-ops-unaligned-vsx
@code{memcpy}と@code{memmove}のインライン展開のために、整列されていないvsxロードとストアを生成します（しません）。

@end table


@node RX Options
@subsection RXオプション
@cindex RX Options

これらのコマンドラインオプションは、RXターゲットに対して定義されている。

@table @gcctabopt
@item -m64bit-doubles
@itemx -m32bit-doubles
@opindex m64bit-doubles
@opindex m32bit-doubles
@code{double}データ型を64ビット（@option{-m64bit-doubles}）または32ビット（@option{-m32bit-doubles}）のサイズにする。 デフォルトは@option{-m32bit-doubles}である。 @emph{_注意_} RX浮動小数点ハードウェアは32ビット値でのみ動作する。そのため、デフォルトは@option{-m32bit-doubles}である。

@item -fpu
@itemx -nofpu
@opindex fpu
@opindex nofpu
RX浮動小数点ハードウェアの使用を有効（@option{-fpu}）または無効（@option{-nofpu}）にする。 デフォルトはRX600シリーズでは有効、RX200シリーズでは無効である。

ただし、浮動小数点命令は32ビット浮動小数点値に対してのみ生成されるため、@option{-m64bit-doubles}オプションが使用されている場合、FPUハードウェアは倍精度には使用されない。

@emph{_注意_} @option{-fpu}オプションを有効にすると、@option{-funsafe-math-optimizations}も自動的に有効になる。 これは、RX FPU命令自体が危険であるためである。

@item -mcpu=@var{name}
@opindex mcpu
ターゲットにするRX CPUのタイプを選択する。 現在、汎用@samp{RX600}と@samp{RX200}シリーズハードウェアと特定の@samp{RX610}CPUの3種類がサポートされている。 デフォルトは@samp{RX600}である。

@samp{RX600}と@samp {RX610}の唯一の違いは、@code{RX610}が@code{MVTIPL}命令をサポートしていないことである。

@samp{RX200}シリーズにはハードウェア浮動小数点ユニットがないため、このタイプが選択されている場合はデフォルトで@option{-nofpu}が有効になっている。

@item -mbig-endian-data
@itemx -mlittle-endian-data
@opindex mbig-endian-data
@opindex mlittle-endian-data
データをビッグエンディアン形式で格納する（コードはしない）。 デフォルトは@option{-mlittle-endian-data}である。すなわち、リトルエンディアン形式でデータを格納する。

@item -msmall-data-limit=@var{N}
@opindex msmall-data-limit
小さなデータ領域に配置できるグローバルおよび静的変数の最大サイズをバイト単位で指定する。 小さなデータ領域を使用すると、コードが小さくて高速になる可能性があるが、領域のサイズは限られていて、領域がオーバーフローしないかどうかはプログラマにまかされている。 小さなデータ領域が使用されている場合には、RXのレジスタの1つ（通常は@code{r13}）はこの領域を指すために予約されているため、コンパイラでは使用できなくなる。 この結果、変数がこのレジスタに保持されるのではなくスタックにプッシュされると、コードの速度が遅くなりコードが大きくなることもある。

一般的な変数（初期化されていない変数）と定数は、実行可能な出力の他のセクションに割り当てられているため、小さなデータ領域には配置されない。

デフォルト値は0で、この機能は無効になっている。 この機能は、レジスタを予約すると悪影響を受ける可能性があるため、デフォルトでは高度な最適化レベル（@option {-O2}など）では有効になっていない。 この機能がプログラムに有益であるかどうかを実験して発見することはプログラマの責任である。 小さなデータ領域ポインタを保持する実際のレジスタの選択方法については、@option{-mpid}オプションの説明を参照せよ。

@item -msim
@itemx -mno-sim
@opindex msim
@opindex mno-sim
シミュレータランタイムを使用する。 デフォルトでは、libglossボード固有のランタイムを使用する。

@item -mas100-syntax
@itemx -mno-as100-syntax
@opindex mas100-syntax
@opindex mno-as100-syntax
アセンブラ出力を生成する場合に、ルネサスのAS100アセンブラと互換性のある構文を使用する。 この構文はGASアセンブラでも処理できるが、いくつかの制限があり、デフォルトでは生成されない。

@item -mmax-constant-size=@var{N}
@opindex mmax-constant-size
RX命令のオペランドとして使用できる定数の最大サイズをバイト単位で指定する。RX命令セットは、長さが最大4バイトの定数を命令で使用することを可能にするが、より長い値はより長い命令に等しい。したがって、状況によっては、命令で使用される定数のサイズを制限することが有益である。大きすぎる定数は、代わりに定数プールに配置され、レジスタの間接参照によって参照される。

値@var{N}は0と4の間で指定できる。値0（デフォルト）または4は、任意のサイズの定数が許可されることを意味する。

@item -mrelax
@opindex mrelax
リンカーの緩和を有効にする。 リンカー緩和は、リンカーがさまざまな命令の短いバージョンを見つけることによってプログラムのサイズを縮小しようとするプロセスである。 デフォルトでは無効である。

@item -mint-register=@var{N}
@opindex mint-register
高速割り込みハンドラ機能用に予約するレジスタの数を指定する。値@var{N}は0と4の間にある。1という値は、レジスタ@code{r13}が高速割り込みハンドラ専用に予約されていることを意味する。 2の値は@code{r13}と@code{r12}を予約する。3の値は@code{r13}、@code{r12}と@code{r11}を予約し、4の値は@code{r13}から@code{r10}を予約する。デフォルトの値0は、レジスタを予約しない。

@item -msave-acc-in-interrupts
@opindex msave-acc-in-interrupts
割り込みハンドラ関数がアキュムレータレジスタを保持する必要があることを指定する。 これは、たとえば64ビット乗算を実行するなど、通常のコードでアキュムレータレジスタを使用する場合にのみ必要である。 デフォルトでは、アキュムレータは無視されるため、割り込みハンドラが高速になる。

@item -mpid
@itemx -mno-pid
@opindex mpid
@opindex mno-pid
位置に依存しないデータの生成を有効にする。 有効にされると、定数データへのアクセスは、レジスタに保持されたベースアドレスからのオフセットを介して行わる。 これにより、実行可能ファイルの再配置を必要とせずに、実行時に定数データの位置を決定することができる。これは、厳しいメモリ制約を伴う組み込みアプリケーションのメリットである。 このオプションによって、変更可能なデータは影響を受けない。

この機能を使用すると、定数データベースのアドレスには、通常@code{r13}のレジスタが予約される。 これにより、特に複雑な機能では、コードの速度が遅くなることがある。

定数データベースアドレスを保持するために選択された実際のレジスタは、@option{-msmall-data-limit}および/または@option{-mint-register}コマンドラインオプションが有効かどうかによって異なる。レジスタ@code{r13}から始め下方に進み、レジスタは最初に@option{-mint-register}、次に@option {-mpid}、最後に@option{-msmall-data-limit}の要件を満たすように割り当てられる。したがって、@option{-mint-register=4}と@option{-mpid}の両方がコマンドラインで指定されている場合、小さなデータエリアレジスタは@code{r8}になる可能性がある。

デフォルトでは、この機能は有効になっていない。 デフォルトは、@option{-mno-pid}コマンドラインオプションで復元できる。

@item -mno-warn-multiple-fast-interrupts
@itemx -mwarn-multiple-fast-interrupts
@opindex mno-warn-multiple-fast-interrupts
@opindex mwarn-multiple-fast-interrupts
ファイルをコンパイル中に複数の高速割り込みハンドラが見つかった場合、GCCが警告メッセージを出さないようにする。 RXは、このような割り込みの1つのみをサポートするため、デフォルトでは、見つかった追加の高速割り込みハンドラごとに警告を発行する。

@item -mallow-string-insns
@itemx -mno-allow-string-insns
@opindex mallow-string-insns
@opindex mno-allow-string-insns
文字列操作命令@code{SMOVF}、@code{SCMPU}、@code{SMOVB}、@code{SMOVU}、@code{SUNTIL}、@code{SWHILE}、@code{SWILE}、@code{RMPA}命令の使用を有効または無効にする 。 これらの命令はデータをプリフェッチする可能性があり、I/Oレジスタにアクセスする場合は安全ではない。 （詳細についてはRX62Nグループユーザーズマニュアルの12.2.7節参照）。

デフォルトではこれらの命令が許可されているが、I/Oレジスタにアクセスするために文字列命令が使用される可能性のあるすべての状況をGCCが確実に検出することはできないため、その使用を自動的に無効にすることはできない。 代わりに、プログラムがI/O空間にアクセスする場合、@option{-mno-allow-string-insns}オプションを使用することはプログラマに依存している。

命令が有効になると、GCCはCプリプロセッサシンボル@code{__RX_ALLOW_STRING_INSNS__}を定義する。それ以外の場合はシンボル@code{__RX_DISALLOW_STRING_INSNS__}を定義する。

@item -mjsr
@itemx -mno-jsr
@opindex mjsr
@opindex mno-jsr
関数にアクセスするには@code{JSR}命令だけ（ではなく）使用する。このオプションは、コードサイズが@code{BSR}命令の範囲を超える場合に使用できる。 @option{-mno-jsr}は@code {JSR}を使用しないことを意味するのではなく、任意の種類のブランチを使用できることを意味する。
@end table

@emph{_注意：_}一般的なGCCのコマンドラインオプション@option{-ffixed-@var{reg}}は、@code{interrupt}関数属性とともに使用するとき、RXポートに対して特別な意味を持つ。 この属性は、高速割り込みを処理する機能を示す。 GCCは、レジスタ@code{r10}、@code{r11}、@code{r12}および/または@code{r13}のみを使用し、対応するレジスタの通常の使用が@option{-ffixed-@var{reg}}または@option{-mint-register}コマンドラインオプションを使用する。

@node S/390 and zSeries Options
@subsection S/390とzSeriesのオプション
@cindex S/390 and zSeries Options

これらは、S/390およびzSeriesアーキテクチャー用に定義された@samp{-m}オプションである。

@table @gcctabopt
@item -mhard-float
@itemx -msoft-float
@opindex mhard-float
@opindex msoft-float
ハードウェア浮動小数点命令と浮動小数点演算用のレジスタを使用する（しない）。 @option{-msoft-float}を指定すると、@file{libgcc.a}の関数が浮動小数点演算の実行に使用される。 @option{-mhard-float}を指定すると、コンパイラはIEEE浮動小数点命令を生成する。 これがデフォルトである。

@item -mhard-dfp
@itemx -mno-hard-dfp
@opindex mhard-dfp
@opindex mno-hard-dfp
10進浮動小数点演算にはハードウェア10進浮動小数点命令を使用する（しない）。 @option{-mno-hard-dfp}を指定すると、@file{libgcc.a}の関数を使用して10進浮動小数点演算が実行される。 @option{-mhard-dfp}を指定すると、コンパイラは10進浮動小数点ハードウェア命令を生成する。 これは、@option{-march=z9-ec}以上のデフォルトである。

@item -mlong-double-64
@itemx -mlong-double-128
@opindex mlong-double-64
@opindex mlong-double-128
これらのスイッチは、@code{long double}型のサイズを制御する。 64ビットのサイズは、@code{long double}型を@code{double}型と等価にする。 これがデフォルトである。

@item -mbackchain
@itemx -mno-backchain
@opindex mbackchain
@opindex mno-backchain
呼び出し元のフレームのアドレスをバックチェーンポインタとして呼び出し先のスタックフレームに格納する（しない）。DWARFコールフレーム情報を理解していないツールを使用してデバッグを可能にするには、バックチェーンが必要な場合がある。@option{-mno-packed-stack}が有効な場合、バックチェーンポインタはスタックフレームの一番下に格納される。 @option{-mpacked-stack}が有効な場合、バックチェーンは96/160バイトレジスタ保存領域の最上位ワードに配置される。

一般に、@option{-mbackchain}でコンパイルされたコードは、@option{-mmo-backchain}でコンパイルされたコードと呼び出し互換である。 しかし、デバッグの目的でバックチェーンを使用するには、通常、バイナリ全体が@option{-mbackchain}で構築されている必要がある。@option{-mbackchain}、@option{-mpacked-stack}と@option{-mhard-float}の組み合わせはサポートされていないことに注意せよ。 Linuxカーネルを構築するには、@option{-msoft-float}を使用する。

デフォルトはバックチェーンを維持しない。

@item -mpacked-stack
@itemx -mno-packed-stack
@opindex mpacked-stack
@opindex mno-packed-stack
パックされたスタックレイアウトを使用する（しない）。 @option{-mno-packed-stack}を指定すると、コンパイラは96/160バイトレジスタ保存領域のすべてのフィールドをデフォルトの目的でのみ使用する。未使用のフィールドはそれでもスタック領域を占有する。@option{-mpacked-stack}を指定すると、レジスタ退避領域はレジスタ退避領域の先頭に密集して配置される。未使用スペースは他の目的で再利用され、使用可能なスタックスペースをより効率的に使用することができる。ただし、@option{-mbackchain}も有効な場合、保存領域の最上位ワードは常にバックチェーンを格納するために使用され、戻りアドレスレジスタは常にバックチェーンの2ワード下に保存される。

スタックフレームバックチェーンが使用されていない限り、@option{-mpacked-stack}で生成されたコードは、@option{-mno-packed-stack}で生成されたコードと呼び出し互換である。 FSF以外のリリースのGCC 2.95（S/390またはzSeries用）では、デバッグの目的だけでなく、実行時にスタックフレームバックチェーンを使用するコードが生成されたことに注意せよ。 このようなコードは、@option{-mpacked-stack}でコンパイルされたコードとの呼び出し互換性はない。また、@option{-mbackchain}、@option{-mpacked-stack}と@option {-mhard-float}の組み合わせはサポートされていない。Linuxカーネルを構築するには、@option{-msoft-float}を使用する。

デフォルトでは、パックドスタックレイアウトは使用されない。

@item -msmall-exec
@itemx -mno-small-exec
@opindex msmall-exec
@opindex mno-small-exec
サブルーチン呼び出しを行うために@code{bras}命令を使ってコードを生成する（しない）。これは、実行可能な合計サイズが64kを超えない場合にのみ、確実に機能する。 デフォルトでは、@code{basr}命令を代わりに使用し、それにはこの制限はない。

@item -m64
@itemx -m31
@opindex m64
@opindex m31
@option{-m31}を指定すると、S/390 ABI向けGNU/Linuxに準拠したコードを生成する。@option{-m64}を指定すると、zSeries ABI向けGNU/Linuxに準拠したコードが生成される。 これにより、特にGCCは64ビット命令を生成することができる。@samp{s390}ターゲットの場合、デフォルトは@option{-m31}だが、@samp{s390x}ターゲットはデフォルトで@option{-m64}になる。

@item -mzarch
@itemx -mesa
@opindex mzarch
@opindex mesa
@option{-mzarch}を指定すると、z/Architectureで使用可能な命令を使用してコードを生成する。@option{-mesa}を指定した場合は、ESA/390で使用可能な命令を使用してコードを生成する。 @option{-mesa}は@option{-m64}では使用できない。S/390 ABI向けGNU/Linuxに準拠したコードを生成する場合、デフォルトは@option{-mesa}である。zSeries ABI向けGNU/Linuxに準拠したコードを生成する場合、デフォルトは@option{-mzarch}である。

@item -mhtm
@itemx -mno-htm
@opindex mhtm
@opindex mno-htm
@option{-mhtm}オプションは、IBM zEnterprise EC12マシン世代で導入されたトランザクショナル実行機能で使用可能な命令を使用した組み込み関数のセットを使用可能にする。@ref{S/390 System z Built-in Functions}。@option{-mhtm}は、@option{-march=zEC12}を使用している場合、デフォルトで有効になっている。

@item -mvx
@itemx -mno-vx
@opindex mvx
@opindex mno-vx
@option {-mvx}を指定すると、IBM z13マシン生成で導入されたベクトル拡張機能で使用可能な命令を使用してコードを生成する。このオプションは、整列と呼び出し規約に関して、いくつかのベクトル型の値をABIに変更する。 ベクトル型の値がABI関連の文脈で使用されている場合は、GAS @samp{.gnu_attribute}コマンドを使用して、使用されたABIで結果のバイナリをマークする。@option{-mvx}は、@option{-march=z13}を使用すると、デフォルトで有効になる。

@item -mzvector
@itemx -mno-zvector
@opindex mzvector
@opindex mno-zvector
@option{-mzvector}オプションを使用すると、IBM z13マシン生成で導入されたベクトル拡張機能で使用可能な命令を使用して、ベクトル言語拡張および組み込み関数を使用できる。このオプションは、@samp{vector}のサポートを追加し、ベクトル型の変数と引数を定義するキーワードとして使用する。 @samp{vector}は、GNU拡張機能が有効な場合にのみ使用できる。たとえば、@option{-std=c99}を指定するような、標準のコンプライアンスを厳格に要求する場合には展開されない。GCCの低レベルの組み込み関数@option{-mzvector}は、PowerやCellなどのAltiVecスタイルの実装との互換性のために追加された組み込み関数を有効にする。 これらの組み込み関数を使用するには、ヘッダファイル@file{vecintrin.h}をインクルードする必要がある。@option{-mzvector}はデフォルトでは無効になっている。

@item -mmvcle
@itemx -mno-mvcle
@opindex mmvcle
@opindex mno-mvcle
ブロック移動を実行するための@code{mvcle}命令を使用してコードを生成する（しない）。 @option{-mno-mvcle}を指定すると、代わりに@code{mvc}ループを使用する。 サイズを最適化しない限り、これがデフォルトである。

@item -mdebug
@itemx -mno-debug
@opindex mdebug
@opindex mno-debug
コンパイル時に追加のデバッグ情報を出力する（またはしない）。デフォルトでは、デバッグ情報は表示されない。

@item -march=@var{cpu-type}
@opindex march
@var{cpu-type}で実行されるコードを生成する。これは、特定のプロセッサタイプを表すシステムの名前である。 @var{cpu-type}に可能な値は、@samp{z900}/@samp{arch5}, @samp{z990}/@samp{arch6}, @samp{z9-109}, @samp{z9-ec}/@samp{arch7}, @samp{z10}/@samp{arch8}, @samp{z196}/@samp{arch9}, @samp{zEC12}, @samp{z13}/@samp{arch11}, @samp{native}である。

デフォルトは@option{-march=z900}である。 @samp{g5}/@samp{arch3}と@samp{g6}は非推奨であり、将来のリリースで削除される予定である。

@samp{native}をcpuタイプとして指定すると、ホストプロセッサに最適なアーキテクチャオプションを選択できる。gccがプロセッサを認識しない場合、@option{-march=native}は効果がない。

@item -mtune=@var{cpu-type}
@opindex mtune
@var{cpu-type}に対して、ABIと使用可能な命令のセットを除いて、生成されたコードに関するすべてを調整する。@var{cpu-type}の値のリストは、@option{-march}の値と同じである。デフォルトは、@option{-march}に使用される値である。

@item -mtpf-trace
@itemx -mno-tpf-trace
@opindex mtpf-trace
@opindex mno-tpf-trace
TPF OS固有のブランチをオペレーティング・システムのトレース・ルーチンに追加する（しない）コードを生成する。 このオプションは、TPF OS用にコンパイルしていても、デフォルトではオフになっている。

@item -mtpf-trace-skip
@itemx -mno-tpf-trace-skip
@opindex mtpf-trace-skip
@opindex mno-tpf-trace-skip
@option{-mtpf-trace}によって有効にされたデフォルトの分岐ターゲットを変更する（変更しない）コードを生成して、TPF OSの関数トレースエントリを選択的にスキップする機能を提供する特殊なトレースルーチンをポイントします。 TPF OS用にコンパイルして@option {-mtpf-trace}を指定した場合でも、このオプションはデフォルトでオフになっています。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点乗算および累算命令を使用する（しない）コードを生成する。 ハードウェア浮動小数点が使用されている場合、これらの命令はデフォルトで生成される。

@item -mwarn-framesize=@var{framesize}
@opindex mwarn-framesize
現在の関数が指定されたフレームサイズを超えた場合に警告を出す。これはコンパイル時のチェックであるため、プログラムを実行するときに実際の問題である必要はない。おそらくスタックオーバーフローを引き起こす可能性のある関数を識別するためのものである。スタックサイズが制限された環境、例えばLinuxカーネルで使用すると便利である。

@item -mwarn-dynamicstack
@opindex mwarn-dynamicstack
関数が@code{alloca}を呼び出すか、動的にサイズの配列を使用する場合は警告を出る。これは一般的に、制限されたスタックサイズでは悪い考えである。

@item -mstack-guard=@var{stack-guard}
@itemx -mstack-size=@var{stack-size}
@opindex mstack-guard
@opindex mstack-size
これらのオプションが提供されている場合、S/390バックエンドは、スタック・サイズが@var{stack-size}よりも@var{stack-guard}バイト大きい場合、トラップを起動する追加の命令を関数プロローグに出す。（S/390ではスタックが下向きに成長することを思い出すこと）。@var{stack-guard}オプションを省略すると、コンパイルされた関数のフレームサイズよりも大きな2の最小の累乗が選択される。これらのオプションは、スタックオーバーフローの問題のデバッグに役立つ。追加的に放出されるコードは、わずかなオーバーヘッドしか生じさせず、従って、より性能低下のない生産様のシステムにおいても使用されることも可能である。。与えられた値は正確な2のべき乗でなければならず、@var{stack-size}は64kを超えてはならず、@var{stack-guard}より大きくなければならない。効率を上げるために、余分なコードは、スタックが@var{stack-size}によって与えられた値に揃えられたアドレスで開始するという前提を作る。

@item -mhotpatch=@var{pre-halfwords},@var{post-halfwords}
@opindex mhotpatch
ホットパッチオプションを有効にすると、コンパイルユニット内のすべての関数に対して "ホットパッチ"機能のプロローグが生成される。funtionラベルには、指定された2バイトのNOP命令（@var{pre-halfwords}、最大1000000）が付加される。ラベルの後には、アーキテクチャーが許す最大のNOP命令（最大1000000）を使用して、2 * @var{post-halfwords}バイトが追加される。

両方の引数がゼロの場合、ホットパッチは無効になる。

このオプションは、@code{hotpatch}属性を持つ個々の関数に対してオーバーライドできる。
@end table

@node Score Options
@subsection Scoreオプション
@cindex Score Options

これらのオプションは、Score実装で定義されている。

@table @gcctabopt
@item -meb
@opindex meb
ビッグエンディアンモード用にコードをコンパイルする。これがデフォルトである。

@item -mel
@opindex mel
リトルエンディアンモード用にコードをコンパイルする。

@item -mnhwloop
@opindex mnhwloop
@code{bcnz}命令の生成を無効化する。

@item -muls
@opindex muls
アラインされていないロードおよびストア命令の生成を有効にする。

@item -mmac
@opindex mmac
乗加算命令の使用を有効にする。 デフォルトでは無効である。

@item -mscore5
@opindex mscore5
ターゲットアーキテクチャとしてSCORE5を指定する。

@item -mscore5u
@opindex mscore5u
ターゲットアーキテクチャとしてSCORE5Uを指定する。

@item -mscore7
@opindex mscore7
ターゲットアーキテクチャとしてSCORE7を指定する。これはデフォルトである。

@item -mscore7d
@opindex mscore7d
ターゲットアーキテクチャとしてSCORE7Dを指定する。
@end table

@node SH Options
@subsection SHオプション

これらの@samp {-m}オプションはSH実装で定義されている。

@table @gcctabopt
@item -m1
@opindex m1
SH1用のコードを生成する。

@item -m2
@opindex m2
SH2用のコードを生成する。

@item -m2e
SH2e用のコードを生成する。

@item -m2a-nofpu
@opindex m2a-nofpu
FPUを使用しないSH2a、または浮動小数点ユニットが使用されないSH2a-FPU用のコードを生成する。

@item -m2a-single-only
@opindex m2a-single-only
倍精度浮動小数点演算が使用されないSH2a-FPU用のコードを生成する。

@item -m2a-single
@opindex m2a-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH2a-FPU用のコードを生成する。

@item -m2a
@opindex m2a
浮動小数点ユニットがデフォルトで倍精度モードであると仮定して、SH2a-FPU用のコードを生成する。

@item -m3
@opindex m3
SH3用のコードを生成する。

@item -m3e
@opindex m3e
SH3e用のコードを生成する。

@item -m4-nofpu
@opindex m4-nofpu
浮動小数点ユニットなしのSH4用のコードを生成する。

@item -m4-single-only
@opindex m4-single-only
単精度演算のみをサポートする浮動小数点ユニットを使用したSH4用のコードを生成する。

@item -m4-single
@opindex m4-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4用のコードを生成する。

@item -m4
@opindex m4
SH4用のコードを生成する。

@item -m4-100
@opindex m4-100
SH4-100用のコードを生成する。

@item -m4-100-nofpu
@opindex m4-100-nofpu
浮動小数点ユニットを使用しないでSH4-100用のコードを生成する。

@item -m4-100-single
@opindex m4-100-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4-100用のコードを生成する。

@item -m4-100-single-only
@opindex m4-100-single-only
倍精度浮動小数点演算を使用しないでSH4-100用のコードを生成する。

@item -m4-200
@opindex m4-200
SH4-200用のコードを生成する。

@item -m4-200-nofpu
@opindex m4-200-nofpu
浮動小数点ユニットを使用しないでSH4-200のコードを生成する。

@item -m4-200-single
@opindex m4-200-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4-200のコードを生成する。

@item -m4-200-single-only
@opindex m4-200-single-only
倍精度浮動小数点演算を使用しないでSH4-200のコードを生成する。

@item -m4-300
@opindex m4-300
SH4-300用のコードを生成する。

@item -m4-300-nofpu
@opindex m4-300-nofpu
浮動小数点ユニットを使用しないでSH4-300のコードを生成する。

@item -m4-300-single
@opindex m4-300-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4-300のコードを生成する。

@item -m4-300-single-only
@opindex m4-300-single-only
倍精度浮動小数点演算を使用しないでSH4-300のコードを生成する。

@item -m4-340
@opindex m4-340
SH4-340用のコードを生成する（MMUなし、FPUなし）。

@item -m4-500
@opindex m4-500
SH4-500（FPUなし）用のコードを生成します。 @option{-isa=sh4-nofpu}をアセンブラに渡す。

@item -m4a-nofpu
@opindex m4a-nofpu
浮動小数点ユニットを使用しないでSH4al-dspまたはSH4a用のコードを生成する。

@item -m4a-single-only
@opindex m4a-single-only
倍精度浮動小数点演算を使用しないでSH4a用のコードを生成します。

@item -m4a-single
@opindex m4a-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4a用のコードを生成する。

@item -m4a
@opindex m4a
SH4a用のコードを生成する。

@item -m4al
@opindex m4al
@option{-m4a-nofpu}と同じだが、暗黙的に@option{-dsp}がアセンブラに渡さる。 GCCは現時点ではDSP命令を生成しない。

@item -mb
@opindex mb
ビッグエンディアンモードでプロセッサのコードをコンパイルする。

@item -ml
@opindex ml
リトルエンディアンモードでプロセッサのコードをコンパイルする。

@item -mdalign
@opindex mdalign
64ビット境界で倍精度を整列させる。 これは呼び出し規約を変更するので、標準Cライブラリの一部の関数は、@option{-mdalign}で最初に再コンパイルしないと機能しない。

@item -mrelax
@opindex mrelax
可能であれば、リンク時にいくつかのアドレス参照を短くする。 リンカオプション@option{-relax}を使用する。

@item -mbigtable
@opindex mbigtable
@code{switch}テーブルでは32ビットのオフセットを使用する。 デフォルトでは、16ビットのオフセットが使用される。

@item -mbitops
@opindex mbitops
SH2Aでビット操作命令を使用できるようにする。

@item -mfmovd
@opindex mfmovd
命令@code{fmovd}の使用を有効にする。 整列の制約については、@option{-mdalign}を確認せよ。

@item -mrenesas
@opindex mrenesas
ルネサスが定めた呼び出し規約に従う。

@item -mno-renesas
@opindex mno-renesas
ルネサスの規約が利用可能になる前に、GCC用に定義された呼び出し規約に従う。 このオプションは、SHツールチェーンのすべてのターゲットのデフォルトである。

@item -mnomacsave
@opindex mnomacsave
@option{-mrenesas}が指定されていても、@code{MAC}レジスタに呼び出しで破壊されるとマークする。

@item -mieee
@itemx -mno-ieee
@opindex mieee
@opindex mno-ieee
浮動小数点比較のIEEE準拠を制御する。比較の結果が順序付けられていない場合の処理に影響する。デフォルトでは、@option{-mieee}は暗黙的に有効になっている。@option{-ffinite-math-only}を有効にすると、@option{-mno-ieee}が暗黙的に設定される。その結果、より高速の浮動小数点のより大きな等価比較とより小さい等しい比較が行われる。 暗黙の設定は、@option{-mieee}または@option{-mno-ieee}のいずれかを指定することによって上書きできる。

@item -minline-ic_invalidate
@opindex minline-ic_invalidate
ネストされた関数トランポリンを設定した後に命令キャッシュエントリを無効にするコードをインライン化する。@option{-musermode}が有効で、選択されたコード生成オプション（@option{-m4}など）で@code{icbi}命令を使用できない場合、このオプションは無効である。選択されたコード生成オプションが@code{icbi}命令の使用を許可せず、@option{-musermode}が有効でない場合、インラインコードは命令キャッシュアドレス配列を連想書き込みで直接操作する。これは、実行時に特権モードを必要とするだけでなく、キャッシュラインが元々TLBを介してマップされていて、マップされなくなった場合にも失敗する。

@item -misize
@opindex misize
アセンブリコードの命令サイズと位置をダンプする。

@item -mpadstruct
@opindex mpadstruct
このオプションは非推奨である。 SH ABIと互換性のない4バイトの倍数に構造体を埋め込む。

@item -matomic-model=@var{model}
@opindex matomic-model=@var{model}
アトミック操作のモデルと追加パラメータをコンマ区切りのリストとして設定する。アトミック組み込み関数の詳細については、@ref {__atomic Builtins}を参照せよ。  次のモデルとパラメータがサポートされている。

@table @samp

@item none
コンパイラが生成したアトミック操作を無効にし、アトミック操作のライブラリ呼び出しを発行する。 ターゲットが@code {sh*-*-linux*}でない場合、これがデフォルトである。

@item soft-gusa
アトミック組み込み関数用のGNU/Linux互換gUSAソフトウェアのアトミック列を生成する。生成されたアトミック列は、システムの割り込み/例外処理コードからの追加サポートを必要とし、SH3*およびSH4*シングルコアシステムにのみ適している。このオプションは、ターゲットが@code{sh*-*-linux*}とSH3*またはSH4*の場合、デフォルトで有効になる。ターゲットがSH4Aの場合、このオプションは@samp{strict}が指定されていない限り、ハードコードの原子命令@code{movli.l}と@code{movco.l}を部分的に利用してより効率的なコードを作成する。

@item soft-tcb
スレッド制御ブロック内の変数を使用するソフトウェアのアトミック列を生成する。これは、SH1*およびSH2*ターゲットでも使用できるgUSAシーケンスのバリエーションである。生成されたアトミック列は、システムの割り込み/例外処理コードからの追加サポートを必要とし、シングルコアシステムにのみ適している。このモデルを使用する場合、@samp{gbr-offset=}パラメータも指定する必要がある。

@item soft-imask
@code{SR.IMASK=1111}を設定して、一時的に割り込みを無効にするソフトウェアのアトミック列を生成する。このモデルは、プログラムが特権モードで動作し、シングルコアシステムにのみ適している場合にのみ機能する。システムの割り込み/例外処理コードからの追加のサポートは必要ない。 このモデルは、ターゲットが@code{sh*-*-linux*}とSH1*またはSH2*の場合、デフォルトで有効になる。

@item hard-llcs
@code{movli.l}命令と@code{movco.l}命令のみを使用して、ハードウェアアトミック列を生成する。これはSH4Aでのみ利用可能で、マルチコアシステムに適している。ハードウェア命令は32ビットのアトミック変数のみをサポートするため、8または16ビット変数へのアクセスは32ビットアクセスでエミュレートされる。このオプションでコンパイルされたコードは、SH4Aシステム上で実行される場合、他のソフトウェアアトミックモデル割り込み/例外処理システムとも互換性がある。このモデルでは、システムの割り込み/例外処理コードの追加サポートは必要ない。

@item gbr-offset=
このパラメータは、@samp{soft-tcb}モデルが選択されているときに、生成されたアトミック列によって使用されるスレッド制御ブロック構造内の変数のオフセットをバイト単位で指定する。他のモデルの場合、このパラメータは無視される。 指定する値は、4の整数倍で、0〜1020の範囲で指定する必要がある。

@item strict
このパラメータは、互換性があっても複数のアトミックモデルを混在して使用することを防ぎ、指定されたモデルのアトミック列のみをコンパイラに生成させる。

@end table

@item -mtas
@opindex mtas
@code{__atomic_test_and_set}の@code{tas.b}オペコードを生成する。特定のハードウェアとソフトウェアの設定によっては、@code{tas.b}命令によって暗示されるオペランドキャッシュラインフラッシュによって全体的なパフォーマンスが低下する可能性があることに注意せよ。マルチコアSH4Aプロセッサでは、特定のキャッシュ構成でデータが破損する可能性があるため、@code{tas.b}命令は慎重に使用する必要がある。

@item -mprefergot
@opindex mprefergot
位置に依存しないコードを生成する場合は、プロシージャのリンケージテーブルの代わりにグローバルオフセットテーブルを使用して関数呼び出しを発行する。

@item -musermode
@itemx -mno-usermode
@opindex musermode
@opindex mno-usermode
特権モードコードを生成するコンパイラを許可するい（しない）。 @option{-musermode}を指定すると、インラインコードがユーザモードで動作しない場合は、@option{-mno-inline-ic_invalidate}も意味する。 targetが@code{sh*-*-linux*}の場合、@option{-musermode}がデフォルトである。ターゲットがSH1*またはSH2*の場合、@option{-musermode}は効果がない。なぜなら、ユーザーモードがないからである。

@item -multcost=@var{number}
@opindex multcost=@var{number}
乗算命令の想定コストを設定します。

@item -mdiv=@var{strategy}
@opindex mdiv=@var{strategy}
整数除算操作に使用する除算ストラテジーを設定する。 @var{strategy}は次のいずれかである

@table @samp

@item call-div1
単一ステップ除算命令@code{div1}を使用して操作を実行するライブラリ関数を呼び出す。 ゼロ除算は、不特定の結果を計算し、トラップしまない。 これは、SH4、SH2A、およびSHcompactを除くデフォルトである。

@item call-fp
倍精度浮動小数点で演算を実行するライブラリ関数を呼び出す。 ゼロ除算は浮動小数点例外を発生させる。 これはFPUを使用するSHcompactのデフォルトである。 倍精度FPUを持たないターゲットに対してこれを指定すると、デフォルトで@code{call-div1}になる。

@item call-table
小さな除数のルックアップテーブルと@code{div1}命令を使用するライブラリ関数を呼び出し、大きな除数の場合を分岐する。ゼロ除算は、不特定の結果を計算し、トラップしない。これはSH4のデフォルトである。 動的シフト命令を持たないターゲットに対してこれを指定すると、デフォルトでは@code{call-div1}になる。

@end table

分割戦略が指定されていない場合、現在のターゲットに基づいてデフォルト戦略が選択される。 SH2Aの場合、デフォルトの戦略は、ライブラリ関数呼び出しの代わりに@code{divs}命令と@code{divu}命令を使用することである。

@item -maccumulate-outgoing-args
@opindex maccumulate-outgoing-args
各呼び出しの周りではなく、関数のプロローグで発信する引数用に一度スペースを予約する。 パフォーマンスとサイズには一般的に有益である。 また、条件コードの周りのスタックフレームを変更しないようにするための巻き戻しのためにも必要である。

@item -mdivsi3_libfunc=@var{name}
@opindex mdivsi3_libfunc=@var{name}
32ビット符号付き除算に使用するライブラリ関数の名前を@var{name}に設定する。
これは、@samp{call}除算戦略で使用される名前にのみ影響し、このオプションが存在しない場合と同じように、コンパイラは入力/出力/破壊されるレジスタの同じセットを引き続き予測する。

@item -mfixed-range=@var{register-range}
@opindex mfixed-range
与えられたレジスタ範囲を固定レジスタとして扱うコードを生成する。固定レジスタは、レジスタアロケータが使用できないレジスタである。 カーネルコードをコンパイルするときに便利である。レジスタ範囲は、ダッシュで区切られた2つのレジスタとして指定される。カンマで区切って複数のレジスタ範囲を指定することができる。

@item -mbranch-cost=@var{num}
@opindex mbranch-cost=@var{num}
@var{num}を分岐命令のコストと仮定する。可能であれば、より多くのブランチなしのコードを生成しようとする。
指定されていない場合は、コンパイル対象のプロセッサタイプに応じて値が選択される。

@item -mzdcbranch
@itemx -mno-zdcbranch
@opindex mzdcbranch
@opindex mno-zdcbranch
ゼロ置換条件分岐命令@code{bt}と@code{bf}が高速であると仮定する（しない）。@option {-mzdcbranch}を指定すると、コンパイラはゼロ変位分岐コードシーケンスを優先する。これは、SH4とSH4Aのコードを生成するときにデフォルトで有効になる。@option{-mno-zdcbranch}を指定することによって明示的に無効にすることができる。

@item -mcbranch-force-delay-slot
@opindex mcbranch-force-delay-slot
条件付きブランチのための遅延スロットの使用を強制する。これは、適切な命令が見つからない場合、遅延スロットに@code{nop}を詰め込む。デフォルトでは、このオプションは無効になっている。 オリジナルSH7055のハードウェアバグを回避することができる。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点乗加算命令を使用する（しない）コードを生成する。ハードウェア浮動小数点が使用されている場合、これらの命令はデフォルトで生成される。マシンに依存する@option{-mfused-madd}オプションは、マシンに依存しない@option{-ffp-contract=fast}オプションにマップされ、@option{-mno-fused-madd}は@option{-ffp-contract=off}を指定する。

@item -mfsca
@itemx -mno-fsca
@opindex mfsca
@opindex mno-fsca
コンパイラが正弦および余弦の近似のために@code{fsca}命令を出すのを許可する、または許可しない。オプション@option{-mfsca}は、@option{-funsafe-math-optimizations}と組み合わせて使用する必要がある。SH4A用のコードを生成するときは、デフォルトで有効になっている。@option{-mno-fsca}を使用すると、@option{-funsafe-math-optimizations}が有効な場合でも正弦と余弦の近似は無効になる。

@item -mfsrra
@itemx -mno-fsrra
@opindex mfsrra
@opindex mno-fsrra
コンパイラが逆平方根近似のために@code{fsrra}命令を出すのを許可する、または許可しない。
オプション@option{-mfsrra}は、@option{-funsafe-math-optimizations}および@option{-ffinite-math-only}と組み合わせて使用する必要がある。SH4A用のコードを生成するときは、デフォルトで有効になっている。@option{-mno-fsrra}を使用すると、@option{-funsafe-math-optimizations}と@option{-ffinite-math-only}が有効な場合でも、逆数平方根近似が無効になる。

@item -mpretend-cmove
@opindex mpretend-cmove
条件付き移動命令パターンのゼロ変位条件分岐を優先する。 これにより、SH4プロセッサでより高速なコードが生成される可能性がある。

@item -mfdpic
@opindex fdpic
FDPIC ABIを使用してコードを生成する。

@end table

@node Solaris 2 Options
@subsection Solaris 2オプション
@cindex Solaris 2 options

これらの@samp {-m}オプションは、Solaris 2でサポートされている。

@table @gcctabopt
@item -mclear-hwcap
@opindex mclear-hwcap
@option{-mclear-hwcap}は、Solarisアセンブラによって生成されたハードウェア機能を削除するようコンパイラに指示する。  これは、オブジェクトファイルが現在のマシンでサポートされていないISA拡張機能を使用する場合にのみ必要だが、実行時にそれらを使用するかどうかを確認せよ。

@item -mimpure-text
@opindex mimpure-text
@option{-mared-text}は、@option{-shared}に加えて、共有オブジェクトをリンクするときに@option{-z text}をリンカに渡さないようコンパイラに指示する。 このオプションを使用すると、位置依存のコードを共有オブジェクトにリンクできる。

@option{-mimpure-text}は、「再配置は割り当て可能だが書き込み不可能なセクションに残る」リンカーエラーメッセージを抑制する。ただし、必要な再配置によってコピーオンライトが開始され、共有オブジェクトは実際にはプロセス間で共有されない。 @option{-mimpure-text}を使用する代わりに、すべてのソースコードを@option{-fpic}または@option{-fPIC}でコンパイルする必要がある。

@end table

これらのスイッチは、Solaris 2で上記に加えてサポートされている。

@table @gcctabopt
@item -pthreads
@opindex pthreads
これは@option{-pthread}の同義語である。
@end table

@node SPARC Options
@subsection SPARCオプション
@cindex SPARC options

これらの@samp {-m}オプションは、SPARCでサポートされている。

@table @gcctabopt
@item -mno-app-regs
@itemx -mapp-regs
@opindex mno-app-regs
@opindex mapp-regs
SPARC SVR4 ABIがアプリケーション用に予約するグローバルレジスタ2～4を使用して出力を生成するには、@option{-mapp-regs}を指定する。 グローバル・レジスタ1と同様に、各グローバル・レジスタ2～4は、関数呼び出しによって保護される割り当て可能なレジスタとして扱われる。 これがデフォルトである。

一部のパフォーマンス低下を犠牲にして完全にSVR4 ABIに準拠するには、@option{-mno-app-regs}を指定する。 このオプションでライブラリとシステムソフトウェアをコンパイルする必要がある。

@item -mflat
@itemx -mno-flat
@opindex mflat
@opindex mno-flat
@option{-mflat}では、コンパイラは保存/復元命令を生成せず、 「フラット」またはシングルレジスタウィンドウモデルを使用する。このモデルは、正規のレジスタウィンドウモデルと互換性がある。ローカルレジスタおよび入力レジスタ（0～5）は、依然として「コールセーブされた」レジスタとして扱われ、必要に応じてスタックに保存される。

@option{-mno-flat}（デフォルト）では、コンパイラは保存/復元命令を生成する（リーフ関数を除く）。これは通常の動作モードである。

@item -mfpu
@itemx -mhard-float
@opindex mfpu
@opindex mhard-float
浮動小数点命令を含む出力を生成する。 これがデフォルトである。

@item -mno-fpu
@itemx -msoft-float
@opindex mno-fpu
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含む出力を生成する。@strong{注意：}必要なライブラリは、すべてのSPARCターゲットで利用できるわけではない。通常、マシンの通常のCコンパイラの機能が使用されるが、これはクロスコンパイルで直接行うことはできない。クロスコンパイルに適したライブラリ関数を提供するために、独自の手配をしなければならない。 埋め込みターゲット@samp{sparc-*-aout}と@samp{sparclite-*-*}は、ソフトウェア浮動小数点サポートを提供する。

@option{-msoft-float}は、出力ファイルの呼び出し規約を変更する。 したがって、このオプションでプログラムの@emph{すべて}をコンパイルする場合にのみ有用である。特に、GCCに付属のライブラリである@file{libgcc.a}を@option{-msoft-float}とコンパイルする必要がある。

@item -mhard-quad-float
@opindex mhard-quad-float
クワッドワード（long double）浮動小数点命令を含む出力を生成する。

@item -msoft-quad-float
@opindex msoft-quad-float
クワッドワード（long double）浮動小数点命令のライブラリ呼び出しを含む出力を生成する。 呼び出される関数はSPARC ABIで指定された関数である。これがデフォルトである。

この記事の執筆時点では、クワッドワード浮動小数点命令のハードウェアをサポートするSPARC実装はないん。 これらの命令はいずれもこれらの命令のいずれかのトラップハンドラを呼び出し、トラップハンドラは命令の効果をエミュレートする。 トラップハンドラのオーバーヘッドのために、ABIライブラリルーチンを呼び出すよりもはるかに時間がかかる。 したがって、@option{-msoft-quad-float}オプションがデフォルトである。

@item -mno-unaligned-doubles
@itemx -munaligned-doubles
@opindex mno-unaligned-doubles
@opindex munaligned-doubles
倍精度は8バイトのアライメントを持つと仮定する。 これがデフォルトである。

@option{-munaligned-doubles}を指定すると、GCCは、それらが他の型に含まれているか、さもなければ絶対アドレスを保つ場合に限り、double型が8バイトのアライメントを持つとみなす。それ以外の場合は、4バイトのアライメントがあるとみなされる。このオプションを指定すると、他のコンパイラで生成されたコードとの稀な互換性の問題を回避できる。特に浮動小数点コードの場合、パフォーマンスが低下するため、デフォルトではない。

@item -muser-mode
@itemx -mno-user-mode
@opindex muser-mode
@opindex mno-user-mode
スーパーバイザモードでしか実行できないコードを生成しない。 これは、LEON3プロセッサ用に生成された@code{casa}命令にのみ関係する。 これがデフォルトである。

@item -mfaster-structs
@itemx -mno-faster-structs
@opindex mfaster-structs
@opindex mno-faster-structs
@option {-mfaster-structs}を使用すると、構造体は8バイトの境界整列を持つ必要があるとコンパイラは想定する。これにより、@code{ld}と@code{st}の2倍の代わりに、構造割り当てのコピーに@code{ldd}命令と@code{std}命令のペアを使用することができる。ただし、この変更されたアラインメントの使用は、SPARC ABIに直接違反する。したがって、開発者が結果のコードがABIのルールに直接沿ったものではないことを認識しているターゲットでのみ使用することを意図している。

@item -mstd-struct-return
@itemx -mno-std-struct-return
@opindex mstd-struct-return
@opindex mno-std-struct-return
コンパイラは、@option{-mstd-struct-return}を使用して、構造体または共用体を返す関数にチェックコードを生成し、32ビットABIのように関数呼び出しの両側のサイズの不一致を検出する。

デフォルトは@option{-mno-std-struct-return}である。 このオプションは、64ビットモードでは効果がない。

@item -mlra
@itemx -mno-lra
@opindex mlra
@opindex mno-lra
ローカルレジスタ割り付けを有効にする。 これはGCC 7以降のSPARCのデフォルトのため、古いリロードを得るためには@option{-mno-lra}を渡す必要がある。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var {cpu_type}の命令セット、レジスタセット、および命令スケジューリングパラメータを設定する。 @var{cpu_type}のサポートされている値は@samp{v7}, @samp{cypress}, @samp{v8}, @samp{supersparc}, @samp{hypersparc}, @samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{sparclite}, @samp{f930}, @samp{f934}, @samp{sparclite86x}, @samp{sparclet}, @samp{tsc701}, @samp{v9}, @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3}, @samp{niagara4}, @samp{niagara7}, @samp{m8}である。

ネイティブSolarisおよびGNU/Linuxツールチェーンは、@samp{native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。GCCがプロセッサを認識しない場合、@option{-mcpu=native}は効果がない。

デフォルトの命令スケジューリングパラメータは、アーキテクチャを選択する値であり、実装ではない。 これらは@samp{v7}、@samp{v8}、@samp{sparclite}、@samp{sparclet}、@samp{v9}である。

サポートされている各アーキテクチャとサポートされている実装の一覧を示す。

@table @asis
@item v7
cypress, leon3v7

@item v8
supersparc, hypersparc, leon, leon3

@item sparclite
f930, f934, sparclite86x

@item sparclet
tsc701

@item v9
ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4,
niagara7, m8
@end table

デフォルトでは（別途設定されていない限り）、GCCはSPARCアーキテクチャのV7版のコードを生成する。 @option{-mcpu=cypress}を使用すると、コンパイラはSPARCStation/SPARCServer 3xxシリーズで使用されているCypress CY7C602チップ用に最適化する。これは古いSPARCStation 1,2、IPXなどにも適している。

@option{-mcpu=v8}を指定すると、GCCはSPARCアーキテクチャのV8版のコードを生成する。 V7コードとの唯一の違いは、コンパイラがSPARC-V8には存在し、SPARC-V7には存在しない整数乗算命令と整数除算命令を発行することである。 @option{-mcpu=supersparc}を指定すると、コンパイラはSPARCStation 10,1000,2000シリーズで使用されているように、SuperSPARCチップ用にコンパイラを最適化する。

@option{-mcpu=sparclite}を使用すると、GCCはSPARCアーキテクチャのSPARCliteバリアントのコードを生成する。これによりSPARCliteには存在するが、SPARC-V7には存在しない整数の乗算、整数除算のステップとスキャン（@code{ffs}）命令が追加される。@option {-mcpu=f930}を使用すると、コンパイラは元のSPARCliteであるFujitsu MB86930チップ（FPUなし）に最適化する。@option{-mcpu=f934}を指定すると、FPU付きのSPARCliteであるFujitsu MB86934チップ用に最適化される。

@option{-mcpu=sparclet}を使用すると、GCCはSPARCアーキテクチャのSPARCletバリアントのコードを生成する。これにより、SPARCletには存在するが、SPARC-V7には存在しない整数の乗算、乗算/累積、整数除算のステップとスキャン（@code{ffs}）命令が追加される。 @option{-mcpu=tsc701}では、TEMIC SPARCletチップ用に最適化されている。

@option {-mcpu=v9}を指定すると、GCCはSPARCアーキテクチャのV9版のコードを生成する。これにより、64ビット整数および浮動小数点移動命令、3つの追加浮動小数点条件コード・レジスタおよび条件付き移動命令が追加される。@option{-mcpu=ultrasparc}を使用すると、コンパイラはSun UltraSPARC I/II/IIiチップ用にコンパイラを最適化する。@option{-mcpu=ultrasparc}を使用すると、コンパイラはSun UltraSPARC I/II/IIiチップ用にコンパイラを最適化する。 @option{-mcpu=ultrasparc3}を使用すると、コンパイラはSun UltraSPARC III/III+/IIIi+/IV/IV+チップ用にコンパイラを最適化する。@option{-mcpu=niagara}を使用すると、コンパイラはSun UltraSPARC T1チップ用にコンパイラを最適化する。@option{-mcpu=niagara2}を使用すると、コンパイラはSun UltraSPARC T2チップ用にコンパイラを最適化する。@option{-mcpu=niagara3}では、コンパイラはSun UltraSPARC T3チップ用にコンパイラを最適化する。@option{-mcpu=niagara4}では、コンパイラはSun UltraSPARC T4チップ用にコンパイラを最適化する。@option{-mcpu=niagara7}を使用すると、コンパイラはOracle SPARC M7チップ用にコンパイラを最適化する。 @option{-mcpu=m8}を指定すると、コンパイラはOracle M8チップ用にコンパイラを最適化する。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var {cpu_type}の命令スケジューリングパラメータを設定するが、オプション@option{-mcpu=@var{cpu_type}}が実行する命令セットまたはレジスタセットは設定しない。

@option{-mcpu=@var{cpu_type}}と同じ値を@option{-mtune=@var{cpu_type}}に使用できるが、唯一有用な値は特定のCPU実装を選択する値であるす。それらは@samp{cypress}, @samp{supersparc}, @samp{hypersparc}, @samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{f930}, @samp{f934}, @samp{sparclite86x}, @samp{tsc701}, @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3}, @samp{niagara4}, @samp{niagara7}, @samp{m8}である。 ネイティブのSolarisおよびGNU/Linuxツールチェーンでは、@samp{native}も使用できる。 

@item -mv8plus
@itemx -mno-v8plus
@opindex mv8plus
@opindex mno-v8plus
@option{-mv8plus}を指定すると、GCCはSPARC-V8+ ABI用のコードを生成する。 V8 ABIとの違いは、グローバルレジスタとアウトレジスタが64ビット幅とみなされることである。これは、すべてのSPARC-V9プロセッサで32ビットモードのSolarisでデフォルトで有効になる。

@item -mvis
@itemx -mno-vis
@opindex mvis
@opindex mno-vis
@option{-mvis}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張機能を利用するコードを生成する。デフォルトは@option{-mno-vis}である。

@item -mvis2
@itemx -mno-vis2
@opindex mvis2
@opindex mno-vis2
@option{-mvis2}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン2.0を利用するコードを生成する。UltraSPARC-III以降など、そのような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mvis2}である。

@item -mvis3
@itemx -mno-vis3
@opindex mvis3
@opindex mno-vis3
@option{-mvis3}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン3.0を利用するコードを生成する。niagara-3以降のような命令をサポートしているCPUを対象とする場合、デフォルトは@option{-mvis3}である。@option{-mvis3}を設定すると、@option{-mvis2}と@option{-mvis}も設定される。

@item -mvis4
@itemx -mno-vis4
@opindex mvis4
@opindex mno-vis4
@option{-mvis4}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン4.0を利用するコードを生成する。 niagara-7以降のような命令をサポートしているCPUを対象にする場合、デフォルトは@option{-mvis4}である。 @option{-mvis4}を設定すると、@option{-mvis3}、@option{-mvis2}、@option{-mvis}も設定される。

@item -mvis4b
@itemx -mno-vis4b
@opindex mvis4b
@opindex mno-vis4b
@option{-mvis4b}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン4.0と、Oracle SPARC Architecture 2017で導入された追加のVIS命令を利用するコードを生成する。 m8以降のような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mvis4b}である。 @option{-mvis4b}を設定すると、@option{-mvis4}、@option{-mvis3}、@option{-mvis2}、@option{-mvis}も設定される。

@item -mcbcond
@itemx -mno-cbcond
@opindex mcbcond
@opindex mno-cbcond
@option{-mcbcond}を指定すると、GCCはUltraSPARC条件つきコンペア・アンド・ブランチ命令を利用したコードを生成する。 Niagara-4以降のような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mcbcond}である。

@item -mfmaf
@itemx -mno-fmaf
@opindex mfmaf
@opindex mno-fmaf
@option{-mfmaf}を使用すると、GCCは、UltraSPARC 乗加算融合浮動小数点命令を利用するコードを生成する。 Niagara-3以降のような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mfmaf}である。

@item -mfsmuld
@itemx -mno-fsmuld
@opindex mfsmuld
@opindex mno-fsmuld
@option{-mfsmuld}を使用すると、GCCは浮動小数点倍精度単精度（FsMULd）命令を利用するコードを生成する。@option{-mcpu=leon}を除くFPUでアーキテクチャバージョンV8またはV9をサポートしているCPUを対象とする場合、デフォルトは@option{-mfsmuld}である。

@item -mpopc
@itemx -mno-popc
@opindex mpopc
@opindex mno-popc
@option{-mpopc}を指定すると、GCCはUltraSPARC Population Count命令を利用するコードを生成する。Niagara-2以降のような命令をサポートしているCPUを対象とする場合、デフォルトは@option{-mpopc}である。

@item -msubxc
@itemx -mno-subxc
@opindex msubxc
@opindex mno-subxc
@option{-msubxc}を使用すると、GCCはUltraSPARC キャリー減算拡張命令を利用したコードを生成する。Niagara-7以降のような命令をサポートしているCPUを対象とする場合、デフォルトは@option{-msubxc}である。

@item -mfix-at697f
@opindex mfix-at697f
Atmel AT697Fプロセッサの単一のエラッタ（AT697Eプロセッサのエラータ＃13に対応）について、文書化された回避策を有効にする。

@item -mfix-ut699
@opindex mfix-ut699
UT699プロセッサの浮動小数点エラッタとデータキャッシュ無効化エラータについて、文書化された回避策を有効にする。

@item -mfix-ut700
@opindex mfix-ut700
UT699E/UT700プロセッサのバックツーバックストアエラッタについて、文書化された回避策を有効にする。

@item -mfix-gr712rc
@opindex mfix-gr712rc
GR712RCプロセッサのバックツーバックストアエラッタについて、文書化された回避策を有効にする。
@end table

これらの@samp{-m}オプションは、上記の64ビット環境のSPARC-V9プロセッサでサポートされている。

@table @gcctabopt
@item -m32
@itemx -m64
@opindex m32
@opindex m64
32ビットまたは64ビット環境用のコードを生成します。32ビット環境はint、long、およびポインタを32ビットに設定する。64ビット環境ではintを32ビット、longとポインタ64ビットに設定する。

@item -mcmodel=@var{which}
@opindex mcmodel
コードモデルを次のいずれかに設定する。

@table @samp
@item medlow
中位/低コード・モデル：64ビット・アドレス、プログラムはメモリの低位32ビットにリンクする必要がある。 プログラムは静的または動的にリンクできる。

@item medmid
中位/中コードモデル：64ビットアドレス、プログラムはメモリの低位44ビットにリンクする必要がある。テキストとデータセグメントのサイズは2GB未満で、データセグメントはテキストセグメントの2GB以内に配置する必要がある。

@item medany
中位/任意コードモデル：64ビットアドレス、プログラムはメモリ内のどこにでもリンクできる。テキストとデータセグメントのサイズは2GB未満で、データセグメントはテキストセグメントの2GB以内に配置する必要がある。

@item embmedany
組み込みシステム用の中位/任意コードモデル：64ビットのアドレスでは、テキストセグメントとデータセグメントのサイズは2GB未満でなければならず、どちらもメモリ内の任意の場所（リンク時に決定）から開始する必要がある。  グローバル・レジスタ%g4は、データ・セグメントのベースを指す。プログラムは静的にリンクされており、PICはサポートされていない。
@end table

@item -mmemory-model=@var{mem-model}
@opindex mmemory-model
プロセッサの強制的なメモリモデルを次のいずれかに設定する。

@table @samp
@item default
プロセッサーとオペレーティングシステムのデフォルトのメモリーモデル。

@item rmo
緩和されたメモリ順序

@item pso
部分ストア順序

@item tso
完全ストア順序

@item sc
シーケンシャル一貫性
@end table

これらのメモリモデルは、プロセッサの@code{PSTATE.MM}フィールドで設定されているように、SPARC-V9アーキテクチャマニュアルの付録Dで正式に定義されている。

@item -mstack-bias
@itemx -mno-stack-bias
@opindex mstack-bias
@opindex mno-stack-bias
@option{-mstack-bias}を指定すると、GCCはスタックポインタとフレームポインタが存在すればそれを@minus{}2047でオフセットしているとみなす。これはスタックフレーム参照の際に追加する必要がある。 これは64ビットモードのデフォルトである。それ以外の場合は、そのようなオフセットが存在しないと仮定する。
@end table

@node System V Options
@subsection System Vオプション

これらの追加オプションは、System V Release 4で、これらのシステム上の他のコンパイラとの互換性のために利用できる。

@table @gcctabopt
@item -G
@opindex G
共有オブジェクトを作成する。代わりに@option{-symbolic}または@option{-shared}を使用することを推奨する。

@item -Qy
@opindex Qy
出力の@code{.ident}アセンブラ指示文で、コンパイラが使用する各ツールのバージョンを指定する。

@item -Qn
@opindex Qn
@code{.ident}ディレクティブを出力ファイルに追加しない（これがデフォルト）。

@item -YP,@var{dirs}
@opindex YP
ディレクトリ@var{dirs}を検索し、@option{-l}で指定されたライブラリを探す。

@item -Ym,@var{dir}
@opindex Ym
ディレクトリ@var{dir}を見て、M4プリプロセッサを見つけてる。アセンブラはこのオプションを使用する。
@c This is supposed to go with a -Yd for predefined M4 macro files, but
@c the generic assembler that comes with Solaris takes just -Ym.
@end table

@node TILE-Gx Options
@subsection TILE-Gxオプション
@cindex TILE-Gx options

これらの@samp {-m}オプションはTILE-Gxでサポートされている：

@table @gcctabopt
@item -mcmodel=small
@opindex mcmodel=small
小さなモデルのコードを生成する。直接呼び出しの距離はどちらの方向にも500Mに制限されている。PC相対アドレスは32ビットです。絶対アドレスは完全なアドレス範囲をサポートする。

@item -mcmodel=large
@opindex mcmodel=large
大型モデル用のコードを生成します。呼び出し距離、PC相対アドレス、または絶対アドレスに制限はない。

@item -mcpu=@var{name}
@opindex mcpu
ターゲットにするCPUのタイプを選択します。 現在サポートされているタイプは@samp{tilegx}のみである。

@item -m32
@itemx -m64
@opindex m32
@opindex m64
32ビットまたは64ビット環境用のコードを生成する。32ビット環境では、int、long、および32ビットへのポインタが設定される。64ビット環境ではintを32ビット、longとポインタを64ビットをに設定する。

@item -mbig-endian
@itemx -mlittle-endian
@opindex mbig-endian
@opindex mlittle-endian
ビッグ/リトルエンディアンモードでコードを生成します。
@end table

@node TILEPro Options
@subsection TILEProオプション
@cindex TILEPro options

これらの@samp{-m}オプションはTILEProでサポートされている：

@table @gcctabopt
@item -mcpu=@var{name}
@opindex mcpu
ターゲットにするCPUのタイプを選択する。 現在サポートされているタイプは@samp{tilepro}のみである。

@item -m32
@opindex m32
int、long、および32ビットへのポインタを設定する32ビット環境用のコードを生成する。 これはサポートされている唯一の動作なので、フラグは本質的に無視される。
@end table

@node V850 Options
@subsection V850オプション
@cindex V850 Options

これらの@samp{-m}オプションは、V850実装で定義されている。

@table @gcctabopt
@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
すべての呼び出しを遠く（近く）として扱う。 呼び出しが遠くにあると仮定すると、コンパイラは常に関数のアドレスをレジスタにロードし、ポインタを介して間接を呼び出す。

@item -mno-ep
@itemx -mep
@opindex mno-ep
@opindex mep
同じインデックスポインタを使用する基本ブロックを4回以上最適化（最適化）してポインタを@code{ep}レジスタにコピーし、より短い@code{sld}命令と@code{sst}命令を使用しない。@option{-mep}オプションは、最適化するとデフォルトでオンになっている。

@item -mno-prolog-function
@itemx -mprolog-function
@opindex mno-prolog-function
@opindex mprolog-function
関数のプロローグとエピローグでレジスタを保存および復元するために外部関数を使用しない（する）。 外部関数は遅くなるが、複数の関数が同じ数のレジスタを保存する場合は、より少ないコードスペースを使用する。 @option{-mprolog-function}オプションは、最適化するとデフォルトでオンになっている。

@item -mspace
@opindex mspace
できるだけコードを小さくしてみる。 現在のところ、これは@option{-mep}オプションと@option{-mprolog-function}オプションをオンにするだけである。

@item -mtda=@var{n}
@opindex mtda
@var{n}バイト以下の静的変数または大域変数を、@code{ep}の指す小さなデータ領域に入れる。小さなデータ領域は合計で256バイト（バイト参照の場合は128バイト）まで保持できる。

@item -msda=@var{n}
@opindex msda
@var{n}バイト以下の静的変数または大域変数を、@code{gp}を指す小さなデータ領域に入れる。 小さなデータ領域は64キロバイトまで保持できる。

@item -mzda=@var{n}
@opindex mzda
@var{n}バイト以下のサイズの静的変数または大域変数をメモリの最初の32キロバイトに入れる。

@item -mv850
@opindex mv850
ターゲット・プロセッサーがV850であることを指定する。

@item -mv850e3v5
@opindex mv850e3v5
ターゲット・プロセッサーがV850E3V5であることを指定する。 このオプションを使用すると、プリプロセッサ定数@code{__v850e3v5__}が定義される。

@item -mv850e2v4
@opindex mv850e2v4
ターゲット・プロセッサーがV850E3V5であることを指定する。 これは@option{-mv850e3v5}オプションのエイリアスである。

@item -mv850e2v3
@opindex mv850e2v3
ターゲット・プロセッサーがV850E2V3であることを指定する。 このオプションを使用すると、プリプロセッサ定数@code {__v850e2v3__}が定義される。

@item -mv850e2
@opindex mv850e2
ターゲット・プロセッサーがV850E2であることを指定する。 このオプションを使用すると、プリプロセッサ定数@code{__v850e2__}が定義される。

@item -mv850e1
@opindex mv850e1
ターゲット・プロセッサーがV850E1であることを指定する。 このオプションを使用すると、プリプロセッサの定数@code{__v850e1__}と@code{__v850e__}が定義される。

@item -mv850es
@opindex mv850es
ターゲット・プロセッサーがV850ESであることを指定する。 これは@option{-mv850e1}オプションのエイリアスである。

@item -mv850e
@opindex mv850e
ターゲット・プロセッサーがV850Eであることを指定する。このオプションを使用すると、プリプロセッサ定数@code{__v850e__}が定義される。

@option{-mv850}、@option{-mv850e}、@option{-mv850e1}、@option{-mv850e2}、および@option{-mv850e2v3}や@option{-mv850e3v5}のどれも定義されていない場合、デフォルトのターゲット・プロセッサが選択され、関連する@samp{__v850*__}プリプロセッサ定数が定義される。

プリプロセッサの定数@code{__v850}と@code{__v851__}は、ターゲットとなるプロセッサの種類に関係なく常に定義される。

@item -mdisable-callt
@itemx -mno-disable-callt
@opindex mdisable-callt
@opindex mno-disable-callt
このオプションは、v850アーキテクチャーのv850e、v850e1、v850e2、v850e2v3、およびv850e3v5フレーバーの@code {CALLT}命令の生成を抑制する。

このオプションは、RH850 ABIが使用されている場合（デフォルトでは@option{-mrh850-abi}を参照）、デフォルトで有効になっている。GCC ABIが使用されている場合、デフォルトでは無効になっている。 @code{CALLT}命令が生成されている場合、Cプリプロセッサシンボル@code{__V850_CALLT__}が定義される。

@item -mrelax
@itemx -mno-relax
@opindex mrelax
@opindex mno-relax
@option{-mrelax}コマンドラインオプションをアセンブラに渡す（渡さない）。

@item -mlong-jumps
@itemx -mno-long-jumps
@opindex mlong-jumps
@opindex mno-long-jumps
PC相対ジャンプ命令の生成を無効にする（または再び有効にする）。

@item -msoft-float
@itemx -mhard-float
@opindex msoft-float
@opindex mhard-float
ハードウェア浮動小数点命令の生成を無効にする（または再び有効にする）。 このオプションは、ターゲット・アーキテクチャーが@samp{V850E2V3}以上の場合にのみ重要である。 ハードウェア浮動小数点命令が生成されている場合は、Cプリプロセッサシンボル@code{__FPU_OK__}が定義される。そうでない場合、シンボル@code{__NO_FPU__}が定義される。

@item -mloop
@opindex mloop
e3v5 LOOP命令の使用を有効にする。 e3v5アーキテクチャが選択されている場合、その命令の使用はまだ実験的であるので、このデフォルトでは有効になっていない。

@item -mrh850-abi
@itemx -mghs
@opindex mrh850-abi
@opindex mghs
V850 ABIのRH850バージョンのサポートを有効にする。 これがデフォルトである。 このバージョンのABIでは、以下のルールが適用される。

@itemize
@item
整数サイズの構造体と共用体は、レジスタではなくメモリポインタを介して返される。

@item
大きな構造体と共用体（サイズが8バイト以上）は値渡しされる。

@item
関数は16ビットの境界に揃えられる。

@item
@option {-m8byte-align}コマンドラインオプションがサポートされる。

@item
@option {-mdisable-callt}コマンドラインオプションは、デフォルトで有効になっている。@option{-mno-disable-callt}コマンドラインオプションはサポートされていない。
@end itemize

このバージョンのABIを有効にすると、Cプリプロセッサシンボル@code{__V850_RH850_ABI__}が定義される。

@item -mgcc-abi
@opindex mgcc-abi
古いGCCバージョンのV850 ABIをサポートする。 このバージョンのABIでは、以下のルールが適用される。

@itemize
@item
整数サイズの構造体と共用体はレジスタ@code{r10}に返される。

@item
大きな構造体と共用体（サイズが8バイト以上）は、参照渡しされる。

@item
関数は、サイズを最適化しない限り、32ビットの境界に整列される。

@item
@option{-m8byte-align}コマンドラインオプションはサポートされていない。

@item
@option{-mdisable-callt}コマンドラインオプションはサポートされていないが、デフォルトでは有効になっていない。
@end itemize

このバージョンのABIを有効にすると、Cプリプロセッサシンボル@code{__V850_GCC_ABI__}が定義される。

@item -m8byte-align
@itemx -mno-8byte-align
@opindex m8byte-align
@opindex mno-8byte-align
@code{double}型と@code{long long}型を8バイトの境界に整列させるためのサポートを有効にする。 デフォルトでは、すべてのオブジェクトの配置を最大で4バイトに制限する。 @option{-m8byte-align}が有効な場合、Cプリプロセッサシンボル@code{__V850_8BYTE_ALIGN__}が定義される。

@item -mbig-switch
@opindex mbig-switch
大きなスイッチテーブルに適したコードを生成する。 このオプションは、アセンブラ/リンカがスイッチテーブル内の範囲外の分岐に不平を言う場合にのみ使用する。

@item -mapp-regs
@opindex mapp-regs
このオプションを指定すると、コンパイラによって生成されたコードでr2とr5が使用される。 この設定はデフォルトである。

@item -mno-app-regs
@opindex mno-app-regs
このオプションは、r2とr5を固定レジスタとして扱う。

@end table

@node VAX Options
@subsection VAXオプション
@cindex VAX options

これらの@samp{-m}オプションは、VAXに対して定義されている。

@table @gcctabopt
@item -munix
@opindex munix
VAXのUnixアセンブラが長距離で処理できない特定のジャンプ命令（@code{aobleq}など）を出力しない。

@item -mgnu
@opindex mgnu
GNUアセンブラが使用されていることを前提に、これらのジャンプ命令を出力する。

@item -mg
@opindex mg
D-フォーマットの代わりにG-フォーマット浮動小数点数のコードを出力する。
@end table

@node Visium Options
@subsection Visiumオプション
@cindex Visium options

@table @gcctabopt

@item -mdebug
@opindex mdebug
ファイルI/Oを実行し、MCMターゲット上で実行する予定のプログラムは、このオプションにリンクする必要がある。これにより、ライブラリlibc.aとlibdebug.aがリンクされる。プログラムは、GDBリモートデバッグスタブの制御下でターゲット上で実行する必要がある。

@item -msim
@opindex msim
ファイルI/Oを実行し、シミュレータ上で動作するように設計されたプログラムは、オプションつきでリンクする必要がある。 これにより、ライブラリlibc.aとlibsim.aがリンクされる。

@item -mfpu
@itemx -mhard-float
@opindex mfpu
@opindex mhard-float
浮動小数点命令を含むコードを生成する。 これがデフォルトである。

@item -mno-fpu
@itemx -msoft-float
@opindex mno-fpu
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含むコードを生成する。

@option{-msoft-float}は、出力ファイルの呼び出し規約を変更する。 したがって、このオプションでプログラムの@emph{すべて}をコンパイルする場合にのみ有用である。 特に、GCCに付属のライブラリである@file{libgcc.a}を@option{-msoft-float}とコンパイルする必要がある。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var{cpu_type}の命令セット、レジスタセット、および命令スケジューリングパラメータを設定する。 @var{cpu_type}にサポートされている値は@samp{mcm}、@samp{gr5}、@samp{gr6}である。

@samp{mcm}は、下位互換性のために存在する@samp{gr5}の同義語である。

既定では（別途設定されていない限り）、GCCはVisiumアーキテクチャのGR5バリアントのコードを生成する。

@option{-mcpu=gr6}を指定すると、GCCはVisiumアーキテクチャのGR6バリアントのコードを生成する。 GR5コードとの唯一の違いは、コンパイラがブロック移動命令を生成することである。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var{cpu_type}の命令スケジューリングパラメータを設定するが、@option{-mcpu=@var{cpu_type}}オプションが設定する命令セットまたはレジスタセットは設定しない。

@item -msv-mode
@opindex msv-mode
汎用レジスタへのアクセスに制限のないスーパバイザ・モード用のコードを生成します。 これがデフォルトである。

@item -muser-mode
@opindex muser-mode
いくつかの汎用レジスタへのアクセスが禁止されているユーザモード用のコードを生成する。GR5では、このモードではレジスタr24〜r31にアクセスできまない。 GR6では、レジスタr29〜r31のみが影響を受ける。
@end table

@node VMS Options
@subsection VMSオプション

これらの@samp{-m}オプションは、VMS実装に対して定義されている。

@table @gcctabopt
@item -mvms-return-codes
@opindex mvms-return-codes
@code{main}からVMS条件コードを返す。 デフォルトでは、POSIXスタイルの条件（たとえばエラー）コードが返される。

@item -mdebug-main=@var{prefix}
@opindex mdebug-main=@var{prefix}
@var{prefix}で始まる名前の最初のルーチンに、デバッガのメインルーチンとしてフラグを立てる。

@item -mmalloc64
@opindex mmalloc64
デフォルトは64ビットメモリ割り当てルーチンである。

@item -mpointer-size=@var{size}
@opindex mpointer-size=@var{size}
ポインタのデフォルトサイズを設定する。@var{size}の可能なオプションは、32ビットポインタの場合は@samp{32}または@samp{short}、64ビットポインタの場合は@samp{64}または@samp{long}、32ビットポインタのみをサポートする@samp{no}。後のオプションは@code{pragma pointer_size}を無効にする。
@end table

@node VxWorks Options
@subsection VxWorksオプション
@cindex VxWorks Options

このセクションのオプションは、すべてのVxWorksターゲットで定義されている。ターゲットハードウェアに固有のオプションは、そのターゲットの他のオプションとともにリストされる。

@table @gcctabopt
@item -mrtp
@opindex mrtp
GCCは、VxWorksカーネルとリアルタイムプロセス（RTP）の両方のコードを生成できる。 このオプションは前者から後者に切り替える。 また、プリプロセッサマクロ@code{__RTP__}も定義する。

@item -non-static
@opindex non-static
静的ライブラリではなく共有ライブラリに対してRTP実行可能ファイルをリンクする。 オプション@option{-static}と@option{-shared}はRTPにも使用できる（@pxref{Link Options}）。 @option{-static}がデフォルトである。

@item -Bstatic
@itemx -Bdynamic
@opindex Bstatic
@opindex Bdynamic
これらのオプションはリンカに渡される。 それらはDiabとの互換性のために定義されている。

@item -Xbind-lazy
@opindex Xbind-lazy
関数呼び出しの遅延バインドを有効にする。 このオプションは@option{-Wl,-z,now}に相当し、Diabとの互換性のために定義されている。

@item -Xbind-now
@opindex Xbind-now
関数呼び出しの遅延バインディングを無効にする。 このオプションはデフォルトであり、Diabとの互換性のために定義されている。
@end table

@node x86 Options
@subsection x86オプション
@cindex x86 Options

これらの@samp {-m}オプションは、x86ファミリのコンピュータで定義されている。

@table @gcctabopt

@item -march=@var{cpu-type}
@opindex march
機種@var{cpu-type}の命令を生成する。@option{-march=@var{cpu-type}}は、指定された@var{cpu-type}の生成コードをチューニングするだけで、@option{-march=@var{cpu-type}}は、 示されているプロセッサ以外のプロセッサではまったく動作しないコードを生成するためにGCCを使用する。@option{-march=@var{cpu-type}}を指定すると、@option{-mtune=@var{cpu-type}}となる。

@var{cpu-type}の選択肢は次のとおりである。

@table @samp
@item native
これにより、コンパイル時のコードを生成するCPUが選択され、コンパイルマシンのプロセッサタイプが決定される。@option{-march = native}を使用すると、ローカルマシンでサポートされているすべての命令サブセットが有効になる（したがって、結果は異なるマシンでは実行されない可能性がある。）@option{-mtune = native}を使用すると、選択した命令セットの制約の下でローカルマシン用に最適化されたコードが生成される。

@item x86-64
64ビット拡張機能を備えた汎用CPU。

@item i386
元々のi386CPU。

@item i486
Intel i486 CPU。 （このチップ用スケジューリングは実装されていない。）

@item i586
@itemx pentium
MMXサポートのないIntel Pentuim CPU。

@item lakemont
Intel Pentium CPUに基づいたIntel Lakemont MCU。

@item pentium-mmx
MMX命令セットサポートを持つPentuimコアに基づいたIntel Pentium MMX CPU。

@item pentiumpro
Intel Pentium Pro CPU。

@item i686
@option{-march}で使ったときは、Pentuim Pro命令セットが使われ、全i686ファミリチップ上で走るコードになる。@option{-mtune}で使ったときは、@samp{generic}と同じ意味である。

@item pentium2
MMX命令セットサポートを持つPentium Proコアに基づいたIntel Pentuim II CPU。

@item pentium3
@itemx pentium3m
MMXとSSEの命令セットサポートを持つPentium Proコアに基づいたIntel Pentuim II CPU。

@item pentium-m
Intel Pentuim M。MMX、SSE、SSE2命令セットサポートを持つIntel Pentuim III CPUの低消費電力バージョン。Centrinoノートブックで使われた。

@item pentium4
@itemx pentium4m
MMX、SSE、SSE2命令セットサポートを持つIntel Pentuim 4 CPU。

@item prescott
MMX、SSE、SSE2、SSE3命令セットサポートを持つIntel Pentuim 4 CPUの改良バージョン。

@item nocona
64ビット拡張、MMX、SSE、SSE2、SSE3命令セットサポートを持つIntel Pentium 4 CPUの改良バージョン。

@item core2
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つIntel Core 2 CPU。

@item nehalem
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT命令セットサポートを持つIntel Nehalem CPU。

@item westmere
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AES、PCLMUL命令セットサポートを持つIntel Westmere CPU。

@item sandybridge
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AES、PCLMUL命令セットサポートを持つIntel Sandy Bridge CPU。

@item ivybridge
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AES、PCLMUL、FSGSBASE、RDRND、F16C命令セットサポートを持つIntel Sandy Bridge CPU。

@item haswell
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C命令セットサポートを持つIntel Haswell CPU。

@item broadwell
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW命令セットサポートを持つIntel Broadwell CPU。

@item skylake
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES命令セットサポートを持つIntel Skylake CPU。

@item bonnell
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポート持つIntel Bonnell CPU。

@item silvermont
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AES、PCLMUL、RDRND命令セットサポートを持つIntel Slivermont CPU。

@item goldmont
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AES、PCLMUL、RDRNDXSAVE、 XSAVEOPT、FSGSBASE命令セットサポートを持つIntel Goldmont CPU。

@item goldmont-plus
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AES、PCLMUL、RDRNDXSAVE、 XSAVEOPT、FSGSBASE、TWRITE、RDPID、SGX、UMIP命令セットサポートを持つIntel Goldmont Plus CPU。

@item tremont
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AES、PCLMUL、RDRNDXSAVE、 XSAVEOPT、FSGSBASE、TWRITE、RDPID、SGX、UMIP、GFNI-SSE、CLWB、ENCLV命令セットサポートを持つIntel Tremont CPU。

@item knl
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、MFA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、AVX512F、AVX512PF、AVX512ER、AVX512CD命令セットサポート持つIntel Knight's Landing CPU。

@item knm
64-bit拡張, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX5124VNNIW, AVX5124FMAPS, AVX512VPOPCNTDQ命令セットサポート持つIntel Knight's Mill CPU。

@item skylake-avx512
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、MFA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、AVX512VL、AVX512BW、AVX512DQ、AVX512CD命令セットサポートを持つIntel SkylakeサーバーCPU。

@item cannonlake
64ビット拡張, MOVBE, MMX, SSE, SSE2,
SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE,
RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC,
XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI,
AVX512IFMA, SHA, UMIP命令セットサポートを持つIntel CannonlakeサーバーCPU。

@item icelake-client
64ビット拡張, MOVBE, MMX, SSE, SSE2,
SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE,
RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC,
XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI,
AVX512IFMA, SHA, CLWB, UMIP, RDPID, GFNI, AVX512VBMI2, AVX512VPOPCNTDQ,
AVX512BITALG, AVX512VNNI, VPCLMULQDQ, VAES命令セットサポートを持つIntel Icelake クライアントCPU 。

@item icelake-server
64ビット拡張, MOVBE, MMX, SSE, SSE2,
SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE,
RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC,
XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI,
AVX512IFMA, SHA, CLWB, UMIP, RDPID, GFNI, AVX512VBMI2, AVX512VPOPCNTDQ,
AVX512BITALG, AVX512VNNI, VPCLMULQDQ, VAES, PCONFIG, WBNOINVD命令セットサポートを持つIntel Icelake サーバーCPU 。

@item cascadelake
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2 、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ、AVX512CDおよびAVX512VNNI命令セットサポートを持つIntel Cascadelake CPU

@item cooperlake
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2 、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VNNIおよびAVX512BF16命令セットのサポートを持つIntel Cooperlake CPU。

@item tigerlake
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、
SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、
BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、
AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VBMI、AVX512IFMA、SHA、CLWB、UMIP、
RDPID、GFNI、AVX512VBMI2、AVX512VPOPCNTDQ、AVX512BITALG、AVX512VNNI、VPCLMULQDQ、
VAES、PCONFIG、WBNOINVD、MOVDIRI、MOVDIR64B命令セットのサポートを持つIntel Cooperlake CPU。

@item sapphirerapids
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2 、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VNNI、AVX512BF16、MOVDIRI、MOVDIR64B、AVX512BF16、MOVDIRI、MOVDIR64B、AVX512VP2INTERS 、AMX-BF16、AMX-TILE、AMX-INT8、およびAVX-VNNI命令セットのサポートを持つIntel sapphirerapids CPU。

@item alderlake
64ビット拡張機能、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C 、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、CLDEMOTE、PTWRITE、WAITPKG、SERIALIZE、KEYLOCKER、HRESET、およびAVX-VNNI命令セットのサポートを持つIntel Alderlake CPU。

@item k6
MMX命令セットサポートを持つAMD K6 CPU。

@item k6-2
@itemx k6-3
MMXと3DNow!命令セットサポートを持つAMD K6の改良されたバージョン。

@item athlon
@itemx athlon-tbird
MMX、3dNOW!、enhanced 3DNow!、SSEプリフェッチ命令サポートを持つAMD Athlon CPU。

@item athlon-4
@itemx athlon-xp
@itemx athlon-mp
MMX、3DNow!、enhanced 3DNow!、完全SSE命令セットサポートを持つ改良されたAMD Athlon CPU。

@item k8
@itemx opteron
@itemx athlon64
@itemx athlon-fx
AMD Opteron、Athlong 64、Athlon 64 FXプロセッサを含む、x86-64命令セットサポートを持つAMD K8コアに基づくプロセッサ。（これは、MMX、SSE、SSE2、3DNow!、enhanced 3DNow!、64ビット命令セット拡張を含む。）

@item k8-sse3
@itemx opteron-sse3
@itemx athlon64-sse3
SSE3命令セットサポートを含むAMD K8コアの改良されたバージョン。

@item amdfam10
@itemx barcelona
x86-64命令セットサポートを持つAMD10世代コアに基づくCPU。（これはMMX、SSE、SSE2、SSE3、SSE4A、3DNow!、enhaned 3DNow!、ABM、64ビット命令セット拡張を含む。）

@item bdver1
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはFMA4、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item bdver2
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはBMI、TBM、F16C、FMA、FMA4、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item bdver3
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはBMI、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item bdver4
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはBMI、BMI2、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、AVX2、XOP、LWP、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item znver1
x86-64命令セットサポートを持つAMD17世代コアに基づくCPU。（これはBMI、BMI2、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVES、CLFULSHOPT、POPCNT、64ビット命令セット拡張を含む。）

@item znver2
x86-64命令セットサポートを持つAMD17世代コアに基づくCPU。（これはBMI、BMI2、F16C、CLWB、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVES、CLFULSHOPT、POPCNT、RDPID、WBNOINVD、64ビット命令セット拡張を含む。）

@item znver3
x86-64命令セットサポートを持つAMD19世代コアに基づくCPU。（これはBMI、BMI2、F16C、CLWB、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVES、CLFULSHOPT、POPCNT、RDPID、WBNOINVD、PKU、VPCLMULQDQ、VAES、64ビット命令セット拡張を含む。）

@item btver1
x86-64命令セットサポートを持つAMD14世代コアに基づくCPU。（これはMMX、SSE、SSE2、SSE3、SSE4A、CX16、ABM、64ビット命令セット拡張を含む。）

@item btver2
x86-64命令セットサポートを持つAMD16世代コアに基づくCPU。（これはMOVBE、F16C、BMI、AVX、PCL_MUL、AES、SSE4.2、SSE4.1、CX16、ABM、SSE4A、SSSE3、SSE3、SSE2、SSE、MMX、64ビット命令セット拡張を含む。）

@item winchip-c6
追加のMMX命令セットをサポートするi486と同じように処理される、IDT WinChip C6 CPU。

@item winchip2
追加のMMXと3DNow!命令セットをサポートするi486と同じように処理される、IDT WinChip 2 CPU。

@item c3
MMXと3DNow!命令セットサポートを持つVIA C3 CPU。 （このチップ用スケジューリングは実装されていない。）

@item c3-2
MMXとSSE命令セットサポートを持つVIA C3-2 (Nehemiah/C5XL) CPU。（このチップ用スケジューリングは実装されていない。）

@item c7
MMX、SSE、SSE2、SSE3命令セットサポートを持つVIA C7 (Esther) CPU。（このチップ用スケジューリングは実装されていない。）

@item samuel-2
MMXと3DNow!命令セットサポートを持つVIA Eden Samuel 2 CPU。（このチップ用スケジューリングは実装されていない。）

@item nehemiah
MMXとSSE命令セットサポートを持つVIA Eden Nehemiah CPU。（このチップ用スケジューリングは実装されていない。）

@item esther
MMX、SSE、SSE2、SSE3命令セットサポートを持つVIA Eden Esther CPU。（このチップ用スケジューリングは実装されていない。）

@item eden-x2
x86-64、MMX、SSE、SSE2、SSE3命令セットサポートを持つVIA Eden X2 CPU。（このチップ用スケジューリングは実装されていない。）

@item eden-x4
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、AVX、AVX2命令セットサポートを持つVIA Eden X4 CPU。（このチップ用スケジューリングは実装されていない。）

@item nano
x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つ汎用VIA Nano CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-1000
x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つVIA Nano 1xxx CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-2000
x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つVIA Nano 2xxx CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-3000
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットサポートを持つVIA Nano 2xxx CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-x2
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットサポートを持つVIA Nano Dual Core CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-x4
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットサポートを持つVIA Nano Quadl Core CPU。（このチップ用スケジューリングは実装されていない。）

@item geode
MMXと3DNow!命令セットサポートを持つAMD Geode組み込みプロセッサ。
@end table

@item -mtune=@var{cpu-type}
@opindex mtune
ABIと使用可能な命令のセットを除いて、生成されたコードに関するすべてのものを@var{cpu-type}に調整する。特定の@var{cpu-type}を選んでその特定のチップを適切にスケジューリングすると、@option{-march=@var{cpu-type}}オプションを使用しない限り、コンパイラはデフォルトのマシンタイプでは実行できないコードを生成しない。たとえば、GCCがi686-pc-linux-gnu用に設定されている場合、@option{-mtune=pentium4}はPentium 4用にチューニングされたコードを生成するが、i686マシン上で実行できる。

@var{cpu-type}の選択肢は、@option{-march}の選択肢と同じである。さらに、@option{-mtune}は、@var{cpu-type}に対して2つの追加の選択肢をサポートしている：

@table @samp
@item generic
最も一般的なIA32・AMD64・EM64Tプロセッサ用に最適化されたコードを生成する。コードを実行するCPUが分かっている場合は、@option{-mtune=generic}ではなく、対応する@option{-mtune}または@option{-march}オプションを使用するべきである。しかし、アプリケーションのどのCPUユーザーが正確に何を持っているのかわからない場合は、このオプションを使用する必要がある。

新しいプロセッサが市場に展開されると、このオプションの動作が変わる。 したがって、新しいバージョンのGCCにアップグレードすると、このオプションで制御されるコード生成は、GCCのリリース時に最も一般的なプロセッサーを反映して変更される。

@option{-march}はコンパイラが使用できる命令セットを示し、すべてのプロセッサに適用可能な汎用命令セットがないため、@option{-march=generic}オプションはない。 対照的に、@option{-mtune}は、コードが最適化されているプロセッサ（または、この場合はプロセッサの集合）を示す。

@item intel
このバージョンのGCCでは、最新のIntelプロセッサ（GCCの現在のバージョンではHaswellとSilvermont）向けに最適化されたコードを生成する。コードが実行されるCPUを知っているなら、@option{-mtune=intel}の代わりに対応する@option{-mtune}または@option{-march}オプションを使うべきである。しかし、HaswellとSilvermontの両方でアプリケーションのパフォーマンスが向上したい場合は、このオプションを使用する必要がある。

新しいIntelプロセッサが市場に展開されると、このオプションの動作が変更される。 したがって、新しいバージョンのGCCにアップグレードすると、このオプションによって制御されるコード生成は、GCCのバージョンがリリースされた時点の最新のIntelプロセッサを反映して変更される。

@option{-march}は、コンパイラが使用できる命令セットを示し、すべてのプロセッサに共通の命令セットがないため、@option{-march=intel}オプションはない。 対照的に、@option{-mtune}は、コードが最適化されているプロセッサ（または、この場合はプロセッサの集合）を示す。
@end table

@item -mcpu=@var{cpu-type}
@opindex mcpu
@option{-mtune}の非推奨シノニム。

@item -mfpmath=@var{unit}
@opindex mfpmath
選択したユニット@var{unit}の浮動小数点演算を生成する。 @var{unit}の選択肢は次のとおりである。

@table @samp
@item 387
大多数のチップに存在する標準の387浮動小数点コプロセッサを使用し、それ以外の場合はエミュレートする。 このオプションでコンパイルされたコードは、ほぼすべての場所で実行できる。一時的な結果は、型によって指定された精度の代わりに80ビットの精度で計算され、他のほとんどのチップと比較してわずかに異なる結果になる。 より詳しい説明は@option{-ffloat-store}を参照せよ。

これは非Dawrinのx86-32ターゲットのデフォルトの選択肢である。

@item sse
SSE命令セットに存在するスカラー浮動小数点命令を使用する。この命令セットは、Pentium III以上のチップ、Athlon-4、Athlon XP、Athlon MPチップによるAMDラインでサポートされている。 SSE命令セットの以前のバージョンは単精度算術のみをサポートしているため、387を使用して倍精度および拡張精度算術演算が行われる。Pentium 4およびAMD x86-64チップにのみ存在する後のバージョンでは、倍精度算術もある。

x86-32コンパイラでは、SSE拡張を有効にしてこのオプションを有効にするには、@option{-march=@var{cpu-type}}、@option{-msse}または@option{-msse2}スイッチを使用する必要がある。 x86-64コンパイラの場合、これらの拡張機能はデフォルトで有効になっている。

結果のコードは、大部分のケースでかなり速く、387コードの数値的な不安定性の問題を回避するはずであるが、一時的なものが80ビットであることを期待する既存のコードがいくつか破壊される可能性がある。

これは、x86-64コンパイラ、Darwin x86-32ターゲット、および@option{-ffast-math}が有効な場合にSSE2命令セットを持つx86-32ターゲットのデフォルト選択のデフォルト選択である。

@item sse,387
@itemx sse+387
@itemx both
両方の命令セットを同時に使用しようとする。 これにより、使用可能なレジスタの量が効果的に倍増し、387用とSSE用で別々の実行単位を持つチップでは実行リソースも別々になる。 GCCレジスタアロケータは別々の関数ユニットをうまくモデル化せず、結果として不安定なパフォーマンスになるために、まだ実験的なので注意してこのオプションを使用すること。
@end table

@item -masm=@var{dialect}
@opindex masm=@var{dialect}
選択された@var{dialect}を使用してアセンブリ命令を出力する。 基本的な@code{asm}（@pxref{Basic Asm}）と拡張された@code{asm}（@pxref{Extended Asm}）に使われる変種にも影響する。 サポートされている選択肢（ダイアレクト順）は@samp{att}または@samp{intel}である。 デフォルトは@samp{att}である。 Darwinは@samp{intel}をサポートしていない。

@item -mieee-fp
@itemx -mno-ieee-fp
@opindex mieee-fp
@opindex mno-ieee-fp
コンパイラがIEEE浮動小数点比較を使用するかどうかを制御する。 これらは、比較の結果が順序付けられていない場合を正しく処理する。

@item -m80387
@itemx -mhard-float
@opindex 80387
@opindex mhard-float
浮動小数点用に80387命令を含む出力を生成する。

@item -mno-80387
@itemx -msoft-float
@opindex no-80387
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含む出力を生成する。

@strong{警告：}必要なライブラリはGCCの一部ではない。通常、マシンの通常のCコンパイラの機能が使用されるが、これはクロスコンパイルで直接行うことはできない。 クロスコンパイルに適したライブラリ機能を提供するために、独自の手配をしなければならない。

関数が80387レジスタスタックの浮動小数点結果を返すマシンでは、@option{-msoft-float}が使用されていても、一部の浮動小数点オペコードが発行されることがある。

@item -mno-fp-ret-in-387
@opindex mno-fp-ret-in-387
関数の戻り値にFPUレジスタを使用しない。

通常の呼び出し規約では、FPUがない場合でも、関数が@code{float}型と@code{double}型の値をFPUレジスタで返すようになっている。 考え方は、オペレーティングシステムがFPUをエミュレートする必要があるということである。

オプション@option{-mno-fp-ret-in-387}は、そのような値が通常のCPUレジスタに返されるようにする。

@item -mno-fancy-math-387
@opindex mno-fancy-math-387
一部の387エミュレータは、387の@code{sin}、@code{cos}および@code{sqrt}命令をサポートしていない。これらの命令の生成を避けるには、このオプションを指定する。このオプションはOpenBSDとNetBSDのデフォルトである。  このオプションは、@option{-march}がターゲットCPUが常にFPUを持っていることを示し、命令がエミュレーションを必要としないときには無効になる。@option{-funsafe-math-optimizations}スイッチも使用しない限り、これらの命令は生成されない。

@item -malign-double
@itemx -mno-align-double
@opindex malign-double
@opindex mno-align-double
GCCが@code{double}、@code{long double}、@code{long long}の変数を2ワード境界か1ワード境界に揃えるかどうかを制御する。 2ワード境界で@code{double}変数を調整すると、Pentium上でより高速に動作するコードが生成され、より多くのメモリが消費される。

x86-64では、デフォルトで@option{-malign-double}が有効になっている。

@strong{警告:} @option{-malign-double}スイッチを使用すると、上記の型を含む構造体は公開されているx86-32のバイナリインタフェース仕様とは異なった位置に配置され、そのスイッチなしでコンパイルされたコード内の構造体とバイナリ互換性はない。

@item -m96bit-long-double
@itemx -m128bit-long-double
@opindex m96bit-long-double
@opindex m128bit-long-double
これらのスイッチは、@code{long double}型のサイズを制御する。x86-32アプリケーションのバイナリインタフェースでは、サイズを96ビットに指定しているため、32ビットモードではデフォルトで@option{-m96bit-long-double}が使用される。

最近のアーキテクチャー（Pentium以上）は、@code{long double}が8バイト境界または16バイト境界に整列させることを好む。ABIに準拠した配列や構造では、これは不可能である。したがって、@option{-m128bit-long-double}を指定すると、@code{long double}に追加の32ビットのゼロを埋め込むことで、@code{long double}を16バイト境界に揃える。

x86-64コンパイラでは、ABIが@code{long double}が16バイトの境界に揃うように指定するので、@option{-m128bit-long-double}がデフォルトの選択肢である。

これらのオプションのいずれも、@code{long double}の80ビットのx87標準に対する余分な精度を有効にしないことに注意せよ。

@strong{警告:} ターゲットABIのデフォルト値をオーバーライドすると、@code{long double}変数を含む構造体と配列のサイズが変更され、@code{long double}を持つ関数の関数呼び出し規約が変更される。 したがって、スイッチなしでコンパイルされたコードとバイナリ互換性はない。

@item -mlong-double-64
@itemx -mlong-double-80
@itemx -mlong-double-128
@opindex mlong-double-64
@opindex mlong-double-80
@opindex mlong-double-128
これらのスイッチは、@code{long double}型のサイズを制御する。 64ビットのサイズは、@code{long double}型を@code{double}型と等価にする。 これは、32ビットのBionic Cライブラリのデフォルトである。 128ビットのサイズは@code{long double}型を@code{__float128}型と同等にする。 これは、64ビットのBionic Cライブラリのデフォルトである。

@strong{警告:} ターゲットABIのデフォルト値をオーバーライドすると、@code{long double}変数を含む構造体と配列のサイズが変更され、@code{long double}を持つ関数の関数呼び出し規約が変更される。 したがって、スイッチなしでコンパイルされたコードとバイナリ互換性はない。

@item -malign-data=@var{type}
@opindex malign-data
GCCがどのように変数を整列させるかを制御する。@var{type}のサポートされた値は、GCC 4.8以前で使用されている増加したアラインメント値互換性を使用さうる@samp{compat}、psABIで指定されたアライメント値を使用する@samp{abi}、キャッシュラインのサイズと一致するように増加したアラインメント値を使用する@samp{cacheline}である。@samp{compat}がデフォルトである。

@item -mlarge-data-threshold=@var{threshold}
@opindex mlarge-data-threshold
@option{-mcmodel=medium}を指定すると、@var{threshold}より大きいデータオブジェクトが大きなデータセクションに配置される。 この値は、バイナリにリンクされているすべてのオブジェクトで同じでなければならず、デフォルトは65535である。

@item -mrtd
@opindex mrtd
引数の数が固定されている関数が@code{ret @var{num}}命令で返される別の関数呼び出し規約を使用する。 これにより、引数をポップする必要がないため、呼び出し元に1つの命令が節約される。

関数の属性@code{stdcall}を使用して、この呼び出しシーケンスで個々の関数が呼び出されるように指定することができる。 また、関数属性@code{cdecl}を使用して@option{-mrtd}オプションを上書きすることもできる。 @xref{Function Attributes}.

@strong{警告:} この呼び出し規約はUnixで通常使用されているものと互換性がないため、Unixコンパイラでコンパイルされたライブラリを呼び出す必要がある場合は使用できない。

また、可変数の引数（@code{printf}を含む）をとるすべての関数の関数プロトタイプを提供する必要がある。 それ以外の場合は、それらの関数への呼び出しに対して誤ったコードが生成される。

さらに、あまりにも多くの引数を指定して関数を呼び出すと、コードが深刻に不正確になる。 （通常、余分な引数は無害に無視される。）

@item -mregparm=@var{num}
@opindex mregparm
整数引数を渡すために使用されるレジスタの数を制御する。 デフォルトでは、引数を渡すためにレジスタは使用されず、最大で3つのレジスタを使用できる。 関数の属性@code{regparm}を使用すると、特定の関数のこの動作を制御できる。@xref{Function Attributes}.

@strong{警告:} このスイッチを使用し、@var{num}がゼロ以外の場合は、ライブラリを含めて同じ値を持つすべてのモジュールを構築する必要がある。 これには、システムライブラリと起動モジュールが含まれる。

@item -msseregparm
@opindex msseregparm
floatとdoubleの引数と戻り値には、SSEのレジスタ渡し規則を使用する。 関数の属性@code{sseregparm}を使用すると、特定の関数のこの動作を制御できる。@xref{Function Attributes}.

@strong{警告:} このスイッチを使用する場合は、ライブラリを含め、同じ値を持つモジュールをすべてビルドする必要がある。 これには、システムライブラリと起動モジュールが含まれる。

@item -mvect8-ret-in-mem
@opindex mvect8-ret-in-mem
MMXレジスタの代わりに8バイトのベクトルをメモリに返します。 これは、Solaris@tie{}8および9とVxWorksでは、バージョン12まではSun StudioコンパイラのABIと一致するようにデフォルト設定されている。後のコンパイラバージョン（Studio 12 Update@tie{}1以降）は、他のx86ターゲットで使用されているABIに従う。これはSolaris 10以降のデフォルトである。以前のコンパイラバージョンまたは古いバージョンのGCCで作成された既存のコードとの互換性を保つ必要がある場合に@emph{_のみ_}、このオプションを使用すること。

@item -mpc32
@itemx -mpc64
@itemx -mpc80
@opindex mpc32
@opindex mpc64
@opindex mpc80

80387浮動小数点精度を32,64、または80ビットに設定する。@option{-mpc32}を指定すると、浮動小数点演算の結果の有効数字は24ビット（単精度）に丸められる。@option{-mpc64}は、浮動小数点演算の結果の有効数字を53ビット（倍精度）に丸め、@option{-mpc80}は浮動小数点演算の結果の有効数字を64ビット（拡張倍精度）に丸め、それがデフォルトである。このオプションを使用すると、FPU制御ワードを明示的に設定せずに、より高い精度での浮動小数点演算をプログラマが使用できなくなる。

浮動小数点演算の丸めをデフォルトの80ビット未満に設定すると、プログラムによっては2%以上の速度が得られることがある。いくつかの数学ライブラリは、拡張精度（80ビット）浮動小数点演算がデフォルトで有効になっていると仮定している。 このオプションを使用して精度を拡張精度以下に設定すると、このようなライブラリのルーチンは、通常、いわゆる「致命的な取り消し」を介して、精度の大幅な低下を被る可能性がある。

@item -mstackrealign
@opindex mstackrealign
入力時にスタックを再調整する。 x86では、@option{-mstackrealign}オプションは、必要に応じてランタイムスタックを再調整する代替のプロローグとエピローグを生成する。 これにより、SSE互換性のために16バイトのスタックアライメントを維持する最新のコードと4バイトのスタックアライメントを維持するレガシーコードの混在がサポートされる。 個々の関数に適用可能な属性@code{force_align_arg_pointer}も参照せよ。

@item -mpreferred-stack-boundary=@var{num}
@opindex mpreferred-stack-boundary
スタックの境界線を2の@var{num}乗バイト境界に合わせて整列させようとする。@option{-mpreferred-stack-boundary}が指定されていない場合、デフォルトは4（16バイトまたは128ビット）である。

@strong{警告:} SSE拡張機能を無効にしてx86-64アーキテクチャー用のコードを生成する場合、@option{-mpreferred-stack-boundary=3}を使用して、スタック境界を8バイト境界に揃えることができる。 x86-64 ABIは16バイトのスタックアライメントを必要とするため、ABIは互換性がなく、スタック領域が重要な制限である制御された環境で使用することを意図している このオプションは、16バイトのスタックアライメント（標準ライブラリの関数など）でコンパイルされた関数が、整列されていないスタックで呼び出されると、間違ったコードになる。 この場合、SSE命令は、不整合なメモリアクセストラップにつながる可能性がある。さらに、可変長引数は、16バイトの整列したオブジェクト（x87 long doubleと__int128を含む）に対して正しく処理されず、結果が正しくない。@option{-mpreferred-stack-boundary=3}（すべてのライブラリを含む）ですべてのモジュールをビルドする必要がある。 これには、システムライブラリと起動モジュールが含まれる。

@item -mincoming-stack-boundary=@var{num}
@opindex mincoming-stack-boundary
入ってくるスタックが2の@var{num}バイト乗の境界に揃えられていると仮定する。@option{-mincoming-stack-boundary}を指定しないと、@option{-mpreferred-stack-boundary}で指定されたものが使用される。

PentiumとPentium Proでは、@code{double}と@code{long double}の値は8バイトの境界（@option{-malign-double}を参照）に合わせるか、さもなければ実行時に大きなパフォーマンス上のペナルティを被る。Pentium IIIでは、Streaming SIMD Extension（SSE）のデータ型@code{__m128}が16バイト境界でないと正しく動作しないことがある。

スタック上のこの値の適切なアライメントを確実にするためには、スタック境界は、スタックに格納された任意の値が必要とする値と同じ位置になければならない。さらに、スタックを整列させたままにするように、すべての関数を生成する必要がある。したがって、より望まれたスタック境界でコンパイルされた関数を、あまり望まれないスタック境界でコンパイルされた関数から呼び出すと、スタックの位置がずれてしまう可能性が最も高くなる。コールバックを使用するライブラリは、常にデフォルト設定を使用することが推奨される。

この余分な配置は、余分なスタックスペースを消費し、一般にコードサイズを増加させる。 組み込みシステムやオペレーティングシステムのカーネルなど、スタック領域の使用に敏感なコードは、優先されるアラインメントを@option{-mpreferred-stack-boundary=2}に減らしたい場合がある。

@need 200
@item -mmmx
@opindex mmmx
@need 200
@itemx -msse
@opindex msse
@need 200
@itemx -msse2
@opindex msse2
@need 200
@itemx -msse3
@opindex msse3
@need 200
@itemx -mssse3
@opindex mssse3
@need 200
@itemx -msse4
@opindex msse4
@need 200
@itemx -msse4a
@opindex msse4a
@need 200
@itemx -msse4.1
@opindex msse4.1
@need 200
@itemx -msse4.2
@opindex msse4.2
@need 200
@itemx -mavx
@opindex mavx
@need 200
@itemx -mavx2
@opindex mavx2
@need 200
@itemx -mavx512f
@opindex mavx512f
@need 200
@itemx -mavx512pf
@opindex mavx512pf
@need 200
@itemx -mavx512er
@opindex mavx512er
@need 200
@itemx -mavx512cd
@opindex mavx512cd
@need 200
@itemx -mavx512vl
@opindex mavx512vl
@need 200
@itemx -mavx512bw
@opindex mavx512bw
@need 200
@itemx -mavx512dq
@opindex mavx512dq
@need 200
@itemx -mavx512ifma
@opindex mavx512ifma
@need 200
@itemx -mavx512vbmi
@opindex mavx512vbmi
@need 200
@itemx -msha
@opindex msha
@need 200
@itemx -maes
@opindex maes
@need 200
@itemx -mpclmul
@opindex mpclmul
@need 200
@itemx -mclflushopt
@opindex mclflushopt
@need 200
@itemx -mclwb
@opindex mclwb
@need 200
@itemx -mfsgsbase
@opindex mfsgsbase
@need 200
@itemx -mptwrite
@opindex mptwrite
@need 200
@itemx -mrdrnd
@opindex mrdrnd
@need 200
@itemx -mf16c
@opindex mf16c
@need 200
@itemx -mfma
@opindex mfma
@need 200
@itemx -mpconfig
@opindex mpconfig
@need 200
@itemx -mwbnoinvd
@opindex mwbnoinvd
@need 200
@itemx -mfma4
@opindex mfma4
@need 200
@itemx -mprfchw
@opindex mprfchw
@need 200
@itemx -mrdpid
@opindex mrdpid
@need 200
@itemx -mprefetchwt1
@opindex mprefetchwt1
@need 200
@itemx -mrdseed
@opindex mrdseed
@need 200
@itemx -msgx
@opindex msgx
@need 200
@itemx -mxop
@opindex mxop
@need 200
@itemx -mlwp
@opindex mlwp
@need 200
@itemx -m3dnow
@opindex m3dnow
@need 200
@itemx -m3dnowa
@opindex m3dnowa
@need 200
@itemx -mpopcnt
@opindex mpopcnt
@need 200
@itemx -mabm
@opindex mabm
@need 200
@itemx -madx
@opindex madx
@need 200
@itemx -mbmi
@opindex mbmi
@need 200
@itemx -mbmi2
@opindex mbmi2
@need 200
@itemx -mlzcnt
@opindex mlzcnt
@need 200
@itemx -mfxsr
@opindex mfxsr
@need 200
@itemx -mxsave
@opindex mxsave
@need 200
@itemx -mxsaveopt
@opindex mxsaveopt
@need 200
@itemx -mxsavec
@opindex mxsavec
@need 200
@itemx -mxsaves
@opindex mxsaves
@need 200
@itemx -mrtm
@opindex mrtm
@need 200
@itemx -mhle
@opindex mhle
@need 200
@itemx -mtbm
@opindex mtbm
@need 200
@itemx -mmwaitx
@opindex mmwaitx
@need 200
@itemx -mclzero
@opindex mclzero
@need 200
@itemx -mpku
@opindex mpku
@need 200
@itemx -mavx512vbmi2
@opindex mavx512vbmi2
@need 200
@itemx -mavx512bf16
@opindex mavx512bf16
@need 200
@itemx -mgfni
@opindex mgfni
@need 200
@itemx -mvaes
@opindex mvaes
@need 200
@itemx -mwaitpkg
@opindex mwaitpkg
@need 200
@itemx -mvpclmulqdq
@opindex mvpclmulqdq
@need 200
@itemx -mavx512bitalg
@opindex mavx512bitalg
@need 200
@itemx -mmovdiri
@opindex mmovdiri
@need 200
@itemx -mmovdir64b
@opindex mmovdir64b
@need 200
@itemx -menqcmd
@opindex menqcmd
@itemx -muintr
@opindex muintr
@need 200
@itemx -mtsxldtrk
@opindex mtsxldtrk
@need 200
@itemx -mavx512vpopcntdq
@opindex mavx512vpopcntdq
@need 200
@itemx -mavx512vp2intersect
@opindex mavx512vp2intersect
@need 200
@itemx -mavx5124fmaps
@opindex mavx5124fmaps
@need 200
@itemx -mavx512vnni
@opindex mavx512vnni
@need 200
@itemx -mavxvnni
@opindex mavxvnni
@need 200
@itemx -mavx5124vnniw
@opindex mavx5124vnniw
@need 200
@itemx -mcldemote
@opindex mcldemote
@need 200
@itemx -mserialize
@opindex mserialize
@need 200
@itemx -mamx-tile
@opindex mamx-tile
@need 200
@itemx -mamx-int8
@opindex mamx-int8
@need 200
@itemx -mamx-bf16
@opindex mamx-bf16
@need 200
@itemx -mhreset
@opindex mhreset
@itemx -mkl
@opindex mkl
@need 200
@itemx -mwidekl
@opindex mwidekl
これらのスイッチを使用すると、MMX, SSE,
SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF,
AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA,
AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG,
WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP,
3DNow!@:, enhanced 3DNow!@:, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE,
XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2,
GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512BF16,
ENQCMD, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, SERIALIZE,
UINTR, HRESET, AMXTILE, AMXINT8, AMXBF16, KL, WIDEKL, AVXVNNI or CLDEMOTE拡張命令セットでの命令の使用を有効にする。それぞれに対応する@option{-mno-}オプションがあり、これらの命令の使用を無効にする。

これらの拡張機能は、組み込み関数としても利用できる。これらのスイッチで有効または無効にする関数の詳細については、@ref{x86 Built-in Functions}を参照せよ。

浮動小数点コード（387命令ではなく）からSSE / SSE2命令を自動的に生成するには、@option{-mfpmath=sse}を参照せよ。

@option{-mavx}を使用するとGCCはSSEx命令を抑制する。 代わりに、必要に応じてすべてのSSEx命令に対して新しいAVX命令またはAVX等価を生成する。

これらのオプションは、GCCが@option{-mfpmath=sse}を使わなくても、生成されたコードでこれらの拡張命令を使用できるようにする。 ランタイムCPU検出を実行するアプリケーションは、適切なフラグを使用して、サポートされているアーキテクチャごとに個別のファイルをコンパイルする必要がある。 特に、CPU検出コードを含むファイルは、これらのオプションなしでコンパイルする必要がある。

@item -mdump-tune-features
@opindex mdump-tune-features
このオプションは、GCCにx86パフォーマンス調整機能の名前とデフォルト設定をダンプするよう指示する。 名前は@option{-mtune-ctrl=@var{feature-list}}で使用できる。

@item -mtune-ctrl=@var{feature-list}
@opindex mtune-ctrl=@var{feature-list}
このオプションは、x86コード生成機能の粒度を細かく制御するために使用される。@var{feature-list}はカンマで区切られた@var{feature}のリストである。@option{-mdump-tune-features}も参照せよ。これが指定されると、@var{feature}は@samp{^}の前になければオンになり、それ以外の場合にはオフになる。@option{-mtune-ctrl=@var{feature-list}}は、GCC開発者が使用するためのものである。これを使用すると、テストでカバーされないコードパスが発生し、コンパイラのICEまたは実行時エラーが発生する可能性がある。

@item -mno-default
@opindex mno-default
このオプションは、GCCにすべてのチューニング可能な機能をオフにするよう指示する。 @option{-mtune-ctrl=@var{feature-list}}と@option{-mdump-tune-features}も参照せよ。

@item -mcld
@opindex mcld
このオプションはGCCに文字列命令を使用する関数のプロローグで@code{cld}命令を出すよう指示する。文字列命令は、DFフラグに依存して、自動インクリメントモードまたは自動デクリメントモードを選択する。ABIは、関数入力時にDFフラグをクリアするよう指定しているが、一部のオペレーティングシステムでは、例外ディスパッチャでDFフラグをクリアしないため、この仕様に違反する。例外ハンドラは、DFフラグがセットされた状態で呼び出すことができる。これは、文字列命令が使用されているときに間違った方向モードにつながる。このオプションは、GCCをconfigureオプション@option{-enable-cld}で設定することで、デフォルトで32ビットx86ターゲットで有効にすることができる。@option{-mno-cld}コンパイラオプションを使用すると、@code{cld}命令の生成を抑止できる。

@item -mvzeroupper
@opindex mvzeroupper
このオプションは、AVXからSSEへの遷移ペナルティを最小限に抑え、不要な@code{zeroupper}組み込み関数を削除するために、関数から制御フローを転送する前にGCCに@code{vzeroupper}命令を発行するよう指示する。

@item -mprefer-avx128
@opindex mprefer-avx128
このオプションは、GCCに、自動ベクトル化器で256ビットAVX命令の代わりに128ビットAVX命令を使用するよう指示する。

@item -mprefer-vector-width=@var{opt}
@opindex mprefer-vector-width
このオプションは、GCCに対して、選択されたプラットフォームでのデフォルトではなく、@var{opt}ビットのベクトル幅を命令で使用するように指示します。

@table @samp
@item none
選択したプラットフォームで定義されている以外に、GCCに適用される追加の制限はありません。

@item 128
命令については、128ビットのベクトル幅を優先してください。

@item 256
命令については、256ビットのベクトル幅を優先してください。

@item 512
命令については、512ビットのベクトル幅を優先してください。
@end table

@item -mcx16
@opindex mcx16
このオプションを使用すると、GCCは64ビットコードで@code{CMPXCHG16B}命令を生成して、16バイト整列128ビットオブジェクトに対して比較および交換操作を実装できる。これは、1つのマシンワードサイズを超えるデータ構造のアトミック更新に役立つ コンパイラはこの命令を使用して@ref{__sync Builtins}を実装する。 しかし、128ビット整数で動作する@ref{__atomic Builtins}では、常にライブラリ呼び出しが使用される。

@item -msahf
@opindex msahf
このオプションを使用すると、64ビットコードで@code{SAHF}命令を生成できる。2005年12月のPentium 4 G1の導入に先立ち、インテル64をサポートしていた初期のインテルPentium 4 CPUは、AMD64でサポートされている@code{LAHF}と@code{SAHF}命令が欠けていた。これらは、それぞれ特定のステータスフラグのロードおよびストア命令である。64ビットモードでは、@code{fmod}、@code{drem}、および@code{remainder}組み込み関数を最適化するために@code{SAHF}命令が使用される。詳細は@ref{Other Builtins}を参照せよ。

@item -mmovbe
@opindex mmovbe
このオプションは@code{__builtin_bswap32}と@code{__builtin_bswap64}を実装するために@code{movbe}命令の使用を可能にする。

@item -mshstk
@opindex mshstk
@option {-mshstk}オプションは、x86 Control-flow Enforcement Technology（CET）のシャドウスタック組み込み関数を有効にします。

@item -mcrc32
@opindex mcrc32
このオプションは組み込み関数@code{__builtin_ia32_crc32qi}、@code{__builtin_ia32_crc32hi}、@code{__builtin_ia32_crc32si}、@code{__builtin_ia32_crc32di}を使用して@code{crc32}機械命令をする。

@item -mrecip
@opindex mrecip
このオプションは、@code{DIVSS}の代わりに、精度を高めるために追加のNewton-Raphsonステップのある@code{RCPSS}命令と@code{RSQRTSS}命令（およびそのベクトル化された変形@code{RCPPS}と@code{RSQRTPS}と@code{SQRTSS}（およびそれらのベクトル化されたバリアント）を使用する。 これらの命令は、@option{-funsafe-math-optimizations}が@option{-ffinite-math-only}と@option{-fno-trapping-math}とともに有効になっている場合にのみ生成される。シーケンスのスループットは、非相反命令のスループットよりも高いが、シーケンスの精度は2 ulpまで減少することある（すなわち、1.0の逆数は0.99999994に等しい）ことに注意すること。

GCCは@option{-fast-math}ではすでに@code{RSQRTSS}（または@code{RSQRTPS}）の観点から@code{1.0f/sqrtf(@var{x})}を実装しているので、@option{-mrecip}は必要ないことに注意すること。

また、GCCは、既に@option{-ffast-math}（または上のオプションの組み合わせ）ではベクトル化された単精度浮動小数点数除算とベクトル化された@code{sqrtf(@var{x})}に対する追加のNewton-Raphsonステップ付きの上の列を生成するので、@option{-mrecip}は必要ないことに注意すること。

@item -mrecip=@var{opt}
@opindex mrecip=opt
このオプションは、どの逆数見積り命令を使用するかを制御する。 @var{opt}はコンマで区切られたオプションのリストである。オプションの前に@samp{!}を付けてオプションを反転することができる。

@table @samp
@item all
全推測命令を有効にする。

@item default
デフォルトの命令を有効にし、@option{-mrecip}と等価である。

@item none
全推測命令を無効にし、@option{-mno-recip}と等価である。

@item div
スカラー除算の近似を有効にする。

@item vec-div
ベクトル化除算の近似を有効にする。

@item sqrt
スカラー平方根の近似を有効にする。

@item vec-sqrt
ベクトル化平方根の近似を有効にする。
@end table

たとえば、@option{-mrecip=all,!sqrt}は、平方根を除き、すべての逆数近似を有効にする。

@item -mveclibabi=@var{type}
@opindex mveclibabi
外部ライブラリを使用して組み込み関数をベクトル化するために使用するABIタイプを指定する。 @var{type}にサポートされている値は、インテルの短いベクトル演算ライブラリの場合は@samp{svml}、AMD演算コアライブラリの場合は@samp{acml}である。このオプションを使用するには、@option{-ftree-vectorize}と@option{-funsafe-math-optimizations}の両方を有効にし、リンク時にSVMLまたはACML ABI互換ライブラリを指定する必要がある。

GCCは現在、@option {-mveclibabi=svml}が使用されているときは対応する関数型用の@code{vmldExp2}, @code{vmldLn2}, @code{vmldLog102}, @code{vmldLog102}, @code{vmldPow2}, @code{vmldTanh2}, @code{vmldTan2}, @code{vmldAtan2}, @code{vmldAtanh2}, @code{vmldCbrt2}, @code{vmldSinh2}, @code{vmldSin2}, @code{vmldAsinh2}, @code{vmldAsin2}, @code{vmldCosh2}, @code{vmldCos2}, @code{vmldAcosh2}, @code{vmldAcos2}, @code{vmlsExp4}, @code{vmlsLn4}, @code{vmlsLog104}, @code{vmlsLog104}, @code{vmlsPow4}, @code{vmlsTanh4}, @code{vmlsTan4}, @code{vmlsAtan4}, @code{vmlsAtanh4}, @code{vmlsCbrt4}, @code{vmlsSinh4}, @code{vmlsSin4}, @code{vmlsAsinh4}, @code{vmlsAsin4}, @code{vmlsCosh4}, @code{vmlsCos4}, @code{vmlsAcosh4}, @code{vmlsAcos4}への呼び出しを@option{-mveclibabi=svml}が使われたときに使い、@code{__vrd2_sin}, @code{__vrd2_cos}, @code{__vrd2_exp}, @code{__vrd2_log}, @code{__vrd2_log2},
@code{__vrd2_log10}, @code{__vrs4_sinf}, @code{__vrs4_cosf}, @code{__vrs4_expf}, @code{__vrs4_logf}, @code{__vrs4_log2f}, @code{__vrs4_log10f}, @code{__vrs4_powf}への対応する関数型用の呼び出しを、@option{-mveclibabi=acml}が使われたときに生成する。

@item -mabi=@var{name}
@opindex mabi
指定された呼び出し規約のコードを生成する。 GNU/Linuxなどのシステムで使用されるABIでは@samp{sysv}、Microsoft ABIでは@samp{ms}が許容値である。 デフォルトでは、Microsoft WindowsターゲットではMicrosoft ABIを使用し、他のすべてのシステムではSysV ABIを使う。関数の属性@code{ms_abi}と@code{sysv_abi}を使用すると、特定の関数のこの動作を制御できる。@xref{Function Attributes}.

@item -mforce-indirect-call
@opindex mforce-indirect-call
関数のすべての呼び出しを強制的に間接的にします。 これは、関数呼び出しのより正確なタイミング情報を生成するインテルプロセッサートレースを使用する場合に役立ちます。

@item -mmanual-endbr
@opindex mmanual-endbr
@code{cf_check}関数属性を介してのみ、関数エントリにENDBR命令を挿入します。 これは、オプション@option{-fcf-protection=branch}とともに使用して、関数エントリでのENDBR挿入を制御する場合に役立ちます。

@item -mcall-ms2sysv-xlogues
@opindex mcall-ms2sysv-xlogues
@opindex mno-call-ms2sysv-xlogues
64ビットABIの違いにより、System V ABI関数を呼び出すMicrosoft ABI関数は、RSI、RDI、およびXMM6-15を破壊されたものと見なす必要があります。 デフォルトでは、これらのレジスタを保存および復元するためのコードはインラインで出力されるため、かなり長いプロローグとエピローグが生成されます。 @option{-mcall-ms2sysv-xlogues}を使用すると、libgccの静的部分のスタブを使用してこれらの保存と復元を実行するプロローグとエピローグが生成されるため、いくつかの追加の命令を使用して関数サイズを削減できます。

@item -mtls-dialect=@var{type}
@opindex mtls-dialect
@samp{gnu}または@samp{gnu2}の規則を使用してスレッドローカルストレージにアクセスするコードを生成する。 @samp{gnu}は控えめなデフォルトである。 @samp{gnu2}はより効率的だが、すべてのシステムで満たすことができないコンパイルおよび実行時の要件が追加される可能性がある。

@item -mpush-args
@itemx -mno-push-args
@opindex mpush-args
@opindex mno-push-args
PUSH操作を使用して、送信パラメータを格納する。 この方法は、SUB / MOV操作を使用するメソッドよりも短く、通常は同等に高速で、既定で有効になっている。 ある場合にはこれを向こうにすることでスケジューリングが改善され、依存関係が減少するため、パフォーマンスを向上させる場合がある。

@item -maccumulate-outgoing-args
@opindex maccumulate-outgoing-args
有効な場合、発信引数に必要な最大容量が関数プロローグで計算される。 これは、望まれるスタック境界が2に等しくない場合、依存性の減少、スケジューリングの改善、およびスタック使用率の低下のために、最新のCPUでは高速である。欠点はコードサイズが著しく増加することである。 このスイッチは、@option{-mno-push-args}を含む。

@item -mthreads
@opindex mthreads
MinGWでスレッドセーフな例外処理をサポートする。 スレッドセーフな例外処理に依存するプログラムは、すべてのコードをコンパイルし、@option{-mthreads}オプションでリンクする必要がある。 コンパイル時に、@option{-mthreads}は@option{-D_MT}を定義する。 リンクすると、スレッドごとの例外処理データをクリーンアップする特別なスレッドヘルパーライブラリ@option{-lmingwthrd}にリンクする。

@item -mms-bitfields
@itemx -mno-ms-bitfields
@opindex mms-bitfields
@opindex mno-ms-bitfields

ネイティブMicrosoft Windowsコンパイラと互換性のあるビットフィールドレイアウトを有効/無効にする。

構造体で@code{packed}が使用されている場合、またはビットフィールドが使用されている場合は、Microsoft ABIがGCCの通常の方法とは異なる構造をレイアウトしている可能性がある。 特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラ（関数呼び出しまたはファイル内のデータ）の間でパックされたデータを移動する場合は、どちらの形式にもアクセスする必要がある。

このオプションは、Microsoft Windowsターゲットではデフォルトで有効になっている。 この動作は、変数または型の属性を使用してローカルで制御することもできる。さらなる情報は、@ref{x86 Variable Attributes}と@ref{x86 Type Attributes}.

Microsoftの構造レイアウトアルゴリズムは、ビットフィールドパッキングを除いてかなり簡単である。構造体のメンバーのパディングとアライメント、およびビットフィールドがストレージユニットの境界をまたぐことができるかどうかは、次の規則によって決定される。

@enumerate
@item 構造体のメンバーは宣言された順番で順番に格納される。最初のメンバは最低のメモリアドレスを持ち、最後のメンバは最高のものを持つ。

@item すべてのデータオブジェクトにアラインメント要件がある。 構造体、共用体、および配列を除くすべてのデータの配置要件は、オブジェクトのサイズか、現在のパッキングサイズ（@code{aligned}属性または@code{pack}プラグマで指定）のいずれか小さい方である。 構造体、共用体、および配列の場合、配置要件は、そのメンバーの最大の配置要件である。すべてのオブジェクトには次のようにオフセットが割り当てられる。

@smallexample
offset % alignment_requirement == 0
@end smallexample

@item 整数型が同じサイズで、次のビットフィールドがビットフィールドの共通アラインメント要件によって課せられた境界を横切ることなく現在の割り当て単位に適合するならば、隣接するビットフィールドは同じ1バイト、2バイト、または4バイトの割り当て単位にパックされる 。
@end enumerate

MSVCは、次のようにゼロ長のビットフィールドを解釈する。

@enumerate
@item 通常合体された2つのビットフィールドの間に長さゼロのビットフィールドが挿入されている場合、ビットフィールドは結合されない。例えば：

@smallexample
struct
 @{
   unsigned long bf_1 : 12;
   unsigned long : 0;
   unsigned long bf_2 : 12;
 @} t1;
@end smallexample

@noindent
@code{t1}のサイズは、長さ0のビットフィールドを持つ8バイトである。 長さゼロのビットフィールドが削除された場合、@code{t1}のサイズは4バイトになる。

@item ビットフィールド@code{foo}の後に長さゼロのビットフィールドが挿入され、長さがゼロのビットフィールドの配置がそれに続くメンバーより大きい場合、@code{bar}、@code{bar}は、長さゼロのビットフィールドのタイプとして整列される。

For example:

@smallexample
struct
 @{
   char foo : 4;
   short : 0;
   char bar;
 @} t2;

struct
 @{
   char foo : 4;
   short : 0;
   double bar;
 @} t3;
@end smallexample

@noindent
@code{t2}では、@code{bar}はオフセット1ではなくオフセット2に配置される。したがって、@code{t2}のサイズは4である。@code{t3}では、長さゼロのビットフィールドは@code{bar}のアライメントや構造体のサイズに影響しない。

これを考慮すると、次の点に注意することが重要である。

@enumerate
@item ゼロ長のビットフィールドが通常のビットフィールドの後に続く場合、ゼロ長のビットフィールドのタイプは構造全体のアライメントに影響を与える可能性がある。 たとえば、@code{t2}は4バイトのサイズを持つ。なぜなら、長さゼロのビットフィールドは通常のビットフィールドの後ろにあり、short型であるからである。

@item 長さ0のビットフィールドの後に通常のビットフィールドが続くことがない場合でも、構造の配置にはまだ影響を与える可能性がある：

@smallexample
struct
 @{
   char foo : 6;
   long : 0;
 @} t4;
@end smallexample

@noindent
ここで、@code {t4}は4バイトを占める。
@end enumerate

@item 非ビットフィールドメンバに続くゼロ長ビットフィールドは無視される。

@smallexample
struct
 @{
   char foo;
   long : 0;
   char bar;
 @} t5;
@end smallexample

@noindent
ここで、@code {t5}は2バイトを占める。
@end enumerate


@item -mno-align-stringops
@opindex mno-align-stringops
インライン文字列操作の宛先を揃えない。 このスイッチは、宛先が既に整列されている場合にコードサイズを減らし、パフォーマンスを向上させるが、GCCはそれを知らない。

@item -minline-all-stringops
@opindex minline-all-stringops
デフォルトでは、GCCは、宛先が少なくとも4バイトの境界に位置合わせされていることがわかっている場合にのみ文字列操作をインライン化する。これにより、より多くのインライン化が可能になり、コードサイズは増加するが、短縮された長さの@code{memcpy}、@code{strlen}、@code{memset}に依存するコードのパフォーマンスが向上する可能性がある。

@item -minline-stringops-dynamically
@opindex minline-stringops-dynamically
不明なサイズの文字列操作では、小さなブロックのインラインコードと大きなブロックのライブラリ呼び出しを含む実行時検査を使用する。

@item -mstringop-strategy=@var{alg}
@opindex mstringop-strategy=@var{alg}
文字列操作のインライン化に使用する特定のアルゴリズムの内部決定ヒューリスティックをオーバーライドする。 @var{alg}に許される値は次のとおりである：

@table @samp
@item rep_byte
@itemx rep_4byte
@itemx rep_8byte
指定したサイズのi386接頭辞@code{rep}を使用して展開する。

@item byte_loop
@itemx loop
@itemx unrolled_loop
インラインループに展開する。

@item libcall
常にライブラリ呼び出しを使用する。
@end table

@item -mmemcpy-strategy=@var{strategy}
@opindex mmemcpy-strategy=@var{strategy}
@code{__builtin_memcpy}をインライン化するかどうかを、コピー操作の予想されるサイズがわかっているときに使用するインラインアルゴリズムを決定するための、内部決定のヒューリスティックをオーバーライドする。 @var{strategy}は@var{alg}:@var{max_size}:@var{dest_align}の三つ組のコンマで区切られたリストである。@var{alg}は@option{-mstringop-strategy}で指定され、@var{max_size}はインラインアルゴリズム@var{alg}が許可される最大バイトサイズを指定する。 最後のトリプレットの場合、@var{max_size}は@code{-1}でなければならない。 リスト内のトリプレットの@var{max_size}は、昇順で指定する必要がある。 @var{alg}の最小バイトサイズは、最初のトリプレットの場合は@code{0}、前の範囲の@code{@var{max_size}+1}である。

@item -mmemset-strategy=@var{strategy}
@opindex mmemset-strategy=@var{strategy}
このオプションは@code{__builtin_memset}拡張を制御する以外は@option{-mmemcpy-strategy=}と似ている。

@item -momit-leaf-frame-pointer
@opindex momit-leaf-frame-pointer
リーフ機能用のレジスタにフレームポインタを保持しない。 これにより、命令がフレームポインタのセーブ、セットアップ、および復元を回避し、リーフ機能で余分なレジスタを利用できるようになる。 オプション@option{-fomit-leaf-frame-pointer}は、リーフ関数のフレームポインタを削除する。これにより、デバッグが難しくなる可能性がある。

@item -mtls-direct-seg-refs
@itemx -mno-tls-direct-seg-refs
@opindex mtls-direct-seg-refs
TLSセグメントレジスタ（32ビットの場合は@code{%gs}、64ビットの場合は@code{%fs}）からのオフセットを使用してTLS変数にアクセスできるかどうか、スレッドベースポインタを追加する必要があるかどうかを制御する。 これが有効かどうかは、オペレーティングシステムによって異なり、TLSエリア全体をカバーするようにセグメントをマップするかどうかによって異なる。

GNU Cライブラリを使用するシステムの場合、デフォルトはオンである。

@item -msse2avx
@itemx -mno-sse2avx
@opindex msse2avx
アセンブラがVEX接頭辞付きSSE命令をエンコードするように指定する。 @option{-mavx}オプションは、デフォルトでこれを有効にする。

@item -mfentry
@itemx -mno-fentry
@opindex mfentry
プロファイリングがアクティブな場合（@option{-pg}）、プロファイリングカウンタの呼び出しをプロローグの前に置く。
注：x86アーキテクチャでは、@option{-mfentry}と@option{-pg}の属性では@code{ms_hook_prologue}は現時点では不可能である。

@item -mrecord-mcount
@itemx -mno-record-mcount
@opindex mrecord-mcount
プロファイリングがアクティブな場合（@option{-pg}）、各プロファイリングコールへのポインタを含む__mcount_locセクションを生成する。 これは、自動的にパッチを当てたり、呼び出しを外したりする場合に便利である。

@item -mnop-mcount
@itemx -mno-nop-mcount
@opindex mnop-mcount
プロファイリングがアクティブな場合（@option{-pg}）、プロファイリング関数への呼び出しをNOPとして生成する。 これは、あとで動的にパッチを適用する必要がある場合に便利である。 これはおそらく@option{-mrecord-mcount}と一緒に使うと便利である。

@item -minstrument-return=@var{type}
@opindex minstrument-return
指定された関数の呼び出しを伴う-pg -mfentryインストルメント済み関数の関数出口を計装します。 これは、retで終わる真の戻り値のみを計測しますが、jumpで終わる兄弟呼び出しは計測しません。 有効なタイプは、計測を行わない@var{none}、__return__への呼び出しを生成する@var{call}、または5バイトのnopを生成する@var{nop5}です。

@item -mrecord-return
@itemx -mno-record-return
@opindex mrecord-return
すべてのリターンインストルメンテーションコードを指す__return_locセクションを生成します。

@item -mfentry-name=@var{name}
@opindex mfentry-name
-pg -mfentry関数の関数エントリで呼び出される__fentry__シンボルの名前を設定します。

@item -mfentry-section=@var{name}
@opindex mfentry-section
-mrecord-mcount呼び出しを記録するセクションの名前を設定します（デフォルトは__mcount_loc）。

@item -mskip-rax-setup
@itemx -mno-skip-rax-setup
@opindex mskip-rax-setup
SSE拡張機能を無効にしてx86-64アーキテクチャ用のコードを生成するとき、可変引数がベクタレジスタに渡されていないときは、@option{-mskip-rax-setup}を使用してRAXレジスタの設定をスキップできる。

@strong{警告:} RAXレジスタは、可変引数を渡すときにスタック上のベクトルレジスタを不必要に節約するのを避けるために使用されるため、呼び出し先がスタックスペースを無駄にしたり、ランダムな場所にジャンプしたりする可能性がある。 GCC 4.4以降には、RAXレジスタの値に関係なく、これらの問題はない。

@item -m8bit-idiv
@itemx -mno-8bit-idiv
@opindex m8bit-idiv
Intel Atomのような一部のプロセッサでは、8ビット符号なし整数除算は32ビット/ 64ビット整数除算よりもはるかに高速である。 このオプションは、実行時チェックを生成する。 被除数と除数の両方が0〜255の範囲内にある場合、32ビット/ 64ビット整数除算の代わりに8ビット符号なし整数除算が使用される。

@item -mavx256-split-unaligned-load
@itemx -mavx256-split-unaligned-store
@opindex mavx256-split-unaligned-load
@opindex mavx256-split-unaligned-store
32バイトのAVXのアラインメントされていないロードとストアを分割する。

@item -mstack-protector-guard=@var{guard}
@itemx -mstack-protector-guard-reg=@var{reg}
@itemx -mstack-protector-guard-offset=@var{offset}
@opindex mstack-protector-guard
@opindex mstack-protector-guard-reg
@opindex mstack-protector-guard-offset
@var{guard}にカナリアを使用してスタック保護コードを生成する。サポートされている場所は、グローバルカナリアの@samp{global}およびTLSブロック内のスレッドカナリア（デフォルト）の@samp{tls}である。このオプションは、@option{-fstack-protector}または@option{-fstack-protector-all}が指定されている場合にのみ有効である。

後者の選択肢では、オプション@option{-mstack-protector-guard-reg=@var{reg}}と@option{-mstack-protector-guard-offset=@var{offset}}カナリアを読み込むためのベース・レジスタとして、またそのベース・レジスタからのオフセットから使用するために、@code{%fs}または@code{%gs}を使用する。 これらのデフォルトは、関連するABIで指定されている。

@item -mgeneral-regs-only
@opindex mgeneral-regs-only
汎用レジスタのみを使用するコードを生成する。 これにより、コンパイラは浮動小数点、ベクトル、マスク、およびバウンドレジスタを使用できなくなる。

@item -mindirect-branch=@var{choice}
@opindex mindirect-branch
間接呼び出しを変換し、@var{choice}でジャンプします。 デフォルトは@samp{keep}で、間接呼び出しを維持し、変更せずにジャンプします。 @samp{thunk}は、間接呼び出しを変換し、呼び出しにジャンプしてサンクを返します。 @samp{thunk-inline}は、間接呼び出しを変換し、インライン呼び出しにジャンプしてサンクを返します。 @samp{thunk-extern}は、間接呼び出しを変換し、外部呼び出しにジャンプして、別のオブジェクトファイルで提供されるサンクを返します。 関数属性@code{indirect_branch}を使用して、特定の関数のこの動作を制御できます。@xref{Function Attributes}.

@option{-mcmodel=large}は、@option{-mindirect-branch=thunk}および@option{-mindirect-branch=thunk-extern}と互換性がないことに注意してください。これは、大きなコードモデルではサンク関数に到達できない場合があるためです。

外部サンクを変更して制御フローチェックを無効にすることはできないため、@option{-mindirect-branch=thunk-extern}は@option{-fcf-protection=branch}と互換性がないことに注意してください。

@item -mfunction-return=@var{choice}
@opindex mfunction-return
@var{choice}で関数の戻り値を変換します。 デフォルトは@samp{keep}で、関数の戻り値は変更されません。 @samp{thunk}は、関数returnを呼び出しに変換し、thunkを返します。 @samp{thunk-inline}は、関数の戻りをインライン呼び出しに変換し、サンクを返します。 @samp{thunk-extern}は、関数の戻りを外部呼び出しに変換し、別のオブジェクトファイルで提供されるサンクを返します。 関数属性@code{function_return}を使用して、特定の関数のこの動作を制御できます。@xref{Function Attributes}.

大きなコードモデルではサンク関数に到達できない可能性があるため、@option{-mcmodel = large}は@option{-mfunction-return=thunk}および@option{-mfunction-return=thunk-extern}と互換性がないことに注意してください。

@item -mindirect-branch-register
@opindex mindirect-branch-register
間接呼び出しとレジスタを介してのジャンプを強制しします。

@end table

上記に加えて、これらの@samp {-m}スイッチは、64ビット環境のx86-64プロセッサ上でサポートされている。

@table @gcctabopt
@item -m32
@itemx -m64
@itemx -mx32
@itemx -m16
@itemx -miamcu
@opindex m32
@opindex m64
@opindex mx32
@opindex m16
@opindex miamcu
16ビット、32ビット、または64ビット環境用のコードを生成する。@option{-m32}オプションは、@code {int}、@code{long}、およびポインタ型を32ビットに設定し、任意のi386システムで実行されるコードを生成する。

@option{-m64}オプションは、@code{int}を32ビットに、@code{long}とポインタ型を64ビットに設定し、x86-64アーキテクチャ用のコードを生成する。Darwinの場合、@option{-m64}オプションは@option{-fno-pic}と@option{-mdynamic-no-pic}オプションも無効にする。

@option{-mx32}オプションは、@code{int}、@code{long}、ポインタ型を32ビットに設定し、x86-64アーキテクチャ用のコードを生成する。

@option{-m16}オプションは@option{-m32}と同じだが、アセンブリ出力の先頭に@code{.code16gcc}アセンブリディレクティブを出力し、バイナリを16ビットモードで実行できるようにする 。

@option{-miamcu}オプションはIntel MCU psABIに準拠したコードを生成する。 @option{-m32}オプションをオンにする必要がある。

@item -mno-red-zone
@opindex mno-red-zone
x86-64コードで、いわゆる「レッドゾーン」を使用しない。レッドゾーンは、x86-64 ABIによって必須であり、シグナルによって変更されないスタックポインタの場所を超える128バイトの領域である。@option{-mno-red-zone}フラグは、このレッドゾーンを無効にする。

@item -mcmodel=small
@opindex mcmodel=small
小さなコードモデル用のコードを生成する：プログラムとそのシンボルは、アドレス空間の下位2 GBにリンクされている必要がある。 ポインタは64ビットである。プログラムは静的または動的にリンクできる。 これがデフォルトコードモデルである。

@item -mcmodel=kernel
@opindex mcmodel=kernel
カーネルコードモデル用のコードを生成する。 カーネルは負の2 GBのアドレス空間で動作する。 このモデルは、Linuxのカーネルコードで使用する必要がある。

@item -mcmodel=medium
@opindex mcmodel=medium
中間モデル用のコードを生成する。プログラムはアドレス空間の下位2GBにリンクされる。 小さなシンボルもそこに配置される。 @option{-mlarge-data-threshold}より大きいサイズのシンボルは、大量のデータまたはBSSセクションに格納され、2GBを超える場所に配置できる。 プログラムは静的または動的にリンクできる。

@item -mcmodel=large
@opindex mcmodel=large
大型モデル用のコードを生成する。 このモデルでは、セクションのアドレスとサイズについて前提はない。

@item -maddress-mode=long
@opindex maddress-mode=long
ロングアドレスモード用のコードを生成する。 これは、64ビットおよびx32環境でのみサポートされている。 これは、64ビット環境のデフォルトアドレスモードである。

@item -maddress-mode=short
@opindex maddress-mode=short
ショートアドレスモード用のコードを生成する。 これは、32ビットおよびx32環境でのみサポートされている。 これは、32ビットおよびx32環境のデフォルトアドレスモードである。
@end table

@item -mneeded
@itemx -mno-needed
@opindex mneeded
LinuxターゲットのGNU_PROPERTY_X86_ISA_1_NEEDEDGNUプロパティを発行して、バイナリの実行に必要なマイクロアーキテクチャISAレベルを示します。
@end table

@node x86 Windows Options
@subsection x86 Windows オプション
@cindex x86 Windows Options
@cindex Windows Options for x86

これらの追加オプションは、Microsoft Windowsターゲットで使用できる。

@table @gcctabopt
@item -mconsole
@opindex mconsole
このオプションは、コンソールアプリケーションに必要なPEヘッダーサブシステムタイプをリンカーに設定するように指示することによって、コンソールアプリケーションを生成することを指定する。このオプションは、CygwinおよびMinGWターゲットで使用でき、デフォルトでこれらのターゲットで有効になっている。

@item -mdll
@opindex mdll
このオプションは、CygwinおよびMinGWターゲットで使用できる。 DLL「ダイナミックリンクライブラリ」を生成し、必要なランタイムスタートアップオブジェクトとエントリポイントの選択を可能にすることを指定する。

@item -mnop-fun-dllimport
@opindex mnop-fun-dllimport
このオプションは、CygwinおよびMinGWターゲットで使用できる。 @code{dllimport}属性を無視することを指定する。

@item -mthread
@opindex mthread
このオプションは、MinGWターゲットで使用できる。 MinGW固有のスレッドサポートが使用されることを指定する。

@item -municode
@opindex municode
このオプションは、MinGW-w64ターゲットで使用できる。 @code{UNICODE}プリプロセッサマクロがあらかじめ定義され、Unicode対応のランタイムスタートアップコードが選択される。

@item -mwin32
@opindex mwin32
このオプションは、CygwinおよびMinGWターゲットで使用できる。 これは、典型的なMicrosoft Windowsの事前定義マクロをプリプロセッサに設定することを指定するが、実行時ライブラリ/起動コードの選択には影響しない。

@item -mwindows
@opindex mwindows
このオプションは、CygwinおよびMinGWターゲットで使用できる。 リンカーにPEヘッダーサブシステムタイプを適切に設定するように指示することによって、GUIアプリケーションを生成することを指定する。

@item -fno-set-stack-executable
@opindex fno-set-stack-executable
このオプションは、MinGWターゲットで使用できる。 ネストされた関数によって使用されるスタックの実行可能フラグが設定されていないことを指定する。 これは、実行可能な特権を設定するために使用されるUser32 APIが利用できないため、Microsoft Windowsのカーネルモードで実行されるバイナリに必要である。

@item -fwritable-relocated-rdata
@opindex fno-writable-relocated-rdata
このオプションは、MinGWおよびCygwinターゲットで使用できる。 読み取り専用セクションの再配置されたデータが@code{.data}セクションに置かれることを指定する。 これは、擬似再配置のための@code{.rdata}セクションの変更をサポートしていない古いランタイムには必要である。

@item -mpe-aligned-commons
@opindex mpe-aligned-commons
このオプションは、CygwinおよびMinGWターゲットで使用できる。 これは、コードを生成する際に、COMMON変数の正しい整列を可能にするPEファイル形式へのGNU拡張を使用することを指定する。 設定中に見つかったターゲットアセンブラがこの機能をサポートしていることをGCCが検出すると、デフォルトで有効になる。
@end table

標準オプションについては、@ref {x86 Options}も参照せよ。

@node Xstormy16 Options
@subsection Xstormy16オプション
@cindex Xstormy16 Options

これらのオプションはXstormy16で定義されている：

@table @gcctabopt
@item -msim
@opindex msim
シミュレータに適した起動ファイルとリンカスクリプトを選択する。
@end table

@node Xtensa Options
@subsection Xtensaオプション
@cindex Xtensa Options

これらのオプションは、Xtensaターゲットでサポートされている。

@table @gcctabopt
@item -mconst16
@itemx -mno-const16
@opindex mconst16
@opindex mno-const16
定数値をロードするための@code{CONST16}命令の使用を有効または無効にする。 @code{CONST16}命令は現在、Tensilicaの標準オプションではない。 有効にすると、標準の@code{L32R}命令の代わりに@code{CONST16}命令が常に使用される。 @code{L32R}命令が利用できない場合に限り、@code{CONST16}の使用はデフォルトで有効になる。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点オプションで、融合乗算/加算および乗算/減算命令の使用を有効または無効にする。 浮動小数点オプションも有効になっていない場合は、これは無効である。 融合乗算/加算および乗算/減算命令を無効にすると、コンパイラは乗算演算および加算/減算演算に別々の命令を使用する。これは、厳密なIEEE 754準拠の結果が必要な場合に望ましい場合がある。融合乗算加算/減算命令は中間結果を丸めないため、IEEE標準で指定された精度よりも@emph{多い}ビットの精度で結果を生成する。また、積和加算/減算命令を無効にすることで、プログラムの出力が、乗算と加算/減算の演算を組み合わせるコンパイラの能力に影響されないことが保証される。

@item -mserialize-volatile
@itemx -mno-serialize-volatile
@opindex mserialize-volatile
@opindex mno-serialize-volatile
このオプションを有効にすると、GCCはシーケンシャル一貫性を保証するために@code{MEMW}命令を@code{volatile}メモリ参照の前に挿入する。デフォルトは@option{-mserialize-volatile}である。@code{MEMW}命令を省略するには、@option{-mno-serialize-volatile}を使用する。

@item -mforce-no-pic
@opindex mforce-no-pic
GNU/Linuxのようなターゲット用に、すべてのユーザモードXtensaコードが位置独立コード（PIC）でなければならない場合、このオプションはカーネルコードをコンパイルするためにPICを無効にする。

@item -mtext-section-literals
@itemx -mno-text-section-literals
@opindex mtext-section-literals
@opindex mno-text-section-literals
これらのオプションは、リテラルプールの処理を制御する。 デフォルトは@option{-mno-text-section-literals}で、リテラルは出力ファイルの別のセクションに配置される。 これにより、リテラルプールをデータRAM/ROMに配置することができる。また、リンカーは別々のオブジェクトファイルからのリテラルプールを結合してリテラルを削除し、コードサイズを改善することもできる。 @option{-mtext-section-literals}では、リテラルはテキストセクションに散在して、できるだけそれらの参照にできるだけ近づける。 これは、大規模なアセンブリファイルに必要な場合がある。 各関数のリテラルは、その関数の直前に配置される。

@item -mauto-litpools
@itemx -mno-auto-litpools
@opindex mauto-litpools
@opindex mno-auto-litpools
これらのオプションは、リテラルプールの処理を制御する。デフォルトは@option{-mno-auto-litpools}で、@option{-mtext-section-literals}が使われていない限り、リテラルを出力ファイルの別のセクションに置く。 @option{-mauto-litpools}を使用すると、リテラルはアセンブラによってテキストセクションに散在する。コンパイラは明示的な@code {.literal}指令を生成せず、アセンブラが緩和を行い、必要に応じてリテラルを置くために@code{L32R}ではなく@code{MOVI}命令でレジスタにリテラルをロードする。このオプションを使用すると、アセンブラは関数ごとに複数のリテラルプールを作成し、@option{-mtext-section-literals}では不可能な非常に大きな関数をアセンブルすることができる。

@item -mtarget-align
@itemx -mno-target-align
@opindex mtarget-align
@opindex mno-target-align
このオプションを有効にすると、GCCはコード密度を犠牲にして分岐ペナルティを減らすために命令を自動的に整列させるようにアセンブラに指示する。アセンブラは、分岐命令と呼び出し命令に続く命令を整列させるために密度命令を拡張しようとする。 ターゲットを整列させるのに先行する安全密度命令が十分でない場合、拡幅は行われない。デフォルトは@option{-mtarget-align}である。 これらのオプションは、@code{LOOP}のようなオートアライメントされた命令の処理には影響しない。アセンブラは、密度命令を広げたり、NOP命令を挿入したりして、常に整列する。

@item -mlongcalls
@itemx -mno-longcalls
@opindex mlongcalls
@opindex mno-longcalls
このオプションを有効にすると、GCCはダイレクトコールのターゲットがコール命令で許可された範囲内にあると判断できない限り、ダイレクトコールを間接呼び出しに変換するようにアセンブラに指示する。この変換は、通常、他のソースファイル内の関数への呼び出しで発生する。 具体的には、アセンブラは直接@code{CALL}命令を@code{L32R}と@code{CALLX}命令に変換する。デフォルトは@option{-mno-longcalls}である。このオプションは、コールターゲットが潜在的に範囲外になる可能性のあるプログラムで使用する必要がある。このオプションはコンパイラではなくアセンブラで実装されているので、GCCによって生成されたアセンブリコードはダイレクトコール命令を表示する。実際の命令を見るために逆アセンブルされたオブジェクトコードを見ること。アセンブラは、本当に範囲外のものだけでなく、クロスファイルコールごとに間接呼び出しを使用することに注意せよ。
@end table

@node zSeries Options
@subsection zSeriesオプション
@cindex zSeries options

@xref{S/390 and zSeries Options}でリストされている。


@c man end

@node Spec Files
@section サブプロセスとスイッチを指定してそれらに渡す
@cindex Spec Files

@command{gcc}はドライバプログラムである。 コンパイル、アセンブル、およびリンクの作業を行うために、他のプログラムのシーケンスを呼び出すことによって、そのジョブを実行する。 GCCはコマンドラインパラメータを解釈し、どのプログラムを呼び出すべきか、そしてコマンドラインにどのコマンドラインオプションを置くべきかを推測するためにこれらのパラメータを使用する。この動作は@dfn{spec strings}（仕様文字列）によって制御される。 ほとんどの場合、GCCが呼び出すことができるプログラムごとに1つの仕様文字列があるが、いくつかのプログラムでは、その動作を制御する複数の仕様文字列がありる。 GCCに組み込まれている仕様文字列は、@option{-specs=}コマンドラインスイッチを使用して仕様ファイルを指定することで上書きすることができる。

@dfn{Spec files}（仕様ファイル）は、仕様文字列の作成に使用されるプレーンテキストファイルである。それらは空白行で区切られた一連のディレクティブで構成されている。  ディレクティブのタイプは、行の最初の非空白文字によって決まる。次のいずれかになる。

@table @code
@item %@var{command}
@var{command}を仕様ファイル・プロセッサーに発行する。 ここに表示されるコマンドは次のとおりである。

@table @code
@item %include <@var{file}>
@cindex @code{%include}
@var{file}を検索し、仕様ファイルの現在の点にテキストを挿入します。

@item %include_noerr <@var{file}>
@cindex @code{%include_noerr}
@samp{%include}と似ていますが、インクルードファイルが見つからない場合はエラーメッセージを生成しない。

@item %rename @var{old_name} @var{new_name}
@cindex @code{%rename}
@var{old_name}を@var{new_name}に変更する。

@end table

@item *[@var{spec_name}]:
これは、指定されたspec文字列を作成、上書き、または削除するようにコンパイラに指示する。このディレクティブの次のディレクティブまたは空白行までのすべての行は、仕様文字列のテキストとみなされる。この結果が空の文字列の場合、仕様は削除される。 （または、仕様が存在しない場合、何も起こらない。）それ以外の場合、仕様が現在存在しない場合は、新しい仕様が作成される。仕様が存在する場合、その内容は、このテキストの最初の文字が@samp{+}文字でない限り、このディレクティブのテキストによって上書きされる。この場合、テキストは仕様に追加される。

@item [@var{suffix}]:
新しい@samp{[@var{suffix}] spec}のペアを作成する。このディレクティブの後の次のディレクティブまたは空白行までのすべての行は、指定されたサフィックスの仕様文字列を構成すると見なされる。コンパイラが名前付きサフィックスを持つ入力ファイルを検出すると、そのファイルをコンパイルする方法を理解するために仕様文字列を処理する。 例えば：

@smallexample
.ZZ:
z-compile -input %i
@end smallexample

これは、名前が@samp{.ZZ}で終わる入力ファイルは@samp{z-compile}プログラムに渡されなければならず、これはコマンドラインスイッチ@option{-input}と結果@samp{%i}置換を実行する。 （下記参照。）

仕様文字列を提供する代わりに、接尾辞ディレクティブに続くテキストは、次のいずれかになる。

@table @code
@item @@@var{language}
これは、接尾辞が既知の@var{language}のエイリアスであることを示している。 これは、GCCへの@option{-x}コマンドラインスイッチを使用して明示的に言語を指定するのと同様である。 例えば：

@smallexample
.ZZ:
@@c++
@end smallexample

ZZファイルは実際にはC++ソースファイルだと言う。

@item #@var{name}
これにより、次のようなエラーメッセージが表示される。

@smallexample
@var{name} compiler not installed on this system.
@end smallexample
@end table

GCCは既にそれに組み込まれているサフィックスの広範なリストを持っている。このディレクティブは、接尾辞のリストの最後にエントリを追加するが、リストは末尾から検索されるため、この手法を使用して以前のエントリをオーバーライドすることは事実上可能である。

@end table

GCCには、以下の仕様文字列が組み込まれている。 仕様ファイルはこれらの文字列を無効にするか、独自のファイルを作成できる。 個々のターゲットは、独自の仕様文字列をこのリストに追加することもできる。

@smallexample
asm          アセンブラに渡されるオプション
asm_final    アセンブラの後処理に渡されるオプション
cpp          Cプリプロセッサに渡されるオプション
cc1          Cコンパイラに渡されるオプション
cc1plus      C++コンパイラに渡されるオプション
endfile      リンクの終わりで入れるオブジェクトファイル
link         ランカに渡されるオプション
lib          リンカにコマンドラインで入れるライブラリ
libgcc       リンカに渡すGCCサポートライブラリを決定する
linker       リンカの名前を設定する
predefines   Cプリプロセッサへ渡すために定義される
signed_char  CPPにデフォルトで@code{char}が符号付きかどうかを決定するために渡すために定義する
startfile    リンクの初めで入れるオブジェクトファイル
@end smallexample

ここに仕様ファイルの小さい例がある。

@smallexample
%rename lib                 old_lib

*lib:
--start-group -lgcc -lc -leval1 --end-group %(old_lib)
@end smallexample

この例では、@samp{lib}という名前を@samp{old_lib}という名前に変更し、以前の@samp{lib}の定義を新しいもので上書きする。新しい定義では、古い定義のテキストを含める前にいくつかの余分なコマンドラインオプションが追加されている。

@dfn{Spec strings}（仕様文字列）は、対応するプログラムに渡すコマンドラインオプションのリストである。  さらに、仕様文字列には、可変テキストを置換するため、または条件付きでテキストをコマンドラインに挿入するための@samp{%}-接頭辞付きのシーケンスを含めることができる。 これらの構文を使用すると、非常に複雑なコマンドラインを生成することができる。

ここに仕様文字列のすべての定義済みの@samp{%}-シーケンスのテーブルがある。これらのシーケンスを展開した結果の周りにスペースは自動的に生成されないことに注意せよ。したがって、それらを連結したり、単一の引数で定数テキストと組み合わせることができる。

@table @code
@item %%
@samp{%}をプログラム名または引数に置き換える。

@item %i
処理中の入力ファイルの名前に置き換える。

@item %b
処理中の入力ファイルの基本名を置き換える。これは、最後のピリオドまで（ディレクトリは含まず）の部分文字列である。

@item %B
これは@samp{%b}と同じだが、ファイルサフィックス（最後の後のテキスト）を含む。

@item %d
@samp{%d}を含むかそれに続く引数を一時ファイル名としてマークし、GCCが正常に終了するとそのファイルが削除されるようにする。 @samp{%g}とは異なり、これは引数にテキストを与えない。

@item %g@var{suffix}
@var{接尾辞}という接尾辞を持ち、コンパイルごとに一度選択されるファイル名に置き換え、@samp{%d}と同じ方法で引数に印を付ける。サービス拒否攻撃に対する被害を軽減するため、以前に選択したファイル名が判明しても予測が困難な方法でファイル名が選択されるようになった。 たとえば、@samp{%g.s @dots{}%g.o @dots{}%g.s} @samp {ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s}に変わる可能性がある。 @var{suffix}は正規表現@samp{[.A-Za-z]*}や特殊文字列@samp{%O}にマッチする。これは@samp{%O}が前処理されたのとまったく同じように扱われる。以前は@samp{%g}は、コンパイルごとに一度選択されたファイル名で置き換えられていた。そのため、通常のテキストと同様に処理されていたため、そのような攻撃は成功する可能性が高くなっていた。

@item %u@var{suffix}
@samp{%g}に似ているが、コンパイルごとに1回ではなく、現れるごとに毎回新しい一時ファイル名が生成される。

@item %U@var{suffix}
@samp{%u@var{suffix}}で生成された最後のファイル名を置き換える。最後のファイル名がない場合は新しいファイル名を生成する。@samp{%u@var{suffix}}がない場合、これは@samp{%g@var{suffix}}と似ているが、それらは同じサフィックス@emph{space}を共有しないので、@samp{%g.s @dots{} %U.s @dots{} %g.s @dots{} %U.s}は、@samp{%g.s}ごとに1つずつ、@samp{%U.s}ごとに1つずつ、2つの異なるファイル名を生成する。以前は、@samp{%U}は直前の@samp{%u}に対して選択されたファイル名で置き換えられていた。

@item %j@var{suffix}
もし存在し、書き込み可能で、@option{-save-temps}が使用されていない場合は、@code{HOST_BIT_BUCKET}の名前を置き換える。 それ以外の場合は、@samp{%u}のように一時ファイルの名前を置き換える。この一時ファイルは、プロセス間の通信ではなく、ジャンク処理メカニズムとして使用される。

@item %|@var{suffix}
@itemx %m@var{suffix}
@option{-pipe}が有効な場合を除いて、@samp{%g}と似ている。その場合、@samp{%|}は単一のダッシュを置き換え、@samp{%m}は何も置き換えない。これらは、プログラムに標準入力から読み込むか標準出力に書き込むかを指示する2つの最も一般的な方法である。もっと精巧なものが必要な場合は、@samp{%@{pipe:@code{X}@}}構文を使用することができる。例については@file{f/lang-specs.h}を参照せよ。

@item %.@var{SUFFIX}
後で@samp{%*}で出力されるときに、一致するスイッチのargsの接尾辞を@var{.SUFFIX}に置き換える。@var{SUFFIX}は次のスペースまたは%で終了する。

@item %w
このコンパイルの指定された出力ファイルとして@samp{%w}を含むかそれに続く引数をマークする。 これは、@samp{%o}が代入する引数のシーケンスに引数を置く。

@item %o
すべての出力ファイルの名前を、それらの周囲に自動的にスペースを入れて置き換える。 @samp{%o}の前後にスペースを入れるべきである。そうしないと、結果は未定義である。@samp{%o}は、リンカを実行するための仕様で使用される。名前に接尾辞が付いていない入力ファイルは、コンパイルされないが、出力ファイルには含まれているため、リンクされる。

@item %O
オブジェクトファイルの接尾辞を置き換える。完全なファイル名を作成する必要があるため、これは@samp{%g, %u, %U}の直後にあるときに特別に処理されることに注意せよ。@samp {%g、%u、%U}が現在、例えば@samp{.o}が続くような、@samp{%O}が続く追加の@var{suffix}文字をサポートしていないことを除いて、@samp {%O}は既に置換されているかのように扱われる

@item %I
@env{GCC_EXEC_PREFIX}からの@option{-iprefix}、@env{TARGET_SYSTEM_ROOT}からの@option{-isysroot}、@env{COMPILER_PATH}からの@option{-isystem} @option{-B}オプション）と@option{-imultilib}を使用する。

@item %s
現在の引数は、ある種のライブラリまたはスタートアップファイルの名前である。ディレクトリの標準リストでそのファイルを検索し、見つかったフルネームで置き換える。現在の作業ディレクトリは、スキャンされたディレクトリのリストに含まれている。

@item %T
現在の引数は、リンカースクリプトの名前である。 現在のディレクトリのリストでそのファイルを検索し、ライブラリをスキャンする。 ファイルが見つかった場合は、@option{-script}オプションをコマンド行に挿入し、その後に完全なパス名を入力する。 ファイルが見つからない場合は、エラーメッセージを生成する。 注：現在の作業ディレクトリは検索されない。

@item %e@var{str}
@var{str}をエラーメッセージとして出力する。 @var{str}は改行で終了する。一貫性のないオプションが検出された場合に使用する。

@item %n@var{str}
通知として@var{str}を印刷します。 @var{str}は改行で終了します。

@item %(@var{name})
この時点で、spec文字列@var{name}の内容を置き換える。

@item %x@{@var{option}@}
@samp {%X}のオプションを累積する。

@item %X
@option{-Wl}または@samp{%x}指定文字列によって指定された蓄積されたリンカオプションを出力する。

@item %Y
@option{-Wa}で指定した累積アセンブラオプションを出力する。

@item %Z
@option {-Wp}で指定された累積プリプロセッサオプションを出力する。

@item %M
@code{multilib_os_dir}を出力します。

@item %R
@code{target_system_root}と@code{target_sysroot_suffix}の連結を出力します。

@item %a
@code{asm}仕様を処理する。 これは、アセンブラに渡されるスイッチを計算するために使用される。

@item %A
@code{asm_final}仕様を処理する。 これは、このようなプログラムが必要な場合に、スイッチをアセンブラポストプロセッサに渡すための仕様文字列である。

@item %l
@code{link}仕様を処理する。 これは、リンカーに渡されたコマンドラインを計算するための仕様である。 通常、@samp{%L%G%S%Dと%E}シーケンスを使用する。

@item %D
GCCがスタートアップファイルを含んでいる可能性のあるディレクトリごとに@option{-L}オプションをダンプする。 ターゲットがマルチブロックをサポートしている場合、現在のmultilibディレクトリがこれらのパスのそれぞれに付加される。

@item %L
@code {lib}仕様を処理する。 これは、どのライブラリがリンカーへのコマンドラインに含まれるかを決めるための仕様文字列である。

@item %G
@code {libgcc}仕様を処理する。 これは、どのGCCサポートライブラリがリンカのコマンドラインに含まれているかを決定するための仕様文字列である。

@item %S
@code{startfile}仕様を処理する。 これは、どのオブジェクトファイルが最初にリンカに渡されるかを決定するための仕様である。通常、これは@file{crt0.o}という名前のファイルである。

@item %E
@code{endfile}仕様を処理する。 これは、リンカに渡された最後のオブジェクトファイルを指定する仕様文字列である。

@item %C
@code{cpp}仕様を処理する。 これは、Cプリプロセッサに渡す引数を作成するために使用される。

@item %1
@code{cc1}仕様を処理する。 これは、実際のCコンパイラ（@command{cc1}）に渡すオプションを構築するために使用される。

@item %2
@code{cc1plus}仕様を処理する。 これは、実際のC++コンパイラ（@command{cc1plus}）に渡すオプションを構築するために使用される。

@item %*
一致するオプションの可変部分を代入する。 下記参照。置換文字列の各カンマは単一のスペースで置き換えられることに注意せよ。

@item %<S
コマンドラインから@code{-S}をすべて削除する。 注---このコマンドは位置によって異なる。これより前の@samp{%}コマンドは@code{-S}を見て、これよりあとの@samp{%}コマンドは見ない。

@item %<S*
@samp{%<S}に似ていますが、@code{-S}で始まるすべてのスイッチに一致します。

@item %>S
@samp{%<S}に似ていますが、GCCコマンドラインで@code{-S}を保持します。

@item %:@var{function}(@var{args})
名前付き関数@var{function}を呼び出し、@var{args}を渡す。 @var{args}はネストされた仕様文字列として最初に処理され、通常の方法で引数ベクトルに分割される。 関数は現在の仕様の一部として文字通り現れたかのように処理される文字列を返す。

以下のビルトイン仕様関数が用意されている。

@table @code
@item @code{getenv}
@code{getenv}仕様関数は、環境変数名と文字列という2つの引数をとる。 環境変数が定義されていない場合、致命的なエラーが発行される。それ以外の場合、戻り値は文字列と連結された環境変数の値である。たとえば、@env{TOPDIR}が@file{/path/to/top}として定義されている場合、次のようになる。

@smallexample
%:getenv(TOPDIR /include)
@end smallexample

は@file{/path/to/top/include}へと展開される。

@item @code{if-exists}
@code{if-exists}仕様関数は1つの引数、ファイルへの絶対パス名をとる。 ファイルが存在する場合、@code{if-exists}はパス名を返す。 その使い方の小さな例がある：

@smallexample
*startfile:
crt0%O%s %:if-exists(crti%O%s) crtbegin%O%s
@end smallexample

@item @code{if-exists-else}
@code{if-exists-else}仕様関数は、2つの引数を取る点を除いて、@code{if-exists}仕様関数と似ている。最初の引数は、ファイルへの絶対パス名である。ファイルが存在する場合、@code{if-exists-else}はパス名を返す。存在しない場合は、2番目の引数を返す。このようにして、@code{if-exists-else}を使用して、最初のファイルの存在に基づいて1つのファイルまたは別のファイルを選択することができる。その使い方の小さな例があります：

@smallexample
*startfile:
crt0%O%s %:if-exists(crti%O%s) \
%:if-exists-else(crtbeginT%O%s crtbegin%O%s)
@end smallexample

@item @code{if-exists-then-else}
@code{if-exists-then-else}仕様関数は、少なくとも2つの引数とオプションの3番目の引数を取ります。 最初の引数は、ファイルへの絶対パス名です。 ファイルが存在する場合、関数は2番目の引数を返します。 ファイルが存在しない場合、関数は3番目の引数が存在する場合はそれを返し、存在しない場合はNULLを返します。 これは、ファイルの存在に基づいて、1つのテキスト、またはオプションで別のテキストを展開するために使用できます。 これはその使用法の小さな例です：

@smallexample
-l%:if-exists-then-else(%:getenv(VSB_DIR rtnet.h) rtnet net)
@end smallexample

@item @code{sanitize}
@code{sanitize}仕様関数は引数を取りません。 アドレス、スレッド、または未定義の動作サニタイザーがアクティブな場合は、NULL以外を返します。

@smallexample
%@{%:sanitize(address):-funwind-tables@}
@end smallexample

@item @code{replace-outfile}
@code{replace-outfile}仕様関数は2つの引数をとる。これは、outfiles配列の最初の引数を探し、それを2番目の引数に置き換える。 その使い方の小さな例がある：

@smallexample
%@{fgnu-runtime:%:replace-outfile(-lobjc -lobjc-gnu)@}
@end smallexample

@item @code{remove-outfile}
@code{remove-outfile}仕様関数は1つの引数をとる。 これは、outfiles配列の最初の引数を探し、それを削除する。 その使用例を以下に示す。

@smallexample
%:remove-outfile(-lm)
@end smallexample

@item @code{version-compare}
@code{version-compare}仕様関数は、次の形式の4つまたは5つの引数を取ります。

@smallexample
<comparison-op> <arg1> [<arg2>] <switch> <result>
@end smallexample

比較がtrueと評価された場合は@code{result}を返し、そうでない場合はNULLを返します。 サポートされている@code{comparison-op}の値は次のとおりです。

@table @code
@item >=
@code{switch}が@code{arg1}より後の（または同じ）バージョンである場合はTrue

@item !>
@code{>=}の反対

@item <
@code{switch}が@code{arg1}より前のバージョンである場合はTrue

@item !<
@code{<}の反対

@item ><
@code{switch}が@code{arg1}以降で、@code{arg2}より前の場合はTrue

@item <>
@code{switch}が@code{arg1}より前、または@code{arg2}以降の場合はTrue
@end table

@code{switch}がまったく存在しない場合、@code{comparison-op}の最初の文字が@code{!}でない限り、条件はfalseになります。

@smallexample
%:version-compare(>= 10.3 mmacosx-version-min= -lmx)
@end smallexample

上記の例では、@option{-mmacosx-version-min=10.3.9}が渡された場合、@option{-lmx}が追加されます。

@item @code{include}
@code{include}仕様関数は@code{%include}とよく似た動作をしますが、仕様内にネストできるため、条件付き化できるという利点があります。 ファイル名という1つの引数を取り、startfileパスでそれを探します。 常にNULLを返します。

@smallexample
%@{static-libasan|static:%:include(libsanitizer.spec)%(link_libasan)@}
@end smallexample

@item @code{pass-through-libs}
@code{pass-through-libs}仕様関数は任意の数の引数をとる。任意の@option{-l}オプションと@file{.a}（リンカ入力ライブラリアーカイブファイルの名前であると仮定する）で終わるオプション以外を見つけ出し、それぞれの先頭に@option{-plugin-opt=-pass-through=}を入力し、スペースで結合する。このリストは、LTOリンカー・プラグインに渡されることを意図している。

@smallexample
%:pass-through-libs(%G %L %G)
@end smallexample

@item @code{print-asm-header}
@code{print-asm-header}関数は引数をとらず、単純に次のようなバナーを出力する：

@smallexample
Assembler options
=================

Use "-Wa,OPTION" to pass "OPTION" to the assembler.
@end smallexample

@option{-target-help}出力のアセンブラオプションからコンパイラオプションを分離するために使用される。
@end table

@item @code{gt}
@code{gt}仕様関数は2つ以上の引数を取ります。 最後から2番目の引数が最後の引数より大きい場合は@code{""}（空の文字列）を返し、それ以外の場合はNULLを返します。 次の例では、コマンドラインで指定された最後の@option{-ftree-parallelize-loops=}オプションが1より大きい場合、@code{link_gomp}仕様を挿入します。

@smallexample
%@{%:gt(%@{ftree-parallelize-loops=*:%*@} 1):%:include(libgomp.spec)%(link_gomp)@}
@end smallexample

@item @code{debug-level-gt}
@code{debug-level-gt}仕様関数は、1つの引数を取り、@code{debug_info_level}が指定された数より大きい場合は@code{""}（空の文字列）を返し、それ以外の場合はNULLを返します。

@smallexample
%@{%:debug-level-gt(0):%@{gdwarf*:--gdwarf2@}@}
@end smallexample
@end table

@item %@{S@}
スイッチがGCCに与えられている場合は、@code{-S}スイッチに置き換える。そのスイッチが指定されていない場合、これは何も置き換えない。先頭のダッシュはこのオプションを指定するときは省略され、置換が実行されると自動的に挿入されることに注意せよ。したがって、仕様文字列@samp{%@{foo@}}は、コマンドラインオプション@option{-foo}と一致し、コマンドラインオプション@option{-foo}を出力する。

@item %W@{S@}
%@{@code{S}@}と似ているが、失敗したときに削除するファイルとして指定された最後の引数をマークする。

@item %@@@{S@}
%@{@code{S}@}と同様ですが、結果を@code{FILE}に入れ、@code{@@file}引数が指定されている場合は@code{@@FILE}に置き換えます。

@item %@{S*@}
指定されたすべてのスイッチをGCCに代入する。名前は@code{-S}で始まるだけでなく、引数もとる。これは、@option{-o}、@option{-D}、@option{-I}などのスイッチに使用される。GCCは@option{-o foo}を@samp{o}で始まる1つのスイッチとみなす。 %@{o*@}はスペースを含めてこのテキストを置き換えるます。 したがって、2つの引数が生成される。

@item %@{S*&T*@}
%@{@code{S}*@}と似ているが、@code{S}と@code {T}オプションの順序を保持する（仕様の@code{S}と@code{T}の順序は重要ではない）。アンパサンドで区切られた変数はいくつでもよい。 ワイルドカードはそれぞれオプションである。@samp{%@{D*&U*&A*@}}としてCPPに役立つ。

@item %@{S:X@}
@option{-S}スイッチがGCCに与えられている場合、@code{X}に置き換えられる。

@item %@{!S:X@}
@option{-S}スイッチがGCCに対して与えられて@emph{いない}場合、@code{X}に置き換えられる。

@item %@{S*:X@}
名前が@code{-S}で始まるスイッチがGCCに指定されている場合は、@code{X}に置き換える。通常、@code{X}はスイッチの数にかかわらず一度だけ置換される。しかし、@code{%*}が@code{X}のどこかに現れた場合、@code{X}は、一致するスイッチごとに1回置き換えられ、@code{%*}は@code {*}に一致するスイッチの一部で置き換えられる。

@code{%*}が仕様列の最後の部分として現れた場合、最後の置換の終了後にスペースが追加される。ただし、列内にテキストがさらに存在する場合は、スペースは生成されない。 これにより、より大きな文字列の一部として@code{%*}置換を使用することができる。たとえば、次のような列文字列があると：

@smallexample
%@{mcu=*:--script=%*/memory.ld@}
@end smallexample

@noindent
@option{-mcu = newchip}のようなオプションをマッチさせると次のようになる：

@smallexample
--script=newchip/memory.ld
@end smallexample

@item %@{.S:X@}
接尾辞@code{S}を持つファイルを処理する場合は、@code{X}に置き換える。

@item %@{!.S:X@}
接尾辞@code{S}を持つファイルを処理@emph{_しない_}場合は、@code{X}に置き換える。

@item %@{,S:X@}
言語@code{S}のファイルを処理する場合は、@code {X}に置き換える。

@item %@{!,S:X@}
言語@code{S}のファイルを処理していない場合は、@code{X}に置き換える。

@item %@{S|P:X@}
@code{-S}か@code{-P}のどちらかがGCCに与えられた場合、@code{X}に置き換える。これは@samp{!}、@samp{.}、@samp{,}、@code{*}シーケンスと組み合わせても問題ないが、結合は@samp{|}よりも強くなる。 @code{X*}に@code{%*}が含まれている場合は、すべての選択肢に星印を付ける必要があり、最初の一致する選択肢のみが置換される。

たとえば、次のような仕様文字列があると、

@smallexample
%@{.c:-foo@} %@{!.c:-bar@} %@{.c|d:-baz@} %@{!.c|d:-boggle@}
@end smallexample

@noindent
次の入力コマンドラインオプションから次のコマンドラインオプションを出力する。

@smallexample
fred.c        -foo -baz
jim.d         -bar -boggle
-d fred.c     -foo -baz -boggle
-d jim.d      -bar -baz -boggle
@end smallexample

@item %@{%:@var{function}(@var{args}):X@}

@var{function}という名前の関数を引数@var{args}で呼び出します。 関数がNULL以外を返す場合は、@code{X}が置換され、NULLを返す場合は、置換されません。

@item %@{S:X; T:Y; :D@}

GCCに@code{S}が与えられていれば、@code{X}に置き換えられる。 そうでなければ、GCCに@code{T}が与えられていれば、@code{Y}に置き換える。さもなければ@code{D}を代入する。必要だけ多くの節をできる。 これは、必要に応じて@code{.}、@code{,}、@code{!}、@code{|}、@code{*}と組み合わせることができる。


@end table

@samp{%@{S@}}や@samp{%@{S:X@}}やそれに類する構文のテキストの@code {S}にマッチするスイッチは、バックスラッシュを使って次の文字の特殊な意味を無視することができ、これにより、特別に扱われる文字のリテラルマッチングが可能になる。@option{-std=iso9899:1999}オプションが指定されている場合、@samp{%@{std=iso9899\:1999:X@}}は@code{X}を置き換える。

@samp{%@{S:X@}}内の条件付きテキスト@code{X}や他の同様の構文には、他のネストされた@samp{%}構造体やスペース、あるいは改行文字が含まれている。 これらは上記のように通常通り処理される。@code{X}の末尾の空白は無視される。 空白は、@code{.}や@code {*}とそれに対応する単語を除いて、これらの構造体のコロンの左側の任意の場所に表示されることもある。

@option{-O}、@option{-f}、@option{-m}、および@option{-W}スイッチは、これらの構造体で特に処理される。@option{-O}の別の値または@option{-f}、@option{-m}、または@option{-W}スイッチの否定された形式がコマンドラインの後のほうにある場合、以前のスイッチ値@{@code{S}*@}を除いて無視される。ここで@code {S}はすべての一致するオプションを渡す単一文字である。

述語テキストの先頭にある文字@samp{|}は、コマンドが次のコマンドにパイプされるべきであることを示すために使用されるが、それは@option{-pipe}が指定されている場合のみである。

それはどのスイッチが引数を取ってどれが取らないかがGCCに組み込まれている。（各コンパイラの仕様によって、どのスイッチが引数を取るかを言うために、これを一般化することが有用であると考えるかもしれない。  しかし、これは一貫した方法で行うことはできない。  GCCはどのスイッチが引数を取るかを知らずにどの入力ファイルが指定されたのかを判断することもできず、実行するコンパイラを知らせるためにどの入力ファイルをコンパイルするのかを知る必要がある。）

GCCはまた、@option{-l}で始まる引数がコンパイラの出力ファイルとして扱われ、他の出力ファイルの中の適切な位置にリンカに渡されることを暗黙のうちに知っている。

@node Environment Variables
@section GCCに影響を与える環境変数
@cindex environment variables

@c man begin ENVIRONMENT
このセクションでは、GCCの動作に影響を与えるいくつかの環境変数について説明する。それらの中には、さまざまな種類のファイルを検索するときに使用するディレクトリや接頭辞を指定するものもある。 いくつかは、コンパイル環境の他の側面を指定するために使用される。

@option {-B}、@option {-I}、@option {-L}などのオプションを使用して検索する場所を指定することもできる。 (@pxref{Directory Options})。 これらは環境変数を使用して指定された場所よりも優先される。環境変数はGCCの設定で指定された場所よりも優先される。@xref{Driver,, Controlling the Compilation Driver @file{gcc}, gccint,
GNU Compiler Collection (GCC) Internals}.

@table @env
@item LANG
@itemx LC_CTYPE
@c @itemx LC_COLLATE
@itemx LC_MESSAGES
@c @itemx LC_MONETARY
@c @itemx LC_NUMERIC
@c @itemx LC_TIME
@itemx LC_ALL
@findex LANG
@findex LC_CTYPE
@c @findex LC_COLLATE
@findex LC_MESSAGES
@c @findex LC_MONETARY
@c @findex LC_NUMERIC
@c @findex LC_TIME
@findex LC_ALL
@cindex locale
これらの環境変数は、GCCがローカリゼーション情報を使用する方法を制御する。これにより、GCCはさまざまな国の慣習に従って動作することができる。 GCCはロケールカテゴリ@env{LC_CTYPE}と@env{LC_MESSAGES}が設定されているかどうかを調べる。これらのロケールカテゴリは、インストールでサポートされている任意の値に設定できる。典型的な値は、UTF-8でエンコードされた英国の英語の@samp{en_GB.UTF-8}である。

@env{LC_CTYPE}環境変数は、文字の分類を指定する。 GCCはそれを使用して文字列内の文字境界を判断する。 これは、引用符とエスケープ文字を含むマルチバイトエンコーディングの場合に必要である。これは、文字列の終わりまたはエスケープとして解釈される。

@env{LC_MESSAGES}環境変数は、診断メッセージに使用する言語を指定する。

@env{LC_ALL}環境変数が設定されている場合、@env{LC_CTYPE}と@env{LC_MESSAGES}の値が上書きされる。 そうでない場合、@env{LC_CTYPE}と@env{LC_MESSAGES}はデフォルトで@env{LANG}環境変数の値になる。 これらの変数のいずれも設定されていない場合、GCCのデフォルトは従来のC言語の動作になる。

@item TMPDIR
@findex TMPDIR
@env{TMPDIR}が設定されている場合は、一時ファイルに使用するディレクトリを指定する。 GCCは一時ファイルを使用して、次の段階への入力として使用されるコンパイルの1段階の出力を保持する。たとえば、コンパイラの適切な入力であるプリプロセッサの出力である。

@item GCC_COMPARE_DEBUG
@findex GCC_COMPARE_DEBUG
@env{GCC_COMPARE_DEBUG}を設定することは、@option{-fcompare-debug}をコンパイラドライバに渡すこととほぼ同じである。 詳細については、このオプションのドキュメントを参照せよ。

@item GCC_EXEC_PREFIX
@findex GCC_EXEC_PREFIX
@env{GCC_EXEC_PREFIX}が設定されている場合、コンパイラによって実行されるサブプログラムの名前に使用する接頭辞を指定する。 このプレフィックスとサブプログラムの名前を組み合わせた場合、スラッシュは追加されないが、必要に応じてスラッシュで終わる接頭辞を指定できる。

@env{GCC_EXEC_PREFIX}が設定されていない場合、GCCは呼び出されたパス名に基づいて適切な接頭辞を探し出す。

GCCが指定された接頭辞を使用してサブプログラムを見つけることができない場合、GCCは通常の場所でサブプログラムを探す。

@env{GCC_EXEC_PREFIX}のデフォルト値は@file{@var{prefix}/lib/gcc/}である。ここで、@var{prefix}はインストールされたコンパイラの接頭辞である。 多くの場合、@var{prefix}は、@file{configure}スクリプトを実行したときの@code{prefix}の値である。

@option{-B}で指定された他の接頭辞は、この接頭辞よりも優先される。

この接頭辞は、リンクに使用される@file{crt0.o}のようなファイルを見つけるためにも使用される。

さらに、接頭辞は、ヘッダーファイルを検索するディレクトリを見つける際に通常とは異なる方法で使用される。名前が通常@samp{/usr/local/lib/gcc}で始まる標準ディレクトリ（より正確には@env{GCC_INCLUDE_DIR}の値）ごとに、GCCは代替ディレクトリ名を生成するために指定された接頭辞で始まるものを置き換えようとする。 したがって、@option{-Bfoo/}で、GCCは標準ディレクトリ@file{/usr/local/lib/bar}を検索する直前に@file{foo/bar}を検索する。標準ディレクトリが設定された@var{prefix}で始まる場合、@var{prefix}の値はヘッダファイルを探すときに@env{GCC_EXEC_PREFIX}に置き換えらる。

@item COMPILER_PATH
@findex COMPILER_PATH
@env{COMPILER_PATH}の値は、@env{PATH}と同様に、コロンで区切られたディレクトリのリストである。 @env{GCC_EXEC_PREFIX}を使用してサブプログラムが見つからない場合、GCCはサブプログラムを検索するときにこのように指定されたディレクトリを試す。

@item LIBRARY_PATH
@findex LIBRARY_PATH
@env{LIBRARY_PATH}の値は、@env{PATH}と同様に、コロンで区切られたディレクトリのリストである。ネイティブコンパイラとして設定された場合、GCCは@env{GCC_EXEC_PREFIX}を使用してそれらを見つけることができない場合、特別なリンカファイルを検索するときに指定されたディレクトリを試す。GCCを使用してリンクすると、@option{-l}オプションの通常のライブラリを検索する際にもこれらのディレクトリが使用される（しかし、@option{-L}で指定されたディレクトリが最初に来る）。

@item LANG
@findex LANG
@cindex locale definition
この変数は、ロケール情報をコンパイラに渡すために使用される。この情報が使用される1つの方法は、文字リテラル、文字列リテラルおよびコメントがCおよびC++で解析されるときに使用される文字セットを決定することである。コンパイラがマルチバイト文字を許可するように設定されている場合、次の@env{LANG}の値が認識されます。

@table @samp
@item C-JIS
JIS文字を認識する。
@item C-SJIS
SJIS文字を認識する。
@item C-EUCJP
EUCJP文字を認識する。
@end table

@env{LANG}が定義されていない場合、または他の値がある場合、コンパイラはデフォルトロケールで定義されている@code{mblen}と@code{mbtowc}を使用して、マルチバイト文字を認識して変換する。
@end table

@noindent
いくつかの追加の環境変数は、プリプロセッサの動作に影響する。

@include cppenv.texi

@c man end

@node Precompiled Headers
@section コンパイル済みヘッダを使う
@cindex precompiled headers
@cindex speed of compilation

多くの場合、大きなプロジェクトには、すべてのソースファイルに含まれるヘッダファイルが多数ある。 コンパイラがこれらのヘッダファイルを何度も処理するのにかかる時間は、プロジェクトを構築するのに必要な時間のほとんどすべてを占めることがある。 ビルドを高速化するために、GCCではヘッダファイルを@dfn{precompile}（プリコンパイル）することができる。

プリコンパイル済みのヘッダーファイルを作成するには、必要に応じて@option{-x}オプションを使用してドライバでCまたはC++ヘッダーファイルとして扱うように、他のファイルと同様にコンパイルする。 @command{make}のようなツールを使用して、プリコンパイルされたヘッダーに変更が含まれている場合、そのヘッダーを最新の状態に保つことができる。

コンパイル時に@code{#include}が見えた時、プリコンパイルされたヘッダファイルが検索される。 インクルードされたファイル(@pxref{Search Path,,Search Path,cpp,The C Preprocessor}) を検索すると、コンパイラはそのディレクトリのインクルードファイルを探す直前に各ディレクトリのプリコンパイル済みヘッダを探す。 検索される名前は、@code{#include}で指定されたものに@samp{.gch}が付加された名前である。 プリコンパイルされたヘッダーファイルを使用できない場合は無視される。

たとえば、@code{#include "all.h"}を持ち、@file{all.h}と同じディレクトリに@file{all.h.gch}がある場合、可能であればプリコンパイルされたヘッダファイルが使用される。 さもなければ元のヘッダーが使用される。

あるいは、プリコンパイルされたヘッダーファイルをディレクトリに入れ、@option{-I}を使用して元のヘッダーを含むディレクトリの前に（またはその代わりに）ディレクトリを検索することもできる。次に、プリコンパイルされたヘッダファイルが常に使用されていることを確認したい場合は、@code{#error}コマンドを含む元のヘッダと同じ名前のファイルをこのディレクトリに置くことができる。

これは@option {-include}でも有効である。プリコンパイルされたヘッダーを使用するもう1つの方法は、プリコンパイルされたヘッダーファイルを考慮して設計されていないプロジェクトに適している。プロジェクトで使用されるヘッダーファイルの大半を取り込み、別のヘッダーファイルからインクルードし、 プリコンパイルされたヘッダーを@option{-include}する。ヘッダーファイルに複数のインクルードが含まれている場合、ヘッダーファイルは既にインクルードされているため（プリコンパイル済みヘッダー内にあるため）、スキップされる。

異なる言語、ターゲット、またはコンパイラ・オプションに対して同じヘッダー・ファイルをプリコンパイルする必要がある場合は、代わりに@emph{ディレクトリ}を@file {all.h.gch}のように作成して、各プリコンパイルされたヘッダーをディレクトリに入れて、 おそらく@option{-o}を使用する。あなたがディレクトリ内のファイルと呼ぶものは重要ではない。 ディレクトリ内のすべてのプリコンパイル済みヘッダーが考慮される。このコンパイルで有効な、ディレクトリ内で最初にプリコンパイルされたヘッダーが使用される。 それらは特別な順序で検索されることはない。

他にも多くの可能性がある。あなたの想像力、良識、ビルドシステムの制約によってのみ制限される。

プリコンパイル済みヘッダーファイルは、次の条件が当てはまる場合にのみ使用できる。

@itemize
@item
特定のコンパイルでは、1つのプリコンパイル済みヘッダーしか使用できない。

@item
最初のCトークンが見えると、プリコンパイルされたヘッダーは使用できない。 プリコンパイルされたヘッダの前にプリプロセッサディレクティブを置くことができる。 別のヘッダーの中からプリコンパイルされたヘッダーを含めることはできない。

@item
プリコンパイルされたヘッダーファイルは、現在のコンパイルと同じ言語で作成する必要がある。 C++コンパイルにCプリコンパイル済みヘッダーを使用することはできない。

@item
プリコンパイルされたヘッダーファイルは、現在のコンパイルが使用しているのと同じコンパイラバイナリによって生成されている必要がある。

@item
プリコンパイル済みヘッダーが含まれる前に定義されたマクロは、プリコンパイル済みヘッダーの生成時と同じ方法で定義するか、プリコンパイル済みヘッダーに影響を与えてはならない。

@option{-D}オプションは、プリコンパイルされたヘッダがインクルードされる前にマクロを定義する方法の1つである。 @code{#define}を使うこともできる。@option{-O}や@option{-Wdeprecated}のように暗黙的にマクロを定義するオプションもある。 この方法で定義されたマクロにも同じ規則が適用される。

@item @option{-g}などを使用してプリコンパイル済みヘッダーを使用するときにデバッグ情報が出力された場合、プリコンパイル済みヘッダーを構築するときに、同じ種類のデバッグ情報が出力されている必要がある。 ただし、デバッグ情報が出力されていない場合は、コンパイル時に@option{-g}を使用してビルドされたプリコンパイル済みヘッダーを使用できる。

@item プリコンパイルされたヘッダーを構築して使用するときは、通常、同じ@option {-m}オプションを使用する必要がある。この規則が緩和される場合は@xref{Submodel Options}にある。

@item プリコンパイル済みヘッダーを作成して使用する場合は、次の各オプションを同じにする必要がある。

@gccoptlist{-fexceptions}

@item
@option{-f}、@option{-p}、または@option{-O}で始まるいくつかのコマンドラインオプションは、プリコンパイル済みヘッダーが生成されたときと同じ方法で定義する必要がある。  現在、どのオプションを変更するのが安全かどうかは明らかではない。 最も安全な選択は、プリコンパイル済みヘッダーを生成して使用するときに、まったく同じオプションを使用することである。以下は安全であることが知られている：

@gccoptlist{-fmessage-length=  -fpreprocessed  -fsched-interblock 
-fsched-spec  -fsched-spec-load  -fsched-spec-load-dangerous 
-fsched-verbose=@var{number}  -fschedule-insns  -fvisibility= 
-pedantic-errors}

@end itemize
最後のものを除くこれらすべての場合、条件が満たされない場合、コンパイラはプリコンパイル済みヘッダーを自動的に無視する。オプションの組み合わせがうまくいかず、コンパイルされたヘッダーが無視されない場合は、バグレポートを提出することを検討せよ。@ref{Bugs}参照。

プリコンパイル済みヘッダーを生成して使用する際に異なるオプションを使用する場合、実際の動作はオプションの動作の混合である。 たとえば、プリコンパイル済みヘッダーを生成するのに@option{-g}を使用するが、使うときにはしない場合は、プリコンパイル済みヘッダー内のルーチンのデバッグ情報を取得することも、取得しないこともできる。

@node C++ Modules
@section C++モジュール
@cindex speed of compilation

モジュールはC++20言語機能です。 名前が示すように、それらはモジュラーコンパイルシステムを提供し、より高速なビルドとより優れたライブラリ分離の両方を提供することを目的としています。 「Merging Modules」ペーパー@uref{https://wg21.link/p1103}は、後の変更をキャプチャしていませんが、標準に対する一連の変更を最も読みやすく提供しています。 その仕様は現在C++ 20、@uref{git@@github.com:cplusplus/draft.git}の一部であり、完全であると見なされます（今後欠陥報告がある可能性があります）。

@emph{_G++のモジュールのサポートは完成していません。}  バグ以外の既知の欠落部分は次のとおりです。

@table @emph

@item プライベートモジュールフラグメント
プライベートモジュールフラグメントは認識されますが、エラーが発生します。

@item パーティション定義の可視性ルール
エンティティは実装パーティションで定義できますが、それらの定義はモジュールの外部では使用できません。 これは実装されておらず、定義はモジュール外で使用できます。

@item 到達可能なGMエンティティのテキストマージ
エンティティは、異なるヘッダーユニット間で複数定義される場合があります。 これらは重複排除する必要があり、これはインポート間で、またはインポートがテキストで定義されたエンティティを再定義するときに実装されます。 ただし、その逆は実装されていません---インポートされたヘッダーユニットで定義されたエンティティをテキストで再定義します。 再定義エラーが発生します。

@item 翻訳-ユニットのローカル参照ルール
ペーパーp1815（@uref{https://wg21.link/p1815}）およびp2003（@uref{https://wg21.link/p2003}）は、エクスポートされた領域が参照できるエンティティ（たとえば、エンティティ）に制限を追加します。 エクスポートされたテンプレート定義が参照する場合があります）。 これらは完全には実装されていません。
Papers p1815 (@uref{https://wg21.link/p1815}) and p2003

@item 言語リンケージモジュールの添付
明示的な言語リンケージ（@code{extern "C"}または@code{extern "C++"}）を使用した宣言は、名前付きモジュールの範囲内であっても、グローバルモジュールに添付されます。 これは実装されていません。 このような宣言は、宣言されているモジュールに添付されます（存在する場合）。

@item 標準ライブラリヘッダーユニット
標準ライブラリは、インポート可能なヘッダーユニットとして提供されていません。 このようなユニットをインポートする場合は、最初に明示的にビルドする必要があります。これを注意深く行わないと、モジュール機構がマージする必要のある複数の宣言が存在する可能性があります---コンパイラリソースの使用は、ヘッダーファイルをヘッダーユニットに分割する方法によって影響を受ける可能性があります。

@end table

モジュラーコンパイルは、@option{-std=c++20}オプションだけでは有効になりま@emph{_せん_}。 @option{-fmodules-ts}オプションを使用して明示的に有効にする必要があります。 これは、選択した言語バージョンとは無関係ですが、C++20より前のバージョンでは、もちろん拡張機能です。

新しいソースファイルのサフィックスは必要なく、サポートされていません。 非標準のサフィックス（@xref{全体のオプション}）を使用する場合は、@option{-x c++}オプションも指定する必要があります。@footnote{一部のユーザーは、ソースに@code{module.cppm}という名前を付けるなど、新しいサフィックスを持つモジュールインターフェイスファイルを区別することを好みます。これには、新しいサフィックスについてすべてのツールに教えることが含まれます。@code{module-m.cpp}に名前を付けるなど、別のスキームの方が侵襲性が低くなります。}

モジュールインターフェイスユニットをコンパイルすると、コンパイル済みモジュールインターフェイス（CMI）と呼ばれる追加の出力（アセンブリまたはオブジェクトファイルへの）が生成されます。 これは、モジュールのエクスポートされた宣言をエンコードします。 モジュールをインポートすると、CMIが読み込まれます。 インポートグラフは、有向非巡回グラフ（DAG）です。 インポーターの前にインポートをビルドする必要があります。

ヘッダーファイル自体をヘッダーユニットにコンパイルできます。ヘッダーユニットは、コンパイルの高速化を目的とした移行機能です。 @option{-fmodule-header}オプションはこれを有効にするために使用され、@option{-fmodules-ts}オプションを含みます。 これらのCMIは、完全に解決された基になるヘッダーファイルによって名前が付けられるため、サブディレクトリを含む完全なパス名である可能性があります。 ヘッダーファイルが絶対パス名で見つかった場合でも、CMIの場所はCMIルートディレクトリからの相対位置にあります。

ヘッダーファイルには多くの場合サフィックスがないため、通常は@option{-x}オプションを指定して、ソースがヘッダーファイルであることをコンパイラーに通知する必要があります。@option{-x c++-header}、@option{-x c++-user-header}、または@option{-x c++-system-header}を使用できます。 @option{-fmodules-ts}と組み合わせて使用すると、これらはすべて適切な@option{-fmodule-header}オプションを含みます。 後者の2つのバリアントは、ユーザーまたはシステムのインクルードパスを使用して、指定されたファイルを検索します。 これにより、たとえば、標準ライブラリのヘッダーファイルをヘッダーユニットとしてコンパイルできます。インストール場所を正確に知る必要はありません。 これらのバリアントの1つとして言語を指定すると、ヘッダーファイルにオブジェクトファイルが関連付けられていないため、オブジェクトファイルの出力も禁止されます。

@option{-fmodule-only}オプションは、モジュールインターフェイスをコンパイルするための関連オブジェクトファイルの生成を無効にします。 CMIのみが生成されます。このオプションは、@option{-fmodule-header}オプションを使用する場合に暗黙的に示されます。

@option{-flang-info-include-translate}および@option{-flang-info-include-translate-not}オプションは、インクルード変換が発生するかどうかを示します。引数なしでは、前者は全include変換を示します。 後者は、意図的にテキストであることがわかっていないインクルードファイルのすべての非翻訳を示します。引数を使用すると、その特定の末尾のパス名を持つヘッダーファイルのインクルード変換に関するクエリが記録されます。このフォームを繰り返して、いくつかの異なるヘッダーファイルをカバーすることができます。このオプションは、インクルード変換が行われているかどうかを判断するのに役立つ場合があります---正しく機能している場合は、まったく存在しなかったかのように動作します。

@option{-Winvalid-imported-macros}オプションを使用すると、インポートされたすべてのマクロがコンパイルの最後に解決されます。 これがないと、インポートされたマクロは、展開または（再）定義された場合にのみ解決されます。 このオプションは、すべてのマクロの競合するインポート定義を検出します。

@option{-fmodule-mapper}ファミリーのオプションの詳細については、@xref{C++ Module Mapper}を参照してください。

@menu
* C++ Module Mapper::       モジュールマッパー
* C++ Module Preprocessing::  モジュールプリプロセス
* C++ Compiled Module Interface:: コンパイル済みモジュールインターフェース
@end menu

@node C++ Module Mapper
@subsection モジュールマッパー
@cindex C++ Module Mapper

モジュールマッパーは、コンパイラーがモジュール名とCMIファイル間のマッピングを決定するために照会するサーバーまたはファイルを提供します。 また、オンデマンドでCMIを構築するためにも使用されます。 @emph{*マッパーの機能はまだ初期段階であり、ビルドシステムの相互作用を実験することを目的としています。*}

マッパーは、@option{-fmodule-mapper=@var{val}}オプションまたは@env{CXX_MODULE_MAPPER}環境変数を使用して指定できます。 値は、次のいずれかの形式になります。

@table @gcctabopt

@item @r{[}@var{hostname}@r{]}:@var{port}@r{[}?@var{ident}@r{]}
接続するオプションのホスト名と数値のポート番号。 ホスト名を省略すると、ループバックアドレスが使用されます。 ホスト名が複数のIPV6アドレスに対応している場合、1つが成功するまで、これらが順番に試行されます。 ホストにIPv6がない場合、このフォームは機能しません。 IPv4を使用する必要がある場合は@option{-fmodule-mapper='|ncat @var{ipv4host} @var{port}'}を使います。

@item =@var{socket}@r{[}?@var{ident}@r{]}
ローカルドメインソケット。 ホストにローカルドメインソケットがない場合、このフォームは機能しません。

@item |@var{program}@r{[}?@var{ident}@r{]} @r{[}@var{args...}@r{]}
stdin/stdoutストリームで生成し、通信するプログラム。 @var{PATH}環境変数でプログラムが検索されます。 引数はスペース文字で区切られます（プログラムに提供される引数の1つにスペースを含めることはできません）。 例外は、@var{program}が@@で始まる場合です。 その場合、@var{program}（sans @@）はコンパイラの内部バイナリディレクトリで検索されます。 したがって、サンプルのマッパーサーバーは@code{@@g++-mapper-server}で指定できます。

@item <>@r{[}?@var{ident}@r{]}
@item <>@var{inout}@r{[}?@var{ident}@r{]}
@item <@var{in}>@var{out}@r{[}?@var{ident}@r{]}
通信する名前付きパイプまたはファイル記述子。 最初の形式である@option{<>}は、stdinとstdoutを介して通信します。 他の形式では、ファイル記述子を指定したり、パイプに名前を付けたりできます。 数値はファイル記述子として解釈されます。そうでない場合は、名前付きパイプが開かれます。 2番目の形式は双方向パイプを指定し、最後の形式では2つの独立したパイプを指定できます。 この方法でファイル記述子を直接使用すると、中間プロセスの協力が必要になる可能性があるため、一般に脆弱です。 特に、stdinとstdoutを使用すると、他のコンパイラオプションによってコンパイラがstdinを読み取ったり、stdoutを書き込んだりする可能性があり、端末からの信号配信と不幸な相互作用が発生する可能性があるため、危険が伴います。

@item @var{file}@r{[}?@var{ident}@r{]}
スペースで区切られたモジュール名、ファイル名のペア、1行に1つずつで構成されるマッピングファイル。 直接インポートのマッピングとモジュールのエクスポート名のみを指定する必要があります。 他のマッピングが提供されている場合、それらはインポートされたCMIファイルに保存されているマッピングを上書きします。 リポジトリルートは、最初のアクティブな行のモジュール名として@samp{$root}を使用することにより、マッピングファイルで指定できます。

@end table

示されているように、オプションの@var{ident}は、@samp{?}}プレフィックスで示される、オプションの最初の単語の接尾辞になる場合があります。 この値は、モジュールサーバーとの最初のハンドシェイクで、またはマッピングファイル行のプレフィックスを指定するために使用されます。 サーバーの場合、@var{ident}が指定されていない場合は、メインのソースファイル名が使用されます。 ファイルの場合、値が指定されていない限り、空白以外のすべての行が重要です。指定されている場合、@var{ident}で始まる行のみが重要です。 @var{ident}は、モジュール名から空白で区切る必要があります。 @samp{<}、@samp{>}、@samp{?}、および@samp{|}の文字はシェルにとって重要であることが多いため、引用符が必要になる場合があることに注意してください。

最初のモジュールマッピングが必要な場合、マッパーは遅延接続またはロードされます。 ネットワークプロトコルは、ネットワークを提供するホストでのみサポートされます。 マッパーが指定されていない場合、デフォルトが提供されます。

プロジェクト固有のマッパーは、コンパイラーを呼び出すビルドシステムによって提供されることが期待されています。 すべてのコンパイルに汎用サーバーが提供されることは期待されていません。 そのため、サーバーは、ビルド構成、呼び出されたコンパイラー、およびそれが動作している環境（作業ディレクトリなど）を認識します。 ビルドを並列化する可能性があるため、複数のコンパイルが同じソケットに接続する場合があります。

デフォルトのマッパーは、@samp{gcm.cache}ディレクトリにCMIファイルを生成します。 CMIファイルには@samp{.gcm}サフィックスが付いています。 モジュールユニット名は、ベース名を提供するために直接使用されます。 ヘッダーユニットは、基になるヘッダーファイル名を使用して相対パスを作成します。 パスがすでに相対パスである場合は、@samp{,}ディレクトリが先頭に追加されます。 内部の@samp{..}コンポーネントは@samp{,,}に変換されます。 一般にシンボリックリンクが存在する場合はあいまいであるため、プリプロセッサのインクルード検索アルゴリズムによって実行されるファイル名を超えて、これらのファイル名を正規化する試みは行われません。

マッパープロトコルは、「モジュールマッパー」@uref{https://wg21.link/p1184}として公開されました。 実装は、正規のプロトコル定義を指定する@command{libcody}、@uref{https://github.com/urnathan/libcody}によって提供されます。 @command{make}に埋め込まれた概念実証サーバーの実装については、「Make Me A Module」、@uref{https://wg21.link/p1602}で説明されています。

@node C++ Module Preprocessing
@subsection モジュールプリプロセス
@cindex C++ Module Preprocessing

モジュールはヘッダーユニットのために前処理に影響を与え、変換を含みます。 プリプロセッサを個別のステップとして使用すると、正しい出力が生成されないか、CMIが使用可能である必要があります。

ヘッダーユニットはマクロをインポートします。 これらのマクロは、後の条件付きインクルードに影響を与える可能性があるため、異なるインポートセットにカスケードする可能性があります。 前処理の際には、CMIをロードする必要があります。 ヘッダーユニットが使用できない場合、プリプロセッサーは警告を発行して続行します（前処理だけでないときは、エラーが発生します）。 このようなインポートを検出するには、入力ストリームをフェーズ4（マクロ展開）にプリプロセッサでトークン化する必要があります。

インクルード変換は、@code{#include}、@code{#include_next}、および@code {#import}ディレクティブを内部の@code{import}宣言に変換します。 特定のディレクティブが変換されるかどうかは、モジュールマッパーによって制御されます。 ヘッダーユニット名は、前処理中に正規化されます。

マクロのインポートのために依存関係情報を出力して、@option{-MD}および@option{-MMD}オプションの機能を拡張できます。 インポート宣言の検出にはフェーズ4の前処理も必要であるため、完全な前処理（またはコンパイル）が必要です。

@option{-M}、@option{-MM}、および@option{-E -fdirectives-only}オプションは、フェーズ4の前に前処理を停止します。

@option{-save-temps}オプションは、前処理に@option{-fdirectives-only}を使用し、前処理された出力にマクロ定義を保持します。 通常、ヘッダーユニットを明示的に前処理する場合、またはそのような前処理された出力を使用する場合にも、このオプションを使用する必要があります。

@smallexample
g++ -fmodules-ts -E -fdirectives-only my-header.hh -o my-header.ii
g++ -x c++-header -fmodules-ts -fpreprocessed -fdirectives-only my-header.ii
@end smallexample

@node C++ Compiled Module Interface
@subsection コンパイル済みモジュールインターフェース(CMI)
@cindex C++ Compiled Module Interface

CMIは、名前付きモジュールインターフェイス、パーティション、またはヘッダーユニットをコンパイルする際の追加のアーティファクトです。 これらはインポート時に読み取られます。 CMIの内容は実装固有であり、GCCの場合はコンパイラのバージョンに関連付けられています。 それらを、配布可能なオブジェクトではなく、再構築可能なキャッシュアーティファクトと見なしてください。

出力CMIを作成する場合、欠落しているディレクトリコンポーネントは、共通のサブディレクトリツリー内に複数の異なるCMIを作成する同時ビルドに対して安全な方法で作成されます。

CMIの内容は一時ファイルに書き込まれ、一時ファイルの名前がアトミックに変更されます。 オブザーバーは、古いコンテンツ（既存のファイルがある場合）を表示するか、新しいコンテンツを完成させます。 彼らは、CMIの作成中にCMIを監視しません。 これは、外部プロセスによって監視される可能性のあるオブジェクトファイルの書き込みとは異なります。

ホストOSが@code{mmap}機能を提供している場合、CMIは遅延で読み込まれます。 通常、ブロックは、名前のルックアップまたはテンプレートのインスタンス化が発生したときに読み取られます。 これを禁止するには、@option{-fno-module-lazy}オプションを使用できます。

@option{-param lazy-modules=@var{n}}パラメーターは、遅延読み込み中に同時に開くモジュールファイルの数の制限を制御します。 さらにモジュールをインポートする場合は、LRUアルゴリズムを使用して、閉じるファイルを決定します---そのファイルが再び必要になるまで。 この制限は、モジュールの依存関係の階層が深い場合に超える可能性があります。 コードベースが大きい場合、ファイル記述子のプロセス制限よりも多くのインポートが発生する可能性があります。 デフォルトでは、制限は、それが決定可能である場合、プロセスごとのファイル記述子のハード制限よりも数少ないです。@footnote{該当する場合、ソフト制限はハード制限に向かって必要に応じて増分されます。}

GCC CMIは、アーキテクチャに依存しないカプセル化メカニズムとしてELF32を使用します。 @command{readelf}を使用してそれらを検査できますが、セクションの内容はほとんど解読できません。 @code{.gnu.c++.README}という名前のセクションがあり、人間が読めるテキストが含まれています。 最初の行を除いて、各行は@code{@var{tag}: @code{value}}タプルで構成されています。

@smallexample
> @command{readelf -p.gnu.c++.README gcm.cache/foo.gcm}

String dump of section '.gnu.c++.README':
  [     0]  GNU C++ primary module interface
  [    21]  compiler: 11.0.0 20201116 (experimental) [c++-modules revision 20201116-0454]
  [    6f]  version: 2020/11/16-04:54
  [    89]  module: foo
  [    95]  source: c_b.ii
  [    a4]  dialect: C++20/coroutines
  [    be]  cwd: /data/users/nathans/modules/obj/x86_64/gcc
  [    ee]  repository: gcm.cache
  [   104]  buildtime: 2020/11/16 15:03:21 UTC
  [   127]  localtime: 2020/11/16 07:03:21 PST
  [   14a]  export: foo:part1 foo-part1.gcm
@end smallexample

特に、ビルドされたソース、使用されたC++変種、およびモジュールのインポートが一覧表示されます。@footnote{この出力の正確な内容は変更される可能性があります。} タイムスタンプは、@code{__DATE__}と@code{__TIME__}マクロによって提供される値と同じで、環境変数@code{SOURCE_DATE_EPOCH}で明示的に指定できます。 詳細については、@xref{Environment Variables}を参照してください。

相対パス名が保持されている場合は、関連するCMIのセットをコピーできます。

@code{.gnu.c++.README}の内容はCMIの整合性に影響を与えず、削除または変更される可能性があります。 名前が@code{.gnu.c++.}で始まらない、または文字列セクションではないセクションのセクション番号は重要であり、変更してはなりません。
