@c Copyright (C) 1988-2020 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@ignore
@c man begin INCLUDE
@include gcc-vers.texi
@c man end

@c man begin COPYRIGHT
Copyright @copyright{} 1988-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the gfdl(7) man page.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.
@c man end
@c Set file name and title for the man page.
@setfilename gcc
@settitle GNU project C and C++ compiler
@c man begin SYNOPSIS
gcc [@option{-c}|@option{-S}|@option{-E}] [@option{-std=}@var{standard}]
    [@option{-g}] [@option{-pg}] [@option{-O}@var{level}]
    [@option{-W}@var{warn}@dots{}] [@option{-Wpedantic}]
    [@option{-I}@var{dir}@dots{}] [@option{-L}@var{dir}@dots{}]
    [@option{-D}@var{macro}[=@var{defn}]@dots{}] [@option{-U}@var{macro}]
    [@option{-f}@var{option}@dots{}] [@option{-m}@var{machine-option}@dots{}]
    [@option{-o} @var{outfile}] [@@@var{file}] @var{infile}@dots{}

Only the most useful options are listed here; see below for the
remainder.  @command{g++} accepts mostly the same options as @command{gcc}.
@c man end
@c man begin SEEALSO
gpl(7), gfdl(7), fsf-funding(7),
cpp(1), gcov(1), as(1), ld(1), gdb(1), dbx(1)
and the Info entries for @file{gcc}, @file{cpp}, @file{as},
@file{ld}, @file{binutils} and @file{gdb}.
@c man end
@c man begin BUGS
For instructions on reporting bugs, see
@w{@value{BUGURL}}.
@c man end
@c man begin AUTHOR
See the Info entry for @command{gcc}, or
@w{@uref{http://gcc.gnu.org/onlinedocs/gcc/Contributors.html}},
for contributors to GCC@.
@c man end
@end ignore

@node Invoking GCC
@chapter GCCコマンドラインオプション
@cindex GCC command options
@cindex command options
@cindex options, GCC command

@c man begin DESCRIPTION
GCCを呼び出すとき、通常は、プリプロセス、コンパイル、アセンブル、リンクを行う。
「全体のオプション」はこの過程を中間で止めることができる。例えば、
@option{-c}オプションはリンカを走らせないようにする。したがって、
出力はアセンブラによるオブジェクトファイルを含む。
@xref{Overall Options,,出力の種類を制御するオプション}

他のオプションは処理の1つ以上の段階に渡される。あるオプションは
プリプロセスを制御し、他のはコンパイラ自身を制御する。更に別のもはアセンブラや
リンカを制御する。それらのほとんどはここでは文書化しない。なぜならはそれらを使う必要は
殆ど無いからである。

@cindex C compilation options
GCCで使うことができるコマンドラインオプションのほとんどはCプログラムで有用である。
他の言語（大抵はC++）でのみ有用なオプションの場合は、明示的に説明する。
もし特定のオプションの描写でソース言語に言及がないならば、すべてのサポートされている言語で
使うことができる。

@cindex cross compiling
@cindex specifying machine version
@cindex specifying compiler version and target machine
@cindex compiler version, specifying
@cindex target machine, specifying
GCCを走らせる通常の方法は@command{gcc}と呼ばれる実行ファイルを走らせるか、
クロスコンパイルの時は@command{@var{machine}-gcc}、特定のGCCのバージョンの時は
@command{@var{machine}-gcc-@var{version}}である。C++プログラムをコンパイルするときは、
GCCを@command{g++}として起動するべきである。C++プログラムをコンパイルするときの
@command{gcc}と@code{G++}の振る舞いの差につての情報は@xref{Invoking G++,,C++プログラムをコンパイルする}。

@cindex grouping options
@cindex options, grouping
@command{gcc}プログラムはオプションとファイル名をオペランドとして受理する。多くのオプションは複数文字の
名前である。したがって複数の単一文字オプションはグループ化@emph{できない}。@option{-dv}は@w{@samp{-d -v}}とは
全く異なる。

@cindex order of options
@cindex options, order
オプションと他の引数は混ぜることができる。多くの場合で、使う順番は問題にならない。同じ種類のオプションを
複数使う場合は順番が問題になる。例えば、@option{-L}を複数回指定すれば、ディレクトリは指定した順番で
検索される。同様に、@option{-}の位置は意味を持つ。

多くのオプションは@samp{-f}ないし@samp{-W}で始まる長い名前を持つ。例えば@option{-fmove-loop-invariants}, 
@option{-Wformat}など。それらの大抵は肯定形と否定形を持つ。@option{-ffoo}の否定形は@option{-fno-foo}である。
このマニュアルはそれらの形の、デフォルトでない方のみを記述する。

一部のオプションは、オプション名からスペースまたは等号（@samp{=}）で区切られた1つ以上の引数を取ります。
特に記載がない限り、引数は数値または文字列のいずれかです。 数値引数は通常、小さな符号なし10進数または16進数の整数でなければなりません。16進引数は@samp{0x}プレフィックスで始まる必要があります。 ある種のサイズしきい値を指定するオプションの引数は、キロバイトとキビバイトの@code{kB}と@code{KiB}など、複数のバイトを指定するバイトサイズサフィックスが後に続く任意の大きな10進または16進整数です。メガバイトとメビバイトの場合は@code{MB}と@code{MiB}、ギガバイトとギギバイトの場合は@code{GB}と@code{GiB}などです。  このような引数は、次のテキストで@var{byte-size}で指定されます。 2進および10進のバイトサイズプレフィックスの完全なリストと説明については、NIST、IEC、およびその他の関連する国内および国際規格を参照してください。

@c man end

@xref{Option Index}はGCCはオプションの索引である

@menu
* Option Summary::     説明なしの全オプションのリスト
* Overall Options::     出力の種類を制御する。実行ファイル、オブジェクトファイル。
                         アセンブラファイル。プリプロセス済みソース
* Invoking G++::        C++プログラムの実行
* C Dialect Options::    コンパイルされるC言語の変種を制御する.
* C++ Dialect Options::  C++の変種
* bjective-C and Objective-C++ Dialect Options:: Objective-CとObjective-C++の変種
* Diagnostic Message Formatting Options:: 診断がどのように書式化されるかを制御する
* Warning Options::       どのくらいコンパイラがうるさいか
* Debugging Options::   デバッグ可能なコードを生成する
* Optimize Options::    どのくらい最適化するか
* Instrumentation Options::       プロファイリングと追加の実行時エラーチェック
* Preprocessor Options::     ヘッダファイルとマクロ定義の制御。さらにMake用の依存情報を得る
* Assembler Options:: アセンブラに渡すオプション
* Link Options::     ライブラリの指定など
* Directory Options::   ヘッダファイルとライブラリを見つける場所。コンパイラが実行可能ファイルを見つける場所
* Code Gen Options:: 関数呼び出し、データレイアウト、レジスタ使用の規約の指定
* Developer Options:: GCCは設定情報、統計、デバッグダンプの出力
* Submodel Options:: 特定のプロセッサ変種のコンパイルのような、ターゲット固有のオプション
* Spec Files::         サブプロセスへスイッチを渡す方法
* Environment Variables::             GCCに影響する環境変数
* Precompiled Headers:: 一度コンパイルして、何度も使う
@end menu

@c man begin OPTIONS

@node Option Summary
@section オプションの要約

これは全オプションの要約を、タイプ別にグループ化したものである。説明は以下の節にある。

@table @emph
@item 全体のオプション
@xref{Overall Options,,出力の種類を制御するオプション}.
@gccoptlist{-c  -S  -E  -o @var{file}  -x @var{language}
-v  -###  --help@r{[}=@var{class}@r{[},@dots{}@r{]]} --target-help --version
-pass-exit-codes -pipe  -specs=@var{file}  -wrapper
@@@var{file}  -ffile-prefix-map=@var{old}=@var{new}
-fplugin=@var{file}  -fplugin-arg-@var{name}=@var{arg}
-fdump-ada-spec@r{[}-slim@r{]}  -fada-spec-parent=@var{unit}  -fdump-go-spec=@var{file}}

@item C言語オプション
@xref{C Dialect Options,,C変種を制御するオプション}.
@gccoptlist{-ansi  -std=@var{standard}  -fgnu89-inline 
-fpermitted-flt-eval-methods=@var{standard} 
-aux-info @var{filename}  -fallow-parameterless-variadic-functions 
-fno-asm  -fno-builtin  -fno-builtin-@var{function}  -fgimple
-fhosted  -ffreestanding  -fopenacc  -fopenacc-dim=@var{geom} -fopenmp  -fopenmp-simd 
-fms-extensions  -fplan9-extensions  -fsso-struct=@var{endianness} 
-fallow-single-precision  -fcond-mismatch  -flax-vector-conversions 
-fsigned-bitfields  -fsigned-char 
-funsigned-bitfields  -funsigned-char}

@item C++言語オプション
@xref{C++ Dialect Options,,C++変種を制御するオプション}.
@gccoptlist{-fabi-version=@var{n}  -fno-access-control 
-faligned-new=@var{n}  -fargs-in-order=@var{n}  -fchar8_t  -fcheck-new 
-fconstexpr-depth=@var{n}  -fconstexpr-loop-limit=@var{n} 
-fconstexpr-ops-limit=@var{n} -fno-elide-constructors 
-fno-enforce-eh-specs 
-fno-gnu-keywords 
-fno-implicit-templates 
-fno-implicit-inline-templates 
-fno-implement-inlines  -fms-extensions 
-fnew-inheriting-ctors 
-fnew-ttp-matching 
-fno-nonansi-builtins  -fnothrow-opt  -fno-operator-names 
-fno-optional-diags  -fpermissive 
-fno-pretty-templates 
-frepo  -fno-rtti  -fsized-deallocation 
-ftemplate-backtrace-limit=@var{n} 
-ftemplate-depth=@var{n} 
-fno-threadsafe-statics  -fuse-cxa-atexit 
-fno-weak  -nostdinc++ 
-fvisibility-inlines-hidden 
-fvisibility-ms-compat 
-fext-numeric-literals 
-Wabi=@var{n}  -Wabi-tag  -Wconversion-null  -Wctor-dtor-privacy 
-Wdelete-non-virtual-dtor  -Wdeprecated-copy  -Wdeprecated-copy-dtor 
-Wliteral-suffix 
-Wmultiple-inheritance  -Wno-init-list-lifetime 
-Wnamespaces  -Wnarrowing 
-Wpessimizing-move  -Wredundant-move 
-Wnoexcept  -Wnoexcept-type  -Wclass-memaccess 
-Wnon-virtual-dtor  -Wreorder  -Wregister 
-Weffc++  -Wstrict-null-sentinel  -Wtemplates 
-Wno-non-template-friend  -Wold-style-cast 
-Woverloaded-virtual  -Wno-pmf-conversions 
-Wno-class-conversion  -Wno-terminate 
-Wsign-promo  -Wvirtual-inheritance}

@item Objective-CとObjective-C++言語オプション
@xref{Objective-C and Objective-C++ Dialect Options,,Objective-CとObjective-C++変種を制御するオプション}.
@gccoptlist{-fconstant-string-class=@var{class-name} 
-fgnu-runtime  -fnext-runtime 
-fno-nil-receivers 
-fobjc-abi-version=@var{n} 
-fobjc-call-cxx-cdtors 
-fobjc-direct-dispatch 
-fobjc-exceptions 
-fobjc-gc 
-fobjc-nilcheck 
-fobjc-std=objc1 
-fno-local-ivars 
-fivar-visibility=@r{[}public@r{|}protected@r{|}private@r{|}package@r{]} 
-freplace-objc-classes 
-fzero-link 
-gen-decls 
-Wassign-intercept 
-Wno-protocol  -Wselector 
-Wstrict-selector-match 
-Wundeclared-selector}

@item 診断メッセージ書式化オプション
@xref{Diagnostic Message Formatting Options,,診断メッセージの書式を制御するオプション}.
@gccoptlist{-fmessage-length=@var{n}  
-fdiagnostics-show-location=@r{[}once@r{|}every-line@r{]}  
-fdiagnostics-color=@r{[}auto@r{|}never@r{|}always@r{]}  
-fdiagnostics-format=@r{[}text@r{|}json@r{]}  
-fno-diagnostics-show-option  -fno-diagnostics-show-caret 
-fno-diagnostics-show-labels  -fno-diagnostics-show-line-numbers 
-fdiagnostics-minimum-margin-width=@var{width} 
-fdiagnostics-parseable-fixits  -fdiagnostics-generate-patch 
-fdiagnostics-show-template-tree  -fno-elide-type 
-fno-show-column}

@item 警告オプション
@xref{Warning Options,,警告の要求・抑制をするオプション}.
@gccoptlist{-fsyntax-only  -fmax-errors=@var{n}  -Wpedantic 
-pedantic-errors 
-w  -Wextra  -Wall  -Waddress  -Waddress-of-packed-member 
-Waggregate-return  -Waligned-new 
-Walloc-zero  -Walloc-size-larger-than=@var{byte-size} 
-Walloca  -Walloca-larger-than=@var{byte-size} 
-Wno-aggressive-loop-optimizations  -Warray-bounds  -Warray-bounds=@var{n} 
-Wno-attributes  -Wattribute-alias=@var{n}  
-Wbool-compare  -Wbool-operation 
-Wno-builtin-declaration-mismatch 
-Wno-builtin-macro-redefined  -Wc90-c99-compat  -Wc99-c11-compat 
-Wc++-compat  -Wc++11-compat  -Wc++14-compat  -Wc++17-compat  
-Wcast-align  -Wcast-align=strict  -Wcast-function-type  -Wcast-qual  
-Wchar-subscripts  -Wcatch-value  -Wcatch-value=@var{n} 
-Wclobbered  -Wcomment  -Wconditionally-supported 
-Wconversion  -Wcoverage-mismatch  -Wno-cpp  -Wdangling-else  -Wdate-time 
-Wdelete-incomplete 
-Wno-attribute-warning 
-Wno-deprecated  -Wno-deprecated-declarations  -Wno-designated-init 
-Wdisabled-optimization 
-Wno-discarded-qualifiers  -Wno-discarded-array-qualifiers 
-Wno-div-by-zero  -Wdouble-promotion 
-Wduplicated-branches  -Wduplicated-cond 
-Wempty-body  -Wenum-compare  -Wno-endif-labels  -Wexpansion-to-defined 
-Werror  -Werror=*  -Wextra-semi  -Wfatal-errors 
-Wfloat-equal  -Wformat  -Wformat=2 
-Wno-format-contains-nul  -Wno-format-extra-args  
-Wformat-nonliteral  -Wformat-overflow=@var{n} 
-Wformat-security  -Wformat-signedness  -Wformat-truncation=@var{n} 
-Wformat-y2k  -Wframe-address 
-Wframe-larger-than=@var{byte-size}  -Wno-free-nonheap-object 
-Wjump-misses-init 
-Whsa  -Wif-not-aligned 
-Wignored-qualifiers  -Wignored-attributes  -Wincompatible-pointer-types 
-Wimplicit  -Wimplicit-fallthrough  -Wimplicit-fallthrough=@var{n} 
-Wimplicit-function-declaration  -Wimplicit-int 
-Winit-self  -Winline  -Wno-int-conversion  -Wint-in-bool-context 
-Wno-int-to-pointer-cast  -Winvalid-memory-model  -Wno-invalid-offsetof 
-Winvalid-pch  -Wlarger-than=@var{byte-size} 
-Wlogical-op  -Wlogical-not-parentheses  -Wlong-long 
-Wmain  -Wmaybe-uninitialized  -Wmemset-elt-size  -Wmemset-transposed-args 
-Wmisleading-indentation  -Wmissing-attributes  -Wmissing-braces 
-Wmissing-field-initializers  -Wmissing-format-attribute 
-Wmissing-include-dirs  -Wmissing-noreturn  -Wmissing-profile 
-Wno-multichar  -Wmultistatement-macros  -Wnonnull  -Wnonnull-compare 
-Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]} 
-Wnull-dereference  -Wodr  -Wno-overflow  -Wopenmp-simd  
-Woverride-init-side-effects  -Woverlength-strings 
-Wpacked  -Wpacked-bitfield-compat -Wpacked-not-aligned  -Wpadded 
-Wparentheses  -Wno-pedantic-ms-format 
-Wplacement-new  -Wplacement-new=@var{n} 
-Wpointer-arith  -Wpointer-compare  -Wno-pointer-to-int-cast 
-Wno-pragmas  -Wno-prio-ctor-dtor  -Wredundant-decls 
-Wrestrict  -Wno-return-local-addr 
-Wreturn-type  -Wsequence-point  -Wshadow  -Wno-shadow-ivar 
-Wshadow=global,  -Wshadow=local,  -Wshadow=compatible-local 
-Wshift-overflow  -Wshift-overflow=@var{n} 
-Wshift-count-negative  -Wshift-count-overflow  -Wshift-negative-value 
-Wsign-compare  -Wsign-conversion  -Wfloat-conversion 
-Wno-scalar-storage-order  -Wsizeof-pointer-div 
-Wsizeof-pointer-memaccess  -Wsizeof-array-argument 
-Wstack-protector  -Wstack-usage=@var{byte-size}  -Wstrict-aliasing 
-Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} 
-Wstringop-overflow=@var{n}  -Wstringop-truncation  -Wsubobject-linkage 
-Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} 
-Wsuggest-final-types   -Wsuggest-final-methods  -Wsuggest-override 
-Wswitch  -Wswitch-bool  -Wswitch-default  -Wswitch-enum 
-Wswitch-unreachable  -Wsync-nand 
-Wsystem-headers  -Wtautological-compare  -Wtrampolines  -Wtrigraphs 
-Wtype-limits  -Wundef 
-Wuninitialized  -Wunknown-pragmas 
-Wunsuffixed-float-constants  -Wunused  -Wunused-function 
-Wunused-label  -Wunused-local-typedefs  -Wunused-macros 
-Wunused-parameter  -Wno-unused-result 
-Wunused-value  -Wunused-variable 
-Wunused-const-variable  -Wunused-const-variable=@var{n} 
-Wunused-but-set-parameter  -Wunused-but-set-variable 
-Wuseless-cast  -Wvariadic-macros  -Wvector-operation-performance 
-Wvla  -Wvla-larger-than=@var{byte-size}  -Wvolatile-register-var 
-Wwrite-strings 
-Wzero-as-null-pointer-constant}

@item CとObjective-C専用の警告オプション
@gccoptlist{-Wbad-function-cast  -Wmissing-declarations 
-Wmissing-parameter-type  -Wmissing-prototypes  -Wnested-externs 
-Wold-style-declaration  -Wold-style-definition 
-Wstrict-prototypes  -Wtraditional  -Wtraditional-conversion 
-Wdeclaration-after-statement  -Wpointer-sign}

@item デバッグオプション
@xref{Debugging Options,,あなたのプログラムをデバッグするためのオプション}.
@gccoptlist{-g  -g@var{level}  -gdwarf  -gdwarf-@var{version} 
-ggdb  -grecord-gcc-switches  -gno-record-gcc-switches 
-gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf 
-gas-loc-support  -gno-as-loc-support 
-gas-locview-support  -gno-as-locview-support 
-gcolumn-info  -gno-column-info 
-gstatement-frontiers  -gno-statement-frontiers 
-gvariable-location-views  -gno-variable-location-views 
-ginternal-reset-location-views  -gno-internal-reset-location-views 
-ginline-points  -gno-inline-points 
-gvms  -gxcoff  -gxcoff+  -gz@r{[}=@var{type}@r{]} 
-gsplit-dwarf  -gdescribe-dies  -gno-describe-dies 
-fdebug-prefix-map=@var{old}=@var{new}  -fdebug-types-section 
-fno-eliminate-unused-debug-types 
-femit-struct-debug-baseonly  -femit-struct-debug-reduced 
-femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]} 
-feliminate-unused-debug-symbols  -femit-class-debug-always 
-fno-merge-debug-strings  -fno-dwarf2-cfi-asm 
-fvar-tracking  -fvar-tracking-assignments}

@item 最適化オプション
@xref{Optimize Options,,最適化を制御するオプション}.
@gccoptlist{-faggressive-loop-optimizations 
-falign-functions[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-falign-jumps[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-falign-labels[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-falign-loops[=@var{n}[:@var{m}:[@var{n2}[:@var{m2}]]]] 
-fassociative-math  -fauto-profile  -fauto-profile[=@var{path}] 
-fauto-inc-dec  -fbranch-probabilities 
-fbranch-target-load-optimize  -fbranch-target-load-optimize2 
-fbtr-bb-exclusive  -fcaller-saves 
-fcombine-stack-adjustments  -fconserve-stack 
-fcompare-elim  -fcprop-registers  -fcrossjumping 
-fcse-follow-jumps  -fcse-skip-blocks  -fcx-fortran-rules 
-fcx-limited-range 
-fdata-sections  -fdce  -fdelayed-branch 
-fdelete-null-pointer-checks  -fdevirtualize  -fdevirtualize-speculatively 
-fdevirtualize-at-ltrans  -fdse 
-fearly-inlining  -fipa-sra  -fexpensive-optimizations  -ffat-lto-objects 
-ffast-math  -ffinite-math-only  -ffloat-store  -fexcess-precision=@var{style} 
-fforward-propagate  -ffp-contract=@var{style}  -ffunction-sections 
-fgcse  -fgcse-after-reload  -fgcse-las  -fgcse-lm  -fgraphite-identity 
-fgcse-sm  -fhoist-adjacent-loads  -fif-conversion 
-fif-conversion2  -findirect-inlining 
-finline-functions  -finline-functions-called-once  -finline-limit=@var{n} 
-finline-small-functions  -fipa-cp  -fipa-cp-clone 
-fipa-bit-cp  -fipa-vrp  -fipa-pta  -fipa-profile  -fipa-pure-const 
-fipa-reference  -fipa-reference-addressable 
-fipa-stack-alignment  -fipa-icf  -fira-algorithm=@var{algorithm} 
-flive-patching=@var{level} 
-fira-region=@var{region}  -fira-hoist-pressure 
-fira-loop-pressure  -fno-ira-share-save-slots 
-fno-ira-share-spill-slots 
-fisolate-erroneous-paths-dereference  -fisolate-erroneous-paths-attribute 
-fivopts  -fkeep-inline-functions  -fkeep-static-functions 
-fkeep-static-consts  -flimit-function-alignment  -flive-range-shrinkage 
-floop-block  -floop-interchange  -floop-strip-mine 
-floop-unroll-and-jam  -floop-nest-optimize 
-floop-parallelize-all  -flra-remat  -flto  -flto-compression-level 
-flto-partition=@var{alg}  -fmerge-all-constants 
-fmerge-constants  -fmodulo-sched  -fmodulo-sched-allow-regmoves 
-fmove-loop-invariants  -fno-branch-count-reg 
-fno-defer-pop  -fno-fp-int-builtin-inexact  -fno-function-cse 
-fno-guess-branch-probability  -fno-inline  -fno-math-errno  -fno-peephole 
-fno-peephole2  -fno-printf-return-value  -fno-sched-interblock 
-fno-sched-spec  -fno-signed-zeros 
-fno-toplevel-reorder  -fno-trapping-math  -fno-zero-initialized-in-bss 
-fomit-frame-pointer  -foptimize-sibling-calls 
-fpartial-inlining  -fpeel-loops  -fpredictive-commoning 
-fprefetch-loop-arrays 
-fprofile-correction 
-fprofile-use  -fprofile-use=@var{path}  -fprofile-values 
-fprofile-reorder-functions 
-freciprocal-math  -free  -frename-registers  -freorder-blocks 
-freorder-blocks-algorithm=@var{algorithm} 
-freorder-blocks-and-partition  -freorder-functions 
-frerun-cse-after-loop  -freschedule-modulo-scheduled-loops 
-frounding-math  -fsave-optimization-record 
-fsched2-use-superblocks  -fsched-pressure 
-fsched-spec-load  -fsched-spec-load-dangerous 
-fsched-stalled-insns-dep[=@var{n}]  -fsched-stalled-insns[=@var{n}] 
-fsched-group-heuristic  -fsched-critical-path-heuristic 
-fsched-spec-insn-heuristic  -fsched-rank-heuristic 
-fsched-last-insn-heuristic  -fsched-dep-count-heuristic 
-fschedule-fusion 
-fschedule-insns  -fschedule-insns2  -fsection-anchors 
-fselective-scheduling  -fselective-scheduling2 
-fsel-sched-pipelining  -fsel-sched-pipelining-outer-loops 
-fsemantic-interposition  -fshrink-wrap  -fshrink-wrap-separate 
-fsignaling-nans 
-fsingle-precision-constant  -fsplit-ivs-in-unroller  -fsplit-loops
-fsplit-paths 
-fsplit-wide-types  -fssa-backprop  -fssa-phiopt 
-fstdarg-opt  -fstore-merging  -fstrict-aliasing 
-fthread-jumps  -ftracer  -ftree-bit-ccp 
-ftree-builtin-call-dce  -ftree-ccp  -ftree-ch 
-ftree-coalesce-vars  -ftree-copy-prop  -ftree-dce  -ftree-dominator-opts 
-ftree-dse  -ftree-forwprop  -ftree-fre  -fcode-hoisting 
-ftree-loop-if-convert  -ftree-loop-im 
-ftree-phiprop  -ftree-loop-distribution  -ftree-loop-distribute-patterns 
-ftree-loop-ivcanon  -ftree-loop-linear  -ftree-loop-optimize 
-ftree-loop-vectorize 
-ftree-parallelize-loops=@var{n}  -ftree-pre  -ftree-partial-pre  -ftree-pta 
-ftree-reassoc  -ftree-scev-cprop  -ftree-sink  -ftree-slsr  -ftree-sra 
-ftree-switch-conversion  -ftree-tail-merge 
-ftree-ter  -ftree-vectorize  -ftree-vrp  -funconstrained-commons 
-funit-at-a-time  -funroll-all-loops  -funroll-loops 
-funsafe-math-optimizations  -funswitch-loops 
-fipa-ra  -fvariable-expansion-in-unroller  -fvect-cost-model  -fvpt 
-fweb  -fwhole-program  -fwpa  -fuse-linker-plugin 
--param @var{name}=@var{value}
-O  -O0  -O1  -O2  -O3  -Os  -Ofast  -Og}

@item プログラム計装オプション
@xref{Instrumentation Options,,プログラム計装オプション}.
@gccoptlist{-p  -pg  -fprofile-arcs  --coverage  -ftest-coverage 
-fprofile-abs-path 
-fprofile-dir=@var{path}  -fprofile-generate  -fprofile-generate=@var{path} 
-fprofile-update=@var{method}  -fprofile-filter-files=@var{regex} 
-fprofile-exclude-files=@var{regex} 
-fsanitize=@var{style}  -fsanitize-recover  -fsanitize-recover=@var{style} 
-fasan-shadow-offset=@var{number}  -fsanitize-sections=@var{s1},@var{s2},... 
-fsanitize-undefined-trap-on-error  -fbounds-check 
-fcf-protection=@r{[}full@r{|}branch@r{|}return@r{|}none@r{]} 
-fstack-protector  -fstack-protector-all  -fstack-protector-strong 
-fstack-protector-explicit  -fstack-check 
-fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} 
-fno-stack-limit  -fsplit-stack 
-fvtable-verify=@r{[}std@r{|}preinit@r{|}none@r{]} 
-fvtv-counts  -fvtv-debug 
-finstrument-functions 
-finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} 
-finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{}}

@item プリプロセスオプション
@xref{Preprocessor Options,,プリプロセスを制御するオプション}.
@gccoptlist{-A@var{question}=@var{answer} 
-A-@var{question}@r{[}=@var{answer}@r{]} 
-C  -CC  -D@var{macro}@r{[}=@var{defn}@r{]} 
-dD  -dI  -dM  -dN  -dU 
-fdebug-cpp  -fdirectives-only  -fdollars-in-identifiers  
-fexec-charset=@var{charset}  -fextended-identifiers  
-finput-charset=@var{charset}  -fmacro-prefix-map=@var{old}=@var{new}  
-fno-canonical-system-headers  -fpch-deps  -fpch-preprocess  
-fpreprocessed  -ftabstop=@var{width}  -ftrack-macro-expansion  
-fwide-exec-charset=@var{charset}  -fworking-directory 
-H  -imacros @var{file}  -include @var{file} 
-M  -MD  -MF  -MG  -MM  -MMD  -MP  -MQ  -MT 
-no-integrated-cpp  -P  -pthread  -remap 
-traditional  -traditional-cpp  -trigraphs 
-U@var{macro}  -undef  
-Wp,@var{option}  -Xpreprocessor @var{option}}

@item アセンブラオプション
@xref{Assembler Options,,アセンブラに渡すオプション}.
@gccoptlist{-Wa,@var{option}  -Xassembler @var{option}}

@item リンカオプション
@xref{Link Options,,リンクのオプション}.
@gccoptlist{@var{object-file-name}  -fuse-ld=@var{linker}  -l@var{library} 
-nostartfiles  -nodefaultlibs  -nolibc  -nostdlib 
-e @var{entry}  --entry=@var{entry} 
-pie  -pthread  -r  -rdynamic 
-s  -static  -static-pie  -static-libgcc  -static-libstdc++ 
-static-libasan  -static-libtsan  -static-liblsan  -static-libubsan 
-shared  -shared-libgcc  -symbolic 
-T @var{script}  -Wl,@var{option}  -Xlinker @var{option} 
-u @var{symbol}  -z @var{keyword}}

@item ディレクトリオプション
@xref{Directory Options,,ディレクトリ検索オプション}.
@gccoptlist{-B@var{prefix}  -I@var{dir}  -I- 
-idirafter @var{dir} 
-imacros @var{file}  -imultilib @var{dir} 
-iplugindir=@var{dir}  -iprefix @var{file} 
-iquote @var{dir}  -isysroot @var{dir}  -isystem @var{dir} 
-iwithprefix @var{dir}  -iwithprefixbefore @var{dir}  
-L@var{dir}  -no-canonical-prefixes  --no-sysroot-suffix 
-nostdinc  -nostdinc++  --sysroot=@var{dir}}


@item コード生成オプション
@xref{Code Gen Options,,コード生成規約オプション}.
@gccoptlist{-fcall-saved-@var{reg}  -fcall-used-@var{reg} 
-ffixed-@var{reg}  -fexceptions 
-fnon-call-exceptions  -fdelete-dead-exceptions  -funwind-tables 
-fasynchronous-unwind-tables 
-fno-gnu-unique 
-finhibit-size-directive  -fno-common  -fno-ident 
-fpcc-struct-return  -fpic  -fPIC  -fpie  -fPIE  -fno-plt 
-fno-jump-tables 
-frecord-gcc-switches 
-freg-struct-return  -fshort-enums  -fshort-wchar 
-fverbose-asm  -fpack-struct[=@var{n}]  
-fleading-underscore  -ftls-model=@var{model} 
-fstack-reuse=@var{reuse_level} 
-ftrampolines  -ftrapv  -fwrapv 
-fvisibility=@r{[}default@r{|}internal@r{|}hidden@r{|}protected@r{]} 
-fstrict-volatile-bitfields  -fsync-libcalls}

@item デベロッパオプション
@xref{Developer Options,,GCCデベロッパオプション}.
@gccoptlist{-d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion 
-dumpfullversion  -fchecking  -fchecking=@var{n}  -fdbg-cnt-list 
-fdbg-cnt=@var{counter-value-list} 
-fdisable-ipa-@var{pass_name} 
-fdisable-rtl-@var{pass_name} 
-fdisable-rtl-@var{pass-name}=@var{range-list} 
-fdisable-tree-@var{pass_name} 
-fdisable-tree-@var{pass-name}=@var{range-list} 
-fdump-debug  -fdump-earlydebug 
-fdump-noaddr  -fdump-unnumbered  -fdump-unnumbered-links 
-fdump-final-insns@r{[}=@var{file}@r{]} 
-fdump-ipa-all  -fdump-ipa-cgraph  -fdump-ipa-inline 
-fdump-lang-all 
-fdump-lang-@var{switch} 
-fdump-lang-@var{switch}-@var{options} 
-fdump-lang-@var{switch}-@var{options}=@var{filename} 
-fdump-passes 
-fdump-rtl-@var{pass}  -fdump-rtl-@var{pass}=@var{filename} 
-fdump-statistics 
-fdump-tree-all 
-fdump-tree-@var{switch} 
-fdump-tree-@var{switch}-@var{options} 
-fdump-tree-@var{switch}-@var{options}=@var{filename} 
-fcompare-debug@r{[}=@var{opts}@r{]}  -fcompare-debug-second 
-fenable-@var{kind}-@var{pass} 
-fenable-@var{kind}-@var{pass}=@var{range-list} 
-fira-verbose=@var{n} 
-flto-report  -flto-report-wpa  -fmem-report-wpa 
-fmem-report  -fpre-ipa-mem-report  -fpost-ipa-mem-report 
-fopt-info  -fopt-info-@var{options}@r{[}=@var{file}@r{]} 
-fprofile-report 
-frandom-seed=@var{string}  -fsched-verbose=@var{n} 
-fsel-sched-verbose  -fsel-sched-dump-cfg  -fsel-sched-pipelining-verbose 
-fstats  -fstack-usage  -ftime-report  -ftime-report-details 
-fvar-tracking-assignments-toggle  -gtoggle 
-print-file-name=@var{library}  -print-libgcc-file-name 
-print-multi-directory  -print-multi-lib  -print-multi-os-directory 
-print-prog-name=@var{program}  -print-search-dirs  -Q 
-print-sysroot  -print-sysroot-headers-suffix 
-save-temps  -save-temps=cwd  -save-temps=obj  -time@r{[}=@var{file}@r{]}}

@item 機種依存オプション
@xref{Submodel Options,,機種依存オプション}.
@c This list is ordered alphanumerically by subsection name.
@c Try and put the significant identifier (CPU or system) first,
@c so users have a clue at guessing where the ones they want will be.

@emph{AArch64 Options}
@gccoptlist{-mabi=@var{name}  -mbig-endian  -mlittle-endian 
-mgeneral-regs-only 
-mcmodel=tiny  -mcmodel=small  -mcmodel=large 
-mstrict-align  -mno-strict-align 
-momit-leaf-frame-pointer 
-mtls-dialect=desc  -mtls-dialect=traditional 
-mtls-size=@var{size} 
-mfix-cortex-a53-835769  -mfix-cortex-a53-843419 
-mlow-precision-recip-sqrt  -mlow-precision-sqrt  -mlow-precision-div 
-mpc-relative-literal-loads 
-msign-return-address=@var{scope} 
-mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}]|@var{bti} 
-march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}  
-moverride=@var{string}  -mverbose-cost-dump 
-mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{sysreg} 
-mstack-protector-guard-offset=@var{offset} -mtrack-speculation }

@emph{Adapteva Epiphany Options}
@gccoptlist{-mhalf-reg-file  -mprefer-short-insn-regs 
-mbranch-cost=@var{num}  -mcmove  -mnops=@var{num}  -msoft-cmpsf 
-msplit-lohi  -mpost-inc  -mpost-modify  -mstack-offset=@var{num} 
-mround-nearest  -mlong-calls  -mshort-calls  -msmall16 
-mfp-mode=@var{mode}  -mvect-double  -max-vect-align=@var{num} 
-msplit-vecmove-early  -m1reg-@var{reg}}

@emph{AMD GCN Options}
@gccoptlist{-march=@var{gpu} -mtune=@var{gpu} -mstack-size=@var{bytes}}

@emph{ARC Options}
@gccoptlist{-mbarrel-shifter  -mjli-always 
-mcpu=@var{cpu}  -mA6  -mARC600  -mA7  -mARC700 
-mdpfp  -mdpfp-compact  -mdpfp-fast  -mno-dpfp-lrsr 
-mea  -mno-mpy  -mmul32x16  -mmul64  -matomic 
-mnorm  -mspfp  -mspfp-compact  -mspfp-fast  -msimd  -msoft-float  -mswap 
-mcrc  -mdsp-packa  -mdvbf  -mlock  -mmac-d16  -mmac-24  -mrtsc  -mswape 
-mtelephony  -mxy  -misize  -mannotate-align  -marclinux  -marclinux_prof 
-mlong-calls  -mmedium-calls  -msdata  -mirq-ctrl-saved 
-mrgf-banked-regs  -mlpc-width=@var{width}  -G @var{num} 
-mvolatile-cache  -mtp-regno=@var{regno} 
-malign-call  -mauto-modify-reg  -mbbit-peephole  -mno-brcc 
-mcase-vector-pcrel  -mcompact-casesi  -mno-cond-exec  -mearly-cbranchsi 
-mexpand-adddi  -mindexed-loads  -mlra  -mlra-priority-none 
-mlra-priority-compact mlra-priority-noncompact  -mmillicode 
-mmixed-code  -mq-class  -mRcq  -mRcw  -msize-level=@var{level} 
-mtune=@var{cpu}  -mmultcost=@var{num}  -mcode-density-frame 
-munalign-prob-threshold=@var{probability}  -mmpy-option=@var{multo} 
-mdiv-rem  -mcode-density  -mll64  -mfpu=@var{fpu}  -mrf16  -mbranch-index}

@emph{ARM Options}
@gccoptlist{-mapcs-frame  -mno-apcs-frame 
-mabi=@var{name} 
-mapcs-stack-check  -mno-apcs-stack-check 
-mapcs-reentrant  -mno-apcs-reentrant 
-mgeneral-regs-only 
-msched-prolog  -mno-sched-prolog 
-mlittle-endian  -mbig-endian 
-mbe8  -mbe32 
-mfloat-abi=@var{name} 
-mfp16-format=@var{name}
-mthumb-interwork  -mno-thumb-interwork 
-mcpu=@var{name}  -march=@var{name}  -mfpu=@var{name}  
-mtune=@var{name}  -mprint-tune-info 
-mstructure-size-boundary=@var{n} 
-mabort-on-noreturn 
-mlong-calls  -mno-long-calls 
-msingle-pic-base  -mno-single-pic-base 
-mpic-register=@var{reg} 
-mnop-fun-dllimport 
-mpoke-function-name 
-mthumb  -marm  -mflip-thumb 
-mtpcs-frame  -mtpcs-leaf-frame 
-mcaller-super-interworking  -mcallee-super-interworking 
-mtp=@var{name}  -mtls-dialect=@var{dialect} 
-mword-relocations 
-mfix-cortex-m3-ldrd 
-munaligned-access 
-mneon-for-64bits 
-mslow-flash-data 
-masm-syntax-unified 
-mrestrict-it 
-mverbose-cost-dump 
-mpure-code 
-mcmse}

@emph{AVR Options}
@gccoptlist{-mmcu=@var{mcu}  -mabsdata  -maccumulate-args 
-mbranch-cost=@var{cost} 
-mcall-prologues  -mgas-isr-prologues  -mint8 
-mn_flash=@var{size}  -mno-interrupts 
-mmain-is-OS_task  -mrelax  -mrmw  -mstrict-X  -mtiny-stack 
-mfract-convert-truncate 
-mshort-calls  -nodevicelib 
-Waddr-space-convert  -Wmisspelled-isr}

@emph{Blackfin Options}
@gccoptlist{-mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]} 
-msim  -momit-leaf-frame-pointer  -mno-omit-leaf-frame-pointer 
-mspecld-anomaly  -mno-specld-anomaly  -mcsync-anomaly  -mno-csync-anomaly 
-mlow-64k  -mno-low64k  -mstack-check-l1  -mid-shared-library 
-mno-id-shared-library  -mshared-library-id=@var{n} 
-mleaf-id-shared-library  -mno-leaf-id-shared-library 
-msep-data  -mno-sep-data  -mlong-calls  -mno-long-calls 
-mfast-fp  -minline-plt  -mmulticore  -mcorea  -mcoreb  -msdram 
-micplb}

@emph{C6X Options}
@gccoptlist{-mbig-endian  -mlittle-endian  -march=@var{cpu} 
-msim  -msdata=@var{sdata-type}}

@emph{CRIS Options}
@gccoptlist{-mcpu=@var{cpu}  -march=@var{cpu}  -mtune=@var{cpu} 
-mmax-stack-frame=@var{n}  -melinux-stacksize=@var{n} 
-metrax4  -metrax100  -mpdebug  -mcc-init  -mno-side-effects 
-mstack-align  -mdata-align  -mconst-align 
-m32-bit  -m16-bit  -m8-bit  -mno-prologue-epilogue  -mno-gotplt 
-melf  -maout  -melinux  -mlinux  -sim  -sim2 
-mmul-bug-workaround  -mno-mul-bug-workaround}

@emph{CR16 Options}
@gccoptlist{-mmac 
-mcr16cplus  -mcr16c 
-msim  -mint32  -mbit-ops
-mdata-model=@var{model}}

@emph{C-SKY Options}
@gccoptlist{-march=@var{arch}  -mcpu=@var{cpu} 
-mbig-endian  -EB  -mlittle-endian  -EL 
-mhard-float  -msoft-float  -mfpu=@var{fpu}  -mdouble-float  -mfdivdu 
-melrw  -mistack  -mmp  -mcp  -mcache  -msecurity  -mtrust 
-mdsp  -medsp  -mvdsp 
-mdiv  -msmart  -mhigh-registers  -manchor 
-mpushpop  -mmultiple-stld  -mconstpool  -mstack-size  -mccrt 
-mbranch-cost=@var{n}  -mcse-cc  -msched-prolog}

@emph{Darwin Options}
@gccoptlist{-all_load  -allowable_client  -arch  -arch_errors_fatal 
-arch_only  -bind_at_load  -bundle  -bundle_loader 
-client_name  -compatibility_version  -current_version 
-dead_strip 
-dependency-file  -dylib_file  -dylinker_install_name 
-dynamic  -dynamiclib  -exported_symbols_list 
-filelist  -flat_namespace  -force_cpusubtype_ALL 
-force_flat_namespace  -headerpad_max_install_names 
-iframework 
-image_base  -init  -install_name  -keep_private_externs 
-multi_module  -multiply_defined  -multiply_defined_unused 
-noall_load   -no_dead_strip_inits_and_terms 
-nofixprebinding  -nomultidefs  -noprebind  -noseglinkedit 
-pagezero_size  -prebind  -prebind_all_twolevel_modules 
-private_bundle  -read_only_relocs  -sectalign 
-sectobjectsymbols  -whyload  -seg1addr 
-sectcreate  -sectobjectsymbols  -sectorder 
-segaddr  -segs_read_only_addr  -segs_read_write_addr 
-seg_addr_table  -seg_addr_table_filename  -seglinkedit 
-segprot  -segs_read_only_addr  -segs_read_write_addr 
-single_module  -static  -sub_library  -sub_umbrella 
-twolevel_namespace  -umbrella  -undefined 
-unexported_symbols_list  -weak_reference_mismatches 
-whatsloaded  -F  -gused  -gfull  -mmacosx-version-min=@var{version} 
-mkernel  -mone-byte-bool}

@emph{DEC Alpha Options}
@gccoptlist{-mno-fp-regs  -msoft-float 
-mieee  -mieee-with-inexact  -mieee-conformant 
-mfp-trap-mode=@var{mode}  -mfp-rounding-mode=@var{mode} 
-mtrap-precision=@var{mode}  -mbuild-constants 
-mcpu=@var{cpu-type}  -mtune=@var{cpu-type} 
-mbwx  -mmax  -mfix  -mcix 
-mfloat-vax  -mfloat-ieee 
-mexplicit-relocs  -msmall-data  -mlarge-data 
-msmall-text  -mlarge-text 
-mmemory-latency=@var{time}}

@emph{FR30 Options}
@gccoptlist{-msmall-model  -mno-lsim}

@emph{FT32 Options}
@gccoptlist{-msim  -mlra  -mnodiv  -mft32b  -mcompress  -mnopm}

@emph{FRV Options}
@gccoptlist{-mgpr-32  -mgpr-64  -mfpr-32  -mfpr-64 
-mhard-float  -msoft-float 
-malloc-cc  -mfixed-cc  -mdword  -mno-dword 
-mdouble  -mno-double 
-mmedia  -mno-media  -mmuladd  -mno-muladd 
-mfdpic  -minline-plt  -mgprel-ro  -multilib-library-pic 
-mlinked-fp  -mlong-calls  -malign-labels 
-mlibrary-pic  -macc-4  -macc-8 
-mpack  -mno-pack  -mno-eflags  -mcond-move  -mno-cond-move 
-moptimize-membar  -mno-optimize-membar 
-mscc  -mno-scc  -mcond-exec  -mno-cond-exec 
-mvliw-branch  -mno-vliw-branch 
-mmulti-cond-exec  -mno-multi-cond-exec  -mnested-cond-exec 
-mno-nested-cond-exec  -mtomcat-stats 
-mTLS  -mtls 
-mcpu=@var{cpu}}

@emph{GNU/Linux Options}
@gccoptlist{-mglibc  -muclibc  -mmusl  -mbionic  -mandroid 
-tno-android-cc  -tno-android-ld}

@emph{H8/300 Options}
@gccoptlist{-mrelax  -mh  -ms  -mn  -mexr  -mno-exr  -mint32  -malign-300}

@emph{HPPA Options}
@gccoptlist{-march=@var{architecture-type} 
-mcaller-copies  -mdisable-fpregs  -mdisable-indexing 
-mfast-indirect-calls  -mgas  -mgnu-ld   -mhp-ld 
-mfixed-range=@var{register-range} 
-mjump-in-delay  -mlinker-opt  -mlong-calls 
-mlong-load-store  -mno-disable-fpregs 
-mno-disable-indexing  -mno-fast-indirect-calls  -mno-gas 
-mno-jump-in-delay  -mno-long-load-store 
-mno-portable-runtime  -mno-soft-float 
-mno-space-regs  -msoft-float  -mpa-risc-1-0 
-mpa-risc-1-1  -mpa-risc-2-0  -mportable-runtime 
-mschedule=@var{cpu-type}  -mspace-regs  -msio  -mwsio 
-munix=@var{unix-std}  -nolibdld  -static  -threads}

@emph{IA-64 Options}
@gccoptlist{-mbig-endian  -mlittle-endian  -mgnu-as  -mgnu-ld  -mno-pic 
-mvolatile-asm-stop  -mregister-names  -msdata  -mno-sdata 
-mconstant-gp  -mauto-pic  -mfused-madd 
-minline-float-divide-min-latency 
-minline-float-divide-max-throughput 
-mno-inline-float-divide 
-minline-int-divide-min-latency 
-minline-int-divide-max-throughput  
-mno-inline-int-divide 
-minline-sqrt-min-latency  -minline-sqrt-max-throughput 
-mno-inline-sqrt 
-mdwarf2-asm  -mearly-stop-bits 
-mfixed-range=@var{register-range}  -mtls-size=@var{tls-size} 
-mtune=@var{cpu-type}  -milp32  -mlp64 
-msched-br-data-spec  -msched-ar-data-spec  -msched-control-spec 
-msched-br-in-data-spec  -msched-ar-in-data-spec  -msched-in-control-spec 
-msched-spec-ldc  -msched-spec-control-ldc 
-msched-prefer-non-data-spec-insns  -msched-prefer-non-control-spec-insns 
-msched-stop-bits-after-every-cycle  -msched-count-spec-in-critical-path 
-msel-sched-dont-check-control-spec  -msched-fp-mem-deps-zero-cost 
-msched-max-memory-insns-hard-limit  -msched-max-memory-insns=@var{max-insns}}

@emph{LM32 Options}
@gccoptlist{-mbarrel-shift-enabled  -mdivide-enabled  -mmultiply-enabled 
-msign-extend-enabled  -muser-enabled}

@emph{M32R/D Options}
@gccoptlist{-m32r2  -m32rx  -m32r 
-mdebug 
-malign-loops  -mno-align-loops 
-missue-rate=@var{number} 
-mbranch-cost=@var{number} 
-mmodel=@var{code-size-model-type} 
-msdata=@var{sdata-type} 
-mno-flush-func  -mflush-func=@var{name} 
-mno-flush-trap  -mflush-trap=@var{number} 
-G @var{num}}

@emph{M32C Options}
@gccoptlist{-mcpu=@var{cpu}  -msim  -memregs=@var{number}}

@emph{M680x0 Options}
@gccoptlist{-march=@var{arch}  -mcpu=@var{cpu}  -mtune=@var{tune} 
-m68000  -m68020  -m68020-40  -m68020-60  -m68030  -m68040 
-m68060  -mcpu32  -m5200  -m5206e  -m528x  -m5307  -m5407 
-mcfv4e  -mbitfield  -mno-bitfield  -mc68000  -mc68020 
-mnobitfield  -mrtd  -mno-rtd  -mdiv  -mno-div  -mshort 
-mno-short  -mhard-float  -m68881  -msoft-float  -mpcrel 
-malign-int  -mstrict-align  -msep-data  -mno-sep-data 
-mshared-library-id=n  -mid-shared-library  -mno-id-shared-library 
-mxgot  -mno-xgot  -mlong-jump-table-offsets}

@emph{MCore Options}
@gccoptlist{-mhardlit  -mno-hardlit  -mdiv  -mno-div  -mrelax-immediates 
-mno-relax-immediates  -mwide-bitfields  -mno-wide-bitfields 
-m4byte-functions  -mno-4byte-functions  -mcallgraph-data 
-mno-callgraph-data  -mslow-bytes  -mno-slow-bytes  -mno-lsim 
-mlittle-endian  -mbig-endian  -m210  -m340  -mstack-increment}

@emph{MeP Options}
@gccoptlist{-mabsdiff  -mall-opts  -maverage  -mbased=@var{n}  -mbitops 
-mc=@var{n}  -mclip  -mconfig=@var{name}  -mcop  -mcop32  -mcop64  -mivc2 
-mdc  -mdiv  -meb  -mel  -mio-volatile  -ml  -mleadz  -mm  -mminmax 
-mmult  -mno-opts  -mrepeat  -ms  -msatur  -msdram  -msim  -msimnovec  -mtf 
-mtiny=@var{n}}

@emph{MicroBlaze Options}
@gccoptlist{-msoft-float  -mhard-float  -msmall-divides  -mcpu=@var{cpu} 
-mmemcpy  -mxl-soft-mul  -mxl-soft-div  -mxl-barrel-shift 
-mxl-pattern-compare  -mxl-stack-check  -mxl-gp-opt  -mno-clearbss 
-mxl-multiply-high  -mxl-float-convert  -mxl-float-sqrt 
-mbig-endian  -mlittle-endian  -mxl-reorder  -mxl-mode-@var{app-model} 
-mpic-data-is-text-relative}

@emph{MIPS Options}
@gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} 
-mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2  -mips32r3  -mips32r5 
-mips32r6  -mips64  -mips64r2  -mips64r3  -mips64r5  -mips64r6 
-mips16  -mno-mips16  -mflip-mips16 
-minterlink-compressed  -mno-interlink-compressed 
-minterlink-mips16  -mno-interlink-mips16 
-mabi=@var{abi}  -mabicalls  -mno-abicalls 
-mshared  -mno-shared  -mplt  -mno-plt  -mxgot  -mno-xgot 
-mgp32  -mgp64  -mfp32  -mfpxx  -mfp64  -mhard-float  -msoft-float 
-mno-float  -msingle-float  -mdouble-float 
-modd-spreg  -mno-odd-spreg 
-mabs=@var{mode}  -mnan=@var{encoding} 
-mdsp  -mno-dsp  -mdspr2  -mno-dspr2 
-mmcu  -mmno-mcu 
-meva  -mno-eva 
-mvirt  -mno-virt 
-mxpa  -mno-xpa 
-mcrc  -mno-crc 
-mginv  -mno-ginv 
-mmicromips  -mno-micromips 
-mmsa  -mno-msa 
-mloongson-mmi  -mno-loongson-mmi 
-mloongson-ext  -mno-loongson-ext 
-mloongson-ext2  -mno-loongson-ext2 
-mfpu=@var{fpu-type} 
-msmartmips  -mno-smartmips 
-mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx 
-mips3d  -mno-mips3d  -mmt  -mno-mt  -mllsc  -mno-llsc 
-mlong64  -mlong32  -msym32  -mno-sym32 
-G@var{num}  -mlocal-sdata  -mno-local-sdata 
-mextern-sdata  -mno-extern-sdata  -mgpopt  -mno-gopt 
-membedded-data  -mno-embedded-data 
-muninit-const-in-rodata  -mno-uninit-const-in-rodata 
-mcode-readable=@var{setting} 
-msplit-addresses  -mno-split-addresses 
-mexplicit-relocs  -mno-explicit-relocs 
-mcheck-zero-division  -mno-check-zero-division 
-mdivide-traps  -mdivide-breaks 
-mload-store-pairs  -mno-load-store-pairs 
-mmemcpy  -mno-memcpy  -mlong-calls  -mno-long-calls 
-mmad  -mno-mad  -mimadd  -mno-imadd  -mfused-madd  -mno-fused-madd  -nocpp 
-mfix-24k  -mno-fix-24k 
-mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 
-mfix-r5900  -mno-fix-r5900 
-mfix-r10000  -mno-fix-r10000  -mfix-rm7000  -mno-fix-rm7000 
-mfix-vr4120  -mno-fix-vr4120 
-mfix-vr4130  -mno-fix-vr4130  -mfix-sb1  -mno-fix-sb1 
-mflush-func=@var{func}  -mno-flush-func 
-mbranch-cost=@var{num}  -mbranch-likely  -mno-branch-likely 
-mcompact-branches=@var{policy} 
-mfp-exceptions  -mno-fp-exceptions 
-mvr4130-align  -mno-vr4130-align  -msynci  -mno-synci 
-mlxc1-sxc1  -mno-lxc1-sxc1  -mmadd4  -mno-madd4 
-mrelax-pic-calls  -mno-relax-pic-calls  -mmcount-ra-address 
-mframe-header-opt  -mno-frame-header-opt}

@emph{MMIX Options}
@gccoptlist{-mlibfuncs  -mno-libfuncs  -mepsilon  -mno-epsilon  -mabi=gnu 
-mabi=mmixware  -mzero-extend  -mknuthdiv  -mtoplevel-symbols 
-melf  -mbranch-predict  -mno-branch-predict  -mbase-addresses 
-mno-base-addresses  -msingle-exit  -mno-single-exit}

@emph{MN10300 Options}
@gccoptlist{-mmult-bug  -mno-mult-bug 
-mno-am33  -mam33  -mam33-2  -mam34 
-mtune=@var{cpu-type} 
-mreturn-pointer-on-d0 
-mno-crt0  -mrelax  -mliw  -msetlb}

@emph{Moxie Options}
@gccoptlist{-meb  -mel  -mmul.x  -mno-crt0}

@emph{MSP430 Options}
@gccoptlist{-msim  -masm-hex  -mmcu=  -mcpu=  -mlarge  -msmall  -mrelax 
-mwarn-mcu 
-mcode-region=  -mdata-region= 
-msilicon-errata=  -msilicon-errata-warn= 
-mhwmult=  -minrt}

@emph{NDS32 Options}
@gccoptlist{-mbig-endian  -mlittle-endian 
-mreduced-regs  -mfull-regs 
-mcmov  -mno-cmov 
-mext-perf  -mno-ext-perf 
-mext-perf2  -mno-ext-perf2 
-mext-string  -mno-ext-string 
-mv3push  -mno-v3push 
-m16bit  -mno-16bit 
-misr-vector-size=@var{num} 
-mcache-block-size=@var{num} 
-march=@var{arch} 
-mcmodel=@var{code-model} 
-mctor-dtor  -mrelax}

@emph{Nios II Options}
@gccoptlist{-G @var{num}  -mgpopt=@var{option}  -mgpopt  -mno-gpopt 
-mgprel-sec=@var{regexp}  -mr0rel-sec=@var{regexp} 
-mel  -meb 
-mno-bypass-cache  -mbypass-cache 
-mno-cache-volatile  -mcache-volatile 
-mno-fast-sw-div  -mfast-sw-div 
-mhw-mul  -mno-hw-mul  -mhw-mulx  -mno-hw-mulx  -mno-hw-div  -mhw-div 
-mcustom-@var{insn}=@var{N}  -mno-custom-@var{insn} 
-mcustom-fpu-cfg=@var{name} 
-mhal  -msmallc  -msys-crt0=@var{name}  -msys-lib=@var{name} 
-march=@var{arch}  -mbmx  -mno-bmx  -mcdx  -mno-cdx}

@emph{Nvidia PTX Options}
@gccoptlist{-m32  -m64  -mmainkernel  -moptimize}

@emph{OpenRISC Options}
@gccoptlist{-mboard=@var{name}  -mnewlib  -mhard-mul  -mhard-div 
-msoft-mul  -msoft-div 
-mcmov  -mror  -msext  -msfimm  -mshftimm}

@emph{PDP-11 Options}
@gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 
-mint32  -mno-int16  -mint16  -mno-int32 
-msplit  -munix-asm  -mdec-asm  -mgnu-asm  -mlra}

@emph{picoChip Options}
@gccoptlist{-mae=@var{ae_type}  -mvliw-lookahead=@var{N} 
-msymbol-as-address  -mno-inefficient-warnings}

@emph{PowerPC Options}
See RS/6000 and PowerPC Options.

@emph{RISC-V Options}
@gccoptlist{-mbranch-cost=@var{N-instruction} 
-mplt  -mno-plt 
-mabi=@var{ABI-string} 
-mfdiv  -mno-fdiv 
-mdiv  -mno-div 
-march=@var{ISA-string} 
-mtune=@var{processor-string} 
-mpreferred-stack-boundary=@var{num} 
-msmall-data-limit=@var{N-bytes} 
-msave-restore  -mno-save-restore 
-mstrict-align  -mno-strict-align 
-mcmodel=medlow  -mcmodel=medany 
-mexplicit-relocs  -mno-explicit-relocs 
-mrelax  -mno-relax 
-mriscv-attribute  -mmo-riscv-attribute}

@emph{RL78 Options}
@gccoptlist{-msim  -mmul=none  -mmul=g13  -mmul=g14  -mallregs 
-mcpu=g10  -mcpu=g13  -mcpu=g14  -mg10  -mg13  -mg14 
-m64bit-doubles  -m32bit-doubles  -msave-mduc-in-interrupts}

@emph{RS/6000 and PowerPC Options}
@gccoptlist{-mcpu=@var{cpu-type} 
-mtune=@var{cpu-type} 
-mcmodel=@var{code-model} 
-mpowerpc64 
-maltivec  -mno-altivec 
-mpowerpc-gpopt  -mno-powerpc-gpopt 
-mpowerpc-gfxopt  -mno-powerpc-gfxopt 
-mmfcrf  -mno-mfcrf  -mpopcntb  -mno-popcntb  -mpopcntd  -mno-popcntd 
-mfprnd  -mno-fprnd 
-mcmpb  -mno-cmpb  -mmfpgpr  -mno-mfpgpr  -mhard-dfp  -mno-hard-dfp 
-mfull-toc   -mminimal-toc  -mno-fp-in-toc  -mno-sum-in-toc 
-m64  -m32  -mxl-compat  -mno-xl-compat  -mpe 
-malign-power  -malign-natural 
-msoft-float  -mhard-float  -mmultiple  -mno-multiple 
-mupdate  -mno-update 
-mavoid-indexed-addresses  -mno-avoid-indexed-addresses 
-mfused-madd  -mno-fused-madd  -mbit-align  -mno-bit-align 
-mstrict-align  -mno-strict-align  -mrelocatable 
-mno-relocatable  -mrelocatable-lib  -mno-relocatable-lib 
-mtoc  -mno-toc  -mlittle  -mlittle-endian  -mbig  -mbig-endian 
-mdynamic-no-pic  -mswdiv  -msingle-pic-base 
-mprioritize-restricted-insns=@var{priority} 
-msched-costly-dep=@var{dependence_type} 
-minsert-sched-nops=@var{scheme} 
-mcall-aixdesc  -mcall-eabi  -mcall-freebsd  
-mcall-linux  -mcall-netbsd  -mcall-openbsd  
-mcall-sysv  -mcall-sysv-eabi  -mcall-sysv-noeabi 
-mtraceback=@var{traceback_type} 
-maix-struct-return  -msvr4-struct-return 
-mabi=@var{abi-type}  -msecure-plt  -mbss-plt 
-mlongcall  -mno-longcall  -mpltseq  -mno-pltseq  
-mblock-move-inline-limit=@var{num} 
-mblock-compare-inline-limit=@var{num} 
-mblock-compare-inline-loop-limit=@var{num} 
-mstring-compare-inline-limit=@var{num} 
-misel  -mno-isel 
-mvrsave  -mno-vrsave 
-mmulhw  -mno-mulhw 
-mdlmzb  -mno-dlmzb 
-mprototype  -mno-prototype 
-msim  -mmvme  -mads  -myellowknife  -memb  -msdata 
-msdata=@var{opt}  -mreadonly-in-sdata  -mvxworks  -G @var{num} 
-mrecip  -mrecip=@var{opt}  -mno-recip  -mrecip-precision 
-mno-recip-precision 
-mveclibabi=@var{type}  -mfriz  -mno-friz 
-mpointers-to-nested-functions  -mno-pointers-to-nested-functions 
-msave-toc-indirect  -mno-save-toc-indirect 
-mpower8-fusion  -mno-mpower8-fusion  -mpower8-vector  -mno-power8-vector 
-mcrypto  -mno-crypto  -mhtm  -mno-htm 
-mquad-memory  -mno-quad-memory 
-mquad-memory-atomic  -mno-quad-memory-atomic 
-mcompat-align-parm  -mno-compat-align-parm 
-mfloat128  -mno-float128  -mfloat128-hardware  -mno-float128-hardware 
-mgnu-attribute  -mno-gnu-attribute 
-mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{reg} 
-mstack-protector-guard-offset=@var{offset}}

@emph{RX Options}
@gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu
-mcpu=
-mbig-endian-data  -mlittle-endian-data 
-msmall-data 
-msim  -mno-sim
-mas100-syntax  -mno-as100-syntax
-mrelax
-mmax-constant-size=
-mint-register=
-mpid
-mallow-string-insns  -mno-allow-string-insns
-mjsr
-mno-warn-multiple-fast-interrupts
-msave-acc-in-interrupts}

@emph{S/390 and zSeries Options}
@gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} 
-mhard-float  -msoft-float  -mhard-dfp  -mno-hard-dfp 
-mlong-double-64  -mlong-double-128 
-mbackchain  -mno-backchain  -mpacked-stack  -mno-packed-stack 
-msmall-exec  -mno-small-exec  -mmvcle  -mno-mvcle 
-m64  -m31  -mdebug  -mno-debug  -mesa  -mzarch 
-mhtm  -mvx  -mzvector 
-mtpf-trace  -mno-tpf-trace  -mfused-madd  -mno-fused-madd 
-mwarn-framesize  -mwarn-dynamicstack  -mstack-size  -mstack-guard 
-mhotpatch=@var{halfwords},@var{halfwords}}

@emph{Score Options}
@gccoptlist{-meb  -mel 
-mnhwloop 
-muls 
-mmac 
-mscore5  -mscore5u  -mscore7  -mscore7d}

@emph{SH Options}
@gccoptlist{-m1  -m2  -m2e 
-m2a-nofpu  -m2a-single-only  -m2a-single  -m2a 
-m3  -m3e 
-m4-nofpu  -m4-single-only  -m4-single  -m4 
-m4a-nofpu  -m4a-single-only  -m4a-single  -m4a  -m4al 
-mb  -ml  -mdalign  -mrelax 
-mbigtable  -mfmovd  -mrenesas  -mno-renesas  -mnomacsave 
-mieee  -mno-ieee  -mbitops  -misize  -minline-ic_invalidate  -mpadstruct 
-mprefergot  -musermode  -multcost=@var{number}  -mdiv=@var{strategy} 
-mdivsi3_libfunc=@var{name}  -mfixed-range=@var{register-range} 
-maccumulate-outgoing-args 
-matomic-model=@var{atomic-model} 
-mbranch-cost=@var{num}  -mzdcbranch  -mno-zdcbranch 
-mcbranch-force-delay-slot 
-mfused-madd  -mno-fused-madd  -mfsca  -mno-fsca  -mfsrra  -mno-fsrra 
-mpretend-cmove  -mtas}

@emph{Solaris 2 Options}
@gccoptlist{-mclear-hwcap  -mno-clear-hwcap  -mimpure-text  -mno-impure-text 
-pthreads}

@emph{SPARC Options}
@gccoptlist{-mcpu=@var{cpu-type} 
-mtune=@var{cpu-type} 
-mcmodel=@var{code-model} 
-mmemory-model=@var{mem-model} 
-m32  -m64  -mapp-regs  -mno-app-regs 
-mfaster-structs  -mno-faster-structs  -mflat  -mno-flat 
-mfpu  -mno-fpu  -mhard-float  -msoft-float 
-mhard-quad-float  -msoft-quad-float 
-mstack-bias  -mno-stack-bias 
-mstd-struct-return  -mno-std-struct-return 
-munaligned-doubles  -mno-unaligned-doubles 
-muser-mode  -mno-user-mode 
-mv8plus  -mno-v8plus  -mvis  -mno-vis 
-mvis2  -mno-vis2  -mvis3  -mno-vis3 
-mvis4  -mno-vis4  -mvis4b  -mno-vis4b 
-mcbcond  -mno-cbcond  -mfmaf  -mno-fmaf  -mfsmuld  -mno-fsmuld  
-mpopc  -mno-popc  -msubxc  -mno-subxc 
-mfix-at697f  -mfix-ut699  -mfix-ut700  -mfix-gr712rc 
-mlra  -mno-lra}

@emph{SPU Options}
@gccoptlist{-mwarn-reloc  -merror-reloc 
-msafe-dma  -munsafe-dma 
-mbranch-hints 
-msmall-mem  -mlarge-mem  -mstdmain 
-mfixed-range=@var{register-range} 
-mea32  -mea64 
-maddress-space-conversion  -mno-address-space-conversion 
-mcache-size=@var{cache-size} 
-matomic-updates  -mno-atomic-updates}

@emph{System V Options}
@gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}

@emph{TILE-Gx Options}
@gccoptlist{-mcpu=CPU  -m32  -m64  -mbig-endian  -mlittle-endian 
-mcmodel=@var{code-model}}

@emph{TILEPro Options}
@gccoptlist{-mcpu=@var{cpu}  -m32}

@emph{V850 Options}
@gccoptlist{-mlong-calls  -mno-long-calls  -mep  -mno-ep 
-mprolog-function  -mno-prolog-function  -mspace 
-mtda=@var{n}  -msda=@var{n}  -mzda=@var{n} 
-mapp-regs  -mno-app-regs 
-mdisable-callt  -mno-disable-callt 
-mv850e2v3  -mv850e2  -mv850e1  -mv850es 
-mv850e  -mv850  -mv850e3v5 
-mloop 
-mrelax 
-mlong-jumps 
-msoft-float 
-mhard-float 
-mgcc-abi 
-mrh850-abi 
-mbig-switch}

@emph{VAX Options}
@gccoptlist{-mg  -mgnu  -munix}

@emph{Visium Options}
@gccoptlist{-mdebug  -msim  -mfpu  -mno-fpu  -mhard-float  -msoft-float 
-mcpu=@var{cpu-type}  -mtune=@var{cpu-type}  -msv-mode  -muser-mode}

@emph{VMS Options}
@gccoptlist{-mvms-return-codes  -mdebug-main=@var{prefix}  -mmalloc64 
-mpointer-size=@var{size}}

@emph{VxWorks Options}
@gccoptlist{-mrtp  -non-static  -Bstatic  -Bdynamic 
-Xbind-lazy  -Xbind-now}

@emph{x86 Options}
@gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} 
-mtune-ctrl=@var{feature-list}  -mdump-tune-features  -mno-default 
-mfpmath=@var{unit} 
-masm=@var{dialect}  -mno-fancy-math-387 
-mno-fp-ret-in-387  -m80387  -mhard-float  -msoft-float 
-mno-wide-multiply  -mrtd  -malign-double 
-mpreferred-stack-boundary=@var{num} 
-mincoming-stack-boundary=@var{num} 
-mcld  -mcx16  -msahf  -mmovbe  -mcrc32 
-mrecip  -mrecip=@var{opt} 
-mvzeroupper  -mprefer-avx128  -mprefer-vector-width=@var{opt} 
-mmmx  -msse  -msse2  -msse3  -mssse3  -msse4.1  -msse4.2  -msse4  -mavx 
-mavx2  -mavx512f  -mavx512pf  -mavx512er  -mavx512cd  -mavx512vl 
-mavx512bw  -mavx512dq  -mavx512ifma  -mavx512vbmi  -msha  -maes 
-mpclmul  -mfsgsbase  -mrdrnd  -mf16c  -mfma  -mpconfig  -mwbnoinvd  
-mptwrite  -mprefetchwt1  -mclflushopt  -mclwb  -mxsavec  -mxsaves 
-msse4a  -m3dnow  -m3dnowa  -mpopcnt  -mabm  -mbmi  -mtbm  -mfma4  -mxop 
-madx  -mlzcnt  -mbmi2  -mfxsr  -mxsave  -mxsaveopt  -mrtm  -mhle  -mlwp 
-mmwaitx  -mclzero  -mpku  -mthreads  -mgfni  -mvaes  -mwaitpkg 
-mshstk -mmanual-endbr -mforce-indirect-call  -mavx512vbmi2 
-mvpclmulqdq  -mavx512bitalg  -mmovdiri  -mmovdir64b  -mavx512vpopcntdq 
-mavx5124fmaps  -mavx512vnni  -mavx5124vnniw  -mprfchw  -mrdpid 
-mrdseed  -msgx 
-mcldemote  -mms-bitfields  -mno-align-stringops  -minline-all-stringops 
-minline-stringops-dynamically  -mstringop-strategy=@var{alg} 
-mmemcpy-strategy=@var{strategy}  -mmemset-strategy=@var{strategy} 
-mpush-args  -maccumulate-outgoing-args  -m128bit-long-double 
-m96bit-long-double  -mlong-double-64  -mlong-double-80  -mlong-double-128 
-mregparm=@var{num}  -msseregparm 
-mveclibabi=@var{type}  -mvect8-ret-in-mem 
-mpc32  -mpc64  -mpc80  -mstackrealign 
-momit-leaf-frame-pointer  -mno-red-zone  -mno-tls-direct-seg-refs 
-mcmodel=@var{code-model}  -mabi=@var{name}  -maddress-mode=@var{mode} 
-m32  -m64  -mx32  -m16  -miamcu  -mlarge-data-threshold=@var{num} 
-msse2avx  -mfentry  -mrecord-mcount  -mnop-mcount  -m8bit-idiv 
-minstrument-return=@var{type} -mfentry-name=@var{name} -mfentry-section=@var{name} 
-mavx256-split-unaligned-load  -mavx256-split-unaligned-store 
-malign-data=@var{type}  -mstack-protector-guard=@var{guard} 
-mstack-protector-guard-reg=@var{reg} 
-mstack-protector-guard-offset=@var{offset} 
-mstack-protector-guard-symbol=@var{symbol} 
-mgeneral-regs-only  -mcall-ms2sysv-xlogues 
-mindirect-branch=@var{choice}  -mfunction-return=@var{choice} 
-mindirect-branch-register}

@emph{x86 Windows Options}
@gccoptlist{-mconsole  -mcygwin  -mno-cygwin  -mdll 
-mnop-fun-dllimport  -mthread 
-municode  -mwin32  -mwindows  -fno-set-stack-executable}

@emph{Xstormy16 Options}
@gccoptlist{-msim}

@emph{Xtensa Options}
@gccoptlist{-mconst16  -mno-const16 
-mfused-madd  -mno-fused-madd 
-mforce-no-pic 
-mserialize-volatile  -mno-serialize-volatile 
-mtext-section-literals  -mno-text-section-literals 
-mauto-litpools  -mno-auto-litpools 
-mtarget-align  -mno-target-align 
-mlongcalls  -mno-longcalls}

@emph{zSeries Options}
See S/390 and zSeries Options.
@end table


@node Overall Options
@section 出力の種類を制御するオプション

コンパイルは、最高4つの段階を含み得る。プリプロセス、本来のコンパイル、アセンブル、リンクを常にこの順番で。
GCCは複数のファイルをプリプロセス・コンパイルして複数のアセンブラ入力ファイルにすることも、一つのアセンブラ入力ファイル
にすることもできる。それからそれぞれのアセンブラ入力ファイルはオブジェクトファイルを生成し、リンクですべてのオブジェクト
ファイル（新しくコンパイルされ、入力として指定されて）実行可能ファイルへと組み合わせられる。

@cindex file name suffix
入力ファイルに対して、ファイル名の拡張子によってどの種類のコンパイルを行うかを決定する。

@table @gcctabopt
@item @var{file}.c
プリプロセスをするべきのCソースコード

@item @var{file}.i
プリプロセスをするべきでないCソースコード

@item @var{file}.ii
プリプロセスをするべきでないC＋＋ソースコード

@item @var{file}.m
Object-Cソースコード。Object-Cプログラムを動作させるためには、@file{libobjc}とリンクしなければならない
ことに注意する。

@item @var{file}.mi
プリプロセスをするべきでないObjective-Cソースコード

@item @var{file}.mm
@itemx @var{file}.M
Object-C＋＋ソースコード。Object-C＋＋プログラムを動作させるためには、@file{libobjc}とリンクしなければならない
ことに注意する。@samp{.M}は文字通り大文字のMを参照する。

@item @var{file}.mii
プリプロセスをするべきでないObjective-C＋＋ソースコード

@item @var{file}.h
プリプロセス済みヘッダへと変換すべきC, C++, Objective-C, Objective-C++ヘッダファイル（デフォルト）および、
Ada specへと(@option{-fdump-ada-spec}スイッチ経由で)変換すべきC, C++ヘッダファイル

@item @var{file}.cc
@itemx @var{file}.cp
@itemx @var{file}.cxx
@itemx @var{file}.cpp
@itemx @var{file}.CPP
@itemx @var{file}.c++
@itemx @var{file}.C
プリプロセスをしなけれあばならないC++のソースコード。@samp{.cxx}の最後の2文字は文字通りの@samp{x}であることに注意する。
同様に、@samp{.C}は文字通りの大文字Cである。

@item @var{file}.mm
@itemx @var{file}.M
プリプロセスをしなければならないObject-C++ソースコード。

@item @var{file}.mii
プリプロセスをするべきではないObject-C++ソースコード。

@item @var{file}.hh
@itemx @var{file}.H
@itemx @var{file}.hp
@itemx @var{file}.hxx
@itemx @var{file}.hpp
@itemx @var{file}.HPP
@itemx @var{file}.h++
@itemx @var{file}.tcc
プリプロセス済みヘッダおよびAda specに変換されるC++ヘッダ

@item @var{file}.f
@itemx @var{file}.for
@itemx @var{file}.ftn
プリプロセスをすべきではないFortran固定形式のソースコード

@item @var{file}.F
@itemx @var{file}.FOR
@itemx @var{file}.fpp
@itemx @var{file}.FPP
@itemx @var{file}.FTN
（伝統的なプリプリプロセッサで）プリプロセスをしなければならないFortranソースコード

@item @var{file}.f90
@itemx @var{file}.f95
@itemx @var{file}.f03
@itemx @var{file}.f08
プリプロセスをすべきではない自由形式Fortranソースコード

@item @var{file}.F90
@itemx @var{file}.F95
@itemx @var{file}.F03
@itemx @var{file}.F08
（伝統的なプリプリプロセッサで）プリプロセスをしなければならない自由形式Fortranソースコード

@item @var{file}.go
Goソースコード

@item @var{file}.brig
BRIGファイル(HSAILのバイナリ表現)

@item @var{file}.d
Dのソースコード。

@item @var{file}.di
Dのインターフェースファイル。

@item @var{file}.dd
Dのドキュメントコード（Ddoc）。

@item @var{file}.ads
ライブラリユニット宣言（パッケージ宣言、サブプログラム、汎用、汎用特定化）を含むAdaソースコード、
ライブラリ単位リネーム宣言（パッケージ、汎用、サブプログラムリネーム宣言）。そのようなファイルは
@dfn{specs}と呼ばれる。

@item @var{file}.adb
ライブラリユニット本体（サブプログラムおよびパッケージ本体）を含むAdaソースコードファイル、そのようなファイルは
@dfn{ボディ}と呼ばれる。

@c GCCはまだ含まれていない元の拡張子を知っている。
@c Ratfor:
@c @var{file}.r

@item @var{file}.s
アセンブラコード

@item @var{file}.S
@itemx @var{file}.sx
プリプロセスをしなければならないアセンブラコード

@item @var{other}
リンクへと直接食わせるオブジェクトファイル。認識しない拡張子を持つファイルは
この方法で扱われる。
@end table

@opindex x
入力言語を@option{-x}オプションで明示的に指定することができる。

@table @gcctabopt
@item -x @var{language}
入力ファイルが従う@var{language}(言語)を（コンパイラに拡張子に基づいて選択させるのではなく）
明示的に指定する。このオプションは次の@option{-x}オプションまでのすべてのファイルに適用される。可能な@var{langage}の値は
@smallexample
c  c-header  cpp-output
c++  c++-header  c++-cpp-output
objective-c  objective-c-header  objective-c-cpp-output
objective-c++ objective-c++-header objective-c++-cpp-output
assembler  assembler-with-cpp
ada
d
f77  f77-cpp-input f95  f95-cpp-input
go
brig
@end smallexample

@item -x none
言語の指定を切って、残りのファイルが拡張子に基づいて（@option{-x}が全く使われていないように）
扱うようにする。
@end table

もしコンパイルのある段階のみを望むなら、@option{-x}を@command{gcc}がどこから始めるかを教え、
@option{-c}, @option{-S}, @option{-E}を@command{gcc}がどこで終わるかを教えるために使うことができる。
ある組み合わせ（例えば、@samp{-x cpp-output -E}は@command{gcc}に何もしないように指示することに注意。

@table @gcctabopt
@item -c
@opindex c
ソースのコンパイル・アセンブルはするがリンクしない。リンクの段階は単に行われない。
最終的な出力はそれぞれのファイルのオブジェクトファイルの形式である。

デフォルトでは、ソースファイルのオブジェクトファイル名は拡張子@samp{.c}, @samp{.i}, @samp{.s}などを
@samp{.o}で置換したものである。

認識できないファイル、コンパイル・アセンブルが不要なファイルは無視される。

@item -S
@opindex S
コンパイル自身の段階で止める。アセンブルしない。出力は指定した非アセンブラ入力ファイルのアセンブラコード
形式である。

デフォルトでは、ソースファイルのオブジェクトファイル名は拡張子@samp{.c}, @samp{.i}などを@samp{.s}で置換したものである。

コンパイルが必要ないファイルは無視される。

@item -E
@opindex E
プリプロセスの段階の後で停止する。コンパイラ自身は動かない。出力はプリプロセスされたソースコードの形式で、標準出力へ送られる。

プリプロセスを必要としないファイルは無視される。

@cindex output file option
@item -o @var{file}
@opindex o
ファイル@var{file}に出力させる。これは
Place output in file @var{file}.  これは実行ファイル、オブジェクトファイル、アセンブラファイル、プリプロセス済みのCのコード
であるかにかかわらず、すべての種類の出力で適用される。.

もし@option{-o}が指定されていないならば、デフォルトは実行ファイルが@file{a.out}であり、@file{@var{source}.@var{suffix}}の
オブジェクトファイルが@file{@var{source}.o}であり、そのアセンブラが@file{@var{source}.s}であり、プリプロセスされた
ヘッダファイルが@file{@var{source}.@var{suffix}.gch}であり、すべてのプリプロセスされたCソースが標準出力である。

@item -v
@opindex v
（標準エラー出力に）コンパイルの段階を走らせるために実行されるコマンドをプリントする。コンパイラ・ドライバ・プログラムの、そして、プリプロセッサと本来のコンパイラのバージョン番号もプリントする。

@item -###
@opindex ###
@option{-v}と同様だが、コマンドは実行されず、引数は単なるアルファベット文字と@code{./-_}のみを含んでいるのでない限りクォートされる。これはドライバが生成したコマンド行を取り込むシェルスクリプトで有用である。

@item --help
@opindex help
（標準出力に）@command{gcc}が理解するコマンド列オプションの説明を出力する。もし@option{-v}も指定された時は、
@option{--help}は@command{gcc}が呼び出す様々なプロセスにも@option{--help}が渡されて、それらが受け付けるコマンド行オプション
も表示できるようにする。もし@option{-Wextra}オプションが（@option{--help}の前に）指定された時は、対応する文書のないコマンド行オプションも表示する。

@item --target-help
@opindex target-help
（標準出力に）それぞれのツールでターゲット固有のコマンド行オプションの説明を表示する。あるターゲットでは、ターゲット固有の追加の情報もプリントする。

@item --help=@{@var{class}@r{|[}^@r{]}@var{qualifier}@}@r{[},@dots{}@r{]}
（標準出力に）コンパイラが理解し、すべての指定されたクラスと指定子に当てはまるコマンド行オプションを出力する。サポートするクラスがは、

@table @asis
@item @samp{optimizers}
コンパイラがサポートするすべての最適化オプションを表示する。

@item @samp{warnings}
コンパイラによって生成される警告メッセージを制御するすべてのオプションを表示する

@item @samp{target}
ターゲット固有のオプションを表示する。しかし、@option{--target-help}と異なり、リンカとアセンブラのターゲット固有のオプションは表示しない。これはそれらのツールが拡張@option{-help=}構文を現在サポートしていないからである。

@item @samp{params}
@option{-param}によって認識される値を表示する。

@item @var{language}
@var{language}がサポートするオプションを表示する。@var{language}はこのバージョンのGCCがサポートする言語名の１つである。

@item @samp{common}
全言語で共通のオプションを表示する
@end table

サポートされた指定子は

@table @asis
@item @samp{undocumented}
文書化されていないオプションのみを表示する。

@item @samp{joined}
等号の後ろにテキストが続く@samp{--help=target}のような引数を表示する。

@item @samp{separate}
@samp{-o output-file}のような、元のオプションの後ろで分離した後で現れる引数を取るオプションを表示する。
@end table

したがって、コンパイラがサポートする文書化されていないターゲット固有のスイッチをすべて表示する例では、これを使う。

@smallexample
--help=target,undocumented
@end smallexample

指定子の意味は@samp{^}文字を前に置くことで反転することができ、例えば、説明のあるすべてのON/OFFの警告オプションを表示したいときはこれを使う。

@smallexample
--help=warnings,^joined,^undocumented
@end smallexample

@option{--help=}の引数は否定された指定子のみにするべきではない。

いくつかのクラスを組み合わせることは可能だが、これは通常は出力が何も表示されないように制限する。
しかし、機能するケースとして、クラスの一つが@var{targe}である場合である。
例えば、すべてのターゲット固有の最適化オプションを表示したい、これを使う。

@smallexample
--help=target,optimizers
@end smallexample

オプション@option{--help=}はコマンド行で繰り返すことができる。それぞれの連続した使用はオプションの繰り返された
列を出力し、すでに表示したものを飛ばす。

もし@option{-Q}が@option{--help=}オプションの前にコマンド行で現れるなら、@option{--help=}で表示される説明テキストが変わる。
表示されたオプションを描写する代わりに、オプションが有効・無効・特定の値がセットされているかどうかをの表示が与えられる。
（コンパイラが@option{--help=}オプションが使われた場所を知っていると仮定して）

ここにARMポートの@command{gcc}の短縮された例がある。

@smallexample
  % gcc -Q -mabi=2 --help=target -c
  The following options are target specific:
  -mabi=                                2
  -mabort-on-noreturn                   [disabled]
  -mapcs                                [disabled]
@end smallexample

出力は前のコマンドラインオプションの効果に依存するので、例えば、以下を使うことで@option{-O2}でどの最適化が有効になるかを
調べることが可能になる。

@smallexample
-Q -O2 --help=optimizers
@end smallexample

代わりに、以下を使うことで@option{-O3}で有効になるON/OFFの最適化を見つけることができる。

@smallexample
gcc -c -Q -O3 --help=optimizers > /tmp/O3-opts
gcc -c -Q -O2 --help=optimizers > /tmp/O2-opts
diff /tmp/O2-opts /tmp/O3-opts | grep enabled
@end smallexample

@item --version
@opindex version
呼びだされたGCCのバージョン番号と著作権を表示する。

@item -pass-exit-codes
@opindex pass-exit-codes
通常@command{gcc}プログラムはコンパイラのどの段階で非成功の返りコードを返しても
コード1で終了する。もし@option{-pass-exit-codes}を指定すると@command{gcc} プログラムは
代わりにエラー指示を返す段階で生じた数値的に最も高いエラーを返す。内部コンパイラ・エラーが
発生した場合は、C、C++とFortranフロントエンドは4を返す。

@item -pipe
@opindex pipe
種々のコンパイルの段階の間の通信に一時ファイルではなくパイプを用いる。これはアセンブラがパイプ
からの読み出しができないシステムでは失敗する。しかしGNUアセンブラでは問題がない。

@item -specs=@var{file}
@opindex specs
コンパイラは、標準的な@file{specs}ファイルを読み込むあと、@command{cc1}、@command{cc1plus}、@command{as}、@command{ld}、その他にどのスイッチを渡すか決定するときに、@command{gcc}ドライバ・プログラムが使うデフォルトを上書きするために@var{file}を処理する。コマンド行に1つより多くの@option{-specs=@var{file}}を使うことができ、それはその順で、左から右に処理される。
@var{file}の書式についての情報は@xref{Spec Files}。

@item -wrapper
@opindex wrapper
ラッパプログラムの下ですべてのサブプログラムを起動する。ラッパプログラムの名前と引数はコンマ区切りのリストで渡される。

@smallexample
gcc -c t.c -wrapper gdb,--args
@end smallexample

@noindent
これは@command{gcc}のすべてのサブプログラムを@samp{gdb --args}で実行し、
@command{cc1}の呼び出しは@samp{gdb --args cc1 @dots{}}である。

@item -ffile-prefix-map=@var{old}=@var{new}
@opindex ffile-prefix-map
When compiling files residing in directory @file{@var{old}}, record
any references to them in the result of the compilation as if the
files resided in directory @file{@var{new}} instead.  Specifying this
option is equivalent to specifying all the individual
@option{-f*-prefix-map} options.  This can be used to make reproducible
builds that are location independent.  See also
@option{-fmacro-prefix-map} and @option{-fdebug-prefix-map}.

@item -fplugin=@var{name}.so
@opindex fplugin
それがコンパイラによってdlopenされる共有オブジェクトであると仮定して、ファイル@var{name}.so
のプラグインコードをロードする。共有オブジェクトファイルの基底名は
引数解析の目的でプラグインを識別するために使われる。（下の
@option{-fplugin-arg-@var{name}-@var{key}=@var{value}}を見よ）
それぞれのプラグインはPlugins APIで指定されたコールバック関数を定義すべきである。

@item -fplugin-arg-@var{name}-@var{key}=@var{value}
@opindex fplugin-arg
プラグイン@var{name}の引数@var{key}を@var{value}で定義する。

@item -fdump-ada-spec@r{[}-slim@r{]}
@opindex fdump-ada-spec
CとC++のソースとインクルードファイルで、対応するAda specsを生成する。
For C and C++ source and include files, generate corresponding Ada specs.
@xref{Generating Ada Bindings for C and C++ headers,,, gnat_ugn,
GNAT ユーザガイド}で、この機能の詳細の文書が提供される。

@item -fada-spec-parent=@var{unit}
@opindex fada-spec-parent
上の@option{-fdump-ada-spec@r{[}-slim@r{]}}と合わせて、Ada specsを親の
@var{unit}の子単位で生成する。

@item -fdump-go-spec=@var{file}
@opindex fdump-go-spec
どんな言語の入力ファイルについてに対しても、@var{file}で対応するGo宣言を生成する。
これは、Go @code{const}、@code{type}、@code{var}とある他の言語で書かれるコードに
Goインターフェースを書き始める役に立つ方法であるかもしれない@code{func}宣言を生成する。

@include ../libiberty/at-file.texi
@end table

@node Invoking G++
@section C++プログラムのコンパイル

@cindex suffixes for C++ source
@cindex C++ source file suffixes
C++ソースファイルは通常@samp{.C}、@samp{.cc}、@samp{.cpp}、@samp{.CPP}、@samp{.c++}、
@samp{.cp}、@samp{.cxx}拡張子の一つを使う。C++ヘッダファイルは、@samp{.hh}、@samp{.hpp}、
@samp{.H}または（共有テンプレート・コードについては）@samp{.tcc}をしばしば使う。そして、プリプロセスされたC++ファイルは、接尾辞@samp{.ii}を使う。Cプログラム（通常名前@command{gcc}で）をコンパイルするためにあってたとえあなたが同じ方法でコンパイラを呼ぶとしても、GCCはこれらの名前でファイルを認識して、C++プログラムとしてそれらをコンパイルする。

@findex g++
@findex c++
しかし、@command{gcc}を使った場合はC++ライブラリを加えない。@command{g++}はGCCを呼んで自動的にC++ライブラリに
対してリンクする。それは@samp{.c}、@samp{.h}、@samp{.i}ファイルを@option{-x}を使わないかぎりはCソースではなく
C++ソースとして扱う。このプログラムは@samp{.h}拡張子のCヘッダファイルをC++で使うためにプリコンパイルするときに役立つ。
多くのシステムで、@command{g++}は@command{c++}でもインストールされる。

@cindex invoking @command{g++}
C++プログラムをコンパイルするとき、どんな言語をコンパイルするときのコマンドラインオプションと同じもの指定して良い。
C関連でのみ意味を持つコマンドラインオプション、C++プログラムでのみ意味を持つオプションもある。
@xref{C Dialect Options,,C変種を制御するオプション}はC関連言語のオプションの説明である。
@xref{C++ Dialect Options,,C++変種を制御するオプション}はC++プログラムでのみ意味を持つオプションの説明である。

@node C Dialect Options
@section C変種を制御するオプション
@cindex dialect options
@cindex language dialect options
@cindex options, dialect

以下のオプションはコンパイラが受理するC（もしくはC派生のC++、Objective-C、Objective-C++)の変種を制御するオプションである。

@table @gcctabopt
@cindex ANSI support
@cindex ISO support
@item -ansi
@opindex ansi
Cモードでは@option{-std=c90}と等価である。C++のモードでは@option{-std=c++98}と等価である。

これは@code{asm}や@code{typeof}キーワード、使っているシステムを識別する@code{unix}や@code{vax}
のような定義済みマクロのような、ISO C90(Cコードをコンパイルするとき)、標準C++(C++コードをコンパイルするとき)と
非互換のあるGCCの機能を消す。それは望まれず、めったに使われないトライグラフを有効にする。Cコンパイラでは
C++スタイルの@samp{//}コメントや@code{inline}キーワードも無効にする。

代替キーワード@code{__asm__}, @code{__extension__}, @code{__inline__}, @code{__typeof__}は@option{-ansi}
があっても機能する。もちろんISO Cプログラムで使いたくはないだろうが、@option{-ansi}でのコンパイル
に含まれるかもしれないヘッダファイルでは役に立つ。@code{__unix__}や@code{__vax__}のような代替定義済みマクロも、
@option{-ansi}の有無にかかわらず有効である。

@option{-ansi}オプションは、非ISOプログラムがむやみに拒絶される原因にならない。
それのために、@option{-Wpedantic}は@option{-ansi}に加えて必要とされる。
  @xref{Warning Options}.

@option{-ansi}オプションが使われるとき、マクロ@code{__STRICT_ANSI__}はあらかじめ定義されている。
あるヘッダファイルはこのマクロに注意するかもしれなくて、特定の機能を宣言するか、
ISO標準が必要としない特定のマクロを定めることを控えるかもしれない;これは、他のもののこれらの名前を
使用するかもしれないどんなプログラムにでも干渉することを避けることになっている。

通常組み込まれるが、意味論をISO Cによって定義されていない関数（例えば@code{alloca}と@code{ffs}）は
@option{-ansi}が使われるとき、組み込み関数でない。影響される関数の詳細は
@xref{Other Builtins,,GCCによって提供されている他の組み込み関数}。

@item -std=
@opindex std
言語標準を指定する。それらの言語標準の詳細は@xref{Standards,,GCCによってサポートされた言語標準}。このオプションは現在CかC++をコンパイルするときだけサポートしている。

コンパイラは、（例えば@samp{c90}または@samp{c++98}のような）いくつかのベース標準と、
（@samp{gnu90}や@samp{gnu++98}のような）それらの標準のGNU変種を受け入れることができる。
ベース標準が指定されるとき、コンパイラはその標準に追従しているすべてのプログラム＋
それと矛盾しないGNU拡張を使っているプログラムを受け入れる。
たとえば、@option{-std=c90}はISO C90と相容れないGCCの特定の機能（例えば@code{asm}と@code{typeof}キーワード）を
オフにするが、ISO C90で、意味をそんなに持たない（@code{?: }表現の中名辞を省略することのような）他のGNU拡張は
受け入れる。他方、標準のGNU変種が指定されるとき、それらの機能がベース標準の意味を変えるときでも、コンパイラによってサポートされるすべての機能は使用可能にされる。その結果、ある厳しく従っているプログラムは拒絶されるかもしれない。どの機能が標準のそのバージョンを与えられるGNU拡張であるかについて確認するために、特定の標準は、@option{-Wpedantic}により用いられる。たとえば、@option{-std=gnu90 -Wpedantic}はC++スタイルの@samp{//}コメントについて警告するが、@option{-std=gnu99 -Wpedantic}はそうしない。

このオプションの値は提供されなければならない。可能な値は以下のとおりである。

@table @samp
@item c90
@itemx c89
@itemx iso9899:1990
ISO C90プログラムすべてをサポートする。（ISO C90と衝突するいくつかのGNU拡張は無効にされる。Cコードでは
@option{-ansi}と同じである。

@item iso9899:199409
改正案1で修正されたISO C90

@item c99
@itemx c9x
@itemx iso9899:1999
@itemx iso9899:199x
ISO C99。剰余のバグと浮動小数点問題（主に附属書FとGからのオプションのC99機能に関するでない以外）を除いて、
この標準は、かなり完全にサポートされる。詳しい情報は@w{@uref{http://gcc.gnu.org/c99status.html}}を見よ。
名前@samp{c9x}と@samp{iso9899:199x}は非推奨である。

@item c11
@itemx c1x
@itemx iso9899:2011
ISO C11、ISO C標準の2011版である。この標準は、剰余のバグ、浮動小数点数の問題（
附属書FとGからのオプションのC11の機能と、主に、しかし完全にではなく関連している）、
オプションの附属書K（境界チェックインターフェース）、L（解析可能性）。名前@samp{c1x}は非推奨
である。

@item c17
@itemx c18
@itemx iso9899:2017
@itemx iso9899:2018
ISO C17、ISO C標準の2017年改訂版（2018年に公開）。 この標準は、欠陥の修正（すべて@option{-std=c11}で適用される）と@code{__STDC_VERSION__}の新しい値を除いてC11と同じであり、C11と同じ範囲でサポートされます。

@item c2x
ISO C標準の次のバージョン、まだ開発中です。 このバージョンのサポートは実験的で不完全です。

@item gnu90
@itemx gnu89
ISO C90のGNU変種（C99の機能をいくつか含む）

@item gnu99
@itemx gnu9x
ISO C99のGNU変種。名前@samp{gnu9x}は非推奨である。

@item gnu11
@itemx gnu1x
ISO C11のGNU変種。名前@samp{gnu1x}は非推奨である。

@item gnu17
@itemx gnu18
ISO C17のGNU変種。これはCコードのデフォルトである。

@item gnu2x
まだ開発中のISO C標準の次のバージョン、およびGNU拡張機能。 このバージョンのサポートは実験的で不完全です。

@item c++98
@itemx c++03
1998年のISO C++標準＋2003の技術的なエラッタと追加の不具合報告。C++コードでの@option{-ansi}と同じ。

@item gnu++98
@itemx gnu++03
@option{-std=c++98}のGNU変種。

@item c++11
@itemx c++0x
2011 ISO C++標準＋改定。名前@samp{c++0x}は非推奨である。

@item gnu++11
@itemx gnu++0x
@option{-std=c++11}のGNU変種。名前@samp{gnu++0x}は非推奨である。

@item c++14
@itemx c++1y
2014 ISO C++標準＋改定。名前@samp{c++1y}は非推奨である。

@item gnu++14
@itemx gnu++1y
@option{-std=c++14}のGNU変種。これはC++コードのデフォルトである。名前@samp{gnu++1y}は非推奨である。

@item c++17
@item c++1z
2017 ISO C++標準＋改定。名前@samp{c++1z}は非推奨である。

@item gnu++17
@item gnu++1z
@option{-std=c++17}のGNU変種。名前@samp{gnu++1z}は非推奨である。

@item c++2a
ISO C++標準の次の改定であり、とりあえず、2020年の間で計画される。サポートは非常に実験的で、ほぼ間違いなく将来のリリースにおいて非互換の方向で変わる。

@item gnu++2a
@option{-std=c++2a}のGNU変種。サポートは非常に実験的で、ほぼ間違いなく将来のリリースにおいて非互換の方向で変わる。

@end table

@item -fgnu89-inline
@opindex fgnu89-inline
オプション@option{-fgnu89-inline}はGCCにC99モードで@code{inline}関数を使った時に伝統的なGNUの意味を使うように
伝える。@xref{Inline,,マクロと同速のインライン関数}.このオプションを使用することは、@code{gnu_inline}関数属性をすべてのインライン関数に加えることにざっと等しい。(@pxref{Function Attributes}).

オプション@option{-fno-gnu89-inline}は明示的にGCCにC99やgnu99モードでC99の意味を使えるように伝える。（すなわち、デフォルトの振る舞いを指定する。）このオプションは@option{-std=c90}や@option{-std=gnu90}モードではサポートしていない。

プリプロセスマクロ@code{__GNUC_GNU_INLINE__}と@code{__GNUC_STDC_INLINE__}を@code{inline}関数がどちらの意味であるかをチェックするのに使って良い。 @xref{Common Predefined
Macros,,,cpp,The C Preprocessor}.

@item -fpermitted-flt-eval-methods=@var{style}
@opindex fpermitted-flt-eval-methods
@opindex fpermitted-flt-eval-methods=c11
@opindex fpermitted-flt-eval-methods=ts-18661-3
ISO/IEC TS 18661-3は、交換または拡張フォーマットであるセマンティックタイプを持つ操作と定数を、
その型の精度と範囲で評価すべきかを示す@code{FLT_EVAL_METHOD}の新しい許容値を定義する。
これらの新しい値は、C99 / C11で許可されているもののスーパーセットであり、
@code{FLT_EVAL_METHOD}の他の正の値の意味を指定しない。したがって、C11に準拠するコードは、
新しい値の可能性を期待して書かれていない可能性がある。

@option{-fpermitted-flt-eval-methods}は、コンパイラがC99 / C11で指定された@code{FLT_EVAL_METHOD}の値のみを許可するか、
SO / IEC TS 18661-3で指定された拡張された値のセットを許可するかを指定する。

@var{style}は必要に応じて@code{c11}か@code{ts-18661-3}である。

規格に準拠したモード（@option{-std = c11}など）のデフォルトは、@option{-fpermitted-flt-eval-methods = c11}である。
GNU変種（@option{-std = gnu11}など）のデフォルトは@option{-fpermitted-flt-eval-methods = ts-18661-3}である。

@item -aux-info @var{filename}
@opindex aux-info
与えられたファイル名にヘッダファイルを含めて、翻訳単位で宣言・定義されたすべての関数のプロトタイプ化した宣言を
出力する。このオプションはC以外の言語では黙って無視される。

宣言に加え、ファイルはコメント内に、それぞれの宣言の起源（ソースファイルと行）、
宣言が暗黙か、プロトタイプ化されているかしないか（それぞれ@samp{I}, 新しい時は@samp{N}, 古い時は@samp{I}で
行番号とコロンの後ろの最初の文字で）、宣言と定義のどちらから来たか（それぞれ続く文字で@samp{C}か@samp{F}で）
を指定する。。関数定義のの場合は、コメント内に、宣言の後ろで、K&R式の引数リストが宣言に続いて提供される。

@item -fallow-parameterless-variadic-functions
@opindex fallow-parameterless-variadic-functions
名前無しパラメータなしでの可変長関数を受理する。

そのような関数を定義することは可能だが、引数を読むことが不可能なのであまり役に立たない。
これはこの構造がC++では許可されているのでCでのみサポートしている。

@item -fno-asm
@opindex fno-asm
@code{asm}, @code{inline}, @code{typeof}をキーワードとして認識せず、識別子としてこの語を使えるようにする。
キーワード@code{__asm__}, @code{__inline__}, @code{__typeof__}は代わりに使うことができる。@option{-ansi}は
@option{-fno-asm}を含む。

C++では@code{asm}と@code{inline}は標準キーワードなので@code{typeof}キーワードのみに影響する。代わりに、
同じ効果を持つ@option{-fno-gnu-keywords}フラグを使いたいかもしれない。C99モード(@option{-std=c99}, 
@option{-std=gnu99})では、このスイッチは@code{inline}がC99で標準キーワードなので、@code{asm}と
@code{typeof}キーワードにのみ影響する。

@item -fno-builtin
@itemx -fno-builtin-@var{function}
@opindex fno-builtin
@cindex built-in functions
@samp{__builtin_}接頭辞で始まらない組み込み関数を認識しない。
ISOの標準の意味が無いために厳密なISO C準拠のための@option{-ansi}や@option{-std}オプション
では組み込み関数にならないものを含め、影響される関数は@xref{Other Builtins,,GCCによって提供される他の組み込み関数}

GCCは通常ある組み込み関数をもっと効率よく扱うために特別なコードを生成する。例えば、@code{alloca}は
スタックを直接調整する単一命令になるかもしれず、@code{memcpy}の呼び出しはインラインのコピーループ
になるかもしれない。結果のコードはしばしばより小さく、より速くなるが、関数呼び出し自体がもはや
現れないため、それらの呼び出しにブレークポイントをセットすることはできず。異なるライブラリをリンクして
挙動を変える事もできない。それに加え、関数が組み込み関数として認識されると、たとえ結果のコードがまだ
関数への呼び出しを含んでいても、GCCはそのような関数への呼び出しについての問題に警告したり、
もっと効率のよいコードを生成するために、その関数の情報を使うかもしれない。例えば、@code{printf}が組み込みならば
@option{-Wformat}での悪い呼び出しに警告を与え、@code{strlen}はグローバルメモリを修正しないことを知っている。

@option{-fno-builtin-@var{function}}オプションは組み込み関数@var{function}のみを無効にする。
@var{function}は@samp{__builtin_}で始まってはならない。もしこのバージョンのGCCで組み込みでない関数の名前の
場合は、このオプションは無視される。対応する@option{-fbuiltin-@var{function}}オプションはない。もし、
@option{-fno-builtin}か@option{-ffreestanding}を使っていて選択的に組み込み関数を有効にしたいならば、以下の様な
マクロを定義して良い。

@smallexample
#define abs(n)          __builtin_abs ((n))
#define strcpy(d, s)    __builtin_strcpy ((d), (s))
@end smallexample

@item -fgimple
@opindex fgimple

@code{__GIMPLE}とマークされた関数定義の解析を有効にする。これは実験的な機能であり、
GIMPLEパスの単体試験を可能にする。

@item -fhosted
@opindex fhosted
@cindex hosted environment

コンパイルターゲットをホスト環境と宣言する。これは@option{-fbuiltin}を含む。
ホスト環境は全標準ライブラリが利用可能で、@code{main}が@code{int}の戻り値型であるものである。
例はカーネル以外のほとんどすべてである。これは@option{-fno-freestanding}と等価である。

@item -ffreestanding
@opindex ffreestanding
@cindex hosted environment

コンパイルターゲットと自立環境と宣言する。これは@option{-fno-builtin}を含む。自立環境は
標準ライブラリが存在しないかもしれず、プログラムの開始が@code{main}とは限らないものである。
最も明白な例はOSのカーネルである。これは@option{-fno-hosted}と等価である。

自立環境とホスト環境の詳細は@xref{Standards,,GCCによってサポートされた言語標準}

@item -fopenacc
@opindex fopenacc
@cindex OpenACC accelerator programming
C/C++での@code{#pragma acc}とFortranでの@code{!$acc}OpenACCディレクティブを有効にする。
@option{-fopenacc}が指定された時は、コンパイラはOpenACCアプリケーション・プログラミングインターフェースv2.0
@w{@uref{https://www.openacc.org/}}に基づいた加速されたコードを生成する。このオプションは
@option{-pthread}を含み、したがって@option{-pthread}をサポートするターゲットでのみサポートされている。

@item -fopenacc-dim=@var{geom}
@opindex fopenacc-dim
@cindex OpenACC accelerator programming
明示的に指定されていない並列オフロード領域のデフォルト計算次元を指定する。@var{geom}の値は
':'で区切られた3つのサイズで、順番に'gang', 'worker', 'vector'である。サイズは省略でき、
ターゲット固有のデフォルト値が使われる。

@item -fopenmp
@opindex fopenmp
@cindex OpenMP parallel
C/C++での@code{#pragma omp}、Fortranでの@code{!$omp}OpenMPディレクティブを有効にする。
@option{-openmp}が指定された時は、コンパイラはOpenMPアプリケーションプログラムインターフェース
v4.5@w{@uref{http://www.openmp.org/}}による並列コードを生成する。このオプションは@option{-pthread}を含み、
したがって@option{-pthread}をサポートするターゲットでのみサポートされている。
@option{-fopenmp}は@option{-fopenmp-simd}を含む。

@item -fopenmp-simd
@opindex fopenmp-simd
@cindex OpenMP SIMD
@cindex SIMD
C/C++での@code{#pragma omp}とFortranでの@code{!$imp}でのOpenMPのSIMPディレクティブを有効にする。
他のOpenMPディレクティブは無視される。

@item -fgnu-tm
@opindex fgnu-tm
オプション@option{-fgnu-tm}が指定されると、コンパイラはIntelの現在のトランザクションメモリABI仕様書文書
(2009年5月6日、リビジョン1.1)のLinux変種のコードを生成する。これは公式の仕様書が変更されると、
GCCの将来のバージョンでインターフェースが変更されるかもしれない実験的な機能である。この機能は
すべてのアーキテクチャでサポートされているわけではないことに気をつけてください。

トランザクションメモリーのGCCのサポートの情報は
@xref{Enabling libitm,,The GNU Transactional Memory Library,libitm,GNU
Transactional Memory Library}.

トランザクションメモリーの機能は非呼び出し例外(@option{-fnon-call-exceptions}ありではサポートされない
ことに注意。

@item -fms-extensions
@opindex fms-extensions
Microsoftヘッダファイルで使われる非標準のいくつかを受理する。

C+＋コードでは、これは構造体のメンバ名が前の型宣言と同じであることを許す。

@smallexample
typedef int UOW;
struct ABC @{
  UOW UOW;
@};
@end smallexample

構造体と共用体での無名フィールドのある場合では、このオプションでのみ受理される。詳細は
 @xref{Unnamed Fields,,構造体・共用体内部の無名構造体・共用体フィールド}

このオプションはms-abiを使うx86ターゲット以外ではオフであることに注意。

@item -fplan9-extensions
@opindex fplan9-extensions
Plan9コードで使われる非標準の構造のいくつかを受理する。

これは@option{-fms-extensions}を有効にし、匿名フィールドを持つ構造体へのポインタをフィールドの型
の要素へのポインタを期待する関数を渡すことを許し、typedefを使って宣言された匿名フィールドへ参照することを
許可する。詳細は @xref{Unnamed Fields,,構造体・共用体内部の無名構造体・共用体フィールド}。これはCでのみサポートされ、C++ではサポートされない。

@item -fcond-mismatch
@opindex fcond-mismatch
条件式の第2引数と第3引数での型の不一致を許す。そのような式の値はvoidである。このオプションは
C++ではサポートされない。

@item -flax-vector-conversions
@opindex flax-vector-conversions
異なる要素数・非互換の要素型のベクタの暗黙の型変換を許す。このオプションは新しいコードでは使うべきではない。

@item -funsigned-char
@opindex funsigned-char
型@code{char}を@code{unsigned char}のように符号なしにさせる。

それぞれの機種では@code{char}がどちらであるべきかのデフォルトがある。@code{unsigned char}がデフォルトであるか、
@code{signed char}がデフォルトであるかのどちらかである。

理想的には、移植性のあるプログラムは常にオブジェクトの符号に依存するときには@code{signed char}か
@code{unsigned char}を使うべきである。しかし、多くのプログラムでは単なる@code{char}を使って書かれ、
書かれた機種に依存して、符号ありであるか、符号なしであるかを期待する。このオプションと、その逆は、
そのようなプログラムが逆のデフォルトでも動くようにさせる。

型@code{char}は、その振る舞いが@code{signed char}, @code{unsigned char}のどちらにいつも似ていても、
常にそれらの型とは異なる型である。

@item -fsigned-char
@opindex fsigned-char
型@code{char}を@code{signed char}のように符号付きにさせる。

これは、@option{-funsigned-char}の否定形である@option{-fno-unsigned-char}と等価である。
同様に、オプション@option{-fno-signed-char}は@option{-funsigned-char}と等価である。

@item -fsigned-bitfields
@itemx -funsigned-bitfields
@itemx -fno-signed-bitfields
@itemx -fno-unsigned-bitfields
@opindex fsigned-bitfields
@opindex funsigned-bitfields
@opindex fno-signed-bitfields
@opindex fno-unsigned-bitfields
これらのオプションはビットフィールドが、宣言に@code{signed}や@code{unsigned}が含まれていない時に
符号ありか符号なしかを制御する。デフォルトでは、そのようなビットフィールドは符号ありである。なぜなら
それで一貫しているからである。@code{int}のような基本的な整数型は符号あり型である。

@item -fsso-struct=@var{endianness}
@opindex fsso-struct
構造体や共用体のデフォルトの格納順序そ指定されたエンディアンにする。受理される値は@samp{big-endian}と
@samp{little-endian}、ターゲットの本来のエンディアンである（デフォルトの）@samp{native}である。
このオプションはC++ではサポートされない。

@strong{警告：} @option{-fsso-struct}スイッチはもし指定されたエンディアンがターゲット本来のエンディアンでない場合には、オプション無しで生成したコードとバイナリ非互換のコードを生成する。
@end table

@node C++ Dialect Options
@section C++変種を制御するオプション

@cindex compiler options, C++
@cindex C++ options, command-line
@cindex options, C++
この節ではC++プログラムでのみ意味を持つコマンドラインオプションを描写する。どの言語が含まれているかにかかわらず、
GNUコンパイラオプションの殆どのオプションを使うことができる。例えば、@file{firstClass.C}をこのようにコンパイルできる。

@smallexample
g++ -g -fstrict-enums -O -c firstClass.C
@end smallexample

@noindent
この例で、@option{-fstrict-enums}はC++プログラムでのみ意味を持つオプションである。GCCでサポートされている
どの言語でも、他のプションを使うことができる。

@option{-std}のような、Cプログラムをコンパイルする幾つかのオプションはC++プログラムにも関連する。
@xref{C Dialect Options,,C変種を制御するオプション}.

ここにC++プログラムをコンパイルするとき@emph{だけ}のオプションのリストがある。

@table @gcctabopt

@item -fabi-version=@var{n}
@opindex fabi-version
C++ABIのバージョン@var{n}を使う。デフォルトは0である。

バージョン0はC++ABI仕様書に最も近く準拠するバージョンを参照する。したがって、バージョン0を使って得られる
ABIはABIのバグが修正されるとG++の異なるバージョンでは変化するだろう。

バージョン1はG++ 3.2で初めて現れたバージョンである。

バージョン２はG++3.4で初めて現れ、G++4.9までのデフォルトであった。

バージョン3はテンプレート引数としての定数アドレスのマングルでの誤りを修正する。

バージョン4は、G++ 4.5で最初に現れ、ベクタ型の標準マングルを実装する。

バージョン5は、G++ 4.6で最初に現れ、関数ポインタ型のconst/volatile属性のマングル、
素のdeclのdecltype、他のパラメータの宣言での関数パラメータの使用を修正する

バージョン6は、G++ 4.7で最初に現れ、C++11 スコープenumの昇格の振舞、とテンプレート引数パックのマングル、
const/ststic_cast, 前置++/-- テンプレート引数として使われるクラススコープ関数を修正する。 

バージョン7は、G++ 4.8で最初に現れ、nullptr_tを組み込み型として扱い、デフォルト引数スコープでのラムダのマングル
を修正する。

バージョン8は、G++ 4.9で最初に現れ、関数cv指定子ありの関数型の置換の振る舞いを修正する。

バージョン9は、G++ 5.2で最初に現れ、@code{nullptr_t}のアライメントを修正する。

バージョン10は、G++ 6.1で最初に現れ、(ia32呼び出し規約属性@samp{stdcall}のような)タイプ同一性に影響する
属性のマングルを加える。

バージョン11は、G++ 7で最初に現れ、sizeof...式とオペレーター名のマングリングを訂正する。
関数内で、異なるスコープで宣言されたの同じ名前を持つ複数のエンティティでは、マングリングは
12回の出現で変化を始める。それは@option{-fnew-inheriting-ctors}を含む。

G++ 8で初めて登場したバージョン12は、x86_64ターゲット上の空のクラスと、削除されたコピー/移動コンストラクタのみを持つクラスの呼び出し規約を修正している。 それは、誤って、削除されたコピーコンストラクタと簡単な移動コンストラクタを持つクラスの呼び出し規約を変更した。

バージョン13は、G++ 8.2ではじめて登場し、バージョン12の偶発的な変更を修正した。
 
@option{-Wabi}も見よ。

@item -fabi-compat-version=@var{n}
@opindex fabi-compat-version
強いエイリアスをサポートするターゲットで、G++は間違ったマングルされた名前でシンボルが定義された時に、
正しくマングルされた名前へのエイリアスを作ることでマングルの変化に対処する。このスイッチはエイリアス
で使うABIバージョンを指定する。

@option{-fabi-version=0}で（デフォルト）、これはデフォルトを11（GCC7互換）とする。もしほかのABIバージョンが明示的に選択されれば、これはデフォルトを0とする。GCC3.2から4.9への互換性のためには、@option{-fabi-compat-version=2}を使う。

もしこのオプションが与えられず、@option{-Wabi=@var{n}}がある場合は、そのバージョンが互換エイリアスに使われる。
もしオプションが@option{-Wabi}（バージョン無しで）といっしょに提供された場合は、このオプションのバージョンが警告
で用いられる。

@item -fno-access-control
@opindex fno-access-control
すべてのアクセスコントロールチェックを切る。このスイッチは主にアクセスコントロールコードのバグの対処に有用である。

@item -faligned-new
@opindex faligned-new
@code{void:: operator new(std::size_t)}が提供する以上のアラインメントを要求する型のC++17@code{new}の
サポートを有効にする。@code{-faligned-new=32}のような数値の引数は（バイト単位で）どのぐらいのアラインメントが
その関数で提供されているを指定するために使うことができるが、殆どのユーザはデフォルトの@code{alignof(std::max_align_t)}
を上書きする必要はないだろう。

このフラグは@option {-std=c++17}でデフォルトで有効になっています。

@item -fcheck-new
@opindex fcheck-new
@code{operator new}で返されるポインタがnullでないことを割り当てられた領域を修正しようとする前にチェックする。
C++標準が@code{operator new}が@code{throw()}と宣言された場合にのみ@code{0}を返すと指定し、
その場合にはこのオプションなしでもコンパイラはいつも返り値をチェックするため、このチェックは通常は不必要である。
他の場合は、@code{operator new}が空でない例外指定を持つときは、メモリ枯渇は@code{std::bad_alloc}を投げることで
示される。@samp{new (nothrow)}も見よ。

@item -fconcepts
@opindex fconcepts
C++コンセプト技術仕様書ISO 19217 (2015)のサポートを有効にし、以下の様なコードを許可する。

@smallexample
template <class T> concept bool Addable = requires (T t) @{ t + t; @};
template <Addable T> T add (T a, T b) @{ return a + b; @}
@end smallexample

@item -fconstexpr-depth=@var{n}
@opindex fconstexpr-depth
C++11定数式関数の最大入れ子評価深さを@var{n}にセットする。制限は定数表現評価の無限再帰を検出するために
必要である。標準で指定された最小値は512である。

@item -fconstexpr-loop-limit=@var{n}
@opindex fconstexpr-loop-limit
C++14constexpr関数でのループの繰り返し吸うの最大値を@var{n}に指定する。制限値は定数式評価中の
無限ループの検出に必要である。デフォルトは262144(1<<18)である。

@item -fdeduce-init-list
@opindex fdeduce-init-list
すなわち、ブレースで囲まれた初期化リストからの@code{std::initializer_list}として、テンプレート・タイプ・パラメータの推論を使用可能にする。すなわち、

@smallexample
template <class T> auto forward(T t) -> decltype (realfn (t))
@{
  return realfn (t);
@}

void f()
@{
  forward(@{1,2@}); // call forward<std::initializer_list<int>>
@}
@end smallexample

この推論はC++11標準で元々提案された意味へのありうる拡張として実装されたが、最終標準の一部ではなかったので、
デフォルトで無効にされた。このオプションは非推奨であり、G++の将来のバージョンでは削除されるかもしれない。

@item -ffriend-injection
@opindex ffriend-injection
フレンド関数を、宣言されている関数のスコープの外側から見えるようにそれを囲んでいる名前空間に注入する。
フレンド関数はそのように働くように古い注釈付きC++リファレンス・マニュアルには記述されていた。しかし、
ISO C++では囲んでいるスコープで宣言されていないフレンド関数は引数依存検索でのみ見つけることができる。
GCCのデフォルトは標準の振る舞いである。

このオプションは廃止予定であり、削除されるだろう。

@item -fno-elide-constructors
@opindex fno-elide-constructors
C++標準は同じ型の他のオブジェクトを初期化するために使われるだけの一時値の生成を省略する実装を許している。
このオプションを指定するとその最適化を無効化、G++がどんな場合でもコピーコンストラクタを呼ぶようにする。
このオプションはG++がさもなければインライン展開されるようなささいなメンバ関数を呼ぶようにもさせる。

C++17では、コンパイラはこれらの一時値を抜かすことを要求しているが、このオプションは些細なメンバ関数にはまだ影響する。

@item -fno-enforce-eh-specs
@opindex fno-enforce-eh-specs
実行時の例外指定違反のチェックコードを生成しない。このオプションはC++標準に反するが、
@code{NDEBUG}が定義されるような製品ビルドでコードサイズを削減するのに有用かもしれない。
これはユーザコードが例外指定に反する例外を投げることを許可するわけではない。コンパイラはそれでも指定に基づいて
最適化するので、予期せぬ例外を投げると実行時に未定義の振る舞いを引き起こす。

@item -fextern-tls-init
@itemx -fno-extern-tls-init
@opindex fextern-tls-init
@opindex fno-extern-tls-init
C++11とOpneMPは@code{thread_local}と@code{threadprivate}変数が動的に（実行時に）初期化することを認めている。
これをサポートするために、そのような変数の使用はラッパ関数を通して必要な初期化を呼び出す。
同じ翻訳単位で使用と定義をした場合には、このオーバーヘッドは最適化で消えるが、別の翻訳単位で使われた時は、
たとえ動的な初期化が実際には必要ない時でもかなりのオーバーヘッドがある。もしプログラマが動的の初期化のトリガが
必要な定義されていない翻訳単位への変数の使用がない（変数が静的に初期化されているか、他の翻訳単位で使う前に
定義された翻訳単位で実行されている）と確信できるときは、このオーバーヘッドを@option{-fo-extern-tls-init}オプション
で避けることができる。

シンボルエイリアスをサポートしているターゲットでは、デフォルトは@option{-fextern-tls-init}である。シンボルエイリアスを
サポートしていないターゲットでは、デフォルトは@option{-fno-extern-tls-init}である。

@item -ffor-scope
@itemx -fno-for-scope
@opindex ffor-scope
@opindex fno-for-scope
@option{-ffor-scope}が指定されると、@i{for-初期化文}で宣言された変数のスコープはC++標準で指定されたように、
@code{for}ループ自身に制限される。もし@option{-fno-for-scope}が指定されると、古いバージョンG+＋や、
他の（伝統的な）C++の実装のように、@i{for-初期化文}で宣言された変数のスコープは取り囲むスコープの終わりまで拡張される。

このオプションは廃止予定であり、関連した非標準の機能は削除されるだろう。

@item -fno-gnu-keywords
@opindex fno-gnu-keywords
@code{typeof}をキーワードとして認識せず、この語を識別子として使えるようにする。代わりにキーワード@code{__typeof__}を使うことができる。
このオプションは厳格なISO C++変種に含まれる。@option{-ansi}, @option{-std=c++98}, @option{-std=c++11}など。

@item -fno-implicit-templates
@opindex fno-implicit-templates
暗黙のうちに（すなわち、使うことで）実体化される非インラインテンプレートのコードを生成しない。。明示的な実体化のみコードを生成する。
詳しい情報は@xref{Template Instantiation}。

@item -fno-implicit-inline-templates
@opindex fno-implicit-inline-templates
インラインテンプレートの暗黙の実体化のコードも生成しない。デフォルトはインラインを別に扱い、最適化の有無で明示的な実体化の必要な集合が変わらないようにする。

@item -fno-implement-inlines
@opindex fno-implement-inlines
空間を節約するために、@code{#pragma implementation}によって制御されるインライン関数の行外のコピーを生成しない。
これはもしそれらの関数が呼ばれた場所のどこでもインライン化されていないならばリンカエラーを起こすだろう。

@item -fms-extensions
@opindex fms-extensions
MFCで使われている、暗黙のintやメンバへのポインタを非標準の構文で得るような構造についての警告を無効にする。

@item -fnew-inheriting-ctors
@opindex fnew-inheriting-ctors
C++11コンストラクタ継承の意味に対してP0136の調整を有効にする。これはC++17の一部だが
C++11とC++14に対するデファクト・レポートであるとも考えられる。このフラグは@option{-fabi-version=10}以下
が指定されない限りデフォルトである。

@item -fnew-ttp-matching
@opindex fnew-ttp-matching
Core issue150、テンプレートテンプレートパラメータとデフォルト引数へのP0522解決を有効にする。
これはデフォルトテンプレート引数のあるテンプレートをより少ないテンプレートパラメータでの
テンプレートテンプレートパラメータの引数としての使用を可能にする。このフラグは@option{-std=c++17}でデフォルトで
有効である。

@item -fno-nonansi-builtins
@opindex fno-nonansi-builtins
ANSI/ISO Cで義務付けられていない関数の組み込み宣言を無効にする。これは、@code{ffs}, @code{alloca}, @code{_exit}, @code{index}, @code{bzero},
@code{conjf}や他の関連した関数が含まれる。

@item -fnothrow-opt
@opindex fnothrow-opt
@code{throw()}例外指定を例外指定なしの関数に対してテキストサイズのオーバーヘッドの削減/除去のために@code{noexcept}指定をしたかのように扱う。
もし関数が自明でないデストラクタの型のローカル変数を持つならば、それの変数のEHクリーンアップは除去できるので、例外指定は実際に小さくなる。
意味論上の効果は例外指定のような関数の外で投げられた例外は@code{unexpected}ではなく@code{terminate}を呼ぶようになる。

@item -fno-operator-names
@opindex fno-operator-names
演算子名キーワード@code{and}, @code{bitand}, @code{bitor}, @code{compl}, @code{not}, @code{or}, @code{xor}を別名のキーワードして扱わない。

@item -fno-optional-diags
@opindex fno-optional-diags
標準がコンパイラが発行する必要が無いと言っている診断を無効にする。現在、G++によって発行されるそのような唯一の診断はクラス内で複数の意味を持つ名前
に関するものである。

@item -fpermissive
@opindex fpermissive
非準拠コードの幾つかの診断をエラーから警告に格下げする。したがって、@option{-fpermissive}を使うと幾つかの非準拠コードをコンパイルできるようになる。

@item -fno-pretty-templates
@opindex fno-pretty-templates
エラーメッセージが関数テンプレートの特殊化を参照するとき、コンパイラは通常どのテンプレートが関与しているかを明白にするために
テンプレート引数とシグネチャのtypedefか形名をテンプレートシグネチャの後ろに出力する。（例えば、@code{void f(int)}ではなく
@code{void f(T) [with T = int]}。エラーメッセージがクラステンプレートの特殊化を参照するとき、コンパイラはテンプレートのデフォルトテンプレート引数を
省略する。もしこれらの振る舞いがエラーメッセージを理解するのを易しくするのではなく、難しくしているときは、@option{-fno-pretty-templates}を使って
無効にすることができる。

@item -frepo
@opindex frepo
リンク時の自動テンプレート実体化を有効にする。このオプションは@option{-fno-implicit-templates}を含む。さらなる情報は@xref{Template
Instantiation}。

@item -fno-rtti
@opindex fno-rtti
C++実行時型識別の機能(@code{dynamic_cast}と@code{typeid})で使うための仮想関数のある全クラスについての情報の出力を無効にする。
もし言語のこれらの機能を使わないならば、このフラグを使うことで空間を少し節約できる。例外の扱いも同じ情報を使うが、G++は必要に応じて
生成することに注意する。実行時型情報を使わないキャストでは@code{dynamic_cast}演算子はまだ使用可能である。すなわち、@code{void*}や
曖昧でない基底クラスへのキャスト

@item -fsized-deallocation
@opindex fsized-deallocation
C++14で導入される組み込みグローバル宣言
@smallexample
void operator delete (void *, std::size_t) noexcept;
void operator delete[] (void *, std::size_t) noexcept;
@end smallexample
を有効にする。これは、例えば、解放をより速くするためにオブジェクトのサイズを使うユーザ定義の置換解放関数に役立つ。
@option{-std=c++13}以上ではデフォルトで有効である。フラグ@option{-Wsized-deallocation}は定義を加えたいかもしれない場所について警告する。

@item -fstrict-enums
@opindex fstrict-enums
コンパイラが列挙型の値が（C++標準で定義されているように）列挙の値の一つのみだという仮定を使って最適化するのを許す。
（基本的には、可能な値はすべての列挙を表現できる最小のビット数で表現される。）
仮定はプログラムが任意の整数を列挙型に変換するためのキャストを使うならば正当でないかもしれない。

@item -fstrong-eval-order
@opindex fstrong-eval-order
C++17で採用されたとおり、メンバアクセス、配列の添字、シフト表現を左から右への順序で評価し、
代入文を右から左への順序で評価する。@option{-std=c++17}ではデフォルトで有効である。
@option{-fstrong-eval-order=some}はメンバアクセスとシフト表現の順序のみ有効にし、
@option{-std=c++17}なしでデフォルトである。

@item -ftemplate-backtrace-limit=@var{n}
@opindex ftemplate-backtrace-limit
単一の警告/エラーのテンプレート実体化注釈の最大値を設定する。デフォルト値は10である。

@item -ftemplate-depth=@var{n}
@opindex ftemplate-depth
テンプレートクラスの最大実体化の深さを@var{n}に設定する。テンプレート実体化の深さの制限はテンプレートクラス実体化の
無限再帰を検出するために必要である。ANSI/ISO C++に適合したプログラムは最大深さが17より多いことに依存してはならない。
(C++11では1024に変更された)。デフォルト値は900である。なぜならコンパイラはある状況では1024に到達する前にスタック空間を尽くしうるからだ。

@item -fno-threadsafe-statics
@opindex fno-threadsafe-statics
ローカル静的変数のスレッドセーフな初期化のC++ ABIで指定されたルーチンを使う追加のコードを生成しない。
このオプションをスレッドセーフにする必要が無いコードで少しコードサイズを削減するために使うことができる。

@item -fuse-cxa-atexit
@opindex fuse-cxa-atexit
静的領域のオブジェクトのデストラクタを@code{atexit}関数ではなく@code{__cxa_atexit}で登録する。このオプションは静的デストラクタの
完全に標準準拠の扱いに必要だが、Cライブラリは@code{__cxa_atexit}をサポートしている場合のみ働く。

@item -fno-use-cxa-get-exception-ptr
@opindex fno-use-cxa-get-exception-ptr
@code{__cxa_get_exception_ptr}ランタイムルーチンを使わない。これは@code{std::uncaught_exception}を正しくなくさせるが、
もしランタイムルーチンが利用できないならば必要である。

@item -fvisibility-inlines-hidden
@opindex fvisibility-inlines-hidden
このスイッチはユーザが２つの関数のアドレスが別の共有オブジェクトで取られるところで、
インライン関数やメソッドのポインタの比較をしようとしないと宣言する。

この効果はGCCが、事実上、インライン関数を@code{__attribute__ ((visibility ("hidden")))}とマークして、
DSOのエクスポートテーブルに現れないようにして。DSO内で使われた時にPLT間接を要求しないようにする。
このオプションを有効にするとライブラリがかなりのテンプレートを使っている時には動的エクスポートテーブルのサイズを大いに減らすので、
ロードとリンク時間に劇的な効果が有る。

このスイッチの振る舞いはメソッドに直接hiddenとマークするのと全く同じではない。なぜならそれは関数にローカルな静的変数には影響せず、
コンパイラに単一の共有オブジェクトで定義された関数を推測させるわけでもないからである。

メソッドをそのメソッドのスイッチの効果を反転させるのに明示的に可視性をマークしてもよい。例えば、特定のインラインメソッドへのポインタを比較したいならば、
デフォルトの可視性を持つようにマークするかもしれない。囲むクラスに明示的に可視性をマークしても効果はない。

明示的に実体化されたインラインメソッドは、リンケージが共有ライブラリの境界をまたぐかもしれないので、このオプションの効果はない。
@xref{Template Instantiation}.

@item -fvisibility-ms-compat
@opindex fvisibility-ms-compat
このフラグはGCCのC++リンケージモデルをMicrosoft Visual Studioのものと互換性を持たせるような可視性設定を使おうとする。

このフラグはGCCはリンケージモデルにこれらの変更を行う。

@enumerate
@item
デフォルトの可視性を、@option{-fvisibility=hidden}のように@code{hidden}にする。

@item
型は、メンバとは異なり、デフォルトでは隠されない。

@item
単一定義規則は複数の共有物で定められる明確な可視性仕様なしの型では緩和される。
このオプションが使われないときそれらが許されるならば、それらの宣言は許される。
@end enumerate

新しいコードは@option{-fvisibility=hidden}を使い、明示的に可視を意図するクラスをエクスポートした方がいい。
不幸にも、たぶん意図せずに、Visual Studioの振る舞いに依存するコードはありうる。

これらの変化の結果の間で、同じ名前で同じ型だが別の共有オブジェクトの静的データメンバは異なるので、
片方を変えても、もう片方は変わらない。そして異なる共有オブジェクトで定義された関数メンバへのポインタは
等しくないかもしれない。このフラグが与えられると、異なって同じ名前の型を定義するとODR違反となる。

@item -fno-weak
@opindex fno-weak
弱いシンボルをリンカが提供していても使わない。デフォルトでは、もし利用可能ならば弱いシンボルを使う。
これはテストのためだけに存在し。エンドユーザは使うべきではない。それは劣ったコードを引き起こし、利点はない。
このオプションは将来のG++のバージョンでは削除されるかもしれない。

@item -nostdinc++
@opindex nostdinc++
C++特有の標準ディレクトリでヘッダファイルを検索しないが、他の標準ディレクトリは検索する。（このオプションは
C++ライブラリをビルドするときに使う）
@end table

加えて、これらの最適化、警告、コード生成オプションはC++プログラムでのみ意味を持つ。

@table @gcctabopt
@item -Wabi @r{(C, Objective-C, C++とObjective-C++専用)}
@opindex Wabi
@opindex Wno-abi
ベンダー本来のC++ ABIと互換性を持たないかもしれないコードを生成するときに警告する。
G++は現在、メジャーリリースごとにデフォルトでABIを更新するので、@option{-Wabi}は通常、
初期のリリース以降に発見されたABIの問題のためにリリースの後半で加えられたチェックがある場合だけ警告する。@option{-Wabi}は
(@option{-fabi-version=@var{n}}で)古いABIバージョンが選択されたときにはもっと多くの警告をする。

特定の@option{-fabi-version}レベル（例えば@option{-fabi-version=2}と比較した変化について警告する@option{-Wabi=2}）との
互換性について警告するために、@option{-Wabi}が明確なバージョン番号で使われることもできる。

明確なバージョン番号が提供され、@option{-fabi-compat-version}が指定されないならば、このオプションからのバージョン番号が互換性別名のために使われる。
明確なバージョン番号がこのオプションで提供されないが@option{-fabi-compat-version}が指定されるならば、そのバージョン番号がABI警告のために使われる。

すべての場合について警告するように努力するが、たとえG++が非互換のコードを生成しているとしても、警告されないあるケースが多分あるだろう。たとえ生成されるコードが互換性を持つとしても、警告が発されるケースも、あるかもしれない。

G++によって生成されるコードが他のコンパイラによってコードを生成してバイナリ互換でないかもしれないという事実を心配するならば、あなたはこれらの警告を避けるためにあなたのコードを書き直すべきである。

@option{-fabi-version=2}（GCC 3.4～4.9からのデフォルトであった）の既知の非互換性は、以下を含む：

@itemize @bullet

@item
参照型の非型のテンプレートパラメータのテンプレートは誤ってマングルされた

@smallexample
extern int N;
template <int &> struct S @{@};
void n (S<N>) @{2@}
@end smallexample

これは@option{-fabi-version=3}で修正された。

@item
@code{__attribute ((vector_size))}を使って宣言されたSIMDベクタ型は異なるサイズのベクタを取るオーバーロードができない
非標準のやり方でマングルされた

マングルは @option{-fabi-version=4}で変わった。

@item
@code{__attribute ((const))}と@code{noreturn}は型修飾子としてマングルされ、素の宣言の@code{decltype}は折りたたまれた。

これらノンマングルの問題は@option{-fabi-version=5}で修正された。

@item
可変長引数関数に渡されるスコープの列挙は非スコープの列挙のように格上げされ、@code{va_arg}が文句を言う。多くのターゲットでは、@code{int}より小さな
引数を渡す方法がないので、これは効果を持たない。

さらに、ABIはテンプレート引数の詰め、@code{const_cast}, @code{static_cast}, 前置インクリメント・デクリメント、テンプレート引数として使われるクラススコープの関数
のマングルを変えた。

これらの問題は@option{-fabi-version=6}で修正された。

@item
デフォルト引数スコープでのラムダは間違ってマングルされ、ABIは@code{nullptr_t}のマングルを変えた。

これらの問題は@option{-fabi-version=7}で修正された。

@item
関数cv修正子つきの関数型をマングルするとき、修正子なしの関数型は誤って置換対象として扱われた。

これは @option{-fabi-version=8}で修正され、GCC5.1のデフォルトである。

@item
@code{decltype(nullptr)}は誤ってアライメント1を持ち。非境界アクセスを起こした。これはパラメータが最小のアラインメントを持つので、
@code{nullptr_t}パラメータを持つ関数のABIには影響しないことに注意。

これは @option{-fabi-version=9}で修正され、GCC5.2のデフォルトである。

@item
関数型のia32呼び出し規約(stdcall, regparmなど)のような、型の識別性に影響するターゲット固有の属性はマングル名に影響せず、テンプレート引数として関数ポインタ
が使われた時は名前の衝突を引き起こした。

これは @option{-fabi-version=10}で修正され、GCC6.1のデフォルトである。

@end itemize

psABI関連の変更についても警告する。現時点での既知のpsABIの変更はいかを含む。

@itemize @bullet

@item
SysV/x86-64では、@code{long double}を持つ共用体メンバはpsABIで指定されたようにメモリで渡される。例えば、

@smallexample
union U @{
  long double ld;
  int i;
@};
@end smallexample

@noindent
@code{union U}は常にメモリで渡される。

@end itemize

@item -Wabi-tag @r{(C++とObjective-C++専用)}
@opindex Wabi-tag
@opindex -Wabi-tag
ABIタグを持たないコンテキストでABIタグが使われた型について警告する。
ABIタグについての情報は@ref{C++ Attributes}参照。

@item -Wctor-dtor-privacy @r{(C++とObjective-C++専用)}
@opindex Wctor-dtor-privacy
@opindex Wno-ctor-dtor-privacy
そのクラスの全コンストラクタかデストラクタがprivateで、フレンドもpublicな静的メンバ関数もないために使用不可能に見えるときに警告する。
privateでないメソッドがあり、少なくとも1つコンストラクタでもデストラクタでもないprivateメンバ関数があるときにも警告する。

@item -Wdelete-non-virtual-dtor @r{(C++とObjective-C++専用)}
@opindex Wdelete-non-virtual-dtor
@opindex Wno-delete-non-virtual-dtor
@code{delete}が仮想関数と非仮想のデストラクタを持つクラスのインスタンスを破壊するために使われた時に警告する。もし基底クラスが仮想デストラクタを
持っていないなら、基底クラスへのポインタを通して派生クラスのインスタンスを削除するのは安全ではない。この警告は@option{-Wall}で有効になる。

@item -Wliteral-suffix @r{(C++とObjective-C++専用)}
@opindex Wliteral-suffix
@opindex Wno-literal-suffix
文字列が文字定数にアンダースコアで始まらないユーザ定義接尾辞が続くときに警告する。合致する警告として、GCCはそのような接尾辞を、
@code{<inttypes.h>}からの書式マクロを使うコードとの後方互換性を維持するために分離されたプリプロセストークンとして扱う。

@smallexample
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <stdio.h>

int main() @{
  int64_t i64 = 123;
  printf("My int64: %" PRId64"\n", i64);
@}
@end smallexample

この場合、@code{PRId64}は別のプリプロセストークンとして扱われる。

さらに、ユーザ定義のリテラル演算子が、アンダースコアで始まらないリテラル接尾辞識別子で宣言されたときに警告する。アンダースコアで始まらないリテラル接尾辞識別子は、将来の標準化のために予約されている。

この警告はデフォルトで有効である。

@item -Wlto-type-mismatch
@opindex Wlto-type-mismatch
@opindex Wno-lto-type-mismatch

リンク時最適化の間に異なるコンパイル単位からのグローバル宣言ち不一致の型について警告する。
有効にするには@option{-flto}が要求される。デフォルトで有効である。

@item -Wno-narrowing @r{(C++とObjective-C++専用)}
@opindex Wnarrowing
@opindex Wno-narrowing
C++11以降の標準では、挟化変換は標準で要求される通り、デフォルトで診断される。
定数からの挟化変換はエラーを生成し、非定数からの挟化変換は警告を出すが、@option{-Wno-narrowing}は診断を抑制する。
これは正しく書かれたコードの意味に影響を与えない。挟化変換はSFIANE文脈ではまだ間違っていると判断される。

C++98では@option{-Wnarrowing}によって、C++11で@samp{@{ @}}内で禁止されている狭化変換について警告する。
例えば、

@smallexample
int i = @{ 2.2 @}; // error: narrowing from double to int
@end smallexample

このフラグは@option{-Wall}と@option{-Wc++11-compat}に含まれる。

@item -Wnoexcept @r{(C++とObjective-C++専用)}
@opindex Wnoexcept
@opindex Wno-noexcept
例外を投げない例外指定（すなわち、@code{throw()}か@code{noexcept}）を持たない関数を呼び出しているのでnoexcept式が偽と評価されるがｍ
コンパイラが決して例外を出さないと知っている時に警告する。

@item -Wnoexcept-type @r{(C++とObjective-C++専用)}
@opindex Wnoexcept-type
@opindex Wno-noexcept-type
関数型に@code{noexcept}部分が含まれるC++17の機能がC++14と比較してシンボルのマングル名を変えるなら警告する。
@option{-Wabi}と@option{-Wc++17-compat}で有効である。

例として：

@smallexample
template <class T> void f(T t) @{ t(); @};
void g() noexcept;
void h() @{ f(g); @}
@end smallexample

@noindent
C++14では、@code{f}は@code{f}@code{f<void(*)()>}を呼ぶが、C++17では、@code{f<void(*)()noexcept>}を呼ぶ。

@item -Wclass-memaccess @r{(C++とObjective-C++のみ)}
@opindex Wclass-memaccess
@code{memset}や@code{memcpy}のような生のメモリ関数の呼び出し先がクラス型のオブジェクトで、そのようなオブジェクトへの書き込みがクラスの非自明な、または削除されたコンストラクタおよびコピー代入をバイパスするか、 constの正当性やカプセル化に違反するか、仮想テーブルポインタが壊れる可能性があるに警告する。 そのようなオブジェクトの表現を変更すると、そのクラスのメンバ関数によって維持される不変量に違反する可能性がある。 例えば、以下の@code{memset}への呼び出しは、自明ではないクラスオブジェクトを変更するため未定義で、診断される。 このような型のオブジェクトの記憶域を初期化またはクリアする安全な方法は、適切なコンストラクタまたは代入演算子が利用可能であればそれを使用することである。
@smallexample
std::string str = "abc";
memset (&str, 0, sizeof str);
@end smallexample
@option{-Wclass-memaccess}オプションは@option {-Wall}によって有効になる。明示的にクラスオブジェクトへのポインタを@code{void *}にキャストするか、生のメモリ関数によって安全にアクセスできる型にキャストすると警告が抑制される。

@item -Wnon-virtual-dtor @r{(C++とObjective-C++専用)}
@opindex Wnon-virtual-dtor
@opindex Wno-non-virtual-dtor
クラスが仮想関数を持ち、それ自身がアクセス可能な非仮想デストラクタを持つか、アクセス可能な多相基底クラスを持つ場合、
クラス自身かその基底クラスへのポインタを通して派生クラスのインスタンスを削除するのは可能だが安全でないために警告する。
この警告は@option{-Weffc++}が指定された時は自動的に有効になる。

@item -Wregister @r{(C++とObjective-C++専用)}
@opindex Wregister
@opindex Wno-register
GNU@ref{Explicit Register Variables}拡張の一部を除いて、@code{register}領域クラス指定子の使用について
警告する。領域クラス指定子としての@code{register}キーワードの使用はC++11で非推奨になりC++17では取り除かれた。
@option{-std=c++17}ではデフォルトで有効である。

@item -Wreorder @r{(C++とObjective-C++専用)}
@opindex Wreorder
@opindex Wno-reorder
@cindex reordering, warning
@cindex warning for reordering of member initializers
コード内で与えられたメンバ初期化子が実行される順番と一致しない時に警告する。例えば、

@smallexample
struct A @{
  int i;
  int j;
  A(): j (0), i (1) @{ @}
@};
@end smallexample

@noindent
コンパイラは@code{i}と@code{j}のメンバ初期化を並べ替えてメンバの宣言順に一致させ、その効果に対する警告を生成する。
この警告は@option{-Wall}で有効である。

@item -fext-numeric-literals @r{(C++とObjective-C++専用)}
@opindex fext-numeric-literals
@opindex fno-ext-numeric-literals
GNU拡張として、虚数、固定小数点、機種定義のリテラル数値接尾辞を受理する。このオプションが切られているときは、
C++11ユーザ定義リテラル数値接尾辞として扱う。これはすべてのC++11以前の変種と全GNU変種ではデフォルトである。
@option{-std=c++98}, @option{-std=gnu++98}, @option{-std=gnu++11}, @option{-std=gnu++14}。このオプションはISO C++11以降では
(@option{-std=c++11}, ... ではデフォルトでオフである。
@end table

以下の@option{-W@dots{}}オプションは@option{-Wall}に影響されない。

@table @gcctabopt
@item -Weffc++ @r{(C++とObjective-C++専用)}
@opindex Weffc++
@opindex Wno-effc++
Scott Meyersの@cite{Effective C++}シリーズ本のスタイルガイドラインの違反について警告する。

@itemize @bullet
@item
動的に割り当てられるメモリのあるクラスのコピーコンストラクタと代入演算子を定義する。

@item
コンストラクタでは代入よりも初期化する。

@item
@code{operator=}は@code{*this}への参照を返す。

@item
オブジェクトを返さなければならないときに参照を返そうとするな。

@item
インクリメントとデクリメント演算子の前置と後置を区別せよ。

@item
@code{&&}, @code{||}, or @code{,}をオーバーロードするな。

@end itemize

このオプションはeffective C++の推奨のひとつでもある、@option{-Wnon-virtual-dtor}も有効にする。
しかし、検査はアクセス可能な非多相基底クラスの仮想デストラクタの欠如にも警告する。

このオプションを選択した時は、標準ライブラリヘッダがすべてのガイドラインに従っているわけではないことに気をつけること。
@samp{grep -v}をそれらの警告を除外するのに使う。

@item -Wstrict-null-sentinel @r{(C++とObjective-C++専用)}
@opindex Wstrict-null-sentinel
@opindex Wno-strict-null-sentinel
キャストなしの@code{NULL}を標識として使うことを警告する。@code{NULL}はが@code{__null}と定義されているので、
GCCでコンパイルするときだけ有効化標識である。これはヌルポインタではなくヌルポインタ定数であるが、それはポインタと同じサイズ
であることが保証されている。しかしこれは他のコンパイラに対しては移植性がない。

@item -Wno-non-template-friend @r{(C++とObjective-C++専用)}
@opindex Wno-non-template-friend
@opindex Wnon-template-friend
非テンプレート化されたフレンド関数がテンプレート内で宣言された時の警告を無効にする。
ISO標準以前の実装である非常に古いバージョンのGCCは@samp{friend foo(int)}のような宣言で、フレンドの名前が非修飾識別子
であるならば、それはテンプレート関数の部分特殊化として解釈し得た。互換性の問題を診断する警告が存在し、デフォルトで有効である。

@item -Wold-style-cast @r{(C++とObjective-C++専用)}
@opindex Wold-style-cast
@opindex Wno-old-style-cast
もし非void型への旧式（C方式）のキャストがC++プログラムにあったら警告する。新式のキャスト(@code{dynamic_cast}, @code{static_cast},
@code{reinterpret_cast}, @code{const_cast})は意図しない効果を受けにくく、検索がずっとしやすい。

@item -Woverloaded-virtual @r{(C++とObjective-C++専用)}
@opindex Woverloaded-virtual
@opindex Wno-overloaded-virtual
@cindex overloaded virtual function, warning
@cindex warning for overloaded virtual function
基底クラスからの仮想関数を関数宣言が隠すときに警告する。例えば、

@smallexample
struct A @{
  virtual void f();
@};

struct B: public A @{
  void f(int);
@};
@end smallexample

は@code{f}の@code{A}クラスバージョンが@code{B}のものを隠し、以下のコードは

@smallexample
B* b;
b->f();
@end smallexample

@noindent
コンパイルできない。

@item -Wno-pmf-conversions @r{(C++とObjective-C++専用)}
@opindex Wno-pmf-conversions
@opindex Wpmf-conversions
メンバ関数への結合ポインタから通常のポインタへの変換についての診断を無効にする。

@item -Wsign-promo @r{(C++とObjective-C++専用)}
@opindex Wsign-promo
@opindex Wno-sign-promo
オーバーロードの解決が符号なし・列挙から符号ありの型への格上げか、同じサイズの符号なし型への変換を選択するときに警告する。
前のバージョンのG++は符号性を維持しようとしたが、標準は現在の振る舞いを要求する。

@item -Wtemplates @r{(C++とObjective-C++専用)}
@opindex Wtemplates
主要テンプレート宣言に出会った時に警告する。あるコードルールはテンプレートを許さず、
これはその規則を強制させるために使うことができる。STLのようなシステムヘッダ内ではこの警告は効力がないため、
まだSTLは使用可能である。テンプレートの実体化や特殊化をしてもよい。

@item -Wmultiple-inheritance @r{(C++とObjective-C++専用)}
@opindex Wmultiple-inheritance
クラスが複数の直接基底クラスで定義されたときに警告する。あるコードルールは多重継承を禁止していて、これはそのルールを
強制するのに使うことができる。この警告はSTLのようなシステムヘッダファイルでは効力がないため、
STLはまだ使用可能である。間接的に多重継承しているクラスも定義できる。

@item -Wvirtual-inheritance
@opindex Wvirtual-inheritance
クラスが仮想の直接基底クラスで定義されていると警告する。あるコードルールは多重継承を禁止していて、これはそのルールを
強制するのに使うことができる。この警告はSTLのようなシステムヘッダファイルでは効力がないため、
STLはまだ使用可能である。間接的に仮想継承を使っているクラスも定義できる。

@item -Wnamespaces
@opindex Wnamespaces
名前空間定義が開かれていると警告する。あるコードルールは名前空間を禁止していて、これはそのルールを
強制するのに使うことができる。この警告はSTLのようなシステムヘッダファイルでは効力がないため、
STLはまだ使用可能である。間接的に仮想継承を使っているクラスも定義できる。usingディレクティブと
修飾名も利用可能である。

@item -Wno-terminate @r{(C++とObjective-C++専用)}
@opindex Wterminate
@opindex Wno-terminate
@code{terminate}を直ちに呼ぶことになるthrows式について警告する。
@end table

@node Objective-C and Objective-C++ Dialect Options
@section Objective-CとObjective-C++変種を制御するオプション
@cindex compiler options, Objective-C and Objective-C++
@cindex Objective-C and Objective-C++ options, command-line
@cindex options, Objective-C and Objective-C++
(注意：このマニュアルはObjective-CとObjective-C++言語自身は説明していない。参照は
@xref{Standards,,GCCによってサポートされている言語標準})

この節はObjective-CとObjective-C++プログラムでのみ意味を持つコマンドラインオプションを紡車する。
言語非依存のGNUコンパイラオプションのほとんども使用可能である。
例えば、@file{some_Class.m}を次のようにコンパイルするかもしれない。

@smallexample
gcc -g -fgnu-runtime -O -c some_class.m
@end smallexample

@noindent
この例では、@option{-fgnu-runtime}はObjective-CとObjective-C++プログラムでのみ意味をを持つ
オプションである。GCCでサポートされているどんな言語でもサポートされている他のオプションを使うことができる。

Objective-CがC言語の拡張なので、Objective-CのコンパイルはCフロントエンド特有の（例えば、@option{-Wtraditional}）オプション
も使うことができる。ことに注意する。同様に、Objective-C++コンパイルはC++と特有のオプション（例えば、@option{-Wabi}を使うことができる。

ここにObjective-CとObjective-C++プログラム@emph{専用}のオプションのリストがある。

@table @gcctabopt
@item -fconstant-string-class=@var{class-name}
@opindex fconstant-string-class
構文@code{@@"@dots{}"}で指定されたそれぞれの文字列定数を実体化するクラス名を@var{class-name}で指定する。
デフォルト名はGNUランタイムが使われたときは@code{NXConstantString}で、NeXTランタイムが使われた時は（下を見よ）
@code{NSConstantString}である。@option{-fconstant-cfstrings}オプションが、もし存在したら、
@option{-fconstant-string-class}設定を上書きして@code{@@"@dots{}"}定数が定数CoreFoundation文字列として展開する。

@item -fgnu-runtime
@opindex fgnu-runtime
標準GNU Objective-Cランタイムと互換性のあるオブジェクトコードを生成する。これはたいていのタイプのシステムで
デフォルトである。

@item -fnext-runtime
@opindex fnext-runtime
NeXTランタイムと互換性のある出力を生成する。これはDawrinとMac OS Xを含めた、NeXTベースのシステムでデフォルトである。
マクロ@code{__NEXT_RUNTIME__}がこのオプションが使われた（ときだけ）事前に定義される。

@item -fno-nil-receivers
@opindex fno-nil-receivers
この翻訳単位のすべてのObjective-Cメッセージディスパッチ(@code{[receiver message:arg]})でレシーバーが
@code{nil}でないことを確かめる。これはランタイムでのもっと効率的なエントリポインタが使われることを可能にする。
このオプションはNeXTランタイムでABIのバージョンが0か1の時のみ利用可能である。

@item -fobjc-abi-version=@var{n}
@opindex fobjc-abi-version
選択されたランタイムのObjective-C ABIのバージョン@var{n}を使う。これは現在NeXTランタイムでのみ
サポートされている。この場合、バージョン0は伝統的な(32ビットの)ABIでプロパティと他のObjective-C 2.0の追加をサポートしない。
バージョン1は伝統的な(32ビットの)ABIでプロパティと他のObjective-C 2.0の追加をサポートする。
バージョン2は現代の(64ビット)ABIである。もし何も指定されない時は、32ビットのターゲットの機種ではバージョン0で、
64ビットのターゲットの機種ではバージョン2である。

@item -fobjc-call-cxx-cdtors
@opindex fobjc-call-cxx-cdtors
それぞれのObjective-Cクラスで、そのインスタンス変数が自明でないデフォルトコンストラクタを持つC++オブジェクトかどうかをチェックする。
もしそうならば、そのようなインスタンス変数の非自明のデフォルトコンストラクタを、順番に呼んで、@code{self}を返す
特別な@code{- (id) .cxx_construct}インスタンスメソッドを合成する。同様に、もしインスタンス変数が非自明なデストラクタを持つC++オブジェクトならば、
そのような全デフォルトコンストラクタを逆順で呼ぶ特別な@code{- (void) .cxx_destruct}を合成する。

現在のObjective-Cクラスで宣言されるインスタンス変数にのみ、このように生成される@code{- (id) .cxx_construct}と@code{- (void) .cxx_destruct}メソッドは
作用し、上位クラスからは継承されない。オブジェクトの継承階層ですべてのそのようなメソッドを実行することは、Objective-Cランタイムの責任である。
@code{- (id) .cxx_construct}メソッドは、新しいオブジェクト例が割り当てられた直後にランタイムによって実行される。
ランタイムがオブジェクトインスタンスの割当てを解放する直前に@code{- (void) .cxx_destruct}メソッドは実行される。

これを書いている時点では、Mac OS X 10.4以降のNeXTランタイムでのみ@code{- (id) .cxx_construct}と@code{- (void) .cxx_destruct}メソッドの実行をサポートする。

@item -fobjc-direct-dispatch
@opindex fobjc-direct-dispatch
メッセージ分岐の高速ジャンプを許可する。Darwinではこれはcommページ経由で達成される。

@item -fobjc-exceptions
@opindex fobjc-exceptions
C++で提供されるものと同様の、Objective-Cでの構造化例外処理の構文サポートを有効にする。これはObjective-Cキーワード@code{@@try}, 
@code{@@throw}, @code{@@catch}, @code{@@finally}, @code{@@synchronized}の使用が要求される。このオプションはGNUランタイムと
NeXTランタイム（しかしNeXTランタイムのMac OS X 10.2以前では利用できない）の両方で利用可能である。

@item -fobjc-gc
@opindex fobjc-gc
Objective-CとObjective-C++プログラムのガベージコレクション(GC)を有効にする。このオプションはNeXTランタイムでのみ利用可能である。
GNUランタイムは特別なコンパイラフラグを必要としない別のガベージコレクション実装を持っていてる。

@item -fobjc-nilcheck
@opindex fobjc-nilcheck
ABIのバージョン2のNeXTランタイムで、実際のメソッド呼び出しを行う前にメソッド呼び出しのレシーバーがnilかをチェックする。
これはデフォルトであり、@option{-fno-objc-nilcheck}を使って無効にできる。
クラスメソッドとsuper呼び出しはこのフラグをセットしたかにかかわらずnilのチェックは決して行われない。
現在このフラグはGNUランタイムや、NeXTランタイムABIの古いバージョンでは何もしない。

@item -fobjc-std=objc1
@opindex fobjc-std
GCC 4.0で認識される言語、Objective-C 1.0の言語構文に従う。これは、C/C++言語へのObjective-C追加に影響を及ぼすだけである。
それはC/C++標準に適合に影響を及ぼさない。そして、それは別々のC/C++変種選択フラグによって制御される。
このオプションがObjective-CまたはObjective-C++コンパイラで使われるとき、GCC 4.0によって認識されないどんなObjective-C構文でも拒絶される。
あなたがあなたのObjective-CコードがGCCの以前の
バージョンでコンパイルされることができることを確認する必要があるならば、これは役に立つ。

@item -freplace-objc-classes
@opindex freplace-objc-classes
@command{ld(1)}に結果のオブジェクト・ファイルで静的にリンクしないように指示している特別な目印を発し、
@command{dyld(1)}がその代わりに実行時でそれを中にロードするのを許す。
修正して実行デバッグモード（問題のオブジェクト・ファイルは再コンパイルされ、プログラム実行の間に動的に再ロードされるかもしれない）とともに、これが、プログラムそのものを再開する必要なしで使われる。
現在では、修正して実行機能は、Mac OS X 10.3以降のNeXTランタイムでのみ利用可能である。

@item -fzero-link
@opindex fzero-link
NeXTランタイムでコンパイルしているとき、コンパイラは@code{objc_getClass("@dots{}")}への呼び出しを、
（クラスの名前がコンパイル時に知られているとき）に、ロード時間に初期化される静的クラス引用に通常置き換える。
そして、それは実行時パフォーマンスを向上させる。@option{-fzero-link}フラグを指定することはこのふるまいを抑えて、
@code{objc_getClass("@dots{}")}への呼び出しが保持されるようにする。
個々のクラスの実装がプログラム実行中に修正されるのをそれが許すので、ゼロリンク・デバッギング・モードに役立つ。
コマンド・ライン・オプションに関係なく、GNUランタイムは@code{objc_get_class("@dots{}")}に呼び出しを現在常に保持する。

@item -fno-local-ivars
@opindex fno-local-ivars
@opindex flocal-ivars
デフォルトではObjective=Cでのインスタンス変数はそれらが宣言されているクラスのメソッド内でローカス変数が宣言されているかのように
アクセス可能である。これはインスタンス変数と同じ名前でクラスメソッド内にローカルに宣言されたか、グローバルに宣言された他の変数を隠す。
@option{-fno-local-ivars}フラグを指定するとこの振る舞いを無効にして変数を隠す問題を避ける。

@item -fivar-visibility=@r{[}public@r{|}protected@r{|}private@r{|}package@r{]}
@opindex fivar-visibility
デフォルトインスタンス変数可視性を指定されたオプションにセットして、アクセス指定ディレクティブのスコープの外側で宣言されたインスタンス変数
がデフォルトで指定された可視性を持つようにする。

@item -gen-decls
@opindex gen-decls
名前@file{@var{sourcename}.decl}という名前のファイルへソースファイルで見られる全クラスのインターフェース定義をダンプする。

@item -Wassign-intercept @r{(Objective-CとObjective-C++専用)}
@opindex Wassign-intercept
@opindex Wno-assign-intercept
Objective-C代入がガベージコレクタで妨害される時には警告する。

@item -Wno-protocol @r{(Objective-CとObjective-C++専用)}
@opindex Wno-protocol
@opindex Wprotocol
クラスがプロトコルを実行すると宣言されるならば、警告はクラスによって実装されないプロトコルにおいて、メソッドごとに発される。
たとえメソッド実装がスーパークラスから継承されるとしても、デフォルトの振る舞いはクラスで明示的に実装されないあらゆるメソッドの警告を発することになっている。
あなたが@option{-Wno-protocol}オプションを使用するならば、スーパークラスから継承されるメソッドは実装されると考えられる、そして、警告はそれらのために発されない。

@item -Wselector @r{(Objective-CとObjective-C++専用)}
@opindex Wselector
@opindex Wno-selector
同じセレクタの異なるタイプの複数のメソッドがコンパイルで見つかるならば警告する。
チェックは、コンパイルの最後の段階にメソッドのリストで実行される。
その上、@code{@@selector(@dots{})}表現において現れている各々のセレクタと、コンパイルの間に見つかったそのセレクタの対応するメソッドでチェックは実行される。
これらのチェックがコンパイル終了後だけメソッド・テーブルを探査するので、コンパイルの最後の段階に達しない（たとえばエラーがコンパイル中に見つかるか、、@option{-fsyntax-only}オプションが使われている）ならば、これらの警告は出されない。

@item -Wstrict-selector-match @r{(Objective-CとObjective-C++専用)}
@opindex Wstrict-selector-match
@opindex Wno-strict-selector-match
型@code{id}または@code{Class}のレシーバへこのセレクタを使ってメッセージを送ろうとするとき、異なっている引数による複数のメソッドや戻りタイプが与えられたセレクタのために見つかったら警告する。このフラグがオフである（デフォルトふるまいである）とき、見つかる違いが同じサイズと調整を共有するタイプに限定されるならば、コンパイラはそのような警告を省略する。

@item -Wundeclared-selector @r{(Objective-CとObjective-C++専用)}
@opindex Wundeclared-selector
@opindex Wno-undeclared-selector
もし未宣言のセレクタを参照する@code{@@selector(@dots{})}表現が見つかったら警告する。
セレクタは明示的に@code{@@interface}か@code{@@protocol}宣言でか、暗黙に@code{@@implementation}
セクションの中で、@code{@@selector(@dots{})}表現の前に宣言された名前を持つメソッドがないならば未宣言とみなされる。
このオプションは常に@code{@@selector(@dots{})}が見つかるとすぐにチェックを実行するが、
@option{-Wselector}はチェックをコンパイルの最後の段階でしか実行しない。これはメソッドとセレクタが使われる前に宣言されなければならないという
コードスタイル規約を強制することもする。

@item -print-objc-runtime-info
@opindex print-objc-runtime-info
もしあれば、値で渡された最大の構造を描写するCヘッダを生成する。

@end table

@node Diagnostic Message Formatting Options
@section 診断メッセージの書式を制御するオプション
@cindex options to control diagnostics formatting
@cindex diagnostic messages
@cindex message formatting

伝統的に、診断メッセージは、出力装置の状況向き（例えばその幅@dots{}）にかかわりなく書式を設定された。
あなたは、例えば、診断メッセージのためにフォーマット化しているアルゴリズムを制御するために以下に記すオプションを使用することができる：
行当たりの文字数、ソース情報をどのぐらい頻繁に報告すべきか。
ある言語フロントエンドがこれらのオプションを守らないかもしれないことに注意すべきである。

@table @gcctabopt
@item -fmessage-length=@var{n}
@opindex fmessage-length
エラーメッセージを行あたり@var{n}文字ぐらいで収めようとする。もし、@var{n}が0ならば、
行送り返しは行われない。それぞれのエラーメッセージは1行で現れる。これは全フロントエンドのデフォルトである。

@item -fdiagnostics-show-location=once
@opindex fdiagnostics-show-location
行送り返しモードでのみ意味を持つ。診断メッセージ報告器にソース場所情報を@emph{一度}だけを発するように命じる。
つまり、メッセージが単一の物理行にを収まらないほど長く、行送りをしなければならない場合には、
以降の継続行では、（接頭辞として）ソース場所は二度とは発されない。これは、デフォルトふるまいである。

@item -fdiagnostics-show-location=every-line
行送り返しモードでのみ意味を持つ。診断メッセージ報告器に単一行には収まらないほど長いメッセージを分割する過程の結果の物理行ごとに
（接頭辞として）同じソース場所情報を発するように命じる。

@item -fdiagnostics-color[=@var{WHEN}]
@itemx -fno-diagnostics-color
@opindex fdiagnostics-color
@cindex highlight, color
@vindex GCC_COLORS @r{environment variable}
診断で色を使う。@var{WHEN}は@samp{never}, @samp{always}, @samp{auto}である。デフォルトはコンパイラがどのように設定されたかに依存し、
上の@var{WHEN}オプションのどれかか、環境変数に@env{GCC_COLORS}が存在しなければ@samp{never}であり、さもなければ@samp{auto}である。
@samp{auto}は標準エラーがターミナルの時だけ色を使うことを意味する。@option{-fdiagnostics-color}型と@option{-fno-diagnostics-color}型は
それぞれ@option{-fdiagnostics-color=always}と@option{-fdiagnostics-color=never}の別名である。

色は環境変数@env{GCC_COLORS}で定義されている。その値はコロンで分割された機能とSelect Graphic Rendition (SGR)のリストである。
SGRコマンドはターミナルかターミナルエミュレータで解釈される。（文字属性として可能な値とその意味はターミナルの文書の該当節参照）
これらは部分文字列値はセミコロンで連結可能な10進表現の整数である。連結する一般的な値は
@samp{1}は太字
@samp{4}は下線
@samp{5}は点滅
@samp{7}は反転
@samp{39}はデフォルトの前景色
@samp{30}から@samp{37}は前景色
@samp{90}から@samp{97}は16色モードの前景色
@samp{38;5;0}から@samp{38;5;255}は88色と256色モードの前景色
@samp{49}はデフォルトの背景色
@samp{40}から@samp{47}は背景色
@samp{100}から@samp{107}は16色モードの背景色
@samp{48;5;0}から@samp{48;5;255}は88色と256色モードの背景色である。

デフォルトの@env{GCC_COLORS}は
@smallexample
error=01;31:warning=01;35:note=01;36:range1=32:range2=34:locus=01:\
quote=01:fixit-insert=32:fixit-delete=31:\
diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32:\
type-diff=01;32
@end smallexample
@noindent
であり、@samp{01;31}は太字の赤、@samp{01;35}は太字のマゼンタ、
@samp{01;36}は太字のシアン、@samp{32}は緑、@samp{34}は青、
@samp{01}は太字、@samp{31}は赤である。
@env{GCC_COLORS}を空文字列にすると色を無効にする。サポートされた機能は以下である。

@table @code
@item error=
@vindex error GCC_COLORS @r{capability}
エラーのマーカーのSGR部分文字列

@item warning=
@vindex warning GCC_COLORS @r{capability}
警告のマーカーのSGR部分文字列

@item note=
@vindex note GCC_COLORS @r{capability}
注釈のマーカーのSGR部分文字列

@item range1=
@vindex range1 GCC_COLORS @r{capability}
最初の追加範囲のSGR部分文字列

@item range2=
@vindex range2 GCC_COLORS @r{capability}
二番目の追加範囲のSGR部分文字列
SGR substring for second additional range.

@item locus=
@vindex locus GCC_COLORS @r{capability}
場所情報、@samp{file:line}や@samp{file:line:column}などのSGR部分文字列

@item quote=
@vindex quote GCC_COLORS @r{capability}
引用符内で出力された情報のSGR部分文字列

@item fixit-insert=
@vindex fixit-insert GCC_COLORS @r{capability}
挿入されるか置換されるように提案された修正ヒントテキストのSGR部分文字列

@item fixit-delete=
@vindex fixit-delete GCC_COLORS @r{capability}
削除されるように提案された修正ヒントテキストのSGR部分文字列

@item diff-filename=
@vindex diff-filename GCC_COLORS @r{capability}
生成されたパッチ内でのファイル名ヘッダのSGR部分文字列

@item diff-hunk=
@vindex diff-hunk GCC_COLORS @r{capability}
生成されたパッチ内でのハンクの開始のSGR部分文字列

@item diff-delete=
@vindex diff-delete GCC_COLORS @r{capability}
生成されたパッチ内での削除された行のSGR部分文字列

@item diff-insert=
@vindex diff-insert GCC_COLORS @r{capability}
生成されたパッチ内の追加された行のSGR部分文字列

@item type-diff=
@vindex type-diff GCC_COLORS @r{capability}
C++フロントエンドでのテンプレート引数内でハイライトしている一致していない型のSGR部分文字列。

@end table

@item -fno-diagnostics-show-option
@opindex fno-diagnostics-show-option
@opindex fdiagnostics-show-option
デフォルトでは、それぞれの生成された診断には（もしそのようなオプションが診断機構に既知であれば）
直接診断を生成するコマンドラインオプションを指すテキストを含める。
@option{-fno-diagnostics-show-option}フラグを指定するとこの振る舞いを抑制する。

@item -fno-diagnostics-show-caret
@opindex fno-diagnostics-show-caret
@opindex fdiagnostics-show-caret
デフォルトでは、生成されたそれぞれの診断には元のソース行と列を示すキャレット@samp{^}を含む。
このオプションはこの情報を抑制する。@option{-fmessage-length=n}が与えられた時は、ソース行は@var{n}文字へと切り詰められる。
出力がターミナルへと行われるときは、幅は@env{COLUMNS}環境変数か、もしセットされていない時はターミナルの幅へと制限される。

@item -fdiagnostics-parseable-fixits
@opindex fdiagnostics-parseable-fixits
IDEによる推測に適した、機械で解析可能な形式で修正ヒントを生成する。それぞれの修正で、
行は関連する診断の後に、``fix-it:''文字列で始まって出力される。例えば、

@smallexample
fix-it:"test.c":@{45:3-45:21@}:"gtk_widget_show_all"
@end smallexample

場所は半開区間で表現され、バイト単位で、最初の桁をバイト１で始めて表現される。
上の例では、``test.c''の行45の3から20までのバイトが与えられた文字列で置換される。

@smallexample
00000000011111111112222222222
12345678901234567890123456789
  gtk_widget_showall (dlg);
  ^^^^^^^^^^^^^^^^^^
  gtk_widget_show_all
@end smallexample

ファイル名と置換文字列はバックスラッシュが``\\", タブが``\t''、改行が``\n'',
二重引用符が``\"'', 非出力文字は8進で(例えば、垂直タブは``\013'')出力される。

空の置換文字列は与えられる範囲が削除すべきことを示す。空の範囲(例えば ``45:3-45:3'')は
文字列が与えられた位置に挿入すべきことを意味する。

@item -fdiagnostics-generate-patch
@opindex fdiagnostics-generate-patch
修正ヒントを標準エラーに統一diffフォーマットで、診断の後に出力する。例えば、
@smallexample
--- test.c
+++ test.c
@@ -42,5 +42,5 @@

 void show_cb(GtkDialog *dlg)
 @{
-  gtk_widget_showall(dlg);
+  gtk_widget_show_all(dlg);
 @}

@end smallexample

diffは色が付くかも付かないかもしれず、診断と同じ規則が適用される。
(@option{-fdiagnostics-color}参照)

@item -fdiagnostics-show-template-tree
@opindex fdiagnostics-show-template-tree

In the C++ frontend, when printing diagnostics showing mismatching
template types, such as:

@smallexample
  could not convert 'std::map<int, std::vector<double> >()'
    from 'map<[...],vector<double>>' to 'map<[...],vector<float>>
@end smallexample

the @option{-fdiagnostics-show-template-tree} flag enables printing a
tree-like structure showing the common and differing parts of the types,
such as:

@smallexample
  map<
    [...],
    vector<
      [double != float]>>
@end smallexample

The parts that differ are highlighted with color (``double'' and
``float'' in this case).

@item -fno-elide-type
@opindex fno-elide-type
@opindex felide-type
By default when the C++ frontend prints diagnostics showing mismatching
template types, common parts of the types are printed as ``[...]'' to
simplify the error message.  For example:

@smallexample
  could not convert 'std::map<int, std::vector<double> >()'
    from 'map<[...],vector<double>>' to 'map<[...],vector<float>>
@end smallexample

Specifying the @option{-fno-elide-type} flag suppresses that behavior.
This flag also affects the output of the
@option{-fdiagnostics-show-template-tree} flag.

@item -fno-show-column
@opindex fno-show-column
診断で桁番号を出力しない。これはもし診断が桁番号を理解しない、例えば@command{dejagnu}のような
プログラムでスキャンされるときには必要かもしれない。

@end table

@node Warning Options
@section 警告を要求・抑制するオプション
@cindex options to control warnings
@cindex warning messages
@cindex messages, warning
@cindex suppressing warnings

警告は本質的には誤っていないが、危険であったり、誤りを示唆するかもしれない構造を
報告するメッセージである。

以下の言語非依存のオプションは特定の警告を有効にはしないが、GCCが生成する診断の
種類を制御する。

@table @gcctabopt
@cindex syntax checking
@item -fsyntax-only
@opindex fsyntax-only
コードの構文エラーをチェックするが、それ以上の事はしない。

@item -fmax-errors=@var{n}
@opindex fmax-errors
エラーメッセージの最大数を@var{n}に制限し、その時点でソースコードの処理を続けようとは
せずに、GCCは脱出する。もし@var{n}が0ならば（デフォルト）、生成されるエラーメッセージ
の制限はない。もし@option{-Wfatal-errors}も指定されるなら、@option{-Wfatal-errors}
はこのオプションより優先する。

@item -w
@opindex w
全ての警告メッセージを抑制する。

@item -Werror
@opindex Werror
@opindex Wno-error
全ての警告をエラーにする。

@item -Werror=
@opindex Werror=
@opindex Wno-error=
指定された警告をエラーにする。警告の指定子が加えられる。例えば、@option{-Werror=switch}
は@option{-Wswitch}で制御される警告をエラーにする。このスイッチは否定形を取り、特定の警告で
@option{-Werror}を反転させるために使う。例えば、@option{-Wno-error=switch}は
@option{-Wswitch}警告、@option{-Werror}の効果があってもエラーにしない。

それぞれの制御可能な警告の警告メッセージは警告を制御するオプションを含む。そのオプションは
上で描写された@option{-Werror=}と@option{-Wno-error=}で使うことができる。
（警告メッセージ内のオプションの出力は@option{-fno-diagnostics-show-option}フラグで無効にできる）

@option{-Werror=}@var{foo}を指定すると自動的に@option{-W}@var{foo}を含むことに注意。
しかし、@option{-Wno-error=}@var{foo}は何も含まない。

@item -Wfatal-errors
@opindex Wfatal-errors
@opindex Wno-fatal-errors
このオプションはコンパイルの最初のエラーが起きた場所で、続けてこれ以上エラーメッセージを出力する
代わりにコンパイルを中止させる。

@end table

@samp{-W}（たとえば潜在的な宣言の警告を要請する@option{-Wimplicit}）で始まるオプションで、あなたは多くの特定の警告を要請することができる。
これらの特定の警告オプションの各々も、警告を消すために@samp{-Wno-}を開始している否定形を持つ。たとえば、@option{-Wno-implicit}。
このマニュアルは、2つの形（デフォルトでないものはどれでも）の1つだけをリストする。さらに言語に特有のオプションについても、
@ref{C++ Dialect Options}と@ref{Objective-C and Objective-C++ Dialect Options}を参照する。

あるオプション（例えば@option{-Wall}と@option{-Wextra}）は他のオプション（例えば@option{-Wunused}）をオンにする。そして、
それは更なるオプション（例えば@option{-Wunused-value}）をオンにするかもしれない。正と負の形の複合効果は、コマンド・ラインの位置と独立して、
より特定のオプションがより特定でないものに優先するということである。同じ特性のオプションについては、最後の1つが実施される。
まるでそれらがコマンド・ラインの終わりに現れるように、pragmas（@pxref{Diagnostic Pragmas}）を通して使用可能にされるか、使用不能なオプションは実施される。

認められていない警告オプションが要請される（例えば、@option{-Wunknown-warning}）とき、GCCはオプションが認識されないと述べている診断を発する。
しかし、@option{-Wno-}の形が使われるならば、ふるまいはわずかに異なる：他の診断法が生み出されない限り、
診断は@option{-Wno-unknown-warning}のために生み出されない。これは古いコンパイラで新しい@option{-Wno-}オプションを使用可能にする、
しかし、何かがうまくいかないならば、コンパイラは認められていないオプションが存在すると警告する。

@table @gcctabopt
@item -Wpedantic
@itemx -pedantic
@opindex pedantic
@opindex Wpedantic
厳格なISO CとISO C++によって要求されるすべての警告を発する。禁じられた拡張を使うすべてのプログラムとISO CとISO C++に追従しないある他のプログラムを拒絶する。
ISO Cでは、使われるどんな@option{-std}オプションで特定されたISO C標準のバージョンにも追従する。

有効なISO CとISO C++プログラムはこのオプションの有無にかかわらずきちんとコンパイルするべきである（まれな少数派がISO cの必須の版を指定している@option{-ansi}または@option{-std}オプションを必要とするけれども）。しかし、このオプションなしでは、特定のGNU拡張と伝統的なのCとC++機能も同様にサポートされる。
このオプションで、それらは拒絶される。

名前が@samp{__}で始まって終わる代替キーワードの用法は、@option{-Wpedantic}では警告メッセージを引き起こさない。
@code{__extension__}に追従する表現も、衒学的な警告が無効にされる。しかし、システム・ヘッダファイルだけでこれらの脱出ルートを使うべきである。アプリケーション・プログラムは、それらを避けるべきである。@xref{Alternate Keywords}。

あるユーザーは、厳しいISO C適合のための検査プログラムに@option{-Wpedantic}を使おうと試みる。それらは、それらが欲するものではないとすぐにわかる。
それは、いくつかの非ISO実行を見つけるが、全てではない。 ― それらISO Cが@emph{要求する}の診断とその診断で加えられるものだけである。

ISO Cに適合することの失敗の報告の機能はある状況では役立つかもしれないが、かなりの更なる働きを必要として、@option{-Wpedantic}と全く異なる。我々には、近い将来、そのような機能をサポートする計画はない。

@option{-std}で指定される標準がC（例えば@samp{gnu90}または@samp{gnu99}）のGNU拡張変種を意味する所では、対応する@dfn{ベース標準}（GNU延長した変種が基礎を形成されるISO Cの版）がある。それらがベース標準によって必要とされるところを、@option{-Wpedantic}からの警告は、与えられる。
（定義上、CのGNU変種は与えられたオプションでコンパイラがサポートする機能を全て含み、警告すべきものは何もないため、
指定されたGNU C変種にない機能に対して与えられる警告は意味をなさない。）

@item -pedantic-errors
@opindex pedantic-errors
@dfn{基底標準}（@option{-Wpedantic}参照）が診断を要求するとき、ある場合にはコンパイル時に未定義の振る舞いがあり、
別の場合には、標準に従って正当なプログラムのコンパイルを妨げない場合、エラーを発する。これは@option{-Werror=pedantic}と
等価ではない。なぜならばこのオプションで有効になるが後者ではならないエラーや、その逆があるからだ。

@item -Wall
@opindex Wall
@opindex Wno-all
あるユーザは不確かと考え、安易に避けられる（もしくは警告を抑止するように修正できる）構造に関する警告を、
マクロと複合中でもすべて有効にする。これは@ref{C++ Dialect Options} and @ref{Objective-C and Objective-C++ Dialect Options}
で描写されるある言語依存の警告も有効にする。

@option{-Wall}は以下の警告フラグをONにする。

@gccoptlist{-Waddress   
-Warray-bounds=1 @r{(}@option{-O2}@r{のみ)}  
-Wbool-compare  
-Wbool-operation  
-Wc++11-compat  -Wc++14-compat  
-Wcatch-value @r{(C++とObjective-C++のみ)}  
-Wchar-subscripts  
-Wcomment  
-Wduplicate-decl-specifier @r{(CとObjective-Cのみ)} 
-Wenum-compare @r{(C/ObjCで。これはC++ではデフォルトである)} 
-Wformat   
-Wint-in-bool-context  
-Wimplicit @r{(CとObjective-C専用)} 
-Wimplicit-int @r{(CとObjective-C専用)} 
-Wimplicit-function-declaration @r{(CとObjective-C専用)} 
-Winit-self @r{(C++専用)} 
-Wlogical-not-parentheses 
-Wmain @r{(C/ObjCでかつ} @option{-ffreestanding}@r{でないときのみ)}  
-Wmaybe-uninitialized 
-Wmemset-elt-size 
-Wmemset-transposed-args 
-Wmisleading-indentation @r{(C/C++専用)} 
-Wmissing-attributes 
-Wmissing-braces @r{(C/ObjC専用)} 
-Wmultistatement-macros  
-Wnarrowing @r{(C++専用)}  
-Wnonnull  
-Wnonnull-compare  
-Wopenmp-simd 
-Wparentheses  
-Wpointer-sign  
-Wreorder   
-Wrestrict
-Wreturn-type  
-Wsequence-point  
-Wsign-compare @r{(C++専用)}  
-Wsizeof-pointer-div
-Wsizeof-pointer-memaccess 
-Wstrict-aliasing  
-Wstrict-overflow=1
-Wstringop-truncation
-Wswitch  
-Wtautological-compare  
-Wtrigraphs  
-Wuninitialized  
-Wunknown-pragmas  
-Wunused-function  
-Wunused-label     
-Wunused-value     
-Wunused-variable  
-Wvolatile-register-var 
}

ある警告フラグが@option{-Wall}によって含まれないことに注意すべきである。ユーザーが不確かであると一般に思わないが
あなたは時折それについて調べたいかもしれない構造のいくつかも警告する。他のものは
必要であるかあるケースを中で避けることが難しく、警告を抑制するためにコードを修正する簡単な方法がない。
それらの一部は@option{-Wextra}によって使用可能にされるが、それらの多くは個々に使用可能にされなければならない。

@item -Wextra
@opindex W
@opindex Wextra
@opindex Wno-extra
@option{-Wall}で有効にならない追加の警告フラグのいくつかを有効にする。（このオプションはかつては@option{-W}と呼ばれていた。
古い名前はまだ利用可能だが、新しい名前はより描写的である。）

@gccoptlist{-Wclobbered  
-Wcast-function-type 
-Wempty-body  
-Wignored-qualifiers 
-Wimplicit-fallthrough=3 
-Wmissing-field-initializers  
-Wmissing-parameter-type @r{(C専用)}  
-Wold-style-declaration @r{(C専用)}  
-Woverride-init  
-Wsign-compare @r{(C専用)} 
-Wtype-limits  
-Wuninitialized  
-Wshift-negative-value @r{(C++03とC99以降専用)}  
-Wunused-parameter @r{(} @option{-Wunused} @r{および} @option{-Wall}@r{でのみ)} 
-Wunused-but-set-parameter @r{(} @option{-Wunused} @r{および} @option{-Wall}@r{でのみ)}  
}

オプション@option{-Wextra}は以下の場合の警告メッセージも出力する。

@itemize @bullet

@item
ポインタが整数0と@code{<}, @code{<=}, @code{>}, @code{>=}と比較されている。

@item
(C++のみ) 列挙と非列挙が条件式に両方現れる。

@item
(C++のみ) 曖昧な仮想基底。

@item
(C++のみ) @code{register}で宣言された配列の添字

@item
(C++のみ) @code{register}で宣言された変数のアドレス取得

@item
(C++のみ) 導出クラスのコピーコンストラクタで初期化されていない基底クラス

@end itemize

@item -Wchar-subscripts
@opindex Wchar-subscripts
@opindex Wno-char-subscripts
配列の添字が@code{char}ならば警告する。これはプログラマーがこの型がある機種では符号付きであることをしばしば忘れるので
一般的なエラーの原因である。
この警告は@option{-Wall}で有効になる。

@item -Wchkp
@opindex Wchkp
ポインタ境界検査器によって見つかった不正なメモリアクセスについて警告する。
(@option{-fcheck-pointer-bounds}).

@item -Wno-coverage-mismatch
@opindex Wno-coverage-mismatch
フィードバックプロファイルが@option{-fprofile-use}オプションを使った時と一致しない時に警告する。
もしソースファイルが@option{-fprofile-gen}でコンパイルした時と@option{-fprofile-use}で
コンパイルした時で変わっている場合は、プロファイルフィードバックのファイルはソースファイルと
一致することができず、GCCはプロファイルフィードバック情報を使うことができない。
デフォルトでは、この警告は有効でエラーとして扱われる。
@option{-Wno-coverage-mismatch}は警告を無効にするために使うことができ、
@option{-Wno-error=coverage-mismatch}はエラーを無効にするために使うことができる。
この警告のエラーを無効にすると、貧弱な最適化のコードを生成する可能性があり、
既存のコードベースへのバグ修正のようなとても小さな変更の場合のみ有用である。
この警告を完全に無効にすることは勧められない。

@item -Wno-cpp
@r{(C, Objective-C, C++, Objective-C++とFortran専用)}

@code{#warning}ディレクティブによって生成された警告メッセージを抑制する。

@item -Wdouble-promotion @r{(C, C++, Objective-C とObjective-C++専用)}
@opindex Wdouble-promotion
@opindex Wno-double-promotion
@code{float}型の値が暗黙に@code{double}に格上げされるときに警告する。
32ビット「単精度」浮動小数点ユニットがあるCPUはハードウェアで@code{float}を実装するが、
@code{double}をソフトウェアで再現している。そのような機種で、@code{double}値を使った計算は
ソフトウェアエミュレーションで要求されるオーバーヘッドのためにずっと高く付く。

浮動小数点定数が暗黙に型@code{double}であるために、誤って@code{double}で計算するのは容易い。
例えば、

@smallexample
@group
float area(float radius)
@{
   return 3.14159 * radius * radius;
@}
@end group
@end smallexample
はコンパイラは浮動小数点定数が@code{double}であるために、全計算を@code{double}で行う。

@item -Wduplicate-decl-specifier @r{(CとObjective-C専用)}
@opindex Wduplicate-decl-specifier
@opindex Wno-duplicate-decl-specifier
宣言が重複した@code{const}, @code{volatile}, @code{restrict}, @code{_Atomic}指定子を持つなら警告する。
この警告は@option{-Wall}で有効になる。

@item -Wformat
@itemx -Wformat=@var{n}
@opindex Wformat
@opindex Wno-format
@opindex ffreestanding
@opindex fno-builtin
@opindex Wformat=
@code{printf}、@code{scanf}などの呼び出しを検査し、提供された引数が指定されたフォーマット文字列に対して
適切な型であり、フォーマット文字列で指定された規約が意味をなすことを確かめる。これは標準関数と、
他のformat属性(@pxref{Function Attributes})、@code{printf}, @code{scanf}, @code{strftime}, @code{strfmon}
(X/Open拡張でCで標準ではない)ファミリー（および他のターゲット固有のファミリー）が含まれる。
format属性なしでどの関数がチェックされるかは選択された標準バージョンに依存して、指定された属性無しの
そのようなチェックは@option{-ffreestanding}か@option{-fno-builtin}で無効にされる。

GNU libc版2.2によってサポートされるフォーマット機能に対してフォーマットは照合される。これらは、
すべてのISO C90とC99機能を含み、Single Unix SpecificationとあるBSDとGNU拡張からの機能も同様である。
他のライブラリ実装が、すべてのこれらの機能をサポートするというわけではないかもしれない。
特定のライブラリの限界を越える機能について、GCCは警告をサポートしない。
しかし、@option{-Wpedantic}が@option{-Wformat}で使われるならば、選ばれた標準的なバージョンにない
フォーマット機能については警告されない。
（しかし、それらがどんなC標準のバージョンにもないので、@code{strfmon}フォーマットは別である）
 @xref{C Dialect Options,,C変種を制御するオプション}.

@table @gcctabopt
@item -Wformat=1
@itemx -Wformat
@opindex Wformat
@opindex Wformat=1
オプション@option{-Wformat}は@option{-Wformat=1}と等価であり、@option{-Wno-format}は@option{-Wformat=0}と等価である。
@option{-Wformat}はいくつかの関数でnullフォーマット引数の検査も行うので、@option{-Wformat}は@option{-Wnonnull}も含む。
フォーマット・チェックのこのレベルのある側面は、以下のオプションで無効にできる。 @option{-Wno-format-contains-nul},
@option{-Wno-format-extra-args}, @option{-Wno-format-zero-length}。
@option{-Wformat}は@option{-Wall}で有効にされる。

@item -Wno-format-contains-nul
@opindex Wno-format-contains-nul
@opindex Wformat-contains-nul
もし@option{-Wformat}が指定されるならば、NULバイトを含むフォーマット文字列について警告しない。

@item -Wno-format-extra-args
@opindex Wno-format-extra-args
@opindex Wformat-extra-args
もし@option{-Wformat}が指定されるならば、@code{printf}や@code{scanf}への余分な引数について警告しない。C標準は
そのような引数が無視されると指定している。

未使用に引数が@samp{$}オペランド番号指定子で指定された使用された引数の間にあるならば、実装は未使用の引数
を飛ばすために@code{va_arg}へ渡す型を知ることができないため、通常は警告はまだ与えられる。しかし、
@code{scanf}フォーマットの場合は、もしも未使用に引数が全てポインタならば、Single Unix Specificationがそのような未使用の引数を
許しているので、このオプションは警告を抑制する。

@item -Wformat-overflow
@itemx -Wformat-overflow=@var{level}
@opindex Wformat-overflow
@opindex Wno-format-overflow
@code{sprintf}や@code{vsprintf}のような、フォーマットされた入出力関数への呼び出しが、
出力バッファをオーバーフローする可能性があることを警告する。
コンパイル時にformatディレクティブによって書き込まれるバイト数が正確に決まらない場合は、
@var{level}引数と最適化に依存するヒューリスティックに基づいて推定される。
ほとんどの場合、最適化を有効にすると警告の精度が向上するが、誤検出の可能性もある。

@table @gcctabopt
@item -Wformat-overflow
@itemx -Wformat-overflow=1
@opindex Wformat-overflow
@opindex Wno-format-overflow
@option{-Wformat}によって有効にされる@option{-Wformat-overflow}のレベル@var{1}は、
バッファオーバーフローの可能性が最も高いコールについてのみ警告する保守的なアプローチを採用している。
このレベルでは、未知の値を持つ指令ディレクティブの数値引数は1の値を持ち、未知の長さの文字列は空であると仮定される。
それらの型の部分範囲に束縛されていることが知られている数値引数、またはその出力がそのディレクティブの精度か有限の
文字列リテラルのセットによって制限されている文字列引数は、最大のバイトは出力されると仮定される。
たとえば、下の@code{sprintf}の呼び出しは、例え@var{a}と@var{b}の両方が0であっても、
出力バッファへ関数によって加えられる終了NUL文字（@code{'\0'}）が末端を超えているので、診断が行われる。
バッファーオーバーフローを回避するには十分ではないかもしれないが、
警告を回避するにはバッファのサイズを1バイト増やすだけで十分である。

@smallexample
void f (int a, int b)
@{
  char buf [13];
  sprintf (buf, "a = %i, b = %i\n", a, b);
@}
@end smallexample

@item -Wformat-overflow=2
レベル@var{2}は、十分な長さまたは大きさの引数を与えられたときに出力バッファをオーバーフローさせる可能性のある
コールについても警告する。レベル@var{2}では、未知の数値引数は、精度が1より大きい符号付き型の場合は
表現可能な最小値をとり、それ以外の場合は表現可能な最大値を持つものとみなされる。
その長さがディレクティブの精度、及び評価されるかもしれない文字列リテラル及び指し示している文字配列の有限集合によって制限されない
未知の文字列引数は、1文字長と仮定される。

レベル@var{2}では、上の例の呼び出しが再度診断されるが、今回は、@var{a}が32ビットの@code{INT_MIN}に等しいので、
最初の@code{％i}ディレクティブは出力バッファの末尾を越えていくつかの数字を書く。
2つの変数の値にかかわらず呼び出しを安全にするには、宛先バッファのサイズを少なくとも34バイトに増やす必要がある。
GCCは、警告に続く情報ノート内のバッファの最小サイズが含まれている。

出力バッファのサイズを増やすことの代替手段は、書式化される値の範囲を制限することである。
文字列引数の最大長はフォーマットディレクティブでの精度を指定することで制限される。
フォーマットディレクティブの数値引数がその型の精度未満で制限されていると仮定で切る時は、
フォーマット指定子に適切な長さ指定子を選ぶことで、必要なバッファサイズを減らすだろう。
例えば、もし上の例の@var{a}と@var{b}が@code{short int}型の範囲内であると仮定できるなら、
@code{%hi}フォーマットディレクティブを使うか引数を@code{short}にキャストすることで
要求される最大サイズを24バイトへと減らす。

@smallexample
void f (int a, int b)
@{
  char buf [23];
  sprintf (buf, "a = %hi, b = %i\n", a, (short)b);
@}
@end smallexample
@end table

@item -Wno-format-zero-length
@opindex Wno-format-zero-length
@opindex Wformat-zero-length
もし@option{-Wformat}が指定されるならば、ゼロ長フォーマットについて警告しない。Cの標準はゼロ長フォーマットが許されると
指定している。


@item -Wformat=2
@opindex Wformat=2
@option{-Wformat}への追加のフォーマットチェックの追加を有効にする。現在は、
@option{-Wformat -Wformat-nonliteral -Wformat-security -Wformat-y2k}と等価である。

@item -Wformat-nonliteral
@opindex Wformat-nonliteral
@opindex Wno-format-nonliteral
もし@option{-Wformat}が指定されたら、フォーマット関数が@code{va_list}としてフォーマット引数を取るのでない限り、
フォーマット文字列が文字列定数でなく、チェックできない時に警告する。

@item -Wformat-security
@opindex Wformat-security
@opindex Wno-format-security
もし@option{-Wformat}が指定されたら、セキュリティー問題の可能性があるフォーマット関数の使用についても警告する。
現在、これは@code{printf (foo);}のようにフォーマットもじれうtが文字列定数でなく、フォーマット引数がない@code{printf}および
@code{scanf}関数の呼び出しについて警告する。これはフォーマット文字列は信頼出来ない入力から来た文字列で@samp{%n}を含むならば
セキュリティホールとなるかもしれない。（これは現在@option{-Wformat-nonliteral}が警告するものの部分集合だが、将来の警告では
@option{-Wformat-nonliteral}に含まれないものが@option{-Wformat-security}へ加えられるかもしれない。

@item -Wformat-signedness
@opindex Wformat-signedness
@opindex Wno-format-signedness
もし@option{-Wformat}が指定されたら、フォーマット文字列が符号なしを要求していて、引数が符号付きであるか、その逆の時にも警告する。

@item -Wformat-truncation
@itemx -Wformat-truncation=@var{level}
@opindex Wformat-truncation
@opindex Wno-format-truncation
@code{snprintf}と@code{vsnprintf}のような書式化入出力関数の呼び出しが出力を切り詰めるかもしれない時に警告する。
フォーマットディレクティブによって書かれる正確なバイト数がコンパイル時に決定できない時は、
@var{level}引数と最適化に依存したヒューリスティックによって推測される。
最適化を有効にしたときには大抵の場合に警告の正確さが向上するが、偽の警告も出すかもしれない。他で指摘したことを除いて、
このオプションは@option{-Wformat-overflow}と同じ論理を使う。

@table @gcctabopt
@item -Wformat-truncation
@itemx -Wformat-truncation=1
@opindex Wformat-truncation
@opindex Wno-format-overflow
@option{-Wformat}によって有効にされる@option{-Wformat-truncation}のレベル@var{1}は、
戻り値が未使用で大抵の場合に出力の切り詰めが起こるであろう制限された関数への呼び出しについてのみ警告する
保守的なアプローチを採用している。

@item -Wformat-truncation=2
レベル@var{2}は戻り値が使われて、十分な長さまたは大きさの引数が与えられた場合に切り捨てられる可能性がある、
境界付き関数への呼び出しについても警告する。
@end table

@item -Wformat-y2k
@opindex Wformat-y2k
@opindex Wno-format-y2k
もし@option{-Wformat}が指定されたら、数字2つの年のみを生成する@code{strftime}書式についても警告する。
@end table

@item -Wnonnull
@opindex Wnonnull
@opindex Wno-nonnull
@code{nonnull}関数属性によって非nullを要求するようにマークされている引数にnullポインタを渡すことについて警告する。

@option{-Wnonnull}は@option{-Wall}と@option{-Wformat}に含まれている。@option{-Wno-nonnull}オプションで無効にできる。

@item -Wnonnull-compare
@opindex Wnonnull-compare
@opindex Wno-nonnull-compare
@code{nonnull}関数属性でマークされた引数とnullをその関数内で比較すると警告する。

@option{-Wnonnull-compare}は@option{-Wall}に含まれる。@option{-Wno-nonnull-compare}で無効にできる。

@item -Wnull-dereference
@opindex Wnull-dereference
@opindex Wno-null-dereference
コンパイラがnullポインタの参照剥がしのためにエラーか未定義の振る舞いを引き起こす経路を探知した時に警告する。
このオプションは@option{-fdelete-null-pointer-checks}が活性の時だけ活性で、多くのターゲットで最適化が有効の時である。
この警告の精度はオプションが使われた最適化に依存する。

@item -Winit-self @r{(C, C++, Objective-C, Objective-C++専用)}
@opindex Winit-self
@opindex Wno-init-self
自分自身で初期化された未初期化の変数について警告する。このオプションは@option{-Wuninitialized}オプションと一緒にだけ使うことができる。

例えば、GCCは@option{-Winit-self}が指定された時だけ以下の断片で未初期化の@code{i}について警告する。
@smallexample
@group
int f()
@{
  int i = i;
  return i;
@}
@end group
@end smallexample

この警告はC++では@option{-Wall}で有効である。

@item -Wimplicit-int @r{(CとObjective-C専用)}
@opindex Wimplicit-int
@opindex Wno-implicit-int
宣言が型を指定しない場合に警告する。この警告は@option{-Wall}で有効である。

@item -Wimplicit-function-declaration @r{(CとObjective-C専用)}
@opindex Wimplicit-function-declaration
@opindex Wno-implicit-function-declaration
関数が宣言される前に使われた時に警告する。C99モード(@option{-std=c99}か@option{-std=gnu99})では、
この警告はデフォルトで有効で、@option{-pedantic-errors}でエラーになる。この警告は@option{-Wall}でも有効になる。

@item -Wimplicit @r{(CとObjective-C専用)}
@opindex Wimplicit
@opindex Wno-implicit
@option{-Wimplicit-int}と@option{-Wimplicit-function-declaration}と同じである。
この警告は@option{-Wall}で有効になる。

@item -Wimplicit-fallthrough
@opindex Wimplicit-fallthrough
@opindex Wno-implicit-fallthrough
@option{-Wimplicit-fallthrough}は@option{-Wimplicit-fallthrough=3}と同じであり、
@option{-Wno-implicit-fallthrough}は@option{-Wimplicit-fallthrough=0}と同じである。

@item -Wimplicit-fallthrough=@var{n}
@opindex Wimplicit-fallthrough=
switchのcaseで下へ落下(fall-through)したときの警告する。例えば、

@smallexample
@group
switch (cond)
  @{
  case 1:
    a = 1;
    break;
  case 2:
    a = 2;
  case 3:
    a = 3;
    break;
  @}
@end group
@end smallexample

この警告はcaseの最後の文が下へ落下できないとき、例えば、return文かnoreturn属性で宣言された
関数への呼び出しのときには警告しない。@option{-Wimplicit-fallthrough=}
は制御フロー文、例えばif、も考慮し、適切なときのみ警告する。例えば、

@smallexample
@group
switch (cond)
  @{
  case 1:
    if (i > 3) @{
      bar (5);
      break;
    @} else if (i < 1) @{
      bar (0);
    @} else
      return;
  default:
    @dots{}
  @}
@end group
@end smallexample

switch caseの下への落下が望ましい場合もあるので、GCCは属性@code{__attribute__ ((fallthrough))}
を提供し、それは通常起こる警告を抑制するために空文と一緒に使われる。

@smallexample
@group
switch (cond)
  @{
  case 1:
    bar (0);
    __attribute__ ((fallthrough));
  default:
    @dots{}
  @}
@end group
@end smallexample

C++17ではGNU属性の代わりに、@code{[[fallthrough]];}を使って@option{-Wimplicit-fallthrough}警告
抑制する標準の方法が存在する。C++11およびC++14のユーザはGNU拡張である@code{[[gnu::fallthrough]];}
を使うことができる。これらの属性の代わりに、フォールスルー・コメントを追加して警告を抑止することもできる。 CまたはC++形式のコメントの本文は、以下に示す正規表現と一致する必要がある。 オプション引数@var{n}は、どのようなコメントが受け入れられるかを指定する：

@itemize @bullet

@item @option{-Wimplicit-fallthrough=0}は警告完全に無効にする

@item @option{-Wimplicit-fallthrough=1}は@code{.*}正規表現の一致し、
どんなコメントも落下コメントとして使うことができる

@item @option{-Wimplicit-fallthrough=2}は大文字小文字を無視して正規表現@code{.*falls?[ \t-]*thr(ough|u).*}
に一致する

@item @option{-Wimplicit-fallthrough=3}は大文字小文字を区別して以下の正規表現のどれかに一致する。

@itemize @bullet

@item @code{-fallthrough}

@item @code{@@fallthrough@@}

@item @code{lint -fallthrough[ \t]*}

@item @code{[ \t.!]*(ELSE,? |INTENTIONAL(LY)? )?@*FALL(S | |-)?THR(OUGH|U)[ \t.!]*(-[^\n\r]*)?}

@item @code{[ \t.!]*(Else,? |Intentional(ly)? )?@*Fall((s | |-)[Tt]|t)hr(ough|u)[ \t.!]*(-[^\n\r]*)?}

@item @code{[ \t.!]*([Ee]lse,? |[Ii]ntentional(ly)? )?@*fall(s | |-)?thr(ough|u)[ \t.!]*(-[^\n\r]*)?}

@end itemize

@item @option{-Wimplicit-fallthrough=4}は大文字小文字を区別して、以下の正規表現のどれかに一致する

@itemize @bullet

@item @code{-fallthrough}

@item @code{@@fallthrough@@}

@item @code{lint -fallthrough[ \t]*}

@item @code{[ \t]*FALLTHR(OUGH|U)[ \t]*}

@end itemize

@item @option{-Wimplicit-fallthrough=5}はどんなコメントも落下コメントとして認識せずに、
属性のみが警告を無効にする。

@end itemize


@code{case}や@code{default}のキーワードや、@code{case}や@code{default}のラベルに先行するユーザのラベルによって、
コメントはオプションの空白やその他のコメントの後に続く必要がある。

@smallexample
@group
switch (cond)
  @{
  case 1:
    bar (0);
    /* FALLTHRU */
  default:
    @dots{}
  @}
@end group
@end smallexample

The @option{-Wimplicit-fallthrough=3}警告は@option{-Wextra}によって有効になる。

@item -Wif-not-aligned @r{(C, C++, Objective-C, Objective-C++のみ)}
@opindex Wif-not-aligned
@opindex Wno-if-not-aligned
@code{warn_if_not_aligned}属性によってトリガされる警告を発行するかどうかを制御する。 これはデフォルトで有効になっている。 無効にするには、@option{-Word-aligned not-aligned}を使用する。

@item -Wignored-qualifiers @r{(CとC++専用)}
@opindex Wignored-qualifiers
@opindex Wno-ignored-qualifiers
関数の戻り値が@code{const}のような型修飾子を持つなら警告する。ISO Cでは関数の戻り値は左辺値ではないので
そのような型修飾子には意味が無い。C++では、警告はスカラ型か@code{void}の時だけ発せられる。
ISO Cは関数定義で修飾された@code{void}戻り型を禁じているため、このオプション無しでもそのような戻り型はいつも警告を受ける。

この警告は@option{-Wextra}でも有効になる。

@item -Wignored-attributes @r{(CとC++専用)}
@opindex Wignored-attributes
@opindex Wno-ignored-attributes
属性が無視された時に警告する。これはコンパイラが属性を外すように決定したとき警告し、
属性が未知であるか、間違った場所で使われた時などではないことで@option{-Wattributes}とは異なる。これはデフォルトで有効である。

@item -Wmain
@opindex Wmain
@opindex Wno-main
@code{main}の型が疑わしいならば警告する。@code{main}は外部リンケージを持ち、intを返し、引数は適切な型の0、2、3個のどれかであるべきである。
この警告はC++ではデフォルトで有効で、@option{-Wall}か@option{-Wpedantic}のどちらかによって有効である。

@item -Wmisleading-indentation @r{(CとC++専用)}
@opindex Wmisleading-indentation
@opindex Wno-misleading-indentation
コードのインデントがブロック構造を反映していない時に警告する。特に、中括弧を使っていないガード文の@code{if}、@code{else}、@code{while}、@code{for}節に、
同じインデントの非ガード文が続く場合に警告する。

以下の例で、「bar」への呼び出しは「if」条件でガードされているかのように誤解を招くインデントをしている。

@smallexample
  if (some_condition ())
    foo ();
    bar ();  /* おっと、これは「if」でガードされていない  */
@end smallexample

タブとスペースが混合されている場合、警告は文が整列しているかどうかを決定するために@option{-ftabstop=}オプションを使う。（デフォルトは8）

警告は以下の例のような複数行プリプロセスロジックが関与している場合には警告しない。

@smallexample
  if (flagA)
    foo (0);
#if SOME_CONDITION_THAT_DOES_NOT_HOLD
  if (flagB)
#endif
    foo (1);
@end smallexample

警告は、@code{#line}ディレクトティブの後ろでは、それが典型的には自動生成されたコードを示し、
ディレクティブが参照するファイルのレイアウトについてのなんの仮定もできないために、警告は発せられない。

この警告はCとC++では@option{-Wall}で有効である。

@item -Wmissing-attributes
@opindex Wmissing-attributes
@opindex Wno-missing-attributes
Warn when a declaration of a function is missing one or more attributes
that a related function is declared with and whose absence may adversely
affect the correctness or efficiency of generated code.  For example, in
C++, the warning is issued when an explicit specialization of a primary
template declared with attribute @code{alloc_align}, @code{alloc_size},
@code{assume_aligned}, @code{format}, @code{format_arg}, @code{malloc},
or @code{nonnull} is declared without it.  Attributes @code{deprecated},
@code{error}, and @code{warning} suppress the warning.
(@pxref{Function Attributes}).

@option{-Wmissing-attributes} is enabled by @option{-Wall}.

For example, since the declaration of the primary function template
below makes use of both attribute @code{malloc} and @code{alloc_size}
the declaration of the explicit specialization of the template is
diagnosed because it is missing one of the attributes.

@smallexample
template <class T>
T* __attribute__ ((malloc, alloc_size (1)))
allocate (size_t);

template <>
void* __attribute__ ((malloc))   // missing alloc_size
allocate<void> (size_t);
@end smallexample

@item -Wmissing-braces
@opindex Wmissing-braces
@opindex Wno-missing-braces
集合か共用体初期化子が完全に括弧付けしていない場合に警告する。以下の例では、@code{a}は完全に括弧付けしていないが、
@code{b}は完全に括弧付けされている。この警告はCでは@option{-Wall}で有効である。

@smallexample
int a[2][2] = @{ 0, 1, 2, 3 @};
int b[2][2] = @{ @{ 0, 1 @}, @{ 2, 3 @} @};
@end smallexample

この警告は@option{-Wall}で有効である。

@item -Wmissing-include-dirs @r{(C、C++、Objective-C、Objective-C++専用)}
@opindex Wmissing-include-dirs
@opindex Wno-missing-include-dirs
ユーザの提供したincludeディレクトリが存在しない時警告する。

@item -Wmultistatement-macros
@opindex Wmultistatement-macros
@opindex Wno-multistatement-macros
Warn about unsafe multiple statement macros that appear to be guarded
by a clause such as @code{if}, @code{else}, @code{for}, @code{switch}, or
@code{while}, in which only the first statement is actually guarded after
the macro is expanded.

For example:

@smallexample
#define DOIT x++; y++
if (c)
  DOIT;
@end smallexample

will increment @code{y} unconditionally, not just when @code{c} holds.
The can usually be fixed by wrapping the macro in a do-while loop:
@smallexample
#define DOIT do @{ x++; y++; @} while (0)
if (c)
  DOIT;
@end smallexample

This warning is enabled by @option{-Wall} in C and C++.

@item -Wparentheses
@opindex Wparentheses
@opindex Wno-parentheses
真偽値が来た逸される文脈での代入、演算子が人々がしばしば混乱する優先順位で入れ子になっているなどのような文脈で、
括弧が省略されている場合に警告する。

@code{x<=t<=x}のような比較でも警告する。これは@code{x<=y ? 1 : 0) <= z}と等価であり、一般的な数学の表記の解釈とは異なる。

@code{?:}の第2項を省略するGNU拡張の危険な使い方も警告する。@code{?:}演算子の条件が真偽値の場合は、
省略された値は常に１である。しばしばプログラマは代わりに条件節内部で計算された値であることを期待する。

C ++の場合、宣言で不要なかっこのいくつかの場合に警告される。これは宣言ではなく、関数呼び出しの試みを示しうる。

@smallexample
@{
  // Declares a local variable called mymutex.
  std::unique_lock<std::mutex> (mymutex);
  // User meant std::unique_lock<std::mutex> lock (mymutex);
@}
@end smallexample


この警告は@option{-Wall}で有効になる。

@item -Wsequence-point
@opindex Wsequence-point
@opindex Wno-sequence-point
CとC++標準の副作用完了点規則違反のために未定義の意味を持つかもしれないコードについて警告する。

CとC++標準はプログラムの部分の実行間の部分順序を表現する、@dfn{副作用完了点}の用語で、C/C++プログラムで
どの式が実行されるかの順番を定義している。副作用完了点の前に実行されるものと、その後に実行されるもの。
それらは完全式（より大きな式の一部でないもの）の実行の後、@code{%%}, @code{||}, @code{? :}, @code{,}(コンマ)演算子の後、
関数呼び出しの前（しかし、引数と呼ぶ関数を生成する式の後）、他の幾つかの場所の後である。
副作用完了点規則で表現されたものの他には、表現の部分式の評価の順序は、指定されない。すべてのこれらの規則は完全な順序ではなく
部分的な順序だけを記述し、例えば、2つの関数がそれらの間で副作用完了点がない一つの式内で呼ばれるならば、関数が呼ばれる順序は指定されない。
しかし、標準委員会は、関数呼び出しが重ならないと決定した。

オブジェクトの値への修正がいつシーケンス点の間で実施されるかは指定されない。ふるまいがこれに依存するプログラムは、未定義ふるまいをする;
「前で次の副作用完了点の間で、オブジェクトはその保存された値を式の評価によって最高でも一度だけ修正する。さらに古い値は、
格納される値を決定するためだけに読まれる」ことを、CとC++標準は、示している。プログラムがこれらの規則を破るならば、
どんな特定の実装の結果でもまったく予測できない。

未定義の振る舞いのコードの例は、@code{a = a++;}, @code{a[n] = b[n++]}, @code{a[i++] = i;}などである。
もっと複雑なあるケースはこのオプションによって診断されず、それは時折の偽陽性結果を与えるかもしれないが、
一般に、プログラムでこの種類の問題を見つけることでかなり効果的であるとわかった。

C++17標準は大抵の場合でのオペランドの評価の順序を定義する予定である。特に、代入の右辺値は左辺値より前に
評価されることを要求するので、上の例はもはや未定義ではない。しかし、この警告は、人々がCとC++の以前の版で未定義である
コード書くのを避けるのを避けるためにまだ警告するだろう。

標準は紛らわしく言い表される、したがって、副作用完了点規則の正確な意味についてのある議論が微妙なケースにある。
@uref{http://gcc.gnu.org/@/readings.html}でのGCCの読本ページで、問題（提案された正式な定義を含む）に関する議論との関連は見つかるかもしれない

この警告はCとC++で@option{-Wall}で有効である。

@item -Wno-return-local-addr
@opindex Wno-return-local-addr
@opindex Wreturn-local-addr
関数が帰ったあとでスコープから出るポインタ（およびC++での参照）を返すことについて警告しない。

@item -Wreturn-type
@opindex Wreturn-type
@opindex Wno-return-type
関数が戻り値がデフォルトの@code{int}で定義されていると警告する。戻り値型が@code{void}でない関数で
の戻り値なしの@code{return}文（関数の本体の最後で抜けるのは戻り値なしで返るとみなされる）も警告する。

Cのみでは、戻り型が@code{void}である関数内の式つきの@code{return}文を、式の型も@code{void}出ない限りは
蛍光する。GNU拡張として、後者の場合は@option{-Wpedantic}が使われない限り警告なしで受理される。

C++では、@option{-Wno-return-type}が指定された時でも、戻り値型のない関数は常に診断を生成する。
唯一の例外は@code{main}とシステムヘッダで定義された関数である。

この警告はC++ではデフォルトで有効であり、@option{-Wall}で有効になる。

@item -Wshift-count-negative
@opindex Wshift-count-negative
@opindex Wno-shift-count-negative
シフト数が負ならば警告する。この警告はデフォルトで有効である。

@item -Wshift-count-overflow
@opindex Wshift-count-overflow
@opindex Wno-shift-count-overflow
シフト数が型の幅以上ならば警告する。この警告はデフォルトで有効である。

@item -Wshift-negative-value
@opindex Wshift-negative-value
@opindex Wno-shift-negative-value
負数を左シフトすると警告する。この警告はC99とC++11モード（以降）で@option{-Wextra}で有効である。

@item -Wshift-overflow
@itemx -Wshift-overflow=@var{n}
@opindex Wshift-overflow
@opindex Wno-shift-overflow
左シフトオーバーフローについて警告する。これはC99とC++11モード（以降）でデフォルトで有効である。

@table @gcctabopt
@item -Wshift-overflow=1
これは@option{-Wshift-overflow}の警告レベルであり、C99とC++11モード（以降）ではデフォルトで有効である。
この傾向レベルは符号ビットへの左１シフトについて警告しない。（しかし、C99では整数定数式が要求される文脈では
依然としてそのようなオーバーフローは拒絶される）

@item -Wshift-overflow=2
これはC++14モードがアクティブでないかぎりは、符号ビットへの左１シフトについても警告する。
@end table

@item -Wswitch
@opindex Wswitch
@opindex Wno-switch
@code{switch}文が列挙型の添字を持ち、列挙の名前付きコードの１つ以上の@code{case}が欠けていると警告する。
（@code{default}ラベルがあるとこの警告を出さない）列挙範囲の外側の@code{vase}ラベルもこのオプションが使われた時には
（@code{default}ラベルがあったとしても）警告を出す。
この警告は@option{-Wall}で有効である。

@item -Wswitch-default
@opindex Wswitch-default
@opindex Wno-switch-default
@code{switch}文が@code{default}の場合がない場合にいつも警告する。

@item -Wswitch-enum
@opindex Wswitch-enum
@opindex Wno-switch-enum
@code{switch}文が列挙型の添字を持ち、列挙の名前付きの１つ以上の@code{case}が欠けている時にいつも警告する。
このオプションが使われた時は列挙範囲の外の@code{case}ラベルも警告を発する。このオプションと@option{-Wswitch}との唯一の違いは
たとえ@code{default}ラベルがあったとしても省略された列挙コードの警告を発することである。

@item -Wswitch-bool
@opindex Wswitch-bool
@opindex Wno-switch-bool
@code{switch}文が真偽値型の添字を取り、ケース値が真偽値の範囲外の場合にいつも警告する。@code{bool}以外の型へ条件式をキャスト
することでこの警告を抑制できる。例えば、
@smallexample
@group
switch ((int) (a == 4))
  @{
  @dots{}
  @}
@end group
@end smallexample
この警告はCとC++をプログラムでデフォルトで有効である。

@item -Wswitch-unreachable
@opindex Wswitch-unreachable
@opindex Wno-switch-unreachable
@code{switch}文が制御式と最初のcaseラベルの間に文を含むときに警告する。それは決して実行されない。
例えば、
@smallexample
@group
switch (cond)
  @{
   i = 15;
  @dots{}
   case 5:
  @dots{}
  @}
@end group
@end smallexample
@option{-Wswitch-unreachable}は制御式と最初のcaseラベルの間の文が単なる宣言の場合には警告しない。
@smallexample
@group
switch (cond)
  @{
   int i;
  @dots{}
   case 5:
   i = 5;
  @dots{}
  @}
@end group
@end smallexample
この警告はCとC++プログラムではデフォルで有効である。

@item -Wsync-nand @r{(CとC++専用)}
@opindex Wsync-nand
@opindex Wno-sync-nand
@code{__sync_fetch_and_nand}と@code{__sync_nand_and_fetch}組み込み関数が使われた時に警告する。これらの関数はGCC4.4で意味が変わった。

@item -Wunused-but-set-parameter
@opindex Wunused-but-set-parameter
@opindex Wno-unused-but-set-parameter
代入されたが、（宣言の他に）他の場所で使われていない関数パラメータについて警告する。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

この警告は@option{-Wextra}と一緒の@option{-Wunused}で有効である。


@item -Wunused-but-set-variable
@opindex Wunused-but-set-variable
@opindex Wno-unused-but-set-variable
局所変数が代入されたが、（宣言の他に）他の場所で使われていないと警告する。
この警告は@option{-Wall}で有効である。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

この警告は@option{-Wunused}で有効であり、それは@option{-Wall}で有効になる。

@item -Wunused-function
@opindex Wunused-function
@opindex Wno-unused-function
静的関数が宣言されたが定義されていないか、非インラインの静的関数が使われていない時に警告する。
この警告は@option{-Wall}で有効である。

@item -Wunused-label
@opindex Wunused-label
@opindex Wno-unused-label
ラベルが宣言されたが使われていない時に警告する。
この警告は@option{-Wall}で有効である。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@item -Wunused-local-typedefs @r{(C, Objective-C, C++, Objective-C++専用)}
@opindex Wunused-local-typedefs
typedefが関数内で局所的に宣言されたが使われていない時に警告する。
この警告は@option{-Wall}で有効である。

@item -Wunused-parameter
@opindex Wunused-parameter
@opindex Wno-unused-parameter
関数パラメータが宣言の他には使われていない時に警告する。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@item -Wno-unused-result
@opindex Wunused-result
@opindex Wno-unused-result
@code{warn_unused_result} (@pxref{Function Attributes})属性をマークされた
関数の呼び出し元で戻り値が使われていない時に警告しない。デフォルトは@option{-Wunused-result}である。

@item -Wunused-variable
@opindex Wunused-variable
@opindex Wno-unused-variable
局所か静的変数が宣言の他に使われていない時に警告する。これはCでは@option{-Wunused-const-variable=1}を含むが
C++では含まない。この警告は@option{-Wall}で有効になる。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@item -Wunused-const-variable
@itemx -Wunused-const-variable=@var{n}
@opindex Wunused-const-variable
@opindex Wno-unused-const-variable
定数静的変数が宣言の他に使われていない時にいつも警告する。@option{-Wunused-const-variable=1}は
Cでは@option{-Wunused-variable}の時に有効であるが、C++では異なる。Cではこれは変数領域を宣言するが、
C++では定数変数が@code{#define}を置き換えたのｄエラーではない。

この警告を抑制するには@code{unused}属性(@pxref{Variable Attributes})を使う。

@table @gcctabopt
@item -Wunused-const-variable=1
これはCでは@option{-Wunused-variable}によって有効にされる警告レベルである。
主要コンパイル単位で定義された未使用の静的定数変数についてのみ警告し、includeされたヘッダ
で宣言された静的定数変数は警告しない。

@item -Wunused-const-variable=2
これはヘッダ（システムヘッダを除く）で宣言された未使用の定数静的変数にも警告する。これは
@option{-Wunused-const-variable}の警告レベルであり、C++ではエラーではなく、
Cでも含まれる全てのヘッダを掃除するのは困難なので明示的に要求しなければならない。
@end table

@item -Wunused-value
@opindex Wunused-value
@opindex Wno-unused-value
式が明示的に使われていない結果しているときにいつも警告する。この警告を抑制するには
未使用の式を@code{void}にキャストする。これは式文と、副作用を持たないコンマ式の左辺を含む。
例えば、@code{x[i,j]}のような式は警告を発するが、@code{x[(void)i,j]}はしない。

この警告は@option{-Wall}で有効になる。

@item -Wunused
@opindex Wunused
@opindex Wno-unused
上の全ての@option{-Wunused}オプションを組み合わせる。

未使用の関数パラメータについて警告するには、@option{-Wextra -Wunused}を指定するか、
（@option{-Wall}は@option{-Wunused}を含む）、別に@option{-Wunused-parameter}を指定する。

@item -Wuninitialized
@opindex Wuninitialized
@opindex Wno-uninitialized
自動変数が最初に初期化されずに使われるか、変数が@code{setjmp}の呼び出しで破壊されるかも知れない
時に警告する。C++では、非静的参照か非静的@code{const}メンバがコンストラクタのないクラスに
現れるときに警告する。

もし変数の未初期化値を初期化子で使うコードについて警告したいなら、@option{-Winit-self}オプション
を使う。

これらの警告は全体として未初期化・破壊される変数と同様に、構造体、共用体、配列変数の個々の
未初期化・破壊される要素にも起こる。@code{volatile}と宣言されている変数や要素には起こらない。
それらの警告は最適化に依存しているので、警告が起こる正確な変数および要素は正確な最適化オプションと
使われたGCCはのバージョンに依存する。

計算に使われるがそれ自身は一度も使われない変数は、そのような計算が警告が出力される前にデータフロー解析で
削除されるかもしれないため、警告されないかもしれないことに注意する。

@item -Winvalid-memory-model
@opindex Winvalid-memory-model
@opindex Wno-invalid-memory-model
操作が無効であるか@code{memory_order}列挙の値の範囲外であるメモリ一貫性引数を持つ
@ref{__atomic Builtins}, @ref{__sync Builtins}の呼び出しと、C11アトミック汎用関数を警告する。
例えば、@code{__atomic_store} and @code{__atomic_store_n}組み込みはリラックス、リリース、
経時的に一貫性のメモリ順序で定義されているので、以下のコードは診断される。

@smallexample
void store (int *i)
@{
  __atomic_store_n (i, 0, memory_order_consume);
@}
@end smallexample

@option{-Winvalid-memory-model}はデフォルトで有効である。

@item -Wmaybe-uninitialized
@opindex Wmaybe-uninitialized
@opindex Wno-maybe-uninitialized
自動(すなわち、ローカル）変数で、関数の入り口から初期化されている変数の使用までの経路があるが、変数が初期化されない
他の経路があるならば、コンパイラは未初期化の経路が実行時に実行されないことが証明できないならば警告を発する。

これらの警告は最適化コンパイルでのみ可能である。なぜならさもなければGCCはは変数の状態を追わないからである。

これらの警告はGCCがコードがエラーに見えるがコードが正しいかもしれない理由全てを見れるほど賢くないので、オプションである。ここでこれが起こる一つの例がある。

@smallexample
@group
@{
  int x;
  switch (y)
    @{
    case 1: x = 1;
      break;
    case 2: x = 4;
      break;
    case 3: x = 5;
    @}
  foo (x);
@}
@end group
@end smallexample

@noindent
もし@code{y}の値が常に1, 2, 3のどれかならば、@code{x}は常に初期化されるが、GCCは知ることができない。
警告を抑制するためには、assert(0)か同等のdefaultケースを提供する必要がある。

@cindex @code{longjmp} warnings
このオプションは非volatileの自動変数が@code{longjmp}への呼び出しで変更されるかもしれないときにも警告する。
コンパイラは@code{setjmp}への呼び出しのみが見える。どこで@code{longjmp}が呼ばれるかを知ることができない。
実際、シグナルハンドラはコードの任意の点で呼びうる。結果として、@code{longjmp}が実際には問題を起こす
場所で呼ぶことができないので問題がないときでも警告を得るかもしれない。

いくつかの疑わしい警告は使う全ての決して返らない関数を@code{noreturn}と宣言すれば避けることができる。
@xref{Function Attributes}.

この警告は@option{-Wall}か@option{-Wextra}で有効になる。

@item -Wunknown-pragmas
@opindex Wunknown-pragmas
@opindex Wno-unknown-pragmas
@cindex warning for unknown pragmas
@cindex unknown pragmas, warning
@cindex pragmas, warning of unknown
GCCが理解できない@code{#pragma}ディレクティブに出会ったら警告する。もしこのコマンドラインオプション
が使われたら、システムヘッダファイルの未知のプラグまでも警告を出す。これは@option{-Wall}コマンドラインオプション
によってのみ有効になるケースとは異なる。

@item -Wno-pragmas
@opindex Wno-pragmas
@opindex Wpragmas
正しくないパラメータ、不正の構文、プラグマ間の矛盾のようなプラグマの不正利用について警告しない。
@option{-Wunknown-pragmas}.

@item -Wstrict-aliasing
@opindex Wstrict-aliasing
@opindex Wno-strict-aliasing
このオプションは@option{-fstrict-aliasing}が有効の時だけ有効である。
コンパイラが最適化に使う厳密なエイリアス規則を破るかもしれないコードについて警告する。
警告は全場合を捕まえるわけではないが、より多くの一般的な落とし穴を捕まえようとする。
これは@option{-Wall}に含まれている。

これは@option{-Wstrict-aliasing=3}と等価である。

@item -Wstrict-aliasing=n
@opindex Wstrict-aliasing=n
このオプションは@option{-fstrict-aliasing}が有効の時だけ有効である。
コンパイラが最適化に使う厳密なエイリアス規則を破るかもしれないコードについて警告する。
高いレベルは高い正確性（より少ない偽陽性）に対応している。高いレベルはより多くの努力にも対応し、
@option{-O}と同様の働きをする。
@option{-Wstrict-aliasing}は@option{-Wstrict-aliasing=3}と等価である。

レベル１：最も積極的で、素早く、最も正確でない。
最も少ない偽陰性なので、高いレベルが警告しないが@option{-fstrict-aliasing}がまだコードを壊す場合に
多分役立つ。しかし、多数の偽陽性を持つ。
非互換の可能性のある型同士の全てのポインタ変換、たとえ一度も被参照されなくても警告する。フロントエンドのみで動く。

レベル２：積極的で、素早く、あまり正確でない。
まだ多くの偽陽性があるかもしれない（しかしレベル１ほどではない）。偽陰性は少ない（しかし多分レベル１よりは多い）。
レベル１とは異なり、アドレスが取れらた場所でのみ警告する。非完全型について警告する。フロントエンドのみで動く。

レベル３（@option{-Wstrict-aliasing}のデフォルト）：
偽陽性がとても少なく、偽陰性も少ないはずである。最適化が有効になっている時はレベル１、２よりもかなり遅い。
フロントエンドで共通の別名化＋被参照パターンの場合を拾う。@code{*(int*)&some_float}。
最適化が有効ならば、バックエンドでも動き、フロー依存の点への情報を使って複数の分の場合を扱う。
変換されたポインタが被参照された場合のみ警告する。
非完全型には警告しない。

@item -Wstrict-overflow
@itemx -Wstrict-overflow=@var{n}
@opindex Wstrict-overflow
@opindex Wno-strict-overflow
このオプションは符号付きの桁溢れが未定義の場合のみ有効である。コンパイラが符号付き桁溢れが
起こらないと仮定して最適化した場合について警告する。コードが桁溢れするかもしれない場所全てを警告するわけではない
ことに注意する。コンパイラが最適化を実装している場所のケースのみを警告する。したがってこの警告は最適化レベル
に依存する。

符号つき桁溢れが起こらないという過程する最適化はもし関与した変数の値は実際に決して桁溢れを起こさないならば
完全に安全である。したがってこの警告は容易に偽陽性を与えうる。実際には問題ではないコードの警告。
重要な問題に集中するのを助けるために、いくつかの警告レベルが定義されている。ループが何回回るか見積もる時の
未定義の符号付き桁溢れは、時にループがそもそも事項するかどうかを判断する時は警告しない。

@table @gcctabopt
@item -Wstrict-overflow=1
疑わしく、かつ安易に避けられる場合について警告する。例えば、
@code{x + 1 > x}を@code{1}に単純化する。この@option{-Wstrict-overflow}のレベルは
は@option{-Wall}で有効になる。より高いレベルは有効にならないので、明示的に要求しなければならない。

@item -Wstrict-overflow=2
比較が定数へと単純化される場所の他のケースで警告する。例えば、@code{abs (x) >= 0}である。
これは符号付きの桁溢れが未定義の時だけ単純化される。なぜなら、@code{abs (INT_MIN)}は
@code{INT_MIN}へと桁溢れし、0より小さい。@option{-Wstrict-overflow} （レベルなし）は
@option{-Wstrict-overflow=2}と同じである。

@item -Wstrict-overflow=3
比較が単純化される他の例についても警告する。例えば、@code{x + 1 > 1}は@code{x > 0}へと単純化される。

@item -Wstrict-overflow=4
上の例でカバーされない他の単純化についても警告する。例えば、@code{(x * 10) / 5}は@code{x * 2}
へと単純化される。

@item -Wstrict-overflow=5
コンパイラが比較での定数の強度を削減した場合について警告する。例えば、@code{x + 2 > y}は
@code{x + 1 >= y}へと単純化される。これはこの単純化が多くの比較に適用され、多数の偽陽性
を与えるために、最高の警告レベルでのみ警告される。
@end table

@item -Wstringop-overflow
@itemx -Wstringop-overflow=@var{type}
@opindex Wstringop-overflow
@opindex Wno-stringop-overflow
出力バッファを溢れさせると判断された@code{memcpy}や@code{strcpy}のような文字列操作関数の呼び出し
について警告する。余分な引数は出力先のサイズを決定するために実行するObject Size Checkingの種類よりも
１大きい。 @xref{Object Size Checking}.

引数は、文字配列での操作を行うが関数でのみ意味を持つが、@code{memcpy}のような生メモリ関数は、オブジェクトサイズ
タイプ0をいつも使うので意味を持たない。オプションは、最大の可能なオブジェクトか多くても@code{SIZE_MAX / 2}バイト
を超えてサイズを指定した呼び出しにも警告する。オプションは最適化が利用可能なときに最高の結果を生むが、
最適化なしでも標準関数に対応する@code{__builtin_memcpy}のようなGCCの組み込み関数の呼び出しでも検出する。
どんな場合でも、このオプションは対応するオーバーフローチェック組み込み関数によって検出される
バッファオーバーフローの単なるサブセットについて警告する。例えば、このオプションは
以下の@code{strcpy}呼び出しを、少なくとも5文字（文字列@code{"blue"}と末端のNUL）をサイズ４のバッファにコピーするので
警告を発する。

@smallexample
enum Color @{ blue, purple, yellow @};
const char* f (enum Color clr)
@{
  static char buf [4];
  const char *str;
  switch (clr)
    @{
      case blue: str = "blue"; break;
      case purple: str = "purple"; break;
      case yellow: str = "yellow"; break;
    @}

  return strcpy (buf, str);   // warning here
@}
@end smallexample

オプション@option{-Wstringop-overflow=2}はデフォルトで有効である。
@end table

@table @gcctabopt
@item -Wstringop-overflow
@itemx -Wstringop-overflow=1
@opindex Wstringop-overflow
@opindex Wno-stringop-overflow
@option{-Wstringop-overflow=1}オプションは、タイプ0のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。これはオプションのデフォルト設定である。
この設定では、最大のサブオブジェクトのサイズがわかっていない限り、ポインターによってアクセスされる大きなオブジェクトのサブオブジェクトの末尾を越える書き込みについて警告しない。
宛先が複数のオブジェクトのうちの1つである場合、それらの中で最大のものとみなされる。
Linuxシステムでは、この設定で最適化を有効にすると、@code{_FORTIFY_SOURCE}マクロがゼロ以外の値に定義されているときと同じコードが警告される。

@item -Wstringop-overflow=2
@option{-Wstringop-overflow=2}オプションは、タイプ1のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。この設定では、正確なサイズがわかっている最大の完全オブジェクトのメンバーに書き込むときに、オーバーフローに関する警告が表示される。ただし、未知の要素数を含む配列を指している可能性があるため、ポインタによって参照される未知のオブジェクトの同じメンバーへの過剰な書き込みについて警告しない。

@item -Wstringop-overflow=3
@option{-Wstringop-overflow=3}オプションは、タイプ2のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。この設定では、最小のオブジェクトまたはデータメンバーのオーバーフローに関する警告が表示される。これは、安全なコードを警告するオプションの重要な制限設定である。

@item -Wstringop-overflow=4
@option{-Wstringop-overflow=4}オプションは、タイプ3のオブジェクトサイズチェックを使用して宛先オブジェクトのサイズを決定する。この設定では、データメンバーのオーバーフローに関する警告が表示され、宛先が複数のオブジェクトのいずれかである場合は、最大のサイズを使用して警告を出すかどうかを決定する。@option {-Wstringop-overflow=3}と同様に、このオプションの設定により、良質なコードの警告が発生する可能性があります。

@item -Wstringop-truncation
@opindex Wstringop-truncation
@opindex Wno-stringop-truncation
Warn for calls to bounded string manipulation functions such as @code{strncat},
@code{strncpy}, and @code{stpncpy} that may either truncate the copied string
or leave the destination unchanged.

In the following example, the call to @code{strncat} specifies a bound that
is less than the length of the source string.  As a result, the copy of
the source will be truncated and so the call is diagnosed.  To avoid the
warning use @code{bufsize - strlen (buf) - 1)} as the bound.

@smallexample
void append (char *buf, size_t bufsize)
@{
  strncat (buf, ".txt", 3);
@}
@end smallexample

As another example, the following call to @code{strncpy} results in copying
to @code{d} just the characters preceding the terminating NUL, without
appending the NUL to the end.  Assuming the result of @code{strncpy} is
necessarily a NUL-terminated string is a common mistake, and so the call
is diagnosed.  To avoid the warning when the result is not expected to be
NUL-terminated, call @code{memcpy} instead.

@smallexample
void copy (char *d, const char *s)
@{
  strncpy (d, s, strlen (s));
@}
@end smallexample

In the following example, the call to @code{strncpy} specifies the size
of the destination buffer as the bound.  If the length of the source
string is equal to or greater than this size the result of the copy will
not be NUL-terminated.  Therefore, the call is also diagnosed.  To avoid
the warning, specify @code{sizeof buf - 1} as the bound and set the last
element of the buffer to @code{NUL}.

@smallexample
void copy (const char *s)
@{
  char buf[80];
  strncpy (buf, s, sizeof buf);
  @dots{}
@}
@end smallexample

In situations where a character array is intended to store a sequence
of bytes with no terminating @code{NUL} such an array may be annotated
with attribute @code{nonstring} to avoid this warning.  Such arrays,
however, are not suitable arguments to functions that expect
@code{NUL}-terminated strings.  To help detect accidental misuses of
such arrays GCC issues warnings unless it can prove that the use is
safe.  @xref{Common Variable Attributes}.

Option @option{-Wstringop-truncation} is enabled by @option{-Wall}.

@item -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}cold@r{|}malloc@r{]}
@opindex Wsuggest-attribute=
@opindex Wno-suggest-attribute=
属性を加えることが有用かもしれない場合について警告する。現在サポートされている属性は以下に並べられている。

@table @gcctabopt
@item -Wsuggest-attribute=pure
@itemx -Wsuggest-attribute=const
@itemx -Wsuggest-attribute=noreturn
@itemx -Wsuggest-attribute=malloc
@opindex Wsuggest-attribute=pure
@opindex Wno-suggest-attribute=pure
@opindex Wsuggest-attribute=const
@opindex Wno-suggest-attribute=const
@opindex Wsuggest-attribute=noreturn
@opindex Wno-suggest-attribute=noreturn
@opindex Wsuggest-attribute=malloc
@opindex Wno-suggest-attribute=malloc

属性@code{pure}、@code{const}、@code{noreturn}または@code{malloc}の候補であるかもしれない関数について警告する。コンパイラは他のコンパイル単位で見える関数にだけ、あるいは（@code{pure}と@code{const}の場合）
関数は通常戻ると証明できないならば警告する。それが無限のループを含まないか、例外を投げるか、
@code{abort}を呼ぶか、トラップを呼ぶことによって異常に帰らことがないならば、関数は通常に戻る。
この解析はオプション@option{-fipa-pure-const}を必要とする。そして、それは@option{-O}以上で
デフォルトで使用可能にされる。より高い最適化レベルは、解析の正確さを改善する。

@item -Wsuggest-attribute=format
@itemx -Wmissing-format-attribute
@opindex Wsuggest-attribute=format
@opindex Wmissing-format-attribute
@opindex Wno-suggest-attribute=format
@opindex Wno-missing-format-attribute
@opindex Wformat
@opindex Wno-format

@code{format}属性の候補であるかもしれない関数ポインタについて警告する。
これらが考えられる候補だけであって、絶対のものでない点に注意する。
結果として生じるものの属性が型に対応する@code{format}を、代入、初期化、パラメータ渡し、return文において使われる@code{format}属性による関数ポインタが持つべきであると、GCCは推測する。
すなわち：警告を避けるためには、代入または初期化の左側、パラメータ変数の型、
含んでいる関数の型がそれぞれ@code{format}を持つべきである。

@code{format}属性の候補であるかもしれない関数定義についても、GCCは警告する。
再び、これらは考えられる候補だけである。@code{vprintf}または@code{vscanf}のような関数を呼ぶ
どんな関数でも、@code{format}属性が適切かもしれないと、GCCは推測する、しかし、
これは必ずしも本当でないかもしれない、そして、@code{format}属性が適切であるある関数は
見つけられないかもしれない。

@item -Wsuggest-attribute=cold
@opindex Wsuggest-attribute=cold
@opindex Wno-suggest-attribute=cold

@code{cold}属性の候補となる可能性がある関数について警告する。 これは静的な検出に基づいており、一般的にはC++の@code{throw}のラッパーや@code{abort}につながる致命的なエラー報告関数のような別の@code{cold}関数への呼び出しにつながる関数についてのみ警告する。

@end table

@item -Wsuggest-final-types
@opindex Wno-suggest-final-types
@opindex Wsuggest-final-types
型がC++11@code{final}指定子付きで宣言されるか、もし可能なら匿名名前空間で宣言すれば、
コード品質を向上させる仮想メソッドのある型について警告する。これはGCCのがもっと積極的に
多相呼び出しを非仮想化することを可能にする。この警告は、リンク時最適化で、もっと効果的であり、
そこではクラス階層グラフの情報がもっと完全である。

@item -Wsuggest-final-methods
@opindex Wno-suggest-final-methods
@opindex Wsuggest-final-methods
メソッドがC++11@code{final}指定子で宣言されているか、もし可能ならばその型が匿名名前空間で
宣言するか@code{final}指定子で宣言されていれば、コード品質が向上する仮想メソッドについて警告する。
多相呼び出しを非仮想化することを可能にする。この警告は、リンク時最適化で、もっと効果的であり、
そこではクラス階層グラフの情報がもっと完全である。最初に@option{-Wsuggest-final-types}の提案を考え、
新しい表記で再ビルドすることを推奨する。

@item -Wsuggest-override
ocerrideキーワードでマークされていないオーバーライド仮想関数について警告する。

@item -Walloc-zero
@opindex Wno-alloc-zero
@opindex Walloc-zero
組み込み形式の関数@code{aligned_alloc}、@code{alloca}、@code{calloc}、@code{malloc}と@code{realloc}含め、属性@code{alloc_size}で装飾された割り当て関数へのゼロバイトを指定した呼び出しについて警告する。これらの関数のサイズがゼロで呼び出されたときの動作は実装によって異なる（@code{realloc}の場合は廃止された）ので、それに頼ると微妙な移植性のバグが生じる可能性があるので避けるべきである。りますので避けてください。

@item -Walloc-size-larger-than=@var{n}
属性@code{alloc_size}で修飾された館数が指定されたバイト数よりも大きいサイズを割り当てようとしたとき及び、サイズ計算の結果が無限精度の整数で@code{SIZE_MAX / 2}を超えるところで警告する。
オプション引数@var{n}は、キロバイトとキビバイトに@code{kB}と@code{KiB}、メガバイトとメビバイトに@code{MB}と@code{MiB}などのようなバイトの倍数を指定する標準サフィックスのいずれかで終わってもよい。@option{-Walloc-size-greater-than=}@var{PTRDIFF_MAX}はデフォルトで有効になっている。@var{SIZE_MAX}以上の@var{n}を指定することで、オプションで制御される警告を無効にすることができる。

@xref{Function Attributes}.

@item -Walloca
@opindex Wno-alloca
@opindex Walloca
このオプションはソースでの@code{alloca}の全使用を警告する。

@item -Walloca-larger-than=@var{n}
このオプションは、整数型の引数を多くても@var{n}バイトに制限する制御述語によって制限されない@code{alloca}への呼び出し、またはバインドが未知の@code{alloca}への呼び出しを警告しり。
非整数型の引数は、期待される範囲に制約されているように見えても、無限と見なされます。

例えば、@code{alloca}の制限された場合は以下のようである。

@smallexample
void func (size_t n)
@{
  void *p;
  if (n <= 1000)
    p = alloca (n);
  else
    p = malloc (n);
  f (p);
@}
@end smallexample

上の例で、@code{-Walloca-larger-than=1000}を渡しても@code{alloca}への呼び出しが多くても1000バイトであると既知なので警告を発しない。しかし、@code{-Walloca-larger-than=500}が渡されたとすると、コンパイラは警告を発するだろう。

一方、制限なしの場合は、整数を制限する制御述語なしでの@code{alloca}の使用である。例えば、

@smallexample
void func ()
@{
  void *p = alloca (n);
  f (p);
@}
@end smallexample

もし、@code{-Walloca-larger-than=500}が渡されたとすると、上は警告を発するが、今回は範囲チェックの欠如のためである。

注意として、一見正しくは符号付き整数を含むコードでも警告を発する：

@smallexample
void func (signed int n)
@{
  if (n < 500)
    @{
      p = alloca (n);
      f (p);
    @}
@}
@end smallexample

上の例では、@var{n}は負になりうるので、@code{alloca}呼び出しへの暗黙のキャストによって予測された
引数よりも大きくなる。

このオプションは、ループ内で@code{alloca}が使われたときも警告する。

このオプションは@option{-Wall}では有効にならず、@option{-ftree-vrp}が活性（@option{-O2}以上でのデフォルト）のときのみ活性になる。

@option{-Wvla-larger-than=@var{n}}も見よ。

@item -Warray-bounds
@itemx -Warray-bounds=@var{n}
@opindex Wno-array-bounds
@opindex Warray-bounds
このオプションは@option{-ftree-vrp}が有効で(@option{-O2}以上のデフォルト)の時のみ有効である。
配列の添字が常に範囲外の時に警告する。このオプションは@option{-Wall}で有効になる。

@table @gcctabopt
@item -Warray-bounds=1
これは@option{-Warray-bounds}の警告レベルであり、@option{-Wall}で有効になる。より高いレベルは
ならないので、明示的に要求しなければならない。

@item -Warray-bounds=2
この警告は構造体の終わりの配列とポインタ経由でアクセスされる配列の境界外アクセスについても警告する。
これは多数の偽陽性を与えるかもしれず、デフォルトで無効にされる。
@end table

@item -Wattribute-alias
Warn about declarations using the @code{alias} and similar attributes whose
target is incompatible with the type of the alias.  @xref{Function Attributes,
,Declaring Attributes of Functions}.

@item -Wbool-compare
@opindex Wno-bool-compare
@opindex Wbool-compare
真偽値表現を@code{true}/@code{false}とは異なった整数値と比較していることについて警告する。
例えば、以下の比較は常に偽である。
@smallexample
int n = 5;
@dots{}
if ((n > 1) == 2) @{ @dots{} @}
@end smallexample
この警告は@option{-Wall}で有効になる。

@item -Wbool-operation
@opindex Wno-bool-operation
@opindex Wbool-operation
ブール型の式に対する疑わしい操作について警告する。 たとえば、ブール値のビット単位の否定は、プログラムのバグである可能性が非常に高い。Cの場合、この警告はブール値のインクリメント・デクリメントについても警告するが、それはめったに意味があることはないためである。（C++では、ブール値のデクリメントは常に無効である。ブール値のインクリメントはC++17では無効で、それ以外の場合は非推奨である。）

この警告は@option{-Wall}によって有効になる。

@item -Wduplicated-branches
@opindex Wno-duplicated-branches
@opindex Wduplicated-branches
if-elseが同一の分岐を持つときに警告する。この警告は以下の様な場合
@smallexample
if (p != NULL)
  return 0;
else
  return 0;
@end smallexample
これは両方の分岐が空文をのみを含んでいる場合には警告しない。この警告は条件演算子に対しても警告する。
@smallexample
  int i = x ? *p : *p;
@end smallexample

@item -Wduplicated-cond
@opindex Wno-duplicated-cond
@opindex Wduplicated-cond
if-else-if連鎖での重複した条件について警告する。例えば、以下のコードで警告する。
@smallexample
if (p->q != NULL) @{ @dots{} @}
else if (p->q != NULL) @{ @dots{} @}
@end smallexample

@item -Wframe-address
@opindex Wno-frame-address
@opindex Wframe-address
@samp{__builtin_frame_address}か@samp{__builtin_return_address}が0より大きな引数で
呼ばれたら警告する。そのような呼び出しは不定値を返すか、プログラムをクラッシュさせる。この警告は
@option{-Wall}に含まれている。

@item -Wno-discarded-qualifiers @r{(CとObjective-Cのみ)}
@opindex Wno-discarded-qualifiers
@opindex Wdiscarded-qualifiers
ポインタの型修飾子が削除されることについて警告しない。典型的には、コンパイラは、
@code{const char*}変数が@code{char *}パラメータを取る関数に渡されたら警告する。
このオプションはそのような警告を抑制する。

@item -Wno-discarded-array-qualifiers @r{(CとObjective-Cのみ)}
@opindex Wno-discarded-array-qualifiers
@opindex Wdiscarded-array-qualifiers
ポインタ・ターゲットである配列の型修飾子が削除されることについて警告しない。
典型的には、コンパイラは@code{const int (*)[]}変数が@code{ int (*)[]}パラメータを取る
関数に渡されたら警告する。このオプションはそのような警告を抑制する。

@item -Wno-incompatible-pointer-types @r{(CとObjective-Cのみ)}
@opindex Wno-incompatible-pointer-types
@opindex Wincompatible-pointer-types
ポインタとそれに非互換の型の間の変換について警告しない。この警告は@option{-Wno-pointer-sign}で
カバーしていないケースを警告し、それは異なった符号性のポインタ引数渡しか代入について警告する。

@item -Wno-int-conversion @r{(CとObjective-Cのみ)}
@opindex Wno-int-conversion
@opindex Wint-conversion
非互換の整数とポインタの変換について警告しない。この警告は暗黙の変換についけ警告する。
明示的な変換は警告@option{-Wno-int-to-pointer-cast}と@option{-Wno-pointer-to-int-cast}
が使われるかもしれない。

@item -Wno-div-by-zero
@opindex Wno-div-by-zero
@opindex Wdiv-by-zero
コンパイル時の整数ゼロ除算について警告しない。浮動小数点数ゼロ除算は、無限と非数を得る
合法な手段なので警告しない。

@item -Wsystem-headers
@opindex Wsystem-headers
@opindex Wno-system-headers
@cindex warnings from system headers
@cindex system headers, warnings from
システムヘッダファイルに見つかった構造の警告メッセージを出力する。
システムヘッダからの警告は、通常は本当の問題を指しておらず、コンパイラの出力を読みにくくするという仮定で、
通常は抑制されている。このコマンドラインオプションを使うと、ユーザコードで起こったかのようにシステムヘッダからの警告を
出力するようにGCCに伝える。しかし、このオプションと組み合わせで@option{-Wall}を使ってもシステムヘッダの未知のプラグマ
は警告され@emph{ない}ことに注意する。そのためには、@option{-Wunknown-pragmas}を使わなくてはならない。

@item -Wtautological-compare
@opindex Wtautological-compare
@opindex Wno-tautological-compare
自己比較が常に真か偽と評価されるなら警告する。この警告は以下の様な様々な誤りを検知する。
@smallexample
int i = 1;
@dots{}
if (i > i) @{ @dots{} @}
@end smallexample

この警告は、常にtrueまたはfalseに評価されるビット単位の比較についても警告する。たとえば、

@smallexample
if ((a & 16) == 10) @{ @dots{} @}
@end smallexample
は常に偽である。
 
この警告は@option{-Wall}で有効である。

@item -Wtrampolines
@opindex Wtrampolines
@opindex Wno-trampolines
入れ子関数へのポインタとして生成されたトランポリンについて警告する。トランポリンは
入れ子関数のアドレスが取られた時に実行時にスタックに生成される小さいデータやコードであり、
入れ子関数を間接的に呼ぶときに使われる。あるターゲットでは、データだけで構成され、特殊な処理は不要である。
しかし大抵のターゲットでは、コードで構成され、したがってプログラムを適切に実行するためにはスタックが実行可能である必要がある。

@item -Wfloat-equal
@opindex Wfloat-equal
@opindex Wno-float-equal
浮動小数点数が等価比較で使われたら警告する。

この背後の考えは、時々、浮動小数点値を無限に正確な実数の近似と思うことが（プログラマにとって）便利であるということである。
こうしているならば、あなたは計算が持ち出す最大であるかありそうな最大のエラーを計算し（コードを分析することによって、あるいはなんとかして）
、比較（そして、出力を生じるとき、しかし、それは異なる問題である）を実行するときそれを考慮に入れる必要がある。
特に、平等のためのテストの代わりに、あなたは、2つの値が重なる範囲を持つかどうか見るためにチェックするべきである。
そして、これは関係演算子でされるので、平等比較は多分誤っているだろう。

@item -Wtraditional @r{(CとObjective-Cのみ)}
@opindex Wtraditional
@opindex Wno-traditional
伝統的なC++とISO Cで異なって振る舞う構造のいくつかについて警告する。伝統的なCに等価物がないISO Cの構造と、避けるべき問題のある構造についても警告する。

@itemize @bullet
@item
マクロ本体内の文字列定数内に現れるマクロパラメータ。伝統的なCでは文字列定数内でマクロ置換で置き換えられが、ISO Cではしない。

@item
伝統的なCでは、幾つかのプリプロセスディレクティブが存在しない。伝統的なプリプロセスでは@samp{#}が行の第1桁の時だけディレクティブとみなされる。
したがって、@option{-Wtraditional}は伝統的なCが理解するが、@samp{#}が行の先頭でないために無視されるディレクティブについて警告する。
それは@code{#pragma}のような伝統的なCが理解できないディレクティブを隠すためにインデントするようにも提案する。ある伝統的な実装は
@code{#elif}を認識しないので、このオプションはそれを完全に避けるように提案する。

@item
引数なしで現れる関数風マクロ。

@item
単項プラス演算子

@item
@samp{U}整数定数接尾辞、@samp{F}および@samp{L}浮動小数点定数接尾辞。（伝統的なCは整数定数での@samp{L}接尾辞はサポートしている）
これらの接尾辞はたいていの最近のシステムのシステムヘッダで定義されたマクロに現れることに注意する。例えば、
@code{<limits.h>}の@samp{_MIN}/@samp{_MAX}マクロ。どんなにGCCの統合化プリプロセッサにはこれらの場合警告を避けるのに十分なコンテキストがあっても、
ユーザコードのこれらのマクロの使用はもっともらしい警告に通常つながるかもしれない。

@item
一つのブロックで外部として宣言され、ブロック終わりの後ろで使われた関数。

@item
@code{switch}文が@code{long}型のオペランドを持つ。

@item
非@code{staic}関数宣言が@code{static}に続く。この構造はいくつかの伝統的なCコンパイラでは受理されない。

@item
整数定数のISO型は伝統的な型とは異なった幅と符号性を持つ。定数の底が10であるときだけこの警告は発される。すなわち、
16進と8進の値は、典型的にはビットパターンを表し、警告されない。

@item
ISO文字列連結の使用を検知した時。

@item
自動集合値の初期化。

@item
ラベルと衝突する識別子。伝統的なCは分離されたラベル名前空間を欠けている。

@item
共用体の初期化。もし初期化子が0ならばこの警告は飛ばされる。これはユーザコードの0初期化子が初期化子警告を逃すことを避けるために例えば、@code{__STDC__}上で条件つきに見えて、伝統的なCケースでゼロへのデフォルト初期化に頼るという仮定中でこれはされる。

@item
プロトタイプによる固定・浮動小数点数およびその逆の変換。伝統的なCでこれらのプロトタイプなしでコンパイルすると深刻な問題を引き起こす。これはありうる変換警告の一部である。完全な集合には、@option{-Wtraditional-conversion}を使う。

@item
ISO C方式の関数定義の使用。この警告はプロトタイプ宣言や可変長関数では、それらのISO Cの機能がlibiberryの伝統的なCの互換性マクロ
@code{PARAMS}と@code{VPARAMS}で使われているので意図的に発せられ@emph{ない}。この警告は入れ子関数でも、この機能がすでにGCC拡張であって、
伝統的なC互換性と無関係なので素通りされる。
@end itemize

@item -Wtraditional-conversion @r{(CとObjective-Cのみ)}
@opindex Wtraditional-conversion
@opindex Wno-traditional-conversion
プロトタイプがプロトタイプがない場合同じ引数で起こるものとは異なる型変換を引き起こすならば警告する。
これは固定小数点数から浮動小数点数への変換とその逆、固定小数点引数がデフォルト格上げと同じ場合を除いて幅と符号性が変わる場合を含む。

@item -Wdeclaration-after-statement @r{(CとObjective-Cのみ)}
@opindex Wdeclaration-after-statement
@opindex Wno-declaration-after-statement
ブロック内の文の後に宣言が見つかった場合に警告する。このぞうは、C++とからとして知られ、ISO C99で導入され、GCCではデフォルトで許されている。
ISO C90ではサポートされていない。 @xref{Mixed Declarations}.


@item -Wshadow
@opindex Wshadow
@opindex Wno-shadow
ローカル変数か型宣言が他の変数、パラメータ、型、クラスメンバ（C++で）、インスタンス変数（Objective-Cで）、組み込み関数を隠すときに警告する。
C++では、コンパイラはローカル変数が明示的なtypedefを隠す時は警告するが、struct/class/enumを隠すときは警告しないことに注意する。
@option{-Wshadow=global}と同じである。

@item -Wno-shadow-ivar @r{(Objective-Cのみ)}
@opindex Wno-shadow-ivar
@opindex Wshadow-ivar
Objective-Cメソッドでローカル変数がインスタンス変数を隠すときに警告しない。

@item -Wshadow=global
@opindex Wshadow=global
@option{-Wshadow}のデフォルトである。どんな（グローバル）隠しにも警告する。

@item -Wshadow=local
@opindex Wshadow=local
ローカル変数が他のローカル変数・パラメータを隠すときに警告する。この警告は@option{-Wshadow=global}で有効になる。

@item -Wshadow=compatible-local
@opindex Wshadow=compatible-local
ローカル変数が、隠している変数の型と互換性のある別のローカル変数またはパラメータを隠したときに警告する。 C++では、ここでのタイプの互換性とは、隠している変数の型を隠された変数のタイプに変換できることを意味する。 このフラグの作成（@option{-Wshadow=local}に加えて）は、ローカル変数が互換性のない型の別のものを隠すとき、バグや誤字ではなく、意図的である可能性が高いという考えに基づいている。 次の例：


@smallexample
@group
for (SomeIterator i = SomeObj.begin(); i != SomeObj.end(); ++i)
@{
  for (int i = 0; i < N; ++i)
  @{
    ...
  @}
  ...
@}
@end group
@end smallexample

上での例の2つの変数@code{i}は非互換の型を持つので、@option{-Wshadow=compatible-local}だけを有効にした場合には警告を発しない。それらの型は非互換なので、たとえプログラマが誤って取り違えて使っても、型検査がそれをキャッチしてエラーか警告を発するだろう。したがって、この場合に（隠すことに関して）警告しないことはバグの漏れを引き起こさない。@option{-Wshadow=local}の代わりにこのフラグを使うことで意図的な隠しによって引き起こされる警告の数を減らすことができるかもしれない。

この警告は@option{-Wshadow=local}によって有効になる。

@item -Wlarger-than=@var{len}
@opindex Wlarger-than=@var{len}
@opindex Wlarger-than-@var{len}
@var{len}バイトよりも大きいオブジェクトが定義された時に警告する。

@item -Wframe-larger-than=@var{len}
@opindex Wframe-larger-than
関数フレームが@var{len}バイトよりも大きいサイズの時に警告する。
スタック・フレームサイズを測定するためにされる計算は、概算で、保守的でない。たとえあなたが警告を着かないとしても、
実際の必要条件は@var{len}よりいくぶん大きいかもしれない。そのうえ、警告を発するべきかどうか決定するとき、@code{alloca}、可変長の配列または関連した
構成概念を通して割り当てられる少しのスペースもコンパイラによって含まれない。

@item -Wno-free-nonheap-object
@opindex Wno-free-nonheap-object
@opindex Wfree-nonheap-object
ヒープに割り当てられなかったオブジェクトを開放しようとすることを警告しない。

@item -Wstack-usage=@var{len}
@opindex Wstack-usage
関数のスタック使用が@var{len}バイトを超えるかもしれない時に警告する。
スタック使用を決定するための計算は保守的である。@code{alloca}によって割り当てられる空間,
可変長配列、関連する構造は警告を発するかどうかを決定する際にコンパイラによって含まれる。

メッセージは@option{-fstack-usage}の出力で保持される。

@itemize
@item
もしスタックの使用が完全に静的指定された範囲を超えるなら、こうなる。

@smallexample
  warning: stack usage is 1120 bytes
@end smallexample
@item
もしスタックの使用が（部分的に）動的だが、上限があるならば、こうなる。

@smallexample
  warning: stack usage might be 1648 bytes
@end smallexample
@item
もしスタックの使用が（部分的に）動的に、上限がないならば、こうなる。

@smallexample
  warning: stack usage might be unbounded
@end smallexample
@end itemize

@item -Wno-pedantic-ms-format @r{(MinGWターゲットのみ)}
@opindex Wno-pedantic-ms-format
@opindex Wpedantic-ms-format
@option{-Wformat}とGNU拡張なしの@option{-pednatic}を組み合わせて使った時に、
このオプションは非ISOの@code{printf} / @code{scanf}フォーマットを
MSランタイムに依存して、ウィンドウズターゲットで使われる@code{I32}, @code{I64}, @code{I}
指定子で使った時の警告を無効にする。

@item -Waligned-new
@opindex Waligned-new
@opindex Wno-aligned-new
@code{alignof(std::max_align_t)}よりも大きなアラインメントを要求するが明示的なアラインメントパラメータのない割当関数を使っているnew式について警告する。

通常、この警告はグローバル割当関数についてのみ警告するが、@option{-Waligned-new=all}はクラスメンバ割当関数についても警告する。

@item -Wplacement-new
@itemx -Wplacement-new=@var{n}
@opindex Wplacement-new
@opindex Wno-placement-new
オブジェクトの型より小さいバッファにオブジェクトを構築するような、配置new式の未定義な振る舞い
について警告する。例えば、以下の配置new式は64バイト長しかないバッファに64の整数の配列を
構築しようとするため、診断される。
@smallexample
char buf [64];
new (buf) int[64];
@end smallexample
この警告はデフォルトで有効である。

@table @gcctabopt
@item -Wplacement-new=1
@option{-Wplacement-new}のデフォルトの警告レベルである。このレベルでは、
古いコードとの互換性のためにGCCが拡張として許しているある厳密には未定義の構造については警告を
出さない。例えば、以下の@code{new}式はC++標準によれば1要素の配列の終わりの後ろに書くために、
未定義の振る舞いだが、このレベルでは診断されない。
@smallexample
struct S @{ int n, a[1]; @};
S *s = (S *)malloc (sizeof *s + 31 * sizeof s->a[0]);
new (s->a)int [32]();
@end smallexample

@item -Wplacement-new=2
このレベルでは、レベル１でと同じ構造を診断することに加え、その方が単一要素の配列であり、
そのサイスが構築されるオブジェクトのサイズより小さい構造体の最後のメンバでオブジェクトを構築する
配置new式にも診断する。前の例が診断を出す一方、以下の可変長メンバ配列拡張を使うとレベル２の警告を
避けることができる。
@smallexample
struct S @{ int n, a[]; @};
S *s = (S *)malloc (sizeof *s + 32 * sizeof s->a[0]);
new (s->a)int [32]();
@end smallexample

@end table

@item -Wpointer-arith
@opindex Wpointer-arith
@opindex Wno-pointer-arith
関数型および@code{void}の「サイズ」に依存したもの全てに警告する。GNU Cは、@code{void*}ポインタと
関数へのポインタでの計算の便利のために、それらのサイズを1とする。C++では、@code{NULL}が関与する
算術演算にも警告する。この警告は@option{-Wpedantic}で有効になる。

@item -Wpointer-compare
@opindex Wpointer-compare
@opindex Wno-pointer-compare
ポインタが0文字定数と比較されていると警告する。これは通常ポインタが参照剥がしされる意図があったことを意味する。例えば：

@smallexample
const char *p = foo ();
if (p == '\0')
  return 42;
@end smallexample

上のコードはC++11では不正であることに注意する。

この警告はデフォルトで有効である。

@item -Wtype-limits
@opindex Wtype-limits
@opindex Wno-type-limits
比較がデータ型の制限された範囲のために常に真か偽になるときに警告するが、定数表現では警告しない。
例えば、もし符号なし値が0と@code{<}か@code{>=}で比較されていたら警告する。この警告は
@option{-Wextra}で有効になる。

@include cppwarnopts.texi

@item -Wbad-function-cast @r{(CとObjective-C専用)}
@opindex Wbad-function-cast
@opindex Wno-bad-function-cast
関数呼び出しが一致しない型へキャストされていたら警告する。例えば、整数型を返す関数呼び出しが
ポインタ型へキャストされていたら警告する。

@item -Wc90-c99-compat @r{(CとObjective-C専用)}
@opindex Wc90-c99-compat
@opindex Wno-c90-c99-compat
ISO C90にはないが、ISO C99にはある機能について警告する。たお手羽、可変長配列の使用、
@code{long long}型、@code{bool}型、複合定数、指示付きの初期化子など。このオプションは標準モードと
独立である。傾向は@code{__extension__}に続く式では無効にされる。

@item -Wc99-c11-compat @r{(CとObjective-C専用)}
@opindex Wc99-c11-compat
@opindex Wno-c99-c11-compat
ISO C99にはないが、ISO C11にはある機能について警告する。例えば、匿名構造体と共用体の使用、
@code{_Atomic}型指定子、@code{_Thread_local}ストレージクラス指定子、
@code{_Alignas}指定子、@code{Alignof}演算子、@code{_Generic}キーワードなど。
このオプションは標準モードと独立である。傾向は@code{__extension__}に続く式では無効にされる。

@item -Wc++-compat @r{(CとObjective-C専用)}
@opindex Wc++-compat
ISO CとISO C++の共通部分集合の外側のISO C構造について警告する。例えば、@code{void *}から
非@code{void}型へのポインタへの暗黙の変換の要求。

@item -Wc++11-compat @r{(C++とObjective-C++専用)}
@opindex Wc++11-compat
ISO C++1998とISO C++2011で意味が異なるC++構造について警告する。例えば、ISO C++ 2011で
キーワードであるISO C++1998での識別子。この警告は@option{-Wnarrowing}を有効にし、
@option{-Wall}で有効になる。

@item -Wc++14-compat @r{(C++とObjective-C++専用)}
@opindex Wc++14-compat
ISO C++2011とISO C++2014で意味が異なるC++構造について警告する。
この警告は@option{-Wall}で有効になる。

@item -Wc++17-compat @r{(C++とObjective-C++専用)}
@opindex Wc++17-compat
ISO C++ 2014とISO C++ 2017の間で意味が異なるC++構造について警告する。これは@option{-Wall}で有効になる。

@item -Wcast-qual
@opindex Wcast-qual
@opindex Wno-cast-qual
ポインタがターゲット型から型修飾子が削除されるようにキャストされると警告する。例えば、
@code{const char*}が単なる@code{char *}へとキャストされると警告する。

安全でない方法で型修飾子が追加されるキャストにも警告する。例えば、
@code{char **}から@code{const char **}へのキャストはこの例のように安全でない。

@smallexample
  /* p はchar **の値  */
  const char **q = (const char **) p;
  /* 読み出し専用文字列のconst char*への代入はOK  */
  *q = "string";
  /* 今char**は読み出し専用のメモリを指している  */
  **p = 'b';
@end smallexample

@item -Wcast-align
@opindex Wcast-align
@opindex Wno-cast-align
ターゲットの要求されるアラインメントが増えるようにポインタがキャストされると警告する。
例えば、整数が２か４バイトの境界でしかアクセスできない機種で@code{char *}が@code{int *}に
キャストされると警告する。

@item -Wcast-align=strict
@opindex Wcast-align=strict
Warn whenever a pointer is cast such that the required alignment of the
target is increased.  For example, warn if a @code{char *} is cast to
an @code{int *} regardless of the target machine.

@item -Wcast-function-type
@opindex Wcast-function-type
@opindex Wno-cast-function-type
Warn when a function pointer is cast to an incompatible function pointer.
In a cast involving function types with a variable argument list only
the types of initial arguments that are provided are considered.
Any parameter of pointer-type matches any other pointer-type.  Any benign
differences in integral types are ignored, like @code{int} vs. @code{long}
on ILP32 targets.  Likewise type qualifiers are ignored.  The function
type @code{void (*) (void)} is special and matches everything, which can
be used to suppress this warning.
In a cast involving pointer to member types this warning warns whenever
the type cast is changing the pointer to member type.
This warning is enabled by @option{-Wextra}.

@item -Wwrite-strings
@opindex Wwrite-strings
@opindex Wno-write-strings
Cをコンパイルするとき、文字列定数に型@code{const char[@var{length}]}を、1つのアドレスを非@code{const} @code{char *}ポインタにコピーするために与えると警告を出す。
これらの警告は文字列定数に書こうとするコードをコンパイル時に見つけるのには役立つが、あなたが宣言とプロトタイプで@code{const}を使うことに非常に慎重な場合だけ、その場合に限りである。さもなければ、それは単なる迷惑である。そういうわけで、我々は@option{-Wall}をこれらの警告を要請させなかった。

C++をコンパイルするとき、文字列定数から@code{char *}への廃止予定の変換ついて警告する。この警告は、C++プログラムではデフォルトで使用可能である。

@item -Wcatch-value
@itemx -Wcatch-value=@var{n} @r{(C++ and Objective-C++ only)}
@opindex Wcatch-value
@opindex Wno-catch-value
Warn about catch handlers that do not catch via reference.
With @option{-Wcatch-value=1} (or @option{-Wcatch-value} for short)
warn about polymorphic class types that are caught by value.
With @option{-Wcatch-value=2} warn about all class types that are caught
by value. With @option{-Wcatch-value=3} warn about all types that are
not caught by reference. @option{-Wcatch-value} is enabled by @option{-Wall}.

@item -Wclobbered
@opindex Wclobbered
@opindex Wno-clobbered
変数が@code{longjmp}や@code{vfork}で変わるかもしれないときに警告する。これは@option{-Wextra}で有効である。

@item -Wconditionally-supported @r{(C++とObjective-C++専用)}
@opindex Wconditionally-supported
@opindex Wno-conditionally-supported
条件付きでサポートされる(C++11 [intro.defs])構造について警告する。

@item -Wconversion
@opindex Wconversion
@opindex Wno-conversion
値が変わるかもしれない暗黙の変換について警告する。これは@code{x}が@code{double}の時の@code{abs (x)}のような、実数と整数の変換、
@code {unsigned ui = -1}のような符号ありと符号なしの変換。@code{sqrtf (M_PI)}のようなより小さい型への変換を含む。
@code{abs ((int) x)} and @code{ui = (unsigned) -1}のような明示的なキャスト、および@code{abs (2.0)}のような値の変化しない変換は警告しない。
符号ありと符号なしの整数間の変換の警告は@option{-Wno-sign-conversion}で無効にできる。

C++では、ユーザ定義の混乱したオーバーロード解決、@code{void}、同じ型、基底クラスかそれへの参照型への変換のような、型変換演算子を使わない変換にも
警告する。符号付きと符号なし整数間の変換は@option{-Wsign-conversion}で明示的に有効にしないかぎりデフォルトで無効にされる。

@item -Wno-conversion-null @r{(C++とObjective-C++のみ)}
@opindex Wconversion-null
@opindex Wno-conversion-null
@code{NULL}と非ポインタ型の変換を警告しない。@option{-Wconversion-null}はデフォルトで有効にされる。

@item -Wzero-as-null-pointer-constant @r{(C++とObjective-C++のみ)}
@opindex Wzero-as-null-pointer-constant
@opindex Wno-zero-as-null-pointer-constant
定数@samp{0}をヌルポインタ定数として使った時に警告する。これはC++11で@code{nullptr}への変換を促進するのに役立つ。

@item -Wsubobject-linkage @r{(C++とObjective-C++のみ)}
@opindex Wsubobject-linkage
@opindex Wno-subobject-linkage
クラスタイプが基底かフィールドがその型が匿名名前空間を使っているかリンケージのない型に依存している時に警告する。
もし型Aがリンケージなしか内部リンケージの型Bに依存している時、それを複数の翻訳空間で定義することはBの意味がそれぞれの翻訳単位で
異なるためにODR違反と違反になる。もしAが単一翻訳単位にしか現れないのであれば、警告を黙らせる最善の方法はそれも匿名名前空間において
内部リンケージを与えることである。コンパイラはメイン.Cファイルで定義された型には、複数の定義はありそうもないので、警告を与えない。
@option{-Wsubobject-linkage}はデフォルトで有効である。

@item -Wdangling-else
@opindex Wdangling-else
@opindex Wno-dangling-else
どの@code{if}に@code{else}分岐が属しているか混乱するかもしれない構造に警告する。ここの例の場合、

@smallexample
@group
@{
  if (a)
    if (b)
      foo ();
  else
    bar ();
@}
@end group
@end smallexample

C・C++では、それぞれの@code{else}分岐は可能な最も内側の@code{if}文に属し、この例では@code{if (b)}である。これはしばしば、上の例でプログラマの選択したインデントで示されるように、プログラマの期待した通りでない。この混乱の潜在性があるときには、GCCはこのフラグが指定されたときには警告を発する。警告を除去するためには、@code{else}が囲っている@code{if}に属すことができないように最も内側の@code{if}の周りに明示的なカッコを加える。結果のコードはこのようになる。

@smallexample
@group
@{
  if (a)
    @{
      if (b)
        foo ();
      else
        bar ();
    @}
@}
@end group
@end smallexample

この警告は@option{-Wparentheses}で有効になる。

@item -Wdate-time
@opindex Wdate-time
@opindex Wno-date-time
ビット単位で同一のコンパイル再現性を妨げるかもしれないため、@code{__TIME__}、 @code{__DATE__}、@code{__TIMESTAMP__}に出会ったら警告する。

@item -Wdelete-incomplete @r{(C++とObjective-C++のみ)}
@opindex Wdelete-incomplete
@opindex Wno-delete-incomplete
実行時に未定義の振る舞いを引き起こすかもしれないため、非完全形へのポインタを削除しようとすると警告する。この警告はデフォルトで有効である。

@item -Wuseless-cast @r{(C++とObjective-C++専用)}
@opindex Wuseless-cast
@opindex Wno-useless-cast
式が自分の型へとキャストされている時に警告する。

@item -Wempty-body
@opindex Wempty-body
@opindex Wno-empty-body
@code{if}, @code{else}, @code{do while}文に空の本体が現れると警告する。これは@option{-Wextra}でも有効になる。

@item -Wenum-compare
@opindex Wenum-compare
@opindex Wno-enum-compare
異なる列挙型の値間の比較について警告する。C++では条件式での列挙の不一致も診断して警告はデフォルトで有効になる。
Cではこの警告は@option{-Wall}で有効になる。

@item -Wextra-semi @r{(C++, Objective-C++のみ)}
@opindex Wextra-semi
@opindex Wno-extra-semi
クラス内関数定義の後の冗長なセミコロンについて警告する。
 
@item -Wjump-misses-init @r{(C, Objective-C専用)}
@opindex Wjump-misses-init
@opindex Wno-jump-misses-init
@code{goto}文か@code{switch}文が変数の初期化をまたいで飛ぶか、初期化された後にラベルへと戻って飛ぶときに警告する。
これは宣言された時に初期化された変数についてのみ警告する。この警告はCとObjective-Cでのみサポートされている。
C++ではこの種類の分岐はどのみちエラーである。

@option{-Wjump-misses-init}は@option{-Wc++-compat}に含まれている。@option{-Wno-jump-misses-init}オプションで無効にできる。

@item -Wsign-compare
@opindex Wsign-compare
@opindex Wno-sign-compare
@cindex warning for comparison of signed and unsigned values
@cindex comparison of signed and unsigned values, warning
@cindex signed and unsigned values, comparison warning
符号付きと符号なしの値の比較が符号付き値が符号なし値に変換された時に不正確な結果を生み出す時に警告する。
C++では、この警告は@option{-Wall}でも有効である。Cでは、@option{-Wextra}でも有効である。

@item -Wsign-conversion
@opindex Wsign-conversion
@opindex Wno-sign-conversion
符号付き製数式を符号なし整数値に代入するような、整数値の符号が変わるかもしれない暗黙の変換について警告する。
明示的なキャストはこの警告を黙らせる。Cでは、では、このオプションは@option{-Wconversion}でも有効になる。

@item -Wfloat-conversion
@opindex Wfloat-conversion
@opindex Wno-float-conversion
実数値の精度を減らす暗黙の変換を警告する。これは実数から整数、高い精度の実数から低い精度の実数への変換を含む。
このオプションは@option{-Wconversion}でも有効になる。

@item -Wno-scalar-storage-order
@opindex -Wno-scalar-storage-order
@opindex -Wscalar-storage-order
逆スカラー格納順に関する疑わしい構造について警告しない。

@item -Wsized-deallocation @r{(C++とObjective-C++のみ)}
@opindex Wsized-deallocation
@opindex Wno-sized-deallocation
サイズ無しの解放関数の定義で
@smallexample
void operator delete (void *) noexcept;
void operator delete[] (void *) noexcept;
@end smallexample
対応するサイズ付き解放関数の定義
@smallexample
void operator delete (void *, std::size_t) noexcept;
void operator delete[] (void *, std::size_t) noexcept;
@end smallexample
がないかその逆ならば警告する。@option{-Wextra}と@option{-fsized-deallocation}の時に警告する。

@item -Wsizeof-pointer-div
@opindex Wsizeof-pointer-div
@opindex Wno-sizeof-pointer-div
ポインタサイズを要素サイズで割る2つのsizeof式の疑わしい除算について警告する。これは、配列サイズを計算する通常の方法だが、ポインタで正しく機能しない。 この警告は、例えば@code{sizeof(ptr)/ sizeof(ptr [0])}について、@code{ptr}が配列ではなくポインタであると警告する。 この警告は@option{-Wall}によって有効になる。

@item -Wsizeof-pointer-memaccess
@opindex Wsizeof-pointer-memaccess
@opindex Wno-sizeof-pointer-memaccess
引数が@code{sizeof}を使用する場合で、特定の文字列とメモリの組み込み関数について疑わしい長さパラメータを警告する。 この警告は、例えば、@code{ptr}が配列でなく、ポインタである場合の@code{memset (ptr, 0, sizeof (ptr));}で、可能な修正を示唆している場合や、@code{memset(ptr、0、sizeof ＆foo、ptr、sizeof(＆foo));}についてである。@option{-Wsizeof-pointer-memaccess}は、ソース配列の@code{sizeof}表現を制限として指定した@code{strncat}や@code{strncpy}のような制限文字列コピー関数の呼び出しについても警告する。 たとえば、次の関数では、@code{strncat}を呼び出すと、ソース文字列のサイズが範囲として指定されます。 それはほぼ間違いであり、呼び出しは診断される。
@smallexample
void make_file (const char *name)
@{
  char path[PATH_MAX];
  strncpy (path, name, sizeof path - 1);
  strncat (path, ".text", sizeof ".text");
  @dots{}
@}
@end smallexample

@option{-Wsizeof-pointer-memaccess}オプションは@option{-Wall}で有効になる。

@item -Wsizeof-array-argument
@opindex Wsizeof-array-argument
@opindex Wno-sizeof-array-argument
@code{sizeof}演算子が関数定義の配列として宣言されているパラメータに適用されていると警告する。この警告はCとC++プログラムではデフォルトである。

@item -Wmemset-elt-size
@opindex Wmemset-elt-size
@opindex Wno-memset-elt-size
疑わしい@code{memset}組み込み関数への呼び出しを警告する。もし最初の引数が配列への参照で、
三番目の引数が要素数と等しいが、メモリ内での配列サイズと等しくない場合。これはユーザが要素サイズで掛け忘れたことを示している。この警告は@option{-Wall}で有効になる。

@item -Wmemset-transposed-args
@opindex Wmemset-transposed-args
@opindex Wno-memset-transposed-args
@code{memset}組み込み関数の疑わしい呼び出しを、もし第2引数が0でなく第3引数が0ならば警告する。
これは例えば、@code{memset (buf, sizeof buf, 0)}について警告し、おそらく代わりに
@code{memset (buf, 0, sizeof buf)}を意図していたであろう。診断は第３引数が定数0の時だけ生成される。
もしそれが0へと変換される式であるか、ある型への0のキャストであるなどならば、ユーザが非キスを間違えたことは
ずっとありそうもないので、警告は生成されない。この警告は@option{-Wall}で有効になる。

@item -Waddress
@opindex Waddress
@opindex Wno-address
メモリアドレスの疑わしい使う方について警告する。これは@code{void func(void); if (Func)}のような条件式での関数のアドレスの使用、
@code{if (x == "abc")}のような、文字列定数のメモリアドレスに対する比較を含む。そのような仕様は典型的にはプログラマの誤りを示している。
関数のアドレスは常に真へと評価されるので、条件式でのそれらの仕様は大抵プログラマが関数呼び出しの括弧を忘れたことを示している。
文字列通しの比較は未指定の振る舞いを起こし、Cでは移植性がないので、プログラマが代わりに@code{strcmp}を使うべきなことを示している。
この警告は@option{-Wall}で有効になる。

@item -Wlogical-op
@opindex Wlogical-op
@opindex Wno-logical-op
式での論理演算子の疑わしい使用について警告する。これはビット単位の演算子がおそらく期待される文脈での論理演算子の使用を含む。
さらに演算子のオペランドが同じ場合も警告する。
@smallexample
extern int a;
if (a < 0 && a < 0) @{ @dots{} @}
@end smallexample

@item -Wlogical-not-parentheses
@opindex Wlogical-not-parentheses
@opindex Wno-logical-not-parentheses
比較の左辺値使われていない論理について警告する。このオプションはもし右辺値が真偽値の時は警告しない。その目的は
以下の様な疑わしいコードを検出することである。
@smallexample
int a;
@dots{}
if (!a > 1) @{ @dots{} @}
@end smallexample

左辺値を括弧で囲うことで抑制できる。
@smallexample
if ((!a) > 1) @{ @dots{} @}
@end smallexample

この警告は@option{-Wall}で有効になる。

@item -Waggregate-return
@opindex Waggregate-return
@opindex Wno-aggregate-return
構造体や共用体を返す関数が定義・呼びだされた時に警告する。（配列を返すことができる言語では、それも警告を誘発する）

@item -Wno-aggressive-loop-optimizations
@opindex Wno-aggressive-loop-optimizations
@opindex Waggressive-loop-optimizations
定数回数のループでコンパイラが1つ以上の繰り返しの間に文の中に未定義の振る舞いを検知した場合に警告する。

@item -Wno-attributes
@opindex Wno-attributes
@opindex Wattributes
認識しない属性、変数に適用された関数属性など、予期せぬ@code{__attribute__}が使われた時に警告しない。
これはサポートされた属性の間違った使用のエラーは止めない。

@item -Wno-builtin-declaration-mismatch
@opindex Wno-builtin-declaration-mismatch
@opindex Wbuiltin-declaration-mismatch
組み込み関数が間違ったシグネチャか非関数で宣言されたら警告する。この警告はデフォルトで有効である。

@item -Wno-builtin-macro-redefined
@opindex Wno-builtin-macro-redefined
@opindex Wbuiltin-macro-redefined
いくつかの組み込みマクロが再定義された時に警告しない。これは@code{__TIMESTAMP__}, @code{__TIME__},
@code{__DATE__}, @code{__FILE__}, @code{__BASE_FILE__}の再定義の警告を抑制する。

@item -Wstrict-prototypes @r{(CとObjective-C専用)}
@opindex Wstrict-prototypes
@opindex Wno-strict-prototypes
関数が引数型を指定しないで宣言・定義されたら警告する。（旧式の関数定義は続く宣言は引数型を指定していれば警告なしで受け入れる）

@item -Wold-style-declaration @r{(CとObjective-C専用)}
@opindex Wold-style-declaration
@opindex Wno-old-style-declaration
C標準によれば、宣言での時代遅れの使用を警告する。例えば、@code{static}のような格納クラス指定子が宣言の先頭でないならば警告する。
この警告は@option{-Wextra}でも有効になる。

@item -Wold-style-definition @r{(CとObjective-C専用)}
@opindex Wold-style-definition
@opindex Wno-old-style-definition
旧式の関数定義が使われたら警告する。警告は前のプロトタイプがあっても与えられる。

@item -Wmissing-parameter-type @r{(CとObjective-C専用)}
@opindex Wmissing-parameter-type
@opindex Wno-missing-parameter-type
関数パラメータがK&R式関数での方指定しなしで宣言されている。

@smallexample
void foo(bar) @{ @}
@end smallexample

この警告は@option{-Wextra}でも有効になる。

@item -Wmissing-prototypes @r{(CとObjective-C専用)}
@opindex Wmissing-prototypes
@opindex Wno-missing-prototypes
グローバル関数が前のプロトタイプ宣言なしで定義されていると警告する。
この警告は定義自身がプロトタイプを提供しても発行される。このオプションを使うと
ヘッダファイルに対応するプロトタイプ宣言がないグローバル関数を検知できる。
このオプションは全関数宣言がプロトタイプを提供し、一致しない宣言は前の宣言との衝突ではなくオーバーロードの宣言なので
C++では有効ではない。
C++で失われた宣言を探知するには@option{-Wmissing-declarations}を使う。

@item -Wmissing-declarations
@opindex Wmissing-declarations
@opindex Wno-missing-declarations
グローバル関数が前の宣言なしで定義されていると携行する。定義自身がプロトタイプを提供していてもそうする。
このオプションを使うとヘッダファイルで宣言されていないグローバル関数を検知することができる。
Cでは、前に非プロトタイプの宣言のある関数は警告が発せられない。失われたプロトタイプを探知するには
@option{-Wmissing-prototypes}を使う。C++では、関数テンプレート、インライン関数、匿名名前空間での関数には警告が発せられない。

@item -Wmissing-field-initializers
@opindex Wmissing-field-initializers
@opindex Wno-missing-field-initializers
@opindex W
@opindex Wextra
@opindex Wno-extra
構造体の初期化子であるフィールドが抜けていると警告する。例えば、以下のコードは@code{x.h}が暗黙に0なので、警告を引き起こす。

@smallexample
struct s @{ int f, g, h; @};
struct s x = @{ 3, 4 @};
@end smallexample

このオプションは指示付きの初期化子については警告しないので、以下の修正は警告を引き起こさない。

@smallexample
struct s @{ int f, g, h; @};
struct s x = @{ .f = 3, .g = 4 @};
@end smallexample

Cでは、汎用ゼロ初期化子@samp{@{ 0 @}}については警告しない。:
 
@smallexample
struct s @{ int f, g, h; @};
struct s x = @{ 0 @};
@end smallexample

同様に、C++では空@{ @}の初期化子については警告しない。例えば、

@smallexample
struct s @{ int f, g, h; @};
s x = @{ @};
@end smallexample

この警告は@option{-Wextra}に含まれている。これなしで他の@option{-Wextra}警告を得るには、
@option{-Wextra -Wno-missing-field-initializers}を使う。

@item -Wno-multichar
@opindex Wno-multichar
@opindex Wmultichar
複数文字定数(@samp{'FOOF'})が使われていも警告しない。これは、実装定義値を持ち、移植可能なコードでは使うべきではないので、
通常はユーザコードの誤字を示す。

@item -Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]}
@opindex Wnormalized=
@opindex Wnormalized
@opindex Wno-normalized
@cindex NFC
@cindex NFKC
@cindex character set, input normalization
ISO CとISO C++では、それらが文字の異なるシーケンスであるならば、2つの識別子は異なる。
しかし、時々基本的なASCIIキャラクタセットの外の文字が使われるとき、あなたは同じものに見える2つの異なる文字シーケンスを持つことができる。
混乱を避けるために、同じものに見える2つのシーケンスが同じシーケンスに変えられることを、適用されるとき、確実とするある@dfn{正規化規則}を、
標準のISO 10646は提示する。あなたが正規化されなかった識別子を使っているならば、GCCはあなたに警告することができる;このオプションは、その警告を制御する。

GCCがサポートする4レベルの警告がある。デフォルトは@option{-Wnormalized=nfc}である。そして、ISO 「C」正規化型@dfn{NFC}になり識別子には何でも警告する。
NFCは、大部分の用途のための推薦された形である。それは、@option{-Wnormalized}に等しい。

不幸にも、ISO CとISO C++によって、識別子と認められているが、NFCに変換すると認められない文字がある。すなわち、これらのシンボル移植性のあるCとC++で使い、
すべての識別子をNFCにする方法はない。@option{-Wnormalized=id}は、これらの文字の警告を抑える。関係する標準の将来のバージョンがこれを修正することが望まれる。
そして、それはこのオプションがデフォルトでない理由である。

@option{-Wnormalized=none}または@option{-Wno-normalized}を書くことによって、あなたはすべての文字のために警告のスイッチを切ることができる。
、ある他の（「D」のような）正規化スキームを使っているならば、あなたはこうするべきだけである。なぜならな、さもなければ
見るのが文字通り不可能であるバグを簡単に生じさせることができるからである。

ISO 10646はあるフォントや表示方法では、特にフォーマッティングが適用されると、同一に見えるが異なる意味を持つ
例えば、@code{\u207F}、「上付きラテン小文字N」は上付き文字の場所に置かれた単なる@code{n}のように表示される。
ISO 10646はそれらすべても同様に標準系に変換する@dfn{NFKC}正規化スキームを定義していて、GCCは
@option{-Wnormalized=nfkc}を使っているならNFKCでないコードに警告する。この警告は数字0と混乱するかもしれないという理由で文字Oを含む
すべての識別子を警告するようなものなので、デフォルトではないが、プログラム環境がそれらのもじを区別して表示できないならばローカルコード規約として
役立つかもしれない。

@item -Wno-deprecated
@opindex Wno-deprecated
@opindex Wdeprecated
廃止された機能の使用について警告しない。 @xref{Deprecated Features}.

@item -Wno-deprecated-declarations
@opindex Wno-deprecated-declarations
@opindex Wdeprecated-declarations
@code{deprecated}を使うことで廃止予定としてマークされた関数(@pxref{Function Attributes})、変数(@pxref{Variable Attributes})、
型(@pxref{Type Attributes})について警告しない。

@item -Wno-overflow
@opindex Wno-overflow
@opindex Woverflow
定数式のコンパイル時桁あふれについて警告しない。

@item -Wno-odr
@opindex Wno-odr
@opindex Wodr
リンク時最適化中の単一定義規則違反を警告する。@option{-flto-odr-type-merging}が有効である必要がある。
デフォルトで有効である。

@item -Wopenmp-simd
@opindex Wopenm-simd
ベクトル化コストモデルがユーザによって設定されたOpenMP simdディレクティブを上書きしたら警告する。
@option{-fsimd-cost-model=unlimited}はコストモデルを和らげるために使うことができる。

@item -Woverride-init @r{(CとObjective-C専用)}
@opindex Woverride-init
@opindex Wno-override-init
@opindex W
@opindex Wextra
@opindex Wno-extra
指示付きの初期化子を使った時に副作用のない初期化されたフィールドが上書きされていたら警告する。
(@pxref{Designated Inits, , 指示付きの初期化子}).

この警告は@option{-Wextra}に含まれる。これなしで他の@option{-Wextra}警告を得るには、@option{-Wextra
-Wno-override-init}を使う。

@item -Woverride-init-side-effects @r{(CとObjective-C専用)}
@opindex Woverride-init-side-effects
@opindex Wno-override-init-side-effects
指示付きの初期化子(@pxref{Designated Inits, , 指示付きの初期化子})を使った時に副作用付きの初期化フィールドを
上書きしたら警告する。これはデフォルおで有効である。

@item -Wpacked
@opindex Wpacked
@opindex Wno-packed
構造体がpacked属性を与えられているが、構造体のレイアウトかサイズにpacked属性がなんの効果もない時に警告する。
そのような構造体はあまりない利点のために境界がずれているかもしれない。例えば、このコードでは、
@code{struct bar}の変数@code{f.x}は@code{struct bar}自身はpack属性がないにもかかわらず、境界がずれている。

@smallexample
@group
struct foo @{
  int x;
  char a, b, c, d;
@} __attribute__((packed));
struct bar @{
  char z;
  struct foo f;
@};
@end group
@end smallexample

@item -Wpacked-bitfield-compat
@opindex Wpacked-bitfield-compat
@opindex Wno-packed-bitfield-compat
GCCの4.1、4.2、4.3系列は@code{char}型のビットフィールドの@code{packed}属性を無視する。
これはGCC 4.4では修正されたが、この変更は構造体のレイアウトの違いを引き起こす。
GCCはGCC4.4でそのようなフィールドのオフセットが変わった時に知らせる。
例えば、この構造体でもはや@code{a}フィールドと@code{b}フィールドには4ビットの隙間が存在しない。

@smallexample
struct foo
@{
  char a:4;
  char b:8;
@} __attribute__ ((packed));
@end smallexample

この警告はデフォルトで有効である。この警告を無効にするには、@option{-Wno-packed-bitfield-compat}を使う。

@item -Wpacked-not-aligned @r{(C, C++, Objective-C and Objective-C++ only)}
@opindex Wpacked-not-aligned
@opindex Wno-packed-not-aligned
Warn if a structure field with explicitly specified alignment in a
packed struct or union is misaligned.  For example, a warning will
be issued on @code{struct S}, like, @code{warning: alignment 1 of
'struct S' is less than 8}, in this code:

@smallexample
@group
struct __attribute__ ((aligned (8))) S8 @{ char a[8]; @};
struct __attribute__ ((packed)) S @{
  struct S8 s8;
@};
@end group
@end smallexample

This warning is enabled by @option{-Wall}.

@item -Wpadded
@opindex Wpadded
@opindex Wno-padded
構造体の要素の境界を合わせるためか、構造体全体の境界を合わせるために構造体に隙間を入れていたら警告する。
これが起こった時、隙間を減らして時々構造体をもっと小さくするために構造体のフィールドを並べ替える事が可能である。

@item -Wredundant-decls
@opindex Wredundant-decls
@opindex Wno-redundant-decls
複数の宣言が正当で、なんの変化がない時でも、何かが同じスコープで１つより多くのものが宣言されていたら警告する。

@item -Wno-restrict
@opindex Wrestrict
@opindex Wno-restrict
@code{restrict}修飾パラメータ（またはC++では@code{__ restrict}修飾パラメータ）によって参照されるオブジェクトが別の引数でエイリアスされた場合、またはそのようなオブジェクト間のコピーが重複した場合に警告する。たとえば、以下の@code{strcpy}関数を呼び出しは、最初の文字を最後の4文字に置き換えて文字列を切り詰めようとする。 しかし、呼び出しが終端NULを@code{a[4]}に書き込むため、コピーは重なり、呼び出しは診断される。

@smallexample
void foo (void)
@{
  char a[] = "abcd1234";
  strcpy (a, a + 4);
  @dots{}
@}
@end smallexample
@option{-Wrestrict}オプションは、最適化を行わなくてもシンプルなオーバーラップのインスタンスを検出するが、@option{-O2}以上でうまく動作する。 これは@option{-Wall}に含まれている。

@item -Wnested-externs @r{(CとObjective-C専用)}
@opindex Wnested-externs
@opindex Wno-nested-externs
@code{extern}宣言が関数内に現れたら警告する。

@item -Wno-inherited-variadic-ctor
@opindex Winherited-variadic-ctor
@opindex Wno-inherited-variadic-ctor
基底クラスがC可変長引数コンストラクタをから継承されている時にC++11継承コンストラクタを使うと警告する。
三点文字が継承されないため、この警告はデフォルトでオンである。

@item -Winline
@opindex Winline
@opindex Wno-inline
関数がインラインと宣言されていてもインラインできない時に警告する。
このオプションを使っても、コンパイラはシステムヘッダで宣言されたインライン関数への失敗は警告しない。

コンパイラは関数をインライン化するかどうかを決定するために様々なヒューリスティックを使う。例えば、
コンパイラははインライン化される関数のサイズと現在の関数ですでにされたインラインの量を考慮する。
したがって、ソースプログラムでのの一見ささいな変化が@option{-Winline}で生成される警告を現れたり、消したりする、

@item -Wno-invalid-offsetof @r{(C++とObjective-C++専用)}
@opindex Wno-invalid-offsetof
@opindex Winvalid-offsetof
非POD型の@code{offsetof}マクロの適用の警告を抑制する。2014 C++標準によれば、非標準レイアウト型への@code{offset}の適用は未定義である。
しかし、既存のC++実装では、@code{offsetof}は典型的には意味のある結果を与える。
このフラグは、それらが移植性のないコードを書いていることに気づいていて、それについて警告を無視するほうを故意に選んだユーザーのためである。

@code{offsetof}の制限はC++標準の将来のバージョンでは緩和されうかもしれない。

@item -Wint-in-bool-context
@opindex Wint-in-bool-context
@opindex Wno-int-in-bool-context
@code{if（a <= b ? 2 : 3）}のような、ブール値のコンテキストでの非ブール値整数定数を使った条件式（？:)のような、ブール値が予想される場所での整数値の疑わしい使用を警告する。または、@code{for（a = 0; 1 << a; a ++）;}のような、ブール値のコンテキスト内の符号付きの左シフト整数。同様にデータの種類に関係なく、あらゆる種類の乗算。この警告は@option {-Wall}によって有効になる。

@item -Wno-int-to-pointer-cast
@opindex Wno-int-to-pointer-cast
@opindex Wint-to-pointer-cast
異なるサイズの整数へのポインタへのキャストについての警告を抑制する。C++ではより小さいサイズのポインタ型へのキャストはエラーである。
@option{Wint-to-pointer-cast}はデフォルトで有効である。


@item -Wno-pointer-to-int-cast @r{(CとObjective-C専用)}
@opindex Wno-pointer-to-int-cast
@opindex Wpointer-to-int-cast
ポインタから異なるサイズの整数型へのキャストの警告を抑制する。

@item -Winvalid-pch
@opindex Winvalid-pch
@opindex Wno-invalid-pch
コンパイル済みヘッダ(@pxref{Precompiled Headers})が検索パスに見つかったが使うことができないときに警告する。

@item -Wlong-long
@opindex Wlong-long
@opindex Wno-long-long
@code{long long}型が湯買われた時に警告する。これはISO C90とC++98モードで@option{-Wpedantic}か@option{-Wtraditional}によって有効になる。
警告メッセージを抑制するには、@option{-Wno-long-long}を使う。

@item -Wvariadic-macros
@opindex Wvariadic-macros
@opindex Wno-variadic-macros
可変長マクロがISO C90モードで使われたか、GNU代替構文がISO C99モードで使われたら警告する。これは@option{-Wpedantic}か@option{-Wtraditional}
で有効になる。警告メッセージを抑制するなら、@option{-Wno-variadic-macros}を使う。

@item -Wvarargs
@opindex Wvarargs
@opindex Wno-varargs
@code{va_start}のような可変長引数を扱うためのマクロの疑問な使用法を警告する。これはデフォルトである。警告メッセージを抑制するためには、
@option{-Wno-varargs}を使う。

@item -Wvector-operation-performance
@opindex Wvector-operation-performance
@opindex Wno-vector-operation-performance
ベクトル操作がアーキテクチャのSIMD機能経由で実装されていなければ警告する。主にパフォーマンス調整に役立つ。
ベクトル操作は@code{piecewise}で実装可能であり、それは全ベクトル単位でスカラー演算が実行されることを意味する。
@code{in parallel}は、ベクトル操作がより広い型のスカラーを使って実装されることを意味し、通常ははもっとパフォーマンスがよくなる。
@code{as single scalar}は、ベクトルがスカラー型に合うことを意味する。

@item -Wno-virtual-move-assign
@opindex Wvirtual-move-assign
@opindex Wno-virtual-move-assign
非自明のC++11ムーブ代入演算子で仮想基底から継承されたことの警告を抑制する。これはもし仮想基底が1つ以上の経路で到達可能なら、
複数回ムーブされ。両方のオブジェクトが最終的にムーブされた状態になりうるために危険である。
もしムーブ代入演算子ががムーブされたオブジェクトからのムーブを避けるように書かれているならば、この警告は無効化可能である。

@item -Wvla
@opindex Wvla
@opindex Wno-vla
コードで可変長配列が使われたら警告する。@option{-Wno-vla}は@option{-Wpedantic}から可変長配列の警告を止める。

@item -Wvla-larger-than=@var{n}
このオプションが使われると、コンパイラはサイズが制限されていないか、@var{n}バイト以上になりうる引数によって制限されている使用について警告する。これは@option{-Walloca-larger-than=@var{n}}の動きと同様だが、可変長配列に対して働く。

GCCは既知の値の小さい可変長配列をただの配列に最適化するかもしれず、したがって、そのような配列では警告が発せられないかもしれないことに注意する。

この警告は@option{-Wall}によっては有効にされず、@option{-ftree-vrp}が活性（@option{-O2}以上のデフォルト）のときだけ活性になる。

@option{-Walloca-larger-than=@var{n}}も見よ。

@item -Wvolatile-register-var
@opindex Wvolatile-register-var
@opindex Wno-volatile-register-var
レジスタ変数がvolatileと宣言されていたら警告する。volatile修飾子はレジスタ変数の読み書きを消すかもしれない
すべての最適化を抑制する。この警告は@option{-Wall}で有効である。

@item -Wdisabled-optimization
@opindex Wdisabled-optimization
@opindex Wno-disabled-optimization
要求される最適化パスが無効にされていたら警告する。この警告は一般的にはあなたのコードに何か悪いことがあることを意味するのではない。
単にGCCでの最適化器がコードを効果的に扱うことができないこと意味する。しばしば、問題はコードが大きすぎるか複雑すぎることにある。
GCCは最適化自身が大量の過度の時間を取りそうな場合はプログラムの最適化を拒否する。

@item -Wpointer-sign @r{(CとObjective-C専用)}
@opindex Wpointer-sign
@opindex Wno-pointer-sign
異なる符号性のポインタ引数渡しか代入について警告する。このオプションはCとObjective-Cでのみサポートされている。
これは@option{-Wall}と@option{-Wpedantic}に含まれていて、@option{-Wno-pointer-sign}で無効にできる。

@item -Wstack-protector
@opindex Wstack-protector
@opindex Wno-stack-protector
このオプションは@option{-fstack-protector}が有効の時だけ有効である。それはスタック破壊から守られない関数を警告する。

@item -Woverlength-strings
@opindex Woverlength-strings
@opindex Wno-overlength-strings
C標準で指定された「最小の最大」長より長い文字列定数について警告する。最近のコンパイラは一般的には
標準の最小限度よりずっと長い文字列定数を許すが、とても移植性のあるプログラムは長い文字列を使うのを避けるべきである。

制限は文字列定数連結の@emph{後に}に適用され、最後のNULはカウントしない。C90では、制限は509文字である。
C99では4095に引き上げられた。C++98では規範的な最小最大値が指定されていないので、C++では長すぎる文字列を診断しない。

このオプションは@option{-pedantic}に含まれていて、@option{-Wno-overlength-strings}で無効にできる。

@item -Wunsuffixed-float-constants @r{(CとObjective-C専用)}
@opindex Wunsuffixed-float-constants

接尾辞がないどんな浮動小数点定数にも警告を発する。@option{-Wsystem-headers}と一緒に使った時は
システムヘッダ内のそのような定数に警告する。これはC99への10進浮動小数点拡張からのプラグマ
@code{FLOAT_CONST_DECIMAL64}と一緒に使うコードを準備するときに役立つ。

@item -Wno-designated-init @r{(CとObjective-C専用)}
位置の初期化子が@code{designated_init}属性をマークされた構造体を初期化するために使われたら警告する。

@item -Whsa
コンパイラされた関数かOpenMP構造のためにHSAILが生成されなかった時に警告を発する。

@end table

@node Debugging Options
@section あなたのプログラムをデバッグするオプション
@cindex options, debugging
@cindex debugging information options

GCCにデバッガで使う追加の情報を出力するように伝えるには、殆どの場合で他のオプションに@option{-g}を加える必要があるだけである。

GCCは@option{-O}つきで@option{-g}を使うことができる。最適化コードによって取られた近道は時々驚かせるかもしれない。
あなたが宣言したある変数は全く存在しないかもしれない。制御の流れはあなたが期待する場所から一時的に移動するかもしれない。
ある文は定数の結果を計算しているか、すでに持っている値なので実行されないかもしれない。ある文はループの外に移動したので異なる場所で実行されているかもしれない。
それにもかかわらず、最適化された出力をデバッグすることは可能である。これはバグが有るかもしれないプログラムに最適化器を使うことを
合理的にする。

もし他の最適化オプションを使っていないなら、@option{-Og}を@option{-g}と一緒に使うことを考えよ。(@pxref{Optimize Options})
@option{-O}オプションが全く無いと、デバッグに有用な情報集めるコンパイラパスが全く走らないので、@option{-Og}はよりよいデバッグ経験を起こすかもしれない。

@table @gcctabopt
@item -g
@opindex g
オペレーションシステムのネイティブのフォーマット(stabs, COFF, XCOFF, DWARF)でデバッグ情報を生成する。GDBはこのデバッグ情報で動くことができる。

stabsフォーマットを使う大抵のシステムでは、GDBだけが使うことができる追加のデバッグ情報の使用を@option{-g}は有効にする。この追加の情報は
GDBでのデバッグをより良くするが、他のデバッガをクラッシュさせたり、プログラムの読み込みを拒否させるだろう。もし、追加の情報の生成するかどうかを
制御したいならば、@option{-gstabs+}, @option{-gstabs}, @option{-gxcoff+}, @option{-gxcoff}, @option{-gvms}(下を見よ）を使う。

@item -ggdb
@opindex ggdb
GDBによって使うためのデバッグ情報を生成する。これは利用可能な最も表現力のあるフォーマット
（DWARD, stabs,もしどちらもサポートされていないならネイティブフォーマット）を使い、もし可能ならばGDBで拡張を含むことを意味する。

@item -gdwarf
@itemx -gdwarf-@var{version}
@opindex gdwarf
（もしサポートされているなら）DWARFフォーマットでデバッグ情報を出力する。@var{varsion}は２、３、４、５のどれかでよい。
デフォルトのバージョンはたいていのターゲットで４である。DWARFバージョン５は実験的でしかない。

DWARFバージョン２では、ある移植では巻き戻しテーブルで衝突しないあるDWARF3拡張を要求し、いつも使う。

バージョン4は最大の効果にはGDB 7.0と@option{-fvar-tracking-assignments}を要求する。

GCCはもはやDWARFバージョン1をサポートせず、それはバージョン2以降とかなり異なっている。
歴史的な理由で、他の@option{-fno-dwarf2-cfi-asm}のようなDWARF関連のオプションは名前にDWARFバージョン2への参照を含んでいるが、DWARFの現在サポートされたすべてのバージョンに適用される。

@item -gstabs
@opindex gstabs
（もしサポートされているなら）stabsフォーマットにデバッグ情報をGDB拡張なしで生成する。
これはたいていのBSDシステムでDBXで使われたフォーマットである。MIPS、Alpha、System Vリリース4システムでは、
このオプションはDBXで理解されないstabsデバッグ出力を生成する。System V リリース4システムでは、このオプションは
GNUアセンブラを要求する。

@item -gstabs+
@opindex gstabs+
（もしサポートされているなら）stabsフォーマットにGNUデバッガ(GDB)によってのみ理解されるGNU拡張を使って
デバッグ情報を生成する。これらの拡張の使用はおそらく他のデバッガをクラッシュさせたり、プログラムの読み込みを拒否させたりするだろう。

@item -gxcoff
@opindex gxcoff
（もしサポートされているなら）XCOFFフォーマットにデバッグ情報を生成する。
これはIBM RS/6000システムのDBXデバッガで使われるフォーマットである。

@item -gxcoff+
@opindex gxcoff+
（もしサポートされているなら）XCOFFフォーマットにGNUデバッガ(GDB)によってのみ理解されるGNU拡張を使ってデバッグ情報を生成する。
これらの拡張の使用はおそらく他のデバッガをクラッシュさせたり、プログラムの読み込みを拒否させたりし、GNUアセンブラ(GAS)以外のアセンブラを
エラーで失敗させるだろう。

@item -gvms
@opindex gvms
（もしサポートされているなら）Alpha/VMSデバッグフォーマットにデバッグ情報を生成する。これはAlpha/VMSシステムのDEBUGによって使われるフォーマットである。

@item -g@var{level}
@itemx -ggdb@var{level}
@itemx -gstabs@var{level}
@itemx -gxcoff@var{level}
@itemx -gvms@var{level}
デバッグ情報を要求し、@var{level}でどのくらい多くの情報かを指定する。デフォルトのレベルは2である。

レベル0はデバッグ情報を全く生成しない。したがって、@option{-g0}は@option{-g}を反転させる。

レベル1は最小の情報を生成し、デバッグする計画のないプログラムの部分でバックトレースを生成するのに十分な量である。
これは関数、外部変数、行番号表の記述を含むが、ローカル変数の情報はない。

レベル3は、プログラム中の全マクロ定義のような、追加の情報を含む。あるデバッガは@option{-g3}を使った時にマクロ展開をサポートする。

@option{-gdwarf}は@option{-gdwarf-@var{level}}との混乱を避けるために、デバッグレベルの連結を受理しない。代わりにDWARFデバッグレベルを変えるためには
追加の@option{-g@var{level}}を使う。

@item -feliminate-unused-debug-symbols
@opindex feliminate-unused-debug-symbols
実際に使われているシンボルのみに対して、（もしサポートされていたら）stabsフォーマットでデバッグ情報を生成する。

@item -femit-class-debug-always
@opindex femit-class-debug-always
C++クラスのデバッグ情報を単一オブジェクトファイルに生成する代わりに、クラスを使っている全オブジェクトファイルに生成する。
このオプションを使用すると2のベキの単位でデバッグ情報のサイズを増やすので、
GCCがクラスのためにデバッグ情報を通常発する方法を取り扱うことができないデバッガだけで、このオプションが使われるべきである。

@item -fno-merge-debug-strings
@opindex fmerge-debug-strings
@opindex fno-merge-debug-strings
リンカに異なったオブジェクトファイルで同一のデバッグ情報で文字列をマージしないように伝える。マージはすべてのアセンブラとリンカでサポートしているわけではない。
マージはリンク処理時間を増やす代わりに出力ファイルのデバッグ情報のサイズを減らす。マージはデフォルトで有効である。

@item -fdebug-prefix-map=@var{old}=@var{new}
@opindex fdebug-prefix-map
ディレクトリ@file{@var{old}}にあるファイルをコンパイルするときは、そのファイルがディレクトリ@file{@var{new}}にあるかのようにデバッグ情報を記述する。 これは、ビルド時のパスをデバッグ情報のインストール時のパスに置き換えるために使用できる。 @var{new}に@file{.}を使用することによって、絶対パスを相対パスに変更することもできる。 これは場所に依存しないより再現性の高いビルドを提供することができるが、GDBにソースファイルの場所を指示するための追加のコマンドが必要になることがある。 @option {-ffile-prefix-map}も参照せよ。

@item -fvar-tracking
@opindex fvar-tracking
変数追跡パスを走らせる。それはどの変数がコードのそれぞれの場所で記録されるかを計算する。
（もしデバッグ情報書式がこの情報をサポートしているなら）それからよりよいデバッグ情報が生成される。

最適化あり(@option{-Os},@option{-O}, @option{-O2}, @dots{})、デバッグ情報(@option{-g})ありコンパイルし、
デバッグ情報書式がサポートしている時はデフォルトで有効である。

@item -fvar-tracking-assignments
@opindex fvar-tracking-assignments
@opindex fno-var-tracking-assignments
最適化でのデバッグ情報を向上させようとして、コンパイルの初期でユーザ変数への代入に注釈をつけ、
注釈をコンパイルの最後まで引き継ごうとする。これとともに@option{-gdwarf-4}を使うことが推奨される。

たとえ変数追跡が使用不能であるとしても使用可能にされることができ、その場合には、注釈は作成されて維持されるが、終わりに捨てられる。
デフォルトで、選択的なスケジューリングが使用可能にされるとき以外は、このフラグは@option{-fvar-tracking}と共に使用可能にされる。

@item -gsplit-dwarf
@opindex gsplit-dwarf
できるだけ多くのDWARFデバッグ情報を拡張子@file{.dwo}の別の出力ファイルへと分離する。これは
ビルドシステムがデバッグ情報をリンクするのを避けることを可能にする。このオプションが役立つためには、
@file{.dwo}ファイルをデバッガが読める必要がある。

@item -gpubnames
@opindex gpubnames
DWARF@code{.debug_pubnames}セクションと@code{.debug_pubtypes}セクションを生成する。

@item -ggnu-pubnames
@opindex ggnu-pubnames
GDBインデックスへの変換に適した書式で@code{.debug_pubnames}と@code{.debug_pubtypes}セクションを生成する。
これはGDBインデックスバージョン7を生成できるリンカでのみ役立つ。

@item -fdebug-types-section
@opindex fdebug-types-section
@opindex fno-debug-types-section
DWARFバージョン4以上を使っている時、型DIEをpcode{.debug_info}セクションの一部にする代わりに、
自身の@code{.debug_types}セクションに置けるようにする。リンカが重複を削除できるのでそれらを別の
コンバットセクションに置けばもっと効率的になる。しかし、まだすべてのDWARFコンシューマーが@code{.debug_types}セクションを
サポートしているわけではなく、あるオブジェクトでは@code{.debug_types}が小さいデバッグ情報の代わりに大きく生成する。

@item -grecord-gcc-switches
@itemx -gno-record-gcc-switches
@opindex grecord-gcc-switches
@opindex gno-record-gcc-switches
このスイッチはコード生成に影響するかもしれないコンパイラを実行するのに使ったコマンドラインオプションをDWARFデバッグ情報の
DW_AT_producer属性に追加する。オプションはコンパイラのバージョンとそれぞれを空白で区切って結合される。これはデフォルトで有効である。
オブジェクトファイルにコマンドラインオプションを格納する他の方法は@option{-frecord-gcc-switches}参照。

@item -gstrict-dwarf
@opindex gstrict-dwarf
@option{-gdwarf-@var{version}}で選択された以降のDWARF標準バージョンの拡張の使用を禁止する。
大抵のターゲットでは以降の標準バージョンからの衝突しないDWARF拡張の使用は許されている。

@item -gno-strict-dwarf
@opindex gno-strict-dwarf
@option{-gdwarf-@var{version}}で選択された以降のDWARFバージョン標準バージョンの拡張の使用を許可する。

@item -gas-loc-support
@opindex gas-loc-support
アセンブラが@code{.loc}ディレクティブをサポートしていることをコンパイラに通知する。 その後、アセンブラがDWARF2+行番号テーブルを生成するために使用するかもしれない。
 
アセンブラで生成された行番号テーブルは、コンパイラが生成できるものよりはるかにコンパクトであるため、これが一般に望ましい。

このオプションは、GCCの設定時に、アセンブラでサポートされている場合に、デフォルトで有効になる。
 
@item -gno-as-loc-support
@opindex gno-as-loc-support
DWARF2 +行番号テーブルを生成する場合、GCCにDWARF2+行番号テーブルを内部的に生成させる。

@item gas-locview-support
@opindex gas-locview-support
アセンブラが@code{view}の割り当てをサポートし、@code{.loc}ディレクティブのアサーションチェックをリセットすることをコンパイラに通知する。

このオプションは、GCCの設定時に、アセンブラでサポートされている場合に、デフォルトで有効になる。

@item gno-as-locview-support
@option{-gvariable-location-views}が明示的に要求されている場合、GCCに内部的にビュー番号を割り当てさせる。

@item -gcolumn-info
@itemx -gno-column-info
@opindex gcolumn-info
@opindex gno-column-info
ファイルと行だけでなく、DWARFデバッグ情報に位置情報の列情報を出力する。このオプションはデフォルトで有効になっている。
@item -gstatement-frontiers
@itemx -gno-statement-frontiers
@opindex gstatement-frontiers
@opindex gno-statement-frontiers
このオプションを指定すると、GCCはステートメントの開始時に内部表現のマーカーを作成し、コンパイル時にそれらを大まかに保持して、行番号テーブルの@code{is_stmt}マーカーの出力をガイドするのに使用する。 これは、最適化（@option{-Os}、@option{-O}、@option{-O2}、@dots{}）でコンパイルし、DWARF 2デバッグ情報を通常レベルで出力するときにデフォルトで有効になる。

@item -gvariable-location-views
@itemx -gvariable-location-views=incompat5
@itemx -gno-variable-location-views
@opindex gvariable-location-views
@opindex gvariable-location-views=incompat5
@opindex gno-variable-location-views
行番号テーブルから暗示されるプログレッシブビュー番号で可変ロケーションリストを拡張する。 これにより、たとえその時点で対応するソース位置に関連する命令が存在しなくても、デバッグ情報コンシューマはプログラムの特定の点で状態を検査することが可能になる。 アセンブラで行番号テーブルのビュー番号がサポートされていない場合、コンパイラは行番号テーブルを生成する。これにより、一般に多少コンパクトになる。 拡張された行番号テーブルとロケーションリストは完全に下位互換性があるため、これらの拡張機能を認識していないデバッグ情報コンシューマによって消費される可能性があるが、それらの利点もありません。

これは、@option{-fvar-tracking-assignments}が有効で、@option{-gstrict-dwarf}が有効でない限り、DWARF 2デバッグ情報を通常レベルで出力するときにデフォルトで有効になる。 アセンブラのサポートが利用できない場合、これはまだ有効になっている可能性があるが、GCCに内部行番号テーブルを出力させ、@option{-INTERNAL-reset-location-views}が有効になっていないと、 ロケーションビューが一致しない。

DWARF 5で導入されたロケーションリスト形式と下位互換性のないビュー番号のための提案された表現があり、@option{-gvariable-location-views = incompat5}で有効にできる。 このオプションは将来削除される可能性があり、提案された表現の参照実装としてのみ提供される。 デバッグ情報のコンシューマは、この拡張形式をサポートするとは期待されず、使用不能と判断され、位置リストをデコードできないだろう。

@item -ginternal-reset-location-views
@itemx -gnointernal-reset-location-views
@opindex ginternal-reset-location-views
@opindex gno-internal-reset-location-views
ロケーションビューリストを省略することができるロケーションビューを決定しようとする。 これにより、コンパイラは非常に正確なinsn長さの推定値を必要とするが、必ずしもそうであるとは限らず、ロケーションビューリストをサポートしないアセンブラを使用すると、誤ったビューリストが自動的に生成される可能性がある。 GNUアセンブラはそのようなエラーを@code{view number mismatch}として警告する。 これは、信頼性の高い推定機能を定義するポートでのみ有効になる。

@item -ginline-points
@itemx -gno-inline-points
@opindex ginline-points
@opindex gno-inline-points
インライン関数の拡張デバッグ情報を生成する。 インラインエントリーポイントに位置ビュートラッキングマーカーが挿入されているため、アドレスとビュー番号を計算してデバッグ情報に出力できる。 これはロケーションビューとは独立して有効にすることができる。この場合、ビュー番号は出力されないが、ステートメントフロンティアとともに有効にすることができ、ロケーションビューが有効な場合にのみデフォルトで有効になる。

@item -gz@r{[}=@var{type}@r{]}
@opindex gz
もしサポートされているなら、DWARF書式で圧縮されたデバッグセクションを生成する。
もし@var{type}が与えられないならば、デフォルトタイプは使われたアセンブラとリンカの能力に依存する。
@var{type}は@samp{none}（デバッグセクションを圧縮しない）、@samp{zlib}（ELF gABIフォーマットでzlib圧縮を使う）、
@samp{zlib-gnu}（伝統的なGNU書式でzlib圧縮を使う）のどれかである。もしリンカが圧縮されたデバッグセクションを書くことを
サポートしていないなら、オプションは拒絶される。さもなければ、もしアセンブラはサポートしていないなら、@option{-gz}は
オブジェクトファイルを生成するときに単に無視される。

@item -femit-struct-debug-baseonly
@opindex femit-struct-debug-baseonly
コンパイルのソースファイルの基底名がその構造体が定義されたファイルの基底名と一致するときだけ
構造体風の型のデバッグ情報を生成する。

このオプションはデバッグ情報のサイズを事実上削減するが、デバッガへの型情報の重要な潜在的損失を起こすだろう。
あまり積極的でないオプションは@option{-femit-struct-debug-reduced}参照。もっと詳細な制御は
@option{-femit-struct-debug-detailed}参照。

このオプションはDWARFデバッグ出力でのみ働く。

@item -femit-struct-debug-reduced
@opindex femit-struct-debug-reduced
構造体がテンプレートか、システムヘッダで定義されていないかぎり、コンパイルのソースファイルの基底名が
その構造体が定義されたファイルの基底名と一致するときだけ構造体風の型のデバッグ情報を生成する。

このオプションはデバッグ情報のサイズを事実上削減するが、デバッガへの型情報の重要な潜在的損失を起こすだろう。
もっと積極的なオプションは@option{-femit-struct-debug-baseonly}参照。もっと詳細な制御は
@option{-femit-struct-debug-detailed}参照。

このオプションはDWARFデバッグ出力でのみ働く。

@item -femit-struct-debug-detailed@r{[}=@var{spec-list}@r{]}
@opindex femit-struct-debug-detailed
コンパイラがデバッグ情報を生成する構造体風の型を指定する。
意図は、同じプログラムの範囲内で異なるオブジェクト・ファイルの間で重複の構造体デバッグ情報を減らすことである。

このオプションは大抵の必要性を満たす@option{-femit-struct-debug-reduced}と@option{-femit-struct-debug-baseonly}
の詳細なバージョンである。

指定は以下の構文を持つ@*
[@samp{dir:}|@samp{ind:}][@samp{ord:}|@samp{gen:}](@samp{any}|@samp{sys}|@samp{base}|@samp{none})

オプションの最初の語は直接(@samp{dir:})か間接(@samp{ind:})で使われる構造体への記述を制限する。
構造体型は変数、メンバの型であるときに直接使われる。間接使用は構造体へのポインタを通して使われる。
すなわち、非完全構造体の使用が正当なとき、その使用は間接である。例は
@samp{struct one direct; struct two * indirect;}である。

オプションの2番めの語は普通の構造体(@samp{ord:})か汎用の構造体(@samp{gen:})の記述を制限する。
汎用構造体は少し説明が複雑である。C++では、非明示的なテンプレートクラスの特殊化および、
上記内の非テンプレートクラスである。他のプログラム言語は汎用型を持つが、
@option{-femit-struct-debug-detailed}はまだそれらをサポートしていない。

三番目はコンパイラがデバッグ情報を発すべき構造体のソースファイルを指定する。値@samp{none}と@samp{any}は普通の意味を持つ。
値@samp{base}は型宣言が現れるファイル名の基底が主要コンパイルファイラうの名前の基底を一致しなければならないことを意味する。
実際には、これは@file{foo.c}をコンパイルするとき、デバッグ情報がそのファイルと@file{foo.h}には宣言されているが、他のヘッダファイルにはない
型に対して生成されることを意味する。値@samp{sys}は@samp{base}を満たすか、システムかコンパイラのヘッダで宣言されていることを意味する。

あなたのアプリケーション最適の設定を決定するには実験する必要があるかもしれない。

デフォルトは@option{-femit-struct-debug-detailed=all}である。

このオプションはDWARFデバッグ出力でのみ働く。

@item -fno-dwarf2-cfi-asm
@opindex fdwarf2-cfi-asm
@opindex fno-dwarf2-cfi-asm
GAS@code{.cfi_*}ディレクティブを使う代わりにコンパイラが生成した@code{.eh_frame}セクションとして
DWARFで巻き戻し情報を生成する。

@item -fno-eliminate-unused-debug-types
@opindex feliminate-unused-debug-types
@opindex fno-eliminate-unused-debug-types
通常、DWARF出力を生成するとき、GCCはコンパイルされたソースファイルでどこでも使われていない
型のデバッグシンボルの出力の生成を避ける。時々、コンパイル単位で使ったかどうかにかかわらず、
コンパイル単位で宣言された全型のデバッグ情報を出力するのが役立つかもしれない。
例えば、もし、デバッガであなたのプログラムで実際には使われていない（が宣言されている）
型へ値をキャストしたくなった時など。しかし、より頻繁には、これは多量のスペースの浪費になるだろう。
@end table

@node Optimize Options
@section 最適化を制御するオプション
@cindex optimize options
@cindex options, optimization

これらのオプションを様々な種類の最適化を制御する。

最適化オプションなしでは、コンパイラの目標はコンパイルのコストを削減して、
デバッグは予期する結果を生むようにさせることである。文は独立している。もしプログラムが文の間の
ブレークポイントで止まるなら、どんな変数にも新しい値を代入でき、関数内の他の文へプログラムカウンタを変更でき
ソースコードから期待される正確な結果を得るだろう。

最適化フラグをオンにするとコンパイラはパフォーマンスと・およびコード再うをコンパイル時間とおそらくプログラムをデバッグする可能性と
引き換えに向上させようとする

コンパイラはそのプログラムのち知識に基いて最適化を行う。複数のファイルを一つの出力ファイルに一度にコンパイルすれば
コンパイラはそれぞれをコンパイルするときに全ファイルから得られた情報を使うことができる。

すべての最適化がフラグで直接制御できるわけではない。フラグを持つ最適化だけがこの節でリストされている。

大抵の最適化は@option{-O}レベルがコマンドラインでセットされているときだけ有効になる。さもなければ、個々の最適化フラグが指定されていても
無効にされる。

ターゲットとGCCでがどのように設定されているかに依存して、ここでリストされた他にそれぞれの@option{-O}レベルで有効になる最適化の集合が少し異なる。
GCCを@option{-Q --help=optimizers}で起動することでそれぞれのレベルで有効になる正確な最適化の集合を見つけることができる。
例は@xref{Overall Options}。

@table @gcctabopt
@item -O
@itemx -O1
@opindex O
@opindex O1
最適化する。最適化コンパイルは時間が少しかかり、大きな関数ではかなり多くのメモリを使う。

@option{-O}で、コンパイル時間を大きく使う最適化を行わずに、コンパイラはコードサイズと実行時間を減らそうとする。

@option{-O}は以下の最適化フラグをオンにする
@gccoptlist{
-fauto-inc-dec 
-fbranch-count-reg 
-fcombine-stack-adjustments 
-fcompare-elim 
-fcprop-registers 
-fdce 
-fdefer-pop 
-fdelayed-branch 
-fdse 
-fforward-propagate 
-fguess-branch-probability 
-fif-conversion2 
-fif-conversion 
-finline-functions-called-once 
-fipa-pure-const 
-fipa-profile 
-fipa-reference 
-fmerge-constants 
-fmove-loop-invariants 
-fomit-frame-pointer 
-freorder-blocks 
-fshrink-wrap 
-fshrink-wrap-separate 
-fsplit-wide-types 
-fssa-backprop 
-fssa-phiopt 
-ftree-bit-ccp 
-ftree-ccp 
-ftree-ch 
-ftree-coalesce-vars 
-ftree-copy-prop 
-ftree-dce 
-ftree-dominator-opts 
-ftree-dse 
-ftree-forwprop 
-ftree-fre 
-ftree-phiprop 
-ftree-sink 
-ftree-slsr 
-ftree-sra 
-ftree-pta 
-ftree-ter 
-funit-at-a-time}

@item -O2
@opindex O2
さらに最適化する。GCCは空間・時間のトレードオフが関与しないほぼすべてのサポートされた最適化を行う。
@option{-O}と比較して、これはコンパイル時間と生成されたコードのパフォーマンスの両方を増やす。

@option{-O2}は@option{-O}で指定された最適化フラグすべてをオンにする。それはさらに以下の最適化フラグもオンにする。
@gccoptlist{-fthread-jumps 
-falign-functions  -falign-jumps 
-falign-loops  -falign-labels 
-fcaller-saves 
-fcrossjumping 
-fcse-follow-jumps  -fcse-skip-blocks 
-fdelete-null-pointer-checks 
-fdevirtualize -fdevirtualize-speculatively 
-fexpensive-optimizations 
-fgcse  -fgcse-lm  
-fhoist-adjacent-loads 
-finline-small-functions 
-findirect-inlining 
-fipa-cp 
-fipa-bit-cp 
-fipa-vrp 
-fipa-sra 
-fipa-icf 
-fisolate-erroneous-paths-dereference 
-flra-remat 
-foptimize-sibling-calls 
-foptimize-strlen 
-fpartial-inlining 
-fpeephole2 
-freorder-blocks-algorithm=stc 
-freorder-blocks-and-partition -freorder-functions 
-frerun-cse-after-loop  
-fsched-interblock  -fsched-spec 
-fschedule-insns  -fschedule-insns2 
-fstore-merging 
-fstrict-aliasing 
-ftree-builtin-call-dce 
-ftree-switch-conversion -ftree-tail-merge 
-fcode-hoisting 
-ftree-pre 
-ftree-vrp 
-fipa-ra}

計算gotoを使うプログラムでは@option{-O2}を呼ぶことについての@option{-fgcse}の警告に注意せよ。

@item -O3
@opindex O3
もっと最適化する。@option{-O3}は@option{-O2}によって指定されたすべての最適化をオンにして、以下の最適化フラグもオンにする。
@gccoptlist{-finline-functions 
-funswitch-loops 
-fpredictive-commoning 
-fgcse-after-reload 
-ftree-loop-vectorize 
-ftree-loop-distribution 
-ftree-loop-distribute-patterns 
-floop-interchange 
-floop-unroll-and-jam 
-fsplit-paths 
-ftree-slp-vectorize 
-fvect-cost-model 
-ftree-partial-pre 
-fpeel-loops 
-fipa-cp-clone}

@item -O0
@opindex O0
コンパイル時間を削減してデバッグが期待された結果を得るようにする。これはデフォルトである。

@item -Os
@opindex Os
サイズを最適化する。@option{-Os}はコードサイズを典型的に増やさない@option{-O2}最適化を有効にする。それはコードサイズを削減するように設計された
さらなる最適化も行う。

@option{-Os}は以下の最適化フラグを無効にする。
@gccoptlist{-falign-functions  -falign-jumps  -falign-loops 
-falign-labels  -freorder-blocks  -freorder-blocks-algorithm=stc 
-freorder-blocks-and-partition  -fprefetch-loop-arrays}

@item -Ofast
@opindex Ofast
厳密な標準準拠を無視する。@option{-Ofast}はすべての@option{-O3}最適化を有効にする。
それはすべての標準準拠プログラムで正当なわけではない最適化を有効にする。それは@option{-ffast-math}と、
Fortran固有の@option{-fstack-arrays}、@option{-fmax-stack-var-size}が指定されていない限り@option{-fno-protect-parens}をオンにする。

@item -Og
@opindex Og
デバッグ経験を最適化する。@option{-Og}はデバッグを干渉しない最適化を有効にする。それは標準的な
編集・コンパイル・デバッグサイクルにとっての選択肢のレベルとなる最適化であるべきで、
速いコンパイルとよいデバッグ経験を維持する合理的なレベルを提供する。
@end table

もし、レベル数のありなしにかかわらず、複数の@option{-O}オプションを使うなら、最後のそのようなオプションが有効なものである。

形式@option{-f@var{flag}}のオプションは機種依存のフラグを指定する。大抵のフラグは肯定形と否定形の両方がある。@option{-ffoo}の否定形は
@option{-fno-foo}である。以下のテーブルで、形式の片方だけをリストする。典型的にあなたが使う方である。@samp{no-}を消すか加える事で
他の形式を得ることができる。

以下のオプションは特定の最適化を制御する。それらは@option{-O}で有効にされるか、それと関連しているかである。
以下のフラグをまれな場合に、実行する最適化の「微調整」が望まれる場合に使うことができる。

@table @gcctabopt
@item -fno-defer-pop
@opindex fno-defer-pop
それぞれの関数が返るとすぐに関数呼び出しの引数をポップする。関数呼び出しの後に引数をポップしなければならない機種では、
コンパイラは通常いくつかの関数呼び出しのスタックで引数を計算して一度にポップする。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で無効にされる。

@item -fforward-propagate
@opindex fforward-propagate
RTLでの前方伝搬パスを実行する。このパスは2つの命令を結合しようとして、結果が単純化できるかどうかチェックする。もしループ展開が有効ならば、
2つのパスが実行され、2番めはループ展開の後にスケジュールされる。

このオプションは最適化レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}でデフォルトで有効である。

@item -ffp-contract=@var{style}
@opindex ffp-contract
@option{-ffp-contract=off}は浮動小数点表現構築を無効にする。
@option{-ffp-contract=fast}はもしターゲットがネイティブでサポートしているなら融合乗加算操作の形式のような浮動小数点表現構築を有効にする。
@option{-ffp-contract=on}はもし言語標準が許すなら浮動小数点表現構築をを有効にする。現在は実装されておらず、@option{-ffp-contract=off}と同等に扱う。

デフォルトは@option{-ffp-contract=fast}である。

@item -fomit-frame-pointer
@opindex fomit-frame-pointer
必要がない関数でフレームポインタを省略する。これはフレームポインタの保存、準備、復帰の命令を避ける。それは多くの関数で余分なレジスタを利用可能にする。 

あるターゲットではこのフラグは標準呼び出し列が常にフレームポインタを使い、省略できないので、効果がない。

@option{-fno-omit-frame-pionter}はフレームポインタがすべての関数で使われることを保証しない。あるターゲットでは末端の関数では常にフレームポインタを省略する。

レベル@option{-O}以上で有効である。

@item -foptimize-sibling-calls
@opindex foptimize-sibling-calls
兄弟と末尾再帰呼び出しを最適化する。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -foptimize-strlen
@opindex foptimize-strlen
種々ののC文字列関数（例えば、@code{strlen}, @code{strchr}, @code{Strcpy})とその@code{_FORTIFY_SOURCE}対応物を
より速い代替物でと最適化する。

レベル@option{-O2}, @option{-O3}で有効になる。

@item -fno-inline
@opindex fno-inline
@code{always_inline}属性でマークされたものを除いてインライン関数を展開しない。これは最適化しない時のデフォルトである。

単一の関数は@code{noinline}属性でマークすることでインラインから免除することができる。

@item -finline-small-functions
@opindex finline-small-functions
本体が期待される関数呼び出しコードよりも小さい時（したがってプログラム全体のサイズが小さくなる時）に呼び出し元で統合する。
コンパイラはヒューリスティックにどの関数はこの方法で統合する価値が有るほど小さいかを決定する。
インライン化は、たとえinlineと宣言されていなくても、全関数に適用される。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -findirect-inlining
@opindex findirect-inlining
前のインラインのおかげでコンパイル時に既知のと発見された間接呼び出しもインライン化する。
これは@option{-finline-functions}か@option{-finline-small-functions}オプションによってインライン自身がオンで時のみ効果がある。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -finline-functions
@opindex finline-functions
たとえinlineと宣言されていなくても、インラインで全関数を考える。コンパイラはヒューリスティックにどの関数がこの方法で統合する価値のあるかを決定する。

もし与えられた関数のすべての呼び出しが統合され、関数が@code{static}と宣言されていたら、関数はそれ自身は通常は出力されない。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -finline-functions-called-once
@opindex finline-functions-called-once
すべての一度だけ呼ばれた@code{static}関数を@code{inline}をマークされていなくても呼び出し元へのインライン化と考える。
もし与えられた関数が統合されたなら、関数自身はアセンブラコードとｓていは出力されない。

レベル@option{-O1}, @option{-O2}, @option{-O3}と@option{-Os}で有効になる。

@item -fearly-inlining
@opindex fearly-inlining
@code{always_inline}とマークされたインライン関数とその本体が関数呼び出しオーバーヘッドよりも小さいように見える関数を
@option{-fprofile-generate}計装と本当のインラインパスを行う前にインライン化する。そうすることで
プロファイリングをかなり簡易にして通常は入れ子のラッパ関数の大きな連鎖を持つプログラムのインライン化を高速にする。

デフォルトで有効である。

@item -fipa-sra
@opindex fipa-sra
手続間の集合体のスカラー置換、未使用パラメータの削除、参照渡しのパラメータの値渡しのパラメータへの置換を行う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -finline-limit=@var{n}
@opindex finline-limit
デフォルトでは、GCCはインライン化される関数のサイズを制限する。このフラグは、この制限の粗い制御を可能にする。
@var{n}は擬似命令の数によるインライン化できる関数のサイズである。

インライン化は実際は幾つかのパラメータで制御され、別々に@option{--param @var{name}=@var{value}}を使うことで指定可能である。
@option{-finline-limit=@var{n}}オプションは以下のパラメータのいくつかをセットする。

@table @gcctabopt
@item max-inline-insns-single
は@var{n}/2にセットされる。
@item max-inline-insns-auto
は@var{n}/2にセットされる。
@end table

インライン化を制御する個々のパラメータとそれらのパラメータのデフォルトは文書の下を見よ。

@emph{注意:} デフォルトの振る舞いを起こす@option{-finline-limit}の値はないかもしれない。

@emph{注意:} 擬似命令は、この文脈では、抽象的な関数のサイズの尺度である。それはアセンブリ命令の数を表すわけでは全く無く、
その正確な意味はリリースが変わるごとに変化するかもしれない。

@item -fno-keep-inline-dllexport
@opindex fno-keep-inline-dllexport
これは@option{-fkeep-inline-functions}のよりきめが細かいバージョンである。そして、
@code{dllexport}属性またはdeclspecを使って宣言される関数だけにそれは適用される。
 (@xref{Function Attributes,,関数の属性の宣言})

@item -fkeep-inline-functions
@opindex fkeep-inline-functions
Cで、@code{inline}と宣言された@code{static}関数を、たとえ関数がそのすべての呼び出し元へインライン化されていても生成する。
このスイッチはGNU C90での@code{extern inline}拡張を使った関数には影響しない。C++では、全インライン関数をオブジェクトファイルへ出力する。

@item -fkeep-static-functions
@opindex fkeep-static-functions
関数が使われていなくても、@code{static}関数をオブジェクトファイルへ出力する。

@item -fkeep-static-consts
@opindex fkeep-static-consts
たとえ変数が参照されていなくても、最適化がオン出ない時に@code{static const}と宣言された変数を出力する。

GCCはこのオプションをデフォルトで有効にする。もし最適化がオンになっているかにかかわらず
コンパイラに変数が参照されているかのチェックを強制させたいならば、@option{-fno-keep-static-consts}を使う。
.
@item -fmerge-constants
@opindex fmerge-constants
コンパイル単位を横切って同一の定数（文字列定数と浮動小数点数定数）を併合しようとする。

このオプションはもしアセンブラとリンカがサポートしていたら最適化コンパイルのデフォルトである。
この振る舞いを抑制するには@option{-fno-merge-constants}を使う。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fmerge-all-constants
@opindex fmerge-all-constants
同一の定数と同一の変数を併合しようとする。

このオプションは@option{-fmerge-constants}を含む。@option{-fmerge-constants}に加えて、
これは、例えば、定数で初期化された配列や初期化された定数整数や浮動小数点型の変数でさえ考慮する。
CやC++のような言語はそれぞれの変数が、再帰呼び出しでの同じ変数の複数の実体を含めて、別々の場所を持つことを要求するので、
このオプションを使うと非準拠の振る舞いを起こす。

@item -fmodulo-sched
@opindex fmodulo-sched
最初のスケジューリングパスの直前に振動モジュロスケジューリングを実行する。このパスは最も内側のループを見て
その命令を重なっている別の繰り返しで並べ替える。

@item -fmodulo-sched-allow-regmoves
@opindex fmodulo-sched-allow-regmoves
レジスタ移動が許可されたもっと積極的なSMSベースのモジュロスケジューリングを実行する。
このフラグをセットすることである反依存エッジは削除され、生存範囲解析に基づいたレジスタ移動の生成が発動する。
このオプションは@option{-fmodulo-sched}が有効の時だけ効果がある。

@item -fno-branch-count-reg
@opindex fno-branch-count-reg
レジスタをデクリメントして、ゼロと比較し、その結果に基いて分岐する列を生成する代わりに
カウントレジスタでの「デクリメントと分岐」命令の使用の機会をスキャンするパスの実行を避ける。
このオプションはそのような命令をサポートしたアーキテクチャでのみ意味を持ち、x86、PowerPC、IA-64、S/390を含む。
@option{-fno-branch-count-reg}オプションは他の最適化パスによって導入された生成された命令列からの
デクリメント・分岐命令は削除しないことに注意。

@option{-O1}より高い場合デフォルトで有効である。

デフォルトは@option{-fbranch-count-reg}である。

@item -fno-function-cse
@opindex fno-function-cse
レジスタに関数アドレスを置かない。定数関数を呼ぶそれぞれの命令に関数のアドレスを明示的に含ませる。

このオプションは非効率なコードを生み出すが、アセンブラ出力を変更する奇妙なハックはこのオプションが使われない
時に実行される最適化によって混乱させるかもしれない。

デフォルトは@option{-ffunction-cse}である。

@item -fno-zero-initialized-in-bss
@opindex fno-zero-initialized-in-bss
もしターゲットがBSSセクションをサポートしているなら、GCCはデフォルトで0初期化される変数をBSSに置く。
これは結果のコードで空間を節約できる。

このオプションはあるプログラムが明示的に変数がデータセクションに行くことに頼っている、例えば
結果のコードがそのセクションの始まりを見つける、かつ・またはそれに基づいた仮定をするなどのためにこの振る舞いを切る。

デフォルトは@option{-fzero-initialized-in-bss}である。

@item -fthread-jumps
@opindex fthread-jumps

最初によって包含されるもう一つの比較が見つかる場所に、ジャンプが分岐するかどうか見るためにチェックする最適化を実行する。
もしそうならば、条件が真か偽と既知であるかに依存して、最初の分岐は二番目の分岐の目的地点か、その直前の点へと振り向けられる。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fsplit-wide-types
@opindex fsplit-wide-types
32ビットシステムにおける@code{long long}のように、複数のレジスタを専有する型を使っている時に、レジスタを分割して独立して割り当てる。
これは通常それらの型でもっと良いコードを生成するが、デバッグがより難しくなるかもしれない。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fcse-follow-jumps
@opindex fcse-follow-jumps
共通部分式除去（CSE）で、ジャンプの行き先が他のパスで到達しない時に、ジャンプ命令を通してスキャンする。
例えば、CSEが@code{else}句のある@code{if}文に出会った時、試験された条件が偽ならば、CSEはジャンプを追う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fcse-skip-blocks
@opindex fcse-skip-blocks
これは@option{-fcse-follow-jumps}と同様であるが、CSEにブロックを条件的に飛び越えるジャンプを追いかけさせる。
CSEがelse句のない単純な@code{if}文に出会ったならば、@option{-fcse-skip-blocks}は@code{if}の本体の周りのジャンプを追いかけさせる。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -frerun-cse-after-loop
@opindex frerun-cse-after-loop
ループ最適化の後の共通部分式除去の再実行を行う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fgcse
@opindex fgcse
大域共通部分式除去パスを行う。このパスは大域定数とコピーの伝搬も行う。

@emph{_注意_：} GCC拡張の計算gotoを使ったプログラムをコンパイルするときは、
大域共通部分式除去パスをコマンドラインで@option{-fno-gcse}を加える事で無効にしたほうがよい実行時パフォーマンスを得るかもしれにあ。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fgcse-lm
@opindex fgcse-lm
@option{-fgcse-lm}が有効の時、大域共通部分式除去は自分自身へのストアによって殺されるのみのロードを移動させようとする。
これはロード・ストア列を含むループがループの外でロードし、ループ内でコピー・ストアすることを可能にする。

@option{-fgcse}が有効の時デフォルトで有効である。

@item -fgcse-sm
@opindex fgcse-sm
@option{-fgcse-sm}が有効の時、ストア移動パスが大域共通部分式除去の後に走る。このパスはストアをループの外に移動しようとする。
@option{-fgcse-lm}と組み合わせて使うとき、ロード・ストア列を含むループはループの前にロードし、ループの後にストアすることを可能にする。

どの最適化レベルでも有効でない。

@item -fgcse-las
@opindex fgcse-las
@option{-fgcse-las}が有効の時、大域共通部分式除去パスが同じメモリ場所へのストアの直後の冗長なロードを除去する。
（部分的・完全に冗長なものの両方）

どの最適化レベルでも有効でない。

@item -fgcse-after-reload
@opindex fgcse-after-reload
@option{-fgcse-after-reload}が有効になる時、冗長ロード除去パスがリロードの後に行われる。このパスの目的は
冗長なこぼれを片付けることである。

@item -faggressive-loop-optimizations
@opindex faggressive-loop-optimizations
このオプションはループ最適化器にループの繰り返し数の境界を引き出すために言語制約を使うように伝える。
これはループコードが例えば整数桁あふれや境界外配列アクセスのような未定義の振る舞いを呼ばないと仮定する。
ループの繰り返しの数の境界はループ展開とループ剥がし、ループ脱出テスト最適化によって使われる。
このオプションはデフォルトで有効である。

@item -funconstrained-commons
@opindex funconstrained-commons
このオプションはコンパイラに共通ブロック（例えば、Fortran）で宣言された変数が後でより長い後端の配列で上書きされるかもしれないと伝える。
これは配列の境界を知っているかに依存するある最適化を防ぐ。

@item -fcrossjumping
@opindex fcrossjumping
Perform cross-jumping transformation.
この変換は等価のコードを統合し、コードサイズを節約する。結果のコードはクロスジャンプなしよりも良くなるかもしれないし、
悪くなるかもしれない。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fauto-inc-dec
@opindex fauto-inc-dec
アドレスのインクリメント・デクリメントとメモリアクセスを結合させる。このパスはこれをサポートする命令のないアーキテクチャでは
常にスキップされる。これをサポートするアーキテクチャの@option{-O}以上でデフォルトで有効である。

@item -fdce
@opindex fdce
RTLでの非到達コード除去（DCE)を実行する。@option{-O}以上でデフォルトで有効である。

@item -fdse
@opindex fdse
RTLでの非到達ストア除去（DSE)を実行する。@option{-O}以上でデフォルトで有効である。

@item -fif-conversion
@opindex fif-conversion
条件付きジャンプを分岐なしの等価物に変換しようとする。これは条件付きムーブ、最小、最大、フラグセット、絶対値命令、標準算術で可能ないくつかの
トリックの使用を含む。サポートするチップでの条件付き実行の使用は @option{-fif-conversion2}で制御される。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で利用可能である。

@item -fif-conversion2
@opindex fif-conversion2
（利用可能な場所で）条件付き実行を使って条件付きジャンプを分岐なしの等価物に変換する。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で利用可能である。

@item -fdeclone-ctor-dtor
@opindex fdeclone-ctor-dtor
C++ ABIはコンストラクタとデストラクタの複数の入り口を必要とする。基底のサブオブジェクト用、完全オブジェクト用、
その後でdelete演算子を呼ぶ仮想デストラクタ用。仮想基底のある階層では、基底と完全の変種は同一で、関数の2つのコピーがあることを意味する。
このオプションで、基底で完全変種は共通の実装を呼ぶサンクに変換される。

@option{-Os}で有効になる。

@item -fdelete-null-pointer-checks
@opindex fdelete-null-pointer-checks
プラグラムが安全にヌルポインタの参照外しができず、アドレス０にはコードもデータ要素もないと仮定する。
このオプションは全最適化レベルでの単純な定数畳み込み最適化を有効にする。それに加え、
GCCでの他の最適化パスはヌルポインタの無用なチェックを除去する大域データフロー解析を制御するために
このフラグを使う。これらはアドレス0へのメモリアクセスは常にトラップを発生させ、したがってもしすでに参照外しされた後で
ポインタがチェックされるなら、nullではありえないと仮定する。

しかし、ある環境ではこの仮定は真ではないことに注意。この振る舞いに依存したプログラムでは、
@option{-fno-delete-null-pointer-checks}を使ってこの最適化を無効にする。

このオプションはたいていのターゲットではデフォルトで有効である。Nios II ELFでは、デフォルトでオフである。
AVRILとCR16、MSP430では、このオプションは完全に無効にされる。

データフロー情報を使うパスは別の最適化レベルで独立して有効にされる。

@item -fdevirtualize
@opindex fdevirtualize
仮想関数の呼び出しを直接呼び出しへ変換しようとする。これは手続き内と間接インライン化
(@option{-findirect-inlining})と手続間定数伝搬(@option{-fipa-cp})の一部としての手続間の両方で
行われる。
レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fdevirtualize-speculatively
@opindex fdevirtualize-speculatively
仮想関数の呼び出しを不確かな直接呼び出しに変換しようとする。
型継承グラフの解析に基づいて、与えられた呼び出しのためにありそうな目標のセットを決定する。
セットが小さく、望ましくはサイズ１ならば、直接的および間接的な呼び出しのいずれかに決定している条件文に呼び出しを変える。
不確かな呼び出しは、より多くの最適化（インライン化のような）を使用可能にする。
それらが更なる最適化の後役に立たないようであるとき、それらは原形に戻される。

@item -fdevirtualize-at-ltrans
@opindex fdevirtualize-at-ltrans

ローカル変換モードでリンク時最適化器を走らせるとき、積極的な非仮想化のために必要とされる余分の情報を流れ出させる。
このオプションはより多くの非仮想化を使用可能にするが、かなり流れられたデータのサイズを増やす。この理由で、
それはデフォルトで無効にされている。

@item -fexpensive-optimizations
@opindex fexpensive-optimizations
いくつかの比較的高価な小さい最適化を行う。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -free
@opindex free
冗長な拡張命令を取り除こうとする。これは特にx86-64アーキテクチャで有用である。それは32ビットの下半分に書くと
暗黙に64ビットレジスタに0拡張される。

レベル@option{-O2}, @option{-O3}, @option{-Os}でAlpha, AArch64, x86で有効である。

@item -fno-lifetime-dse
@opindex fno-lifetime-dse
C++では、オブジェクトの値はその生存期間内での変更しか影響しない。コンストラクタが始まった時、
オブジェクトは不定値を持っていて、生存期間中の変更はオブジェクトが破壊された時に消える。
通常非到達ストア除去はこれの利点を使う。もしあなたのコードがオブジェクトの生存期間を超えて存在する領域のオブジェクトの値に
依存しているならば、このフラグをつかってこの最適化を無効にすることができる。コンストラクタが始まる前のストアを保持するが
（例えば、あなたのnew演算子がオブジェクト領域をクリアするので）、デストラクタの後ではオブジェクトが死んでいるとまだ扱うためには、
@option{-flifetime-dse=1}を使う。デフォルトの振る舞いは明示的に@option{-flifetime-dse=2}で選択できる。
@option{-flifetime-dse=0}は@option{-fno-lifetime-dse}と等価である。

@item -flive-range-shrinkage
@opindex flive-range-shrinkage
レジスタ生存範囲縮小を通してレジスタ圧を減らそうとする。これは小さいか適度なサイズのレジスタセットを持つ高速なプロセッサには有用である。

@item -fira-algorithm=@var{algorithm}
@opindex fira-algorithm
統合レジスタアロケータに指定された色付アルゴリズムを使用する。@var{algorithm}引数は
、Chowの優先順位色付けを指定する@samp{priority}、Chaitin-Briggs色付けを行う@samp{CB}にできる。
Chaitin-Briggs色付けはすべてのアーキテクチャで実装されているわけではないが、サポートされているターゲットでは、
より良いコードを生成するのでデフォルトである。

@item -fira-region=@var{region}
@opindex fira-region
統合レジスタアロケータの指定された領域を使う。@var{region}は以下のものの一つであるべきである。

@table @samp

@item all
レジスタ割当領域として全ループを使う。これは小さく、かつ・または不規則なレジスタセットでは最良のコードを生成する。

@item mixed
領域として小さいレジスタ圧のループ以外のすべてのループを使う。これは通常大抵のケースで大抵のアーキテクチャで最良のコードを生成し、
スピードの最適化でコンパイルするとき(@option{-O}, @option{-O2}, @dots{})のデフォルトである。

@item one
単一の領域として全関数を使う。これは典型的には最小のコードサイズを起こすので、@option{-Os}か@option{-O0}でデフォルトである。

@end table

@item -fira-hoist-pressure
@opindex fira-hoist-pressure
表現を巻き上げる決定のために、コードを巻き上げるパスにおいてレジスタ圧を評価するために、IRA（統合レジスタアロケータ）を使う。
このオプションはより小さいコードを起こすが、それはコンパイラを遅くすることがある。

このオプションはすべてのターゲットでレベル@option{-Os}で有効になる。

@item -fira-loop-pressure
@opindex fira-loop-pressure
ループ不変を動かす決定のためにループでレジスタ圧を評価するためにIRA（統合レジスタアロケータ）を使う。
このオプションは通常大きなレジスタファイル（＞＝３２レジスタ）をもつ機種ではより速く、より小さいコードコードを生成するが、、
コンパイラを遅くすることがある。

このオプションはあるターゲットでレベル@option{-O3}で有効になる。

@item -fno-ira-share-save-slots
@opindex fno-ira-share-save-slots
呼び出しを通して生存する呼び出しで使われるハードレジスタの保存で使うスタックスロットの共有を無効にする。
それぞれのハードレジスタ別のスタックスロットを持ち、結果の関数のスタックフレームを大きくなる。

@item -fno-ira-share-spill-slots
@opindex fno-ira-share-spill-slots
擬似レジスタを割り当てるスタックスロットの共有を無効にする。ハードレジスタがないそれぞれの擬似レジスタは別々のスタックスロットを持ち、
結果の関数のスタックフレームは大きくなる。

@item -flra-remat
@opindex flra-remat
LRAでCFGに影響される再実体化を有効にする。こぼれた擬似レジスタの値をロードする代わり、
LRAは利益があるならば再実体化（再計算）を試みる。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -fdelayed-branch
@opindex fdelayed-branch
もしターゲット機種がサポートしているなら、遅延分岐命令の後の利用可能な命令スロットを活用するために
命令を並べ替えようとする。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fschedule-insns
@opindex fschedule-insns
もしターゲット機種がサポートしているなら、必要なデータが利用不可能なための実行の停止を
除去するために命令を並べ替えようとする。これは遅い浮動小数点演算やメモリーロード命令を持つ機種が
ロードや浮動小数点演算の結果が要求されるまでに他の命令が実行されることを可能とする。

レベル@option{-O2}, @option{-O3}で有効である。

@item -fschedule-insns2
@opindex fschedule-insns2
@option{-fschedule-insns}と同様だが、レジスタ割当が行われた後に追加の命令スケジューリングのパスを要求する。
これは特に比較的小さな数のレジスタとメモリーロード命令が1サイクルよりおおくかかる機種で役立つ。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fno-sched-interblock
@opindex fno-sched-interblock
基本ブロックをまたいで命令をスケジュールしない。通常はレジスタ割当前のスケジュールではデフォルトで有効である。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fno-sched-spec
@opindex fno-sched-spec
非ロード命令の投機的な移動を許可しない。通常はレジスタ割当前のスケジュールではデフォルトで有効である。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fsched-pressure
@opindex fsched-pressure
レジスタ割当前のレジスタ圧感知の命令スケジューリングを有効位にする。
これはレジスタ割当前のスケジューリングが有効の時だけ意味を持つ。すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。
このオプションの使用は利用可能なレジスタの数を超えてレジスタ圧が増え、続いてレジスタ割当で溢れることを防ぎ
コード生成を向上させサイズを削減する。

@item -fsched-spec-load
@opindex fsched-spec-load
あるロード命令の投機的移動を許可する。これはレジスタ割当前のスケジューリングが有効の時だけ意味を持つ。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fsched-spec-load-dangerous
@opindex fsched-spec-load-dangerous
もっとロード命令の投機的移動を許可する。これはレジスタ割当前のスケジューリングが有効の時だけ意味を持つ。
すなわち、@option{-fschedule-insns}でか、@option{-O2}以上。

@item -fsched-stalled-insns
@itemx -fsched-stalled-insns=@var{n}
@opindex fsched-stalled-insns
第2スケジューリングパスの間に準備リストへ停止中の命令のキューから（もし存在すれば）どのくらい多くの命令を
時期早々に移動できるかを定義する。@option{-fno-sched-stalled-insns}は時期早々には一つも命令を移動できないことを意味し、
@option{-fsched-stalled-insns=0}は時期早々に移動できるキューされた命令の移動個数に制限がないことを意味する。
値のない@option{-fsched-stalled-insns}は@option{-fsched-stalled-insns=1}と等価である。

@item -fsched-stalled-insns-dep
@itemx -fsched-stalled-insns-dep=@var{n}
@opindex fsched-stalled-insns-dep
停止中の命令全体のキューから時期早々に除去する候補である停止中の命令の依存関係をどのくらい多くの
命令グループ（サイクル）で確認するかを定義する。これは第2スケジューリングパスの間でのみ効果があり、
@option{-fsched-stalled-insns}が使われている場合、その場合のみ効果がある。
@option{-fno-sched-stalled-insns-dep}は@option{-fsched-stalled-insns-dep=0}と等価である。
値なしの@option{-fsched-stalled-insns-dep}は@option{-fsched-stalled-insns-dep=1}と等価である。

@item -fsched2-use-superblocks
@opindex fsched2-use-superblocks
レジスタ割当後のスケジューリングで、スーパーブロックスケジューリングを使う。
これは、基本ブロック境界をまたいだ移動を許し、より速いスケジューリングを起こす。
GCCによって使われるすべての機種描写がアルゴリズムから信頼できない結果を避けるのに十分近く
CPUをモデル化するというわけではないので、このオプションは実験的である。

これはレジスタ割当後のスケジューリングでのみ意味を持つ。すなわち、@option{-fschedule-insns2}か
@option{-O2}以上である。

@item -fsched-group-heuristic
@opindex fsched-group-heuristic
スケジューラーでのグループヒューリスティックを有効にする。このヒューリスティックは
スケジュールグループに属する命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-critical-path-heuristic
@opindex fsched-critical-path-heuristic
スケジューラでのクリティカル・パスヒューリスティックを有効にする。このヒューリスティックは
クリティカルパス上の命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-spec-insn-heuristic
@opindex fsched-spec-insn-heuristic
スケジューラでの投機的な命令ヒューリスティックを有効にする。このヒューリスティックは
より大きな依存性の弱点のある投機的命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-rank-heuristic
@opindex fsched-rank-heuristic
スケジューラのランクヒューリスティックを有効にする。このヒューリスティックは
より大きなサイズか頻度の基本ブロックに属する命令を選好する。これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-last-insn-heuristic
@opindex fsched-last-insn-heuristic
スケジューラでの最終命令ヒューリスティックを有効にする。このヒューリスティックは
スケジュールされた最後の命令にあまり依存していない命令を選好する。
これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -fsched-dep-count-heuristic
@opindex fsched-dep-count-heuristic
スケジューラで依存カウントヒューリスティックを有効にする。このヒューリスティックは
それに依存する命令が多い命令を選好する。
これはスケジューリングが有効の時にはデフォルトで有効である。
すなわち、@option{-fschedule-insns}か、@option{-fschedule-insns2}か、@option{-O2}以上である。

@item -freschedule-modulo-scheduled-loops
@opindex freschedule-modulo-scheduled-loops
伝統的なスケジューリングの前にモジュロスケジューリングを実行する。もしループがモジュロでスケジューリングされるなら、
後半のスケジューリングパスはスケジュールを変更させるかもしれない。このオプションを使うことでその振る舞いを制御できる。

@item -fselective-scheduling
@opindex fselective-scheduling
選択的スケジューリングアルゴリズムを使って命令をスケジュールする。選択的スケジューリングは
最初のスケジューラパスの代わりに走る。

@item -fselective-scheduling2
@opindex fselective-scheduling2
選択的スケジューリングアルゴリズムを使って命令をスケジュールする。選択的スケジューリングは
第2スケジューラパスの代わりに走る。

@item -fsel-sched-pipelining
@opindex fsel-sched-pipelining
選択的スケジューリングの間も最も内側のループのソフトウェアパイプライン化を有効にする。
このオプションは@option{-fselective-scheduling}か@option{-fselective-scheduling2}がオンにならないかぎり効果はない。

@item -fsel-sched-pipelining-outer-loops
@opindex fsel-sched-pipelining-outer-loops
選択的スケジューリングの間のループのパイプライン化で外側のループもパイプライン化する。
このオプションは@option{-fsel-sched-pipelining}がオンでない限り効果がない。

@item -fsemantic-interposition
@opindex fsemantic-interposition
ELFのようなあるオブジェクトフォーマットで、動的リンカによるシンボルの挿入を許可する。
これはDSOからエクスポートされたシンボルで、問題の関数や変数が変わるかもしれないという予想でにより、
コンパイラは手続間の伝搬、インライン化、他の最適化ができなくなることを意味する。
この機能は例えば、メモリ割り当て関数をデバッグ実装で書き換えることなどで有用かもしれないが、
コード品質の観点では高くつく。
@option{-fno-semantic-interposition}によって、コンパイラはもし関数の挿入が起こったらならば、
上書きされる関数は正確に同じ意味（と副作用）を持つと仮定する。同様にもし変数の挿入が起こったならば、
変数のコンストラクタは同じであるだろう。フラグは明示的にインラインと宣言された関数（それは意味を変える挿入が決して許されない）
と、明示的に弱く宣言されたシンボルには効果がない。

@item -fshrink-wrap
@opindex fshrink-wrap
関数の先頭ではなく、それを必要とする関数の部分の前にだけ関数プロローグを出す。
このフラグは@option{-O}以上でデフォルトで有効である。

@item -fshrink-wrap-separate
@opindex fshrink-wrap-separate
プロローグとエピローグの別々の部分を個別に縮小してラップし、必要なときにのみ実行するようにする。このオプションはデフォルトではオンになっているが、@option{-fshrink-wrap}もオンになっていてターゲットがこれをサポートしていないと効果はない。

@item -fcaller-saves
@opindex fcaller-saves
関数呼び出しで破壊されるレジスタへの値の割り当てを、そのような呼び出しの前後でレジスタの保存と
復帰の余分な命令を出すことで有効にする。そのような割り当てはそのほうが良いコードを生成しそうなときだけ行われる。

このオプションはある機種でデフォルトで常に有効であり、通常はそのような機種では代わりに使う呼び出しで保持されるレジスタがない。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fcombine-stack-adjustments
@opindex fcombine-stack-adjustments
スタック調整（プッシュとポップ）とスタックメモリ参照を追って、それらを結合できる方法を探そうとする。

@option{-O1}以上でデフォルトで有効である。

@item -fipa-ra
@opindex fipa-ra
呼ばれた関数で使われていないならば、割り当てに呼び出し元保存レジスタを使う。
その場合では、呼び出し前後で保存と復帰をする必要が無い。これは呼ばれた関数が
現在の関数と同じコンパイル単位の一部でそれより前にコンパイルされている時だけ可能である。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fconserve-stack
@opindex fconserve-stack
スタックの使用を最小化しようとする。コンパイラは、それがプログラムを遅くするとしてもスタック空間を
あまり使わなくしようとする。このオプションを@option{large-stack-frame}パラメータに100をセットし、
@option{large-stack-frame-growth}パラメータに400をセットすることを含む。

@item -ftree-reassoc
@opindex ftree-reassoc
木への再連結を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -fcode-hoisting
@opindex fcode-hoisting
コード巻上げを実行する。 コード巻上げは、すべてのパスで実行された式の評価を可能な限り早く関数出口に移動しようとする。これはコードサイズの最適化として特に有用だが、コードスピードにも役立つ。このフラグは、デフォルトでは@option{-O2}以上で有効になっている。

@item -ftree-pre
@opindex ftree-pre
木での部分冗長除去(PRE)を行う。このフラグは@option{-O2}と@option{-O3}でデフォルトで有効である。

@item -ftree-partial-pre
@opindex ftree-partial-pre
部分冗長除去(PRE)をもっと積極的に行う。このフラグは@option{-O3}でデフォルトで有効である。

@item -ftree-forwprop
@opindex ftree-forwprop
木での前方伝搬を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-fre
@opindex ftree-fre
木での完全冗長除去(FRE)を行う。FREとPRESUMEの差はFREとが冗長圧縮を導くすべての経路で計算された式のみ考慮することである。
この解析はPREより速いが、冗長を少ししか検知しない。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-phiprop
@opindex ftree-phiprop
木での条件ポインタからのロードの持ち上げを行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -fhoist-adjacent-loads
@opindex fhoist-adjacent-loads
もしロードが同じ構造体の隣接の場所からでターゲットアーキテクチャが条件付きmove命令を持つならば
if-then-elseの両方の分岐からロードを投機的に持ち上げる。このフラグは@option{-O2}以上でデフォルトで有効である。 

@item -ftree-copy-prop
@opindex ftree-copy-prop
木でのコピー伝搬を行う。このパスは不必要なコピー操作を除去する。
このフラグは@option{-O}以上でデフォルトで有効である。

@item -fipa-pure-const
@opindex fipa-pure-const
pure、constな関数を発見する。@option{-O}以上でデフォルトで有効である。

@item -fipa-reference
@opindex fipa-reference
コンパイル単位を脱出しない静的変数を発見する。@option{-O}以上でデフォルトで有効である。

@item -fipa-pta
@opindex fipa-pta
手続間ポインタ解析と手続間修正・参照解析を行う。このオプションは大きなコンパイル単位で
非常に多いメモリとコンパイル単位時間を起こしうる。どの最適間レベルでもデフォルトで有効にならない。

@item -fipa-profile
@opindex fipa-profile
手続間プロファイル伝搬を行う。冷たい関数からのみ呼ばれた関数を冷たいとマークする。
一度呼ばれた関数（@code{cold}、 @code{noreturn}、静的コンストラクタとデストラクタ）は識別される。
冷たい関数と一度実行される関数のループのない部分はサイズで最適化される。
@option{-O}以上でデフォルトで有効である。

@item -fipa-cp
@opindex fipa-cp
手続間定数伝搬を行う。この最適化は関数へ渡される値がいつ定数であるかを決定するためにプログラムを解析して、
それのそって最適化する。この最適化はもしアプリケーションが関数に定数を渡していたらかなりパフォーマンスを向上させうる。
このフラグは@option{-O2}, @option{-Os} and @option{-O3}でデフォルトで有効である。

@item -fipa-cp-clone
@opindex fipa-cp-clone
手続間定数伝搬をより強くするために関数複製を行う。有効になると、手続間定数典範は外部で可視の関数が定数引数で呼びうる良きに関数複製を行う。
この最適化が関数の複数のコピーを作りうるので、コードサイズがかなり増えるかもしれない。
(@option{--param ipcp-unit-growth=@var{value}}を見よ。)
このフラグは@option{-O3}でデフォルトで有効である。

@item -fipa-cp-alignment
@opindex -fipa-cp-alignment
有効の時、この最適化はよりよいベクトル化と文字列操作をサポートするために関数パラメータの境界を伝搬する。

このフラグは@option{-O2}と@option{-Os}でデフォルトで有効である。@option{-fipa-cp}が有効である必要がある。

@item -fipa-icf
@opindex fipa-icf
関数と読み込み専用変数の同一コード畳み込みを行う。この最適化はコードサイズを削減して、
関数を異なる名前の同様物で置換することでスタック巻き戻しを乱すかもしれない。最適化あはリンク時最適化が有効の時に
もっと効果的に働く。

振る舞いはGoldリンカICF最適化と似ているにもかかわらず、GCC ICFは異なるレベルで働きそれ故に最適化は同じではない。
GCCによってのみ見つかる同一性もGoldによってのみ見つかる同一性もある。

このフラグは@option{-O2}と@option{-Os}でデフォルトで有効である。

@item -fisolate-erroneous-paths-dereference
@opindex fisolate-erroneous-paths-dereference
nullポインタの被参照のために間違っているか未定義の振る舞いを起こす経路を検知する。
主要制御フローからそれらのパスを孤立させてエラーか未定義の振る舞いのある文をトラップに変換する。
このフラグは@option{-O2}以上でデフォルトで有効で@option{-fdelete-null-pointer-checks}が有効かどうかにも依存している。

@item -fisolate-erroneous-paths-attribute
@opindex fisolate-erroneous-paths-attribute
@code{returns_nonnull}か@code{nonnull}によって禁止されている方法で使われているnull値のために
間違っているか未定義の振る舞いを起こすパスを検知する。主要制御フローからそれらのパスを孤立させて
誤っているか未定義の振る舞いの文をトラップに変換する。これは現在有効でないが、
将来は@option{-O2}で有効になるかもしれない。

@item -ftree-sink
@opindex ftree-sink
木でストアを前方に移動する。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-bit-ccp
@opindex ftree-bit-ccp
木で疎条件ビット定数伝搬を行い、ポインタ境界情報を伝搬させる。
このパスは局所スカラー変数でのみ行われ、@option{-O}以上でデフォルトで有効である。
それは@option{-ftree-ccp}が有効である必要がある。

@item -ftree-ccp
@opindex ftree-ccp
木での疎条件定数伝搬(CCP)を行う。このパスは局所スカラー変数でのみ行われ、@option{-O}以上でデフォルトで有効である。

@item -fssa-backprop
@opindex fssa-backprop
定義を単純化するために定義連鎖を上がって値の使用についての情報を伝搬する。例えば、このパスは
もし値の符号が決して問題にならないなら符号操作を削る。このフラグは@option{-O}以上でデフォルトで有効である。

@item -fssa-phiopt
@opindex fssa-phiopt
条件コードを最適化するためにSSA PHIノードでのパターンマッチを行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-switch-conversion
@opindex ftree-switch-conversion
switchでの単純な初期化からスカラー配列からの初期化への変換を行う。
このフラグは@option{-O2}以上でデフォルトで有効である。

@item -ftree-tail-merge
@opindex ftree-tail-merge
同一コード列を検索する。見つかった時は、それを他の物へのジャンプに置換する。
この最適化は末端マージやクロスジャンプとして知られている。このフラグは@option{-O2}以上で
デフォルトで有効になる。このパスでのコンパイル時間は@option{max-tail-merge-comparisons}パラメータと
@option{max-tail-merge-iterations}パラメータを使って制限できる。

@item -ftree-dce
@opindex ftree-dce
木での未実行コード除去（DCE)を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-builtin-call-dce
@opindex ftree-builtin-call-dce
@code{errno}をセットするかもしれないがそれ以外では副作用のない組み込み関数の呼び出しに対する
条件付き未実行コード除去(DCE)を行う。このフラグは@option{-O}以上で@option{-Os}が指定されていないならば
デフォルトで有効である。

@item -ftree-dominator-opts
@opindex ftree-dominator-opts
ドミネーター・ツリー横断に基づいた様々な単純なスカラー整理（構築・コピー伝搬、冗長除去、範囲伝搬と式の単純化）
を行う。これは（ジャンプからジャンプを削減するための）ジャンプ・スレッディングも行う。
このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-dse
@opindex ftree-dse
木での死んだストアの除去（DSE)を行う。死んだストアは間のロードがなく、後で他のストアによって上書きされるメモリの場所への
ストアである。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-ch
@opindex ftree-ch
木でのループヘッダコピーを行う。これはコード移動最適化の効果を向上させるので有益である。それはジャンプも節約する。
このフラグは@option{-O}以上でデフォルトで有効である。これは、通常コードサイズを増加させるので、@option{-Os}では有効ではない。

@item -ftree-loop-optimize
@opindex ftree-loop-optimize
木でのループ最適化を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-loop-linear
@itemx -floop-strip-mine
@itemx -floop-block
@opindex ftree-loop-linear
@opindex floop-strip-mine
@opindex floop-block
ループ入れ子最適化を行う。@option{-floop-nest-optimize}と同じである。この変換を使うためには、
GCCはGraphiteループ変換基盤を有効にするために@option{--with-isl}で設定されていなければならない。

@item -fgraphite-identity
@opindex fgraphite-identity
グラファイトの同一性変換を有効にする。すべてのSCoPで多面体的な表現を生成し、gimpleに変換して戻す。
@option{-fgraphite-identity}を使うことでGIMPLE -> GRAPHITE -> GIMPLEのコストや利点をチェックすることができる。
ある添字分割や、ループでの非実行コード除去のようのな最小の最適化もコード生成islによって行われる。

@item -floop-nest-optimize
@opindex floop-nest-optimize
islに基いてループ入れ子最適化器を有効にする。これはPluto最適化アルゴリズムにもどついた汎用ループ入れ子最適化器である。
それはデータ局所性と並列性用に最適化されたループ構造体を計算する。このオプションは実験的である。

@item -floop-parallelize-all
@opindex floop-parallelize-all
並列化できるループを識別できるGraphiteデータ依存解析を使う。ループを並列するのに有益であるとチェックしないで
依存を運ぶループを含まないと解析できるすべてのループを並列化する。

@item -ftree-coalesce-vars
@opindex ftree-coalesce-vars
SSA表現の外へプログラムを変換する間、単なるコンパイラの一時値の代わりに、
異なるユーザ定義変数の合体バージョンによってコピーを削減しようとする。
これは@option{-fno-var-tracking-assignments}でコンパイルされた最適化されたプログラムをデバッグする能力を
ひどく制限するかもしれない。否定形で、このフラグはユーザ変数のSSA合体を防ぐ。このオプションは
最適化が有効ならばデフォルトで有効であり、さもなければほとんど行わない。

@item -ftree-loop-if-convert
@opindex ftree-loop-if-convert
最も内側のループでの条件付きジャンプを分岐なしの等価物に変換しようとする。
意図はベクトル化パsうはループを扱う能力を向上させるために最も内側のループから制御フロー
を取り除くことである。これはベクトル化が有効ならばデフォルトで有効である。

@item -ftree-loop-if-convert-stores
@opindex ftree-loop-if-convert-stores
メモリ書き込みを含む条件付きジャンプも変換しようとする。この変換は条件付きメモリ書き込みを無条件メモリ書き込みに
変換するのでマルチスレッドプログラミングでは安全ではなくなりうる。例えば、
@smallexample
for (i = 0; i < N; i++)
  if (cond)
    A[i] = expr;
@end smallexample
は
@smallexample
for (i = 0; i < N; i++)
  A[i] = cond ? expr : A[i];
@end smallexample
へと変換され、潜在的なデータ競合を引き起こす。

@item -ftree-loop-distribution
@opindex ftree-loop-distribution
ループ分散を行う。このフラグは大きなループ本体でのキャッシュパフォーマンスを向上させ、
並列化やベクトル化のようなさらなるループ最適化を可能にする。例えば、ループ
@smallexample
DO I = 1, N
  A(I) = B(I) + C
  D(I) = E(I) * F
ENDDO
@end smallexample
は
@smallexample
DO I = 1, N
   A(I) = B(I) + C
ENDDO
DO I = 1, N
   D(I) = E(I) * F
ENDDO
@end smallexample
へと変換される。

@item -ftree-loop-distribute-patterns
@opindex ftree-loop-distribute-patterns
ライブラリに呼び出しで生成されるコードになりうるパターンのループ分散を実行する。
このフラグは、@option{-O3}でデフォルトで有効である
。
このパスは初期化ループを分散させて、memset 0への呼び出しを生成する。例えば、ループ
@smallexample
DO I = 1, N
  A(I) = 0
  B(I) = A(I) + I
ENDDO
@end smallexample
は
@smallexample
DO I = 1, N
   A(I) = 0
ENDDO
DO I = 1, N
   B(I) = A(I) + I
ENDDO
@end smallexample
へと変換され、初期化ループはmemset 0への呼び出しへと変換される。

@item -floop-interchange
@opindex floop-interchange
Perform loop interchange outside of graphite.  This flag can improve cache
performance on loop nest and allow further loop optimizations, like
vectorization, to take place.  For example, the loop
@smallexample
for (int i = 0; i < N; i++)
  for (int j = 0; j < N; j++)
    for (int k = 0; k < N; k++)
      c[i][j] = c[i][j] + a[i][k]*b[k][j];
@end smallexample
is transformed to
@smallexample
for (int i = 0; i < N; i++)
  for (int k = 0; k < N; k++)
    for (int j = 0; j < N; j++)
      c[i][j] = c[i][j] + a[i][k]*b[k][j];
@end smallexample
このフラグは@option{-O3}でデフォルトで有効になる。

@item -floop-unroll-and-jam
@opindex floop-unroll-and-jam
実現可能なループでアンロールとジャム変換を適用する。 ループネストでは、外部ループを何らかの要因で展開し、結果として得られる複数の内部ループを融合する。 このフラグはデフォルトで@option {-O3}で有効になっている。

@item -ftree-loop-im
@opindex ftree-loop-im
木でのループ不変式移動を行う。このパスはRTLレベルで扱うのが難しい不変式（関数呼び出し、非自明の命令列へと拡張される操作）
のみを動かす。@option{-funswitch-loops}でループの外の不変である条件のオペランドも移動するので、
ループ非スイッチ化で単なる自明不変解析を使うことができる。このパスはストア移動も含んでいる。

@item -ftree-loop-ivcanon
@opindex ftree-loop-ivcanon
繰り返しの数を決定するために複雑な解析を必要とするループで、繰り返しの数ために規範的なカウンタを作成する。
後の最適化は、それから簡単に数を測定するかもしれない。特にループ展開に関連して役に立つ。

@item -fivopts
@opindex fivopts
木で誘導変数最適化（強さ縮小、結合している誘導変数と誘導変数除去）を実行する。

@item -ftree-parallelize-loops=n
@opindex ftree-parallelize-loops
ループを並列化する。すなわち、その繰り返し空間をｎスレッドで走るように分割する。
これはその繰り返しが独立で任意に並べ替えができるループでのみ可能である。
最適化は、例えばメモリ帯域幅によって制約されるよりはむしろ、CPU集約型であるループ用のため、
マルチプロセッサマシンでのみ利益をもたらす。このオプションは@option{-pthread}を含み、
したがって@option{-pthread}をサポートしているターゲットでのみサポートされる。

@item -ftree-pta
@opindex ftree-pta
木での関数局所対点解析を行う。このフラグは@option{-O}以上でデフォルトで有効である。

@item -ftree-sra
@opindex ftree-sra
集積のスカラー置換を行う。このパスは構造体参照をスカラーで置換し、構造体がメモリーへ
あまりに早くコミットすることを防ぐ。このフラグは@option{-O}以上でデフォルトで有効である。

@item -fstore-merging
@opindex fstore-merging
狭い記憶域を連続したメモリアドレスにマージする。このパスは、命令の数を減らすために、ワード長よりも狭い直接値の隣接するストアをより少ないより広いストアにマージする。 これはデフォルトでは@option{-O2}以上、@option{-Os}で有効になっている。

@item -ftree-ter
@opindex ftree-ter
SSA→通常フェーズの間に一時式置換を行う。単一使用・単一定義の一時式はその使用場所でその定義式へ置換される。
これは非GIMPLEコード内で起こるが、展開器にもっとずっと複雑な木を与えて、よりよいTRL生成が起こるように取り組む。
これは@option{-O}以上でデフォルトで有効である。

@item -ftree-slsr
@opindex ftree-slsr
木での直線長さ削減を行う。これは乗算を含んでいる関連した表現を認識して、可能な場合それらをより高価でない計算と置き換える。
これは@option{-O}以上でデフォルトで有効である。


@item -ftree-vectorize
@opindex ftree-vectorize
木でのベクトル化を行う。このフラグはもし明示的に指定されていないなら@option{-ftree-loop-vectorize}と
@option{-ftree-slp-vectorize}を有効にする。

@item -ftree-loop-vectorize
@opindex ftree-loop-vectorize
木でのループベクトル化を行う。このフラグは@option{-O3}でと、@option{-ftree-vectorize}が有効の時にデフォルトで有効である。

@item -ftree-slp-vectorize
@opindex ftree-slp-vectorize
木での基本ブロックベクトル化を行う。このフラグは@option{-O3}でと、@option{-ftree-vectorize}が有効の時にデフォルトで有効である。

@item -fvect-cost-model=@var{model}
@opindex fvect-cost-model
ベクトル化で使われるコストモデルを変更する。@var{model}引数は @samp{unlimited}, @samp{dynamic}, @samp{cheap}の一つであるべきである。
@samp{unlimited}モデルではベクトル化されたコードパスは利益があると仮定される一方、
@samp{dynamic}モデルではランタイムチェックがベクトル化されたコードパスが繰り返し回数が元のスカラーループが実行される時よりも
速いだろう時のみ有効にするように守る。@samp{cheap}モデルは、そうすることがたとえばデータ依存またはアラインメントの必須の
ランタイム・チェックのために
ひどく高くつく時にループベクトル化を無効にするが、それ以外は@samp{dynamic}モデルと等しい。

@item -fsimd-cost-model=@var{model}
@opindex fsimd-cost-model
OpenMP simdディレクティブマークされたループのベクトル化で使われるコストモデルを変える。
@var{model}引数は @samp{unlimited}, @samp{dynamic}, @samp{cheap}の一つであるべきである。
@var{model}のすべての値は@option{-fvect-cost-model}で描写されたのと同じ意味をもち、デフォルトでは
@option{-fvect-cost-model}で使われたコストモデルが使われる。

@item -ftree-vrp
@opindex ftree-vrp
木での値範囲伝搬を行う。これは定数伝搬パスに似ているが、値の代わりに、値の範囲が伝搬する。
これは不必要な配列境界チェックやヌルポインタチェックのような範囲チェックを削除する最適化を可能にする。
これは@option{-O2}以上でデフォルトで有効である。ヌルポインタチェック除去は@option{-fdelete-null-pointer-checks}が
有効の時だけ行われる。

@item -fsplit-paths
@opindex fsplit-paths
ループバックエッジを導くパスを分割する。これは非到達コード除去と共通部分式除去を向上させる。これは
@option{-O2}以上でデフォルトで有効である。

@item -fsplit-ivs-in-unroller
@opindex fsplit-ivs-in-unroller
最初の繰り返しでの値を使って展開されたループの後半の繰り返しでの導出変数の値の表現を有効にする。
これはループ依存連鎖を壊すので、スケジューリングパスの効率性を向上させる。

@option{-fweb}とCSEの組み合わせはしばしば同じ効果を得るために十分である。しかし、これはループ本体が
単一基本ブロックよりも複雑な場合には信頼出来ない。それはさらに、CSEパスでの制限のためにあるアーキテクチャでは全く働かない。

この最適化はデフォルトで有効である。

@item -fvariable-expansion-in-unroller
@opindex fvariable-expansion-in-unroller
このオプションでコンパイラはループ展開時にある局所変数の複数のコピーを作り、それはより良いコードを起こしうる。

@item -fpartial-inlining
@opindex fpartial-inlining
関数の部分をインライン化する。このオプションはインライン自身が@option{-finline-functions}か
@option{-finline-small-functions}オプションによってONの時だけ効果がある。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fpredictive-commoning
@opindex fpredictive-commoning
予測的共通化最適化、すなわち（時にメモリのロード・ストアする）前のループの繰り返しで行われた計算の再利用を行う。

このオプションはレベル@option{-O3}で有効である。

@item -fprefetch-loop-arrays
@opindex fprefetch-loop-arrays
ターゲット機種がサポートしているならば、大きは配列にアクセスするループのパフォーマンスを向上させるために、
メモリへのプリフェッチの命令を生成する。

このオプションはより良いコードもより悪いコードも生成するかもしれない。結果はソースコード内のループの構造に
強く依存する。

レベル@option{-Os}で無効にされる。

@item -fno-printf-return-value
@opindex fno-printf-return-value
@code{sprintf}、@code{vprintf}、@code{vsprintf}、@code{vsnprintf}のようなフォーマットされた出力関数の既知の戻り値に定数を代入しない。 （しかし@code{sprintf}と@code{fprintf}はしない）。
この変換により、GCCは、定数であるか、または正確な戻り値を可能にする範囲内の値であることが知られている引数で呼び出される、これらの関数の既知の戻り値に基づいて分岐を最適化または排除することさえできる。 たとえば、@option{-fprintf-return-value}が有効な場合、@code{if}文の分岐と本体（@code{snprintf}の呼び出しではない） は、@code{i}が32ビット以下の整数のときは、戻り値が多くても8であると保証されているので最適化で消すことができる。

@smallexample
char buf[9];
if (snprintf (buf, "%08x", i) >= sizeof buf)
  @dots{}
@end smallexample

@option{-f printf-return-value}オプションは、他の最適化に依存し、@option{-O2}以上で最良の結果をもたらす。 @option{-Wformat-overflow}オプションと@option{-Wformat-truncation}オプションと連携して動作する。
@option {-fprintf-return-value}オプションは、デフォルトで有効になっている。

@item -fno-peephole
@itemx -fno-peephole2
@opindex fno-peephole
@opindex fno-peephole2
機種依存の覗き穴最適化を無効にする。@option{-fno-peephole}と@option{-fno-peephole2}の違いは
コンパイラ内でどのように実装されているかである。あるターゲットは片方を使い、別のはもう片方を使い、一部は両方使う。

@option{-fpeephole}はデフォルトで有効である。
@option{-fpeephole2}はレベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fno-guess-branch-probability
@opindex fno-guess-branch-probability
ヒュリスティックを使って分岐確率を推測しない。

GCCをはもしプロファイリングフィードバック(@option{-fprofile-arcs})によって提供されていない時は、
分岐確率を推測するのにヒューリスティックを使う。
これらのヒューリスティックは制御フローグラフにもとづいている。もし分岐確率が@code{__builtin_expect}で指定されているならば、
ヒューリスティックは制御フローグラフの残りの分岐確率を推測するのに使われ、@code{__builtin_expect}情報が考慮に入れられる。
ヒューリスティックと@code{__builtin_expect}の相互作用は複雑になりえ、ある場合には、ヒューリスティックを無効にして
@code{__builtin_expect}の高架が理解しやすくすることが役立つかもしれない。

デフォルトはレベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}では@option{-fguess-branch-probability}である。

@item -freorder-blocks
@opindex freorder-blocks
取られる分岐を減らしてコード局所性を向上させるためにコンパイルされた関数の基本ブロックを並べ替える。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -freorder-blocks-algorithm=@var{algorithm}
@opindex freorder-blocks-algorithm
基本ブロックの並べ替えに、指定されたアルゴリズムを使う。@var{algorithm}引数は、
（アラインメントのような時々の二次作用を除いて）それはコードサイズを増やさない@samp{simple}、
しばしば実行コードをまとめ、追加のコードのコピーを作ることで実行される分岐の数を最小化する
「ソフトウェアトレースキャッシュ」アルゴリズムの@samp{stc}が可能である。

デフォルトはレベル@option{-O}, @option{-Os}では@samp{simple}で、レベル@option{-O2}, @option{-O3}
では@samp{stc}である。

@item -freorder-blocks-and-partition
@opindex freorder-blocks-and-partition
コンパイルされた関数での基本ブロックの並べ替えに加え、取られる分岐の数を減らすために、
熱いのと冷たい基本ブロックをアセンブリと@file{.o}ファイルの別々のセクションへと分割し、
ページングとキャッシュ局所性パフォーマンスを向上させる。

この最適化は、例外処理または巻き戻しテーブル（setjump / longjumpまたはターゲット固有のスキームを使用するターゲット）、リンク・ワンスセクション、ユーザー定義セクション属性を持つ関数、および名前付きセクションサポートしていないアーキテクチャで自動的にオフになる。 @option{-fsplit-stack}を使用すると、このオプションはデフォルトでは（リンカエラーを避けるために）有効にはならないが、明示的に有効にすることができる（機能するリンカーを使用している場合）。
  
@option {-O2}、@option {-O3}、@option {-Os}のレベルでx86用に有効になる。

@item -freorder-functions
@opindex freorder-functions
コード局所性を向上させるためにオブジェクトファイルの関数を並べ替える。
これは最も頻繁に実行される関数に@code{.text.hot}サブセクションを使って、あまり実行されない関数に
@code{.text.unlikely}を使うことで実行される。並べ替えはリンカによって行われるので
オブジェクトファイルフォーマットは名前付きセクションをサポートしてリンカは合理的な方法で
それらを配置しなければならない。

さらにこのオプションを効果的にするにはプロファイル・フィードバックも有効にしなければならない。
詳細は@option{-fprofile-arcs}を見よ。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fstrict-aliasing
@opindex fstrict-aliasing
コンパイラはコンパイルされる言語のに適用される最も厳格なエイリアスルールを仮定する。
C（とC++）では、これは式の型に基づいた最適化を有効にする。特に、一つの型のオブジェクトは
型がほとんど同じでない限りは、決して同じアドレスで異なる型で存在しないと仮定する。
例えば、@code{unsigned int}は@code{int}とは別名になれるが、@code{void*}や@code{double}とは
別名になれない。文字型は他のどの型とも別名になっても良い。

@anchor{Type-punning}このようなコードに注意を払え。
@smallexample
union a_union @{
  int i;
  double d;
@};

int f() @{
  union a_union t;
  t.d = 3.0;
  return t.i;
@}
@end smallexample
最も最近に書かれたものではない共用体のメンバから読むこと（タイプ・パンニングと呼ばれる）は一般的である。
@option{-fstrict-aliasing}があっても、タイプ・パンニングは許され、メモリは共用体を通してアクセスできる。
したがって、上のコードは期待した通りに動く。 @xref{Structures unions enumerations and bit-fields
implementation}。しかし、このコードはそうでないかもしれない。
@smallexample
int f() @{
  union a_union t;
  int* ip;
  t.d = 3.0;
  ip = &t.i;
  return *ip;
@}
@end smallexample

同様に、アドレスを取ってアクセスし、結果のポインタをキャストして、
その結果の被参照をすることは、たとえキャストが共用体を使っていても未定義の振る舞いである。例えば、
@smallexample
int f() @{
  double d = 3.0;
  return ((union a_union *) &d)->i;
@}
@end smallexample

@option{-fstrict-aliasing}オプションはレベル@option{-O2}, @option{-O3}, @option{-Os}で有効になる。

@item -falign-functions
@itemx -falign-functions=@var{n}
@opindex falign-functions
関数の開始を@var{n}より大きい次の２のベキに揃え、最大@var{n}バイト飛ばす。例えば、
@option{-falign-functions=32}は次の32バイト境界に関数を揃えるが、
@option{-falign-functions=24}はこれが23バイト以下を飛ばして可能なときのみ32バイト境界に揃える。

@option{-fno-align-functions}と@option{-falign-functions=1}は関数が等価でアラインメントしないという意味である。

あるアセンブラは@var{n}が2のベキの時だけこのフラグをサポートする。その場合は、切り上げられる。

もし@var{n}が指定されていないか0ならば、機種依存のデフォルトが使われる。@var{n}の可能な最大値は65536である。

レベル@option{-O2}, @option{-O3}で有効である。

@item -flimit-function-alignment
このオプションを有効にすると、コンパイラは不要なオーバーアライン機能を回避しようとする。 @option{-falign-functions}で指定された量だけ整列するが、関数のサイズよりも多くのバイトをスキップしないようにアセンブラに指示するが。

@item -falign-labels
@itemx -falign-labels=@var{n}
@opindex falign-labels
@option{-falign-functions}のように@var{n}バイトまでを飛ばしてすべての分岐ターゲットを2のベキの境界に揃える。
このオプションは簡単にコードを遅くできる。なぜなら分岐ターゲットがコードの通常の流れで到達するときにはダミー操作を挿入しなければならない
からである。

@option{-fno-align-labels}と@option{-falign-labels=1}は等価でありラベルがアラインメントされないことを意味する。

@option{-falign-loops}か@option{-falign-jumps}が適用可能でこの値よりも大きいならば、代わりにそれらの値が使われる。

もし@var{n}が指定されていないか0ならば、機種依存のデフォルト値が使われ、それはアラインメントをしないことを意味する@samp{1}である可能性が高い。@var{n}の可能な最大値は65536である。

レベル@option{-O2}, @option{-O3}で有効である。

@item -falign-loops
@itemx -falign-loops=@var{n}
@opindex falign-loops
@option{-falign-functions}のように@var{n}バイトまで飛ばしてループを２のベキの境界に揃える。
もしループが何回も実行されるなら、これはダミー操作の実行を作る。

@option{-fno-align-loops}と@option{-falign-loops=1}は等価であり、ループがアラインメントされないことを意味する。@var{n}の可能な最大値は65536である。

もし@var{n}が指定されていないか0ならば、機種依存のデフォルトが使われる。

レベル@option{-O2}, @option{-O3}で有効である。

@item -falign-jumps
@itemx -falign-jumps=@var{n}
@opindex falign-jumps
ジャンプによってのみ到達可能な分岐ターゲットを、@option{-falign-functions}のように@var{n}バイトまで飛ばして2のベキの境界に揃える。
この場合には、ダミー操作を実行する必要はない。

@option{-fno-align-jumps}と@option{-falign-jumps=1}は等価であり、ループがアラインメントされないことを意味する。

もし@var{n}が指定されていないか0ならば、機種依存のデフォルトが使われる。@var{n}の可能な最大値は65536である。

レベル@option{-O2}, @option{-O3}で有効である。

@item -funit-at-a-time
@opindex funit-at-a-time
このオプションは互換性のために残されている。@option{-funit-at-a-time}には効果がないが、
@option{-fno-unit-at-a-time}は@option{-fno-toplevel-reorder}と@option{-fno-section-anchors}を含む。

デフォルトで有効である。

@item -fno-toplevel-reorder
@opindex fno-toplevel-reorder
関数、変数、@code{asm}を並べ替えない。それらの出力は入力ファイルで現れたのと同じ順で出力される。
このオプションが使われると、未参照の静的変数は削除されない。このオプションは特定の順序に依存した既存のコードをサポートすることを
意図している。新しいコードでは、可能なら属性を使ったほうがいい。

レベル@option{-O0}で有効である。明示的に無効にする時、@option{-fno-section-anchors}を含み、
さもなければあるターゲットでは@option{-O0}で有効である。

@item -fweb
@opindex fweb
レジスタ割当の目的で一般的に使われる網羅図を構築し、それぞれの網羅図に個々の擬似レジスタを割り当てる。
これはレジスタ割当パスが擬似レジスタを直接操作することを可能にするが、CSE、ループ最適化、自明の非実行コードの除去のような
いくつかの他の最適化も強化する。しかし、変数がもはや「ホームレジスタ」にとどまっていないので、デバッグを不可能にしうる。

@option{-funroll-loops}でデフォルトで有効である。

@item -fwhole-program
@opindex fwhole-program
現在のコンパイル単位がコンパイルされう全プログラムを表現していると仮定する。@code{main}の例外を除いたすべてのパブリック関数と変数と
属性@code{externally_visible}によってマージされたものは静的関数になり、その効果で手続間最適化によってもっと積極的に最適化される。

このオプションは@option{-flto}と組み合わせて使うべきではない。代わりにリンカプラグインに頼って、もっと安全でもっと正確な情報を
提供すべきである。

@item -flto[=@var{n}]
@opindex flto
このオプションは標準リンク時最適化を走らせる。ソースコード付きで実行した時は、GIMPLE（GCCの内部表現の一つ）を生成して
オブジェクトファイルの特別なELEセクションに書き出す。オブジェクトファイルが一緒にリンクされた時は、
すべての関数本体がそれらのELFセクションから読み出されて同じ翻訳単位であるかのように実体化される。

リンク時最適化を使うためには、@option{-flto}と最適化オプションがコンパイル時と最後のリンクの間に指定されるべきである。
あなたが同じオプションで同じリンクに関与しているすべてのファイルをコンパイルして、そのうえオプションをリンク時にも指定することを推奨する。
例えば：

@smallexample
gcc -c -O2 -flto foo.c
gcc -c -O2 -flto bar.c
gcc -o myprog -flto -O2 foo.o bar.o
@end smallexample

最初の２つのGCCはへの呼び出しはGIMPLEのバイトコード表現を@file{foo.o}と@file{bar.o}に保存する。
最後の呼び出しは@file{foo.o}と@file{bar.o}からGIMPLEバイトコードを呼んで、一つのイメージにマージして、
いつもどおり結果をコンパイルする。@file{foo.o}と@file{bar.o}の両方が単一のイメージにマージされるので、
これは２つのファイルをまたいで働くGCCはでの手続間解析と最適化のすべてが、まるで単一ファイルであるかのように効くようになる。
これは、例えば、インライン化器が@file{bar.o}での関数を@file{foo.o}にインライン化したり、その逆ができるようになることを意味する。

他の（もっと単純な）リンク時最適化を有効にする方法は：

@smallexample
gcc -o myprog -flto -O2 foo.c bar.c
@end smallexample

上は@file{foo.c}と@file{bar.c}のバイトコードを生成し、それらを単一のGIMPLE表現にマージして
いつもどおり@file{myprog}を生成するために最適化する。

心に留めておかないといけない唯一の重要なことはリンク時最適化を有効にするためにはリンクステップを行うために
GCCはドライバを使う必要があることである。GCCは関与したオブジェクトのどれかががそれから@option{-flto}コマンドラインオプションで
コンパイルされているなら自動的にリンク時最適化を行う。GCCはリンク時に指定しそこねたならばコンパイル時に使われたオプションから
最適化レベルを推測することで賢くなろうとするが、一般的にはリンク時最適化で使われる最適化オプションを指定すべきである。
いつもリンク時に@option{-fno-lto}をリンクコマンドに渡すことでリンク時最適化の自動決定を上書きできる。

全プログラム最適化を効果的にするには、ある全プログラム仮定を置く必要がある。
コンパイラはどの関数と変数がライブラリとリンク時最適化単位の外のランタイムによってアクセスされうるかを知る必要がある。
リンカによってサポートされている時、リンカプラグイン(@option{-fuse-linker-plugin}参照)はコンパイラに使われて外部から可視のシンボルの
情報を渡す。リンカプラグインが利用できない時は、@option{-fwhole-program}をコンパイラがこれらの仮定を行うことを許可するのに使うべきであり、
それによってもっと積極的な最適化の決定を導く。

@option{-fuse-linker-plugin}が有効でない時は、@option{-flto}でファイルがコンパイルされるとき、
生成されたオブジェクトファイルはGIMPLEバイトコードと通常の最終コードを含むので(@option{-ffat-lto-objects}参照)
通常のオブジェクトファイルよりも大きくなる。これはLTO情報ありのオブジェクトファイルは通常のオブジェクトとしてリンクできることを意味する。
もし@option{-fno-lto}がリンカに渡されたなら、手続間最適化は適用されない。
@option{-fno-fat-lto-objects}が有効なときはコンパイル段階は速くなるが、それらを通常の非LTOリンクは行えないことに注意する。

さらに、個々のファイルをコンパイルするのに使ったさいt経過は必ずしもリンク時に使うものと関連している必要はない。例えば、

@smallexample
gcc -c -O0 -ffat-lto-objects -flto foo.c
gcc -c -O0 -ffat-lto-objects -flto bar.c
gcc -o myprog -O3 foo.o bar.o
@end smallexample

これは個々のオブジェクトファイルは最適化されていないアセンブラコードを生成するが、結果のバイナリ@file{myprog}が@option{-O3}で最適化される。
もし、代わりに最終バイナリが@option{-fno-lto}で生成されるなら、@file{myprog}は最適化されない。

最終バイナリを生成するとき、GCCはリンク時最適化をバイトコードを含むファイルに対してのみ適用する。
したがって、オブジェクトファイルとライブラリをGIMPLEバイトコードと最終オブジェクトコードで混ぜて一致させることができる。
GCCは自動的にどのファイルがLTOモードで最適化されてどのファイルがさらなる処理をせずにリンクするかを選択する。

バイトコードを生成するときにGCCによって維持されるコード生成オプションがある、なぜならそれらは最終リンクステージで使う必要があるからである。
一般的にはリンク時に指定したオプションはコンパイル時に指定したオプションを上書きする。

もしリンク時に最適化レベルオプション@option{-O}が指定されていないならば、GCCはオブジェクトファイルをコンパイルするときに使った最高の
最適化レベルを使う。

現在、以下のオプションと設定が明示的に指定した最初のオブジェクトファイルから取られている。
@option{-fPIC}, @option{-fpic}, @option{-fpie}, @option{-fcommon},
@option{-fexceptions}, @option{-fnon-call-exceptions}, @option{-fgnu-tm}
とすべての@option{-m}ターゲットフラグ。

あるABI変更フラグはすべてのコンパイル単位で一致する必要があり、リンク時にこの値を矛盾した値で上書きしようとしても無視される。
これには@option{-freg-struct-return}や@option{-fpcc-struct-return}のようなオプションが含まれる。

他の@option{-ffp-contract}, @option{-fno-strict-overflow},
@option{-fwrapv}, @option{-fno-trapv}, @option{-fno-strict-aliasing}のようなオプションは
リンク段階を通して渡され、矛盾する翻訳単位で控えめにマージされる。特に
@option{-fno-strict-overflow}, @option{-fwrapv}, @option{-fno-trapv}は優先順位を取る。
そして例えば、@option{-ffp-contract=off}は@option{-ffp-contract=fast}より優先される。それらはリンク時に上書きされる。

もしLTOが一緒にリンクされる別の翻訳単位の型と非互換で宣言されているCリンケージのオブジェクトに出会ったら、
(ISO C99 6.2.7によれば未定義の振る舞い), 致命的でない診断が出るかもしれない。振る舞いは実行時は依然として未定義である。
同様の診断が他の言語でも発するかも知れない。

LTOのもう一つの機能は別の言語で書かれたファイルで手続間最適化が適用できることである。

@smallexample
gcc -c -flto foo.c
g++ -c -flto bar.cc
gfortran -c -flto baz.f90
g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran
@end smallexample

最後のリンクはC++実行時ライブラリを得るために@command{g++}で行われFortran実行時ライブラリを得るために
@option{-lgfortran}が加えられる。一般的に、LTOのモードで言語を混ぜるときは、通常の（非LTOの）コンパイルで
言語を混ぜるときと同じリングコマンドオプションを使うべきである。

もしGIMPLEバイトコードを含むオブジェクトファイルが、例えば@file{libfoo.a}のようなライブラリアーカイブに格納されているなら、
プラグインサポートのあるリンカを使えばそれらを抽出してLTOリンクで使うことができる。LTOに適した静的ライブラリを作るためには、
@command{ar}と@command{ranlib}の代わりに @command{gcc-ar}と@command{gcc-ranlib}を使う。
GIMPLEバイトコードでオブジェクトファイルのシンボルを見るためには、@command{gcc-nm}を使う。
これらのコマンドは@command{ar}, @command{ranlib}, @command{nm}がプラグインサポートでコンパイルされている必要がある。
リンク時にLTO最適化過程でライブラリが関与することを保証するためには、フラグ@option{-fuse-linker-plugin}を使う。

@smallexample
gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo
@end smallexample

リンカプラグインが有効ならば、リンカは必要なGIMPLEファイルを@file{libfoo.a}から抽出してそれらを最適化される集積されたGIMPLEイメージ
の一部に加えるように走っているGCCのに渡す。

もしプラグインサポートのあるリンカを使っていないかつ・またはリンカプラグインを有効にしていないならば、
@file{libfoo.a}内部のオブジェクトが抽出されていつもどおりリンクされるが、LTO最適化処理には関与しない。
LTO最適化と通常のリンクの両方に適した静的ライブラリを作るためには、オブジェクトファイルを
@option{-flto} @option{-ffat-lto-objects}でコンパイルする。

リンク時最適化は操作するのにプログラム全体が存在する必要はない。もしプログラムがエクスポートされるシンボルを必要としないなら、
向上された最適化の機会を導くかもしれないもっと積極的な過程を使った手続間最適化を可能にするように@option{-flto}と@option{-fwhole-program}を
組み合わせることが可能である。
@option{-fwhole-program}の使用はリンカプラグインが起動中の時は必要ない(@option{-fuse-linker-plugin}参照)。

LTOの現在の実装は異なるタイプのホストで移植性があるバイトコードを生成しようとはしない。
バイトコードファイルはバージョン化されて、厳密なバージョンチェックがあるので、あるバージョンのGCCで生成された
バイトコードファイルは古い、もしくは新しいGCCのバージョンでは動かない。

リンク時最適化はELFとDWARFの組み合わせ以外でのシステムでのデバッグ情報の生成とはうまく働かない。

任意の@var{n}を指定したならば、リンク時の最適化とコード生成はインストールされた@command{make}プログラムを調整して
@var{n}の並列ジョブを使って並列に実行される。環境変数@env{MAKE}はツアクァれるプログラムを上書きするのに使うことができる。
@var{n}のデフォルト値は1である。

@option{-flto=jobserver}をGNU makeのジョブサーバーモードを並列ジョブの数を決定するために使うために指定することができる。
これはすでにGCCを呼ぶMakefileがすでに並列で実行されている時に役立つ。これを働かせるためには現在のMakefileで
コマンドレシピの前に@samp{+}を加えなくてはならない。このオプションは@env{MAKE}がGNU makeの時だけ働くだろう。

@item -flto-partition=@var{alg}
@opindex flto-partition
リンク時最適化器で使われる分割アルゴリズムを指定する。値は元のソースファイルを反映する
分割を指定する@samp{1to1}か、（可能なときは）同等のサイズのチャンクへと分割するように指定する@samp{balanced}か、
可能な限り各シンボルで新しい領域を作る@samp{max}のどれかである。
アルゴリズムとして@samp{none}を指定すると分割を無効にして完全にストリーミングする。
デフォルト値は@samp{balanced}である。様々なコード順序問題の回避方法として@samp{1to1}を使うことができる一方、
@samp{max}分割は内部テスト専用を意図している。値@samp{one}が正確に一つの分割が使われるべきであることを指定するのに対し、
値@samp{none}は分割を迂回してリンク時最適化ステップをWPAフェーズから直接実行する。

@item -flto-odr-type-merging
@opindex flto-odr-type-merging
リンク時にC++型のマングル化された形名のストリーミングとその統合を有効にする。これはLTOオブジェクトファイルのサイズを増やすが、
単一定義規則違反の診断を有効にする。

@item -flto-compression-level=@var{n}
@opindex flto-compression-level
このオプションはLTOオブジェクトファイルに書かれる中間言語で使われる圧縮レベルを指定し、LTOモード(@option{-flto})との組み合わせ
でのみ意味を持つ。正当な値は0(圧縮なし)から9(最大圧縮)である。この範囲外の値は0か9に固定される。もしオプションが与えられなければ、
デフォルトのバランスのとれた圧縮設定が使われる。

@item -fuse-linker-plugin
@opindex fuse-linker-plugin
リンク時最適化でリンカプラグインの使用を有効にする。このオプションはリンカでのプラグインサポートに依存していて、
goldかGNU ld 2.21以降で利用可能である。

このオプションはGIMPLEバイトコードのあるオブジェクトファイルをライブラリアーカイブから抽出することを可能にする。
これはリンク時最適化でもっと多くのコードを晒すことで最適化の質を向上させる。この情報はどのシンボルが外部でアクセスされることが可能かを
（非LTOのオブジェクトか動的リンクの間に）指定する。バイナリ（と共有リンク）での結果のコード品質向上は
@option{-fwhole-program}と同様である。このフラグの効果の描写とどのように使うかは@option{-flto}を見よ。

このオプションはGCCはのLTOサポートが有効でGCCがプラグインをサポートするリンカ(GNU ld 2.21以降かgold)を使うように設定されていたら
デフォルトで有効である。

@item -ffat-lto-objects
@opindex ffat-lto-objects
ファット・LTOオブジェクトは中間言語とオブジェクトコードの両方を含むオブジェクトファイルである。
これはそれらをLTOリンクと通常のリンクの両方で利用可能にする。このオプションは@option{-flto}でコンパイルした時だけ
効果があり、リンク時は無視される。

@option{-fno-fat-lto-objects}は素のLTOに比較してコンパイル時間を向上させるが、LTOを完治する完全なツールチェーンが必要である。
それは基本機能にリンカプラグインサポートのあるリンカを必要とする。さらに、@command{nm}、@command{ar}、@command{ranlib}が
（静的ライブラリなどをビルドする能力がある）完全に機能するビルド環境を許すためにはリンカプラグインをサポートする必要がある。
GCCは正しいオプションをそれらのツールに渡すために@command{gcc-ar}, @command{gcc-nm}, @command{gcc-ranlib}ラッパを提供している。
非ファットLTOのmakefileはそれらを使うように修正する必要がある。

現代のbinutilsは、プラグインの自動ロードメカニズムを提供している。 リンカプラグインを@file{$libdir/bfd-plugins}にインストールすると、コマンドラッパー（@command{gcc-ar}、@command{gcc-nm}、@command{gcc-ranlib}）と同じ効果がある 。

デフォルトはリンカプラグインをサポートしたターゲットでは@option{-fno-fat-lto-objects}である。

@item -fcompare-elim
@opindex fcompare-elim
レジスタ割当とレジスタ割当後命令分割の後に、その算術に基づく比較命令と同様のプロセッサフラグを計算している算術命令を識別する。
もし可能なら、明示的な比較命令を除去する。

このパスはレジスタ割当が完了するまえに比較操作を明示的に表現できないあるターゲットでの適用される。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fcprop-registers
@opindex fcprop-registers
レジスタ割当とレジスタ割当後命令分割の後に、スケジュール依存を削減しようとするために、コピー伝搬パスを行い、時々コピーを除去する。

レベル@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -fprofile-correction
@opindex fprofile-correction
マルチスレッドプログラムの測定バイナリを使って収集されたプロファイルは失われたカウンタ交信のために矛盾しているかもしれない。
このオプションが指定された時は、GCCはヒューリスティックを使ってこの矛盾を修正・補正する。デフォルトではGCCは矛盾したプロファイルを検知したら
エラーメッセージを生成する。

@item -fprofile-use
@itemx -fprofile-use=@var{path}
@opindex fprofile-use
プロファイルのフィードバックに指示された最適化を有効にし、プロファイルフィードバックが利用可能なときだけ一般的に有益な
最適化に従う。@option{-fbranch-probabilities}, @option{-fvpt},
@option{-funroll-loops}, @option{-fpeel-loops}, @option{-ftracer}, 
@option{-ftree-vectorize}, @option{ftree-loop-distribute-patterns}.

このオプションを使うことができる前には、最初にプロファイル情報を生成しなければならない。
@option{-fprofile-generate}オプションについての情報は@xref{Optimize Options}

デフォルトでは、GCCはもしフィードバックプロファイルがソースコードと一致しない時はエラーメッセージを出す。
このエラーは@option{-Wcoverage-mismatch}を使うことで警告に変換できる。これは貧弱に最適化されたコードになるかもしれないことに注意。

もし@var{path}が指定されたなら、GCCは@var{path}をプロファイルフィードバックデータファイルを探すために見る。@option{-fprofile-dir}参照。

@item -fauto-profile
@itemx -fauto-profile=@var{path}
@opindex fauto-profile
サンプリングベースのフィードバックに指示された最適化を有効にし、プロファイルフィードバックが利用可能なときだけ一般的に有益な
最適化に従う。
@option{-fbranch-probabilities}, @option{-fvpt},
@option{-funroll-loops}, @option{-fpeel-loops}, @option{-ftracer}, 
@option{-ftree-vectorize},
@option{-finline-functions}, @option{-fipa-cp}, @option{-fipa-cp-clone},
@option{-fpredictive-commoning}, @option{-funswitch-loops},
@option{-fgcse-after-reload},  @option{-ftree-loop-distribute-patterns}.

@var{path}はAutoFDOプロファイル情報を含むファイルの名前である。省略された時は、
現在のディレクトの@file{fbdata.afdo}がデフォルトである。

AutoFDOプロファイルデータのプロファイリングにはサポートされたGNU/Linuxターゲットシステムでの
@command{perf}ユーティリティでプログラムを実行する必要がある。さらなる情報は@uref{https://perf.wiki.kernel.org/}を見よ。

例えば、
@smallexample
perf record -e br_inst_retired:near_taken -b -o perf.data \
    -- your_program
@end smallexample

それから@command{create_gcov}ツールを生プロファイルデータからGCCが使える書式へ変換するために使う。
このツールにプログラムのストリップされていないバイナリを提供する必要もある。
@uref{https://github.com/google/autofdo}参照。

例えば、
@smallexample
create_gcov --binary=your_program.unstripped --profile=perf.data \
    --gcov=profile.afdo
@end smallexample
@end table

以下のオプションは浮動小数点算術に関するコンパイラの振る舞いを制御する。これらのオプションは速度と正確さのトレードオフである。
すべては明示的に有効にしなければならない。

@table @gcctabopt
@item -ffloat-store
@opindex ffloat-store
浮動小数点変数をレジスタに格納せず、浮動小数点数値がレジスタとメモリのどちらから取ってくるかを変更するかもしれない他のオプションを抑制する。

@cindex floating-point precision
このオプションは68000のような（68881の）浮動小数点レジスタが@code{double}が持つよりも多くの精度を維持する機種で望まない
余計な精度を防ぐ。x86アーキテクチャも同様である。多くのプログラムで、余分な精度は単にいいことであるが、あるプログラムは
IEEE浮動小数点数の正確な定義に依存している。そのようなプログラムで@option{-ffloat-store}を使うことでそれらを修正した後に、
変数にすべての関係する中間の計算を保存する。

@item -fexcess-precision=@var{style}
@opindex fexcess-precision
このオプションは浮動小数点レジスタがIEEE @code{float}と@code{double}型より多くの精度を持ちプロセッサが
それらの型への丸め操作をサポートしない機種で余分な精度の更なる制御を可能にする。
デフォルトで、@option{-fexcess-precision=fast}が有効である。これは、操作がレジスタの精度で実行され、
ソースコードで指定されている型への丸めが起こるとき、それが予測できないことを意味する。
Cをコンパイルするとき、@option{-fexcess-precision=standard}が指定されるならば、
過剰な精度はISO C99で指定されている規則に追従する;
特に、キャストと代入は、値をそれらの意味論的な型（@option{-ffloat-store}が代入に影響を及ぼすだけであるのに対して）に丸められる。
@option{-std=c99}のような厳しい適合オプションが使われるならば、このオプションはCでデフォルトで使用可能である。

@opindex mfpmath
@option{-fexcess-precision=standard}はC以外の言語では実装されておらず、@option{-funsafe-math-optimizations}か@option{-ffast-math}が
指定されていたら効果がない。x86では、@option{-mfpmath=sse}か@option{-mfpmath=sse+387}が指定されていた時も効果がない。
前者では余分な精度なしでIEEEの意味が適用され、後者では、丸めは予測不能である。

@item -ffast-math
@opindex ffast-math
オプション@option{-fno-math-errno}, @option{-funsafe-math-optimizations},
@option{-ffinite-math-only}, @option{-fno-rounding-math},
@option{-fno-signaling-nans}@option{-fcx-limited-range}をセットする。

このオプションはプリプロセッサマクロ@code{__FAST_MATH__}を定義させる。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でのオンにならない。
しかし、それはそれらの仕様の保証を必要としないプログラムの実行を高速化するかもしれない。

@item -fno-math-errno
@opindex fno-math-errno
@code{sqrt}のような単一命令で実行される数学関数を呼んだ後に@code{errno}をセットしない。
数学のエラーハンドリングのIEEE例外に依存したプログラムはIEEE算術互換性を維持する一方で速度のために
このフラグを使いたいかもしれない。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でのオンにならない。
しかし、それはそれらの仕様の保証を必要としないプログラムの実行を高速化するかもしれない。

デフォルトは@option{-fmath-errno}である。

Darwinシステムでは、数学関数は決して@code{errno}をセットしない。したがって、コンパイラが互換性を考える理由がないので
@option{-fno-math-errno}がデフォルトである。

@item -funsafe-math-optimizations
@opindex funsafe-math-optimizations

（A)引数と結果が正当であると仮定し、（B)IEEEやANSI標準に反するかもしれない浮動小数点算術の最適化を許可する。
リンク時に使われた時は、デフォルトのCPU制御後や他の同様の最適化を変えるかもしれないライブラリやスタートアップファイルを含むかもしれない。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でのオンにならない。
しかし、それはそれらの仕様の保証を必要としないプログラムの実行を高速化するかもしれない。
@option{-fno-signed-zeros}, @option{-fno-trapping-math}, @option{-fassociative-math}, @option{-freciprocal-math}を有効にする。

デフォルトは@option{-fno-unsafe-math-optimizations}である。

@item -fassociative-math
@opindex fassociative-math

一連の浮動小数点演算子のオペランドの再結合を許可する。これは計算結果を変える可能性があるので
ISO CやC++の言語標準に違反する。注意：並べ替えはゼロの符号を変えるかもしれず。NaNを無視したり、アンダーフローやオーバーフロー
を抑制したり作ったりするかもしれない（そして、@code{(x + 2**52) - 2**52}のような丸めの振る舞いに依存したコードでは使うことができない）
浮動小数点数比較を並べ替えるかもしれず、順序の比較が要求されるときは使うことができない。
このオプションは@option{-fno-signed-zeros}と@option{-fno-trapping-math}の両方が効果がある必要がある。
さらに、@option{-frounding-math}と一緒では意味を成さない。Fortranではオプションは
@option{-fno-signed-zeros}と@option{-fno-trapping-math}の両方が有効なときは自動的に有効になる。

デフォルトは@option{-fno-associative-math}である。

@item -freciprocal-math
@opindex freciprocal-math

この最適化が有効ならば値を割る代わりに値の逆数を使うことを許可する。例えば、@code{x / y}は@code{x * (1/y)}で置換され、
これは@code{(1/y)}が共通部分式除去の対象ならば役立つ。これは精度を失い、値の操作するフロップの数を増やすことに注意。

デフォルトは@option{-fno-reciprocal-math}である。

@item -ffinite-math-only
@opindex ffinite-math-only
引数と結果がNaNや+-Infでないと仮定する浮動小数点算術の最適化を許可する。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
@option{-Ofast}を除いてどんな@option{-O}でのオンにならない。

デフォルトは@option{-fno-finite-math-only}である。

@item -fno-signed-zeros
@opindex fno-signed-zeros
ゼロの符号を無視する浮動小数点算術の最適化を許可する。IEEE算術は+0.0と@minus{}0.0値を区別する振る舞いを指定していて、
x+0.0や0.0*xのような表現の単純化を(@option{-ffinite-math-only}であっても)禁じている。
このオプションは結果のゼルの符号が意味を持たないことを暗示する。

デフォルトは@option{-fsigned-zeros}である。

@item -fno-trapping-math
@opindex fno-trapping-math
コードを浮動小数点演算がユーザに可視のトラップを生成しないと仮定してコンパイルする。これらのトラップは、
ゼロによる除算、オーバーフロー、アンダーフロー、不正確の結果と不正な操作が含まれる。このオプションは
@option{-fno-signaling-nans}が有効なことが要求される。もし例えば、「非停止」IEEE算術に依存しているなら
このオプションをセットするとより速いコードを可能にするかもしれない。

このオプションはIEEEの正確な実装やISOの数学関数の規則・仕様に依存しているプログラムに誤った出力を出しうるので、
どんな@option{-O}でのオンにならないはずである。

デフォルトは @option{-ftrapping-math}である。

@item -frounding-math
@opindex frounding-math
デフォルトの浮動小数点丸への振る舞いを仮定した変換と最適化を無効にする。
これはすべての浮動小数点数から整数への０への丸めと、他のすべての算術切り詰めでの最近傍丸めである。
このオプションはFP丸めモードを動的に変更するか、非標準の丸めモードで実行されるかもしれないプログラムに指定すべきである。
このオプションはコンパイル時の（丸めモードによって影響されるかもしれない）浮動小数点数の定数展開と符号依存の丸めモード
の存在下で安全でない算術変換を無効にする。

デフォルトは@option{-fno-rounding-math}である。

このオプションは実験的で、現在は丸めモードに影響されるすべてのGCCは最適化を無効にすることは保証されない、
GCCの将来のバージョンはC99の@code{FENV_ACCESS}プラグマを使うことでこの設定のもっと細かい制御を提供するかもしれない。
このコマンドラインオプションは@code{FENV_ACCESS}のデフォルトの状態を指定するのに使われるだろう。

@item -fsignaling-nans
@opindex fsignaling-nans
IEEEシグナルNaNがユーザ可視のトラップを浮動小数点操作の間に生成するかもしれないと仮定してコードをコンパイルする。
このオプションをセットするとシグナルNaNで可視の例外の数を変えるかもしれない最適化を無効にする。
このオプションは@option{-ftrapping-math}を含んでいる。

このオプションはプリプロセッサマクロ@code{__SUPPORT_SNAN__}を定義させる。

デフォルトは@option{-fno-signaling-nans}である。

このオプションは実験的で現在はすべてのシグナルNaNの振る舞いに影響するGCCの最適化を無効にすることは保証されない。

@item -fno-fp-int-builtin-inexact
@opindex fno-fp-int-builtin-inexact
組み込み関数@code{ceil}、@code{floor}、@code{round}と@code{trunc}、およびそれらの@code{float}および@code{long double}変種に非整数引数で「不正確」浮動小数点例外を発生させることを許可しない。ISO C99とC11は、これらの関数が「不正確」例外を発生させることを許しているが、IEEE 754-2008へのCバインディングであるISO / IEC TS 18661-1：2014では、そうすることは許可していない。

デフォルトは@option{-ffp-int-builtin-inexact}で、例外を発生させる。 このオプションは、@option{-ftrapping-math}が有効でない限りは何も行わない。

@option {-fno-fp-int-builtin-inexact}が使用されていても、関数がライブラリ関数の呼び出しを生成した場合、ライブラリ実装がTS 18661に従わない場合、「不正確」例外が発生する可能性がある。

@item -fsingle-precision-constant
@opindex fsingle-precision-constant
浮動小数点定数を暗黙に倍精度定数に変換する代わりに単精度として扱う。

@item -fcx-limited-range
@opindex fcx-limited-range
有効にした時、このオプションは複素数除算を行うときに範囲縮小ステップが必要ないと述べる。
さらに、複素数乗算や除算の結果が@code{NaN + I*NaN}であるかをチェックせず、その場合の状況を救う必要がないとする。
デフォルトは@option{-fno-cx-limited-range}であるが、@option{-ffast-math}で有効にされる。

このオプションはISO C99での@code{CX_LIMITED_RANGE}プラグマのデフォルト設を制御する。しかし、
このオプションはすべての言語に適用される。

@item -fcx-fortran-rules
@opindex fcx-fortran-rules
複素数乗算と除算でFortran規則に従う。範囲縮小は複素数除算の一部として行われるが、
複素数乗算や除算の結果が@code{NaN + I*NaN}であるかをチェックせず、その場合の状況を救う必要がないとする。

デフォルトは@option{-fno-cx-fortran-rules}である。

@end table

以下のオプションをパフォーマンスを向上させるかもしれない最適化を制御するが、どんな@option{-O}オプションでも有効にならない。
この節は壊れたコードを生成するかもしれない実験的なオプションを含む。

@table @gcctabopt
@item -fbranch-probabilities
@opindex fbranch-probabilities
@option{-fprofile-arcs}でコンパイルしたプログラムを走らせた後(@pxref{Instrumentation Options})、
それぞれの分岐回数に基づいた最適化を向上させるために、@option{-fbranch-probabilities}を使って
2回めのコンパイルをすることができる。@option{-fprofile-arcs}でコンパイルされたプログラムが終了するときに、
それぞれのソースファイルで@file{@var{sourcename}.gcda}と呼ばれるアーク実行カウントを保存する。
このデータの情報は生成されたコードの構造にとても依存するので、両方のコンパイルで同じソースコードと
同じ最適化オプションを使わなくてはならない。

@option{-fbranch-probabilities}で、GCCはそれぞれの@samp{JUMP_INSN}と@samp{CALL_INSN}で@samp{REG_BR_PROB}注釈を置く。
これらは最適化を向上させるために使うことができる。現在、それらは1箇所のみで使われる。@file{reorg.c}で、分岐がどのくらい取られるかを
推測する代わりに、@samp{REG_BR_PROB}がパスがどのくらいの頻度でとられるかを正確に決定するのに使われる。

@item -fprofile-values
@opindex fprofile-values
@option{-fprofile-arcs}と組み合わせれば、それはプログラム内で式の値についてのデータが収集されるようにコードを追加する。

@option{-fbranch-probabilities}で、それは最適化での使用のための表現の値のプライファイリングから収集されたデータを読み戻す。

@option{-fprofile-generate}と @option{-fprofile-use}で有効である。

@item -fprofile-reorder-functions
@opindex fprofile-reorder-functions
プロファイル計装に基づいた関数並べ替えが関数の実行の最初の時間を収集して、それらの関数を昇順で並べる。

@option{-fprofile-use}で有効である。

@item -fvpt
@opindex fvpt
@option{-fprofile-arcs}と組み合わせると、このオプションはコンパイラに式の値についての情報を収集するコードを追加するように支持する。

@option{-fbranch-probabilities}で、収集したデータを読み戻して実際にそれらに基づいた最適化を行う。現在最適化は除数の値についてを知識
を使った除算命令の特殊化を含む。

@item -frename-registers
@opindex frename-registers
レジスタ割当後に残されたレジスタを使うことによってスケジュールされたコードでの偽の依存性を避けようとする。
この最適化は多数のレジスタを持つプロセッサで最も利点がある。しかし、変数が「ホームレジスタ」にもはやとどまらないので、
ターゲットによって採用されるデバッグ情報フォーマットに依存して、デバッギングを不可能にしうる。

@option{-funroll-loops}でデフォルトで有効である。

@item -fschedule-fusion
@opindex fschedule-fusion
それらが命令フローで互いに隣接してあるならばターゲット機種がより効率的にそれらを実行することができるので、
一緒に同じ型のスケジュール命令への命令ストリームについてのターゲット依存的なパスを実行する。

レベル@option{-O2}, @option{-O3}, @option{-Os}で有効である。

@item -ftracer
@opindex ftracer
スーパーブロックサイズを大きくするために末端複写を行う。この変換は関数の制御フローを単純化して
他の最適化がもっといい仕事ができるようにする。

@option{-fprofile-use}で有効になる。

@item -funroll-loops
@opindex funroll-loops
繰り返し数がコンパイル時かループの入り口までに決定できるループを展開する。
@option{-funroll-loops}は@option{-frerun-cse-after-loop}, @option{-fweb}, @option{-frename-registers}を含む。
これは完全ループ引き剥がし（すなわち、小さい定数回の繰り返しのループを完全に除去する）もオンにする。
これはコードを大きくし、実行を速くするかもしれないししないかもしれない。

@option{-fprofile-use}で有効になる。

@item -funroll-all-loops
@opindex funroll-all-loops
すべてのループを、たとえループ開始時に繰り返し数が不確定でも行う。これは通常プログラムの実行を遅くする。
@option{-funroll-all-loops}は@option{-funroll-loops}と同じオプションを含む。

@item -fpeel-loops
@opindex fpeel-loops
（プロファイル・フィードバックから）情報が十分にあるあまり巻かれないループを引き剥がす。
これは完全ループ引き剥がし（すなわち、小さい定数回の繰り返しのループを完全に除去する）もオンにする。

@option{-fprofile-use}で有効になる。

@item -fmove-loop-invariants
@opindex fmove-loop-invariants
RTLループ最適化器でループ不変移動パスを有効にする。レベル@option{-O1}で有効になる。

@item -fsplit-loops
@opindex fsplit-loops
反復空間の一方の側で常に真であり、他方で偽である条件を含む場合、ループを2つに分割する。

@item -funswitch-loops
@opindex funswitch-loops
ループ不変条件の分岐を、両方の分岐でループの重複させて、ループの外へ移動する。（条件の結果に応じて修正する）

@item -ffunction-sections
@itemx -fdata-sections
@opindex ffunction-sections
@opindex fdata-sections
もしターゲットが任意のセクションをサポートしていたらそれぞれの関数やデータアイテムを出力ファイルの自身のセクションに置く。
関数やデータアイテムの名前は出力ファイルのセクションの名前を決定する。

リンカが最適化を実行して命令空間内の参照の局所性を改善できるシステムでは、これらのオプションを使用する。 ELFオブジェクト形式を使用するほとんどのシステムは、そのような最適化を備えたリンカを持っている。 AIXでは、リンカーはコールグラフに基づいてセクション（CSECT）を再配置する。 パフォーマンスへの影響はさまざまである。
 
 リンカのガベージコレクション（リンカの@option{-gc-sections}オプション）と一緒に使うと、これらのオプションは静的にリンクされた実行可能ファイル（ストリッピング後）を小さくするかもしれない。
 
 ELF / DWARFシステムでは、これらのオプションはデバッグ情報の品質を劣化させない。 他のオブジェクトファイル/デバッグ情報フォーマットでは問題がある可能性がある。

これらのオプションは、大きな利点がある場合にのみ使用すること。 これらのオプションを指定すると、アセンブラとリンカはより大きなオブジェクトファイルと実行可能ファイルを作成し、処理速度も低下する。 これらのオプションはコード生成に影響する。 それらはリンク時間まで未知であるため、翻訳ユニット内の相対位置を使用するコンパイラおよびアセンブラによる最適化を妨げる。このような最適化の一例は、ショートコール命令へのコールを緩和することである。

@item -fbranch-target-load-optimize
@opindex fbranch-target-load-optimize
プロローグ・エピローグスレッディングの前に分岐目標レジスタロード最適化を行う。
目標レジスタの使用は典型的にはリロードの間のみ露出するので、ループ外へのロードの持ち上げとブロック内スケジューリングは
別の最適化パスが必要である。

@item -fbranch-target-load-optimize2
@opindex fbranch-target-load-optimize2
プロローグ・エピローグスレッディングの後に分岐目標レジスタロード最適化を行う。

@item -fbtr-bb-exclusive
@opindex fbtr-bb-exclusive
分岐目標レジスタロード最適化を行っている時に、どの基本ブロック内でも分岐目標レジスタを再利用しない。

@item -fstdarg-opt
@opindex fstdarg-opt
可変数引数の使用法に関して、その関数のプロローグを最適化する。

@item -fsection-anchors
@opindex fsection-anchors
近くのオブジェクトを指す共有「アンカー」シンボルを使うことでシンボルアドレス計算の数を削減しようとする。
この変換はGTO項目の数とあるターゲットでのGTO項目アクセスを削減するのを助ける。

例えば、以下の関数@code{foo}の実装で

@smallexample
static int a, b, c;
int foo (void) @{ return a + b + c; @}
@end smallexample

@noindent
は通常すべての三つの変数のアドレスを計算するが、もし@option{-fsection-anchors}でコンパイルしたら、
代わりに共通アンカーポイントから変数にアクセスする。効果は以下の（正当なCではない）擬似コードと同様である。

@smallexample
int foo (void)
@{
  register int *xr = &x;
  return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
@}
@end smallexample

すべてのターゲットがこのオプションをサポートしているわけではない。

@item --param @var{name}=@var{value}
@opindex param
ある場所で、GCCはは行われる最適化の量を制御する様々な定数を使う。例えば、
GCCは命令がある数より大きい関数はインライン化しない。コマンドラインで
@option{--param}オプションを使うことでこれらの定数のいくつかを制御することができる。

指定されたパラメータの名前、値の意味はコンパイラの内部と結びついていて、
将来のリリースで注意なしに変わる対象である。

どの場合にも、@var{value}は整数である。@var{name}の可能な選択肢は以下である。

@table @gcctabopt
@item predictable-branch-outcome
分岐がこの（％での）閾値よりも小さい確率で予測されるならば、よく予測可能だとみなされる。デフォルトは10である。

@item max-rtl-if-conversion-insns
RTLのif変換がブロック周りの条件付き分岐を削除して条件付き実行命令で置換しようとする。
このパラメータはif変換で考慮されるべきブロックの最大命令数を与える。デフォルトは10であるが、
コンパイラはif変換が利益がありそうかどうかを決定するために他のヒューリスティックも使う。

@item max-rtl-if-conversion-predictable-cost
@itemx max-rtl-if-conversion-unpredictable-cost
RTL if-conversionは、ブロックの周りの条件分岐を削除し、それらを条件付きで実行された命令に置き換えようとする。 これらのパラメータは、ブランチが予測可能であると静的に決定されているかどうかに応じて、if変換によって生成されるシーケンスの許容最大コストを示す。 このパラメータの単位は、GCCの内部seq_costメトリックの単位と同じである。 コンパイラは、BRANCH_COSTターゲットマクロを使用して、このパラメータに合理的なデフォルトを提供しようとする。

@item max-crossjump-edges
クロス・ジャンプのために考慮する入って来るエッジの最大数。@option{-fcrossjumping}により用いられるアルゴリズムは、
各々のブロックへのエッジ入力の数の@math{O(N^2)}である。値の増加はより積極的な最適化を意味する。そして、
コンパイル時間を増加させ、おそらく実行サイズで少し向上させる。

@item min-crossjump-insns
クロスジャンプが行われる前に２つのブロックの終わりに一致しなければならない命令の最小数。
この値はそこからクロスジャンプされるブロックの全命令が一致した場合には無視される。
デフォルト値は5である。

@item max-grow-copy-bb-insns
ジャンプの代わりに基本ブロックがコピーされるときに最大コードサイズ拡張係数。
拡張はジャンプ命令との比率である。デフォルト値は8である。

@item max-goto-duplication-insns
計算gotoへジャンプするブロックへの重複する命令の最大値。
いくつかのパスにおいて@math{O(N^2)}ふるまいを避けるために、
GCCはできるだけ遅く、早く計算されたgotosをコンパイル・プロセスを分解し、それらをできるだけ遅くに結合する。
max-goto-duplication-命令を超えない基本ブロックの末端での計算ジャンプのみが結合される。
デフォルト値は8である。

@item max-delay-slot-insn-search
遅延スロットを満たす命令を探すときに考慮される命令の最大数。もしこの任意の命令数よりも多くが見つかったならば、
遅延スロットを埋める時間を節約し、検索を止める。値を増やすともっと積極的な最適化を意味し、コンパイル時間を増やして
おそらく実行時間に小さな向上をするだろう。

@item max-delay-slot-live-search
遅延スロットを埋めるときに、正当な生存レジスタ情報のあるブロックを検索するときに考慮される命令の最大数。
この任意の選ばれた値を増やすともっと積極的な最適化を意味し、コンパイル時間を増やすだろう。
このパラメータは制御フローグラフを維持するために遅延スロットコードが書き直された時には削除されるべきである。

@item max-gcse-memory
大域共通部分式除去最適化を行うために割り当てられるおおよその最大メモリ量。もし指定されたよりも多くのメモリが必要ならば、
最適化は行われない。

@item max-gcse-insertion-ratio
もし削除に対する式挿入比が任意の式でこの値よりも大きいならば、RTL PREは式の挿入や削除を行い、
命令ストリームでの部分冗長計算を残す。デフォルト値は20である。

@item max-pending-list-length
現在の状態をフラッシュして完全に始める前に許可する保留依存スケジューリングの最大値。
少ない分岐や関数呼び出しの大きな関数は不必要にメモリや資源を消費する非常に大きなリストを作るかもしれない。

@item max-modulo-backtrack-attempts
スケジューラがループ中でモジュロスケジューリングをするときに作るべきバックトラックの試みの最大数。
大きな値はコンパイル時間を非常に増やしうる。

@item max-inline-insns-single
GCCで使われるツリーインライン化器を制御する幾つかのパラメータ。
この数はツリーインライン化器がインライン化を考慮する単一関数での（GCCの内部表現で数えられた）
命令の最大数をセットする。これはinlineと宣言された関数とクラス宣言(C++)で実装されたメソッドのみに影響する。
デフォルト値は400である。

@item max-inline-insns-auto
@option{-finline-funcions}(@option{-O3}に含まれる)を使った時、
さもなければコンパイラによってインラインの考慮をされない多数の関数が調査される。
それらの関数にとって、インラインと宣言された関数と比較して異なる（より制限的な）制限が適用される。
デフォルト値は30である。

@item inline-min-speedup
呼び出し元・呼び出し先の推測されたパフォーマンスの向上がこの（パーセントでの）閾値を超えると、
@option{--param max-inline-insns-single}と@option{--param max-inline-insns-auto}の制限にもかかわらず
インライン化されうる。デフォルト値は15である。

@item large-function-insns
ほんとうに大きい関数を指定する制限。インライン化の後でこの制限よりも大きい関数では、インライン化は
@option{--param large-function-growth}によって抑制される。このパラメータはバックエンドによって使われる
非線形アルゴリズムによる極端なコンパイル時間を避けるために主に役立つ。
デフォルト値は2700である。

@item large-function-growth
パーセントで、インライン化で引き起こされる大きな関数の最大成長率を指定する。
デフォルト値は100で元のサイズの2倍の大きさに制限される。

@item large-unit-insns
大きな翻訳単位を指定する制限。この制限より大きい単位のインライン化によって引き起こされる成長は
@option{--param inline-unit-growth}によって制限される。小さい単位ではこれは厳しすぎるかもしれない。
例えば、インライン化されるA関数とAを3回呼ぶだけのBを考える。もしBがAがに比べて小さいならば、
成長率は300\%だがそれでもそのようなインライン化はとてもまともである。しかし、小さいインライン化可能な関数を含むとても大きな単位では、
全体の成長率制限はコードサイズの指数的拡大を避けるために必要である。したがって、もっと小さい単位では、
サイズは@option{--param inline-unit-growth}が適用される前に@option{--param large-unit-insns}へと増やされる。
デフォルトは10000である。

@item inline-unit-growth
インライン化によって起こされるコンパイル単位の全体の最大成長率を指定する。
デフォルトは20で元のサイズ1.2倍に制限される。冷たい関数（属性によってか
プロファイル・フィードバックによって）は単位サイズに入らない。

@item ipcp-unit-growth
手続間定数伝搬によって起こされるコンパイル単位の全体の最大成長率を指定する。
デフォルト値は10で元のサイズ1.1倍に制限される。

@item large-stack-frame
大きなスタックフレームを指定する制限。インライン化の間にアルゴリズムはこの制限をあまり超えて成長しないようにしようとする。
デフォルト値は265バイトである。

@item large-stack-frame-growth
インライン化で起こされる大きなスタックフレームの最大成長率をパーセントで指定する。
デフォルト値は1000で元のサイズの11倍にスタックフレームの成長を制限する。

@item max-inline-insns-recursive
@itemx max-inline-insns-recursive-auto
再帰インライン化をすることによって自己再帰インライン関数の線からはみ出たコピーが成長する命令の最大数を指定する。

@option{--param max-inline-insns-recursive}はインラインと宣言された関数に適用される。インラインと宣言されていない関数では、
再帰インライン化は@option{-finline-functions} (@option{-O3}に含まれる)が有効の時だけ起こる。
代わりに@option{--param max-inline-insns-recursive-auto}が適用される。デフォルト値は450である。

@item max-inline-recursive-depth
@itemx max-inline-recursive-depth-auto
再帰インライン化で使われる最大再帰深さを指定する。

@option{--param max-inline-recursive-depth}はインラインと宣言された関数に適用される。インラインと宣言されていない関数では、
再帰インライン化は@option{-finline-functions} (@option{-O3}に含まれる)が有効の時だけ起こる。
代わりに@option{--param max-inline-recursive-depth-auto}が適用される。デフォルト値は8である。

@item min-inline-recursive-probability
再帰インライン化は平均で深い再帰を持つ関数にだけ有益であまり再帰が深くない関数には
プロローグサイズや関数本体の複雑性の増加によって他の最適化器を傷つけうる。

プロファイル・フィードバックが利用可能(@option{-fprofile-generate}参照)な時、
実際の再帰深さは与えられた関数式経由で関数が再帰する確率から推測できる。
パラメータはその確率が与えられた（パーセントでの）しきい値を超えた呼び出し式のみをインライン化するように制限する。
デフォルト値は10である。

@item early-inlining-insns
初期インライン化が作る成長率を指定する。実際には大きな抽象化ペナルティを持つコードのインライン化の量を増加させる。
デフォルト値は14である。

@item max-early-inliner-iterations
初期インライン化の繰り返し数を制限する。これは基本的には初期インライン化は解決できる入れ子の間接呼び出しの数を制限する。
深い連鎖はまだ後のインライン化で扱われる。

@item comdat-sharing-probability
combat可視性のあるC++のインライン関数が複数のコンパイル単位をまたいで共有される（パーセントでの）確率。
デフォルト値は20である。

@item profile-func-internal-id
プロファイルデータベース検索での関数内部IDを使うかどうかを制御するパラメータ。もし値が0ならば、コンパイラは
関数でアセンブラ名とファイル名に基づいたIDを使い、古いプロファイルデータを関数並べ替えなどのソースの変更にもっと
耐えられるようにする。デフォルト値は0である。

@item min-vect-loop-bound
@option{-ftree-vectorize}が使われた時にループがベクトル化されない最小の繰り返し数。
ベクトル化を可能にするためにはベクトル化後の繰り返し数がこのオプションによって指定された値よりも大きい必要がある。
デフォルト値は0である。

@item gcse-cost-distance-ratio
GCSE最適化によって移動させる表現の最大距離の計算での拡大率。これは現在コード持ち上げ過程でのみサポートされていrう。
比率を大きくするほど、もっと積極的なコード持ち上げが単純な式によって、すなわち、コストが
@option{gcse-unrestricted-cost}未満である式によって行われる。0を指定すると単純な式の持ち上げを無効にする。
デフォルト値は10である。

@item gcse-unrestricted-cost
大雑把に単一の典型的な機械語のコストによって測られる、GCSE最適化が式が移動できる距離を拘束しないコストである。
これは現在コード持ち上げ過程でのみサポートされている。コストを小さくすると、より積極的なコード持ち上げをなる。
0を指定するとすべての式が未制限の距離を移動できるようになる。デフォルト値は3である。

@item max-hoist-depth
ドミネーター・ツリーで式を持ち上げる時の検索の深さ。これは持ち上げアルゴリズムで二次の振る舞いを避けるのに使われる。
0の値は、検索に対する制限をせず、巨大な関数のコンパイルを遅くするかもしれない。デフォルト値は、30である。

@item max-tail-merge-comparisons
bbと比較する類似のbbの最大量。これは木末端マージの二次の振る舞いを避けるために使われる。
デフォルト値は10である。

@item max-tail-merge-iterations
関数を超えた経路の繰り返しの最大値。これは木末端マージでのコンパイル時間を制限するために使われる。
デフォルト値は2である。

@item store-merging-allow-unaligned
ストアのマージパスで、アライメントの合わないストアを導入することが合法的である場合は、許可する。 デフォルト値は1である。

@item max-stores-to-merge
ストアのマージパスでより広いストアにマージしようとするストアの最大数。 最小値は2、デフォルトは64である。

@item max-unrolled-insns
ループは展開されなければならないかもしれない命令の最大値。もしループが展開されたなら、このパラメータは
ループコードが何回展開されるかも決定する。

@item max-average-unrolled-insns
ループが展開されなければならない実行の確率によって重み付けされた命令の最大値。
もしループが展開させるなら、このパラメータは何回ループが展開されるかも決定する。

@item max-unroll-times
単一のループの展開の最大値。

@item max-peeled-insns
ループが引き剥がされるかもしれない命令の最大値。もしループが剥がされるならば、
このパラメータは何回ループコードが剥がされるかも決定する。

@item max-peel-times
単一ループの引き剥がしの最大値。

@item max-peel-branches
引き剥がされた列を通したホットな経路の分岐の最大値。

@item max-completely-peeled-insns
完全に引き剥がされたループの命令の最大値。

@item max-completely-peel-times
完全引き剥がしに適したループの繰り返し数の最大値。

@item max-completely-peel-loop-nest-depth
完全引き剥がしに適した入れ子ループの最大深さ。

@item max-unswitch-insns
非分岐されたループの命令の最大値。

@item max-unswitch-level
単一ループでの非分岐された分岐の最大値。

@item max-loop-headers-insns
コピーループヘッダによって複製されるループヘッダでの命令の最大数。

@item lim-expensive
ループ不変移動での高価な式の最小コスト。

@item iv-consider-all-candidates-bound
すべての候補が誘導変数最適化で使用ごとに考慮される、誘導変数の候補の数の範囲。
もしこれよりも候補が多いならば、二次の時間複雑性を避けるために最も重要なものだけが考慮される。

@item iv-max-considered-uses
誘導変数が使う以上を含むループで誘導変数最適化を諦める。

@item iv-always-prune-cand-set-bound
もし集合での候補の数がこの値よりも小さいならばいつも新規を追加するときに集合から不必要な誘導変数を
取り除こうとする。

@item avg-loop-niter
Average number of iterations of a loop.

@item dse-max-object-size
デッド・ストア除去によって追従されるオブジェクトの最大サイズ（バイト単位）。
値を大きくするとコンパイル時間が長くなる可能性がある。

@item scev-max-expr-size
スカラー変化解析で使われる式のサイズの境界。大きな式は解析器を遅くする。

@item scev-max-expr-complexity
スカラー変化解析器での式の複雑性の境界。複雑な式は解析器を遅くする。

@item max-tree-if-conversion-phi-args
ループがsimdプラグマでマークされていない場合、TREEによってサポートされているPHIの引数の最大数。

@item vect-max-version-for-alignment-checks
ベクトル化でのアラインメントのループバージョン化をしている時に行われる実行時チェックの最大数。

@item vect-max-version-for-alias-checks
ベクトル化で別名のループバージョン化をしている時に行われる実行時チェックの最大数。

@item vect-max-peeling-for-alignment
ベクトル化でアクセスアラインメントを強化するためのループ剥がしの最大値。値-1は制限なしを意味する。

@item max-iterations-to-track
評価しようとするループの繰り返し数の解析のためのループの虱潰しアルゴリズムの最大繰り返し数。

@item hot-bb-count-ws-permille
もし基本ブロックプロファイルのカウントが全体のプロファイルされた実行のパーミル（すなわち0から1000）で与えられたものに
達したならば熱いとみなされる。

@item hot-bb-frequency-fraction
与えられた基本ブロックが熱いとみなされなければならない関数での基本ブロックの実行の入り口ブロック頻度の割合を選択する。

@item max-predicted-iterations
静的に予測するループ繰り返し数の最大値。これは関数が既知の境界を持つ単一ループと未知の境界を持つ別のループを含んでいる場合に
役立つ。既知の繰り返し回数は正確に予測されるが、未知の繰り返し回数は大雑把に平均10と予測される。これは
境界のないループは他のものに比べて人工的に冷たいことを意味する。

@item builtin-expect-probability
指定された値を持つ式の確率を制御する。このパラメータは入力でパーセント（0から100）を取る。
90のデフォルト確率は経験的に得られている。

@item align-threshold
基本ブロックをアラインメントするために関数内の基本ブロックの実行の最大頻度の割合を選択する。

@item align-loop-iterations
ループが少なくとも選択された繰り返し数がアラインメントされていると予期されるだけ繰り返す。

@item tracer-dynamic-coverage
@itemx tracer-dynamic-coverage-feedback

一旦実行された命令の与えられたパーセンテージがカバーされるならば、
この値はスーパーブロック構造を制限するのに用いられる。これは不必要なコードサイズ拡張を制限する。

@option{tracer-dynamic-coverage-feedback}パラメータはプロファイル・フィードバックが利用可能なときだけ使われる。
（静的に推測されたものに対して、）本当のプロファイルはずっと非均等的で、大きな値へのしきい値を可能にする。

@item tracer-max-code-growth
一旦末端重複化コード成長が与えられたパーセンテージに達したらならば止める。これは、重複の大抵が後でクロスジャンプで除去されるので、
むしろ人工的な制限であり、望まれたコード成長よりもずっと高い値にセットされるかもしれない。

@item tracer-min-branch-ratio
最良エッジの逆確率が（パーセントで）この境界を下回ったた時に逆成長を止める。

@item tracer-min-branch-probability
@itemx tracer-min-branch-probability-feedback

もし最良エッジがこの境界を下回る確率を持つならば前方成長を止める。

@option{tracer-dynamic-coverage}と同様に2つのパラメータが提供される。
@option{tracer-min-branch-probability-feedback}がプロファイルフィードバックありでコンパイルした時に使われ、
@option{tracer-min-branch-probability}がなしの時にコンパイルした時に使われる。
プロファイルフィードバックありでのコンパイルｄの値はトレーサーを効果的にするためにはより保守的（高く）する必要がある。

@item stack-clash-protection-guard-size
Specify the size of the operating system provided stack guard as
2 raised to @var{num} bytes.  The default value is 12 (4096 bytes).
Acceptable values are between 12 and 30.  Higher values may reduce the
number of explicit probes, but a value larger than the operating system
provided guard will leave code vulnerable to stack clash style attacks.

@item stack-clash-protection-probe-interval
Stack clash protection involves probing stack space as it is allocated.  This
param controls the maximum distance between probes into the stack as 2 raised
to @var{num} bytes.  Acceptable values are between 10 and 16 and defaults to
12.  Higher values may reduce the number of explicit probes, but a value
larger than the operating system provided guard will leave code vulnerable to
stack clash style attacks.

@item max-cse-path-length
CSEが考える経路での基本ブロックの最大値。デフォルトは10である。

@item max-cse-insns
フラッシュの前のCSEが持つ最大命令数。デフォルトは1000である。

@item ggc-min-expand

GCCは自身のメモリ割り当てを管理するためにガベージコレクションを使う。
このパラメータははガベージコレクタのヒープが収集の間に拡張を許す最小のパーセンテージを指定する。
これを調整するとコンパイル速度を向上させるかもしれないが、コード生成には影響がない。

デフォルトは30% + 70% * (RAM/1GB)でRAM >= 1GBの時は上限100%である。もし@code{getrlimit}が利用可能なときは、
「RAM」の表記は実際のRAMと@code{RLIMIT_DATA}と@code{RLIMIT_AS}の最小値である。
もし特定のプラットフォームでRAMが計算出来ない時は、下界の30%が使われる。
このパラメータと@option{ggc-min-heapsize}をゼロにセットすると全機会で完全収集を引き起こす。
これはとても遅いが、デバッグには役立つ。

@item ggc-min-heapsize

ゴミを収集することを気にし始める前のガベージコレクタの最小サイズ。
最初の収集は@option{ggc-min-heapsize}を@option{ggc-min-expand}%超えてヒープが拡張した後に起こる。
再び、これを調整するとコンパイル速度を向上させるかもしれないが、コード生成には影響がない。

デフォルトはRAM/8、RLIMIT_TSS、RLIMIT_DATAかRLIMIT_ASが拡張しないことを保証しようとする限界の最小
であるが、下界は4096(４メガバイト）で上界は131072(１２８メガバイト）である。もしGCCは特定のプラットフォームで
RAMを計算出来ない時は、下界が使われる。このパラメータをとても大きくすると事実上ガベージコレクションを無効にする。
このパラメータと@option{ggc-min-expand}をゼロにすると全機会で完全収集を引き起こす。

@item max-reload-search-insns
等価レジスタを後方検索する命令リロードの最大数。値を増やすともっと積極的な最適化を意味し、
コンパイル時間を増加させておそらく少しパフォーマンスを向上させる。デフォルト値は100である。

@item max-cselib-memory-locations
cselibが考慮するメモリ場所の最大値。値を増やすともっと積極的な最適化を意味し、
コンパイル時間を増加させておそらく少しパフォーマンスを向上させる。デフォルト値は500である、

@item max-sched-ready-insns
第1スケジュールパスの間に与えられた時間でスケジューラで考慮される発せる準備ができた命令の最大値。
値を増やすもっと徹底的な検索をすることを意味し、コンパイル時間を増加させておそらく小さな利点がある。
デフォルト値は100である。

@item max-sched-region-blocks
ブロック間スケジューリングで考慮される領域のブロックの最大数。デフォルト値は10である。

@item max-pipeline-region-blocks
選択的スケジューラでパイプライン化で考慮される領域のブロックの最大数。デフォルト値は15である。

@item max-sched-region-insns
ブロック間スケジューリングで考慮される領域の命令の最大数。デフォルト値は100である。

@item max-pipeline-region-insns
選択的スケジューラでのパイプライン化で考慮される領域の命令の最大数。デフォルト値は200である。

@item min-spec-prob
ブロック間推測スケジューリング用のソースブロック到達の（パーセントでの）最小確率。デフォルト値は40である。

@item max-sched-extend-regions-iters
CFGを通しての拡張領域への繰り返しの最大数。値0（デフォルト）は領域拡張を無効にする。

@item max-sched-insn-conflict-delay
推測移動で考慮される命令の最大衝突遅延。デフォルト値は3である。

@item sched-spec-prob-cutoff
推測成功で、推測命令がスケジューリングされる（パーセントでの）最小確率。
デフォルト値は40である。

@item sched-state-edge-prob-cutoff
スケジューラがエッジ全体でその段階を保存するためになければならない最小限の確率。
デフォルト血は10である。

@item sched-mem-true-dep-cost
同じ場所を目的とするストアとロードの間の（CPUサイクルでの）最小距離。デフォルト値は1である。

@item selsched-max-lookahead
選択的スケジューリングの前方窓の最大サイズ。それは利用可能な命令の検索の深さである。
デフォルト値は50である。

@item selsched-max-sched-times
選択的スケジューリングの間に命令がスケジュールされる時間の最大値。
これは命令がそれを通してパイプライン化されるかもしれない繰り返し数の制限である。
デフォルト値は2である。

@item selsched-insns-to-rename
選択的スケジューリングでの名前変えで考慮される準備済みリストでの最良の命令の最大数。
デフォルト値は2である。

@item sms-min-sc
振動モジュロスケジューラーが生成するステージカウントの最小値。デフォルト値は2である。

@item max-last-value-rtl
そのレジスタの最後の既知の値として疑似レジスタのコンバイナの表現において記録されることができる多くのRTLとして計られる最大サイズ。
デフォルト値は10000である。

@item max-combine-insns
RTLコンバイナが結合しようとする命令の最大数。デフォルト値は@option{-Og}では2で、さもなければ4である。

@item integer-share-limit
小さい整数定数は共有データ構造を使うことができ、コンパイラのメモリ使用を減らして速度を速める。
これは共有整数定数の最大値をセットする。デフォルト値は256である。

@item ssp-buffer-size
@option{-fstack-protection}を使っている時のスタック破壊防御を受け取るバッファ（すなわち、配列）の最小値。

@item min-size-for-stack-sharing
最適化しない時のスタックスロット共有の一部をなす変数の最小サイズ。デフォルト値は32である。

@item max-jump-thread-duplication-stmts
スレッドジャンプの時に複製する必要があるブロックで許される行の最大値。

@item max-fields-for-field-sensitive
ポインタ解析の間でのフィールドに敏感なやり方で扱われる構造のフィールドの最大数。
デフォルトは@option{-O0}と@option{-O1}ではゼロで、@option{-Os}, @option{-O2}, @option{-O3}では100である。

@item prefetch-latency
プリフェッチが終わる前に実行される命令の平均値の推測。前もってプリフェッチされる距離は
この定数に比例する。この数を増やすとプリフェッチされるストリームも小さくなるかもしれない。
(@option{simultaneous-prefetches}参照)

@item simultaneous-prefetches
同時に走ることができるプリフェッチの最大数。

@item l1-cache-line-size
バイトでのL1キャッシュでのキャッシュラインのサイズ。

@item l1-cache-size
キロバイトでの、L1キャッシュのサイズ。

@item l2-cache-size
キロバイトでの、L2キャッシュのサイズ。

@item loop-interchange-max-num-stmts
The maximum number of stmts in a loop to be interchanged.

@item loop-interchange-stride-ratio
The minimum ratio between stride of two loops for interchange to be profitable.

@item min-insn-to-prefetch-ratio
命令数とループでのプリフェッチを可能にするためのプリフェッチの数の最小比。

@item prefetch-min-insn-to-mem-ratio
命令数とループのプリフェッチを可能にするためのメモリ参照の数の最小比。

@item use-canonical-types
コンパイラが「正規の」型システムを使うべき。デフォルトでは、これは常に1であるべきで、
C++とObjective-C++で型を比較するのにもっと効率のいい内部メカニズムを使う。しかし、
もし正規型システムでのバグが比較の失敗を起こすならば、正規型を無効にするためにこの値を0にセットする。

@item switch-conversion-max-branch-ratio
switch初期化変換がswitch内で@option{switch-conversion-max-branch-ratio}の分岐の数倍よりも大きい配列を作ることを拒否する。

@item max-partial-antic-length
@option{-O3}以上で最適化するときに木部分冗長除去(@option{-ftree-pre})の間に計算される部分奇怪集合の最大長。
ある種類のソースコードでは、強化された部分冗長除去最適化は暴走することがありえ、それはホスト機械で利用できるメモリの全てを消費する。
このパラメータは計算されるセットの長さの上に制限を置き、手に負えないふるまいを妨げる。
0の値をこのパラメータに設定することは、無制限のセットされた長さを許す。

@item sccvn-max-scc-size
SCCVN過程の間の強接続コンポネント(SCC)の最大サイズ。もしこの制限が当たれば、関数全体のSCCVN過程は行われず、
それに依存した最適化は行われない。デフォルト最大SCCサイズは10000である。

@item sccvn-max-alias-queries-per-access
ロードとストアの冗長を探すときに行うエイリアス・オラクルクエリの最大数。
もしこの制限が当たったならば検索は中止されロード・ストアは冗長とはみなされない。
クエリの数は関数エントリへのロード空のすべての経路でのストアの数へとアルゴリズム的に制限される。
クエリのデフォルト最大値は1000である。

@item ira-max-loops-num
IRAはデフォルトで領域レジスタ割り当てを使う。もし関数がこのパラメータで与えられう数よりも多くのループを含むなら、
多くとも領域レジスタ割り当ての領域からの最もよく実行されるループの与えられる数のみである。パラメータのデフォルト値は100である。

@item ira-max-conflict-table-size 
IRAは衝突テーブルを圧縮するために洗練されたアルゴリズムを用いているけれども、テーブルはそれでも巨大な関数には
かなりの量のメモリを要求しうる。もし関数の衝突テーブルがこのパラメータによってMBで与えられるサイズをよりも大きくなりうるなら、、
レジスタアロケータは代わりに疑似レジスタ衝突テーブルを作る必要がない速くて、単純で、低品質なアルゴリズムを使う。
パラメータのデフォルト値は2000である。

@item ira-loop-reserved-regs
IRAはループ不変式を移動するための決定のために(@option{-O3}参照)ループ内のもっと正確なレジスタ圧力を評価するために使うことができる。
ある他の目的のために予約された利用可能なレジスタの数はこのパラメータで与えられる。パラメータのデフォルト値は2で、
それは典型的な命令によって必要となるレジスタの最小数である。この値は数々の実験で最良であることがわかっている。

@item lra-inheritance-ebb-probability-cutoff
LRAは、以降の命令でのレジスタで再ロードされる値を再利用しようと試みる。
この最適化は継承と呼ばれる。EBBはこの最適化をするための領域として使われる。
パラメータはLRAでEBBを継承するためにBBを加えるために使われる最小のフォールスルーの最小確率を
パーセントで定義する。パラメータのデフォルト値は40である。値はx86-64でのSPEC2000の数々の実行から選択された。

@item loop-invariant-max-bbs-in-loop
ループ不変式移動は、とても大きいループでは、コンパイル時間とコンパイル時に必要なメモリの量の両方で、とても高価になりうる。
このパラメータよりも多い基本ブロックを持つループにはループ不変移動最適化が行われない。
パラメータのデフォルト値は@option{-O1}では1000で、@option{-O2}以上では10000である。

@item loop-max-datarefs-for-datadeps
とても大きいループではデータ遺贈の構築は高価である。このパラメータはデータ依存解析で考慮されるループでのデータ参照の数を
制限する。これらの大きいループはループデータ依存を使った最適化では扱われない。
デフォルト値は1000である。

@item max-vartrack-size
任意の関数の変数追跡データフロー解析の間に使うハッシュテーブルスロットの最大値をセットする。
もしこの制限が有効にされた代入での変数追跡で超えたならば、その関数からすべてのデバッグ命令を取り除いた後に
その関数の解析はそれ無しで再試行される。もし制限がデバッグ命令なしでさえ超過したならば、変数追跡解析はその関数では完全に無効にされる。
このパラメータを０にすると無制限になる。

@item max-vartrack-expr-depth
変数名かデバッグ一時値を値式へ割り当てようとするときの再帰レベルの最大値をセットする。
これはもっと完全なデバッグ情報のコンパイル時間と交換する。もしこれがあまりにも低くセットされていたら、
利用可能でデバッグ情報で表現されうる値式は最終的に使われないかもしれない。これを高くすると
コンパイラがもっと複雑なデバッグ式をみつけることができるかもしれないが、コンパイル時間とメモリが増えるかもしれない。
デフォルトは12である。

@item max-debug-marker-count
Sets a threshold on the number of debug markers (e.g. begin stmt
markers) to avoid complexity explosion at inlining or expanding to RTL.
If a function has more such gimple stmts than the set limit, such stmts
will be dropped from the inlined copy of a function, and from its RTL
expansion.  The default is 100000.

@item min-nondebug-insn-uid
非デバッグ命令用にこのパラメータで始まるuidを使う。このパラメータ未満の範囲は
@option{-fvar-tracking-assignments}で作られるデバッグ命令用に排他的に予約されているが、
デバッグ命令はこれより上の（重ならない）udiをもし予約された範囲が枯渇したなら使うかもしれない。

@item ipa-sra-ptr-growth-factor
それらの累積的なサイズが@option{ipa-sra-ptr-growth-factor}の最初のポインタ・パラメータのサイズ倍以下の時だけ、
IPA-SRAは一つ以上の新しいパラメータで集計へのポインタを置き換える。

@item sra-max-scalarization-size-Ospeed
@itemx sra-max-scalarization-size-Osize
２つの集合値のスカラー導出過程(SRAとIPA-SRA)は集合値のスカラー部分を独立のスカラー変数の使用に置換することを助ける。
これらのパラメータはストレージ単位での、それぞれ速度(@option{sra-max-scalarization-size-Ospeed})か
サイズ(@option{sra-max-scalarization-size-Osize})でコンパイルした時に置換として考慮される集合値の最大値を制御する。

@item tm-max-aggregate-size
トランザクション内でスレッド局所変数のコピーを作るときに、変数がロギングで関数を保存されるバイト単位のサイズが
コード・シーケンス一組をセーブ・リストアさせるように、このパラメータは指定する。
このオプションは@option{-fgnu-tm}を使っているときだけ適用される。

@item graphite-max-nb-scop-params
Graphiteループ変換での指数的な効果を避けるために、静的制御部分(SCoP)でのパラメータの数は制限される。デフォルト値は10個のパラメータで、0の値を使用して境界を持ち上げることができる。 コンパイル時に値が不明で、SCoPの外部で定義されている変数は、SCoPのパラメータである。

@item loop-block-tile-size
@option{-floop-block}か@option{-floop-strip-mine}で有効になる、ループブロッキングかループ露天掘り変換で、
与えられた繰り返し数によって入れ子のループ内のそれぞれのループで露天掘りを行う。
露天掘りの長さは@option{loop-block-tile-size}を使って変更できる。デフォルト値は51回である。

@item loop-unroll-jam-size
@option{-floop-unroll-and-jam}オプション用の展開係数を指定する。デフォルト値は4である。

@item loop-unroll-jam-depth
@option{-floop-unroll-and-jam}で展開される次元を（最も内側から数えて）指定する。
デフォルト値は2である。

@item ipa-cp-value-list-size
IPA-CPは関数のパラメータを伝搬させて非仮想化を実行するするためにすべての可能な値と渡された型を追おうとする。
@option{ipa-cp-value-list-size}は、それが関数の1つの形式的パラメータにつき保存する値と型の最大数である。

@item ipa-cp-eval-threshold
IPA-CPはクローンニング収益性ヒューリスティックのそれ自身の得点を計算して、
@option{ipa-cp-eval-threshold}を上回る得点で、それらのクローニング機会を行う。

@item ipa-cp-recursion-penalty
クローンニングで評価での再帰関数が受け取るパーセントのペナルティ。

@item ipa-cp-single-call-penalty
クローンニングの評価での他の関数の単一呼び出しを含む関数が受け取るパーセントのペナルティ。

@item ipa-max-agg-items
IPA-CPも、集合値で渡されるいくつかのスカラー値を伝播するための能力がある。
@option{ipa-max-agg-items}は、1つのパラメータにつきそのような値の最大数を制御する。

@item ipa-cp-loop-hint-bonus
クローニング候補が知られているループの繰り返しの数を作るとIPA-CPが決定するとき、
それは@option{ipa-cp-loop-hint-bonus}のボーナスを候補の収益性得点に加える。

@item ipa-cp-array-index-hint-bonus
クローニング候補が知られている配列アクセスのインデックスを作ることをIPA-CPが決定するとき、
それは@option{ipa-cp-array-index-hint-bonus}のボーナスを候補の収益性得点に加える。

@item ipa-max-aa-steps
関数本体のその解析の間、IPA-CPは、関数パラメータによって指される値を追うために、別名解析を使用する。
巨大な関数を分析することにあまりにたくさんの時間を費やさないために、それは諦めてメモリを修正している@option{ipa-max-aa-steps}分を調べた後に
破壊されるすべてのメモリを考慮する。

@item lto-partitions
WHOPRコンパイルの間、生み出される望ましい分割数を指定する。
分割数は、コンパイルのために使われるCPUの数を超えるべきである。
デフォルト値は、32である。

@item lto-min-partition
WHOPR（推定された命令で）のための最小の分割のサイズ。
これは、非常に小さいプログラムをあまりに多くの分割に分けることの費用を防ぐ。

@item lto-max-partition
パーティションの個々のサイズの上限を提供するWHOPRの最大パーティションサイズ（推定命令内）。
平衡パーティショニングでのみ使用することを意味する。

@item cxx-max-namespaces-for-diagnostic-help
C++名検索が識別子のために失敗するとき、提案について相談する名前空間の最大数。
デフォルトは、1000である。

@item sink-frequency-threshold
文が文の降下を許す本来のブロックと比較してターゲット・ブロックの最大相対的な（パーセントでの）実行頻度。
大きい数はより積極的な文の降下を起こす。デフォルト値は75である。それらは降下するほどより収益性の高いので、
小さな正の調整は、メモリ・オペランドを持つ文に適用される。

@item max-stores-to-sink
降下可能な条件付きストア対の最大数。もしベクトル化(@option{-ftree-vectorize})とif変換
(@option{-ftree-loop-if-convert})のどちらかが無効にされているなら0にセットする。
デフォルトは2である。

@item allow-store-data-races
最適化器がストアでの新しいデータ競合を導入することを許可する。
1にセットすると許可し、さもなければ0である。このオプションは最適化レベル@option{-Ofast}でデフォルトで有効である。

@item case-values-threshold
条件付き分岐の木の代わりにジャンプテーブルを使うのが最良である異なった値の最小値。
もし値が0ならば、その機種のデフォルトを使う。デフォルトは0である。

@item tree-reassoc-width
再結合木で並列に実行される命令の最大数。このパラメータはもし非0の値を持つならばデフォルトで使われる
ターゲット依存のヒューリスティックを上書きする。

@item sched-pressure-algorithm
@option{-fsched-pressure}の利用可能な2つの実装の間で選択する。
アルゴリズム１は元々の実装で命令が再整列されるのを最も防ぐだろう。
アルゴリズム２はアルゴリズム1によってされる比較的保守的なアプローチと
デフォルト・スケジューラによってされるむしろ積極的なアプローチの間の妥協であるように設計された。
それは、普通のレジスタ・ファイルと正確なレジスタ圧クラスがあることにより重く依存している。
詳細はGCCソースの@file{haifa-sched.c}を見よ。

デフォルトの選択肢はターゲットに依存している。

@item max-slsr-cand-scan
新しい直線強度縮小候補の基礎を探すときに考慮される存在する候補の最大数。

@item asan-globals
グローバルオブジェクトのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
グローバルオブジェクト防御を無効にするには@option{--param asan-globals=0}を使う。

@item asan-stack
スタックオブジェクトでのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
スタック防御を無効にするには@option{--param asan-stack=0}オプションを使う。

@item asan-instrument-reads
メモリ読み出しでのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
メモリ読み出し防御を無効にするには@option{--param asan-instrument-reads=0}を使う。

@item asan-instrument-writes
メモリ書き込みでのバッファ溢れ検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
メモリ書き込み防御を無効にするには@option{--param asan-instrument-writes=0}オプションを使う。

@item asan-memintrin
組み込み関数の検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
組み込み関数防御を無効にするには@option{--param asan-memintrin=0}を使う。

@item asan-use-after-return
使用後に復帰の検知を有効にする。この種類の防護は
@option{-fsanitize=address}オプションを使うときにはデフォルトで有効である。
使用後復帰の検知を無効にするには、@option{--param asan-use-after-return=0}を使う。

@item asan-instrumentation-with-call-threshold
もし測定される関数のメモリアクセスの数がこの数以上なら、インラインチェックの代わりにコールバックを使う。
例えば、インラインコードを無効にするには、@option{--param asan-instrumentation-with-call-threshold=0}を使う。

@item chkp-max-ctor-size
ポインタ範囲チェッカで生成される静的コンストラクタは、最適化レベル@option{-O1}以上では
とても大きく、コンパイル時間を増やすかもしれない。このパラメータは単一の生成されたコンストラクタでの
文の最大数である。デフォルト値は5000である。

@item max-fsm-thread-path-insns
有限状態オートマトンジャンプスレッド経路でのブロック複製でコピーされる命令の最大数。デフォルトは100である。

@item max-fsm-thread-length
有限状態オートマトンジャンプスレッド経路での基本ブロックの最大数。デフォルトは10である。

@item max-fsm-thread-paths
有限状態オートマトン用に作るための新しいジャンプスレッドの最大数。デフォルトは50である。

@item parloops-chunk-size
parloopsによって並列化されたループ用のompスケジュールのチャンクサイズ。デフォルトは0である。

@item parloops-schedule
parloopsによって並列化されたループ用のompスケジュールのスケジュールタイプ。（static, dynamic, guided, auto, runtime)
デフォルトはstatic。

@item parloops-min-per-thread
The minimum number of iterations per thread of an innermost parallelized
loop for which the parallelized variant is prefered over the single threaded
one.  The default is 100.  Note that for a parallelized loop nest the
minimum number of iterations of the outermost loop per thread is two.

@item max-ssa-name-query-depth
畳み込みルーチンのようなものでのSSA名の属性を要求するときの再帰の最大深さ。
再帰の1レベルはuse-def連鎖の追尾に対応する。

@item hsa-gen-debug-stores
libgompプラグインによってそれから読まれて、報告されるHSAカーネルの範囲内で、特別なデバッグ・ストアの放出を使用可能にする。
これらのストアの生成はデフォルトで無効にされているて、それを使用可能にするために、@option{--param hsa-gen-debug-stores=1}を使う。

@item max-speculative-devirt-maydefs
投機的に非仮想化できるかもしれない仮想呼び出しを呼び出すオブジェクトの動的型を指定する確実に定義されているものの検索時に解析する
定義されているかもしれないものの最大値。

@item max-vrp-switch-assertions
VRP中にswitchステートメントのデフォルトエッジに沿って追加するアサーションの最大数。 デフォルトは10である。

@item unroll-jam-min-percent
unroll-and-jam変換が利益をもたらすと考えられるように最適化する必要のあるメモリー参照の最小パーセンテージ。

@item unroll-jam-max-unroll
unroll-and-jam変換によって外側ループを展開する必要のある最大回数。

@end table
@end table

@node Instrumentation Options
@section プログラム計装オプション
@cindex instrumentation options
@cindex program instrumentation options
@cindex run-time error checking options
@cindex profiling options
@cindex options, program instrumentation
@cindex options, run-time error checking
@cindex options, profiling

実行時計装をそれが通常生成するコードに加えることを制御するいくつかのコマンド・ライン・オプションを、GCCはサポートする。
たとえば計装の1つの目的は、プログラム・ホットスポット、コード範囲解析またはプロフィール誘導最適化を見つけるために、
プロファイリング統計を集めることである。プログラム計装のもう一つの種類は
不正ポインタ被参照、境界線外配列アクセスなどのプログラミングエラーや、
スタック破壊やC++仮想テーブルハイジャックのような恋の敵対的攻撃の検知である。
デバッグまたはプログラム解析目的のために追跡または関数レベルの計装の道具他の形に使われることができる一般的なフックもある。

@table @gcctabopt
@cindex @command{prof}
@item -p
@opindex p
解析プログラム@command{prof}に適したプロファイル情報を書くための追加のコードを生成する。
このオプションをデータがほしいソースファイルをコンパイルするときに使わなければならず、
リンクするときにも使わなければならない。

@cindex @command{gprof}
@item -pg
@opindex pg
解析プログラム@command{gprof}に適したプロファイル情報を書くための追加のコードを生成する。
このオプションをデータがほしいソースファイルをコンパイルするときに使わなければならず、
リンクするときにも使わなければならない。

@item -fprofile-arcs
@opindex fprofile-arcs
プログラムフロー@dfn{arcs}が測定されるようにコードを追加する。実行の間に
プログラムはそれぞれの分岐と呼び出しが何回実行されるかと何回取られる・返るかを記録する。
コンパイルされたプログラムが終了するときにそれぞれのファイルごとに
@file{@var{auxname}.gcda}と呼ばれるファイルにこのデータを保存する。
データはプロファイルに指示された最適化(@option{-fbranch-probabilities})、
テストカバレッジ解析(@option{-ftest-coverage})でも使うことができる。
それぞれのオブジェクトファイルの@var{auxname}は、
もし明示的に指定されていて最終実行ファイルでないならば出力されたファイルの名前から生成され、
さもなければソースファイルの基底名である。両方の場合で拡張子は取り除かれる。
（例えば、入力ファイル@file{dir/foo.c}では@file{foo.gcda}であり、
@option{-o dir/foo.o})として指定された出力ファイルは@file{dir/foo.gcda}である。
@xref{Cross-profiling}.

@cindex @command{gcov}
@item --coverage
@opindex coverage
このオプションはカバレッジ解析のために測定されたコードをコンパイル・リンクするために使う。
このオプションは@option{-fprofile-arcs} @option{-ftest-coverage}(コンパイル時)と
@option{-lgcov}（リンク時）と同義語である。詳細はこれらのオプションを見よ。

@itemize

@item
@option{-fprofile-arcs}と最適化とコード生成オプションでソースファイルをコンパイルする。
テストカバレッジ解析のためには、追加の@option{-ftest-coverage}オプションを使う。
プログラムの全ソースファイルをプロファイルする必要はない。

@item
@option{-fprofile-abs-path}を使用してソースファイルをコンパイルし、@file{.gcno}ファイルに絶対パス名を作成する。 これにより@command{gcov}は異なる作業ディレクトリでコンパイルが行われるプロジェクトで正しいソースを見つけることができる。

@item
オブジェクトファイルを@option{-lgcov}ないし@option{-fprofile-arcs}でリンクする。
（後者は前者を含む）

@item
arcプロフィール情報を生成する代表的な作業負担の計画を実行する。これは任意回数繰り返されるかもしれない。プログラムの並列のインスタンスを走らせることができ、そして、ファイルシステムがロックすることをサポートするならば、データ・ファイルは正しく更新される。また、厳密なISO C変種が有効でない限り、@code{fork}呼び出しは見つけられて、二重カウントなしで正しく取り扱われる。

@item
プロファイル誘導最適化のためには、ソースファイルを再び同じ最適化とコード生成オプションに加えて@option{-fbranch-probabilities}
を使ってコンパイルする。 (@pxref{Optimize Options,,最適化を制御するオプション}).

@item
テストカバレッジ解析のためには、@file{.gcno}と@file{.gcda}ファイルから人間が読める情報を生成するために@command{gcov}を使う。
さらなる情報は@command{gcov}文書を参照のこと。

@end itemize

@option{-fprofile-arcs}で、あなたのプログラムのそれぞれの関数でGCCはデータフローグラフを作成し、
グラフの全域木を見つける。全域木になりarcのみが測定される。コンパイラはそれらのarcが実行される回数を数えるコードを追加する。
arcが唯一の出口であるかブロックへの唯一の入り口であるとき、測定コードがブロックに追加される。
さもなければ、新しいキボンブロックが測定コードを保持するために作られなければならない。

@need 2000
@item -ftest-coverage
@opindex ftest-coverage
@command{gcov}コード解析ユーティリティ(@pxref{Gcov,, @command{gcov}---テストカバレッジプログラム})が
プログラムカバレッジを表示するために使うことができるノートファイルを生成する。
それぞれのソースファイルのノートファイルは@file{@var{auxname}.gcno}と呼ばれる。
テストカバレッジデータを生成する方法での@var{auxname}と命令の説明のために、
上記の@option{-fprofile-arcs}オプションを参照せよ。
最適化しないならば、カバレッジデータはより密接にソース・ファイルに一致する。

@item -fprofile-abs-path
@opindex fprofile-abs-path
Automatically convert relative source file names to absolute path names
in the @file{.gcno} files.  This allows @command{gcov} to find the correct
sources in projects where compilations occur with different working
directories.

@item -fprofile-dir=@var{path}
@opindex fprofile-dir

@var{path}に中でプロフィール・データ・ファイルを捜すためのディレクトリを決める。
このオプションは、@option{-fprofile-generate}、@option{-ftest-coverage}、@option{-fprofile-arcs}によって生成されて、
@option{-fprofile-use}と@option{-fbranch-probabilities}とその関連したオプションによって使われるプロフィール・データだけに影響を及ぼす。
絶対と相対パスが、使われることができる。
デフォルトで、GCCは@var{path}としてカレント・ディレクトリを使い、したがって
プロフィール・データ・ファイルはオブジェクト・ファイルと同じディレクトリに現れる。

@item -fprofile-generate
@itemx -fprofile-generate=@var{path}
@opindex fprofile-generate

測定アプリケーションがプロフィール・フィードバックに基づいた最適化での後の再コンパイルに役立つプロフィールを生成するのに通常使われる
オプションを有効にする。@option{-fprofile-generate}をコンパイルとリンクの両方で使わなくてはならない。

以下のオプションが有効になる： @option{-fprofile-arcs}, @option{-fprofile-values}, @option{-fvpt}.

もし@var{path}が指定されたならば、GCCはプロファイルフィードバックデータファイルを見つけるために@var{path}を見る。
@option{-fprofile-dir}を見よ。

収集されたプロファイル情報に基づいてプログラムを最適化するためには、@option{-fprofile-use}を使う。
さらなる情報は@xref{Optimize Options}。

@item -fprofile-update=@var{method}
@opindex fprofile-update

プロファイルフィードバックベースの最適化のために計測されたアプリケーションの更新メソッドを変更する。 @var{method}引数は@samp{single}、@samp{atomic}または@samp{prefer-atomic}のいずれかでなければならない。
最初のものはシングルスレッドのアプリケーションには便利だが、2番目のものはスレッドセーフなコードを出力することでプロファイルの破損を防ぎます。

@strong{警告:} アプリケーションがすべてのスレッドを正しくジョインしない場合（または分離されたスレッドを作成する）は、プロファイルファイルはまだ破損する可能性がある。

@samp{prefer-atomic}を使うと、ターゲットでサポートされている場合は@samp{atomic}に、それ以外の場合は@samp {single}に変換される。 コマンドラインに@option{-pthread}がある場合、GCCドライバは自動的に@samp{prefer-atomic}を選択する。

@item -fsanitize=address
@opindex fsanitize=address
高速なメモリエラー検知器のAddressSanitizerを有効にする。
メモリアクセス命令は境界外と解放後使用のバグを検知するために測定される。
さらなる詳細は@uref{https://github.com/google/sanitizers/wiki/AddressSanitizer}を見よ。
実行時の振る舞いは@env{ASAN_OPTIONS}環境変数を使って影響させることができる。
@code{help=1}をセットすると、測定されるプログラムの開始時に利用可能なオプションが表示される。
サポートされているオプションのリストは@url{https://github.com/google/sanitizers/wiki/AddressSanitizerFlags#run-time-flags}を見よ。
このオプションは@option{-fsanitize=thread}かつ/及び@option{-fcheck-pointer-bounds}と組み合わせることはできない。

@item -fsanitize=kernel-address
@opindex fsanitize=kernel-address
Linuxカーネル用のAddressSanitizerを有効にする。詳しい詳細は@uref{https://github.com/google/kasan/wiki}を見よ。

@item -fsanitize=pointer-compare
@opindex fsanitize=pointer-compare
Instrument comparison operation (<, <=, >, >=) with pointer operands.
The option must be combined with either @option{-fsanitize=kernel-address} or
@option{-fsanitize=address}
The option cannot be combined with @option{-fsanitize=thread}
and/or @option{-fcheck-pointer-bounds}.
Note: By default the check is disabled at run time.  To enable it,
add @code{detect_invalid_pointer_pairs=2} to the environment variable
@env{ASAN_OPTIONS}. Using @code{detect_invalid_pointer_pairs=1} detects
invalid operation only when both pointers are non-null.

@item -fsanitize=pointer-subtract
@opindex fsanitize=pointer-subtract
Instrument subtraction with pointer operands.
The option must be combined with either @option{-fsanitize=kernel-address} or
@option{-fsanitize=address}
The option cannot be combined with @option{-fsanitize=thread}
and/or @option{-fcheck-pointer-bounds}.
Note: By default the check is disabled at run time.  To enable it,
add @code{detect_invalid_pointer_pairs=2} to the environment variable
@env{ASAN_OPTIONS}. Using @code{detect_invalid_pointer_pairs=1} detects
invalid operation only when both pointers are non-null.

@item -fsanitize=thread
@opindex fsanitize=thread
高速なデータ競合検知器のThreadSanitizerを有効にする。
メモリアクセス命令はデータ競合バグを検知するために測定される。
さらなる詳細は@uref{https://github.com/google/sanitizers/wiki#threadsanitizer}を見よ。
実行時の振る舞いは@env{TSAN_OPTIONS}環境変数を使って影響させることができる。
サポートされているオプションのリストは@url{https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags}を見よ。
このオプションは@option{-fsanitize=address}, @option{-fsanitize=leak},
かつ/及び@option{-fcheck-pointer-bounds}と組み合わせることはできない。

@item -fsanitize=leak
@opindex fsanitize=leak
メモリリーク検知器のLeakSanitizerを有効にする。
このオプションはもし@option{-fsanitize=address}と@option{-fsanitize=thread}のどちらも使われていないならば
実行ファイルのリンクにのみ関連する。そのような場合には、実行ファイルは@code{malloc}と他の割り当て関数を上書きする
ライブラリに対してリンクされる。さらなる詳細は
@uref{https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer}を見よ。
実行時の振る舞いは@env{LSAN_OPTIONS}環境変数を使って影響させることができる。
このオプションは@option{-fsanitize=thread}と組み合わせることはできない。

@item -fsanitize=undefined
@opindex fsanitize=undefined
高速な未定義の振る舞い検知器、UndefinedBehaviorSanitizerを有効にする。
実行時の未定義の振る舞いを検知するために様々な計算が測定される。現在のサブオプションは以下である。

@table @gcctabopt

@item -fsanitize=shift
@opindex fsanitize=shift
このオプションはシフト演算の結果が未定義でないかをチェックすることを有効にする。
どれが正確に未定義であるかは、CとC++で、またISO C90とC99の間で微妙に異なっていることに注意。
This option has two suboptions, @option{-fsanitize=shift-base} and
@option{-fsanitize=shift-exponent}.

@item -fsanitize=shift-exponent
@opindex fsanitize=shift-exponent
このオプションは、シフト操作の第2引数が負ではなく、昇格した第1引数の精度よりも小さいことをチェックする。

@item -fsanitize=shift-base
@opindex fsanitize=shift-base
シフト演算の2番目の引数が範囲内にある場合は、シフト演算の結果が未定義でないことを確認する。 正確には未定義とみなされるものは、CとC ++の間、およびISO C90とC99の間など、わずかに異る。

@item -fsanitize=integer-divide-by-zero
@opindex fsanitize=integer-divide-by-zero
ゼロ除算と@code{INT_MIN / -1}除算を検知する。

@item -fsanitize=unreachable
@opindex fsanitize=unreachable
このオプションで、コンパイラは@code{__builtin_unreachable}を代わりに診断メッセージ呼び出しに変換する。
@code{__builtin_unreachable}呼び出しに到達するとき、振る舞いは未定義である。

@item -fsanitize=vla-bound
@opindex fsanitize=vla-bound
このオプションはコンパイラに可変長配列の長さが正であるかどうかをチェックするように指示する。

@item -fsanitize=null
@opindex fsanitize=null
このオプションはポインタチェックを有効にする。特に、このオプションでビルドしたアプリケーションは
NULLポインタを被参照しようとしたとき、もし参照が（多分右辺値参照）がNULLポインタと結合したならば、
もしメソッドがNULLポインタで指示されたオブジェクトで実行されたならば、エラーメッセージを発する。

@item -fsanitize=return
@opindex fsanitize=return
このオプションはreturn文チェックを有効にする。このオプションによってビルドされたプログラムは
非void関数の終わりが実際に値を返すことなく到達したならばエラーメッセージを発する。
このオプションはC++のでのみ働く。

@item -fsanitize=signed-integer-overflow
@opindex fsanitize=signed-integer-overflow
このオプションは符号付き整数桁あふれチェックを有効にする。@code{+}, @code{*}と単項と2項の@code{-}で
符号付き算術が桁あふれしないかをチェックする。注意として、整数格上げ規則が考慮に入れられなければならない。
すなわち、以下は桁あふれではない。
@smallexample
signed char a = SCHAR_MAX;
a++;
@end smallexample

@item -fsanitize=bounds
@opindex fsanitize=bounds
このオプションは配列境界の計装を有効にする。様々な境界外アクセスが検知される。可変長配列メンバ、
可変長配列メンバ様配列、静的領域の変数の初期化は計装されない。
このオプションは@option{-fcheck-pointer-bounds}と組み合わせることはできない。

@item -fsanitize=bounds-strict
@opindex fsanitize=bounds-strict
このオプションは厳密な配列境界の計装を有効にする。ほとんどの境界外アクセスは、可変長配列メンバと可変長配列メンバ様配列も含めて
計装される。静的領域の変数の初期化は計装されない。
このオプションは@option{-fcheck-pointer-bounds}と組み合わせることはできない。

@item -fsanitize=alignment
@opindex fsanitize=alignment
このオプションは被参照されるか、参照が不十分にアラインメントされた目標に結合しているか、
メソッドおよびコンストラクタが不十分にアラインメントされたオブジェクトに対して呼ばれているならば、ポインタのアラインメントをチェックする。

@item -fsanitize=object-size
@opindex fsanitize=object-size
このオプションは@code{__builtin_object_size}関数を使ったメモリ参照の計装を有効にする。様々な境界外ポインタアクセスが検知される。

@item -fsanitize=float-divide-by-zero
@opindex fsanitize=float-divide-by-zero

浮動小数点ゼロ除算を検知する。他の同様のオプションとは異なり、@option{-fsanitize=float-divide-by-zero}は
@option{-fsanitize=undefined}によっては有効にならない。なぜなら浮動小数点ゼロ除算は
無限大や非数を得る正当な方法だからである。

@item -fsanitize=float-cast-overflow
@opindex fsanitize=float-cast-overflow

このオプションは符号小数点数から整数型への変換のチェックを有効にする。我々は変換の結果が桁あふれしないかを検査する。
他の同様のオプションとは異なり、@option{-fsanitize=float-cast-overflow}は@option{-fsanitize=undefined}では有効にならない。
このオプションは@code{FE_INVALID}例外が有効のときはよく働かない。

@item -fsanitize=nonnull-attribute
@opindex fsanitize=nonnull-attribute

このオプションは@code{nonnull}関数属性によって非ヌル値を要求するとマークされている引数へnull値を渡していないかどうかを検査する、
呼び出しの計装を有効にする。

@item -fsanitize=returns-nonnull-attribute
@opindex fsanitize=returns-nonnull-attribute

このオプションは@code{returns_nonnull}関数属性でマークされている関数でのreturn文の計装を有効にし、そのような関数からの
null値の返却を検知する。

@item -fsanitize=bool
@opindex fsanitize=bool

このオプションはboolからのロードの計装を有効にする。もし0/1以外の値がロードされたなら、
ランタイムエラーが発せられる。

@item -fsanitize=enum
@opindex fsanitize=enum

このオプションは列挙型からのロードの計装を有効にする。もし列挙型の範囲外の値がロードされたなら、
ランタイムエラーが発せられる。

@item -fsanitize=vptr
@opindex fsanitize=vptr

このオプションはC++メンバ関数呼び出し、メンバアクセス、基底へのポインタとその導出クラス間のある変換の計装を有効にし、
参照されたオブジェクトが正しい動的型を持つかを検証する。

@item -fsanitize=pointer-overflow
@opindex fsanitize=pointer-overflow

This option enables instrumentation of pointer arithmetics.  If the pointer
arithmetics overflows, a run-time error is issued.

@item -fsanitize=builtin
@opindex fsanitize=builtin

This option enables instrumentation of arguments to selected builtin
functions.  If an invalid value is passed to such arguments, a run-time
error is issued.  E.g.@ passing 0 as the argument to @code{__builtin_ctz}
or @code{__builtin_clz} invokes undefined behavior and is diagnosed
by this option.

@end table

@option{-ftrapv}が符号付き桁あふれでトラップを起こす一方、{-fsanitize=undefined}は診断メッセージを与える。
これは現在C言語族にしか働かない。

@item -fno-sanitize=all
@opindex fno-sanitize=all

このオプションはすべての前で有効にしたサニタイザを無効にする。あるサニタイザは一緒に使うことができないので、
@option{-fsanitize=all}は許可されていない。

@item -fasan-shadow-offset=@var{number}
@opindex fasan-shadow-offset
このオプションはGCCにAddressSanitizerチェックでのカスタム・シャドウ・オフセットを使うことを強制する。
これはカーネルAddressSanitizerでの異なったシャドウメモリレイアウトで実験しているときに役立つ。

@item -fsanitize-sections=@var{s1},@var{s2},...
@opindex fsanitize-sections
選択されたユーザ定義セクションでのグローバル変数を浄化する。@var{si}はワイルドカードを含んでも良い。

@item -fsanitize-recover@r{[}=@var{opts}@r{]}
@opindex fsanitize-recover
@opindex fno-sanitize-recover
@option{-fsanitize-recover=}は@var{opts}のコンマで区切られたリストで指摘されたサニタイザのエラー回復モードを制御する。
このオプションを有効にすることでサニタイザコンポネートがエラーが起こっていないかのようにプログラムを走り続けようとさせる。
これは単一のプログラム実行で複数のランタイムエラーが報告されうることを意味し、
プログラムの終了コードはエラーが報告されたにもかかわらず成功を示すかもしれない。
@option{-fno-sanitize-recover=}オプションはこの振る舞いを変えるために使うことができる。
最初に検知されたエラーが報告されプログラムは非ゼロの終了コードで終了する。

現在この機能は@option{-fsanitize=undefined} (と@option{-fsanitize=unreachable}と@option{-fsanitize=return}を除いたそのサブオプション)、
@option{-fsanitize=float-cast-overflow}、@option{-fsanitize=float-divide-by-zero}、@option{-fsanitize=bounds-strict}、
@option{-fsanitize=kernel-address} 、@option{-fsanitize=address}でのみ働く。
これらのサニタイザではエラー回復はデフォルトでオンであり、例外は@option{-fsanitize=address}であり、この機能は実験的である。
@option{-fsanitize-recover=all}と@option{-fno-sanitize-recover=all}も受理され、前者はそれをサポートするすべてのサニタイザ
の回復を有効にし、後者はそれをサポートするすべてのサニタイザで回復を無効にする。

コンパイラー側でリカバリー・モードをオンにしても、ランタイム・ライブラリー側でもリカバリー・モードを使用可能にする必要がある。そうしないと、障害は依然として致命的である。
実行時ライブラリのデフォルトはThreadSanitizerとUndefinedBehaviorSanitizerでは@code{halt_on_error = 0}であるが、AddressSanitizerのデフォルト値は@code{halt_on_error = 1}である。 これは、対応する環境変数の@code{halt_on_error}フラグをセットすることでオーバーライドできる。

明示的な@var{opts}パラメータなしの構文は廃止予定である。それは以下のOPTSを指定したのと
等価である。

@smallexample
undefined,float-cast-overflow,float-divide-by-zero,bounds-strict
@end smallexample

@item -fsanitize-address-use-after-scope
@opindex fsanitize-address-use-after-scope
スコープ使用後のバグを検出するためのローカル変数サニタイズを有効にする。このオプションは@option{-fstack-reuse}を@samp{none}に設定します。

@item -fsanitize-undefined-trap-on-error
@opindex fsanitize-undefined-trap-on-error
@option{-fsanitize-undefined-trap-on-error}オプションはコンパイラに未定義の振る舞いを
@code{libubsan}ライブラリルーチンではなく@code{__builtin_trap}使うように指示する。
この利点は@code{libubsan}が不要でリンクされず、自律環境でも利用可能なことである。

@item -fsanitize-coverage=trace-pc
@opindex fsanitize-coverage=trace-pc
カバレッジに指示されたファジングコード計装を有効にする。すべての基本ブロックに
@code{__sanitizer_cov_trace_pc}への呼び出しを挿入する。

@item -fsanitize-coverage=trace-cmp
@opindex fsanitize-coverage=trace-cmp
Enable dataflow guided fuzzing code instrumentation.
Inserts a call to @code{__sanitizer_cov_trace_cmp1},
@code{__sanitizer_cov_trace_cmp2}, @code{__sanitizer_cov_trace_cmp4} or
@code{__sanitizer_cov_trace_cmp8} for integral comparison with both operands
variable or @code{__sanitizer_cov_trace_const_cmp1},
@code{__sanitizer_cov_trace_const_cmp2},
@code{__sanitizer_cov_trace_const_cmp4} or
@code{__sanitizer_cov_trace_const_cmp8} for integral comparison with one
operand constant, @code{__sanitizer_cov_trace_cmpf} or
@code{__sanitizer_cov_trace_cmpd} for float or double comparisons and
@code{__sanitizer_cov_trace_switch} for switch statements.

@item -fbounds-check
@opindex fbounds-check
サポートするフロントエンドでは、配列にアクセスするための添字が宣言された範囲内であるかをチェックする追加のコードを挿入する。
これは現在JavaとFOrtranフロントエンドによってのみサポートされていて、このオプションはそれぞれデフォルトでtrueとfalseである。

@item -fcheck-pointer-bounds
@opindex fcheck-pointer-bounds
@opindex fno-check-pointer-bounds
@cindex Pointer Bounds Checker options
ポインタ範囲チェック計装を有効にする。そのポインタと関連した境界に対してメモリ・アクセスのために使われるポインタのチェックで、
各々のメモリ参照は計装される。

現在Intel MPXが利用可能な唯一の実装であり、したがって、この機能を有効にするためにはx86 GNU/Linuxターゲットと@option{-mmpx}が必要である。
MPXに基づいた計装はハードウェアでのMPXを有効にして範囲違反シグナルを扱うためにランタイムライブラリを必要とする。
デフォルトでは@option{-fcheck-pointer-bounds}と@option{-mmpx}オプションがプログラムをリンクするために使われたとき、
GCCドライバは@file{libmpx}と@file{libmpxwrappers}ライブラリに対してリンクされる。
動的ライブラリへの呼び出しでの境界チェックは@option{-z bndplt}サポートのあるリンカが必要である。
もしGCCがこのオプションのサポートなしのリンカ（Goldリンカと古いバージョンのldを含む）で設定されたときには、
もし@option{-mmpx}ありで@option{-static}も指定せずにリンクするときには警告が与えられる。なぜなら、なぜなら境界チェック防御の全体の効果が
減らされるためである。@option{-static-libmpxwrappers}も見よ。

MPXに基づいた計装はデバッグにも使うことができ、製品コードでプログラムセキュリティを上げるために含めることもできる。
使用法に応じて、ランタイムライブラリに異なった要求があるかもしれない。MPXランタイムライブラリの現在のバージョンは
デバッグツールとしての使用に重きをおいている。MPXランタイムライブラリの使用は@option{-lpthread}を含む。
@option{-static-libmpx}も見よ。ランタイムライブラリの振る舞いは様々な@env{CHKP_RT_*}環境変数を使って影響させることができる。
さらなる詳細は@uref{https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler}を見よ。

生成された計装は様々な@option{-fchkp-*}オプションと@code{bnd_variable_size}構造体フィールド属性(@pxref{Type Attributes})と
@code{bnd_legacy}、@code{bnd_instrument}関数属性(@pxref{Function Attributes})によって制御されることができる。
GCCはポインタ境界チェッカを制御するいくつかの組み込み関数も提供する。さらなる情報は @xref{Pointer
Bounds Checker builtins}を見よ。

@item -fchkp-check-incomplete-type
@opindex fchkp-check-incomplete-type
@opindex fno-chkp-check-incomplete-type
不完全型の変数のポインタ境界チェックを生成する。デフォルトで有効である。

@item -fchkp-narrow-bounds
@opindex fchkp-narrow-bounds
@opindex fno-chkp-narrow-bounds
オブジェクトフィールドのポインタ用のポインタ境界チェックによって使われる境界を制御する。もし挟化が有効ならば
フィールド境界が使われる。さもなければオブジェクト境界が使われる。@option{-fchkp-narrow-to-innermost-array}、
@option{-fchkp-first-field-has-own-bounds}も見よ。デフォルトで有効である。

@item -fchkp-first-field-has-own-bounds
@opindex fchkp-first-field-has-own-bounds
@opindex fno-chkp-first-field-has-own-bounds
ポインタ境界チェッカに構造体内の最初のフィールドのアドレス用の挟化範囲を使わせる。
デフォルトでは最初のフィールドへのポインタは構造体全体へのポインタと同じ境界を持つ。

@item -fchkp-flexible-struct-trailing-arrays
@opindex fchkp-flexible-struct-trailing-arrays
@opindex fno-chkp-flexible-struct-trailing-arrays
ポインタ境界チェッカーに、構造内のすべての末尾の配列を可変長として扱うように強制する。 デフォルトでは、長さがゼロの配列フィールドまたは属性bnd_variable_sizeでマークされた配列フィールドのみが可変長として扱われる。

@item -fchkp-narrow-to-innermost-array
@opindex fchkp-narrow-to-innermost-array
@opindex fno-chkp-narrow-to-innermost-array
ポインタ境界チェッカに入れ子の静的配列のアクセスの場合に最も内側の配列の境界を使わせる。
デフォルトではこのオプションは向こうで最も外側の配列の境界が使われる。

@item -fchkp-optimize
@opindex fchkp-optimize
@opindex fno-chkp-optimize
ポインタ境界チェッカ最適化を有効にする。最適化レベル@option{-O}, @option{-O2}, @option{-O3}で
デフォルトで有効である。

@item -fchkp-use-fast-string-functions
@opindex fchkp-use-fast-string-functions
@opindex fno-chkp-use-fast-string-functions
ポインタ境界チェッカによる（非コピー境界の）文字列関数の@code{*_nobnd}バージョンの使用を有効にする。
デフォルトで無効である。

@item -fchkp-use-nochk-string-functions
@opindex fchkp-use-nochk-string-functions
@opindex fno-chkp-use-nochk-string-functions
ポインタ境界チェッカによる（非チェック境界の）文字列関数の@code{*_nochk}バージョンの使用を有効にする。
デフォルトで無効である。

@item -fchkp-use-static-bounds
@opindex fchkp-use-static-bounds
@opindex fno-chkp-use-static-bounds
ポインタ境界チェッカが静的変数の境界を保持する静的境界を生成することを許可する。
デフォルトで有効である。

@item -fchkp-use-static-const-bounds
@opindex fchkp-use-static-const-bounds
@opindex fno-chkp-use-static-const-bounds
必要なときに毎回生成する代わりに固定範囲用の静的に初期化された境界を使う。
@option{-fchkp-use-static-bounds}が有効なときにデフォルトで有効である。

@item -fchkp-treat-zero-dynamic-size-as-infinite
@opindex fchkp-treat-zero-dynamic-size-as-infinite
@opindex fno-chkp-treat-zero-dynamic-size-as-infinite
このオプションで、ポインタ境界チェッカによる代わりにその動的に取得されたサイズが0である不完全型の
オブジェクトを無限サイズを持つとして扱う。このオプションはもしプログラムがあるシンボルののサイズ情報が
失われているライブラリとリンクするときに役立つかもしれない。デフォルトで無効にされている。

@item -fchkp-check-read
@opindex fchkp-check-read
@opindex fno-chkp-check-read
ポインタ境界チェッカにすべてのメモリへの読み出しアクセスへのチェックを生成するように指示する。
デフォルトで有効である。

@item -fchkp-check-write
@opindex fchkp-check-write
@opindex fno-chkp-check-write
ポインタ境界チェッカにメモリへのすべての書き出しへのチェックを生成するように指示する。
デフォルトで有効である。

@item -fchkp-store-bounds
@opindex fchkp-store-bounds
@opindex fno-chkp-store-bounds
ポインタ境界チェッカにポインタ書き出し用の境界ストアを生成するように指示する。デフォルトで有効である。

@item -fchkp-instrument-calls
@opindex fchkp-instrument-calls
@opindex fno-chkp-instrument-calls
ポインタ境界チェッカに呼び出しへのポインタ境界を渡すように指示する。デフォルトで有効である。

@item -fchkp-instrument-marked-only
@opindex fchkp-instrument-marked-only
@opindex fno-chkp-instrument-marked-only
ポインタ境界チェッカに@code{bnd_instrument}属性(@pxref{Function Attributes})でマークされた関数のみ計装するように指示する。
デフォルトで無効である。

@item -fchkp-use-wrappers
@opindex fchkp-use-wrappers
@opindex fno-chkp-use-wrappers
ポインタ境界チェッカに組み込み関数への呼び出しをラッパ関数への呼び出しへ置換することを許可する。
@option{-fchkp-use-wrappers}がプログラムをリンクするときに使われたときは、GCCがドライバは自動的に
@file{libmpxwrappers}をリンクする。@option{-static-libmpxwrappers}も見よ。
デフォルトで有効である。

@item -fcf-protection=@r{[}full@r{|}branch@r{|}return@r{|}none@r{]}
@opindex fcf-protection
Enable code instrumentation of control-flow transfers to increase
program security by checking that target addresses of control-flow
transfer instructions (such as indirect function call, function return,
indirect jump) are valid.  This prevents diverting the flow of control
to an unexpected target.  This is intended to protect against such
threats as Return-oriented Programming (ROP), and similarly
call/jmp-oriented programming (COP/JOP).

The value @code{branch} tells the compiler to implement checking of
validity of control-flow transfer at the point of indirect branch
instructions, i.e. call/jmp instructions.  The value @code{return}
implements checking of validity at the point of returning from a
function.  The value @code{full} is an alias for specifying both
@code{branch} and @code{return}. The value @code{none} turns off
instrumentation.

The macro @code{__CET__} is defined when @option{-fcf-protection} is
used.  The first bit of @code{__CET__} is set to 1 for the value
@code{branch} and the second bit of @code{__CET__} is set to 1 for
the @code{return}.

You can also use the @code{nocf_check} attribute to identify
which functions and calls should be skipped from instrumentation
(@pxref{Function Attributes}).

Currently the x86 GNU/Linux target provides an implementation based
on Intel Control-flow Enforcement Technology (CET).

@item -fstack-protector
@opindex fstack-protector
スタック破壊攻撃のようなバッファ溢れのチェックをする追加のコードを生成する。
これは攻撃されやすいオブジェクトのあらう関数にガード変数を加えることで行われる。
これは@code{alloca}を呼ぶ関数、8バイトより大きなバッファを持つ関数が含まれる。
ガードは関数が入ったときに初期化され、関数が抜けるときにチェックされる。
もしガードチェックが失敗したらなば、エラーメッセージが出力されてプログラムが終了する。

@item -fstack-protector-all
@opindex fstack-protector-all
すべての関数が保護されることを除いて@option{-fstack-protector}と同様である。

@item -fstack-protector-strong
@opindex fstack-protector-strong
@option{-fstack-protector}と同様だが追加の関数が保護される。局所配列定義を持つ関数、
およびローカルフレームアドレスへの参照を持つ関数。

@item -fstack-protector-explicit
@opindex fstack-protector-explicit
@option{-fstack-protector}と同様だが@code{stack_protect}属性を持つ関数のみを保護する。

@item -fstack-check
@opindex fstack-check
スタックの境界を超えないように検証するコードを生成する。このフラグをマルチスレッドで走る環境ならば指定すべきだが、
もしひとつしかスタックがないならばほとんどすべてのシステムで自動的にスタック溢れは検知されるので
単一スレッド環境ではめったに指定する必要はない。

このスイッチがチェックが実は、されることを矯正しないことに注意すべきである。オペレーティングシステムまたは言語ランタイムがそうしなければならない。スイッチは、コードの生成がそれらが拡張されているスタックを見ることを確実とするようにさせる。

文字列パラメータをさらに指定することができる：
@samp{no}はチェックしないことを意味し、@samp{generic}手段は旧式なチェックの使用を強制し、
@samp{specific}は最高のチェック方法を意味し、裸の@option{-fstack-check}に等しい。

旧式なチェックは、コンパイラでの特定のターゲットのサポートを要求しない一般的なメカニズムであるが、以下の欠点がある。

@enumerate
@item
大きなオブジェクトへの修正された割り当て戦略。それらはもし固定しきい値をサイズが超えるならば常に動的に割り当てられる。これはコードの意味を変えるかもしれないことに注意。

@item
関数の静的フレームのサイズの固定値制限。それが特定の関数によって上回られるとき、スタック・チェックは信頼できず、
警告はコンパイラによって発される。

@item
非効率性。修正された割り当て戦略と汎用の実装のために、コードパフォーマンスは妨げられる。
@end enumerate

旧式スタックチェックはもしコンパイラでターゲットサポートが加えられないならば、@samp{specific}の代替方法でもあることに注意。

@samp{-fstack-check=} is designed for Ada's needs to detect infinite recursion
and stack overflows.  @samp{specific} is an excellent choice when compiling
Ada code.  It is not generally sufficient to protect against stack-clash
attacks.  To protect against those you want @samp{-fstack-clash-protection}.

@item -fstack-clash-protection
@opindex fstack-clash-protection
Generate code to prevent stack clash style attacks.  When this option is
enabled, the compiler will only allocate one page of stack space at a time
and each page is accessed immediately after allocation.  Thus, it prevents
allocations from jumping over any stack guard page provided by the
operating system.

Most targets do not fully support stack clash protection.  However, on
those targets @option{-fstack-clash-protection} will protect dynamic stack
allocations.  @option{-fstack-clash-protection} may also provide limited
protection for static stack allocations if the target supports
@option{-fstack-check=specific}.

@item -fstack-limit-register=@var{reg}
@itemx -fstack-limit-symbol=@var{sym}
@itemx -fno-stack-limit
@opindex fstack-limit-register
@opindex fstack-limit-symbol
@opindex fno-stack-limit
スタックが特定の値、レジスタの値かシンボルのアドレスを超えないことを確かめるコードを生成する。
もしより大きなスタックが必要ならば、実行時シグナルが発せられる。大抵のターゲットで、
シグナルはスタックが境界を超える前に発せられるので、特別な予防策なしでシグナルを捕捉することは可能である。

例えば、もしスタックが絶対アドレス@samp{0x80000000}で始まり下方に成長するならば、
フラグ@option{-fstack-limit-symbol=__stack_limit}と@option{-Wl,--defsym,__stack_limit=0x7ffe0000}を
スタック制限を128KBに強制するために使うことができる。
これはGNUリンカでのみ働くかもしれないことに注意。

@code{no_stack_limit}関数属性(@pxref{Function Attributes})を使ってスタック制限チェックを局所的に上書きすることができる。

@item -fsplit-stack
@opindex fsplit-stack
スタックを溢れる前に自動的に分割するコードを生成する。結果のプログラムはプログラムがこれ以上メモリを割り当てられない
場合に限り溢れる非連続のスタックになる。これはスレッド化されたプログラムで一番有用である。なぜならもはやそれぞれで適切なスタックサイズを
計算する必要がないためである。これは現在GNU/Linuxで走るx86ターゲットでのみ実装されている。

@option{-fsplit-stack}でコンパイルされたコードが@option{-fsplit-stack}なしでコンパイルされたコードを呼ぶとき、
後者が走る利用可能なスタック空間があまりないかもしれない。もしライブラリコードを含めて、
@option{-fsplit-stack}ですべてのコードをコンパイルすることがオプションでないならば、
リンカはそれらの呼び出しを@option{-fsplit-stack}が常に大きなスタックを持つように修正できる。
これのサポートはGNU binutilsリリース2.21以降のgoldリンカで実装されている。

@item -fvtable-verify=@r{[}std@r{|}preinit@r{|}none@r{]}
@opindex fvtable-verify
このオプションはC++コードをコンパイルするときだけ利用可能である。それは仮想呼び出しごとに、
呼び出しがなされるvtableポインタがオブジェクトの型が正当であり、
破壊されていないか上書きされていないことを、実行時で確かめるセキュリティ機能をオンにする
（もしくは、@option{-fvtable-verify=none}を使ってオフにする）。
もし実行時に不正なvtableポインタを検知したらならば、エラーが報告され、プログラムの実行が直ちに停止される。

このオプションはプログラム開始時に実行時データ構造が構築されるようにし、それはvtableポインタを検証するために使われる。
オプション@samp{std}と@samp{preinit}はいつそれらのデータ構造が構築されるかのタイミングを制御する。両方の場合で
データ構造は実行が@code{main}に達する前に構築される。@option{-fvtable-verify=std}を使うと
データ構造は共有ライブラリがロードされて初期化された後に構築される。
@option{-fvtable-verify=preinit}はそれらが共有ライブラリがロードされて初期化される前に構築されるようにする。

もしこのオプションがコマンドラインで複数回現れ、異なる値が指定されるならば、@samp{none}が、@samp{std}と@samp{preinit}よりも優先される。
@samp{preinit}が@samp{std}よりも優先される。

@item -fvtv-debug
@opindex fvtv-debug
@option{-fvtable-verify=std}および@option{-fvtable-verify=preinit}とともに使われるとき、それはvtable確認機能のための
ランタイム関数のデバッグ・バージョンを呼ばれるようにする。このフラグはまた、コンパイラをそれがクラスごとにどのvtableポインタを
見つけるかという情報を記録するようにもする。
この情報はもし定義されていたら環境変数@env{VTV_LOGS_DIR}の名前のディレクトリ、さもなければ現在の作業ディレクトリの
@file{vtv_set_ptr_data.log}という名前のファイルに書かれる。

注意：この機能はログファイルにデータを@emph{加える}。もし新鮮なログファイルがほしいならば、既存のファイルを確実に削除すべきである。

@item -fvtv-counts
@opindex fvtv-counts
これはデバッグフラグである。@option{-fvtable-verify=std}および@option{-fvtable-verify=preinit}とともに使われるとき、
これは、コンパイラをそれが遭遇する仮想呼び出しの総数とそれが挿入する確認の数の経過を追うようにする。
それは、挿入する特定のランタイムライブラリ関数に呼び出しの数を数えて、各々のコンパイル単位でこの情報も記録する。
この情報はもし定義されていたら環境変数@env{VTV_LOGS_DIR}の名前のディレクトリ、さもなければ現在の作業ディレクトリの
@file{vtv_count_data.log}という名前のファイルに書かれる。それはさらにクラスごとにvtableポインタ・セットの寸法を数えて、
同じディレクトリに@file{vtv_class_set_sizes.log}にこの情報を書く。

注意：この機能はログファイルにデータを@emph{加える}。もし新鮮なログファイルがほしいならば、既存のファイルを確実に削除すべきである。

@item -finstrument-functions
@opindex finstrument-functions
関数の入り口と出口に計装呼び出しを生成する。関数呼び出しの直前と直後に、以下のプロファイル関数が
現在の関数のアドレスと呼び出し場所をともなって呼ばれる。（あるプラットフォームでは、
@code{__builtin_return_address}が現在の関数を超えて働かないので、それ以外では呼び出し場所情報はプロファイル関数に対しては
利用可能でないかもしれない）

@smallexample
void __cyg_profile_func_enter (void *this_fn,
                               void *call_site);
void __cyg_profile_func_exit  (void *this_fn,
                               void *call_site);
@end smallexample

最初の引数は現在の関数の先頭のアドレスで、シンボルテーブルで正確に見つけることができる。

この計装は、他の関数でインライン展開された関数にもされる。インライン関数が、概念的に、どこで入れられて、出たかについて、
プロファイリング呼び出しは示す。これは、そのような関数のアドレス指定可能なバージョンは利用できなければならないことを意味する。
関数のあなたのすべての活用法が展開されたインラインであるならば、これはコード・サイズの更なる膨張を意味するかもしれない。
あなたがあなたのCコードで@code{extern inline}を使うならば、そのような関数のアドレス指定可能なバージョンは提供されなければならない。
（これはいずれにしろ通常本当であるが、あなたが幸運で、最適化器が常に関数をインライン展開するならば、
あなたは静的コピーを提供することなく来るかもしれない。）

関数は属性@code{no_instrument_function}を与えることができ、その場合にはこの計装は行われない。
これは、多々追えば、上に並べたプロファイル関数、高優先度割り込みルーチン、プロファイル関数を安全に呼ぶことができない関数
（多分、もしプロファイルルーチンが出力やメモリ割り当てを行うならば、シグナルハンドラ）に対して使うことができる。

@item -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{}
@opindex finstrument-functions-exclude-file-list

計装（@option{-finstrument-functions}の説明を見よ）から除外される関数のリストをセットする。
関数定義を含むファイルが@var{file}の1つと合うならば、その関数は計装されない。
マッチは、部分文字列の上でされる：@var{file}パラメータがファイル名の部分文字列であるならば、それはマッチであると考えられる。

例えば：

@smallexample
-finstrument-functions-exclude-file-list=/bits/stl,include/sys
@end smallexample

@noindent
はそのパス名が@file{/bits/stl}および@file{include/sys}であるファイルに定義されたインライン関数を除外する。

もし、ある理由で、文字@samp{,}を@var{sym}の一つに含めたいならば、@samp{\,}と書く。例えば、
@option{-finstrument-functions-exclude-file-list='\,\,tmp'}（オプションを囲む単一引用符に注意）

@item -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{}
@opindex finstrument-functions-exclude-function-list

これは@option{-finstrument-functions-exclude-file-list}と類似しているが、
このオプションは計装から除外される関数名のリストをセットする。
マッチされる関数名は、そのユーザー見える名前（例えば@code{vector<int> blah(const vector<int> &)}）であって、
内部のマングルされた名前（例えば、@code{_Z4blahRSt6vectorIiSaIiEE}）でない。
マッチは、部分文字列の上でされる：@var{sym}パラメータが関数名の部分文字列であるならば、それはマッチであると考えられる。
C99とC++拡張された識別子では、関数名はUTF-8で与えられていなければならない。そして、一般的な文字名を使用しない。

@end table


@node Preprocessor Options
@section プリプロセッサを制御するオプション
@cindex preprocessor options
@cindex options, preprocessor

これらのオプションはCプリプロセッサを制御する。そして、それは実際のコンパイルの前に各々のCソース・ファイルで動く。

あなたが@option{-E}オプションを使用するならば、何もプリプロセス以外はされない。
プリプロセッサ出力を実際のコンパイルに不適当であるようにするので、これらのオプションのいくらかは@option{-E}と共にだけ意味をなす。

ここに挙げたオプションに加えて、@ref{Directory Options}に記述されているインクルードファイルの検索パスを制御するオプションがいくつかあります。プリプロセッサ診断を制御するオプションは、@ref{Warning Options}にリストされている。.

@table @gcctabopt
@include cppopts.texi

@item -Wp,@var{option}
@opindex Wp
コンパイラ・ドライバを回避して、プリプロセッサに直接オプションを渡すために、
@option{-Wp,@var{option}}を使うことができる。オプションがコンマを含むならば、
それはコンマで複数のオプションに分けられる。しかし、多くのオプションはプリプロセッサに渡される前に
コンパイラ・ドライバによって修正されるか、翻訳されるか、解釈される、そして、@option{-Wp}はこの段階を強制的に回避する。

@item -Xpreprocessor @var{option}
@opindex Xpreprocessor
@var{option}をオプションとしてプリプロセッサに渡す。これをGCCが認識しないシステム固有のプリプロセッサオプションを提供するために
使うことができる。

もし引数を取るオプションを渡したいならば、@option{-Xpreprocessor}を二度、オプションとその引数で一度ずつ渡さなくてはならない。

@item -no-integrated-cpp
@opindex no-integrated-cpp
コンパイルの前に別のパスとしてプリプロセスを行う。デフォルトでは、GCCは入力トークン化とパースの組み込まれた一部として
プリプロセスを行う。もしこのオプションが提供されたなら、適切な言語フロントエンド
(C、C++、Objective-Cにそれぞれ対応して@command{cc1}, @command{cc1plus}, @command{cc1obj})が代わりに二度呼ばれ、
一度はプリプロセスだけのために、もう一度はプリプロセスされた入力の実際のコンパイルのために呼ばれる。
このオプションは@option{-B}か@option{-wrapper}オプションと組み合わせて、代替のプリプロセッサを指定するか、
通常のプリプロセスとコンパイルの間に追加の処理を行うときに役立つ。

@item -fpatchable-function-entry=@var{N}[,@var{M}]
@opindex fpatchable-function-entry
Generate @var{N} NOPs right at the beginning
of each function, with the function entry point before the @var{M}th NOP.
If @var{M} is omitted, it defaults to @code{0} so the
function entry points to the address just at the first NOP.
The NOP instructions reserve extra space which can be used to patch in
any desired instrumentation at run time, provided that the code segment
is writable.  The amount of space is controllable indirectly via
the number of NOPs; the NOP instruction used corresponds to the instruction
emitted by the internal GCC back-end interface @code{gen_nop}.  This behavior
is target-specific and may also depend on the architecture variant and/or
other compilation options.

For run-time identification, the starting addresses of these areas,
which correspond to their respective function entries minus @var{M},
are additionally collected in the @code{__patchable_function_entries}
section of the resulting binary.

Note that the value of @code{__attribute__ ((patchable_function_entry
(N,M)))} takes precedence over command-line option
@option{-fpatchable-function-entry=N,M}.  This can be used to increase
the area size or to remove it completely on a single function.
If @code{N=0}, no pad location is recorded.

The NOP instructions are inserted at---and maybe before, depending on
@var{M}---the function entry address, even before the prologue.

@end table

@node Assembler Options
@section アセンブラに渡すオプション

@c prevent bad page break with this line
アセンブラにオプションを渡すことができる。

@table @gcctabopt
@item -Wa,@var{option}
@opindex Wa
アセンブラへのオプションとして@var{option}を渡す。もし@var{option}がコンマを含むなら、コンマで複数のオプションに分割する。

@item -Xassembler @var{option}
@opindex Xassembler
アセンブラにオプションとして@var{option}を渡す。これをGCCにが理解しないシステム固有のアセンブラオプションを提供するために使うことができる。

もし引数を取るオプションを渡したいときは、@option{-Xassembler}を二度使わなければならない。オプションで一度と、引数で一度。

@end table

@node Link Options
@section リンクのオプション
@cindex link options
@cindex options, linking

これらのオプションはコンパイラがオブジェクトファイルを実行可能出力ファイルへとリンクするときに役割を演じるものである。
それらはもしコンパイラがリンク段階まで行かないならば役に立たない。

@table @gcctabopt
@cindex file names
@item @var{object-file-name}
特別に認識される接尾辞で終わらないファイル名はオブジェクトかライブラリの名前とみなされる。（オブジェクトファイルは
リンカによってファイルの中身からライブラリと区別される）。もしリンクが行われたならば、それらのオブジェクトファイルはリンカへの入力
として使われる。

@item -c
@itemx -S
@itemx -E
@opindex c
@opindex S
@opindex E
もしこれらのオプションが使われるなら、りんかははしらないので、オブジェクトファイル名は引数として使われるべきではない。
@xref{Overall Options}.

@item -fuse-ld=bfd
@opindex fuse-ld=bfd
デフォルトリンカの代わりに@command{bfd}を使う。

@item -fuse-ld=gold
@opindex fuse-ld=gold
デフォルトリンカの代わりに@command{gold}を使う。

@cindex Libraries
@item -l@var{library}
@itemx -l @var{library}
@opindex l
リンク時に@var{library}という名前のライブラリを探す。（別の引数としてライブラリを渡す
第2の選択肢はPOSIX適合としてのみのためであり、推奨されない。）

コマンドでどこにこのオプションを書くかは違いを生む。リンカは指定された順にライブラリとオブジェクトファイル
を検索して処理する。したがって、@samp{foo.o -lz bar.o}はライブラリ@samp{z}を@file{foo.o}の後だが@file{bar.o}の前に検索する。
もし@file{bar.o}が@samp{z}の関数を参照していても、それらの関数はロードされないかもしれない。

リンカはライブラリを求めてディレクトリの標準的なリストを検索する。そして、それは実際は@file{lib@var{library}.a}という名前の
ファイルである。まるでそれが正確に名前で指定されたように、リンカはこのファイルをそれから使用する。

検索されるディレクトリは、幾つかの標準システムディレクトリとあなたが@option{-L}で指定したものを含む。

通常、このように見つかるファイルは、ライブラリ・ファイルである ― メンバーがオブジェクト・ファイルであるアーカイブのファイル。
ここまで参照されたが定義されなかったシンボルを定義するメンバーのためにそれをスキャンすることによって、
リンカはアーカイブのファイルを取り扱う。しかし、見つかるファイルが普通のオブジェクト・ファイルであるならば、
それは普通の方法にリンクされる。@option{-l}オプションを使用することとファイル名を指定することの唯一の違いは、
@option{-l}が@samp{lib}と@samp{.a}で@var{library}を囲んで、いくつかのディレクトリを捜すということである。

@item -lobjc
@opindex lobjc
Objective-CやObjective-C++プログラムをリンクするためには@option{-l}オプションのこの特別な場合が必要である。

@item -nostartfiles
@opindex nostartfiles
リンク時に標準システムスタートアップファイルを使わない。@option{-nostdlib}または@option{-nodefaultlibs}
が使われない限り、標準システムライブラリは通常使われる。

@item -nodefaultlibs
@opindex nodefaultlibs
リンク時に標準システムライブラリを使わない。指定されたライブラリだけがリンカに渡され、
@option{-static-libgcc}のようなシステムライブラリのリンケージを指定するオプションは無視される。
@option{-nostartfiles}が使われない限り、標準スタートアップファイルは通常使われる。

コンパイラは@code{memcmp}、@code{memset}、@code{memcpy}、@code{memmove}への呼び出しを生成するかもしれない。
これらのエントリは通常libcのエントリによって解決される。これらのエントリポイントはこのオプションを指定したときは
他のメカニズムを通して提供されるべきである。

@item -nostdlib
@opindex nostdlib
リンク時に標準システムスタートファイルもライブラリも使わない。
スタートアップファイルはなく、指定したライブラリのみがリンカに渡され、
@option{-static-libgcc}および@option{-shared-libgcc}のような、システムライブラリのリンケージを指定するオプションは無視される。

コンパイラは@code{memcmp}、@code{memset}、@code{memcpy}、@code{memmove}への呼び出しを生成するかもしれない。
これらのエントリは通常libcのエントリによって解決される。これらのエントリポイントはこのオプションを指定したときは
他のメカニズムを通して提供されるべきである。

@cindex @option{-lgcc}, use with @option{-nostdlib}
@cindex @option{-nostdlib} and unresolved references
@cindex unresolved references and @option{-nostdlib}
@cindex @option{-lgcc}, use with @option{-nodefaultlibs}
@cindex @option{-nodefaultlibs} and unresolved references
@cindex unresolved references and @option{-nodefaultlibs}
@option{-nostdlib}と[option{-nodefaultlibs}によって迂回される標準ライブラリの一つは@file{libgcc.a}であり、
GCCが特定の機種の欠点を克服するため、および、ある言語での特別に必要になるために使う内部サブルーチンのライブラリである。
(@file{libgcc.a}の詳しい議論は@xref{Interface,,Interfacing to GCC Output,gccint,GNU Compiler Collection (GCC) Internals})
大抵の場合は、他の標準ライブラリを避けたい場合でも@file{libgcc.a}は必要である。言い換えると、
@option{-nostdlib}および@option{-nodefaultlibs}を指定するときには、通常は@option{-lgcc}も同様に指定すべきである。
これは内部GCCライブラリサブルーチンへの未解決のシンボルがないことを保証する。
(そのような内部サブルーチンの例は@code{__main}で、C++のコンストラクタが呼ばれることを保証するために使われる。
 @pxref{Collect2,,@code{collect2}, gccint, GNU Compiler Collection (GCC) Internals}.)

@item -pie
@opindex pie
それをサポートするターゲット上で動的にリンクされた位置独立実行可能ファイルを生成する。 予測可能な結果を得るには、このリンカオプションを指定するときに、コンパイルに使用するのと同じオプションセット（@option{-fpie}、@option{-fPIE}、またはモデルサブオプション）も指定する必要がある。
  
@item -no-pie
@opindex no-pie
動的にリンクされた位置独立実行可能ファイルを生成しない。
 
@item -static-pie
@opindex static-pie
それをサポートするターゲット上で静的位置独立実行可能ファイルを生成する。 静的位置独立実行可能ファイルは静的実行可能ファイルに似ているが、ダイナミックリンカなしで任意のアドレスにロードできる。予測可能な結果を得るには、コンパイルに使用するのと同じオプションセットも指定する必要がある（@option{-fpie}、@option{-fPIE}、またはmodelサブオプション）を指定する。

@item -pthread
@opindex pthread
POSIXスレッドライブラリとのリンク。 このオプションは、GNU/Linuxターゲット、その他のほとんどのUnix派生物、x86 CygwinおよびMinGWターゲットでもサポートされている。 いくつかのターゲットでは、このオプションはプリプロセッサのフラグも設定するので、コンパイルとリンクの両方に一貫して使用する必要がある。

@item -rdynamic
@opindex rdynamic
それをサポートするターゲットで、フラグ@option{-export-dynamic}をELFリンカに渡す。
これはリンカに、動的シンボルテーブルに、使われるものだけでなく、全シンボルを加えるように指示する。
このオプションは@code{dlopen}のある使用法や、プログラム内からバックトレースを得ることを可能にするために必要である。

@item -s
@opindex s
実行ファイルからすべてのシンボルテーブルと再割り当て情報を取り除く。

@item -static
@opindex static
動的リンクをサポートするシステムで、@option{-pie}を上書きして共有ライブラリへのリンクを防ぐ。他のシステムでは、このオプションには効果がない。

@item -shared
@opindex shared
実行ファイルから他のオブジェクトとリンクできる共有オブジェクトを生成する。すべてのシステムがこのオプションをサポートする
わけではない。予測可能な結果のためには、
このリンカオプションを指定するときにはコンパイルで使われたのと同じオプション集合
(@option{-fpie}, @option{-fPIE},およびモデルサブオプション）も指定しなければならない。
@footnote{あるシステムでは、@samp{gcc -shared}はコンストラクタが働くためには余分なスタブコードをビルドする必要がある。
複数ライブラリのシステムでは、@samp{gcc -shared}はそれに対してリンクするための正しいサポートライブラリ選択しなくてはならない。
正しいフラグの提供に失敗すると些細な欠陥を引き起こすかもしれない。それらが必要でない場合、それらを供給することは無害である。}

@item -shared-libgcc
@itemx -static-libgcc
@opindex shared-libgcc
@opindex static-libgcc
共有ライブラリとして@file{libgcc}を提供するシステムで、これらのオプションは
それぞれ共有・静的バージョンの使用を強制する。もしコンパイラが設定されたときに
@file{libgcc}の共有バージョンがなければ、これらのオプションには効果がない。

アプリケーションが静的バージョンの代わりに共有@file{libgcc}を使うべき幾つかの状況がある。
それらの最も一般的なものはアプリケーションが異なる共有ライブラリをまたいで例外を投げて受け取りたいときである。
その倍位には、アプリケーション自身と同様にそれぞれのライブラリでも共有の@file{libgcc}を使うべきである。

したがって、G++とドライバは共有ライブラリおよびメイン実行ファイルをビルドするときはいつでも
自動的に@option{-shared-libgcc}を加える。なぜならC++プログラムは典型的に例外を使い、したがってこれはして正しいことだからである。

かわりに、もし共有ライブラリを作るのにGCCにドライバを使うなら、常に共有@file{libgcc}でリンクされるわけではないことに気づくかもしれない。
もしGCCは設定時に、非GNUリンカかオプション@option{--eh-frame-hdr}をサポートしないGNUリンカを持つとわかるなら、
デフォルトで共有ライブラリに@file{libgcc}の共有バージョンをリンクする。さもなければ、リンカの利点を取って
@file{libgcc}の共有バージョンのリンクを最適化でなくす。これはライブラリロード時の再配置コストを負うことなく、
そのような共有ライブラリを通して例外が伝搬することを可能にする。

しかし、もしライブラリかメイン実行ファイルが例外を投げるか受け取るならば、それが共有@file{libgcc}でリンクされるように、
プログラムで使われる言語に適切であるように、G++ドライバを使ってリンクしなければならないか、オプション@option{-shared-libgcc}を用いて
リンクしなければならない。

@item -static-libasan
@opindex static-libasan
@option{-fsanitize=address}オプションがプログラムをリンクするために使われるときに、
GCCドライバは自動的に@option{libasan}に対してリンクする。もし@file{libasan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libasan}の共有バージョンに対してリンクする。
@option{-static-libasan}オプションはGCCドライバに@file{libasan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-libtsan
@opindex static-libtsan
@option{-fsanitize=thread}オプションがプログラムをリンクするために使われるときに、
GCCドライバは自動的に@option{libtsan}に対してリンクする。もし@file{libtsan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libtsan}の共有バージョンに対してリンクする。
@option{-static-libtsan}オプションはGCCドライバに@file{libtsan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-liblsan
@opindex static-liblsan
@option{-fsanitize=leak}オプションがプログラムをリンクするために使われるときに、
GCCは自動的に@option{liblsan}に対してリンクする。もし@file{liblsan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{liblsan}の共有バージョンに対してリンクする。
@option{-static-liblsan}オプションはGCCドライバに@file{liblsan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-libubsan
@opindex static-libubsan
@option{-fsanitize=undefined}オプションがプログラムをリンクするために使われるときに、
GCCドライバは自動的に@option{libubsan}に対してリンクする。もし@file{libubsan}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libubsan}の共有バージョンに対してリンクする。
@option{-static-libubsan}オプションはGCCドライバに@file{libubsan}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-libmpx
@opindex static-libmpx
@option{-fcheck-pointer bounds}と@option{-mmpx}オプションがプログラムをリンクするために使われるときに、
GCCドライバは自動的に@option{libmpx}に対してリンクする。もし@file{libmpx}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libmpx}の共有バージョンに対してリンクする。
@option{-static-libmpx}オプションはGCCドライバに@file{libmpx}を静的にリンクして、他のライブラリを静的にリンクする必要をなくす。

@item -static-libmpxwrappers
@opindex static-libmpxwrappers
@option{-fcheck-pointer bounds}と@option{-mmpx}オプションがプログラムをリンクするときに
@option{-fno-chkp-use-wrappers}は使わずに使われるときに、GCCドライバは自動的に
@option{libmpxwrappers}に対してリンクする。もし@file{libmpxwrappers}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libmpxwrappers}の共有バージョンに対してリンクする。
@option{-static-libmpxwrappers}オプションはGCCドライバに@file{libmpxwrappers}を静的にリンクして、
他のライブラリを静的にリンクする必要をなくす。

@item -static-libstdc++
@opindex static-libstdc++
@command{g++}プログラムがC++プログラムをリンクするために使われるとき、
通常は@option{libstdc++}に対して自動的にリンクする。
もし@file{libstdc++}が共有ライブラリとして利用可能であり、
@option{-static}が使われていないならば、これは@file{libstdc++}の共有バージョンに対してリンクする。
これは通常はよい。しかし、時々完全に静的リンクをすることなしにプログラムで使われる@file{libstdc++}のバージョンを
固定することが役立つ。@option{-static-libstdc++}オプションは@command{g++}ドライバに@file{libstdc++}を静的にリンクして、
他のライブラリを静的にリンクする必要をなくす。

@item -symbolic
@opindex symbolic
共有オブジェクトに結合するときにグローバルシンボルへの参照を結合させる。
（リンクエディタオプション@option{-Xlinker -z -Xlinker defs}によって上書きされない限り）
未解決の参照について警告する。少しのシステムだけがこのオプションをサポートしている。

@item -T @var{script}
@opindex T
@cindex linker script
リンカスクリプトとして@var{script}を使う。このオプションはGNUリンカを使う大抵のシステムではサポートされている。
オペレーションシステムのないベアボードターゲットのような、あるターゲットでは、@option{-T}オプションは
リンク時に未解決のシンボルへの参照を避けるために要求されるかもしれない。

@item -Xlinker @var{option}
@opindex Xlinker
@var{option}をリンカへのオプションとして渡す。これをGCCのが認識しないシステム固有のリンカオプションを提供するために使うことができる。

もし引数を取るオプションを渡したいときは、@option{-Xlinker}を二度使わなければならない。オプションで一度と、引数で一度。
例えば、@option{-assert definitions}を渡したいときは、@option{-Xlinker -assert -Xlinker definitions}を書かなければならない。
@option{-Xlinker "-assert definitions"}と書くのは働かない。なぜなら、これは全体の文字列を単一の引数として文字列で渡し、
それはリンカが期待するものではないからである。

GNUリンカを使うときは、別れた引数よりは@option{@var{option}=@var{value}}構文を使ってリンカオプションに引数を渡すほうが通常は便利である。
例えば、@option{-Xlinker -Map=output.map}を@option{-Xlinker -Map -Xlinker output.map}ではなく指定する。他のリンカはコマンドラインオプションに
この構文をサポートしていないかもしれない。

@item -Wl,@var{option}
@opindex Wl
@var{option}をリンカに渡すオプションとして渡す。もし、@var{option}がコンマを含むなら、コンマでオプションを分割する。
この構文をオプションへの力数を渡すために使うことができる。例えば、@option{-Wl,-Map,output.map}は
リンカに@option{-Map output.map}を渡す。GNUリンカを使うときは、@option{-Wl,-Map=output.map}でも同じ効果を得ることができる。

@item -u @var{symbol}
@opindex u
シンボルが@var{symbol}が未定義だと装い、それを定義したライブらいモジュールのリンクを強制する。
追加のライブラリモジュールのロードを強制するために異なるシンボルに対して複数回@option{-u}を使うことができる。

@item -z @var{keyword}
@opindex z
@option{-z}はキーワード@var{keyword}を伴ってリンカに直接渡される。許される値とその意味はリンカの文書の節を見よ。
@end table

@node Directory Options
@section ディレクトリ検索のオプション
@cindex directory options
@cindex options, directory search
@cindex search path

これらのオプションはヘッダファイル、ライブラリ、コンパイラの部品の検索ディレクトリを指定する。

@table @gcctabopt
@include cppdiropts.texi

@item -iplugindir=@var{dir}
@opindex iplugindir=
プラグインを検索するディレクトリを@option{-fplugin=@var{path}/@var{name}.so}の代わりに
@option{-fplugin=@var{name}}によって渡されたものにセットする。このオプションはユーザによって使われるものではなく、
ドライバによってのみ渡されることを意図している。

@item -L@var{dir}
@opindex L
@option{-l}のために検索されるディレクトリのリストに@var{dir}ディレクトリを加える。

@item -B@var{prefix}
@opindex B
このオプションは実行ファイル、ライブラリ、インクルードファイル、コンパイラ自身のデータファイルを検索する場所を指定する。

コンパイラドライバプログラムは副プログラム@command{cpp}、@command{cc1}、@command{as}、@command{ld}の1つ以上を走らせる。
それは走らせようとするそれぞれのプログラムの接頭辞として@var{prefix}を、対応するターゲット機種とコンパイラバージョンで
@samp{@var{machine}/@var{version}/}をありとなしの両方で試す。

それぞれの副プログラムを走らせるために、コンパイラドライバは最初に、もしあれば@option{-B}接頭辞を試す。
もし名前が見つからないか、@option{-B}が指定されていなければ、ドライバは2つの標準接頭辞
@file{/usr/lib/gcc/}と@file{/usr/local/lib/gcc/}を試す。もし見つかったファイル名ないのそれらの結果のどちらもなければ、
未修正のプログラム名が@env{PATH}環境変数内で指定されたディレクトリを使って検索される。

コンパイラは@option{-B}で提供されるパスがディレクトリを参照しているかをチェックし、もし必要ならパスの末尾にディレクトリ分離文字を加える。

コンパイラがリンカのためにこれらのオプションから@option{-L}オプションに変換するので、
ディレクトリ名も効果的に指定する@option{-B}接頭辞はリンカでライブラリに適用される。
コンパイラがプリプロセッサのためにこれらのオプションから@option{-isystem}オプションに変換するので、
それらもプリプロセッサのインクルードファイルに適用される。この場合、コンパイラは接頭辞に@samp{include}を追加する。

ランタイムサポートファイル@file{libgcc.a}も、もし必要なら@option{-B}接頭辞を使って検索されうる。もしそこで見つからなければ、
上の2つの標準接頭辞が試され、それですべてである。それがそれらの手段で見つからないならば、ファイルは関連から省かれる。

ほぼ@option{-B}接頭辞のような接頭辞を指定するもう一つの方法は、環境変数@env{GCC_EXEC_PREFIX}を使うことである。

特別なクラッジとして、もし@option{-B}で提供されたパスが@file{[dir/]stage@var{N}/}であり、ここで
@var{N}が0から9までの数値ならば、それは@file{[dir/]include}によって置換される。これはコンパイラの
ブートストラップを助けるためである。

@item -no-canonical-prefixes
@opindex no-canonical-prefixes
シンボリックリンクを展開せず、@samp{/../}および@samp{/./}への参照を解決せず、相対接頭辞を生成するときのパス絶対も作らない。

@item --sysroot=@var{dir}
@opindex sysroot
ヘッダとライブラリの論理ルートディレクトリとして@var{dir}を使う。例えば、
コンパイラが通常@file{/usr/include}と@file{/usr/lib}でのライブラリを検索するとき、
かわりに@file{@var{dir}/usr/include}と@file{@var{dir}/usr/lib}を検索する。

もしこのオプションと@option{-isysroot}オプションの両方を使ったならば、
@option{--sysroot}オプションはライブラリに適用され、@option{-isysroot}オプションはヘッダファイルに適用される。

GNUリンカ（2.16以降）はこのオプションの必須のサポートを持っている。もしリンカがこのオプションをサポートしないなら、
@option{--sysroot}のヘッダファイルの部分は動くが、ライブラリの部分は動かない。

@item --no-sysroot-suffix
@opindex no-sysroot-suffix
あるターゲットで、接尾辞は使われた他のオプションに依存して、@option{--sysroot}で指定されたルートディレクトリに加えられ、
ヘッダは例えば@file{@var{dir}/usr/include}の代わりに@file{@var{dir}/@var{suffix}/usr/include}で見つかるかもしれない。
このオプションはそのような接尾辞を無効にする。

@end table

@node Code Gen Options
@section コード生成規約オプション
@cindex code generation conventions
@cindex options, code generation
@cindex run-time options

これらはコード生成で使われるインターフェース規約を制御する機種独立のオプションである。

これらの殆どは肯定形と否定形がある。@option{-ffoo}の否定形は@option{-fno-foo}である。
以下の表で、形式の一つだけがリストされる。デフォルトでないほう。@samp{no-}を取り除くか加えることで
もう片方を得ることができる。

@table @gcctabopt
@item -fstack-reuse=@var{reuse-level}
@opindex fstack_reuse
このオプションは、ユーザー宣言されたローカル/自動変数とコンパイラ生成の一時値のスタック空間の再生利用を制御する。
@var{reuse_level}は、@samp{all}、@samp{named_vars}または@samp{none}であることができる。
@samp{all}はすべての局所変数と一時値のスタック再利用を使用可能にする、
@samp{named_vars}は名前のあるユーザー定義済みの局所変数だけの再利用を使用可能にする、
そして、@samp{none}は完全にスタック再利用を抑制する。デフォルト値は@samp{all}である。
プログラムがスコープを持つ局所変数の有効期間を拡張するか、コンパイラが言語によって定義される端点を超えて一時値を生成したとき、
オプションが必要である。変数の有効期間が終わるとき、そして、変数がメモリで生きるならば、生存範囲がそれと重ならない他の一時値または
スコープを持つ局所変数でそのスタック空間を再利用する自由が、最適化しているコンパイラにはある。
ローカル有効期間を拡張している古いコードは、スタック再利用最適化で破壊しうる。

例えば、

@smallexample
   int *p;
   @{
     int local1;

     p = &local1;
     local1 = 10;
     ....
   @}
   @{
      int local2;
      local2 = 20;
      ...
   @}

   if (*p == 10)  // local1のスコープ外使用
     @{

     @}
@end smallexample

他の例は:
@smallexample

   struct A
   @{
       A(int k) : i(k), j(k) @{ @}
       int i;
       int j;
   @};

   A *ap;

   void foo(const A& ar)
   @{
      ap = &ar;
   @}

   void bar()
   @{
      foo(A(10)); // 一時オブジェクトの有効期間はfooが返るときに終わる。

      @{
        A a(20);
        ....
      @}
      ap->i+= 10;  // スコープ外のap参照の空間はaで再利用される。ap->iの値は？
   @}

@end smallexample

コンパイラ生成の一時値テンポラリーの有効期間は、C++標準によってはっきりしている。
一時変数の有効期間が終わるとき、そして、一時変数がメモリで生きるならば、生存範囲がそれと重ならない他の一時値またはスコープ局所変数で
そのスタック空間を再利用する自由が、最適化しているコンパイラにはある。
どんなに一時値のスタック空間が再利用されない以前のコンパイラの作用に古いコードの一部が頼っても、
攻撃的スタック再利用はランタイム・エラーにつながりうる。このオプションは、一時的なスタック再利用最適化を制御するのに用いられる。

@item -ftrapv
@opindex ftrapv
このオプションは加算、減算、乗算操作での符号付き桁あふれにトラップを生成する。オプション@option{-ftrapv}と@option{-fwrapv}は
それぞれを上書きし、コマンドラインで@option{-ftrapv} @option{-fwrapv}を使うと@option{-fwrapv}が有効になる。
有効オプションのみが上書きするので、コマンドラインでの@option{-ftrapv} @option{-fwrapv} @option{-fno-wrapv}は
@option{-ftrapv}が有効なことに注意する。

@item -fwrapv
@opindex fwrapv
このオプションは、コンパイラが加算、減算、乗算の符号付き算術桁あふれが2の補数表現を使って循環すると仮定させる。
このフラグはある最適化を有効にして別のものを無効にする。このオプションはJavaフロントエンドでは、Java言語仕様で要求されているので
デフォルトである。オプション@option{-ftrapv}と@option{-fwrapv}は
それぞれを上書きし、コマンドラインで@option{-ftrapv} @option{-fwrapv}を使うと@option{-fwrapv}が有効になる。
有効オプションのみが上書きするので、コマンドラインでの@option{-ftrapv} @option{-fwrapv} @option{-fno-wrapv}は
@option{-ftrapv}が有効なことに注意する。

@item -fwrapv-pointer
@opindex fwrapv-pointer
This option instructs the compiler to assume that pointer arithmetic
overflow on addition and subtraction wraps around using twos-complement
representation.  This flag disables some optimizations which assume
pointer overflow is invalid.

@item -fstrict-overflow
@opindex fstrict-overflow
This option implies @option{-fno-wrapv} @option{-fno-wrapv-pointer} and when
negated implies @option{-fwrapv} @option{-fwrapv-pointer}.

@item -fexceptions
@opindex fexceptions
例外処理を有効にする。例外を伝搬するのに必要な追加のコードを生成する。
あるターゲットでは、これはGCCに全関数のフレーム巻き戻し情報を生成させることを暗示し、それはかなりのデータサイズオーバーヘッド
を生むが、実行には影響しない。もしこのオプションを指定しないならば通常は例外処理が必要なC++ののような言語ではデフォルトで有効にし、
C++ののような通常は必要としない言語では無効にする。しかし、C++で書かれた例外処理と適切に相互作用する必要があるC++コードをコンパイルするときは
このオプションを有効にする必要があるかもしれない。もし例外処理を使わない古いC++プログラムをコンパイルするならばこのオプションを無効にしたいかもしれない。

@item -fnon-call-exceptions
@opindex fnon-call-exceptions
トラップ命令が例外を投げることを可能にするコードを生成する。これはプラットフォーム固有の必ずしもすべての場所では存在しない
ランタイムサポートが必要なことに注意する。さらに、これは@emph{トラップ}命令が例外を投げることしか許可しない。
すなわち、メモリ参照か浮動小数点命令である。@code{SIGALRM}のような任意のシグナルハンドラから投げられる例外は許可しない。

@item -fdelete-dead-exceptions
@opindex fdelete-dead-exceptions
例外を投げるかもしれないが、プログラムの実行にそれ以外は貢献しない最適化で消えるかもしれないとみなす。
Ada言語仕様によって許されるように、このオプションはAdaフロントエンドではデフォルトで有効である。
死んだ例外を取り除かれるようにする最適化パスは、異なる最適化レベルで独立して使用可能にされる。

@item -funwind-tables
@opindex funwind-tables
@option{-fexceptions}と同様だが、必要な静的データだけを生成し、他の方法では生成されたコードに影響させないことを除く。
通常はこのオプションを有効にする必要はない。この扱いを必要とする言語プロセッサが代わりに有効にする。

@item -fasynchronous-unwind-tables
@opindex fasynchronous-unwind-tables
もしターゲット機種がサポートしていれば、DWARFフォーマットに巻き戻しテーブルを生成する。
テーブルはそれぞれの命令境界で正確なので、（デバッガやガベージコレクタのような）非同期イベントからの
スタック巻き戻しで使うことができる。

@item -fno-gnu-unique
@opindex fno-gnu-unique
最近のGNUアセンブラとCライブラリのあるシステムで、C++コードコンパイラは
@code{RTLD_LOCAL}のある場合でさえもテンプレート静的データメンバの定義とインライン関数の静的ローカル変数が唯一であることを保証するために
@code{STB_GNU_UNIQUE}結合を使う。これは、2つの異なる@code{RTLD_LOCAL}プラグインで、それらのうちの一つの依存しているものによって使われ、
それ故にシンボルの結合に関して食い違っているライブラリの問題を避けるために必要である。しかし、これは@code{dlclose}に影響を受けるDSOを
無視されるようにする。あなたのプログラムが@code{dlclose}と@code{dlopen}を通してDSOの最初期化に頼るならば、
あなたは@option{-fno-gnu-unique}を使うことができる。

@item -fpcc-struct-return
@opindex fpcc-struct-return
「短い」@code{struct}と@code{union}の値を長いもののように、レジスタではなくメモリで返す。この規約はあまり効率的ではないが、
GCCでコンパイルされたファイルと他のコンパイラ、特にPortable C Comipler(pcc)でコンパイルされたファイルとの相互運用を可能にする利点がある。

メモリで構造体を返す正確な規約はターゲット設定マクロに依存する。

短い構造体と共用体はそのサイズと境界がある整数型と一致するものである。

@strong{注意：} @option{-fpcc-struct-return}スイッチでコンパイルされたコードは@option{-freg-struct-return}スイッチでコンパイルされた
コードとはバイナリ互換性がない。それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -freg-struct-return
@opindex freg-struct-return
可能なときは@code{struct}と@code{union}値をレジスタで返す。これは@option{-fpcc-struct-return}よりも
小さい構造体ではより効率的である。

もし@option{-fpcc-struct-return}も@option{-freg-struct-return}も指定しないなら、GCCはデフォルトではどちらの規約かは
ターゲットの標準である。もし標準規約がないならば、GCCはデフォルトでは、GCCは主要コンパイラであるターゲットを除いて、
@option{-fpcc-struct-return}である。それらの場合では、標準を選び、代替として最も効率的なレジスタ返却を選ぶ。

@strong{注意：} @option{-freg-struct-return}スイッチでコンパイルされたコードは@option{-fpcc-struct-return}スイッチでコンパイルされた
コードとはバイナリ互換性がない。それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fshort-enums
@opindex fshort-enums
@code{enum}型に可能な値の宣言された範囲に必要なバイト数だけを割り当てる。具体的には、
@code{enum}型は十分な余地がある最小の整数型と等しい。

@strong{警告:} @option{-fshort-enums}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fshort-wchar
@opindex fshort-wchar
@code{wchar_t}の基本型をターゲットのデフォルトの代わりに@code{short unsigned int}で上書きする。このオプションはWINEで走る
プログラムをビルドするときに役立つ。

@strong{警告:} @option{-fshort-wchar}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fno-common
@opindex fno-common
Cコードで、未初期化のグローバル変数の配置を制御する。
Unix C コンパイラは伝統的に、共通ブロックにその変数を置くことで異なるコンパイル単位でそのような変数の複数の定義を許可していた。
これは@option{-fcommon}によって指定される振る舞いで、大抵のターゲットでのGCCにのデフォルトである。
一方、この振る舞いはISO Cで要求されておらず、あるターゲットでは変数参照で速度やコードサイズのペナルティを運ぶかもしれない。
@option{-fno-common}オプションは、一般のブロックとしてそれらを生成するのではなく、オブジェクト・ファイルのデータセクションへ
コンパイラが初期化されていないグローバルな変数を置くべきことを指定する。
あなたがそれらをリンクするとき、同じ変数が2つの異なるコンパイルにおいて宣言される（@code{extern}なしで）ならば、
あなたが複数定義エラーを得るという趣旨を、これは持つ。
この場合、あなたは@option{-fcommon}でコンパイルしなければならない。
それがより良いパフォーマンスを提供するターゲットの上で、あるいは、あなたがこのように初期化されていない可変的な宣言を常に扱う
他のシステムでプログラムが機能することを確かめたいならば、@option{-fno-common}でコンパイルすることは役に立つ。

@item -fno-ident
@opindex fno-ident
@code{#ident}ディレクティブを無視する。

@item -finhibit-size-directive
@opindex finhibit-size-directive
@code{.size}アセンブラディレクティブ、あるいは、関数が中央で分割され、メモリのかなり離れた場所に両方が配置されるならば問題を
起こすであろう他のものを出力しない。
@file{crtstuff.c}をコンパイルするとき、このオプションが使われる。他のどれに対しても使われるべきではない。

@item -fverbose-asm
@opindex fverbose-asm
読めるようにするために生成されたアセンブリコードに追加のコメント情報を置く。このオプションは
通常は実際に生成されたアセンブリコードを読む必要がある人（たぶんコンパイラ自身をデバッグしているとき）
にだけ役立つ。

デフォルトの@option{-fno-verbose-asm}は、追加の情報が取り除かれ、2つのアセンブラファイルを比較するときに役立つ。

加えられるコメントは以下を含む。

@itemize @bullet

@item
コンパイラバージョンとコマンドライン・オプションの情報。

@item
形式FILENAME:LINENUMBER:CONTENT OF LINEでのアセンブリ命令と結び付けられたソースコード行。

@item
高レベルの式が様々なアセンブリ命令オペランドに対応するヒント。

@end itemize

例えば、このCソースファイルが与えられ、

@smallexample
int test (int n)
@{
  int i;
  int total = 0;

  for (i = 0; i < n; i++)
    total += i * i;

  return total;
@}
@end smallexample

@option{-S}経由で(x86_64)アセンブリへとコンパイルし、@option{-o} @option{-}経由で標準出力へと直接生成すると
@smallexample
gcc -S test.c -fverbose-asm -Os -o -
@end smallexample

このような出力になる。

@smallexample
	.file	"test.c"
# GNU C11 (GCC) version 7.0.0 20160809 (experimental) (x86_64-pc-linux-gnu)
  [...snip...]
# options passed:
  [...snip...]

	.text
	.globl	test
	.type	test, @@function
test:
.LFB0:
	.cfi_startproc
# test.c:4:   int total = 0;
	xorl	%eax, %eax	# <retval>
# test.c:6:   for (i = 0; i < n; i++)
	xorl	%edx, %edx	# i
.L2:
# test.c:6:   for (i = 0; i < n; i++)
	cmpl	%edi, %edx	# n, i
	jge	.L5	#,
# test.c:7:     total += i * i;
	movl	%edx, %ecx	# i, tmp92
	imull	%edx, %ecx	# i, tmp92
# test.c:6:   for (i = 0; i < n; i++)
	incl	%edx	# i
# test.c:7:     total += i * i;
	addl	%ecx, %eax	# tmp92, <retval>
	jmp	.L2	#
.L5:
# test.c:10: @}
	ret
	.cfi_endproc
.LFE0:
	.size	test, .-test
	.ident	"GCC: (GNU) 7.0.0 20160809 (experimental)"
	.section	.note.GNU-stack,"",@@progbits
@end smallexample

コメントは機械ではなく人間を対象としているため、コメントの正確な形式は変更される可能性がある。

@item -frecord-gcc-switches
@opindex frecord-gcc-switches
このスイッチは、コンパイラを呼び出すのに用いられるコマンド・ラインを作成されているオブジェクト・ファイルに記録されるようにする。
このスイッチはあるターゲットの上で実装されるだけである。そして、記録の正確なフォーマットはターゲットとバイナルファイル
形式に依存するが、それはアスキー・テキストを含んでいるセクションの形を通常はとる。
このスイッチは@option{-fverbose-asm}スイッチに関連がある、しかし、そのスイッチはコメントとしてアセンブラ出力ファイルで
情報を記録するだけであるので、それはオブジェクト・ファイルに決して達しない。
オブジェクト・ファイルにコンパイラ・オプションを格納するもう一つの方法のために、@option{-grecord-gcc-switches}参照。

@item -fpic
@opindex fpic
@cindex global offset table
@cindex PIC
もしターゲット機種がサポートしてたら、共有ライブラリに使うのに適した位置独立コード(PIC)を生成する。
そのようなコードはすべての定数アドレスをグローバルオフセットテーブル(GOT)を通してアクセスする。
動的ローダはGTOエントリをプログラム開始時に解決する。（動的ローダはGCCの一部ではない。それはオペレーションシステムの一部である）
もしリンクされた実行ファイルのGOTサイズが機種指定の最大サイズを超えたらなら、@option{-fpic}が働かないことを示す
リンカからのエラーメッセージを得る。その場合には、代わりに@option{-fPIC}で再コンパイルする。（最大はSPARCでは8k,AArch64では28k,
m68kとRS/6000では32k。x86はそのような限度はない。）

位置独立コードは特別なサポートを必要とし、特定の機種でのみ働く。x86では、GCCはSystem VではPICをサポートするが、Sun 386iではしない。
IBM RS/6000のために生成された子どは常に位置独立である。

このフラグがセットされると、マクロ@code{__pic__}と@code{__PIC__}は1に定義される。

@item -fPIC
@opindex fPIC
もしターゲット機種がサポートしているならば、動的リンクに適し、グローバルオフセットテーブルのサイズの制限を回避した位置独立コードを
生成する。このオプションはAArch64, m68k, PowerPC, SPARCでは異なっている。

位置独立コードは特別なサポートを必要とし、それゆえに特定の機種でのみ働く。

このフラグがセットされると、マクロ@code{__pic__}と@code{__PIC__}は2に定義される。

@item -fpie
@itemx -fPIE
@opindex fpie
@opindex fPIE
これらのオプションは@option{-fpic}と@option{-fPIC}に似ているが、実行ファイルへとリンクされることだけができる
位置独立コードを生成する。これらのオプションは通常は@option{-pie}GCCオプションリンク時に使われるときに使われる。

@option{-fpie}と@option{-fPIE}の両方はマクロ@code{__pie__}と@code{__PIE__}を定義する。
マクロは@option{-fpie}では1で@option{-fPIE}では2である。

@item -fno-plt
@opindex fno-plt
位置独立コードでの外部関数呼び出しにPLTを使わない。代わりに、GOTとそれへの分岐からの呼び出し場所での呼び出し元アドレスをロードする。
これはPLTスタブを除去してGOTロードを最適化に晒すことによってもっと効率的なコードにさせる。
32ビットx86のようなPLTスタブが特定のレジスタでのGTOポインタを期待するアーキテクチャでは、これはコンパイラはより多くのレジスタ割り当ての
自由を与える。遅延バインディングはPLTをの使用を要求する。@option{-fno-plt}ではすべての外部シンボルがロード時に解決される。

代わりに、関数属性@code{noplt}を特定の外部関数にPLTを通しての呼び出しを避けるために使うことができる。

位置依存コードで、幾つかのターゲットはPLTを使わないとマークされている関数への呼び出しも代わりにGOTを使うように変換する。

@item -fno-jump-tables
@opindex fno-jump-tables
switch分でジャンプテーブルをそれが他のコード生成戦略よりも効率的であっても使わない。
このオプションは@option{-fpic}か@option{-fPIC}と組み合わせて、動的リンカの一部を構成し、
ジャンプテーブルのアドレスを参照できないコードを生成するときに使う。
あるターゲットでは、ジャンプテーブルはGOTを必要とせず、このオプションは必要ない。

@item -ffixed-@var{reg}
@opindex ffixed
@var{reg}という名前のレジスタを固定レジスタとして扱う。生成されたコードはそれを決して参照するべきではない。
（多分スタックポインタ、フレームポインタ、および他の固定役割でを除いて）

@var{reg}はレジスタ名でなければならない。受理されるレジスタ名は機種依存で機種描写マクロファイルの
@code{REGISTER_NAMES}マクロで定義されている。

このフラグは3択を指定するので、否定形はない。

@item -fcall-used-@var{reg}
@opindex fcall-used
名前@var{reg}のレジスタを関数呼出しで破壊される割り当て可能レジスタとして扱う。
一時値か呼び出しを通して生存しない変数に割り当てられるかもしれにあ。
この方法でコンパイルされた関数はレジスタ@var{reg}の保存・復帰をしない。

このフラグをフレームポインタかスタックポインタで使うのはエラーである。マシンの実行モデルで
固定の全面的な役割がある他のレジスタでこのフラグを使うと壊滅的な結果を引き起こす。

このフラグは3択を指定するので、否定形はない。

@item -fcall-saved-@var{reg}
@opindex fcall-saved
名前@var{reg}のレジスタを関数によって保存される割り当て可能なレジスタとして扱う。
それ呼び出しをまたいで生存する一時値か変数としてさえも割り当てられるかもしれない。
今方法でコンパイルされる関数は使われた場合には@var{reg}レジスタの保存と復帰を行う。

このフラグをフレームポインタかスタックポインタで使うのはエラーである。マシンの実行モデルで
固定の全面的な役割がある他のレジスタでこのフラグを使うと壊滅的な結果を引き起こす。

そのレジスタに値を返すかもしれない関数でこのフラグを使うと別種の惨事を起こす。

このフラグは3択を指定するので、否定形はない。

@item -fpack-struct[=@var{n}]
@opindex fpack-struct
値を指定しないと、構造体のメンバをすべて穴なしで詰める。値が指定されると（2の小さいベキでなければならない）、
最大アラインメントを表現する、この値に従って構造体メンバを詰める。
（すなわち、デフォルトでアラインメントの要求がこれより大きいオブジェクトは潜在的に次の合う場所に揃わない。

@strong{警告:} @option{-fpack-struct}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それに加えて、それはコードを最適でなくする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。

@item -fleading-underscore
@opindex fleading-underscore
このオプションとその反対@option{-fno-leading-underscore}は、強制的にCシンボルがオブジェクトファイルでどう表現されるかを変更する。
古いアセンブリコードとのリンクを助けるために使う。

@strong{警告:} @option{-fpack-struct}スイッチはGCCにスイッチなしで生成したコードとバイナリ互換性のないコードを生成するようにする。
それを使うと非デフォルトのアプリケーション・バイナリのインターフェースに従う。
すべてのターゲットがこのスイッチを完全にサポートするわけではない。

@item -ftls-model=@var{model}
@opindex ftls-model
使われるスレッド局所領域モデルを変える。 (@pxref{Thread-Local})
@var{model}引数は@samp{global-dynamic}, @samp{local-dynamic}, @samp{initial-exec}, @samp{local-exec}
のどれかであるべきである。選択が最適化を受けることに注意すべきである：
翻訳単位の外で不可視のシンボルに対して、もしくは@option{-fpic}がコマンドラインに与えられないならば、
もっと効率的なモデルを使うかもしれない。

@option{-fpic}なしのデフォルトは@samp{initial-exec}である。@option{-fpic}では、デフォルトは
@samp{global-dynamic}である。

@item -ftrampolines
@opindex ftrampolines
通常ネストされた関数にトランポリンを必要とするターゲットの場合は、記述子を使用する代わりに常に生成する。それ以外の場合、HP-PAやIA-64のようなそれらを必要としないターゲットの場合は何も行わない。

トランポリンは、ネストされた関数のアドレスが取られたときに実行時にスタック上に作成され、ネストされた関数を間接的に呼び出すために使用される小さなコードである。したがって、プログラムが正常に動作するためにはスタックを実行可能にする必要があります。

@option{-fno-trampolines}は、言語単位で言語に対してデフォルトで有効になっており、コンパイラが安全であると判断して記述子で置き換えないようコンパイラに指示する。記述子はデータのみで構成されているが、生成されたコードはそれらを処理するための準備が必要である。この記事の執筆時点では、@option{-fno-trampolines}はAdaの場合にのみデフォルトで有効になっています。

さらに、@option{-ftrampolines}でコンパイルされたコードと@option{-fno-trampolines}でコンパイルされたコードは、ネストされた関数が存在する場合、バイナリ互換ではない。したがって、このオプションはプログラム全体で使用する必要があり、細心の注意を払って操作する必要がある。

@item -fvisibility=@r{[}default@r{|}internal@r{|}hidden@r{|}protected@r{]}
@opindex fvisibility
デフォルトELFイメージ・シンボル可視性を指定されたオプションにセットする 
― コードの範囲内でくつがえされない限り、シンボルがこれで記されるすべてで。
この機能を使うことで、共有オブジェクト・ライブラリのリンクおよびロード時間を非常に大幅に改善することができ、
より最適化されたコードを生成することができ、ほぼ完全なAPIエクスポートを提供することができ、シンボル衝突を防止することができる。
配布する共有オブジェクトではこれを使うことを@strong{強く}勧める。

命名法にもかかわらず、@samp{default}はpublicを常に意味する。すなわち、共有オブジェクトの外でからリンクされることが可能である。
@samp{protected}と@samp{internal}は現実の使用においてかなり役に立たないので、
唯一の他の一般的に用いられるオプションは@samp{hidden}である。
デフォルトはもし@option{-fvisibility}は指定されないならばsamp{default}であり、すなわちあらゆるシンボルをpublicにする。

ELFシンボルが正しい可視性を持つことを確実とすることによって提供される利益の良い説明は
Ulrich Drepperによる「共有ライブラリの書き方」（@w{@uref{http://www.akkadia.org/drepper/}}で見つかる）
で与えられる。しかし、デフォルトがpublicであるとき、hiddenとマークすることにこのオプションによって可能になる
優れた解決は、デフォルトをhiddenにして、ものをpublicと記すことである。これはWindowsのDLLによる基準であり、
@code{__declspec(dllexport)}の代わりに@option{-fvisibility=hidden}と
@code{__attribute__ ((visibility("default")))}で、あなたは同一の構文でほぼ同一の意味を得る。
これは、クロスプラットフォーム・プロジェクトで働いている人にとっての大きな利益である。

既存のコードに可視性を加える人にとって、@code{#pragma GCC visibility}が役に立つとわかるかもしれない。
これは、あなたが（たとえば）@code{#pragma GCC visibility push(hidden)}と@code{#pragma GCC visibility pop}で
可視性をセットしたい宣言を囲むことで働く。シンボル可視性が@strong{APIインターフェース契約の一部として}見られるべきであり、
したがってそれがデフォルトでないとき、すべての新しいコードは可視性を常に指定するべきであることを心に留めておくべきである。
すなわち、ローカルDSOの中だけで使う宣言はPLT間接オーバーヘッドを避けるために@strong{常に}明示的にhiddenとしてマークすべきである。
また、これを非常に明白にすることは、コードの読みやすさと自己ドキュメンテーションを助ける。
ISO C++仕様必要条件のために、@code{operator new}と@code{operator delete}は常にデフォルト可視性でなければならない点に注意する。

プロジェクトの外からのヘッダ、特にシステムヘッダと使っている他のライブラリからのヘッダは、デフォルト以外の可視性でコンパイルされることを予期していないかもしれないことに注意せよ。そのようなヘッダを含む前に明示的に@code{#pragma GCC visibility push(default)}を言う必要があるかもしれない。

@code{extern}宣言は@option{-fvisibility}に影響を受けないので、多くのコードは修正なしで@option{-fvisibility=hidden}で
再コンパイルされることができる。しかし、これは、明確な可視性のない@code{extern}関数への呼び出しがPLTを使うことを意味するので、
隠されるように、どの@code{extern}宣言が扱われるべきかについて、コンパイラに話すために
@code{__attribute ((visibility))}や@code{#pragma GCC visibility}を使うことがより効果的である。

@option{-fvisibility}がC++の曖昧なリンケージのエンティティに影響することに注意すべきである。
これは、例えば、DSO間で投げられた例外クラスは、@samp{type_info}ノードがDSO間に統合されるように明示的にdefaultとマークされなければならない
ことを意味する。

これらの技術、利点と使い方は@uref{http://gcc.gnu.org/@/wiki/@/Visibility}にある。

@item -fstrict-volatile-bitfields
@opindex fstrict-volatile-bitfields
volatileのビットフィールド
（もしくは、いずれにせよコンパイラは通常はそれらの型を守るはずの他の構造体フィールド）へのアクセスが、
可能ならば自然なアライメントに揃えられて、フィールドの型の幅の単一のアクセスをつかうべきならばこのオプションを使うである。
例えば、メモリーマップされた周辺レジスタのターゲットはそのようなアクセスがすべて16ビット幅であることが要求されるかもしれない。
このフラグですべての周辺ビットフィールドが（それらのターゲットでshortが16ビットであると仮定して）@code{unsigned short}として宣言して、
GCCに多分もっと効率的な32ビットアクセスの代わりに16ビットアクセスを使うように強制する。

このオプションが無効ならば、コンパイラは最も効率的な命令を使う。前の例では、これはたとえそれがビットフィールドに含まれていないバイトや、
更新されるものに無関係なメモリマップされたレジスタにアクセスしたとしても、32ビットロード命令になるかもしれない。

@code{packed}属性が構造体フィールドに適用されるときのような、幾つかの場合は、対象の機種で正しくアライメントされた単一の読み書きで
フィールドにアクセスすることが不可能かもしれない。この場合には、GCCは実行時にフォールトするか切り詰められるコードではなく、複数のアクセスの
生成へとフォールバックする。

注意：C・C++11メモリモデルの制限のために、非ビットフィールドメンバを触る書き込みアクセスは許されていない。それ故に
ビットフィールドメンバとしてフィールドの型の全ビットを定義することが推奨される。

このオプションのデフォルト値はターゲットプロセッサのアプリケーションバイナリインターフェースによって決定される。

@item -fsync-libcalls
@opindex fsync-libcalls
このオプションは関数の@code{__sync}族の行外のインスタンスが関数のC++11@code{__atomic}族を実装するために使って良いかを制御する。

このオプションのデフォルト値は有効で、したがって、オプションの有用な唯一の形式は@option{-fno-sync-libcalls}である。
このオプションは@file{libatomic}ランタイムライブラリの実装で使われる。

@end table

@node Developer Options
@section GCCデベロッパオプション
@cindex developer options
@cindex debugging GCC
@cindex debug dump options
@cindex dump options
@cindex compilation statistics

このセクションは、GCC開発者（コンパイラ・テストとコンパイラの虫とコンパイル回のパフォーマンス問題の調査をサポートするオプションを含む）に、主に興味深いコマンド・ライン・オプションを記載する。
これは、コンパイルにおいていろいろな点でデバッグ・ダンプを生じるオプションを含む;
その印刷統計（例えばメモリ使用と実行時間）;
そして、GCCの構成（それがライブラリを捜すところのような）に関するその印刷情報。
あなたは、めったに、普通のコンパイルとタスクをリンクすることためにこれらのオプションの何も使用する必要はあるべきでない。

@table @gcctabopt

@item -d@var{letters}
@itemx -fdump-rtl-@var{pass}
@itemx -fdump-rtl-@var{pass}=@var{filename}
@opindex d
@opindex fdump-rtl-@var{pass}
時々コンパイルの間のデバッギング・ダンプを@var{letters}によって指定されるようにするように言う。
コンパイラのRTLベースのパスをデバッグするために、これが使われる。
@var{dumpname}にパス番号と語を追加することによって、大部分のダンプのファイル名は作られ、
そしてファイルは出力ファイルのディレクトリで作成される。
@option{=@var{filename}}オプションの場合、ダンプはパス数えられたダンプ・ファイルの代わりに、与えられたファイルで出力される。
パスがパス・マネージャに登録されるので、パス番号が割り当てられる点に注意する。
大部分のパスはそれらが実行する順序で登録され、そしてこれらのパスのために、数はパス実行順序に対応する。
しかし、プラグインによって登録されたパス、コンパイル・ターゲットに特有のパス、さもなくば他のパスすべての後で登録されたパスは、
たとえそれらが早く実行されたとしても、"final"という名前のパスよりも高くて数えられる。
明示的に指定される出力ファイルもしもと実行可能であるもの名前から@var{dumpname}は生成され、
さもなければ、それはソース・ファイルのbasenameである。
@option{-E}がプリプロセスのために使われるとき、これらのスイッチは異なる影響を持つかもしれない。

デバッグ・ダンプは、@option{-fdump-rtl}スイッチまたはある@option{-d}オプション@var{letters}で使用可能にされることができる。
@var{pass}と@var{letters}とそれらの意味に用いられる可能性がある文字は、ここにある：

@table @gcctabopt

@item -fdump-rtl-alignments
@opindex fdump-rtl-alignments
分岐アラインメントが計算された後にダンプする。

@item -fdump-rtl-asmcons
@opindex fdump-rtl-asmcons
入出力制約を満たさないRTL文の修正の後にダンプする

@item -fdump-rtl-auto_inc_dec
@opindex fdump-rtl-auto_inc_dec
自動・インクリメント・デクリメント回復の後にダンプする。このパスは自動インクリメントか自動デクリメント命令を持つアーキテクチャ
でのみ走る。

@item -fdump-rtl-barriers
@opindex fdump-rtl-barriers
バリア命令の掃除の後にダンプする。

@item -fdump-rtl-bbpart
@opindex fdump-rtl-bbpart
ホット・コールド基本ブロックの分割の後にダンプする。

@item -fdump-rtl-bbro
@opindex fdump-rtl-bbro
ブロック並べ替えの後にダンプする。

@item -fdump-rtl-btl1
@itemx -fdump-rtl-btl2
@opindex fdump-rtl-btl2
@opindex fdump-rtl-btl2
@option{-fdump-rtl-btl1}と@option{-fdump-rtl-btl2}はふたつの分岐ターゲットロード最適化パスの後のダンプを有効にする。

@item -fdump-rtl-bypass
@opindex fdump-rtl-bypass
ジャンプ迂回と制御フロー最適化の後にダンプする。

@item -fdump-rtl-combine
@opindex fdump-rtl-combine
RTL命令結合パスの後にダンプする。

@item -fdump-rtl-compgotos
@opindex fdump-rtl-compgotos
計算gotoの非重複化の後にダンプする。

@item -fdump-rtl-ce1
@itemx -fdump-rtl-ce2
@itemx -fdump-rtl-ce3
@opindex fdump-rtl-ce1
@opindex fdump-rtl-ce2
@opindex fdump-rtl-ce3
@option{-fdump-rtl-ce1}、@option{-fdump-rtl-ce2}、@option{-fdump-rtl-ce3}は
３つのif変換パスの後にダンプする。

@item -fdump-rtl-cprop_hardreg
@opindex fdump-rtl-cprop_hardreg
ハードレジスタコピー伝搬の後にダンプする。

@item -fdump-rtl-csa
@opindex fdump-rtl-csa
結合スタック調整の後にダンプする。

@item -fdump-rtl-cse1
@itemx -fdump-rtl-cse2
@opindex fdump-rtl-cse1
@opindex fdump-rtl-cse2
@option{-fdump-rtl-cse1}と@option{-fdump-rtl-cse2}は２つの共通部分式除去パスの後のダンプを有効にする。

@item -fdump-rtl-dce
@opindex fdump-rtl-dce
独立未到達コード除去パスの後にダンプする。

@item -fdump-rtl-dbr
@opindex fdump-rtl-dbr
遅延分岐スケジューリングの後にダンプする。

@item -fdump-rtl-dce1
@itemx -fdump-rtl-dce2
@opindex fdump-rtl-dce1
@opindex fdump-rtl-dce2
@option{-fdump-rtl-dce1}と@option{-fdump-rtl-dce2}は２つの死んでいるストアの除去パスの後のダンプを有効にする。

@item -fdump-rtl-eh
@opindex fdump-rtl-eh
EH処理コードの最終化の後にダンプする。

@item -fdump-rtl-eh_ranges
@opindex fdump-rtl-eh_ranges
EH処理範囲領域の変換後にダンプする。
D
@item -fdump-rtl-expand
@opindex fdump-rtl-expand
RTL生成の後にダンプする。

@item -fdump-rtl-fwprop1
@itemx -fdump-rtl-fwprop2
@opindex fdump-rtl-fwprop1
@opindex fdump-rtl-fwprop2
@option{-fdump-rtl-fwprop1}と@option{-fdump-rtl-fwprop2}は２つの前方伝搬パスの後のダンプを有効にする。

@item -fdump-rtl-gcse1
@itemx -fdump-rtl-gcse2
@opindex fdump-rtl-gcse1
@opindex fdump-rtl-gcse2
@option{-fdump-rtl-gcse1}と@option{-fdump-rtl-gcse2}はグローバル共通部分式除去の後のダンプを有効にする。

@item -fdump-rtl-init-regs
@opindex fdump-rtl-init-regs
レジスタの初期化の後にダンプする。

@item -fdump-rtl-initvals
@opindex fdump-rtl-initvals
初期値集合の計算の後にダンプする。

@item -fdump-rtl-into_cfglayout
@opindex fdump-rtl-into_cfglayout
cfglayoutモードへの変換の後にダンプする。

@item -fdump-rtl-ira
@opindex fdump-rtl-ira
繰り返しレジスタ割り当ての後にダンプする

@item -fdump-rtl-jump
@opindex fdump-rtl-jump
第二ジャンプ最適化の後にダンプする

@item -fdump-rtl-loop2
@opindex fdump-rtl-loop2
@option{-fdump-rtl-loop2}はrtlループ最適化パスの後のダンプを有効にする

@item -fdump-rtl-mach
@opindex fdump-rtl-mach
機種依存再組織化パスの行ったあとに、そのパスが存在するならダンプする

@item -fdump-rtl-mode_sw
@opindex fdump-rtl-mode_sw
冗長モードスイッチ除去の後にダンプする

@item -fdump-rtl-rnreg
@opindex fdump-rtl-rnreg
レジスタ再番号化の後にダンプする

@item -fdump-rtl-outof_cfglayout
@opindex fdump-rtl-outof_cfglayout
cfglayoutモードからの変換の後にダンプする

@item -fdump-rtl-peephole2
@opindex fdump-rtl-peephole2
覗き穴パスの後にダンプする

@item -fdump-rtl-postreload
@opindex fdump-rtl-postreload
リロード後最適化の後にダンプする

@item -fdump-rtl-pro_and_epilogue
@opindex fdump-rtl-pro_and_epilogue
関数プロローグとエピローグの後にダンプする

@item -fdump-rtl-sched1
@itemx -fdump-rtl-sched2
@opindex fdump-rtl-sched1
@opindex fdump-rtl-sched2
@option{-fdump-rtl-sched1}と@option{-fdump-rtl-sched2}は基本ブロックスケジューリングパスの後のダンプを
有効にする。

@item -fdump-rtl-ree
@opindex fdump-rtl-ree
符号・0拡張除去の後にダンプする。

@item -fdump-rtl-seqabstr
@opindex fdump-rtl-seqabstr
共通列回復の後にダンプする。

@item -fdump-rtl-shorten
@opindex fdump-rtl-shorten
分岐短縮化の後にダンプする。

@item -fdump-rtl-sibling
@opindex fdump-rtl-sibling
兄弟呼び出し最適化の後にダンプする。

@item -fdump-rtl-split1
@itemx -fdump-rtl-split2
@itemx -fdump-rtl-split3
@itemx -fdump-rtl-split4
@itemx -fdump-rtl-split5
@opindex fdump-rtl-split1
@opindex fdump-rtl-split2
@opindex fdump-rtl-split3
@opindex fdump-rtl-split4
@opindex fdump-rtl-split5
これらのオプションは命令分割の5段階の後のダンプを有効にする。

@item -fdump-rtl-sms
@opindex fdump-rtl-sms
モジュロ・スケジューリングの後にダンプする。このパスはあるアーキテクチャでのみ走る。

@item -fdump-rtl-stack
@opindex fdump-rtl-stack
GCCの「水平レジスタファイル」レジスタからx87のスタック風レジスタへの変換の後にダンプする。
このパスはx86変種でのみ走る。

@item -fdump-rtl-subreg1
@itemx -fdump-rtl-subreg2
@opindex fdump-rtl-subreg1
@opindex fdump-rtl-subreg2
@option{-fdump-rtl-subreg1}と@option{-fdump-rtl-subreg2}は2つのサブレジスタ表現パスの後のダンプを有効にする。

@item -fdump-rtl-unshare
@opindex fdump-rtl-unshare
全rtlが非共有された後にダンプする。

@item -fdump-rtl-vartrack
@opindex fdump-rtl-vartrack
変数追尾の後にダンプする。

@item -fdump-rtl-vregs
@opindex fdump-rtl-vregs
仮想レジスタからハードレジスタへの変換の後にダンプする。

@item -fdump-rtl-web
@opindex fdump-rtl-web
生存範囲分割の後にダンプする。

@item -fdump-rtl-regclass
@itemx -fdump-rtl-subregs_of_mode_init
@itemx -fdump-rtl-subregs_of_mode_finish
@itemx -fdump-rtl-dfinit
@itemx -fdump-rtl-dfinish
@opindex fdump-rtl-regclass
@opindex fdump-rtl-subregs_of_mode_init
@opindex fdump-rtl-subregs_of_mode_finish
@opindex fdump-rtl-dfinit
@opindex fdump-rtl-dfinish
これらのダンプは定義されているが常にからファイルを生成する。

@item -da
@itemx -fdump-rtl-all
@opindex da
@opindex fdump-rtl-all
上に挙げられたすべてをダンプする。

@item -dA
@opindex dA
アセンブラ出力に雑多なデバッグ情報の注釈をつける。

@item -dD
@opindex dD
プリプロセスの最後に、通常の出力に加えて全マクロ定義を出力する。
normal output.

@item -dH
@opindex dH
エラーがいつ起こったかに関わらずコアダンプを生成する。

@item -dp
@opindex dp
アセンブラ出力にどのパターンと選択肢が使われたかを示すコメントで注釈する。それぞれの命令の長さとコストも出力される。

@item -dP
@opindex dP
それぞれの命令の前にコメントとしてアセンブラ出力でのRTLをダンプする。@option{-dp}注釈もオンにする。

@item -dx
@opindex dx
コンパイルする代わりに関数のRTLをだけを生成する。通常は@option{-fdump-rtl-expand}と使われる。
@end table

@item -fdump-noaddr
@opindex fdump-noaddr
デバッグダンプをするとき、アドレス出力を抑制する。これは異なるコンパイラのバイナリかつ/または異なる
text / bss / data / heap / stack / dso開始場所のあるコンパイラ呼び出しでdiffをより使いやすくする。

@item -freport-bug
@opindex freport-bug
もし内部コンパイラエラー(ICE)が起きたならばデバッグ情報を収集して一時ファイルへダンプする。

@item -fdump-unnumbered
@opindex fdump-unnumbered
デバッグダンプをしているとき、命令番号とアドレス出力を抑制する。
これは異なるオプション、特に@option{-g}のありなしでのデバッグダンプでdiffをより使いやすくする。

@item -fdump-unnumbered-links
@opindex fdump-unnumbered-links
デバッグダンプをするとき(上の@option{-d}を見よ)、列の前後の命令へのリンクの命令番号を抑制する。

@item -fdump-ipa-@var{switch}
@opindex fdump-ipa
手続間解析の各段階で言語木をファイルにダンプするのを制御する。ファイル名はソースファイル名にスイッチ固有の接尾辞を加えることで
生成され、出力ファイルと同じディレクトリに作られる。以下のダンプが可能である。

@table @samp
@item all
全手続区間解析ダンプを有効にする。

@item cgraph
呼び出しグラフ最適化、未使用関数削除、インライン化決定についての情報をダンプする。

@item inline
関数インライン化の後にダンプする。

@end table

@item -fdump-lang-all
@itemx -fdump-lang-@var{switch}
@itemx -fdump-lang-@var{switch}-@var{options}
@itemx -fdump-lang-@var{switch}-@var{options}=@var{filename}
@opindex fdump-lang-all
@opindex fdump-lang
Control the dumping of language-specific information.  The @var{options}
and @var{filename} portions behave as described in the
@option{-fdump-tree} option.  The following @var{switch} values are
accepted:

@table @samp
@item all

Enable all language-specific dumps.

@item class
Dump class hierarchy information.  Virtual table information is emitted
unless '@option{slim}' is specified.  This option is applicable to C++ only.

@item raw
Dump the raw internal tree data.  This option is applicable to C++ only.

@end table

@item -fdump-passes
@opindex fdump-passes
現在のコマンドラインオプションでオン・オフになる最適化パスのリストをダンプする。

@item -fdump-statistics-@var{option}
@opindex fdump-statistics
別々のファイルでパス統計のダンピングを使用可能にして制御する。ソース・ファイル名に@samp{.statistics}で終わっている
接尾辞を追加することによってファイル名は生成され、ファイルは出力ファイルと同じディレクトリで作成される。
@samp{-@var{option}}の形が使われるならば、パスがそれらを生成して@samp{-details}があらゆるイベントをダンプする間、
@samp{-stats}はカウンタを全部のコンパイル単位の上に合計されるようにする。
オプションのないデフォルトは、コンパイルされる各々の関数のためにカウンタを合計するようにする。

@item -fdump-tree-all
@itemx -fdump-tree-@var{switch}
@itemx -fdump-tree-@var{switch}-@var{options}
@itemx -fdump-tree-@var{switch}-@var{options}=@var{filename}
@opindex fdump-tree-all
@opindex fdump-tree
中間言語木を処理する様々な段階でのファイルへのダンプを制御する。ファイル名はスイッチ固有の接尾辞をソースファイル名
に食わることで生成され、ファイルは出力ファイルと同じディレクトリに作られる。
@option{=@var{filename}}オプションの場合には、ダンプは自動の名前のダンプファイルの代わりに与えられたファイル名に出力される。
もし@samp{-@var{options}}形式が使われたならば、@var{options}は@samp{-}で区切られたダンプの詳細を制御するオプションのリストである。
すべてのオプションがすべてのダンプに適用可能なわけではない。意味のないものは無視される。以下のオプションが利用可能である。

@table @samp
@item address
それぞれのノードのアドレスを出力する。通常これは環境とソース・ファイルに依存して変わるので意味を持たない。
その主要な使い方はデバッグ環境でダンプファイルと関連させるためである。
@item asmname
もし@code{DECL_ASSEMBLER_NAME}が与えられた宣言でセットされていたら、@code{DECL_NAME}の代わりにダンプでそれが使われる。
その主要な使い方はアセンブリファイルでのマングルされた名前から後方に働かせるときである。
@item slim
フロントエンドの中間の表現をダンプするとき、単にその範囲に達しただけでの関数の範囲または本体のメンバーの廃棄を禁止する。
ある他のパスによって直接届くときだけ、それはそのようなアイテムをダンプする。

ダンピングが木を整えて印字したとき、このオプションは制御構造の本体をダンプすることを妨げる。

RTLをダンプするとき、デフォルトのLISP風表現の代わりに薄い（凝縮される）形式でRTLをプリントする。
@item raw
木の生表現を出力する。デフォルトでは、木はC風の表現にきれいに出力される。
@item details
より詳細なダンプを有効にする。（すべてのダンプ・オプションによって引き受けられるというわけではない）
最適化パスからの情報も含まれる。
@item stats
パスについての様々な統計のダンプを有効にする。（すべてのダンプ・オプションによって引き受けられるというわけではない）
@item blocks
基本ブロック境界の表示を有効にする。（生ダンプでは無効にされる）
@item graph
他の示されたダンプ・ファイル（@option{-fdump-rtl-@var{pass}}）の各々で、
@file{@var{file}.@var{passid}.@var{pass}.dot}にGraphVizで見ることにふさわしい制御フロー・グラフの表現をダンプする。
ファイルの各々の関数はサブグラフとして整えて出力印字され、GraphVizは一つのプロットでそれらにすべてを与えることができる。

このオプションは現在RTLダンプにのみ働き、RTLはいつもslim形式でダンプされる。
@item vops
全文での仮想オペランドの表示を有効にする。
@item lineno
文の行番号の表示を有効にする。
@item uid
それぞれの変数の固有ID(@code{DECL_UID})の表示を有効にする。
@item verbose
それぞれの文の木ダンプの表示を有効にする。
@item eh
それぞれの文を保持するEH領域番号の表示を有効にする。
@item scev
スカラー進化解析詳細の表示を有効にする。
@item optimized
最適化情報の表示を有効にする。（あるパスでの利用可能である）
@item missed
失われた最適化情報の表示を有効にする。（あるパスでのみ利用可能である）
@item note
他の詳細の最適化情報を有効にする。（あるパスでのみ利用可能である）
@item =@var{filename}
自動の名前のダンプファイルの代わりに、与えられたファイル名へ出力する。
ファイル名@file{stdout}と@file{stderr}は特別に扱われて常に標準ストリームを開くとみなされる。
例えば、

@smallexample
gcc -O2 -ftree-vectorize -fdump-tree-vect-blocks=foo.dump
     -fdump-tree-pre=/dev/stderr file.c
@end smallexample

は@file{foo.dump}にベクトル化器ダンプを出力し、PREダンプは@file{stderr}に出力する。
もし2つの矛盾するファイル名が同じパスに与えられたなら、後者のオプションが前者を上書きする。

@item all
@option{raw}, @option{slim}, @option{verbose}, @file{lineno}を除く全オプションを有効にする。

@item optall
すべての最適化オプション、すなわち、@option{optimized}, @option{missed}, @option{note}をオンにする。
@end table


使用可能なツリーダンプを特定する、またはパスのダンプを検索するためには、以下の手順に従う。

@enumerate
@item
@option{-fdump-passes}でGCCを起動し、@file{stderr}の出力で目的のパスに対応するコードを探す。
たとえば、@code{tree-evrp}、@code{tree-vrp1}、@code{tree-vrp2}というコードは、3つの値域伝播パスに対応している。
最後の数字は、同じパスの別々の呼び出しを区別する。
@item
ダンプファイルの作成を有効にするには、パスコードを@option{-fdump-}オプション接頭辞に付加し、GCCをそれつきで呼ぶ。 たとえば、初期値範囲伝播パスからダンプを有効にするには、@option{-fdump-tree-evrp}オプションを指定してGCCを起動する。 オプションで、ダンプ・ファイルの名前を指定することもできる。 指定しない場合、GCCは以下のように作成する。
@item
ピリオドで区切られた3つのコンポーネント、つまりGCCがコンパイルのために呼び出されたソースファイルの名前、パス番号の後に文字パス@samp{t}が続くツリーパスを示す数字サフィックス （RTLパスの場合は@samp{r}）、最後にパスコードを見つける。たとえば、初期VRPパスダンプは、現在の作業ディレクトリの@file{myfile.c.038t.evrp}という名前のファイルに存在する可能性がある。 数値コードは安定しておらず、GCCのあるバージョンから別のバージョンに変更される可能性があることに注意すること。
@end enumerate

@item -fopt-info
@itemx -fopt-info-@var{options}
@itemx -fopt-info-@var{options}=@var{filename}
@opindex fopt-info
様々な最適化パスからの最適化ダンプを制御する。もし@samp{-@var{options}}形が使われるならば、
@var{option}はダンプ詳細と最適化を選択するための@samp{-}で分割されたオプションキーワードのリストである。

@var{options}は2つのグループに分割できる。ダンプの詳細性を描写するオプションと、含まれるべき最適化を描写するオプションである。
両方のグループからのオプションは重ならない限り自由に混ぜることができる。しかし、衝突する場合には、
コマンドラインでの後者のオプションが前者のオプションを上書きする。

以下のオプションがダンプの詳細性を制御する。

@table @samp
@item optimized
最適化が的にように成功したときに情報を出力する。どの情報が関連するかを決定するかはパスまでである。
例えば、ベクトル化パスはベクトル化に成功したループのソースの場所を出力する。
@item missed
外した最適化についての情報を出力する。個々のパスはどの情報が出力に含まれるかを制御する。
@item note
最適化についての、ある変換および決定についてのもっと詳細なメッセージなどの詳細な情報を出力する。
@item all
詳細の最適化情報を出力する。これは@samp{optimized}, @samp{missed}, @samp{note}を含む。
@end table

以下のオプションキーワードの一つ以上は最適化のグループを描写するために使われる。

@table @samp
@item ipa
全手続間最適化からのダンプを有効にする。
@item loop
全ループ最適化からのダンプを有効にする。
@item inline
全インライン最適化からダンプを有効にする。
@item vec
全ベクトル化最適化からのダンプを有効にする。
@item optall
前最適化からのダンプを有効にする。これは上でリストした最適化グループの上位集合である。
@end table

もし@var{options}が省略されたなら、@samp{optimized-optall}がデフォルトになり、
全パスからの成功した最適化についての情報がすべてダンプされることを意味する。

もし@var{filename}が提供されるなら、すべての適用可能な最適化からのダンプが@var{filename}へと連結される。
複数の@option{-fopt-info}オプションが受理されるが、一つだけが@var{filename}を含むことができる。
もし他のファイル名が提供されるなら、最初以外のすべては無視される。

出力@var{filename}は複数の翻訳単位の場合には上書きされることに注意する。
もし複数の翻訳単位からの結合された出力が望まれるならば、@file{stderr}が代わりに使われるべきである。

以下の例では、最適化情報が@file{stder}へと出力される。

@smallexample
gcc -O3 -fopt-info
@end smallexample

この例では：
@smallexample
gcc -O3 -fopt-info-missed=missed.all
@end smallexample

@noindent
全パスからの失敗した最適化報告が@file{missed.all}へと出力され、この例では:

@smallexample
gcc -O2 -ftree-vectorize -fopt-info-vec-missed
@end smallexample

@noindent
ベクトル化パスからの失敗した最適化機会についての情報が@file{stderr}へと出力される。
@option{-fopt-info-vec-missed}は@option{-fopt-info-missed-vec}と等価であることに注意する。@option{-fopt-info}の後にリストされた最適化グループ名とメッセージタイプの順序は関係ない。
  

他の例として、
@smallexample
gcc -O3 -fopt-info-inline-optimized-missed=inline.txt
@end smallexample

@noindent
は全インラインパスからの最適化された場所だけでなく失敗した最適化についての情報も@file{inline.txt}へと出力する。

最後に、以下は:

@smallexample
gcc -fopt-info-vec-missed=vec.miss -fopt-info-loop-optimized=loop.opt
@end smallexample

@noindent
ここで一つの出力ファイルのみが許されるので２つの出力ファイル名@file{vec.miss}と@file{loop.opt}は衝突する。
この例では、最初のオプションのみが効果を持ち、後ろのオプションは無視される。したがって、@file{vec.miss}が生成され、
それには失敗した奇怪に関するベクトル化器からのダンプが含まれる。

@item -fsched-verbose=@var{n}
@opindex fsched-verbose
命令スケジューリングを使うターゲットで、このオプションはダンプファイルへのスケジューラのデバッグ出力の量を制御する。

ゼロより大きい@var{n}では、@option{-fsched-verbose}は@option{-fdump-rtl-sched1}と@option{-fdump-rtl-sched2}と同じ情報を
出力する。1より大きな@var{n}では、基本ブロック確率、詳細の準備リスト情報、unit/命令情報も出力する。
2より大きな@var{n}では、強制終了点でのRTL、制御フロー、領域情報も含まれる。4より大きな@var{n}では、
@option{-fsched-verbose}は依存情報も含まれる。

@item -fenable-@var{kind}-@var{pass}
@itemx -fdisable-@var{kind}-@var{pass}=@var{range-list}
@opindex fdisable-
@opindex fenable-

これは明示的に最適化パスを無効・有効にするために使われるオプションの集合である。
これらのオプションはGCCをデバッグするために使われる。コンパイラのユーザはパスを有効・無効にするためには
代わりに通常のオプションを使うべきである。

@table @gcctabopt

@item -fdisable-ipa-@var{pass}
IPAパス@var{pass}を無効にする。@var{pass}はパスの名前である。もし同じパスがコンパイラで静的に複数回呼ばれるならば、
パス名は１から始まる順番の番号を加えるべきである。

@item -fdisable-rtl-@var{pass}
@itemx -fdisable-rtl-@var{pass}=@var{range-list}
RTLパス@var{pass}を無効にする。@var{pass}はパス名である。もし同じパスがコンパイラで静的に複数回呼ばれるならば、
パス名は１から始まる順番の番号を加えるべきである。@var{range-list}は関数範囲かアセンブラ名のコンマ区切りのリストである。
それぞれの範囲はコロン区切りのペアである。範囲は両端を含む。もし範囲が自明ならば、数値のペアは単一の数に単純化できる。
もし関数の呼び出しグラフノードの@var{uid}が指定された範囲の一つに入らないならば、@var{pass}はその関数で無効にされる。
@var{uid}はダンプファイルの関数ヘッダに現れ、パス名はオプション@option{-fdump-passes}を使ってダンプできる。

@item -fdisable-tree-@var{pass}
@itemx -fdisable-tree-@var{pass}=@var{range-list}
木パス@var{pass}を無効にする。オプション引数の説明は@option{-fdisable-rtl}を見よ。

@item -fenable-ipa-@var{pass}
IPAパス@var{pass}を有効にする。@var{pass}はパス名である。もし同じパスがコンパイラで静的に複数回呼ばれるならば、
パス名は１から始まる順番の番号を加えるべきである。

@item -fenable-rtl-@var{pass}
@itemx -fenable-rtl-@var{pass}=@var{range-list}
RTLパス@var{pass}を有効にする。オプション引数の説明と例は@option{-fdisable-rtl}を見よ。

@item -fenable-tree-@var{pass}
@itemx -fenable-tree-@var{pass}=@var{range-list}
木パス@var{pass}を有効にする。オプション引数の説明は@option{-fdisable-rtl}を見よ。

@end table

ここにこれらのプションを使用を示す例がいくつかある。

@smallexample

# disable ccp1 for all functions
   -fdisable-tree-ccp1
# disable complete unroll for function whose cgraph node uid is 1
   -fenable-tree-cunroll=1
# disable gcse2 for functions at the following ranges [1,1],
# [300,400], and [400,1000]
# disable gcse2 for functions foo and foo2
   -fdisable-rtl-gcse2=foo,foo2
# disable early inlining
   -fdisable-tree-einline
# disable ipa inlining
   -fdisable-ipa-inline
# enable tree full unroll
   -fenable-tree-unroll

@end smallexample

@item -fchecking
@itemx -fchecking=@var{n}
@opindex fchecking
@opindex fno-checking
内部一貫性チェックを有効にする。デフォルトはコンパイラ設定に依存する。
@option{-fchecking=2} enables further
internal consistency checking that might affect code generation.

@item -frandom-seed=@var{string}
@opindex frandom-seed
このオプションはコンパイルファイルごとに異ならなければならないシンボル名を生成する場所でGCCが使うシードを提供する。
それはカバレッジデータファイルとそれが生成するオブジェクトフィアルでの唯一のスタンプを置くためにも使われる。
@option{-frandom-seed}オプションを再現可能な同一のオブジェクトファイルを生成するために使うことができる。

@var{string}が数(10進、8進、16進)か任意の文字列（その場合CRC32を計算することで数に変換される）のどちらかであることができる。

@var{string}はコンパイルするファイルごとに異なるべきである。

@item -save-temps
@itemx -save-temps=cwd
@opindex save-temps
通常の「一時」中間ファイルを永久に保管する。それらを現在のディレクトリでソースファイルに
基づいた名前で置く。したがって、@option{-c -save-temps}で@file{foo.c}でコンパイルすると
ファイル@file{foo.o}だけでなく@file{foo.i}と@file{foo.s}も生成する。
これはたとえ今やコンパイラが統合されたプリプロセッサを使っていてもプリプロセスされた
@file{foo.i}出力ファイルを作る。

@option{-x}コマンドラインオプションと組み合わせて使ったときは、@option{-save-temps}は
十分に賢いので中間ファイルとして同じ拡張子の入力ファイルを上書きするの避ける。
対応する中間ファイルは@option{-save-temps}を使う前にソースファイルのリネームをすることで
得られるかもしれない。

もしGCCを並列で呼んで、異なるサブディレクトリで共通の基底名を共有する異なるソースファイルをコンパイルするか、
複数の出力対象で同じソースファイルをコンパイルするならば、異なる並列コンパイラは相互に干渉し、一時ファイルを
上書きするかもしれない。例えば、

@smallexample
gcc -save-temps -o outdir1/foo.o indir1/foo.c&
gcc -save-temps -o outdir2/foo.o indir2/foo.c&
@end smallexample

は@file{foo.i}と@file{foo.o}を同時に両方のコンパイラで書こうとする結果になるかもしれない。

@item -save-temps=obj
@opindex save-temps=obj
通常の「一時」中間ファイルを影響に保管する。もし@option{-o}オプションが使われたなら、
一時ファイルはオブジェクトファイルに基づく。もし@option{-o}が使われなければ、
@option{-save-temps=obj}スイッチは@option{-save-temps}のように振る舞う。

例えば、

@smallexample
gcc -save-temps=obj -c foo.c
gcc -save-temps=obj -c bar.c -o dir/xbar.o
gcc -save-temps=obj foobar.c -o dir2/yfoobar
@end smallexample

@noindent
は@file{foo.i}, @file{foo.s}, @file{dir/xbar.i},
@file{dir/xbar.s}, @file{dir2/yfoobar.i}, @file{dir2/yfoobar.s},
@file{dir2/yfoobar.o}を作る。

@item -time@r{[}=@var{file}@r{]}
@opindex time
コンパイルシーケンスでの各サブプロセスによって使ったCPU時間を報告する。Cソースファイルでは、
これはコンパイラ自身とアセンブラ（ともしリンクが行われたらリンカ）である。

出力ファイルの指定子なしでは、出力はこのようになる。

@smallexample
# cc1 0.12 0.01
# as 0.00 0.01
@end smallexample

それぞれの行の最初は「ユーザ時間」であり、それはプログラム自身を実行した時間である。
二番目の数は「システム時間」であり、プログラムのためのシステムルーチンを実行した時間である。
両方の数は秒単位である。

出力ファイルの指定ありでは、出力は名前付きファイルに加えられ、以下のようになる。

@smallexample
0.12 0.01 cc1 @var{options}
0.00 0.01 as @var{options}
@end smallexample

「ユーザ時間」と「システム時間」はプログラム名の前に移動し、プログラムに渡されたオプションが表示され、
後でコンパイルされたファイルが何かとどのオプションが使われたかを知ることができる。

@item -fdump-final-insns@r{[}=@var{file}@r{]}
@opindex fdump-final-insns
最終内部表現(RTL)を@var{file}にダンプする。もしオプション引数が省略されたなら（もしくは@var{file}が@code{.}なら）
ファンプファイル名の名前はコンパイル出力ファイル名に@code{.gkd}を加えることで決定される。

@item -fcompare-debug@r{[}=@var{opts}@r{]}
@opindex fcompare-debug
@opindex fno-compare-debug
もしコンパイル中にエラーが起こらなければ、二度コンパイラを走らせ、二度目のコンパイルでは
@var{opts}と@option{-fcompare-debug-second}を引数に加えて渡す。最後のコンパイルで最後の内部表現
をダンプし、異なっていたらエラーを出力うすｒ。

もし統合が省略されたらな、デフォルトの@option{-gtoggle}は使う。

環境変数@env{GCC_COMPARE_DEBUG}が、もし定義されて、空でなくゼロでなければ、
@option{-fcompare-debug}を暗黙の有効する。もし@env{GCC_COMPARE_DEBUG}がダッシュで始まって定義されていたら、
@var{opts}のために使われ、さもなければデフォルトの@option{-gtoggle}が使われる。

等号はあるが@var{opts}のない@option{-fcompare-debug=}は@option{-fno-compare-debug}と等価であり、
最終表現のダンプを無効にして、@env{GCC_COMPARE_DEBUG}さえも効果が出ることを防ぐ。

@option{-fcompare-debug}テストの間、完全なカバーを確かめるために、@option{-fcompare-debug-not-overridden}を言うために、
@env{GCC_COMPARE_DEBUG}をセットし、GCCはそれをがどんな（プリプロセス、アセンブリ・リンクでない）実際のコンパイルでも
不正なオプションとして拒絶する。単に警告を得るには、@env{GCC_COMPARE_DEBUG}に@samp{-w%n-fcompare-debug
not overridden}をセットすることでそうなる。

@item -fcompare-debug-second
@opindex fcompare-debug-second
このオプションは暗黙に@option{-fcompare-debug}によって要求されている第二コンパイル用にコンパイラに渡され、
警告を抑制し、コンパイラーが副作用としてファイルへの出力または標準出力への出力を生成するその他のオプションを省略させる。
ダンプファイルと保存された一時ファイルは、最初によって制し得されたものを上書きするのを防ぐために
第二コンパイルの間は@code{.gk}の追加拡張子を含むように名前を変える。

このオプションをコンパイルドライバに渡したときは、@emph{最初の}コンパイルをスキップさせ、
コンパイラ自身をデバッグするときを除いてあまり役に立たなくする。

@item -gtoggle
@opindex gtoggle
もしそれなしでこのオプションがデバッグ情報を生成するならそれの生成を切り、
さもなければレベル２でオンにする。コマンドラインでのこの引数の位置は問題ではない。
それは他のすべてのオプションが処理された後で効果を持ち、何回与えられたとしても一度だけである。
これは主に@option{-fcompare-debug}と使うことを意図している。

@item -fvar-tracking-assignments-toggle
@opindex fvar-tracking-assignments-toggle
@opindex fno-var-tracking-assignments-toggle
@option{-gtoggle}が@option{-g}を切り替えるのと同じやり方で@option{-fvar-tracking-assignments}を切り替える。

@item -Q
@opindex Q
コンパイラにコンパイルされた関数名ごとに出力するようにさせ、
それぞれのパスについて終わるときに統計を出力する。

@item -ftime-report
@opindex ftime-report
それぞれのパスでそれが終わるときに消費した時間についての統計をコンパイラに出力させる。

@item -ftime-report-details
@opindex ftime-report-details
インフラストラクチャの部品が費やす時間をパスごとに個別に記録する。

@item -fira-verbose=@var{n}
@opindex fira-verbose
統合レジスタ割当器用のダンプファイルの詳細性を制御する。デフォルト値は5である。もし値@var{n}が10以上ならば、
ダンプ出力は@var{n}-10と同じ書式を使って標準エラーへと送られる。

@item -flto-report
@opindex flto-report
リンク時最適化の仕事の内部詳細のある報告を出力する。この報告の内容はあバージョンからバージョンで変化する。
これは(@option{-flto}経由で)LTOモードでのオブジェクトファイルを処理するときにGCC++デベロッパに役立つことを意図している。

デフォルトで無効である。

@item -flto-report-wpa
@opindex flto-report-wpa
@option{-flto-report}と似ているが、リンク時最適化のWPAフェーズのためだけに出力する。

@item -fmem-report
@opindex fmem-report
終了時にコンパイラに永久メモリ割り当てについての統計を出力させる。

@item -fmem-report-wpa
@opindex fmem-report-wpa
コンパイラにWPAフェーズフェーズだけでの永久メモリ割り当てについての統計を出力させる。

@item -fpre-ipa-mem-report
@opindex fpre-ipa-mem-report
@item -fpost-ipa-mem-report
@opindex fpost-ipa-mem-report
コンパイラに手続間最適化の前後での永久メモリ割り当てについての統計を出力させる。

@item -fprofile-report
@opindex fprofile-report
コンパイラに個々のパスの（推測された）プロファイルの一貫性と効果についての統計を出力させる。

@item -fstack-usage
@opindex fstack-usage
プログラムのスタック使用情報を、関数ごとの基準で出力させる。ダンプの大ルメイは@var{auxname}に@file{.su}を加えることで
作られる。@var{auxname}はもし明示的に指定されそれが実行可能でないならば出力ファイルの名前から生成され、
さもなければソースファイルの基底名である。エントリは3つのフィールドで作られる。

@itemize
@item
関数の名前
@item
バイト数
@item
1つ以上の指定子： @code{static}, @code{dynamic}, @code{bounded}
@end itemize

指定子@code{static}は関数がスタックを静的に操作することを意味する。
関数の入り口でフレームに固定長のバイトが割り当てられ、関数の出口で解放される。
関数内では他にはスタックの調整は行われない。第2フィールドはこの固定されたバイト数である。

指定子@code{dynamic}は関数がスタックを動的に操作することを意味する。上で描写された静的割り当てに加えて、
関数の本体で、例えば関数呼び出し周りでの引数のプッシュ・ポップのような関数本体でのスタックの調整がある。
もし指定子@code{bounded}もあるならば、それらの調整の量はコンパイル時に制限され、第2フィールドは関数によって使われる
スタックの合計量の上限である。もしそれが存在しなければ、それらの調整の量はコンパイル時に制限されず、第2フールドは
制限された部分のみを表す。

@item -fstats
@opindex fstats
コンパイルの終わりにフロントエンド処理についての統計を放出する。このオプションはC++フロントエンドでのみサポートされていて、
情報は一般的にはG++の開発チームにのみ役立つ。

@item -fdbg-cnt-list
@opindex fdbg-cnt-list
すべてのデバッグカウンタの名前とカウンタ上限を出力する。


@item -fdbg-cnt=@var{counter-value-list}
@opindex fdbg-cnt
内部デバッグカウンタ上限をセットする。@var{counter-value-list}は
それぞれのデバッグカウンタ@var{name}の上限を@var{value}にセットする@var{name}:@var{value}ペアのコンマで区切られた
リストである。すべてのデバッグカウンタはは初期の上限@code{UINT_MAX}を持っている。したがって、
@code{dbg_cnt}は上限をこのオプションでセットしない限り常に真を返す。
例えば、@option{-fdbg-cnt=dce:10,tail_call:0}で、@code{dbg_cnt(dce)}は最初の10呼び出しだけ真を返す。

@item -print-file-name=@var{library}
@opindex print-file-name
リンク時に使われるライブラリファイル@var{library}の完全絶対名を出力し、他のことは何もしない。
このオプションで、GCCはコンパイルもリンクも何もしない。ファイル名を出力するだけである。

@item -print-multi-directory
@opindex print-multi-directory
コマンドラインに存在する他のスイッチによって選択されるmultilibに対応するディレクトリ名を出力する。
このディレクトリは@env{GCC_EXEC_PREFIX}に存在すると想定される。

@item -print-multi-lib
@opindex print-multi-lib
multilibディレクトリ名からそれをを有効にするコンパイラスイッチへの対応を出力する。ディレクトリ名は
@samp{;}によってスイッチから分離され、それぞれのスイッチは@samp{-}の代わりに@samp{@@}で始まり、
複数のスイッチ間にスペースはない。これはシェル処理を簡易化すると想定される。

@item -print-multi-os-directory
@opindex print-multi-os-directory
選択されたmultilibへのOSライブラリへのパスを@file{lib}サブディレクトリへの相対パスで出力する。
もしOSMOTICライブラリが@file{lib}サブディレクトリにあって、multilibが使われなければ、これは単に@file{.}であり、
もしOSライブラリが@file{lib@var{suffix}}兄弟ディレクトリにあるならば、これは例えば@file{../lib64}, @file{../lib}もしくは
@file{../lib32}を出力し、もしOSライブラリが@file{lib/@var{subdir}}サブディレクトリにあるならば、それは例えば
@file{amd64}、@file{sparcv9}、@file{ev6}を出力する。

@item -print-multiarch
@opindex print-multiarch
選択されたmultiarchのOSライブラリのパスを@file{lib}サブディレクトリからの相対で出力する。

@item -print-prog-name=@var{program}
@opindex print-prog-name
@option{-print-file-name}と似ているが、@command{cpp}のようなプログラムを検索する。

@item -print-libgcc-file-name
@opindex print-libgcc-file-name
@option{-print-file-name=libgcc.a}と同じである。

これは@option{-nostdlib}および@option{-noddefaultlibs}を使うが@file{Libgcc.a}をリンクしたいときに役立つ。
このようにできる。

@smallexample
gcc -nostdlib @var{files}@dots{} `gcc -print-libgcc-file-name`
@end smallexample

@item -print-search-dirs
@opindex print-search-dirs
設定されたインストールディレクトリの名前と@command{gcc}が検索するプログラムとライブラリディレクトリのリストを
出力する。他には何もしない。
これは@command{gcc}はエラーメッセージ@samp{installation problem, cannot exec cpp0: No such file or directory}
を出力したときに役立つ。これを解決するためには@file{cpp0}と他のコンパイラ部品を@command{gcc}が期待する場所におくか、
環境変数@env{GCC_EXEC_PREGIX}をそれらをインストールしたディレクトリにセットする必要がある。末尾に@samp{/}を置くのを忘れないこと。
@xref{Environment Variables}.

@item -print-sysroot
@opindex print-sysroot
コンパイルの間に使われるターゲットsysrootディレクトリを出力する。これは設定時が、多分コンパイルオプションに依存して
追加の接尾辞を付けた@option{--sysroot}オプションを使って指定されたターゲットsysrootである。もしターゲットsysrootが指定されないならば、
このオプションを何も出力しない。

@item -print-sysroot-headers-suffix
@opindex print-sysroot-headers-suffix
ヘッダを検索するときにターゲットsysrootに追加した接尾辞を出力するか、コンパイラがそのような接尾辞を設定されていないならばエラーを出す。
他には何もしない。

@item -dumpmachine
@opindex dumpmachine
コンパイラのターゲット機種（例えば、@samp{i686-pc-linux-gnu}）を出力する。他には何もしない。

@item -dumpversion
@opindex dumpversion
コンパイラのバージョン（@code {3.0}、@code {6.3.0}、@code {7}など）を出力する。他に何もしない。これはファイルシステムのパスと仕様で使用されるコンパイラのバージョンであり、コンパイラの設定方法によっては、単一の数字（メジャーバージョン）、ドットで区切られた2つの数字（メジャーとマイナーバージョン） ドット（メジャー、マイナー、パッチレベルのバージョン）になる。

@item -dumpfullversion
@opindex dumpfullversion
完全なコンパイラバージョンを印刷します。常に3つの数字をドット、メジャー、マイナー、パッチレベルで区切る。

@item -dumpspecs
@opindex dumpspecs
コンパイラの組み込みのspecsを出力する。他には何もしない。（これはGCCの自身をビルドするときに使う）  @xref{Spec Files}.
@end table

@node Submodel Options
@section 機種依存オプション
@cindex submodel options
@cindex specifying hardware config
@cindex hardware models and configurations, specifying
@cindex target-dependent options
@cindex machine-dependent options

GCCのによってサポートされているそれぞれのターゲット機種には自身のオプションがある。例えば、
特定のプロセッサ変種やABI向けにコンパイルするか、その機種固有の最適化を制御するために。規約によって、
機種固有のオプションの名前は@samp{-m}で始まる。

コンパイラのある設定は追加のターゲット固有のオプションもサポートし、通常は同じプラットフォームの他のコンパイラとの互換性のためである。

@c This list is ordered alphanumerically by subsection name.
@c It should be the same order and spelling as these options are listed
@c in Machine Dependent Options

@menu
* AArch64 Options::
* Adapteva Epiphany Options::
* ARC Options::
* ARM Options::
* AVR Options::
* Blackfin Options::
* C6X Options::
* CRIS Options::
* CR16 Options::
* Darwin Options::
* DEC Alpha Options::
* FR30 Options::
* FT32 Options::
* FRV Options::
* GNU/Linux Options::
* H8/300 Options::
* HPPA Options::
* IA-64 Options::
* LM32 Options::
* M32C Options::
* M32R/D Options::
* M680x0 Options::
* MCore Options::
* MeP Options::
* MicroBlaze Options::
* MIPS Options::
* MMIX Options::
* MN10300 Options::
* Moxie Options::
* MSP430 Options::
* NDS32 Options::
* Nios II Options::
* Nvidia PTX Options::
* PDP-11 Options::
* picoChip Options::
* PowerPC Options::
* PowerPC SPE Options::
* RISC-V Options::
* RL78 Options::
* RS/6000 and PowerPC Options::
* RX Options::
* S/390 and zSeries Options::
* Score Options::
* SH Options::
* Solaris 2 Options::
* SPARC Options::
* SPU Options::
* System V Options::
* TILE-Gx Options::
* TILEPro Options::
* V850 Options::
* VAX Options::
* Visium Options::
* VMS Options::
* VxWorks Options::
* x86 Options::
* x86 Windows Options::
* Xstormy16 Options::
* Xtensa Options::
* zSeries Options::
@end menu

@node AArch64 Options
@subsection AArch64オプション
@cindex AArch64 Options

これらのオプションはAArch64実装のために定義されている。

@table @gcctabopt

@item -mabi=@var{name}
@opindex mabi
指定されたデータ・モデルのコードを生成する。許される値はint, long int, ポインタが32ビットであるSys-V風のデータモデル@samp{ilp32}と、
intが32ビットで、long intとポインタが64ビットであるSysV風データモデルの@samp{lp64}である。

デフォルトは指定されたターゲット設定に依存する。LP64とILP32ABIはリンク互換性がないことに注意する。全プログラムを同じABIでコンパイルし、
ライブリの互換性のある集合でリンクしなければならない。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンコードを生成する。これはGCCが@samp{aarch64_be-*-*}ターゲットで設定されているときはデフォルトである。

@item -mgeneral-regs-only
@opindex mgeneral-regs-only
汎用目的レジスタだけを使うコードを生成する。これはコンパイラが符号小数点とAdvanced SIMDレジスタを使うことを防ぐが
アセンブラでの制限は押し付けない。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンコードを生成する。これはGCCは@samp{aarch64-*-*}だが@samp{aarch64_be-*-*}ターゲットでなく
設定されたときのデフォルトである。

@item -mcmodel=tiny
@opindex mcmodel=tiny
極小のコードモデル用のコードを生成する。プログラムと静的に定義されたシンボルはそれぞれ1GB以内でなければならない。
ポインタは64ビットである。プログラムは静的にも動的にもリンクできる。このモデルは完全には実装されていなく、
ほとんど@samp{samll}として扱われる。

@item -mcmodel=small
@opindex mcmodel=small
小さいコードモデル用のコードを生成する。プログラムと静的に定義されたシンボルはそれぞれ4GB以内でなければならない。
ポインタは64ビットである。プログラムは静的にも動的にもリンクできる。これはデフォルトのコードモデルである。

@item -mcmodel=large
@opindex mcmodel=large
大きなコードモデル用のコードを生成する。これはアドレスとセクションおサイズなんの仮定もしない。
ポインタは64ビットである。プログラムは静的にのみリンクできる。

@item -mstrict-align
@opindex mstrict-align
境界の合っていないメモリ参照がシステムで扱われると仮定しない。

@item -momit-leaf-frame-pointer
@itemx -mno-omit-leaf-frame-pointer
@opindex momit-leaf-frame-pointer
@opindex mno-omit-leaf-frame-pointer
末端関数でフレームポインタを省略・保持する。前者の振る舞いがデフォルトである。

@item -mtls-dialect=desc
@opindex mtls-dialect=desc
TLS変数の動的アクセス用のスレッド局所領域メカニズムとしてTSLディスクリプタを使う。これはデフォルトである。

@item -mtls-dialect=traditional
@opindex mtls-dialect=traditional
TSL変数の動的アクセス用のスレッド局所領域メカニズムとして伝統的なTSLを使う。

@item -mtls-size=@var{size}
@opindex mtls-size
即値TSLをオフセットのビットサイズを指定する。正当な値は12、24、32、48である。このオプションは2.25以降のbinutilsに依存する。

@item -mfix-cortex-a53-835769
@itemx -mno-fix-cortex-a53-835769
@opindex mfix-cortex-a53-835769
@opindex mno-fix-cortex-a53-835769
ARM Cortex-A53エラッタ番号835769用の回避手段を有効・無効にする。これはメモリ命令と64ビット整数乗算演算命令の間にNOP命令を挟むことに関連する。

@item -mfix-cortex-a53-843419
@itemx -mno-fix-cortex-a53-843419
@opindex mfix-cortex-a53-843419
@opindex mno-fix-cortex-a53-843419
ARM Cortex-A53エラッタ843419用の回避手段を有効・無効にする。このエラッタ回避手段はリンク時に行われ、これはリンカに対応するフラグを渡すだけである。

@item -mlow-precision-recip-sqrt
@itemx -mno-low-precision-recip-sqrt
@opindex mlow-precision-recip-sqrt
@opindex mno-low-precision-recip-sqrt
逆数平方根近似を計算するとき、そうでない場合よりも1ステップ少ないステップを使用して、待ち時間と精度を低減する。
これは、@option {-ffast-math}が逆平方根近似を有効にする場合にのみ関係し、それはターゲットプロセッサに依存する。

@item -mlow-precision-sqrt
@itemx -mno-low-precision-sqrt
@opindex -mlow-precision-sqrt
@opindex -mno-low-precision-sqrt
平方根近似を有効または無効にする。このオプションは、@option{-ffast-math}または@option{-funsafe-math-optimizations}を使用する場合にのみ有効である。 これを有効にすると、平方根の精度が単精度の場合は約16ビット、倍精度の場合は32ビットになる。有効な場合は、@option{-mlow-precision-recip-sqrt}を含む。

@item -mlow-precision-div
@itemx -mno-low-precision-div
@opindex -mlow-precision-div
@opindex -mno-low-precision-div
除算近似を有効または無効にする。このオプションは、@option{-ffast-math}または@option{-funsafe-math-optimizations}を使用する場合にのみ有効である。 これを有効にすると、除算結果の精度が単精度の場合は約16ビット、倍精度の場合は32ビットになる。

@item -march=@var{name}
@opindex march
ターゲットアーキテクチャと、オプションで1つ以上の機能修飾子を指定する。オプションは形式
@option{-march=@var{arch}@r{@{}+@r{[}no@r{]}@var{feature}@r{@}*}}である。

@var{arch}の可能な値は@samp{armv8-a}, @samp{armv8.1-a}, @samp{armv8.2-a}, @samp{armv8.3-a}, @samp{armv8.4-a}, @var{native}である。

値@samp {armv8.4-a}は@samp {armv8.3-a}を含み、ARMv8.4-Aアーキテクチャ拡張のコンパイラサポートを有効にする。
値@samp{armv8.3-a}は@samp{armv8.2-a}を含み、ARMv8.3-Aアーキテクチャ拡張のコンパイラサポートを有効にする。
値@samp{armv8.2-a}は@samp{armv8.1-a}を含み、ARMv8.2-Aアーキテクチャ拡張のコンパイラサポートを有効にする。
値@samp{armv8.1-a}は@samp{armv8-a}を含み、ARMv8.1アーキテクチャ拡張のコンパイラサポートを有効にする。
特に、@samp{+crc}、@samp{+lse}、@samp{+rdma}機能を有効にする。

値@samp{native}はネイティブのAArch64 GNU/Linuxで利用可能であり、コンパイラにホストシステムの
アーキテクチャを選ばせる。このオプションはもしコンパイラがホストシステムのアーキテクチャを
認識できないときには効果がない。

@var{feature}の可能な値は@ref{aarch64-feature-modifiers,,@option{-march}と@option{-mcpu}機能修正子}
サブセクションでリストされている。衝突する機能修飾子が指定されたときは、一番右の機能が使われる。

GCCは@var{name}をアセンブリコードを生成するときにどの種類の命令を生成できるかを決定するために使う。
もし@option{-march}が@option{-mtune}か@option{-mcpu}のどちらも指定されていないなら、コードは
ターゲットアーキテクチャを実装しているターゲットプロセッサの範囲にまたがってよく実行されるように調整される。

@item -mtune=@var{name}
@opindex mtune
GCCがコードのパフォーマンスを調整すべきターゲットプロセッサの名前を指定する。このオプションの可能な値以下。
@samp{generic}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a55},
@samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
@samp{exynos-m1}, @samp{falkor}, @samp{qdf24xx}, @samp{saphira},
@samp{xgene1}, @samp{vulcan}, @samp{thunderx},
@samp{thunderxt88}, @samp{thunderxt88p1}, @samp{thunderxt81},
@samp{thunderxt83}, @samp{thunderx2t99}, @samp{cortex-a57.cortex-a53},
@samp{cortex-a72.cortex-a53}, @samp{cortex-a73.cortex-a35},
@samp{cortex-a73.cortex-a53}, @samp{cortex-a75.cortex-a55},
@samp{native}。

値@samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
@samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
@samp{cortex-a75.cortex-a55}はbig.LITTLEシステム用のコードのパフォーマンスを調整すべきだということも指定することができる。

さらにネイティブのAArch64 GNU/Linuxシステムでは値@samp{native}が利用可能である。このオプションは、コンパイラに
アーキテクチャを選択してホストシステムのプロセッサ用のコードのパフォーマンスを調整するようにさせる。
コンパイラはホストシステムのアーキテクチャーを認識することができないならば、このオプションは影響を持たない。

@option{-mtune=}, @option{-mcpu=}, @option{-march=}のどれも指定されないならば、コードはターゲットプロセッサの範囲全体でよく動作するように
調整する。

このオプションは機能修正子を後ろにつけることができない。

@item -mcpu=@var{name}
@opindex mcpu
ターゲットプロセッサの名前を指定し、オプションで１つ以上の機能修正子を後ろにつける。
このオプションは形式@option{-mcpu=@var{cpu}@r{@{}+@r{[}no@r{]}@var{feature}@r{@}*}}を持ち、
ここで@var{cpu}の可能な値は@option{-mtune}で利用可能な値と同じである。@var{feature}の可能な値はサブセクション
@ref{aarch64-feature-modifiers,,@option{-march}と@option{-mcpu}機能修正子}で文書化されている。衝突する機能修正子が指定されたときは、
最も右側の機能が使われる。

GCCは@var{name}を（まるで@option{-march}によってのように）アセンブリコードを生成するときに生成可能な命令の種類を決定するために使う。
このオプションが@option{-march}か@option{-mtune}と組み合わせて使われたときは、それらのオプションは、このオプションの該当する一部に優先する。

@item -moverride=@var{string}
@opindex moverride
@option{-mtune=}スイッチに応じてバックエンドによってなされるチューニング決定を上書きする。
このオプションでの@var{string}の構文、意味、受け入れられる値はリリースを超えて一貫性があるようには保証されない。

このオプションはGCCを開発するときに役立つことだけを意図している。

@item -mverbose-cost-dump
@opindex mverbose-cost-dump
デバッグダンプファイルで詳細なコストモデルのダンプを有効にする。 このオプションは、コンパイラのデバッグに使用するために用意されている。

@item -mpc-relative-literal-loads
@itemx -mno-pc-relative-literal-loads
@opindex mpc-relative-literal-loads
@opindex mno-pc-relative-literal-loads
PC相対のリテラルロードを有効・無効にする。このオプションを使用すると、リテラルプールは単一の命令を使用してアクセスされ、各関数の後に放出される。 これにより、関数の最大サイズが1MBに制限される。これは、@option{-mcmodel=tiny}に対してデフォルトで有効になっている。

@item -msign-return-address=@var{scope}
@opindex msign-return-address
戻りアドレスの署名が適用される関数スコープを選択する。許容値はリターンアドレスの署名を無効にする@samp{none}、リーフ関数でない関数のポインタ署名を有効にする@samp{non-leaf}、すべての関数のポインタ署名を有効にする@samp{all}。 デフォルト値は@samp{none}である。

@end table

@subsubsection @option{-march} and @option{-mcpu} Feature Modifiers
@anchor{aarch64-feature-modifiers}
@cindex @option{-march} feature modifiers
@cindex @option{-mcpu} feature modifiers
@option{-march}と@option{-mcpu}で使われる機能修正子は以下とその逆@option{no@var{feature}}のどれかである。

@table @samp
@item crc
CRC拡張を有効にする。これは@option{-march=armv8.1-a}のデフォルトである。
@item crypto
Crypto拡張を有効にする。これは拡張SIMDと浮動小数点命令も有効にする。
@item fp
浮動小数点命令を有効にする。これは@option{-march}と@option{-mcpu}オプションのすべての可能な値のデフォルトである。
@item simd
拡張SIMD命令を有効にする。これは浮動小数点命令も有効にする。これは@option{-march}と@option{-mcpu}オプションのすべての可能な値のデフォルトである。
@item sve
Scalable Vector Extension命令を有効にする。 これにより、アドバンストSIMDおよび浮動小数点命令も有効になる。
@item lse
ラージシステム実行命令を有効にする。これは@option{-march=armv8.1-a}のデフォルトである。
@item rdma
Round Double Multiply Accumulate命令を有効にします。 これは、デフォルトでは@option{-march = armv8.1-a}に対して有効になっている。
@item fp16
FP16拡張を有効にする、これは浮動小数点命令も有効にする。
@item fp16fml
FP16 fmla拡張機能を有効にする。 これにより、FP16拡張命令と浮動小数点命令も有効になる。 このオプションは、@option{-march=armv8.4-a}に対してデフォルトで有効になっている。 Armv8.2-Aより前のアーキテクチャでこのオプションを使用することはサポートされていない。
@item rcpc
RcPc拡張機能を有効にする。 これはGCCからのコード生成を変更するのではなく、アセンブラに渡され、インラインasm文がRcPc拡張からの命令を使用できるようにする。
@item dotprod
ドットプロダクト拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。
@item aes
Armv8-aesおよびpmull暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。
@item sha2
Armv8-sha2暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。
@item sha3
sha512およびsha3暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。 Armv8.2-Aより前のアーキテクチャでこのオプションを使用することはサポートされていない。
@item sm4
sm3およびsm4暗号拡張を有効にする。 これにより、アドバンストSIMD命令も有効になる。Armv8.2-Aより前のアーキテクチャでこのオプションを使用することはサポートされていない。
  
@end table

@option{crypto}は@option{aes}、@option{sha2}、@option{simd}を含み、それは@option{fp}を含む。逆に、
@option{nofp}は@option{nosimd}を含み、それは@option{noctypto}、@option{noaes}、@option{nosha2}を含む。

@node Adapteva Epiphany Options
@subsection Adapteva Epiphanyオプション

これらの@samp{-m}オプションがAdapteva Epiphany用に定義されている。

@table @gcctabopt
@item -mhalf-reg-file
@opindex mhalf-reg-file
範囲@code{r32}@dots{}@code{r63}でレジスタを割り当てない。これはこれらのレジスタがないハードウェア変種でもコードが実行できるようにする。

@item -mprefer-short-insn-regs
@opindex mprefer-short-insn-regs
優先して、短い命令生成を可能にするレジスタを割り当てる。これは命令数を増やし得るので、全体のコードサイズを減らすかもしれないし増やすかもしれない。

@item -mbranch-cost=@var{num}
@opindex mbranch-cost
分岐のコストをだいたい@var{num}「単純」命令にセットする。このコストは反なるヒューリスティックでリリースをまたいで一貫した結果を生み出すことは保証されない。

@item -mcmove
@opindex mcmove
条件付きムーブを生成する。

@item -mnops=@var{num}
@opindex mnops
他のすべての生成された命令の前に@var{num}個のNOPを生成する。

@item -mno-soft-cmpsf
@opindex mno-soft-cmpsf
単精度浮動小数点数比較で、@code{fsub}命令とフラグのテス後を生成する。これはソフトウェア比較よりも速いが、
NaNが存在するか、２つの異なる小さい数が比較されて差が0として計算されるようなときには不正確な結果お生み得る。
デフォルトは@option{-msoft-cmpsf}であり、遅いが、IEEE準拠のソフトウェア比較を使う。

@item -mstack-offset=@var{num}
@opindex mstack-offset
スタックのトップとスタックポインタの間のオフセットをセットする。例えば、
値8は範囲@code{sp+0@dots{}sp+7}の8バイトを末端関数によってスタック割り当てなしで使えることを意味する。
@samp{8}および@samp{16}以外の値はテストされておらずおそらく動かない。
このオプションはABIを変更することにも注意する。ライブラリと異なるスタックオフセットでコンパイルした
プログラムは通常は動かない。
これはもし異なるスタックオフセットがコードを良くするかどうかを評価したい時には役立つが、
実際に異なるスタックサイズオフセットで動くプログラムをビルドするためには、
ツールチェーンに適切な@option{--with-stack-offset=@var{num}}オプションを設定することを推奨する。

@item -mno-round-nearest
@opindex mno-round-nearest
スケジューラが丸めモードが切り詰めにセットされていると仮定する。デフォルトは@option{-mround-nearest}
である。

@item -mlong-calls
@opindex mlong-calls
もし他に属性で指定されていなければ、すべての呼び出しが@code{b} / @code{bl}命令のオフセット範囲を
超えるかもしれないと仮定し、（さもなければ直接の）呼び出しを実行する前にレジスタに関数アドレスをロードする。
これはデフォルトである。

@item -mshort-calls
@opindex short-calls
もし他に属性で指定されていなければ、すべての直接呼び出しが@code{b} / @code{bl}命令の範囲内であると仮定し、
これらの命令を直接呼び出しに用いる。デフォルトは@option{-mlong-calls}である。

@item -msmall16
@opindex msmall16
アドレスが16ビット符号なし値としてロードできると仮定する。これは@option{-mlong-calls}意味論が
有効の関数アドレスには適用されない。

@item -mfp-mode=@var{mode}
@opindex mfp-mode
浮動小数点ユニットの普通の方法をセットする。
これは関数呼び出しと復帰時に提供され期待される浮動小数点モードを決定する。
このモードを関数の開始で主に必要とするモードと一致させると不必要なモード切り替えを避けることで
プログラムと小さく速くすることができる。

@var{mode}は以下の値のうちの一つをセットすることができる。

@table @samp
@item caller
関数の入り口でどんなモードも有効で、保持され、関数の復帰と他の関数の呼び出しで戻される。
このモードはライブラリをおよび異なる一般のFPUモードでの異なるプログラムに
組み込みたいかもしれない翻訳単位をコンパイルするのに役立ち、
普通のFPUモードの特定の選択で必要になるであろうオーバーヘッドと比較して、
単一のオブジェクトファイルを使うことができる利便性は、追加のモードスイッチのサイズとスピードのオーバーヘッドは上回る。

@item truncate
これは切り捨て（すなわち、0への丸め）丸めモードでの浮動小数点計算で使われるモードである。
これは浮動小数点数から整数への変換を含む。

@item round-nearest
これは最も近い偶数への丸めの丸めモードでの浮動小数点数の計算で使われるモードである。

@item int
これはFPUで整数計算を行うために使われるモードである。例えば、整数乗算および、整数乗加算である。
@end table

デフォルトは@option{-mfp-mode=caller}である。

@item -mnosplit-lohi
@itemx -mno-postinc
@itemx -mno-postmodify
@opindex mnosplit-lohi
@opindex mno-postinc
@opindex mno-postmodify
それぞれ、32ビットロードの分割、後置インクリメントアドレスの生成、後置修正アドレスの生成を
無効にするコード生成調整。デフォルトは@option{msplit-lohi},
@option{-mpost-inc}, @option{-mpost-modify}。

@item -mnovect-double
@opindex mno-vect-double
優先SIMDモードをSIモードに変更する。デフォルトは@option{-mvect-double}で、
優先SIMDモードとしてDIモードを使う。

@item -max-vect-align=@var{num}
@opindex max-vect-align
SIMDベクタモード型の最大アラインメント。@var{num}は4か8であり、デフォルトは8である。
これは、もし関連する型のサイズとアラインメントに影響を与える場所でSIMDベクトルモード
を使わないならば多くのライブラリ関数インターフェースに影響を与えないにもかかわらず、
ABI変更であることに注意する。

@item -msplit-vecmove-early
@opindex msplit-vecmove-early
リロード前にベクタムーブを単一のワードのムーブへと分割する。理論的には
これはより良いレジスタ割当を与えるはずだが、今までのところは一般的には逆のようである。

@item -m1reg-@var{reg}
@opindex m1reg-
定数@minus{}1を保持するレジスタを指定し、小さな負の定数とあるビットマスクを高速にロードできるようにする。
@var{reg}の可能な値は@samp{r43}と@samp{r63}で、それは固定レジスタとしてのレジスタの私用を指定子、
@samp{none}はこの目的でレジスタを使わないことを意味する。デフォルトは@option{-m1reg-none}である。

@end table

@node ARC Options
@subsection ARCオプション
@cindex ARC options

このオプションはコードをコンパイルするアーキテクチャ変種を制御する。

@c architecture variants
@table @gcctabopt

@item -mbarrel-shifter
@opindex mbarrel-shifter
バレル・シフタによってサポートされる命令を生成する。これは
@option{-mcpu=ARC601}および@samp{-mcpu=ARCEM}が有効でない限りはデフォルトである。

@item -mjli-always
@opindex mjli-alawys
Force to call a function using jli_s instruction.  This option is
valid only for ARCv2 architecture.

@item -mcpu=@var{cpu}
@opindex mcpu
@var{cpu}用のアーキテクチャタイプ、レジスタ使用、命令スケジューリングパラメータをセットする。
後方互換と利便性のために利用可能な別名オプションもある。@var{cpu}のサポートされた値は

@table @samp
@opindex mA6
@opindex mARC600
@item arc600
ARC600用にコンパイルする。エイリアス： @option{-mA6}, @option{-mARC600}.

@item arc601
@opindex mARC601
ARC601用にコンパイルする。エイリアス： @option{-mARC601}.

@item arc700
@opindex mA7
@opindex mARC700
ARC700用にコンパイルする。エイリアス： @option{-mA7}, @option{-mARC700}.
これは@option{--with-cpu=arc700}で設定されたときのデフォルトである。

@item arcem
ARC EM用にコンパイルする。

@item archs
ARC HS用にコンパイルする。

@item em
ハードウェア拡張なしのARC EM CPU用にコンパイルする。

@item em4
ARC EM4 CPU用にコンパイルする。

@item em4_dmips
ARC EM4 DMIPS CPU用にコンパイルする。

@item em4_fpus
単精度浮動小数点数を拡張したARC EM4 DMIPS CPU用にコンパイルする。

@item em4_fpuda
単精度浮動小数点および二重支援命令を使用するARC EM4 DMIPS CPU用にコンパイルする。

@item hs
アトミック命令以外のハードウェア拡張機能を持たないARC HS CPU用にコンパイルする。

@item hs34
ARC HS34 CPU用にコンパイルする。

@item hs38
ARC HS38 CPU用にコンパイルする。

@item hs38_linux
すべてのハードウェア拡張がオンのARC HS38 CPU用にコンパイルする。

@item arc600_norm
@code{norm}命令を有効にしてARC 600 CPU用にコンパイルする。

@item arc600_mul32x16
@code{norm}命令と32x16ビット乗算命令を有効にしてARC 600 CPU用にコンパイルする。

@item arc600_mul64
@code{norm}と@code{mul64}族命令を有効にしてARC 600 CPU用にコンパイルする。

@item arc601_norm
@code{norm}命令を有効にしてARC 601 CPU用にコンパイルする。

@item arc601_mul32x16
@code {norm}および32x16ビット乗算命令が有効なARC 601 CPU用にコンパイルする。

@item arc601_mul64
@code{norm}と@code{mul64}族命令を使用してARC 601 CPU用にコンパイルする

@item nps400
NPS400チップ上のARC 700用にコンパイルする。

@item em_mini
Compile for ARC EM minimalist configuration featuring reduced register
set.

@end table

@item -mdpfp
@opindex mdpfp
@itemx -mdpfp-compact
@opindex mdpfp-compact
FPX:倍精度FPX命令を生成し、コンパクト実装用に調整する。

@item -mdpfp-fast
@opindex mdpfp-fast
FPX:倍精度FPX命令を生成し、高速実装用に調整する。

@item -mno-dpfp-lrsr
@opindex mno-dpfp-lrsr
FPX拡張補助レジスタの使用から@code{lr}と@code{sr}SR命令を無効にする。

@item -mea
@opindex mea
拡張算術命令を生成する。現在は@code{divaw}, @code{adds}, @code{subs},
@code{sat16}のみがサポートされている。これは@option{-mcpu=ARC700}用にはいつも有効である。

@item -mno-mpy
@opindex mno-mpy
ARC700用の@code{mpy}-属命令を生成しない。このオプションは非推奨である。

@item -mmul32x16
@opindex mmul32x16
32x16ビット乗算と乗加算命令を生成する。

@item -mmul64
@opindex mmul64
@code{mul64}と@code{mulu64}命令を生成する。@option{-mcpu=ARC600}でのみ有効である。

@item -mnorm
@opindex mnorm
@code{norm}命令を生成する。これはもし@option{-mcpu=ARC700}が有効ならデフォルトである。

@item -mspfp
@opindex mspfp
@itemx -mspfp-compact
@opindex mspfp-compact
コンパクトな実装用に調整されたFPX:単精度FPX命令を生成する。

@item -mspfp-fast
@opindex mspfp-fast
高速実装用に調整されたFPX:単精度FPX命令を生成する。

@item -msimd
@opindex msimd
ターゲット固有の組み込み関数を経由したARC SIMD命令の生成を有効にする。
@option{-mcpu=ARM700}でのみ有効である。

@item -msoft-float
@opindex msoft-float
このオプションは無視される。これは互換性の目的のためだけに提供される。
ソフトウェア浮動小数点コードはデフォルトで生成され、このデフォルトはFPXオプションで
上書きできる。単精度には@samp{mspfp}, @samp{mspfp-compact}, または@samp{mspfp-fast}、
倍精度には@samp{mdpfp}, @samp{mdpfp-compact}, or @samp{mdpfp-fast}である。

@item -mswap
@opindex mswap
@code{swap}命令を生成する。

@item -matomic
@opindex matomic
これはアトミックメモリ組み込み関数を実装するためにロック・ロードストア条件拡張を有効にする。
ARC 6xxおよびARC EMコアでは利用できない。

@item -mdiv-rem
@opindex mdiv-rem
ARC v2コアのための@code{div}/@code{rem}命令を有効にする。

@item -mcode-density
@opindex mcode-density
ARC EMのコード密度命令を有効にし、ARC HSではデフォルトでオンである。

@item -mll64
@opindex mll64
ARC HSコアのダブルロード・ストア命令を有効にする。

@item -mtp-regno=@var{regno}
@opindex mtp-regno
スレッドポインタレジスタ番号を指定する。

@item -mmpy-option=@var{multo}
@opindex mmpy-option
乗数設計オプションでARCv2コードをコンパイルする。@samp{wlh1}がデフォルト値である。
@var{multo}の認識される値は：

@table @samp
@item 0
@itemx none
利用可能な乗数はなし。

@item 1
@itemx w
乗数オプションはwにセットされる。16x16乗数で完全にパイプライン化される。
以下の命令が有効になる。@code{mpyw}、@code{mpyuw}。

@item 2
@itemx wlh1
乗数オプションはwlh1にセットされる。32x32乗数で、完全にパイプライン化される（1ステージ）。
以下の命令が追加で有効にされる。@code{mpy}, @code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 3
@itemx wlh2
乗数オプションはwlh2にセットされる。32x32乗数で、完全にパイプライン化される（2ステージ）。
以下の命令が追加で有効にされる。@code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 4
@itemx wlh3
乗数オプションはwlh3にセットされる。2つの16x16乗数で、ブロックされ、直列である。
以下の命令が追加で有効にされる。: @code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 5
@itemx wlh4
乗数オプションはwlh4にセットされる。1つの16x16乗数で、ブロックされ、直列である。
以下の命令が追加で有効にされる。 @code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 6
@itemx wlh5
乗数オプションはwlh5にセットされる。1つの32x4乗数で、ブロックされ、直列である。
以下の命令が追加で有効にされる。 @code{mpy},
@code{mpyu}, @code{mpym}, @code{mpymu}, and @code{mpy_s}.

@item 7
@itemx plus_dmpy
ARC HS SIMDサポート。

@item 8
@itemx plus_macd
ARC HS SIMDサポート。

@item 9
@itemx plus_qmacw
ARC HS SIMDサポート。

@end table

このオプションはARCv2コアでのみ利用可能である。

@item -mfpu=@var{fpu}
@opindex mfpu
指定されたARCv2コア用の浮動小数点ハードウェア拡張を有効にする。@var{fpu}のサポートされた値は以下である。

@table @samp

@item fpus
単精度浮動小数点ハードウェア拡張のサポートを有効にする。

@item fpud
倍精度浮動小数点ハードウェア拡張を有効にする。単精度浮動小数点拡張も有効になる。
ARC EMでは利用できない。

@item fpuda
倍精度補助命令を使った倍精度浮動小数点ハードウェア拡張のサポートを有効にする。
単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpuda_div
倍精度補助命令と、単純精度平方根と除算ハードウェア拡張を使った倍精度浮動小数点ハードウェア拡張
のサポートを有効にする。単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpuda_fma
倍精度補助命令と単純精度融合乗加算ハードウェア拡張を使った倍精度浮動小数点ハードウェア拡張
のサポートを有効にする。単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpuda_all
倍精度補助命令とすべての単純精度ハードウェア拡張を使った倍精度浮動小数点ハードウェア拡張
のサポートを有効にする。単精度浮動小数点拡張も有効になる。このオプションはARC EMでのみ利用可能である。

@item fpus_div
単精度浮動小数点、並びに単精度平方根と除算のハードウェア拡張のサポートを有効にする。

@item fpud_div
倍精度浮動小数点、並びに倍精度平方根と除算のハードウェア拡張のサポートを有効にする。
このオプションは@samp{fpus_div}を含む。ARC EMでは利用できない。

@item fpus_fma
単精度浮動小数点、単精度融合乗加算ハードウェア拡張のサポートを有効にする。

@item fpud_fma
倍精度浮動小数点、倍精度融合乗加算ハードウェア拡張のサポートを有効にする。これは@samp{fpus_fma}を含む。
ARC EMでは利用できない。

@item fpus_all
すべての単精度浮動小数点ハードウェア拡張のサポートを有効にする。

@item fpud_all
すべての単精度・倍精度浮動小数点ハードウェア拡張のサポートを有効にする。ARC EMでは利用できない。

@end table

@item -mirq-ctrl-saved=@var{register-range}, @var{blink}, @var{lp_count}
@opindex mirq-ctrl-saved
Specifies general-purposes registers that the processor automatically
saves/restores on interrupt entry and exit.  @var{register-range} is
specified as two registers separated by a dash.  The register range
always starts with @code{r0}, the upper limit is @code{fp} register.
@var{blink} and @var{lp_count} are optional.  This option is only
valid for ARC EM and ARC HS cores.

@item -mrgf-banked-regs=@var{number}
@opindex mrgf-banked-regs
Specifies the number of registers replicated in second register bank
on entry to fast interrupt.  Fast interrupts are interrupts with the
highest priority level P0.  These interrupts save only PC and STATUS32
registers to avoid memory transactions during interrupt entry and exit
sequences.  Use this option when you are using fast interrupts in an
ARC V2 family processor.  Permitted values are 4, 8, 16, and 32.

@item -mlpc-width=@var{width}
@opindex mlpc-width
Specify the width of the @code{lp_count} register.  Valid values for
@var{width} are 8, 16, 20, 24, 28 and 32 bits.  The default width is
fixed to 32 bits.  If the width is less than 32, the compiler does not
attempt to transform loops in your program to use the zero-delay loop
mechanism unless it is known that the @code{lp_count} register can
hold the required loop-counter value.  Depending on the width
specified, the compiler and run-time library might continue to use the
loop mechanism for various needs.  This option defines macro
@code{__ARC_LPC_WIDTH__} with the value of @var{width}.

@item -mrf16
@opindex mrf16
This option instructs the compiler to generate code for a 16-entry
register file.  This option defines the @code{__ARC_RF16__}
preprocessor macro.

@end table

以下のオプションはアセンブラへと渡され、プリプロセッサのマクロシンボルも定義する。

@c Flags used by the assembler, but for which we define preprocessor
@c macro symbols as well.
@table @gcctabopt
@item -mdsp-packa
@opindex mdsp-packa
DSPパックA拡張を有効にするためにアセンブラに渡される。プリプロセッサシンボル@code{__Xdsp_packa}もセットする。

@item -mdvbf
@opindex mdvbf
二重ビタビ・バタフライ拡張を有効にするためにアセンブラに渡される。プリプロセッサシンボル@code{__Xdvbf}もセットする。

@c ARC700 4.10 extension instruction
@item -mlock
@opindex mlock
ロックロード・ストア条件拡張を有効にするためにアセンブラに渡される。プリプロセッサシンボル@code{__Xlock}もセットする。

@item -mmac-d16
@opindex mmac-d16
アセンブラへ渡される。プリプロセッサシンボル@code{__Xxmac_d16}もセットする。

@item -mmac-24
@opindex mmac-24
アセンブラへ渡される。プリプロセッサシンボル@code{__Xxmac_d24}もセットする。

@c ARC700 4.10 extension instruction
@item -mrtsc
@opindex mrtsc
64ビットタイムスタンプカウンタ拡張命令を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xrtsc}も有効になる。

@c ARC700 4.10 extension instruction
@item -mswape
@opindex mswape
バイト順序反転拡張命令を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xswape}も有効になる。

@item -mtelephony
@opindex mtelephony
電話のための二重・一重イペランド命令を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xtelephony}も有効になる。

@item -mxy
@opindex mxy
XYメモリ拡張を有効にするためにアセンブラへ渡される。
プリプロセッサシンボル@code{__Xxy}も有効になる。

@end table

以下のオプションはどのようにアセンブラコードが注釈されるかを制御する。

@c Assembly annotation options
@table @gcctabopt
@item -misize
@opindex misize
推定されたアドレスでアセンブラ命令を注釈する。

@item -mannotate-align
@opindex mannotate-align
どのアラインメントの考慮が命令を短くするか長くするために決定を導くかを説明する。

@end table

以下のオプションはリンカへと渡される。

@c options passed through to the linker
@table @gcctabopt
@item -marclinux
@opindex marclinux
リンカへと@code{arcliniux}エミュレーションの使用を指定するために渡される。
このオプションはプロファイリングが要求されない@w{@code{arc-linux-uclibc}}と
@w{@code{arceb-linux-uclibc}}ターゲット用にビルドされたツールチェインではデフォルトで有効である。

@item -marclinux_prof
@opindex marclinux_prof
リンカへと@code{arcliniux}エミュレーションの使用を指定するために渡される。
このオプションはプロファイリングが要求される@w{@code{arc-linux-uclibc}}と
@w{@code{arceb-linux-uclibc}}ターゲット用にビルドされたツールチェインではデフォルトで有効である。

@end table

以下のオプションは生成されたコードの意味を制御する。

@c semantically relevant code generation options
@table @gcctabopt
@item -mlong-calls
@opindex mlong-calls
呼び出し命令をレジスタ間接呼び出しとして生成し、したがって完全な32ビット範囲へのアクセスを提供する。

@item -mmedium-calls
@opindex mmedium-calls
呼び出しに、無条件分岐・リンク命令で利用可能なオフセットである25ビット未満のアドレス範囲を使わない。
関す呼び出しの条件付き実行は抑制され、条件付き分岐。リンク命令の21ビット範囲ではなく25ビット範囲が使えるようにする。
これは@w{@code{arc-linux-uclibc}}と@w{@code{arceb-linux-uclibc}}ターゲット用にビルドされたツールチェインの
デフォルトである。

@item -G @var{num}
@opindex G
Put definitions of externally-visible data in a small data section if
that data is no bigger than @var{num} bytes.  The default value of
@var{num} is 4 for any ARC configuration, or 8 when we have double
load/store operations.

@item -mno-sdata
@opindex mno-sdata
sdata参照を生成しない。これは@w{@code{arc-linux-uclibc}}と@w{@code{arceb-linux-uclibc}}
用にビルドされたツールチェインでのデフォルトである。

@item -mvolatile-cache
@opindex mvolatile-cache
volatile参照に任意のキャッシュされたメモリアクセスを使う。これはデフォルトである。

@item -mno-volatile-cache
@opindex mno-volatile-cache
volatile参照でのキャッシュの迂回を有効にする。

@end table

以下のオプションはコード生成を調整する
@c code generation tuning options
@table @gcctabopt
@item -malign-call
@opindex malign-call
呼び出し命令で境界を最適化しない。

@item -mauto-modify-reg
@opindex mauto-modify-reg
レジスタ置換で前置・後置修正の使用を有効にする。

@item -mbbit-peephole
@opindex mbbit-peephole
bbitピープホールを有効にする。

@item -mno-brcc
@opindex mno-brcc
このオプションは@code{BRcc}命令を生成するための@file{arc_reorg}でのターゲット固有のパスを無効にする。
これは結合子パスによって導出される@code{BRcc}生成には影響しない。

@item -mcase-vector-pcrel
@opindex mcase-vector-pcrel
pc相対switchケーステーブルを使う。これはcase表短縮を有効にする。これは@option{-Os}でのデフォルトである。

@item -mcompact-casesi
@opindex mcompact-casesi
短いcasesiパターンを有効にする。これは@option{-Os}でのデフォルトである。

@item -mno-cond-exec
@opindex mno-cond-exec
条件付き実行命令を生成するためのARCompact固有のパスを無効にする。
遅延スロットスケジューリングおよび、オペランド数、リテラルサイズ、命令長、そして条件付き実行の相互作用のために、
条件付き実行を生成するためのターゲット非依存パスはしばしば存在せず、したがってARCポートは
もっと多くのレジスタ割当、分岐短縮、遅延スロットスケジューリングを見つけようとするための特別なパスを保持している。
このパスは、常にではないが、通常はパフォーマンスとコードサイズを向上させるが追加のコンパイル時間がかかり、
それがオフにするスイッチがある理由である。
もし条件付けされているために許容可能なオフセット範囲を超えた呼び出し命令で問題があるならば、代わりに
@option{-mmedium-calls}を使うことを考えるべきである。

@item -mearly-cbranchsi
@opindex mearly-cbranchsi
cbranchsiパターンのリロード前の使用を有効にする。

@item -mexpand-adddi
@opindex mexpand-adddi
RTL生成時に@code{adddi3}と@code{subdi3}を@code{add.f}、@code{adc}などの展開する。このオプションは廃止予定である。

@item -mindexed-loads
@opindex mindexed-loads
添字ロードの使用を有効にする。これはある最適化器が添字付きストアがあつと仮定してしまい、
それはこの場合には成り立たないので問題になりうる。

@item -mlra
@opindex mlra
ローカルレジスタ割当を有効にする。これはARCではまだ実験的であり、したがって
デフォルトではコンパイラは標準のりろー度（すなわち、@option{-mno-lra}）を使う。

@item -mlra-priority-none
@opindex mlra-priority-none
どのターゲットレジスタの優先順位を示さない。

@item -mlra-priority-compact
@opindex mlra-priority-compact
r0..r3 / r12 .. r15のターゲットレジスタ優先順位を示す。

@item -mlra-priority-noncompact
@opindex mlra-priority-noncompact
r0..r3 / r12 .. r15のターゲットレジスタ優先順位を減じる。

@item -mno-millicode
@opindex mno-millicode
(@option{-Os}を使って)サイズの最適化のとき、多数のレジスタの保存と復帰をしなければならない
プロローグとエピローグはしばしばlibgccの特別な関数の呼び出しを使うことで短縮できる。
これは@emph{millicode}呼び出しとして参照される。それらの呼び出しがパフォーマンス問題を持ち出すことがあり、
また・及び非標準でリンクされるときにリンクの問題を引き起こすので、このオプションはmillicode呼び出し生成
を止めるために提供される。

@item -mmixed-code
@opindex mmixed-code
レジスタ割当を16ビット命令生成を助けるために調整する。これは通常は命令数を増やす一方、
平均命令長を減らす効果を持つ。

@item -mq-class
@opindex mq-class
"q"命令選択肢を有効にする。これは@option{-Os}ではデフォルトである。

@item -mRcq
@opindex mRcq
Rcq制約の扱いを有効にする。大抵の短いコード生成はこれに依存している。これはデフォルトである。

@item -mRcw
@opindex mRcw
Rcw制約の扱いを有効にする。ccfsm条件実行は大抵はこれに依存している。これはデフォルトである。

@item -msize-level=@var{level}
@opindex msize-level
命令長とアラインメントに関してサイズ最適化を微調整する。@var{level}の認識された値は、以下の通りである：

@table @samp
@item 0
サイズ最適化なし。このレベルは非推奨であり、@samp{1}として扱われる。

@item 1
短い命令がご都合的に使われる。

@item 2
それに加えて、ループとバリアのあとのコードのアラインメントが落とされる。

@item 3
それに加えて、余分なデータアラインメントが落とされ、オプション@option{Os}が有効になる。

@end table

デフォルトは@option{-Os}が効果があるときは@samp{3}である。それ以外のときは、
セットされていないときの振る舞いはレベル@samp{1}と等価である。

@item -mtune=@var{cpu}
@opindex mune
任意の@option{-mcpu=}によって含まれるものを上書きして、命令スケジューリングパラメータを@var{cpu}用にセットする。

@var{cpu}にサポートされる値は以下のとおりである。

@table @samp
@item ARC600
ARC600 CPU用に調整する。

@item ARC601
ARC601 CPU用に調整する。

@item ARC700
標準乗数ブロックのあるARC700 CPU用に調整する。

@item ARC700-xmac
XMACブロックのあるARC700 CPU用に調整する。

@item ARC725D
ARC725D CPU用に調整する。

@item ARC750D
ARC750D用に調整する。

@end table

@item -mmultcost=@var{num}
@opindex mmultcost
乗算命令の推測されたコストで、@samp{4}が通常命令と等しい。

@item -munalign-prob-threshold=@var{probability}
@opindex munalign-prob-threshold
非境界の分岐の確率しきい値をセットする。@samp{ARC700}用に調整され、速度で最適化されているとき、
ディレイスロットが埋まっていない分岐は、プロファイルが分岐の確率が@var{probability}
未満であると示さない限りは、できれば非境界で長く生成される。
@xref{Cross-profiling}。デフォルトは(REG_BR_PROB_BASE/2)、すなわち5000である。

@end table

以下のオプションは後方互換のために維持されているが、今は非推奨であり、将来のリリースでは削除されるだろう。

@c Deprecated options
@table @gcctabopt

@item -margonaut
@opindex margonaut
時代遅れのFPX

@item -mbig-endian
@opindex mbig-endian
@itemx -EB
@opindex EB
ビッグエンディアン・ターゲットでコードをコンパイルする。これらのオプションは今は非推奨である。
ビッグエンディアンコードを望むユーザは、ツールチェインをビルドするときに
@w{@code{arceb-elf32}}と@w{@code{arceb-linux-uclibc}}ターゲットを使うべきであり、
それはビッグエンディアンがデフォエルトである。

@item -mlittle-endian
@opindex mlittle-endian
@itemx -EL
@opindex EL
リトルエンディアン・ターゲットでコードをコンパイルする。これらのオプションは今は非推奨である。
リトルエンディアンコードを望むユーザは、ツールチェインをビルドするときに
@w{@code{arc-elf32}}と@w{@code{arc-linux-uclibc}}ターゲットを使うべきであり、
それはリトルエンディアンがデフォエルトである。

@item -mbarrel_shifter
@opindex mbarrel_shifter
@option{-mbarrel-shifter}で置き換えられた。

@item -mdpfp_compact
@opindex mdpfp_compact
@option{-mdpfp-compact}で置き換えられた。

@item -mdpfp_fast
@opindex mdpfp_fast
@option{-mdpfp-fast}で置き換えられた。

@item -mdsp_packa
@opindex mdsp_packa
@option{-mdsp-packa}で置き換えられた。

@item -mEA
@opindex mEA
@option{-mea}で置き換えられた。

@item -mmac_24
@opindex mmac_24
@option{-mmac-24}で置き換えられた。

@item -mmac_d16
@opindex mmac_d16
@option{-mmac-d16}で置き換えられた。

@item -mspfp_compact
@opindex mspfp_compact
@option{-mspfp-compact}で置き換えられた。

@item -mspfp_fast
@opindex mspfp_fast
@option{-mspfp-fast}で置き換えられた。

@item -mtune=@var{cpu}
@opindex mtune
@var{cpu}の値@samp{arc600}, @samp{arc601}, @samp{arc700}と
@samp{arc700-xmac}はそれぞれ@samp{ARC601}, @samp{ARC700} and @samp{ARC700-xmac}で置き換えられた。

@item -multcost=@var{num}
@opindex multcost
@option{-mmultcost}で置き換えられた。

@end table

@node ARM Options
@subsection ARMオプション
@cindex ARM options

これらの@samp{-m}オプションはARMポートで定義される。

@table @gcctabopt
@item -mabi=@var{name}
@opindex mabi
指定されたABI用のコードを生成する。許可された値は： @samp{apcs-gnu},
@samp{atpcs}, @samp{aapcs}, @samp{aapcs-linux} と@samp{iwmmxt}.

@item -mapcs-frame
@opindex mapcs-frame
全関数に対して、たとえコードの現在の実行には厳密には必要なくてもARM手続き呼び出し標準に準拠した
スタックフレームを生成する。このオプションと@option{-fomit-frame-pointer}を指定すると
リーフ関数用にスタックフレームは生成されない。デフォルトは@option{-mno-apcs-frame}である。
このオプションは非推奨である。

@item -mapcs
@opindex mapcs
これは@option{-mapcs-frame}の同義語であり非推奨である。

@ignore
@c not currently implemented
@item -mapcs-stack-check
@opindex mapcs-stack-check
（実際にいくつかのスタック領域を使用する）すべての関数への入力時に使用可能なスタック領域の量をチェックするコードを生成する。 十分な空き容量がない場合、必要なスタック領域の量に応じて、@code{__rt_stkovf_split_small}関数または@code{__rt_stkovf_split_big}関数が呼び出される。 ランタイムシステムは、これらの機能を提供する必要がある。 デフォルトは@option{-mno-apcs-stack-check}である。これはより小さなコードを生成するためである。

@c not currently implemented
@item -mapcs-reentrant
@opindex mapcs-reentrant
Generate reentrant, position-independent code.  The default is
@option{-mno-apcs-reentrant}.
@end ignore

@item -mthumb-interwork
@opindex mthumb-interwork
ARMとThumn命令セット間の呼び出しをサポートするコードを生成する。
このオプションなしでは、v5以前のアーキテクチャでは、2つの命令セットは
一つのプログラム内で確実に使うことができない。
@option{-mthumb-interwork}が指定されるとわずかに大きなコードが生成されるため、
@option{-mno-thumb-interwork}である。AAPCS設定ではこのオプションは意味を持たない。

@item -mno-sched-prolog
@opindex mno-sched-prolog
関数プロローグでの命令の並べ替え、及び関数の本体での命令とのそれらの命令との併合を防ぐ。
これは全関数が認識可能な命令の集合で始まり（もしくは実際は異なる関数プロローグの小さい集合の中から
一つ選ばれる）、この情報は実行可能ファイルのコード片内で関数の始まりを探すために使うことができる。
デフォルトは@option{-msched-prolog}である。

@item -mfloat-abi=@var{name}
@opindex mfloat-abi
どの浮動小数点ABIを使うかを指定する。可能な値は@samp{soft}, @samp{softfp}と@samp{hard}である。

@samp{soft}を指定するとGCCは浮動小数点操作用のライブラリ呼び出しを含む出力を生成させる。
@samp{softfp}はハードウェア浮動小数点命令を使うコードを生成できるようにするが、
それでもソフト浮動小数点呼び出し規約を使う。@samp{hard}は浮動小数点命令の生成を許可し、
FPU固有の呼び出し規約を使う。

デフォルトは特定のターゲット設定に依存する。ハード浮動小数点とソフト浮動小数点のABI
はリンク互換でないことに注意する。全プログラムを同じABIで、コンパイルし、
五感のあるライブラリの集合とリンクしなければならない。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンモードで実行するプロセッサ用のコードを生成する。これは
全標準設定のデフォルトである。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンモードで実行するプロセッサ用のコードを生成する。デフォルトは
リトルエンディアンプロセッサ用にコードをコンパイルする。

@item -mbe8
@itemx -mbe32
@opindex mbe8
ビッグエンディアンイメージをリンクするときは、BE8とBE32のフォーマットを選択する。このオプションはリトルエンディアンイメージには効果がなく、無視される。 デフォルトは、選択したターゲットアーキテクチャに依存する。 ARMv6以降のアーキテクチャの場合、デフォルトはBE8である。古いアーキテクチャの場合、デフォルトはBE32である。 BE32形式はARMによって推奨されていない。

@item -march=@var{name}
@opindex march
これはターゲットARMアーキテクチャの名前を指定する。GCCはこの名前をアセンブリコードを生成するときに
生成できる命令の種類を決定するために使う。このオプションは@option{-mcpu=}オプションと一緒に及び代わりに
使うことができる。

可能な名前は以下である： 
@samp{armv4t},
@samp{armv5t}, @samp{armv5te},
@samp{armv6}, @samp{armv6j}, @samp{armv6k}, @samp{armv6kz}, @samp{armv6t2},
@samp{armv6z}, @samp{armv6zk},
@samp{armv7}, @samp{armv7-a}, @samp{armv7ve}, 
@samp{armv8-a}, @samp{armv8.1-a}, @samp{armv8.2-a}, @samp{armv8.3-a},
@samp{armv8.4-a},
@samp{armv7-r},
@samp{armv8-r},
@samp{armv6-m}, @samp{armv6s-m},
@samp{armv7-m}, @samp{armv7e-m},
@samp{armv8-m.base}, @samp{armv8-m.main},
@samp{iwmmxt} and @samp{iwmmxt2}.

さらに、Thumbの実行状態をサポートしない次のアーキテクチャは認識されますが、サポートは廃止予定である。
@samp{armv2}, @samp{armv2a}, @samp{armv3}, @samp{armv3m},
@samp{armv4}, @samp{armv5}, @samp{armv5e}.

多くのアーキテクチャが拡張をサポートしている。 これらは@samp{+@var{extension}}をアーキテクチャ名に追加することで追加できる。 拡張オプションは順番に処理され、機能が蓄積される。拡張は、それに依存する必要なベース拡張も有効にする。 例えば、@samp{+crypto}拡張は常に@samp{+simd}拡張を有効にする。 @samp{+no@dots {}}という接頭辞が付いた拡張機能は例外である。これらの拡張機能は指定されたオプションと、その拡張機能の存在に依存するその他の拡張機能を無効にする。

たとえば、@samp{-march=armv7-a+simd+nofp+vfpv4}オプションは@samp{+simd}オプションがそれに続くsamp{+nofp}オプションで完全に無効になっているので、@samp{-march=armv7-a+vfpv4}と書くのと等価である。

ほとんどの拡張名には一般的に名前が付けられているが、適用されるアーキテクチャに依存する効果がある。 たとえば、@samp{+ simd}オプションは、@samp{armv7-a}と@samp{armv8-a}の両方のアーキテクチャに適用できるが、@samp{armv7-a}の拡張ARMv7-A Advanced SIMD（Neon）と@samp{armv8-a}のARMv8-Aの拡張が有効になる。

以下の表は、各アーキテクチャでサポートされている拡張機能の一覧です。言及されていないアーキテクチャは、拡張をサポートしていない。

@table @samp
@item  armv5e
@itemx armv5te
@itemx armv6
@itemx armv6j
@itemx armv6k
@itemx armv6kz
@itemx armv6t2
@itemx armv6z
@itemx armv6zk
@table @samp
@item +fp
VFPv2浮動小数点命令。拡張@samp{+vfpv2}はこの拡張の別名として使うことができる。

@item +nofp
浮動小数点命令を無効化する。
@end table

@item armv7
ARMv7-A、ARMv7-R、ARMv7-Mアーキテクチャの共通部分集合。
@table @samp
@item +fp
16の倍精度レジスタを持つVFPv3浮動小数点命令。 拡張@samp{+vfpv3-d16}は、この拡張の別名として使用できる。 注意として浮動小数点数は、基本ARMv7-Mアーキテクチャではサポートされていないが、ARMv7-AおよびARMv7-Rアーキテクチャと互換性がある。

@item +nofp
浮動小数点命令を無効化する。
@end table

@item armv7-a
@table @samp
@item +fp
16の倍精度レジスタを持つVFPv3浮動小数点命令。 拡張@samp{+vfpv3-d16}は、この拡張の別名として使用できる。 

@item +simd
Advanced SIMD (Neon) v1とVFPv3浮動小数点命令。拡張@samp{+neon}と@samp{+neon-vfpv3}はこの命令の別名として使用できる。

@item +vfpv3
32の倍精度レジスタを持つVFPv3浮動小数点命令。

@item +vfpv3-d16-fp16
16の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv3-fp16
32の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv4-d16
16の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +vfpv4
32の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +neon-fp16
Advanced SIMD (Neon) v1と半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +neon-vfpv4
Advanced SIMD (Neon) v2とVFPv4浮動小数点命令。

@item +nosimd
Advanced SIMD命令を無効化する（浮動小数点は無効化しない）

@item +nofp
浮動小数点数とAdvanced SIMD命令を無効化する。
@end table

@item armv7ve
仮想化のサポートを持つARMv7-Aアーキテクチャの拡張バージョン。
@table @samp
@item +fp
16の倍精度レジスタを持つVFPv4浮動小数点命令。 拡張@samp{+vfpv4-d16}は、この拡張の別名として使用できる。 

@item +simd
Advanced SIMD (Neon) v2とVFPv4浮動小数点命令。拡張@samp{+neon-vfpv4}はこの命令の別名として使用できる。

@item +vfpv3-d16
16の倍精度レジスタを持つVFPv3浮動小数点命令。

@item +vfpv3
32の倍精度レジスタを持つVFPv3浮動小数点命令。

@item +vfpv3-d16-fp16
16の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv3-fp16
32の倍精度レジスタと半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +vfpv4-d16
16の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +vfpv4
32の倍精度レジスタを持つVFPv4浮動小数点命令。

@item +neon
Advanced SIMD (Neon) v1とVFPv3浮動小数点命令。拡張@samp{+neon-vfpv3}はこの命令の別名として使用できる。

@item +neon-fp16
Advanced SIMD (Neon) v1と半精度浮動小数点変換操作を持つVFPv3浮動小数点命令。

@item +nosimd
Advanced SIMD命令を無効化する（浮動小数点数は無効化しない）

@item +nofp
浮動小数点数とAdvanced SIMD命令を無効化する。
@end table

@item armv8-a
@table @samp
@item +crc
循環冗長検査（CRC）命令。
@item +simd
ARMv8-A Advanced SIMDと浮動小数点命令。
@item +crypto
暗号命令。
@item +nocrypto
暗号命令を無効化する。
@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。
@end table

@item armv8.1-a
@table @samp
@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令。

@item +crypto
暗号命令。これはAdvanced SIMDと浮動小数点命令も有効化する。

@item +nocrypto
暗号命令を無効化する。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。
@end table

@item armv8.2-a
@itemx armv8.3-a
@table @samp
@item +fp16
半精度符号小数点データ処理命令。これはAdvanced SIMDと浮動小数点命令も有効化する。

@item +fp16fml
半精度浮動小数点fmla拡張。これは半精度浮動小数点拡張とAdvanced SIMD、浮動小数点命令も有効化する。

@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令。

@item +crypto
暗号命令。これはAdvanced SIMDと浮動小数点命令も有効化する。

@item +dotprod
内積拡張を有効化する。これは、Advanced SIMD命令も有効化する。

@item +nocrypto
暗号拡張を無効化する。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。
@end table

@item armv8.4-a
@table @samp
@item +fp16
半精度浮動小数点データ処理命令。これはAdvanced SIMD、浮動小数点命令だけでなく、内積拡張と半精度浮動小数点fmla拡張も有効にする。

@item +simd
ARMv8.1-A Advanced SIMDと浮動小数点命令に加えて内積拡張。

@item +crypto
暗号命令。これはAdvanced SIMD、浮動小数点命令に加えて内積拡張も有効にする。

@item +nocrypto
暗号拡張を無効にする。

@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。
@end table

@item armv7-r
@table @samp
@item +fp.sp
単精度VFPv3浮動小数点命令。拡張@samp{+vfpv3xd}をこの拡張の別名として使用可能である。

@item +fp
16の倍精度レジスタを持つVFPv3浮動小数点命令。拡張@samp{+vfpv3-d16}をこの拡張の別名として使用可能である。

@item +nofp
浮動小数点拡張を無効にする。

@item +idiv
ARM状態整数除算命令。

@item +noidiv
ARM状態整数除算拡張を無効化する。
@end table

@item armv7e-m
@table @samp
@item +fp
単精度VFPv4浮動小数点命令。

@item +fpv5
単精度FPv5浮動小数点命令。

@item +fp.dp
単精度・倍精度VFPv5浮動小数点命令。

@item +nofp
浮動小数点拡張を無効化する。
@end table

@item  armv8-m.main
@table @samp
@item +dsp
DSP命令。

@item +nodsp
DSP拡張を無効化する。

@item +fp
単精度浮動小数点命令。

@item +fp.dp
単精度・倍精度浮動小数点命令。

@item +nofp
浮動小数点拡張を無効化する。
@end table

@item armv8-r
@table @samp
@item +crc
循環冗長検査（CRC)命令。
@item +fp.sp
単精度FPv5浮動小数点命令。
@item +simd
ARMv8-A Advanced SIMDと浮動小数点命令。
@item +crypto
暗号命令。
@item +nocrypto
暗号命令を無効化する。
@item +nofp
浮動小数点数、Advanced SIMD、暗号命令を無効化する。
@end table

@end table

@option{-march=native}はビルドコンピュータのアーキテクチャを自動で検出させる。
現在は、この機能はGNU/Linuxでのみサポートされていて、すべてのアーキテクチャが認識されるわけではない。
もし自動検出が不成功ならばこのオプションはなんの効果もない。

@item -mtune=@var{name}
@opindex mtune
このオプションはGCCはコードのパフォーマンスを調整すべきターゲットARMプロセッサの名前を指定する。
ありARM実装ではこのオプションを使うことでよりよいパフォーマンスを得ることができる。
可能な名前は以下である： @samp{arm2}, @samp{arm250},
@samp{arm3}, @samp{arm6}, @samp{arm60}, @samp{arm600}, @samp{arm610},
@samp{arm620}, @samp{arm7}, @samp{arm7m}, @samp{arm7d}, @samp{arm7dm},
@samp{arm7di}, @samp{arm7dmi}, @samp{arm70}, @samp{arm700},
@samp{arm700i}, @samp{arm710}, @samp{arm710c}, @samp{arm7100},
@samp{arm720},
@samp{arm7500}, @samp{arm7500fe}, @samp{arm7tdmi}, @samp{arm7tdmi-s},
@samp{arm710t}, @samp{arm720t}, @samp{arm740t},
@samp{strongarm}, @samp{strongarm110}, @samp{strongarm1100},
@samp{strongarm1110},
@samp{arm8}, @samp{arm810}, @samp{arm9}, @samp{arm9e}, @samp{arm920},
@samp{arm920t}, @samp{arm922t}, @samp{arm946e-s}, @samp{arm966e-s},
@samp{arm968e-s}, @samp{arm926ej-s}, @samp{arm940t}, @samp{arm9tdmi},
@samp{arm10tdmi}, @samp{arm1020t}, @samp{arm1026ej-s},
@samp{arm10e}, @samp{arm1020e}, @samp{arm1022e},
@samp{arm1136j-s}, @samp{arm1136jf-s}, @samp{mpcore}, @samp{mpcorenovfp},
@samp{arm1156t2-s}, @samp{arm1156t2f-s}, @samp{arm1176jz-s}, @samp{arm1176jzf-s},
@samp{generic-armv7-a}, @samp{cortex-a5}, @samp{cortex-a7}, @samp{cortex-a8},
@samp{cortex-a9}, @samp{cortex-a12}, @samp{cortex-a15}, @samp{cortex-a17},
@samp{cortex-a32}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a55},
@samp{cortex-a57}, @samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75},
@samp{cortex-r4}, @samp{cortex-r4f}, @samp{cortex-r5}, @samp{cortex-r7},
@samp{cortex-r8}, @samp{cortex-r52},
@samp{cortex-m33},
@samp{cortex-m23},
@samp{cortex-m7},
@samp{cortex-m4},
@samp{cortex-m3},
@samp{cortex-m1},
@samp{cortex-m0},
@samp{cortex-m0plus},
@samp{cortex-m1.small-multiply},
@samp{cortex-m0.small-multiply},
@samp{cortex-m0plus.small-multiply},
@samp{exynos-m1},
@samp{marvell-pj4},
@samp{xscale}, @samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312},
@samp{fa526}, @samp{fa626},
@samp{fa606te}, @samp{fa626te}, @samp{fmp626}, @samp{fa726te},
@samp{xgene1}.

それに加えて、このオプションはGCCがbig.LITTLEシステム用のコードのパフォーマンスを調整すべきかを指定することができる。
可能な名前は以下である：
@samp{cortex-a15.cortex-a7}, @samp{cortex-a17.cortex-a7},
@samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
@samp{cortex-a72.cortex-a35}, @samp{cortex-a73.cortex-a53},
@samp{cortex-a75.cortex-a55}.

@option{-mtune=generic-@var{arch}}はGCCがアーキテクチャ@var{arch}内のプロセッサの混合用に
パフォーマンスを調整すべきことを指定する。
目的は現在の最も有名なプロセッサでよく走り、その範囲でのあるCPUで有益である最適化の間でバランスを取り、
他のCPUのパフォーマンスの落とし穴を避けることである。このオプションの効果はCPUモデルが出入りするごとに
将来のGCCバージョンでは変化するかもしれない。

@option{-mtune}は@option {-mcpu}と同じ拡張オプションを許可するが、拡張オプションは生成されたコードのチューニングに影響しない。
 
@option{-mtune=native}はコンパイラにCPUを自動検出させる。現在は、この機能はGNU/Linuxでのみサポートされていて、
すべてのアーキテクチャで認識されるわけではない。もし自動検出が不成功ならばこのオプションはなんの効果もない。

@item -mcpu=@var{name}@r{[}+extension@dots{}@r{]}
@opindex mcpu
ターゲットARMプロセッサの名前を指定する。GCCはこの名前を
（まるで@option{-march}で指定されたかのように）ターゲットARMアーキテクチャの名前と
（まるで@option{-mtune}で指定されたかのように）パフォーマンスの調整に用いるARMプロセッサタイプ
を導出するために使う。このオプションが@option{-march}または@option{-mtune}と一緒に使われたときは、
これらのオプションはこのオプションの対応する部分に優先する。

サポートされているCPUの多くは、オプションのアーキテクチャ拡張を実装している。 そうであるところでは、アーキテクチャの拡張は通常、デフォルトで有効になっている。 拡張がない実装が存在する場合、拡張構文を使用して省略された拡張を無効にすることができる。 浮動小数点およびAdvanced SIMD（Neon）命令の場合は、オプション@option{-mfloat-abi}および@option{-mfpu}の設定も考慮する必要がある。浮動小数点およびAdvanced SIMD命令は、@option{-mfloat-abi}は@samp{soft}に設定されていない。 @samp{auto}以外の@option{-mfpu}の設定は、利用可能な浮動小数点命令とSIMD拡張命令を上書きする。

例えば、@samp{cortex-a9}は3つの主要な構成で見つけることができる：整数のみ、浮動小数点ユニットのみ、または浮動小数点とAdvanced SIMD。 デフォルトではすべての命令が有効になるが、拡張@samp{+nosimd}と@samp{+nofp}を使用して、SIMDだけ、またはSIMD命令と浮動小数点命令の両方を無効にすることができる。

このオプションの可能な値は@option{-mtune}のものと同じである。

以下の拡張オプションは、リストされているCPUに共通です。

@table @samp
@item +nodsp
@samp{cortex-m33}のDSP命令を無効にする。
+ 
@item  +nofp
@samp{arm9e}, @samp{arm946e-s}, @samp{arm966e-s}, @samp{arm968e-s}, @samp{arm10e},
@samp{arm1020e}, @samp{arm1022e}, @samp{arm926ej-s},
@samp{arm1026ej-s}, @samp{cortex-r5}, @samp{cortex-r7}, @samp{cortex-r8},
@samp{cortex-m4}, @samp{cortex-m7}, @samp{cortex-m33}における浮動小数点命令を無効にする。
@samp{generic-armv7-a}, @samp{cortex-a5}, @samp{cortex-a7},
@samp{cortex-a8}, @samp{cortex-a9}, @samp{cortex-a12},
@samp{cortex-a15}, @samp{cortex-a17}, @samp{cortex-a15.cortex-a7},
@samp{cortex-a17.cortex-a7}, @samp{cortex-a32}, @samp{cortex-a35},
@samp{cortex-a53}, @samp{cortex-a55}における浮動小数点とSIMD命令を無効にする。

@item +nofp.dp
@samp{cortex-r5}, @samp{cortex-r52}, @samp{cortex-m7}における浮動小数点命令の倍精度構成要素を無効化する。

@item +nosimd
@samp{generic-armv7-a}, @samp{cortex-a5}, @samp{cortex-a7}, @samp{cortex-a9}でのSIMD命令を無効化する（が、不動小数点はしない）
 
@item +crypto
@samp{cortex-a32}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a55}, @samp{cortex-a57},
@samp{cortex-a72}, @samp{cortex-a73}, @samp{cortex-a75}, @samp{exynos-m1},
@samp{xgene1}, @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
@samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53}, @samp{cortex-a75.cortex-a55}で
暗号命令を有効化する。
@end table

さらに、@samp{generic-armv7-a}擬似ターゲットは、16倍精度レジスタを持つVFPv3にデフォルト設定されている。次の拡張オプションをサポートしている。@samp{vfpv3-d16}, @samp{vfpv3},
@samp{vfpv3-d16-fp16}, @samp{vfpv3-fp16}, @samp{vfpv4-d16},
@samp{vfpv4}, @samp{neon}, @samp{neon-vfpv3}, @samp{neon-fp16},
@samp{neon-vfpv4}.  意味は@option{-march=armv7-a}への拡張と同じである。

@option{-mcpu=generic-@var{arch}}も許可され、@option{-march=@var{arch} -mtune=generic-@var{arch}}
と等価である。さらなる情報は@option{-mtune}を見よ。

@option{-mcpu=native}はコンパイラにビルドコンピュータのCPUを自動検出させる。
現在は、この機能はGNU/Linuxでのみサポートされていて、すべてのアーキテクチャが認識されるわけではない。。
もし自動検出が不成功ならば、オプションはなんの効果もない。

@item -mfpu=@var{name}
@opindex mfpu
これはどの浮動小数点ハードウェア（またはハードウェアエミュレーション）がターゲットで利用可能化を指定する。
可能な名前は以下のとおりである： @samp{auto}, @samp{vfpv2}, @samp{vfpv3},
@samp{vfpv3-fp16}, @samp{vfpv3-d16}, @samp{vfpv3-d16-fp16}, @samp{vfpv3xd},
@samp{vfpv3xd-fp16}, @samp{neon-vfpv3}, @samp{neon-fp16}, @samp{vfpv4},
@samp{vfpv4-d16}, @samp{fpv4-sp-d16}, @samp{neon-vfpv4},
@samp{fpv5-d16}, @samp{fpv5-sp-d16},
@samp{fp-armv8}, @samp{neon-fp-armv8}, @samp{crypto-neon-fp-armv8}。
@samp{neon}は@samp{neon-vfpv3}の別名であり、@samp{vfp}は@samp{vfpv2}の別名であることに注意。

設定@samp{auto}がデフォルトであり、これは特別である。それはコンパイラに@option{-mcpu}と@option{-march}の設定に基づいて浮動小数点とAdvanced SIMD命令を選択させる。

もし選択された浮動小数点ハードウェアがNEON拡張（例えば、@option{-mfpuneon})を含むなら、
浮動小数点操作は@option{-funsafe-math-optimizations}も指定しない限りはGCCの自動ベクトル化によっては
生成されない。これはNEONハードウェアが浮動小数点算術がIEEE754標準を完全には実装していないため、
（特に非正規数は０として扱われる）NEON命令の使用は精度の消失を導くかもしれないためである。

@code{target("fpu=")}関数属性(@pxref{ARM Function Attributes})か
プラグマ(@pxref{Function Specific Option Pragmas})を使うことfpu名を設定することもできる。

@item -mfp16-format=@var{name}
@opindex mfp16-format
@code{__fp16}半精度浮動小数点型の書式を指定する。可能な値は@samp{none}, @samp{ieee}, 
@samp{alternative}である。デフォルトは@samp{none}であり、その場合には@code{__fp16}型は定義されない。
さらなる情報は@xref{Half-Precision}参照。

@item -mstructure-size-boundary=@var{n}
@opindex mstructure-size-boundary
全構造体と黄道帯はこのオプションによってセットされたビットの数の倍数に丸められる。
可能な値は8，32, 64である。デフォルト値はツールチェーンで異なる。COFFターゲットのツールチェーンでは
デフォルト値は8であり。もし基準となるABIがサポートするならばその場合だけ64の値が許される。

大きな数を指定すると、より速くて効率的なコードを生成できるが、プログラムのサイズが大きくなる。
異なる値は潜在的に非互換である。ある値でコンパイルされたコードは、もしそれらが構造体や共用体を使った情報
をやり取りするならば、必ずしも他の値でコンパイルされたコードやライブラリと一緒に動くことは期待できない。

This option is deprecated.

@item -mabort-on-noreturn
@opindex mabort-on-noreturn
@code{noreturn}関数の終わりで@code{abort}への呼び出しを生成する。これは関数が帰ろうとすれば実行される。

@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
コンパイラに最初にレジスタに関数のアドレスをロードして、
それからこのレジスタでサブルーチン呼び出しを実行することで関数呼出しを実行するように伝える。
このスイッチはターゲット関数がサブルーチン呼び出し命令のオフセットに基づいたバージョンの64メガバイトの
アドレスの範囲の外にあるならば必要である。

このスイッチが有効であるとしても、すべての関数がロング・コールへと変換されるわけではない。
発見法は、静的関数、@code{short_call}属性を持つ関数、
@code{#pragma no_long_calls}ディレクティブのスコープ内の関数、その定義がすでに現在の翻訳単位内で
コンパイルされた関数ははロング・コールへと変換されないことである。この規則の例外は弱い関数定義、
@code{long_call}属性か@code{seciton}属性を持つ関数、@code{#pragma long_calls}ディレクティブのスコープ内の
関数は常にロングコールへと変換されることである。

この機能はデフォルトでは有効にされない。@option{-mno-long-calls}を指定すると、
デフォルトの機能が復元され、@code{#pragma}ディレクティブのスコープ内に関数が置かれたようになる。
これらのスイッチは関数ポインタ経由で関数呼び出しを使うコードをコンパイラがどのように生成するかには関係しない。

@item -msingle-pic-base
@opindex msingle-pic-base
PICアドレス計算に使われるレジスタを、それぞれの関数のプロローグでロードされるのではなく、
読み取り専用として扱う。ランタイムシステムは実行が始まるまえにこのレジスタを適切な値で初期化する
責任がある。

@item -mpic-register=@var{reg}
@opindex mpic-register
PICアドレス計算で使われるレジスタを指定する。標準のPICベースの場合には、デフォルトは
コンパイラによって決定される任意の適切なレジスタである。単一のPICベースの場合には、
もしEABIベースであるか、スタックチェックが有効ならば、＠samp{R9}であり、
さもなければデフォルトは@samp{R10}である。

@item -mpic-data-is-text-relative
@opindex mpic-data-is-text-relative
それぞれのデータセグメントがロード時のテキストセグメントの相対であると仮定する。
したがって、PC相対命令を使ったデータのアドレス計算を許可する。このオプションは
VxWorksRTP以外のターゲットではデフォルトでオンである。 このようなターゲットで無効のときは、
デフォルトで@option{-msingle-pic-base}が有効になる。

@item -mpoke-function-name
@opindex mpoke-function-name
それぞれの関数の名前をテキストセクションに、関数プロローグの直前に書く。生成されるコードは
これのようになる。

@smallexample
     t0
         .ascii "arm_poke_function_name", 0
         .align
     t1
         .word 0xff000000 + (t1 - t0)
     arm_poke_function_name
         mov     ip, sp
         stmfd   sp!, @{fp, ip, lr, pc@}
         sub     fp, ip, #4
@end smallexample

スタックバックトレースを実行すると金費、コードは@code{fp+0}に格納された@code{pc}の値を検査することができる。
もしその時トレース関数が場所@code{pc-12}を見て最初の8ビットがセットされているならば、
この場所の直前に関数名が埋め込まれていてその長さが@code{((pc[-3]) & 0xff000000)}であることがわかる。

@item -mthumb
@itemx -marm
@opindex marm
@opindex mthumb

生成するコードが実行する状態をARMとThumb状態での間で選択する。
多くの設定でのデフォルトはARM状態で実行するが、デフォルトは
@option{--with-mode=}@var{state}設定オプションでGCCを設定することで変えることができる。

@code{target("thumb")}と@code{target("arm")}関数属性(@pxref{ARM Function Attributes})および
プラグマ(@pxref{Function Specific Option Pragmas})を使うことでそれぞれの関数で
ARMとThumbモードを上書きすることができる。

@item -mflip-thumb 
@opindex mflip-thumb
Switch ARM/Thumb modes on alternating functions.
This option is provided for regression testing of mixed Thumb/ARM code
generation, and is not intended for ordinary use in compiling code.

@item -mtpcs-frame
@opindex mtpcs-frame
全非リーフ関数にThumb手続き呼び出し標準に適合したスタックフレームを生成する。
（リーフ関数は他の関数を呼ばない関数である。）デフォルトは@option{-mno-tpcs-frame}.

@item -mtpcs-leaf-frame
@opindex mtpcs-leaf-frame
すべてのリーフ関数にThumb手続き呼び出し標準に適合したスタックフレームを生成する。
（リーフ関数は他の関数を呼ばない関数である。）デフォルトは@option{-mno-apcs-leaf-frame}

@item -mcallee-super-interworking
@opindex mcallee-super-interworking
関数の残りの部分を実行する前に、Thumbモードに切り替わるARM命令セットヘッダを、
コンパイルされるファイル内のすべての外部から見える関数に渡す。
これはそれらの関数が非連携コードから呼ばれることを可能にする。
このオプションはAAPCS設定では連携がデフォルトで有効になっているために不正である。

@item -mcaller-super-interworking
@opindex mcaller-super-interworking
関数ポインタ（仮想関数を含む）経由での呼び出しがターゲットコードが連携ありで
コンパイルされたかどうかにかかわらず正しく実行できるようにする。このオプションが有効ならば
関数ポインタの実行のコストには小さなオーバーヘッドがある。このオプションはAAPCS設定では
連携がデフォルトで有効になっているので不正である。

@item -mtp=@var{name}
@opindex mtp
スレッドローカル領域ポインタ用のアクセスモデルをシチエする。正当な値は、
@code{_aeabi_read_tp}への呼び出しを生成する@samp{soft}と、
(arm6kアーキテクチャでサポートされた）直接@code{cp15}からスレッドポインタを取る
@samp{cp15}、選択されたプロセッサで利用可能な最善の方法を使う@samp{auto}である。

@item -mtls-dialect=@var{dialect}
@opindex mtls-dialect
スレッドローカル領域にアクセスする方法の変種を指定する。2つの
@var{dialect}がサポートされている。@samp{gnu}と@samp{gnu2}である。
@samp{gnu}変種はローカルとグローバルの動的TLSモデルをサポートするもともとのGNUのスキームを選択する。
@samp{gnu2}変種はGNUディスクリプタスキームを選択肢、それは共有ライブラリでよりよいパフォーマンスを提供する。
GNUディスクリプタスキーマはもともとのスキームと互換性があるが、新しいアセンブラ、リンカとライブラリの
サポートが必要である。初期とローカルの実行のTSLモデルはこのオプションには影響されず、
もともとのスキームが常に使われる。

@item -mword-relocations
@opindex mword-relocations
ワード長の値(すなわち、R_ARM_ABS32)で絶対再割当てのみを生成する。
これはランタイムローダーがこの制限を課しているターゲット（uClinux, SymbianOS）で、
@option{-fpic}及び@option{-fPIC}が指定されているときにデフォルトで有効である。

@item -mfix-cortex-m3-ldrd
@opindex mfix-cortex-m3-ldrd
あるCortex-M3コアは@code{ldrd}命令が重なったデスティネーションとベースレジスタが使われたときに、
データ破壊を引き起こしうる。このオプションはこれらの命令の生成を酒雨r。このオプションは
@option{-mcpu=cortex-m3}が指定されたときにデフォルトで有効である。

@item -munaligned-access
@itemx -mno-unaligned-access
@opindex munaligned-access
@opindex mno-unaligned-access
16及び32ビットに合わせていないアドレスからの16及び32ビット値の読み書きを有効（無効）にする。
デフォルトでは、非境界のアクセスはARMv6より前すべてとARMv6-M全アーキテクチャで無効であり、
他のすべてのアーキテクチャで有効である。境界のあっていないアクセスは有効でないならば、
詰められたデータ構造でのワードは一度に1バイトアクセスされる。

ARM属性@code{Tag_CPU_unaligned_access}がこのオプションの設定に依存して、
生成されたオブジェクトファイルに真か偽でセットされる。もし非境界のアクセスが有効ならば、、
プリプロセッサシンボル@code{__ARM_FEATURE_UNALIGNED}も定義される。

@item -mneon-for-64bits
@opindex mneon-for-64bits
スカラー64ビット操作を扱うためにNeonを使う。これは、コアレジスタからNeonへのデータの移動コストが高いため、
デフォルトでは無効である。

@item -mslow-flash-data
@opindex mslow-flash-data
flashからのデータの読み込みが命令の取得よりも遅いと仮定する。したがって、パフォーマンス向上のために
定数のロードは最小化される。このオプションはARMv7 Mプロファイル用にコンパイルした時だけサポートされ、
デフォルトではオフである。

@item -masm-syntax-unified
@opindex masm-syntax-unified
インラインアセンブラは統一asm構文を使っているとか定数r。デフォルトは現在はオフであり、分割構文を意味する。
このオプションはThumb2では効果がない。しかし、これはGCCはの将来のリリースではカラルかもしれない。
分割構文は非推奨とみなされるべきである。

@item -mrestrict-it
@opindex mrestrict-it
ARMv8-Aの規則に適合するためにITブロックの生成を制限する。ITブロックは命令の選択された集合からの
単一の16ビット命令のみを含むことができる。このオプションはARMv8-A Thumbモードではデフォルトでオンである。

@item -mprint-tune-info
@opindex mprint-tune-info
アセンブラファイルでのコメントとしてCPU調整情報を出力する。これはコンパイラの退行試験用のみに使われるオプションであり、
コードをコンパイルする通常の使用は意図していない。このオプションはデフォルトで無効である。

@item -mverbose-cost-dump
@opindex mverbose-cost-dump
デバッグダンプファイルで詳細なコストモデルのダンプを有効にする。 このオプションは、コンパイラのデバッグに使用するために用意されている。

@item -mpure-code
@opindex mpure-code
コードセクションに定数データを配置しない。さらに、ELFオブジェクト形式用にコンパイルするとき、すべてのテキストセクションにELFプロセッサ固有のセクション属性@code{SHF_ARM_PURECODE}が与えられる。 このオプションは、MOVT命令を使用してM-プロファイルターゲット用に非picコードを生成する場合にのみ使用できる。

@item -mcmse
@opindex mcmse
「ARMv8-Mセキュリティ拡張機能：開発ツールのエンジニアリング仕様に関する要件」に従って、セキュアなコードを生成する。この文書は
@url{http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf}にある。
@end table

@node AVR Options
@subsection AVRオプション
@cindex AVR Options

これらのオプションはAVR実装用に定義されている。

@table @gcctabopt
@item -mmcu=@var{mcu}
@opindex mmcu
Atmel AVR命令セットアーキテクチャ(ISA)かMCUタイプを指定する。

このオプションのデフォルトは@tie{}@samp{avr2}である。

GCCは以下のAVRデバイスとISAをサポートしている。

@include avr-mmcu.texi

@item -mabsdata
@opindex mabsdata
スタティックストレージ内のすべてのデータにLDS / STS命令でアクセスできると仮定する。 このオプションは、ATtiny40のようなTinyデバイスの縮小にのみ影響する。
@code{absdata} @ref{AVR Variable Attributes,variable attribute}も見よ。

@item -maccumulate-args
@opindex maccumulate-args
関数のプロローグ/エピローグで、出力関数の引数を累積し、出力関数の引数に必要なスタック領域を取得/解放する。 このオプションがなければ、発信引数はプッシュされてから関数が呼び出され、後でポップされる。

関数呼び出し後に引数をポップすると、AVR上でコストがかかることがある。そのような関数呼び出し後に引数をスタックから削除する必要がないため、スタック領域を累積すると実行可能ファイルが少なくなる可能性がある。

このオプションは、printfのような関数への呼び出しのように引数をスタックに渡す関数へのいくつかの呼び出しを行う関数のコードサイズを減らすことができる。

@item -mbranch-cost=@var{cost}
@opindex mbranch-cost
条件付き分岐命令の分岐コストを@var{cost}に設定する。 @var{cost}の合理的な値は、小さな負でない整数である。 デフォルトの分岐コストは0である。

@item -mcall-prologues
@opindex mcall-prologues
関数プロローグ/エピローグは、適切なサブルーチンへの呼び出しとして展開される。 コードサイズが小さくなる。

@item -mgas-isr-prologues
@opindex mgas-isr-prologues
Interrupt service routines (ISRs) may use the @code{__gcc_isr} pseudo
instruction supported by GNU Binutils.
If this option is on, the feature can still be disabled for individual
ISRs by means of the @ref{AVR Function Attributes,,@code{no_gccisr}}
function attribute.  This feature is activated per default
if optimization is on (but not with @option{-Og}, @pxref{Optimize Options}),
and if GNU Binutils support @w{@uref{https://sourceware.org/PR21683,PR21683}}.

@item -mint8
@opindex mint8
@code{int}が8ビット整数であると仮定する。 @code{char}は1バイト、@code{int}は1バイト、@code{long}は2バイト、@code{long long}は4バイトである。 このオプションはC標準に準拠していないが、コードサイズは小さくなる。
size.

@item -mmain-is-OS_task
@opindex mmain-is-OS_task
Do not save registers in @code{main}.  The effect is the same like
attaching attribute @ref{AVR Function Attributes,,@code{OS_task}}
to @code{main}. It is activated per default if optimization is on.

@item -mn-flash=@var{num}
@opindex mn-flash
フラッシュメモリサイズが64@tie{}KiBの@var{num}倍と仮定する。

@item -mno-interrupts
@opindex mno-interrupts
ハードウェア割り込みと互換性のないコードを生成する。コードサイズが小さくなる。

@item -mrelax
@opindex mrelax
可能なら@code{CALL}、@code{JMP}命令をそれぞれより短い@code{RCALL}、@code{RJMP}命令で置き換えようとする。
@option{-mrelax}の設定は単にアセンブラのコマンド行に@option{mrelax}を加え、リンカのコマンド行に@option{--relax}オプションを加える。

ジャンプ・リラックスは、ジャンプオフセットがコードが配置される前には既知でないので、リンカによって実行される。したがって、アセンブラコードは、コンパイラは同じだが、実行可能ファイル内の命令は、アセンブラコードの命令とは異る。

リンカスタブが必要な場合は、リラクシングをオンにする必要があります。
以下の@code {EIND}セクションとリンカスタブのセクションを参照すること。

@item -mrmw
@opindex mrmw
デバイスが読み込み・修正・書き込み命令@code{XCH}、@code{LAC}、@code{LAS}、@code{LAT}をサポートしていると仮定する。

@item -mshort-calls
@opindex mshort-calls

Assume that @code{RJMP} and @code{RCALL} can target the whole
program memory.

This option is used internally for multilib selection.  It is
not an optimization option, and you don't need to set it by hand.

@item -msp8
@opindex msp8
スタックポインタレジスタと8ビットレジスタとして扱う。すなわち、スタックポインタの上位ビットを0と仮定する。一般的には、手でこのオプションを設定する必要はない。

このオプションは、コンパイラによって内部的に使用され、@code{avr2}と@code{avr25}アーキテクチャ用のマルチビルドを構築する。これらのアーキテクチャは、@code{SPH}の有無にかかわらずデバイスを混在させる。@option{-mmcu=avr2}または@option{-mmcu=avr25}以外の設定では、コンパイラはこのオプションをコンパイラ固有のコマンドラインから追加または削除する。これは、コンパイラがデバイスまたはアーキテクチャに8-bitスタックポインタを使用していて、@code{SPH}レジスタがあるかどうかを知っているためである。

@item -mstrict-X
@opindex mstrict-X
ハードウェアによって提案された方法でアドレスレジスタ@code{X}を使用する。 つまり、@code{X}は、間接、後置インクリメント、またはプリデクリメントのアドレッシングでのみ使用される。

このオプションがなければ、@code{X}レジスタは@code{Y}または@code{Z}と同じ方法で使用されるかもしれず、そのときは追加の命令によってエミュレートされる。たとえば、レジスタ@var{Rn}に負でない@code{const <64}という小さな負の@code{X + const}で値をロードすると、次のように実行される。

@example
adiw r26, const   ; X += const
ld   @var{Rn}, X        ; @var{Rn} = *X
sbiw r26, const   ; X -= const
@end example

@item -mtiny-stack
@opindex mtiny-stack
スタックポインタの下位8ビットのみ変更する。

@item -mfract-convert-truncate
@opindex mfract-convert-truncate
固定小数点型で、ゼロに丸める代わりに切り捨てを使用する。

@item -nodevicelib
@opindex nodevicelib
AVR-LibCのデバイス固有ライブラリ@code{lib <mcu> .a}にはリンクしない。

@item -Waddr-space-convert
@opindex Waddr-space-convert
結果のアドレススペースが受信アドレススペースに含まれていない場合のアドレススペース間の変換について警告する。

@item -Wmisspelled-isr
@opindex Wmisspelled-isr
ISRのスペルが間違っている場合、つまり__vectorプレフィックスがない場合に警告する。
デフォルトでは有効である。
@end table

@subsubsection @code{EIND}と128Kiバイト以上のフラッシュを持つデバイス
@cindex @code{EIND}
実装のポインタは16ビット幅である。関数またはラベルのアドレスはワードアドレスとして表されるので、間接ジャンプおよび呼び出しは64@tie{}Kiワードの範囲内の任意のコードアドレスを対象とすることができる。

128@tie{}Kiバイトを超えるプログラムメモリ空間を持つデバイスの間接ジャンプを容易にするために、@code{EICALL}及び@code{EIJMP}命令が使用されるときにターゲットアドレスの最も重要な部分として機能する@code{EIND}という特別な機能レジスタがある。

これらのデバイスでの間接ジャンプと呼び出しは、コンパイラによって次のように処理され、いくつかの制限がある。

@itemize @bullet

@item
コンパイラは決して@code{EIND}をセットしない。

@item
コンパイラは、@code{EICALL}/@code{EIJMP}で暗黙的に@code{EIND}を使うかもしれず、@code{RET}命令を使って間接的な呼び出し/ジャンプをエミュレートするために@code {EIND}を直接読むかもしれない。

@item
コンパイラは、起動コード中またはアプリケーション中に@code{EIND}が変更されないとみなす。 特に、@code{EIND}は、関数や割り込みサービスルーチンのプロローグ/エピローグでは保存/復元されない。

@item
関数間接呼び出しと計算されたgotoの場合、リンカは@emph{スタブ}を生成する。 スタブは時には@emph{トランポリン}と呼ばれるジャンプパッドである。 したがって、間接コール/ジャンプはそのようなスタブにジャンプする。
スタブには、目的のアドレスへの直接ジャンプが含まれている。

@item
すべての状況でリンカがスタブを正しく生成できるように、リンカの緩和をオンにする必要がある。 コンパイラオプション@option{-mrelax}とリンカオプション@option{--relax}を参照せよ。リンカがスタブを生成するが、緩和せずに役立つエラーメッセージが表示されずに終了する特殊な状況がある。

@item
デフォルトのリンカースクリプトは、@code{EIND = 0}のコード用に配置されている。コードが@code{EIND！= 0}で設定されている場合、カスタムリンカースクリプトを使用して、@code {.trampolines}で始まるセクションを@code{ EIND}が指し示す。

@item
libgccの起動コードは@code {EIND}を設定しない。起動コードは、libgccとAVR-LibCのコードの組み合わせであることに注意せよ。AVR-LibCが@code {EIND}に与える影響については、
@w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC user manual}}を見よ

@item
@code {.init3}セクションにある初期化コードなどを使用して、@code{EIND}を早期に設定することは、ユーザー固有のスタートアップコードにとって正当である。 このようなコードは、RAMを初期化してコンストラクタを呼び出す一般的な起動コードの前に実行されるが、AVR-LibCの起動コードのビットの後に、@code{EIND}をベクトルテーブルがあるセグメントに設定する
@example
#include <avr/io.h>

static void
__attribute__((section(".init3"),naked,used,no_instrument_function))
init3_set_eind (void)
@{
  __asm volatile ("ldi r24,pm_hh8(__trampolines_start)\n\t"
                  "out %i0,r24" :: "n" (&EIND) : "r24","memory");
@}
@end example

@noindent
@code{__trampolines_start}シンボルはリンカスクリプトで定義される。.

@item
次の2つの条件が満たされている場合、リンカーによって自動的にスタブが生成される。
@itemize @minus

@item ラベルのアドレスは、@code{gs}修飾子（@emph{generate stubs}の略語）によって次のように取得される。
@example
LDI r24, lo8(gs(@var{func}))
LDI r25, hi8(gs(@var{func}))
@end example
@item そのラベルの最終的な位置は、スタブがあるセグメントのコードセグメントの@emph{外側}にある。
@end itemize

@item
コンパイラは、以下のような場合にコードラベルのための@code{gs}修飾子を発行する：
@itemize @minus
@item 関数及びコードラベルのアドレスと取る
@item 計算goto
@item プロローグ保存の関数が使われたとき、@option{-mcall-prologues}コマンド行オプション参照
@item switch/case分岐テーブル。このような分岐テーブルを必要としない場合は、@option {-fno-jump-tables}コマンドラインオプションを指定することができる。
@item スタートアップ・シャットダウン中に呼ばれるCとC++では、のコンストラクタ・デストラクタ
@item もしツールが上で説明した@code{gs()}修飾子に当たったとき
@end itemize

@item
このような非シンボルアドレスへのジャンプはサポートされ@emph{ない}

@example
int main (void)
@{
    /* Call function at word address 0x2 */
    return ((int(*)(void)) 0x2)();
@}
@end example

代わりに、スタブをセットアップしなければならない。すなわち、関数はシンボル（例では@code{func_4}）
を通じて呼ばなくてはならない。

@example
int main (void)
@{
    extern int func_4 (void);

    /* Call function at byte address 0x4 */
    return func_4();
@}
@end example

アプリケーションは@option{-Wl,--defsym,func_4=0x4}でリンクされる。あるいは、リンカスクリプトで@code{func_4}を定義することもできる。
@end itemize

@subsubsection @code{RAMPD}, @code{RAMPX}, @code{RAMPY}, @code{RAMPZ}特別関数レジスタの扱い
@cindex @code{RAMPD}
@cindex @code{RAMPX}
@cindex @code{RAMPY}
@cindex @code{RAMPZ}
いくつかのAVRデバイスは、16ビットポインタでアクセスできる64@tie{}KiBの範囲を超えるメモリをサポートしている。 この64@tie{}KiB範囲外のメモリ位置にアクセスするには、@code{RAMP}レジスタの内容がアドレスの上位部分として使用される。@code{RAM}、@code{RAMPY}、@code{RAMPZ}特殊関数レジスタとそれぞれ連結され、@code{X}、@code{Y}、@code{Z}アドレスレジスタがそれぞれワイドアドレスを得るために@code{RAMPX}, @code{RAMPY}, @code{RAMPZ}特別関数レジスタと連結される。 同様に、@code{RAMPD}はダイレクトアドレッシングと一緒に使用される。

@itemize
@item
起動コードは、@code{RAMP}特殊関数レジスタをゼロで初期化する。

@item
@ref{AVR Named Address Spaces,名前付き関数空間}が汎用または@code{__ flash}の他に使用されると、操作の前に必要に応じて@code{RAMPZ}が設定される。

@item
デバイスが64@tie{}KiBより大きいRAMをサポートし、コンパイラが操作を実行するために@code{RAMPZ}を変更する必要がある場合、@code{RAMPZ}は操作後に0にリセットされる。

@item
デバイスに特定の@code{RAMP}レジスタが付いている場合、ISRプロローグ/エピローグはそのSFRを保存/復元し、ISRコードが（暗黙的に）使用する場合はゼロで初期化する。

@item
64 KiBを超えるRAMは、AVRターゲットのGCCではサポートされていない。インラインアセンブラを使用して16ビットのアドレス範囲外の場所から読み取り、@code{RAMP}レジスタの1つを変更する場合は、アクセス後に0にリセットする必要がある。

@end itemize

@subsubsection AVR組み込みマクロ

GCCは、ユーザーコードが機能の有無をテストできるように、いくつかのビルトインマクロを定義している。 次の組み込みマクロのほとんどは、デバイスの機能から導き出され、@option{-mmcu=}コマンドラインオプションによってトリガされる。

さらなるAVR固有のマクロは@ref{AVR Named Address Spaces}と@ref{AVR Built-in Functions}。

@table @code

@item __AVR_ARCH__
@option{-mmcu=@var{mcu}}オプションに依存する、アーキテクチャを識別する10進数に解決される組み込みマクロ。
可能な値は次のとおり。

@code{2}, @code{25}, @code{3}, @code{31}, @code{35},
@code{4}, @code{5}, @code{51}, @code{6}

はそれぞれ@var{mcu}=@code{avr2}, @code{avr25}, @code{avr3}, @code{avr31},
@code{avr35}, @code{avr4}, @code{avr5}, @code{avr51}, @code{avr6}であり、

@code{100}, @code{102}, @code{103}, @code{104},
@code{105}, @code{106}, @code{107}

はそれぞれ@var{mcu}=@code{avrtiny}, @code{avrxmega2}, @code{avrxmega3}, @code{avrxmega4},
@code{avrxmega5}, @code{avrxmega6}, @code{avrxmega7}である。
@var{mcu}がデバイスを指定する場合、この組み込みマクロはそれに応じて設定される。 たとえば、@option{-mmcu=atmega8}の場合、マクロは@code {4}に定義される。

@item __AVR_@var{Device}__
@option{-mmcu=@var{device}}を設定すると、この組み込みマクロが定義され、デバイスの名前が反映される。 たとえば、@option{-mmcu=atmega8}は組み込みマクロ@code{__ AVR_ATmega8__}を定義し、@option{-mmcu=attiny261a}は@code{__ AVR_ATtiny261A__}などを定義する。

組み込みマクロの名前は、@code{__ AVR_@var{Device}__}というスキームに従う。ここで、@var{Device}はAVRユーザーマニュアルのデバイス名である。 組み込みマクロの@var{Device}と@option{-mmcu=@var{device}}の@var{device}の違いは、後者は常に小文字であることである。

@var{device}がデバイスではなく、@samp{avr51}のようなコアアーキテクチャのみである場合、このマクロは定義されていない。

@item __AVR_DEVICE_NAME__
@option{-mmcu=@var{device}}を設定すると、この組み込みマクロがデバイス名に定義される。 たとえば、@option{-mmcu=atmega8}の場合、マクロは@code{atmega8}と定義される。

@var{device}がデバイスではなく、@samp {avr51}のようなコアアーキテクチャのみである場合、このマクロは定義されない。

@item __AVR_XMEGA__
デバイス/アーキテクチャは、XMEGAファミリのデバイスに属す。

@item __AVR_HAVE_ELPM__
デバイスには@code{ELPM}命令がある。

@item __AVR_HAVE_ELPMX__
デバイスには、@code{ELPM R @var{n}, Z}と@code{ELPM R @var{n},Z+}命令がある。

@item __AVR_HAVE_MOVW__
デバイスには、16ビットのレジスタレジスタの移動を実行するための@code{MOVW}命令がある。

@item __AVR_HAVE_LPMX__
デバイスには、@code{LPM R @var{n},Z}と@code {LPM R@var{n},Z+}命令がある。

@item __AVR_HAVE_MUL__
デバイスには、ハードウェア乗算器がある。

@item __AVR_HAVE_JMP_CALL__
デバイスには@code {JMP}と@code {CALL}命令がある。これは、プログラムメモリの少なくとも8KiBを持つデバイスの場合である。

@item __AVR_HAVE_EIJMP_EICALL__
@itemx __AVR_3_BYTE_PC__
デバイスには、@code{EIJMP}と@code{EICALL}命令がある。128@tie{}KiB以上のプログラムメモリを持つデバイスの場合であり、プログラムカウンタ（PC）が3バイト幅であることも意味する。

@item __AVR_2_BYTE_PC__
プログラムカウンタ（PC）は2バイト幅。 これは、最大128@tie{}KiBのプログラムメモリを持つデバイスの場合である。

@item __AVR_HAVE_8BIT_SP__
@itemx __AVR_HAVE_16BIT_SP__
スタックポインタ（SP）レジスタは、コンパイラによって8ビットおよび16ビットのレジスタとして扱われる。
これらのマクロの定義は@option {-mtiny-stack}の影響を受ける。

@item __AVR_HAVE_SPH__
@itemx __AVR_SP8__
デバイスは、SPH（スタックポインタの上位部分）特殊機能レジスタを持っているか、8ビットのスタックポインタを持っている。これらのマクロの定義は、@option{-mmcu=}と@option{-mmcu=avr2}と@option{-mmcu=avr25}の場合も@option{-msp8}の影響を受ける。

@item __AVR_HAVE_RAMPD__
@itemx __AVR_HAVE_RAMPX__
@itemx __AVR_HAVE_RAMPY__
@itemx __AVR_HAVE_RAMPZ__
デバイスには、それぞれ@code{RAMPD}、@code{RAMPX}、@code{RAMPY}、@code{RAMPZ}特殊関数レジスタがある。

@item __NO_INTERRUPTS__
このマクロは@option {-mno-interrupts}コマンドラインオプションを反映する。

@item __AVR_ERRATA_SKIP__
@itemx __AVR_ERRATA_SKIP_JMP_CALL__
一部のAVRデバイス（AT90S8515、ATmega103）は、ハードウェアエラッタのために32ビット命令をスキップしてはならない。 スキップ命令は@code{SBRS}、@code{SBRC}、@code{SBIS}、@code{SBIC}および@code{CPSE}である。
2番目のマクロは、@code{__ AVR_HAVE_JMP_CALL__}も設定されている場合にのみ定義される。

@item __AVR_ISA_RMW__
このデバイスには、リード・モディファイ・ライト命令（XCH、LAC、LAS、LAT）がある。

@item __AVR_SFR_OFFSET__=@var{offset}
@code{IN}、@code{OUT}、@code{SBI}などのようなI / O特殊機能レジスタに直接対処できる命令は、@code{LD}または@code{STS}のようなRAMにアクセスする命令によってアドレス指定された場合とは異なるアドレスを使用することがある。 このオフセットはデバイスのアーキテクチャに依存し、それぞれのI / Oアドレスを得るためにRAMアドレスから減算する必要がある。

@item __AVR_SHORT_CALLS__
The @option{-mshort-calls} command line option is set.

@item __AVR_PM_BASE_ADDRESS__=@var{addr}
Some devices support reading from flash memory by means of @code{LD*}
instructions.  The flash memory is seen in the data address space
at an offset of @code{__AVR_PM_BASE_ADDRESS__}.  If this macro
is not defined, this feature is not available.  If defined,
the address space is linear and there is no need to put
@code{.rodata} into RAM.  This is handled by the default linker
description file, and is currently available for
@code{avrtiny} and @code{avrxmega3}.  Even more convenient,
there is no need to use address spaces like @code{__flash} or
features like attribute @code{progmem} and @code{pgm_read_*}.

@item __WITH_AVRLIBC__
コンパイラは、AVR-Libcと一緒に使用するように構成されています。
@option { - with-avrlibc}設定オプションを参照せよ。

@end table

@node Blackfin Options
@subsection Blackfinオプション
@cindex Blackfin Options

@table @gcctabopt
@item -mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]}
@opindex mcpu=
ターゲットBlackfinプロセッサの名前を指定する。現在、@var{cpu}は
@samp{bf512}, @samp{bf514}, @samp{bf516}, @samp{bf518},
@samp{bf522}, @samp{bf523}, @samp{bf524}, @samp{bf525}, @samp{bf526},
@samp{bf527}, @samp{bf531}, @samp{bf532}, @samp{bf533},
@samp{bf534}, @samp{bf536}, @samp{bf537}, @samp{bf538}, @samp{bf539},
@samp{bf542}, @samp{bf544}, @samp{bf547}, @samp{bf548}, @samp{bf549},
@samp{bf542m}, @samp{bf544m}, @samp{bf547m}, @samp{bf548m}, @samp{bf549m},
@samp{bf561}, @samp{bf592}の一つにできる。

オプションの@var{sirevision}は、ターゲットのBlackfinプロセッサのシリコンリビジョンを指定する。 対象のシリコンリビジョンで使用可能な回避策がすべて有効になる。 @var{sirevision}が@samp{none}の場合、回避策は有効にならない。@var{sirevision}が@samp{any}の場合、ターゲットプロセッサのすべての回避策が有効になる。 @code{__ SILICON_REVISION__}マクロは、シリコンリビジョンのメジャー番号とマイナー番号を表す2桁の16進数で定義されている。 @var{sirevision}が@samp{none}の場合、@code{__ SILICON_REVISION__}は定義されない。 @var{sirevision}が@samp{any}の場合、@code{__ SILICON_REVISION__}は@code {0xffff}と定義されている。 このオプションの@var{sirevision}を使用しない場合、GCCは対象となるBlackfinプロセッサの最新のシリコンリビジョンを想定する。

GCCは、指定された@var{cpu}のプリプロセッサマクロを定義する。@samp{bfin-elf}ツールチェーンの場合、このオプションを指定すると、@option{-msim}が指定されていない場合、libglossによって提供されるハードウェアBSPがリンクされる。

このオプションがなければ、@samp{bf532}がプロセッサーとしてデフォルトで使用される。

@samp{bf561}のサポートは不完全であることに注意する。 @samp{bf561}の場合、プリプロセッサマクロのみが定義されている。

@item -msim
@opindex msim
プログラムをシミュレータ上で実行することを指定する。 これにより、libglossが提供するシミュレータBSPがリンクされる。このオプションは@samp{bfin-elf} toolchainにのみ有効である。 @option{-mid-shared-library}や@option{-mfdpic}などの特定のオプションは、@option{-msim}を意味する。

@item -momit-leaf-frame-pointer
@opindex momit-leaf-frame-pointer
リーフ時間数用のレジスタにフレームポインタを保持しない。 これにより、命令がフレームポインタのセーブ、セットアップ、および復元を回避し、リーフ関数で余分なレジスタを利用できるようになる。

@item -mspecld-anomaly
@opindex mspecld-anomaly
有効にすると、コンパイラは、ジャンプ命令の後に生成されたコードに投機的なロードが含まれないようにする。 このオプションを使用すると、@code{__ WORKAROUND_SPECULATIVE_LOADS}が定義される。

@item -mno-specld-anomaly
@opindex mno-specld-anomaly
投機的なロードが発生しないようにするための特別なコードを生成しない。

@item -mcsync-anomaly
@opindex mcsync-anomaly
有効にすると、コンパイラは、生成されたコードに条件分岐後すぐにCSYNCまたはSSYNC命令が含まれないようにする。このオプションを使用すると、@code{__ WORKAROUND_SPECULATIVE_SYNCS}が定義される。

@item -mno-csync-anomaly
@opindex mno-csync-anomaly
条件分岐後にCSYNCまたはSSYNC命令があまりに早く発生するのを防ぐための余分なコードを生成しない。

@item -mlow-64k
@opindex mlow-64k
有効にすると、コンパイラは、プログラム全体が低メモリ64kに収まるという知識を自由に利用できる。

@item -mno-low-64k
@opindex mno-low-64k
プログラムが任意に大きいと仮定する。 これがデフォルトである。

@item -mstack-check-l1
@opindex mstack-check-l1
uClinuxカーネルによってL1スクラッチパッドメモリに配置された情報を使用してスタックチェックを実行する。

@item -mid-shared-library
@opindex mid-shared-library
ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成する。
これにより、仮想メモリ管理のない環境で、直接実行や共有ライブラリを実行することができる。 このオプションは@option{-fPIC}を意味する。 @samp{bfin-elf}ターゲットの場合、このオプションは@option{-msim}を意味する。

@item -mno-id-shared-library
@opindex mno-id-shared-library
IDベースの共有ライブラリが使用されていることを前提としないコードを生成する。これがデフォルトである。

@item -mleaf-id-shared-library
@opindex mleaf-id-shared-library
ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成し、このライブラリまたは実行可能ファイルは他のID共有ライブラリとリンクしていないものと想定する。 これにより、コンパイラはジャンプと呼び出しのためのより高速なコードを使用できる。

@item -mno-leaf-id-shared-library
@opindex mno-leaf-id-shared-library
コンパイル中のコードがID共有ライブラリとリンクしないと仮定しない。 jumpおよびcall 命令のコードがより遅く生成される。

@item -mshared-library-id=n
@opindex mshared-library-id
コンパイルされるIDベースの共有ライブラリの識別番号を指定する。 0の値を指定すると、よりコンパクトなコードが生成される。 他の値を指定すると、その番号を現在のライブラリに強制的に割り当てることができるが、このオプションを省略するよりもスペースや時間効率が向上しない。

@item -msep-data
@opindex msep-data
データセグメントをテキストセグメントとは異なるメモリ領域に配置できるようにするコードを生成する。 これにより、テキストセクションに対する再配置を排除することにより、仮想メモリ管理のない環境での実行が可能になる。

@item -mno-sep-data
@opindex mno-sep-data
データセグメントがテキストセグメントに続くことを前提とするコードを生成する。これがデフォルトです。

@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
関数のアドレスをレジスタにロードし、次にこのレジスタでサブルーチン呼び出しを実行することによって、関数呼び出しを実行するようにコンパイラに指示する。 このスイッチは、ターゲット関数がサブルーチン呼び出し命令のオフセットベースバージョンの24ビットアドレッシング範囲外にある場合に必要である。

この機能はデフォルトでは有効になっていない。 @option{-mno-long-calls}を指定すると、デフォルト動作が復元される。 これらのスイッチは、コンパイラが関数ポインタを介して関数呼び出しを処理するコードを生成する方法には影響しないことに注意すること。

@item -mfast-fp
@opindex mfast-fp
高速浮動小数点ライブラリにリンクする。 このライブラリは、パフォーマンスの観点から、非数値（NAN）に対して入力をチェックするIEEE浮動小数点標準の規則のいくつかを緩和する。

@item -minline-plt
@opindex minline-plt
ローカルにバインドされていない関数に対する関数呼び出しのPLTエントリのインライン化を有効にする。 @option{-mfdpic}なしでは効果はない。

@item -mmulticore
@opindex mmulticore
マルチコアBlackfinプロセッサ用のスタンドアロンアプリケーションを構築する。このオプションを使用すると、適切な起動ファイルと、マルチコアをサポートするリンクスクリプトが使用され、マクロ@code {__ BFIN_MULTICORE}が定義される。これは@option{-mcpu=bf561@r{[}-@var{sirevision}@r{]}}でのみ使用できる。

このオプションは、@option{-mcorea}または@option{-mcoreb}とともに使用できる。このオプションは、1アプリケーション/コアのプログラミングモデルを選択する。 @option{-mcorea}または@option{-mcoreb}を使用しない場合は、シングルアプリケーション/デュアルコアプログラミングモデルが使用される。 このモデルでは、コアBの主な機能は@code{coreb_main}と命名されるべきである。

このオプションを使用しない場合は、シングルコアアプリケーションプログラミングモデルが使用される。

@item -mcorea
@opindex mcorea
1アプリケーション/コアプログラミングモデルを使用する場合、BF561のコアA用のスタンドアローンアプリケーションを構築する。 適切な開始ファイルとリンクスクリプトは、コアAをサポートするために使用され、マクロ@code{__ BFIN_COREA}が定義される。このオプションは@option{-mmulticore}と組み合わせてのみ使用できる。

@item -mcoreb
@opindex mcoreb
1アプリケーション/コアプログラミングモデルを使用する場合は、BF561のコアB用のスタンドアロンアプリケーションを作成する。 適切な開始ファイルとリンクスクリプトは、コアBをサポートするために使用され、マクロ@code{__ BFIN_COREB}が定義される。 このオプションを使用するときは、@code{main}の代わりに@code{coreb_main}を使用する必要がある。このオプションは@option {-mmulticore}と組み合わせてのみ使用できる。

@item -msdram
@opindex msdram
SDRAM用のスタンドアロンアプリケーションを構築する。 適切な開始ファイルとリンクスクリプトを使用してアプリケーションをSDRAMに入れ、マクロ@code{__ BFIN_SDRAM}を定義する。ローダーはアプリケーションをロードする前にSDRAMを初期化する必要がある。

@item -micplb
@opindex micplb
実行時にICPLBが有効になっていると仮定する。 これは、特定の異常回避策に影響する。 Linuxターゲットの場合、デフォルトはICPLBが有効であると仮定する。 スタンドアロンアプリケーションの場合、デフォルトはオフである。
@end table

@node C6X Options
@subsection C6Xオプション
@cindex C6X Options

@table @gcctabopt
@item -march=@var{name}
@opindex march
これは、ターゲットアーキテクチャの名前を指定する。 GCCはこの名前を使用して、アセンブリコードを生成するときにどのような命令を発行できるかを判断する。 許可される名前は @samp{c62x},
@samp{c64x}, @samp{c64x+}, @samp{c67x}, @samp{c67x+}, @samp{c674x}である。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンターゲット用のコードを生成する。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンターゲット用のコードを生成する。これはデフォルトである。

@item -msim
@opindex msim
シミュレータに適した起動ファイルとリンカスクリプトを選択する。

@item -msdata=default
@opindex msdata=default
@code{.neardata}セクションに小規模のグローバルデータと静的データを配置する。これはレジスタ@code{B14}によって指し示される。 小さな初期化されていないグローバルデータと静的データを@code{.bss}セクションに置く。これは@code{.neardata}セクションに隣接している。 読み込み専用の小さなデータを@code{.rodata}セクションに置く。 大量のデータに使用される対応するセクションは、@code{.fardata}、@code{.far}、@code{.const}である。

@item -msdata=all
@opindex msdata=all
小規模なデータ用に予約されたセクションには、小さなオブジェクトだけでなく、すべてのデータを格納し、アクセスするために@code{B14}レジスタを基準にしたアドレス指定を使用する。

@item -msdata=none
@opindex msdata=none
小さなデータ用に予約されたセクションを使用せず、絶対アドレスを使用してすべてのデータにアクセスする。 すべての初期化されたグローバルおよび静的データを@code{.fardata}セクションに入れ、すべての初期化されていないデータを@code{.far}セクションに置く。 すべての定数データを@code{.const}セクションに入れる。

@end table

@node CRIS Options
@subsection CRISオプション
@cindex CRIS Options

これらのオプションは、CRISポート専用に定義されている。

@table @gcctabopt
@item -march=@var{architecture-type}
@itemx -mcpu=@var{architecture-type}
@opindex march
@opindex mcpu
指定されたアーキテクチャのコードを生成する。 @var{architecture-type}の選択肢は、@samp{v3}、@samp{v8}、@samp{v10}である。それぞれ、ETRAX@w{ }4、ETRAX@w{ }100、およびETRAX@w{ }100@w{ }LXである。
デフォルトはcris-axis-linux-gnuを除き、@samp{v0}であり、その場合は@samp{v10}である。

@item -mtune=@var{architecture-type}
@opindex mtune
ABIと使用可能な命令のセットを除いて、@var{architecture-type}に合わせて生成されたコードに関するすべてのものを調整する。 @var{architecture-type}の選択肢は、@option{-march=@var{architecture-type}}と同じである。

@item -mmax-stack-frame=@var{n}
@opindex mmax-stack-frame
関数のスタックフレームが@var{n}バイトを超えたときに警告する。

@item -metrax4
@itemx -metrax100
@opindex metrax4
@opindex metrax100
オプション@option {-metrax4}と@option{-metrax100}は、それぞれ@option{-march = v3}と@option{-march = v8}の同義語である。

@item -mmul-bug-workaround
@itemx -mno-mul-bug-workaround
@opindex mmul-bug-workaround
@opindex mno-mul-bug-workaround
それが適用されるCPUモデルの@code{muls}と@code{mulu}命令のバグを回避する。 このオプションは、デフォルトで有効である。

@item -mpdebug
@opindex mpdebug
CRIS固有の詳細なデバッグ関連情報をアセンブリコードで有効にする。 このオプションは、@samp{#NO_APP}フォーマットコードインジケータをアセンブラファイルの先頭でアセンブラに表示しないようにする効果もある。

@item -mcc-init
@opindex mcc-init
前の命令の条件コード結果を使用しない。 条件コードを使用する前に、常に比較とテストの命令を出す。

@item -mno-side-effects
@opindex mno-side-effects
ポストインクリメント以外のアドレッシングモードで副作用のある命令を生成しない。

@item -mstack-align
@itemx -mno-stack-align
@itemx -mdata-align
@itemx -mno-data-align
@itemx -mconst-align
@itemx -mno-const-align
@opindex mstack-align
@opindex mno-stack-align
@opindex mdata-align
@opindex mno-data-align
@opindex mconst-align
@opindex mno-const-align
これらのオプション（@samp{no-}オプション）は、選択したCPUモデルの最大単一データアクセスサイズに合わせて、スタックフレーム、個々のデータと定数を整列（配置を取り除く）する。 デフォルトでは、32ビットのアライメントを調整する。 構造レイアウトなどのABIの詳細は、これらのオプションの影響を受けない。

@item -m32-bit
@itemx -m16-bit
@itemx -m8-bit
@opindex m32-bit
@opindex m16-bit
@opindex m8-bit
上記のstack-data-およびconst-alignオプションと同様に、これらのオプションは、スタックフレーム、書き込み可能なデータおよび定数をすべて32ビット、16ビットまたは8ビットに整列させるように配置する。 デフォルトは32ビット境界である。

@item -mno-prologue-epilogue
@itemx -mprologue-epilogue
@opindex mno-prologue-epilogue
@opindex mprologue-epilogue
@option{-mno-prologue-epilogue}では、スタックフレームを設定する通常の関数プロローグとエピローグは省略され、戻り命令や戻りシーケンスはコード内に生成されない。 このオプションは、コンパイルされたコードの目視検査と一緒にのみ使用すること。コールセーブされたレジスタを保存する必要がある場合、またはローカル変数の格納領域を割り当てる必要がある場合は、警告もエラーも生成されない。

@item -mno-gotplt
@itemx -mgotplt
@opindex mno-gotplt
@opindex mgotplt
@option{-fpic}と@option{-fPIC}と一緒に使用すると、PLTへの（他のアーキテクチャでは従来の）呼び出しではなく、GOTのPLT部分から関数のアドレスをロードする命令シーケンスを生成しない（する）。 デフォルトは@option{-mgotplt}である。

@item -melf
@opindex melf
cris-axis-elfおよびcris-axis-linux-gnuターゲットでのみ認識される旧式の何もしないオプション。

@item -mlinux
@opindex mlinux
cris-axis-linux-gnuターゲットでのみ認識される旧式の何もしないオプション。

@item -sim
@opindex sim
このオプションは、cris-axis-elf用にのみ認識され、シミュレータ・ライブラリからの入出力関数とリンクする。 コード、初期化データ、ゼロ初期化データは連続して割り当てられる。

@item -sim2
@opindex sim2
@option{-sim}と似ているが、初期化されたデータを0x40000000に配置し、ゼロ初期化データを0x80000000に配置すいるようにリンカオプションを渡す。

@end table

@node CR16 Options
@subsection CR16オプション
@cindex CR16 Options

これらのオプションは、CR16ポート専用に定義されている。

@table @gcctabopt

@item -mmac
@opindex mmac
乗算累算命令の使用を有効にする。 デフォルトでは無効である。

@item -mcr16cplus
@itemx -mcr16c
@opindex mcr16cplus
@opindex mcr16c
CR16CまたはCR16C +アーキテクチャ用のコードを生成する。 CR16C+アーキテクチャはデフォルトである。

@item -msim
@opindex msim
シミュレータと互換性のあるライブラリlibsim.aをリンクする。 ELFコンパイラにのみ適用される。

@item -mint32
@opindex mint32
整数型に32ビット長を選ぶ。

@item -mbit-ops
@opindex mbit-ops
ビット操作に@code{sbit}/@code{cbit}命令を生成する。

@item -mdata-model=@var{model}
@opindex mdata-model
データモデルを選択する。 @var{model}の選択肢は@samp{near}、@samp{far}または@samp{medium}である。 @samp{medium}はデフォルトである。ただし、@samp{far}は@option{-mcr16c}では有効ではない。これは、CR16Cアーキテクチャがfarデータモデルをサポートしていないためである。
@end table

@node Darwin Options
@subsection Darwinオプション
@cindex Darwin options

これらのオプションは、Darwinオペレーティングシステムを実行しているすべてのアーキテクチャで定義されています。

DarwinのFSF GCCは、「fat」オブジェクトファイルを作成しない。 GCCがターゲットとする構築された単一アーキテクチャ用のオブジェクトファイルを作成する。 AppleのGCCは、複数の@option{-arch}オプションが使用されている場合、 「fat」ファイルを作成する。 コンパイラーやリンカーを複数回実行し、結果を@file{lipo}と一緒に結合することでそうする。

（@samp{ppc7400}や@samp{ppc970}や@samp{i686}のような）作成されるファイルのサブタイプは、GCCがターゲットとするISAを指定するフラグ@option{-mcpu}や@option{-march}で決定される。これを無効にするには、 @option{-force_cpusubtype_ALL}オプションを使用できる。

Darwinのツールは、ISAの不一致がある場合の動作が異なる。 アセンブラ@file{as}は、生成しているファイルのサブタイプに有効な命令のみを使用できるため、64ビット命令を@samp{ppc750}オブジェクトファイルに入れることはできない。 共有ライブラリのリンカー@file{/usr/bin/libtool}は、入力ファイルよりも制限の少ないサブタイプで共有ライブラリを作成するように要求された場合に失敗し、エラーを表示する。（例えば、@samp{ppc970}オブジェクトファイルを@samp{ppc7400}ライブラリに置こうとすると）。実行可能ファイルのリンカー@command {ld}は、実行可能ファイルに入力ファイルの中で最も制限的なサブタイプを静かに提供する。

@table @gcctabopt
@item -F@var{dir}
@opindex F
フレームワークディレクトリ@var{dir}をリストの先頭に追加するヘッダファイルを検索するディレクトリ。これらのディレクトリは@option{-I}オプションで指定されたものに差し挟まれ、左から右の順序でスキャンされる。

フレームワークディレクトリは、フレームワークを持つディレクトリである。フレームワークとは、@file{.framework}で終わる@file{Headers}や@file{PrivateHeaders}ディレクトリが直接入っているディレクトリである。フレームワークの名前は、@file{.framework}を除いたこのディレクトリの名前である。フレームワークに関連付けられたヘッダーは、@file{Headers}が最初に検索される2つのディレクトリのうちの1つにある。サブフレームワークは、フレームワークの@file{Frameworks}ディレクトリにあるフレームワークディレクトリである。サブフレームワークヘッダーのインクルードは、サブフレームワークを含むフレームワークのヘッダーにのみ、または兄弟サブフレームヘッダーにのみ表示できる。 2つのサブフレームワークは、同じフレームワーク内に存在する場合、兄弟である。サブフレームワークはフレームワークと同じ名前であってはならない。これに違反すると警告が出る。現在、サブフレームワークはサブフレームワークを持つことができない。将来、このメカニズムを拡張することができるだろう。標準のフレームワークは@file{/System/Library/Frameworks}と@file{/Library/Frameworks}にある。例のincludeは@code{#include<Framework/header.h>}のように見え、@file{Framework}はフレームワークの名前を表し、@file{header.h}は@file{PrivateHeaders}や@file{Headers}ディレクトリを表す。

@item -iframework@var{dir}
@opindex iframework
@option {-F}と似ているが、ディレクトリはシステムディレクトリとして扱われる。 この@option{-iframework}と@option{-F}の主な違いは、@option{-iframework}の場合、コンパイラは@var{dir}を介して見つかるヘッダファイルに含まれている構文について警告しないということである。 このオプションはC言語族の言語でのみ有効である。

@item -gused
@opindex gused
使用されているシンボルのデバッグ情報を出力する。 stabsデバッグ形式では、これは@option{-feliminate-unused-debug-symbols}を有効にする。これは、デフォルトでONになっている。

@item -gfull
@opindex gfull
すべてのシンボルとタイプのデバッグ情報を出力する。

@item -mmacosx-version-min=@var{version}
この実行可能ファイルが実行されるMacOS Xの最も古いバージョンは@var{version}である。 @var {version}の典型的な値は@code{10.1}、@code{10.2}、@code{10.3.9}である。

コンパイラがデフォルトでシステムのヘッダーを使用するように構築されている場合、このオプションのデフォルトはコンパイラが実行されているシステムのバージョンである。それ以外の場合、デフォルトはできるだけ多くのシステムおよびコードベースと互換性がある。

@item -mkernel
@opindex mkernel
カーネル開発モードを有効にする。 @option{-mkernel}は@option{-static}, @option{-fno-common}, @option{-fno-use-cxa-atexit},
@option{-fno-exceptions}, @option{-fno-non-call-exceptions},
@option{-fapple-kext}, @option{-fno-weak}, @option{-fno-rtti}を適用可能な場所で有効にする。
このモードはさらにPowerPCターゲットでは@option{-mno-altivec},
@option{-msoft-float}, @option{-fno-builtin}と
@option{-mlong-branch}を有効にする。

@item -mone-byte-bool
@opindex mone-byte-bool
@code{sizeofbool）= 1}のように、@code {bool}のデフォルトを上書きする。デフォルトでは、Darwin/PowerPC用にコンパイルするときは@code{sizeofbool}は@code{4}、Darwin/x86用にコンパイルするときは@code{1}なので、このオプションはx86には影響しない。

@strong{警告:} @option{--one-byte-bool}スイッチは、GCCに、そのスイッチなしで生成されたコードとバイナリ互換性のないコードを生成させる。 このスイッチを使用するには、システムライブラリを含むプログラム内の他のすべてのモジュールを再コンパイルする必要がある。 このスイッチを使用して、デフォルト以外のデータモデルに準拠させる。

@item -mfix-and-continue
@itemx -ffix-and-continue
@itemx -findirect-data
@opindex mfix-and-continue
@opindex ffix-and-continue
@opindex findirect-data
GDBが既に実行中のプログラムに@file{.o}ファイルを動的にロードできるように、高速ターンアラウンド開発に適したコードを生成する。 下位互換性のために@option{-findirect-data}と@option {-ffix-and-continue}が提供されている。

@item -all_load
@opindex all_load
静的アーカイブライブラリのすべてのメンバーを読み込む。詳細は、man ld（1）を参照せよ。
Loads all members of static archive libraries.
See man ld(1) for more information.

@item -arch_errors_fatal
@opindex arch_errors_fatal
誤ったアーキテクチャを持つファイルと関係しているエラーは致命的なものにする。

@item -bind_at_load
@opindex bind_at_load
ファイルがロードまたは起動されたときに、ダイナミックリンカが定義されていないすべての参照をバインドするように、出力ファイルにマークを付ける。

@item -bundle
@opindex bundle
Mach-oバンドル形式ファイルを作成する。詳細は、man ld（1）を参照せよ。

@item -bundle_loader @var{executable}
@opindex bundle_loader
このオプションはリンクされているビルド出力ファイルをロードする@var{executable}を指定する。 詳細は、man ld（1）を参照せよ。

@item -dynamiclib
@opindex dynamiclib
このオプションを渡すと、GCCはDarwinの@file{libtool}コマンドを使用して、リンク時に実行可能ファイルではなく動的ライブラリを生成する。

@item -force_cpusubtype_ALL
@opindex force_cpusubtype_ALL
これにより、GCCの出力ファイルは、@option {-mcpu}または@option{-march}オプションで制御されるものではなく、@samp{ALL}サブタイプになります。

@item -allowable_client  @var{client_name}
@itemx -client_name
@itemx -compatibility_version
@itemx -current_version
@itemx -dead_strip
@itemx -dependency-file
@itemx -dylib_file
@itemx -dylinker_install_name
@itemx -dynamic
@itemx -exported_symbols_list
@itemx -filelist
@need 800
@itemx -flat_namespace
@itemx -force_flat_namespace
@itemx -headerpad_max_install_names
@itemx -image_base
@itemx -init
@itemx -install_name
@itemx -keep_private_externs
@itemx -multi_module
@itemx -multiply_defined
@itemx -multiply_defined_unused
@need 800
@itemx -noall_load
@itemx -no_dead_strip_inits_and_terms
@itemx -nofixprebinding
@itemx -nomultidefs
@itemx -noprebind
@itemx -noseglinkedit
@itemx -pagezero_size
@itemx -prebind
@itemx -prebind_all_twolevel_modules
@itemx -private_bundle
@need 800
@itemx -read_only_relocs
@itemx -sectalign
@itemx -sectobjectsymbols
@itemx -whyload
@itemx -seg1addr
@itemx -sectcreate
@itemx -sectobjectsymbols
@itemx -sectorder
@itemx -segaddr
@itemx -segs_read_only_addr
@need 800
@itemx -segs_read_write_addr
@itemx -seg_addr_table
@itemx -seg_addr_table_filename
@itemx -seglinkedit
@itemx -segprot
@itemx -segs_read_only_addr
@itemx -segs_read_write_addr
@itemx -single_module
@itemx -static
@itemx -sub_library
@need 800
@itemx -sub_umbrella
@itemx -twolevel_namespace
@itemx -umbrella
@itemx -undefined
@itemx -unexported_symbols_list
@itemx -weak_reference_mismatches
@itemx -whatsloaded
@opindex allowable_client
@opindex client_name
@opindex compatibility_version
@opindex current_version
@opindex dead_strip
@opindex dependency-file
@opindex dylib_file
@opindex dylinker_install_name
@opindex dynamic
@opindex exported_symbols_list
@opindex filelist
@opindex flat_namespace
@opindex force_flat_namespace
@opindex headerpad_max_install_names
@opindex image_base
@opindex init
@opindex install_name
@opindex keep_private_externs
@opindex multi_module
@opindex multiply_defined
@opindex multiply_defined_unused
@opindex noall_load
@opindex no_dead_strip_inits_and_terms
@opindex nofixprebinding
@opindex nomultidefs
@opindex noprebind
@opindex noseglinkedit
@opindex pagezero_size
@opindex prebind
@opindex prebind_all_twolevel_modules
@opindex private_bundle
@opindex read_only_relocs
@opindex sectalign
@opindex sectobjectsymbols
@opindex whyload
@opindex seg1addr
@opindex sectcreate
@opindex sectobjectsymbols
@opindex sectorder
@opindex segaddr
@opindex segs_read_only_addr
@opindex segs_read_write_addr
@opindex seg_addr_table
@opindex seg_addr_table_filename
@opindex seglinkedit
@opindex segprot
@opindex segs_read_only_addr
@opindex segs_read_write_addr
@opindex single_module
@opindex static
@opindex sub_library
@opindex sub_umbrella
@opindex twolevel_namespace
@opindex umbrella
@opindex undefined
@opindex unexported_symbols_list
@opindex weak_reference_mismatches
@opindex whatsloaded
これらのオプションはDarwinリンカーに渡される。 Darwinのリンカのmanページに詳細が記述されている。
@end table

@node DEC Alpha Options
@subsection DEC Alpha オプション

これらの@samp {-m}オプションは、DEC Alphaの実装で定義されている。

@table @gcctabopt
@item -mno-soft-float
@itemx -msoft-float
@opindex mno-soft-float
@opindex msoft-float
浮動小数点演算には、ハードウェア浮動小数点命令を使用する（しない）。 @option{-msoft-float}を指定すると、@file{libgcc.a}の関数が浮動小数点演算の実行に使用される。 浮動小数点演算をエミュレートするルーチンに置き換えられたり、エミュレーションルーチンを呼び出すようにコンパイルされたりしない限り、これらのルーチンは浮動小数点演算を発行する。 浮動小数点演算を使用せずにAlpha用にコンパイルする場合は、ライブラリが呼び出されないようにビルドされていることを確認する必要がある。

浮動小数点演算を使用しないAlphaの実装では、浮動小数点レジスタが必要であることに注意。

@item -mfp-reg
@itemx -mno-fp-regs
@opindex mfp-reg
@opindex mno-fp-regs
浮動小数点レジスタセットを使用する（しない）コードを生成する。 @option{-mno-fp-regs}は、@option{-msoft-float}を含む。 浮動小数点レジスタセットが使用されていない場合、浮動小数点オペランドは整数であるかのように整数レジスタに渡され、浮動小数点の結果は@code{$f0}の代わりに@code{$0}に渡される。 これは非標準呼び出しシーケンスなので、@option{-mno-fp-regs}でコンパイルされたコードで呼び出される浮動小数点引数または戻り値を持つ関数も、そのオプションでコンパイルする必要がある。

このオプションの典型的な使用方法は、浮動小数点レジスタを使用しないため、浮動小数点レジスタを保存および復元する必要がないカーネルを構築することである。

@item -mieee
@opindex mieee
Alphaアーキテクチャは、パフォーマンスを最大限に高めるように最適化された浮動小数点ハードウェアを実装する。 これは、ほとんどIEEE浮動小数点標準に準拠している。 ただし、完全な準拠のためには、ソフトウェアの補助が必要である。 このオプションは、@var{inexact-flag}が維持されていないことを@emph{除いては}完全にIEEE準拠のコードを生成する（下記参照）。 このオプションをオンにすると、プリプロセッサマクロ@code{_IEEE_FP}がコンパイル時に定義される。 結果として生成されるコードの効率は低下するが、正規化されていない数値や、非数やプラスマイナスの無限大などの例外的なIEEE値を正しくサポートすることができる。 他のAlphaコンパイラはこのオプションを@option{-ieee_with_no_inexact}と呼んでいる。

@item -mieee-with-inexact
@opindex mieee-with-inexact
これは@option{-mieee}と似ているが、生成されたコードはIEEE@var{inexact-flag}も維持される。 このオプションをオンにすると、生成されたコードは完全準拠のIEEE演算を実装する。 @code{_IEEE_FP}に加えて、@code{_IEEE_FP_EXACT}はプリプロセッサマクロとして定義される。 一部のAlpha実装では、生成されるコードはデフォルトで生成されるコードよりも大幅に遅く実行されることがある。 @var{inexact-flag}に依存するコードはごくわずかなので、通常はこのオプションを指定するべきではない。 他のAlphaコンパイラはこのオプションを@option{-ieee_with_inexact}と呼んでいる。

@item -mfp-trap-mode=@var{trap-mode}
@opindex mfp-trap-mode
このオプションは、浮動小数点関連のトラップを有効にするかどうかを制御する。他のAlphaコンパイラはこのオプションを@option{-fptm @var{trap-mode}}と呼んでいる。トラップモードは、次の4つの値のいずれかに設定できる。

@table @samp
@item n
これがデフォルト（通常）の設定である。 有効にされる唯一のトラップは、ソフトウェアで無効にすることができないトラップ（例えば、ゼロトラップによる除算）である。

@item u
@samp{n}によって有効にされたトラップに加えて、アンダーフロートラップも有効である。

@item su
@samp{u}と似ているが、ソフトウェアの完了時に命令が安全であるとマークされる。（詳細はAlphaアーキテクチャのマニュアルを参照）。

@item sui
@samp {su}と似ていますが、不正確なトラップも有効である。
@end table

@item -mfp-rounding-mode=@var{rounding-mode}
@opindex mfp-rounding-mode
IEEE丸めモードを選択する。 他のAlphaコンパイラはこのオプションを@option{-form @var{rounding-mode}}と呼んでいる。 @var{rounding-mode}は次のいずれかである：

@table @samp
@item n
通常のIEEE丸めモード。 浮動小数点数は、最も近いマシン番号に向かって丸められ、または同数の場合は均等なマシン番号に丸めらる。

@item m
負の無限大に向かって丸められる。

@item c
切り捨て丸めモード。浮動小数点は0に向かって丸められる。

@item d
動的丸めモード。 浮動小数点制御レジスタのフィールド（@var{fpcr}、Alphaアーキテクチャのリファレンスマニュアルを参照）は、有効な丸めモードを制御する。 Cライブラリは正の無限大に丸められるようにこのレジスタを初期化する。 したがって、プログラムが@var{fpcr}を変更しない限り、@samp{d}は+無限大に丸める。
@end table

@item -mtrap-precision=@var{trap-precision}
@opindex mtrap-precision
Alphaアーキテクチャでは、浮動小数点トラップは不正確である。 これは、ソフトウェアの支援なしでは、浮動小数点トラップから回復することは不可能であり、プログラムの実行は通常終了する必要があることを意味する。 GCCは、オペレーティングシステムのトラップハンドラが浮動小数点トラップの原因となった正確な位置を特定する際に役立つコードを生成することができる。 アプリケーションの要件に応じて、さまざまなレベルの精度を選択できます。
@table @samp
@item p
プログラム精度。 このオプションはデフォルトであり、トラップハンドラが浮動小数点例外を発生させたプログラムのみを識別できることを意味する。

@item f
関数精度。 トラップハンドラは、浮動小数点例外の原因となった関数を判別できる。

@item i
命令精度。 トラップハンドラは、浮動小数点例外の原因となった正確な命令を判別できる。
@end table

他のAlphaコンパイラには、@option{-scope_safe}と@option{-resumption_safe}という同等のオプションがある。

@item -mieee-conformant
@opindex mieee-conformant
このオプションは、生成されたコードをIEEE準拠としてマークする。 @option{-mtrap-precision=i}と@option{-mfp-trap-mode=su}または@option{-mfp-trap-mode=sui}を指定しない限り、このオプションを使用してはならない。 その唯一の効果は、生成されたアセンブリファイルの関数プロローグで@samp{.eflag 48}という行を出力することである。

@item -mbuild-constants
@opindex mbuild-constants
通常、GCCは32ビットまたは64ビット整数定数を調べて、2つまたは3つの命令で小さな定数から構造体を構築できるかどうかを調べる。 できない場合は定数をリテラルとして出力し、実行時にデータセグメントからロードするコードを生成する。

このオプションを使用すると、たとえより多くの命令を使ったとしても（最大で6）GCCが@emph{すべての}整数定数をコードを使って構築するように要求する。

通常、このオプションを使用して共有ライブラリの動的ローダを構築する。 共有ライブラリそのものでは、変数と定数を自分のデータセグメントで見つける前に、メモリ内で自身を再配置する必要がある。

@item -mbwx
@itemx -mno-bwx
@itemx -mcix
@itemx -mno-cix
@itemx -mfix
@itemx -mno-fix
@itemx -mmax
@itemx -mno-max
@opindex mbwx
@opindex mno-bwx
@opindex mcix
@opindex mno-cix
@opindex mfix
@opindex mno-fix
@opindex mmax
@opindex mno-max
GCCがオプションのBWX、CIX、FIX、およびMAX命令セットを使用するコードを生成する必要があるかどうかを示す。 デフォルトでは、@option{-mcpu=}オプションで指定されたCPUタイプでサポートされている命令セット、または何も指定されていない場合はGCCが構築されたCPUのものが使用される。

@item -mfloat-vax
@itemx -mfloat-ieee
@opindex mfloat-vax
@opindex mfloat-ieee
IEEE単精度および倍精度の代わりにVAX FおよびG浮動小数点演算を使用する（しない）コードを生成する。

@item -mexplicit-relocs
@itemx -mno-explicit-relocs
@opindex mexplicit-relocs
@opindex mno-explicit-relocs
以前のAlphaアセンブラは、アセンブラマクロ以外ではシンボルの再配置を生成できなかった。 これらのマクロを使用しても、最適な命令スケジューリングはできない。 バージョン2.12のGNU binutilsは、コンパイラがどの命令にどの再配置を適用すべきかを明示的に示すことを可能にする新しい構文をサポートしている。 このオプションは、GCCがビルド時にアセンブラの機能を検出し、それに応じてデフォルトを設定するため、デバッグに最も役立つ。

@item -msmall-data
@itemx -mlarge-data
@opindex msmall-data
@opindex mlarge-data
@option{-mexplicit-relocs}が有効な場合、静的データは@dfn{gp-relative}再配置によってアクセスされる。 @option{-msmall-data}を使用すると、長さが8バイト以下のオブジェクトが@dfn{小データ領域}（@code{.sdata}セクションと@code{.sbss}セクション）に配置され、 @code{$gp}レジスタからの16ビット再配置経由でアクセスされる。 これにより、小さなデータ領域のサイズが64KBに制限されるが、変数には単一の命令で直接アクセスすることができる。

デフォルトは@option{-mlarge-data}である。 このオプションを使用すると、データ領域が2GB未満に制限される。 2GBを超えるデータを必要とするプログラムでは、プログラムのデータセグメントではなく、ヒープ内のデータを割り当てるために、@code{malloc}または@code{mmap}を使用する必要がある。

共有ライブラリ用のコードを生成する場合、@option{-fpic}は@option{-msmall-data}を意味し、@option{-fPIC}は@option{-mlarge-data}を意味する。

@item -msmall-text
@itemx -mlarge-text
@opindex msmall-text
@opindex mlarge-text
@option {-msmall-text}を使用すると、コンパイラはプログラム全体（または共有ライブラリ）のコードが4MBに収まり、分岐命令で到達可能であるとみなす。 @option{-msmall-data}を使用すると、コンパイラはすべてのローカルシンボルが同じ@code{$gp}値を共有しているとみなし、関数呼び出しに必要な命令数を4から1に減らすことができる。

デフォルトは@option{-mlarge-text}です。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var{cpu_type}の命令セットと命令スケジューリングパラメータを設定する。 @samp{EV}スタイル名または対応するチップ番号を指定できる。 GCCは、EV4、EV5、EV6ファミリプロセッサのスケジューリングパラメータをサポートし、指定したプロセッサから命令セットのデフォルト値を選択する。 プロセッサタイプを指定しない場合、GCCのデフォルトはコンパイラが構築されたプロセッサである。

@var {cpu_type}にサポートされている値は

@table @samp
@item ev4
@itemx ev45
@itemx 21064
EV4としてスケジュールし、命令セット拡張を持たない。

@item ev5
@itemx 21164
EV5としてスケジュールし、命令セット拡張はない。

@item ev56
@itemx 21164a
EV5としてスケジューリングし、BWX拡張をサポートする。

@item pca56
@itemx 21164pc
@itemx 21164PC
EV5としてスケジューリングし、BWXおよびMAX拡張をサポートする。

@item ev6
@itemx 21264
EV6としてスケジューリングし、BWX、FIX、およびMAX拡張をサポートします。

@item ev67
@itemx 21264a
EV6としてスケジュールし、BWX、CIX、FIX、およびMAX拡張をサポートします。
@end table

ネイティブツールチェーンは、@samp{native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。GCCがプロセッサを認識しない場合、@option{-mcpu=native}は効果がない。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var{cpu_type}の命令スケジューリングパラメータのみを設定する。 命令セットは変更されない。

ネイティブツールチェーンは、@samp {native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。 GCCがプロセッサを認識しない場合は、@option{-mtune = native}は効果がない。

@item -mmemory-latency=@var{time}
@opindex mmemory-latency
スケジューラがアプリケーションによって見られる典型的なメモリ参照に対して想定するレイテンシを設定する。 この数値は、アプリケーションで使用されるメモリアクセスパターンとマシン上の外部キャッシュのサイズに大きく依存する。

@var{time}の有効なオプションは

@table @samp
@item @var{number}
クロックサイクルを表す10進数。

@item L1
@itemx L2
@itemx L3
@itemx main
コンパイラには、レベル1,2、および3のキャッシュ（Dcache、Scache、およびBcacheとも呼ばれる）のための「典型的な」EV4およびEV5ハードウェアのためのクロックサイクル数の推定値とメインメモリが含まれている。 L3はEV5にのみ有効である。

@end table
@end table

@node FR30 Options
@subsection FR30オプション
@cindex FR30 Options

これらのオプションは、FR30ポート専用に定義されている。

@table @gcctabopt

@item -msmall-model
@opindex msmall-model
小さなアドレス空間モデルを使用する。 これにより、より小さなコードが生成されるが、すべてのシンボリックな値とアドレスが20ビットの範囲に収まると仮定する。

@item -mno-lsim
@opindex mno-lsim
実行時サポートが提供されていると仮定して、シミュレータライブラリ（@file{libsim.a}）をリンカコマンドラインに含める必要をなくす。

@end table

@node FT32 Options
@subsection FT32オプション
@cindex FT32 Options

これらのオプションは、FT32ポート専用に定義されている。

@table @gcctabopt

@item -msim
@opindex msim
プログラムをシミュレータ上で実行することを指定する。 これにより、別のランタイム起動とライブラリがリンクされる。 実際のハードウェア上で動作するプログラムを生成するときは、このオプションを使用してはならない。 どのI/O関数が必要なのかに関わらず、独自のランタイムライブラリを用意する必要がある。

@item -mlra
@opindex mlra
ローカルレジスタ割り付けを有効にする。 これはFT32ではまだ実験的なので、デフォルトでコンパイラは標準リロードを使用する。

@item -mnodiv
@opindex mnodiv
divとmod命令を使わない。

@end table

@node FRV Options
@subsection FRVオプション
@cindex FRV Options

@table @gcctabopt
@item -mgpr-32
@opindex mgpr-32

最初の32個の汎用レジスタのみを使用する。

@item -mgpr-64
@opindex mgpr-64

64個の汎用レジスタをすべて使用する。

@item -mfpr-32
@opindex mfpr-32

最初の32個の浮動小数点レジスタのみを使用する。

@item -mfpr-64
@opindex mfpr-64

64個の浮動小数点レジスタをすべて使用する。

@item -mhard-float
@opindex mhard-float

浮動小数点演算にはハードウェア命令を使用する。

@item -msoft-float
@opindex msoft-float

浮動小数点演算にはライブラリルーチンを使用する。

@item -malloc-cc
@opindex malloc-cc

条件コードレジスタを動的に割り当てる。

@item -mfixed-cc
@opindex mfixed-cc

条件コードレジスタを動的に割り当てようとはせず、@code{icc0}と@code{fcc0}だけを使用する。

@item -mdword
@opindex mdword

ダブルワード命令を使用するようにABIを変更する。

@item -mno-dword
@opindex mno-dword

ダブルワード命令は使用しない。

@item -mdouble
@opindex mdouble

浮動小数点の倍精度命令を使用する。

@item -mno-double
@opindex mno-double

浮動小数点の倍精度命令を使用しない。

@item -mmedia
@opindex mmedia

メディア命令を使う。

@item -mno-media
@opindex mno-media

メディア命令を使わない。

@item -mmuladd
@opindex mmuladd

乗加算・乗減算命令を使う。

@item -mno-muladd
@opindex mno-muladd

乗加算・乗減算命令を使わない。

@item -mfdpic
@opindex mfdpic

関数へのポインタを表すために関数記述子を使用するFDPIC ABIを選択する。 PIC/PIE関連のオプションがなければ、それは@option{-fPIE}を意味する。 @option{-fpic}または@option{-fpie}を使用すると、GOTエントリと小データがGOTベースアドレスから12ビットの範囲内にあるとみなされる。 @option{-fPIC}または@option{-fPIE}を指定すると、GOTオフセットは32ビットで計算される。@samp{bfin-elf}ターゲットの場合、このオプションは@option{-msim}を意味する。

@item -minline-plt
@opindex minline-plt

ローカルにバインドされていない関数に対する関数呼び出しのPLTエントリのインライン化を有効にする。 @option{-mfdpic}なしでは効果はない。共有ライブラリ（つまり、@option{-fPIC}や@option{-fpic}）用に速度でコンパイルされるか、@option{-O3}以上のような最適化が有効の場合はデフォルトで有効である。

@item -mTLS
@opindex mTLS

スレッドローカルコードを生成するときは、大きなTLSセグメントを仮定する。

@item -mtls
@opindex mtls

スレッドローカルコードを生成するときに大きなTLSセグメントを想定しない。

@item -mgprel-ro
@opindex mgprel-ro

読取り専用セクションにあることが知られているデータについては、FDPIC ABIの@code{GPREL}再配置の使用を有効にする。 @option{-fpic}または@option{-fpie}を除いて、デフォルトで有効になっている。グローバルオフセットテーブルを小さくするのに役立つかもしれないが、１命令を4つに変える。@option{-fPIC}または@option{-fPIE}では、3命令を4に変え、そのうちの1つを複数のシンボルで共有することができ、参照シンボルのGOTエントリが不要になるため、勝つ可能性が高くなる。 そうでない場合は、@option{-mno-gprel-ro}を使用して無効にすることができる。

@item -multilib-library-pic
@opindex multilib-library-pic

（FDでなく、ライブラリの）picライブラリにリンクする。 これは、@option{-mlibrary-pic}と、@option{-fPIC}と@option{-fpic}（@option{-mfdpic}なし）によって暗示されている。 明示的に使用する必要はない。

@item -mlinked-fp
@opindex mlinked-fp

スタックフレームが割り当てられるたびに必ずフレームポインタを作成するというEABIの要求に従う。 このオプションはデフォルトで有効になっており、@option{-mno-linked-fp}で無効にすることができる。

@item -mlong-calls
@opindex mlong-calls

間接アドレッシングを使用して、現在のコンパイル単位の外にある関数を呼び出す。 これにより、関数を32ビットアドレス空間のどこにでも配置することができる。

@item -malign-labels
@opindex malign-labels

前のパケットにNOPを挿入して、ラベルを8バイトの境界に揃える。 このオプションは、VLIWパッキングが有効な場合にのみ有効である。 新しいパケットは作成されない。 単に既存のものにNOPを追加するだけである。

@item -mlibrary-pic
@opindex mlibrary-pic

位置独立のEABIコードを生成する。

@item -macc-4
@opindex macc-4

最初の4メディアアクセレーターレジスタのみを使う。

@item -macc-8
@opindex macc-8

全８メディアアクセレーターレジスタを使う。

@item -mpack
@opindex mpack

VLIW命令を詰める。

@item -mno-pack
@opindex mno-pack

VLIW命令を詰めない。

@item -mno-eflags
@opindex mno-eflags

e_flags内でABIスイッチをマークしない。

@item -mcond-move
@opindex mcond-move

条件ムーブ命令の使用を有効にする（デフォルト）。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-cond-move
@opindex mno-cond-move

条件ムーブ命令の使用を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mscc
@opindex mscc

条件付きセット命令の使用を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-scc
@opindex mno-scc

条件付きセット命令の使用を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mcond-exec
@opindex mcond-exec

条件付き実行の使用を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-cond-exec
@opindex mno-cond-exec

条件付き実行の使用を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mvliw-branch
@opindex mvliw-branch

分岐をVLIW命令に詰めるパスを走らせる。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-vliw-branch
@opindex mno-vliw-branch

分岐をVLIW命令に詰めるパスを走らせない。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mmulti-cond-exec
@opindex mmulti-cond-exec

@code{&&}と@code{||}の条件付き実行での最適化を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-multi-cond-exec
@opindex mno-multi-cond-exec

@code{&&}と@code{||}の条件付き実行での最適化を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mnested-cond-exec
@opindex mnested-cond-exec

入れ子条件付き実行最適化を有効にする。（デフォルト）

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -mno-nested-cond-exec
@opindex mno-nested-cond-exec

入れ子条件付き実行最適化を無効にする。

このスイッチは主にコンパイラをデバッグするためのスイッチで、将来のバージョンでは削除される可能性がある。

@item -moptimize-membar
@opindex moptimize-membar

このスイッチは冗長な@code{membar}命令をコンパイラが生成したコードから取り除く。デフォルトで有効である。

@item -mno-optimize-membar
@opindex mno-optimize-membar

このスイッチは生成されたコードから冗長な@code{membar}を自動的に除去するのを無効にする。

@item -mtomcat-stats
@opindex mtomcat-stats

gasにtomcat統計を出力させる。

@item -mcpu=@var{cpu}
@opindex mcpu

生成コードのプロセッサタイプを指定する。可能な値は
@samp{frv}, @samp{fr550}, @samp{tomcat}, @samp{fr500}, @samp{fr450},
@samp{fr405}, @samp{fr400}, @samp{fr300} と@samp{simple}である。

@end table

@node GNU/Linux Options
@subsection GNU/Linuxオプション

これらの@samp{-m}オプションはGNU / Linuxターゲットに対して定義されています：

@table @gcctabopt
@item -mglibc
@opindex mglibc
GNU Cライブラリを使う。これは@samp{*-*-linux-*uclibc*}, @samp{*-*-linux-*musl*}, 
@samp{*-*-linux-*android*}ターゲット以外でのデフォルトである。

@item -muclibc
@opindex muclibc
uClibc Cライブラリを使う。これは@samp{*-*-linux-*uclibc*}ターゲットでのデフォルトである。

@item -mmusl
@opindex mmusl
musl Cライブラリを使う。これは@samp{*-*-linux-*musl*}ターゲットでのデフォルトである。

@item -mbionic
@opindex mbionic
Bionic Cライブラリを使う。これは@samp{*-*-linux-*android*}ターゲットでのデフォルトである。

@item -mandroid
@opindex mandroid
Andriodプラットフォームで互換性のあるコードをコンパイルする。これは@samp{*-*-linux-*android*}ターゲットでのデフォルトである。

コンパイル時には、デフォルトで@option{-mbionic}、@option{-fPIC}、@option{-fno-exceptions}、@option{-fno-rtti}を有効にする。 リンクするとき、このオプションはGCCドライバがAndroid固有のオプションをリンカに渡すようにする。 最後に、このオプションはプリプロセッサマクロ@code{__ ANDROID__}を定義させます。

@item -tno-android-cc
@opindex tno-android-cc
@option{-mandroid}のコンパイル効果を無効にする。つまり、デフォルトでは、@option{-mbionic}、@option{-fPIC}、@option{-fno-exceptions}、@option{-fno-rtti}を有効にしない。

@item -tno-android-ld
@opindex tno-android-ld
@option{-mandroid}のリンク効果を無効にします。つまり、標準のLinuxリンクオプションをリンカーに渡す。

@item -mft32b
@opindex mft32b
Enable use of the extended instructions of the FT32B processor.

@item -mcompress
@opindex mcompress
Compress all code using the Ft32B code compression scheme.

@item -mnopm
@opindex  mnopm
Do not generate code that reads program memory.

@end table

@node H8/300 Options
@subsection H8/300 オプション

これらの@samp{-m}オプションは、H8/300実装で定義されている。

@table @gcctabopt
@item -mrelax
@opindex mrelax
可能であれば、リンク時にいくつかのアドレス参照を短くする。 リンカオプション@option{-relax}を使用する。 完全な記述のために@xref{H8/300,, @code{ld}とH8/300,ld, Using ld}を参照。

@item -mh
@opindex mh
H8/300H用のコードを生成する。

@item -ms
@opindex ms
H8S用のコードを生成する。

@item -mn
@opindex mn
H8SおよびH8/300H用のコードを通常モードで生成します。 このスイッチは、@option{-mh}または@option{-ms}のいずれかと一緒に使用する必要がある。

@item -ms2600
@opindex ms2600
H8S/2600用のコードを生成する。このスイッチは@option{-ms}と一緒に使用する必要がある。

@item -mexr
@opindex mexr
拡張レジスタは、monitor属性を持つfunctionを実行する前にスタックに格納される。 デフォルトのオプションは@option{-mexr}である。このオプションはH8Sターゲットに対してのみ有効である。

@item -mno-exr
@opindex mno-exr
モニタ属性のある関数を実行する前に、拡張レジスタはスタックに格納されない。 デフォルトのオプションは@option{-mno-exr}である。 このオプションは、H8Sターゲットに対してのみ有効である。

@item -mint32
@opindex mint32
@code{int}データをデフォうとで32ビットにする。

@item -malign-300
@opindex malign-300
H8/300HおよびH8Sでは、H8/300と同じアライメント規則を使用する。 H8/300HおよびH8Sのデフォルトでは、longおよびfloatを4バイトの境界に揃えることができる。 @option{-malign-300}は、それらを2バイトの境界に整列させる。 このオプションはH8/300には影響しない。
@end table

@node HPPA Options
@subsection HPPAオプション
@cindex HPPA Options

これらの@samp {-m}オプションは、HPPAファミリのコンピュータに対して定義されている。

@table @gcctabopt
@item -march=@var{architecture-type}
@opindex march
指定されたアーキテクチャのコードを生成する。 @var{architecture-type}の選択肢は、PA 1.0では@samp{1.0}、PA 1.1では@samp{1.1}、PA 2.0プロセッサでは@samp{2.0}である。 使用のマシンに適したアーキテクチャー・オプションを判別するには、HP-UXシステムの@file{/usr/lib/sched.models}を参照せよ。 低い番号のアーキテクチャ用にコンパイルされたコードは、高い番号のアーキテクチャ上で実行されるが、それ以外の方法では実行されない。

@item -mpa-risc-1-0
@itemx -mpa-risc-1-1
@itemx -mpa-risc-2-0
@opindex mpa-risc-1-0
@opindex mpa-risc-1-1
@opindex mpa-risc-2-0
@option{-march=1.0}、@option{-march=1.1}、@option{-march=2.0}の同義語である。

@item -mcaller-copies
@opindex mcaller-copies
呼び出し元は、隠し参照によって渡された関数引数をコピーする。 このオプションは、デフォルトの32ビット・ランタイムと互換性がないため、注意して使用する必要がある。 ただし、8バイトを超える集約のみが非表示の参照で渡され、このオプションはOpenMPとの互換性が向上する。

@item -mjump-in-delay
@opindex mjump-in-delay
このオプションは無視され、互換性の目的でのみ提供される。

@item -mdisable-fpregs
@opindex mdisable-fpregs
任意の方法で浮動小数点レジスタが使用されないようにする。 これは、浮動小数点レジスタの遅延コンテキスト切り替えを実行するカーネルをコンパイルするために必要である。 このオプションを使用して浮動小数点演算を実行しようとすると、コンパイラは異常終了する。

@item -mdisable-indexing
@opindex mdisable-indexing
コンパイラがインデックスアドレスモードを使用しないようにする。 これにより、MACHの下でMIG生成コードをコンパイルするときに、あまり目立たない問題が回避される。

@item -mno-space-regs
@opindex mno-space-regs
ターゲットにスペースレジスタがないことを前提としたコードを生成する。 これにより、GCCはより高速の間接呼び出しを生成し、スケーリングされていないインデックスアドレスモードを使用できる。

このようなコードはレベル0のPAシステムとカーネルに適している。

@item -mfast-indirect-calls
@opindex mfast-indirect-calls
コールがスペース境界を越えることがないと想定するコードを生成する。 これにより、GCCはより高速な間接呼び出しを実行するコードを発行することができる。

このオプションは、共有ライブラリまたはネストされた関数が存在する場合は機能しない。

@item -mfixed-range=@var{register-range}
@opindex mfixed-range
与えられたレジスタ範囲を固定レジスタとして扱うコードを生成する。 固定レジスタは、レジスタアロケータが使用できないレジスタである。 カーネルコードをコンパイルするときに便利である。 レジスタ範囲は、ダッシュで区切られた2つのレジスタとして指定される。 カンマで区切って複数のレジスタ範囲を指定することができる。

@item -mlong-load-store
@opindex mlong-load-store
HP-UX 10リンカで時々必要となる3命令ロードおよびストアシーケンスを生成する。 これはHPコンパイラの@samp{+k}オプションと同じである。

@item -mportable-runtime
@opindex mportable-runtime
ELFシステムには、HPが提案した移植性呼び出し規則を使用する。

@item -mgas
@opindex mgas
GASだけが理解できるアセンブラディレクティブの使用を有効にする。

@item -mschedule=@var{cpu-type}
@opindex mschedule
機種@var{cpu-type}の制約に従ってコードをスケジュールする。 @var{cpu-type}の選択肢は、@samp{700} @samp{7100}、@samp{7100LC}、@samp{7200}、@samp{7300}、@samp{8000}である。 使用のマシンに適したスケジューリング・オプションを判別するには、HP-UXシステムの@file{/usr/lib/sched.models}を参照せよ。 デフォルトのスケジューリングは@samp{8000}である。

@item -mlinker-opt
@opindex mlinker-opt
HP-UXリンカで最適化パスを有効にするい。 これによりシンボリックデバッグが不可能になることに注意すること。 また、HP-UX 8およびHP-UX 9リンカでは、いくつかのプログラムをリンクするときに偽のエラーメッセージを表示するバグが発生する。

@item -msoft-float
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含む出力を生成する。
@strong{警告：}必要なライブラリは、すべてのHPPAターゲットで利用できるわけではない。 通常、マシンの通常のCコンパイラの機能が使用されるが、これはクロスコンパイルで直接行うことはできない。 クロスコンパイルに適したライブラリ関数を提供するために、独自の手配をしなければならない。

@option {-msoft-float}は、出力ファイルの呼び出し規約を変更する。 したがって、このオプションでプログラムの@emph{すべて}をコンパイルする場合にのみ有用である。 特に、GCCに付属のライブラリである@file{libgcc.a}を@option{-msoft-float}とコンパイルする必要がある。

@item -msio
@opindex msio
サーバーIOの事前定義、@code{_SIO}を生成する。 デフォルトは@option{-mwsio}である。 これにより、ワークステーションIOの事前定義、@code{__hp9000s700}、@code{__hp9000s700__}および@code{_WSIO}が生成される。 これらのオプションは、HP-UXおよびHI-UXの下で使用できる。

@item -mgnu-ld
@opindex mgnu-ld
GNU @command{ld}に固有のオプションを使用する。共有ライブラリを構築するときに、@option{-shared}を@command{ld}に渡す。 GCCが明示的または暗黙的にGNUリンカーで設定されている場合は、これがデフォルトである。 このオプションは、どの@command{ld}が呼び出されるかには影響しない。 その@command{ld}に渡されるパラメータだけが変更される。 呼び出される@command{ld}は、@option{-with-ld}設定オプション、GCCのプログラム検索パス、最後にユーザの@env{PATH}によって決まる。 GCCで使用されるリンカーは@samp{which `gcc -print-prog-name=ld`}を使用して出力できる。 このオプションは、64ビットHP-UX GCCでのみ使用できる。つまり、@samp{hppa*64*-*-hpux*}で構成されている場合。

@item -mhp-ld
@opindex mhp-ld
HP @command{ld}に固有のオプションを使用する。共有ライブラリをビルドするときに@option{-b}を@command{ld}に渡し、すべてのリンクで@option{+Accept TypeMismatch}を@command{ld}に渡します。 GCCが明示的または暗黙的にHPリンカーで設定されている場合は、これがデフォルトである。このオプションは、どの@command{ld}が呼び出されるかには影響しない。 その@command{ld}に渡されるパラメータだけが変更される。 呼び出される@command{ld}は、@option{-with-ld}設定オプション、GCCのプログラム検索パス、最後にユーザの@env{PATH}によって決まる。 GCCで使用されるリンカーは@samp{which `gcc -print-prog-name=ld`}を使用して出力できる。 このオプションは、64ビットHP-UX GCCでのみ使用できる。つまり、@samp{hppa*64*-*-hpux*}で構成されている場合。

@item -mlong-calls
@opindex mno-long-calls
ロング・コールシーケンスを使用するコードを生成する。これにより、呼び出しが常にリンカによって生成されたスタブに到達できるようになる。デフォルトでは、コールサイトから関数または変換ユニットの先頭までの距離が、使用されているブランチタイプによって設定された事前定義された制限を超える場合にのみ、ロング・コールを生成する。通常のコールの制限は、PA 2.0およびPA 1.Xアーキテクチャでそれぞれ7,600,000と240,000バイトである。 Sibcallsは常に240,000バイトに制限されている。

距離は、@option{-ffunction-sections}オプションを使用するとき、またはSOMリンカーのあるHP-UXで@option{-mgas}オプションと@option{-mno-portable-runtime}オプションを一緒に使用するとき、関数の始めから測られる。

パフォーマンスを低下させるので、通常このオプションを使用することは望ましくない。 ただし、大規模なアプリケーションでは、特に部分的なリンクを使用してアプリケーションを構築する場合に役立つ。

使用されるロング・コールの種類は、アセンブラとリンカの機能、および生成されるコードの種類によって異なる。 ロング絶対コール、長いピクチャシンボル差分、またはPC相対コールをサポートするシステムへの影響は比較的小さいはずである。 しかし、間接呼び出しは、32ビットELFシステムではpicコードで使用されており、かなり長い。

@item -munix=@var{unix-std}
@opindex march
コンパイラ前定義を生成し、指定されたUNIX標準の開始ファイルが選択される。 @var{unix-std}の選択肢は@samp{93}、@samp{95}、@samp{98}である。 @samp{93}は、すべてのHP-UXバージョンでサポートされている。 @samp{95}は、HP-UX 10.10以降で使用できる。 @samp{98}は、HP-UX 11.11以降で使用できる。デフォルト値は、HP-UX 10.00では@samp{93}、HP-UX 10.10から11.00では@samp{95}、HP-UX 11.11以降では@samp{98}である。

@option{-munix=93}は、GCC 3.3と3.4と同じ事前定義を提供する。 @option{-munix=95}は、@code{XOPEN_UNIX}と@code{_XOPEN_SOURCE_EXTENDED}、および@file{unix95.o}の開始ファイルに追加の事前定義を提供する。
@option{-munix=98}は、@code{_XOPEN_UNIX}、@code{_XOPEN_SOURCE_EXTENDED}、@code{_INCLUDE__STDC_A1_SOURCE}、@code{_INCLUDE_XOPEN_SOURCE_500}、および開始ファイル@file{unix98.o}の追加定義を提供する。

このオプションは、さまざまなライブラリルーチンのインターフェイスを変更することに注意することが@emph{重要}である。 また、Cライブラリの動作上の動作にも影響する。 したがって、このオプションの使用には@emph{細心}の注意が必要です。

複数のUNIX標準で動作するライブラリコードは、必要に応じて変数@code{__ xpg4_extended_mask}をテスト、設定、復元する必要がある。 ほとんどのGNUソフトウェアはこの機能を提供していない。

@item -nolibdld
@opindex nolibdld
HP-UX 10以降で@option{-static}オプションが指定されている場合、libdld.slを検索するリンクオプションの生成を抑制する。

@item -static
@opindex static
libcのsetlocaleのHP-UX実装は、libdld.slに依存している。 libdld.slのアーカイブバージョンはない。 したがって、@option{-static}オプションを指定すると、この依存関係を解決するために特別なリンクオプションが必要になる。

HP-UX 10以降では、@option {-static}オプションが指定されている場合、GCCドライバはlibdld.slとリンクするために必要なオプションを追加する。これにより結果のバイナリが動的になる。 64ビットポートでは、リンカはどのような場合でもデフォルトで動的バイナリを生成する。 @option{-nolibdld}オプションは、GCCドライバがこれらのリンクオプションを追加しないようにするために使用できる。

@item -threads
@opindex threads
HP-UXの@dfn{dce thread}ライブラリを使用して、マルチスレッドのサポートを追加する。 このオプションは、プリプロセッサとリンカの両方のフラグを設定する。
@end table

@node IA-64 Options
@subsection IA-64 Options
@cindex IA-64 Options

これらは、インテルIA-64アーキテクチャーのために定義される@samp{-m}オプションである。

@table @gcctabopt
@item -mbig-endian
@opindex mbig-endian
ビッグエンディアン・ターゲットのコードを生成する。これは、HP-UXのデフォルトである。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアン・ターゲットのコードを生成する。これは、AIX5とGNU/Linuxのデフォルトである。

@item -mgnu-as
@itemx -mno-gnu-as
@opindex mgnu-as
@opindex mno-gnu-as
GNUアセンブラのコードを生成する（しない）。これは、デフォルトである。
@c Also, this is the default if the configure option @option{--with-gnu-as}
@c is used.

@item -mgnu-ld
@itemx -mno-gnu-ld
@opindex mgnu-ld
@opindex mno-gnu-ld
Generate (or don't) code for the GNU linker.  This is the default.
@c Also, this is the default if the configure option @option{--with-gnu-ld}
@c is used.

@item -mno-pic
@opindex mno-pic
グローバルなポインタ・レジスタを使わないコードを生成する。結果は位置独立したコードでなく、IA-64 ABIに違反する。

@item -mvolatile-asm-stop
@itemx -mno-volatile-asm-stop
@opindex mvolatile-asm-stop
@opindex mno-volatile-asm-stop
揮発性のasm文の直前・直後にストップ・ビットを生成する（しない）。

@item -mregister-names
@itemx -mno-register-names
@opindex mregister-names
@opindex mno-register-names
スタックされたレジスタ用の@samp{in}、@samp{loc}と@samp{out}レジスタ名前を生成する（しない）。
これは、アセンブラ出力をより読みやすくするかもしれない。

@item -mno-sdata
@itemx -msdata
@opindex mno-sdata
@opindex msdata
小さいデータセクションを使う最適化を無（有）効にする。これは、オプティマイザのバグの回避策に役立つかもしれない。

@item -mconstant-gp
@opindex mconstant-gp
単一の定数グローバルポインタ値を使用するコードを生成する。 これはカーネルコードをコンパイルするときに便利である。

@item -mauto-pic
@opindex mauto-pic
自己再配置可能なコードを生成する。これは@option{-mconstant-gp}を意味する。これは、ファームウェアコードをコンパイルするときに便利である。

@item -minline-float-divide-min-latency
@opindex minline-float-divide-min-latency
最小レイテンシアルゴリズムを使用して、浮動小数点値のインライン除算のコードを生成する。

@item -minline-float-divide-max-throughput
@opindex minline-float-divide-max-throughput
最大スループットアルゴリズムを使用して、浮動小数点値のインライン除算のコードを生成する。

@item -mno-inline-float-divide
@opindex mno-inline-float-divide
浮動小数点値の除算にインラインコードを生成しない。

@item -minline-int-divide-min-latency
@opindex minline-int-divide-min-latency
最小レイテンシアルゴリズムを使用して、整数値のインライン除算のコードを生成する。

@item -minline-int-divide-max-throughput
@opindex minline-int-divide-max-throughput
最大スループットアルゴリズムを使用して、整数値のインライン除算のコードを生成する。

@item -mno-inline-int-divide
@opindex mno-inline-int-divide
整数値の除算にはインラインコードを生成しない。

@item -minline-sqrt-min-latency
@opindex minline-sqrt-min-latency
最小レイテンシアルゴリズムを使用してインライン平方根のコードを生成する。

@item -minline-sqrt-max-throughput
@opindex minline-sqrt-max-throughput
最大スループットアルゴリズムを使用してインライン平方根のコードを生成する。

@item -mno-inline-sqrt
@opindex mno-inline-sqrt
@code{sqrt}のインラインコードを生成しない。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
融合乗加算または乗減算命令を使用するコードを生成する（しない）。デフォルトでは、これらの命令が使用される。

@item -mno-dwarf2-asm
@itemx -mdwarf2-asm
@opindex mno-dwarf2-asm
@opindex mdwarf2-asm
DWARF行番号デバッグ情報用のアセンブラコードを生成しない（する）。 これは、GNUアセンブラを使用しない場合に便利である。

@item -mearly-stop-bits
@itemx -mno-early-stop-bits
@opindex mearly-stop-bits
@opindex mno-early-stop-bits
ストップビットが、ストップビットをトリガした命令の直前に配置することを許可する。 これは命令スケジューリングを改善することができるが、必ずしもそうであるとは限らない。

@item -mfixed-range=@var{register-range}
@opindex mfixed-range
与えられたレジスタ範囲を固定レジスタとして扱うコードを生成する。 固定レジスタは、レジスタアロケータが使用できないレジスタである。 カーネルコードをコンパイルするときに便利である。 レジスタ範囲は、ダッシュで区切られた2つのレジスタとして指定される。 カンマで区切って複数のレジスタ範囲を指定することができる。

@item -mtls-size=@var{tls-size}
@opindex mtls-size
即時TLSオフセットのビットサイズを指定します。 有効な値は14、22、および64。

@item -mtune=@var{cpu-type}
@opindex mtune
特定のCPUの命令スケジューリングを調整する。有効な値は@samp{itanium}、@samp{itanium1}、@samp{merced}、@samp{itanium2}、@samp{mckinley}である。

@item -milp32
@itemx -mlp64
@opindex milp32
@opindex mlp64
32ビットまたは64ビット環境用のコードを生成する。 32ビット環境はint、long、およびポインタを32ビットへ設定する。 64ビット環境ではintを32ビット長、longとポインタを64ビットに設定する。 これらはHP-UX固有のフラグである。

@item -mno-sched-br-data-spec
@itemx -msched-br-data-spec
@opindex mno-sched-br-data-spec
@opindex msched-br-data-spec
リロードする前にデータ推測スケジューリングを無（有）効にする。その結果、@code{ld.a}命令とそれに対応するチェック命令（@code{ld.c} / @code{chk.a}）が生成される。 デフォルト設定は無効です。

@item -msched-ar-data-spec
@itemx -mno-sched-ar-data-spec
@opindex msched-ar-data-spec
@opindex mno-sched-ar-data-spec
リロード後にデータ推測スケジューリングを有（無）効にする。その結果、@code{ld.a}命令とそれに対応するチェック命令（@code{ld.c} / @code{chk.a}）が生成される。デフォルト設定は有効である。

@item -mno-sched-control-spec
@itemx -msched-control-spec
@opindex mno-sched-control-spec
@opindex msched-control-spec
制御投機的スケジューリングを無（有）効にする。 この機能は、領域スケジュール設定時にのみ使用できる（すなわち、リロード前）。 これにより、@code{ld.s}命令とそれに対応するチェック命令@code{chk.s}が生成される。デフォルト設定は無効である。

@item -msched-br-in-data-spec
@itemx -mno-sched-br-in-data-spec
@opindex msched-br-in-data-spec
@opindex mno-sched-br-in-data-spec
リロード前にデータ投機的ロードに依存する命令の投機的スケジューリングを有（無）効にする。 これは、@option{-msched-br-data-spec}を有効にした場合にのみ有効である。 デフォルト設定は有効である。

@item -msched-ar-in-data-spec
@itemx -mno-sched-ar-in-data-spec
@opindex msched-ar-in-data-spec
@opindex mno-sched-ar-in-data-spec
リロード後のデータ投機的ロードに依存する命令の投機的スケジューリングを有（無）効にする。 これは、@option{-msched-ar-data-spec}を有効にした場合にのみ有効である。デフォルト設定は有効である。

@item -msched-in-control-spec
@itemx -mno-sched-in-control-spec
@opindex msched-in-control-spec
@opindex mno-sched-in-control-spec
制御投機的負荷に依存する命令の投機的スケジューリングを有（無）効にする。これは、@option{-msched-control-spec}が有効な場合にのみ有効である。デフォルト設定は有効である。

@item -mno-sched-prefer-non-data-spec-insns
@itemx -msched-prefer-non-data-spec-insns
@opindex mno-sched-prefer-non-data-spec-insns
@opindex msched-prefer-non-data-spec-insns
このオプションが有効になっていると、その時点で他の選択肢がない場合にのみ、スケジュールでデータの投機的な命令が選択される。 これは、データ推測の使用をはるかに控えめにする。 デフォルト設定は無効である。

@item -mno-sched-prefer-non-control-spec-insns
@itemx -msched-prefer-non-control-spec-insns
@opindex mno-sched-prefer-non-control-spec-insns
@opindex msched-prefer-non-control-spec-insns
有効にすると、現時点で他の選択肢がない場合にのみ、スケジュールで制御投機的命令が選択されます。 これは、制御推測の使用をより控えめにする。 デフォルト設定は無効である。

@item -mno-sched-count-spec-in-critical-path
@itemx -msched-count-spec-in-critical-path
@opindex mno-sched-count-spec-in-critical-path
@opindex msched-count-spec-in-critical-path
有効にすると、命令の優先順位の計算中に投機的な依存関係が考慮される。 これにより、推測の使用は少し控えめになる。デフォルト設定は無効である。

@item -msched-spec-ldc
@opindex msched-spec-ldc
簡単なデータの推測チェックを使用する。 このオプションは、デフォルトでオンになっている。

@item -msched-control-spec-ldc
@opindex msched-spec-ldc
コントロールの推測のための簡単なチェックを使用する。 このオプションは、デフォルトでオンになっている。

@item -msched-stop-bits-after-every-cycle
@opindex msched-stop-bits-after-every-cycle
スケジューリングの際には、各サイクルの後にストップビットを配置する。 このオプションは、デフォルトでオンになっている。

@item -msched-fp-mem-deps-zero-cost
@opindex msched-fp-mem-deps-zero-cost
浮動小数点ストアとロードは、同じ命令グループに配置されたときに競合を引き起こす可能性が低いと仮定する。 このオプションはデフォルトで無効になっている。

@item -msel-sched-dont-check-control-spec
@opindex msel-sched-dont-check-control-spec
選択的スケジューリングで制御の推測のチェックを生成する。このフラグは、デフォルトでは無効になっている。

@item -msched-max-memory-insns=@var{max-insns}
@opindex msched-max-memory-insns
命令グループごとのメモリインinsの数を制限し、同じ命令グループ内でスケジューリングを試みる後続のメモリインシュランスを優先させる。 キャッシュバンクの競合を防止するために頻繁に役立つ。 デフォルト値は1である。

@item -msched-max-memory-insns-hard-limit
@opindex msched-max-memory-insns-hard-limit
@option{msched-max-memory-insns}で指定された制限をハードリミットにし、その数を命令グループ内で禁止する。
それ以外の場合、制限は「ソフト」である。つまり、制限に達すると非メモリー操作が優先されるが、メモリー操作は引き続きスケジュールされる。

@end table

@node LM32 Options
@subsection LM32オプション
@cindex LM32 options

これらの@option{-m}オプションは、LatticeMico32アーキテクチャ用に定義されている。

@table @gcctabopt
@item -mbarrel-shift-enabled
@opindex mbarrel-shift-enabled
バレルシフト命令を有効にする。

@item -mdivide-enabled
@opindex mdivide-enabled
除算と剰余命令を有効にする。

@item -mmultiply-enabled
@opindex multiply-enabled
乗算命令を有効にする。

@item -msign-extend-enabled
@opindex msign-extend-enabled
符号拡張命令を有効にする。

@item -muser-enabled
@opindex muser-enabled
ユーザー定義の命令を有効にする。

@end table

@node M32C Options
@subsection M32Cオプション
@cindex M32C options

@table @gcctabopt
@item -mcpu=@var{name}
@opindex mcpu=
コードが生成されるCPUを選択する。 @var{name}は、R8C / Tinyシリーズでは@samp{r8c}、M16Cシリーズ（/ 60まで）では@samp{m16c}、M16C / 80シリーズでは@samp{m32cm}、 @samp{m32c}はM32C / 80シリーズ用である。

@item -msim
@opindex msim
プログラムをシミュレータ上で実行することを指定する。 これにより、ファイルI/Oなどをサポートする別のランタイムライブラリがリンクされる。 実際のハードウェア上で動作するプログラムを生成するときは、このオプションを使用してはならない。 どのI/O関数が必要なのかに関わらず、独自のランタイムライブラリを用意する必要がある。

@item -memregs=@var{number}
@opindex memregs=
コード生成時にGCCが使用するメモリベースの擬似レジスタの数を指定する。 これらの擬似レジスタは実レジスタのように使用されるため、GCCのコードを使用可能なレジスタに収める能力と、レジスタの代わりにメモリを使用する際のパフォーマンス上のペナルティがある。 このオプションには、プログラム内のすべてのモジュールを同じ値でコンパイルする必要がある。 そのため、GCCのデフォルトのランタイムライブラリではこのオプションを使用してはならない。

@end table

@node M32R/D Options
@subsection M32R/D オプション
@cindex M32R/D options

これらの@option{-m}オプションは、ルネサスM32R/Dのアーキテクチャで定義されています。

@table @gcctabopt
@item -m32r2
@opindex m32r2
M32R/2用のコードを生成する。

@item -m32rx
@opindex m32rx
M32R/X用のコードを生成する。

@item -m32r
@opindex m32r
M32R/R用のコードを生成する。これはデフォルトである。

@item -mmodel=small
@opindex mmodel=small
すべてのオブジェクトがメモリの下位16MBにあると仮定し、（そのアドレスは@code{ld24}命令でロードできるようになる）、すべてのサブルーチンは@code{bl}命令で到達可能であると仮定する。 これがデフォルトである。

特定のオブジェクトのアドレス可能性は@code{model}属性で設定できる。

@item -mmodel=medium
@opindex mmodel=medium
オブジェクトが32ビットアドレス空間のどこにもあるかもしれないと仮定し、（コンパイラがアドレスをロードするために@code{seth/add3}命令を生成する）、すべてのサブルーチンが@code{bl}命令で到達可能であると仮定する。

@item -mmodel=large
@opindex mmodel=large
オブジェクトが32ビットアドレス空間のどこにもあるかもしれないと仮定し、（コンパイラがアドレスをロードするために@code{seth/add3}命令を生成する）、@code{bl}命令でサブルーチンに到達できないと仮定する。（コンパイラははるかに遅い@code{seth/add3/jl}命令シーケンスを生成する）

@item -msdata=none
@opindex msdata=none
小さなデータ領域の使用を無効にする。 変数は（@code{section}属性が指定されていない限り）@code{.data}、@code{.bss}、@code{.rodata}のいずれかに入れられる。 これがデフォルトである。

小さなデータ領域は、セクション@code{.sdata}と@code{.sbss}で構成されている。 オブジェクトは、これらのセクションの1つを使用して、@code{section}属性を持つ小さなデータ領域に明示的に置くことができる。

@item -msdata=sdata
@opindex msdata=sdata
小規模なデータ領域に小さなグローバルおよび静的データを入れるが、それらを参照する特別なコードは生成しない。

@item -msdata=use
@opindex msdata=use
小規模なデータ領域に小さなグローバルおよび静的データを入れ、それを参照する特別な命令を生成する。

@item -G @var{num}
@opindex G
@cindex smaller data references
@var{num}バイト以下のグローバルおよび静的オブジェクトを、通常のデータまたはBSSセクションの代わりに、小さなデータまたはBSSセクションに配置する。 @var{num}のデフォルト値は8である。@option{-msdata}オプションは、@samp{sdata}または@samp{use}のいずれかに設定する必要がある。

すべてのモジュールは同じ@option{-G @var{num}}値でコンパイルする必要がある。 異なる値の@var{num}を使ってコンパイルすると、うまく動作しない場合がある。 リンカーがエラーメッセージを表示しない場合、間違ったコードは生成されない。

@item -mdebug
@opindex mdebug
コンパイラ内のM32R固有のコードで、プログラムのデバッグに役立ついくつかの統計情報が表示される。

@item -malign-loops
@opindex malign-loops
すべてのループを32バイト境界に揃えます。

@item -mno-align-loops
@opindex mno-align-loops
ループに32バイトのアライメントを強制しない。 これがデフォルトである。

@item -missue-rate=@var{number}
@opindex missue-rate=@var{number}
サイクルごとに@var{number}命令を発行する。 @var{number}は1または2しか指定できない。

@item -mbranch-cost=@var{number}
@opindex mbranch-cost=@var{number}
@var{number}は1または2しか指定できない。1の場合は条件コードよりも分岐が優先され、2の場合は逆が適用される。

@item -mflush-trap=@var{number}
@opindex mflush-trap=@var{number}
キャッシュをフラッシュするために使用するトラップ番号を指定する。 デフォルトは12である。有効な数値は0から15である。

@item -mno-flush-trap
@opindex mno-flush-trap
トラップを使用してキャッシュをフラッシュできないことを指定する。

@item -mflush-func=@var{name}
@opindex mflush-func=@var{name}
キャッシュをフラッシュするために呼び出すオペレーティングシステム関数の名前を指定する。 デフォルトは@samp{_flush_cache}であるが、関数呼び出しはトラップが利用できない場合にのみ使用される。

@item -mno-flush-func
@opindex mno-flush-func
キャッシュをフラッシュするためのOS機能がないことを示す。

@end table

@node M680x0 Options
@subsection M680x0オプション
@cindex M680x0 options

これらは、M680x0とColdFireプロセッサーで定義された@samp{-m}オプションである。デフォルト設定は、コンパイラの設定時に選択されたアーキテクチャによって異なる。 最も一般的な選択肢のデフォルトが以下に示されている。

@table @gcctabopt
@item -march=@var{arch}
@opindex march
特定のM680x0またはColdFire命令セットアーキテクチャ用のコードを生成する。M680x0アーキテクチャ用の@var{arch}の許容値は次のとおりである。@samp{68000}、@samp{68010}、@samp{68020}、@samp{68030}、@samp{68040}、@samp{68060}、@samp{cpu32}である。ColdFireアーキテクチャはFreescaleのISA分類に従って選択され、許容値は@samp{isaa}、@samp{isaaplus}、@samp{isab}、@samp{isac}である。

GCCは、ColdFireターゲット用のコードを生成しているときは常に、マクロ@code{__ mcf@var{arch}__}を定義する。 このマクロの@var{arch}は、上記の@option{-march}引数の1つである。

@option{-march}と@option{-mtune}を併用すると、類似のプロセッサファミリで実行されるが特定のマイクロアーキテクチャに最適化されたコードを選択する。

@item -mcpu=@var{cpu}
@opindex mcpu
特定のM680x0またはColdFireプロセッサ用のコードを生成する。M680x0 @var{cpu}は次のとおりである：@samp{68000}、@samp{68010}、@samp{68020}、@samp{68030}、@samp{68040}、@samp{68060}、@samp{68302}、@samp{68332}
@samp{cpu32}である。ColdFire@var{cpu}は、以下の表で与えられる。この表はまた、CPUをファミリに分類する。

@multitable @columnfractions 0.20 0.80
@item @strong{Family} @tab @strong{@samp{-mcpu} arguments}
@item @samp{51} @tab @samp{51} @samp{51ac} @samp{51ag} @samp{51cn} @samp{51em} @samp{51je} @samp{51jf} @samp{51jg} @samp{51jm} @samp{51mm} @samp{51qe} @samp{51qm}
@item @samp{5206} @tab @samp{5202} @samp{5204} @samp{5206}
@item @samp{5206e} @tab @samp{5206e}
@item @samp{5208} @tab @samp{5207} @samp{5208}
@item @samp{5211a} @tab @samp{5210a} @samp{5211a}
@item @samp{5213} @tab @samp{5211} @samp{5212} @samp{5213}
@item @samp{5216} @tab @samp{5214} @samp{5216}
@item @samp{52235} @tab @samp{52230} @samp{52231} @samp{52232} @samp{52233} @samp{52234} @samp{52235}
@item @samp{5225} @tab @samp{5224} @samp{5225}
@item @samp{52259} @tab @samp{52252} @samp{52254} @samp{52255} @samp{52256} @samp{52258} @samp{52259}
@item @samp{5235} @tab @samp{5232} @samp{5233} @samp{5234} @samp{5235} @samp{523x}
@item @samp{5249} @tab @samp{5249}
@item @samp{5250} @tab @samp{5250}
@item @samp{5271} @tab @samp{5270} @samp{5271}
@item @samp{5272} @tab @samp{5272}
@item @samp{5275} @tab @samp{5274} @samp{5275}
@item @samp{5282} @tab @samp{5280} @samp{5281} @samp{5282} @samp{528x}
@item @samp{53017} @tab @samp{53011} @samp{53012} @samp{53013} @samp{53014} @samp{53015} @samp{53016} @samp{53017}
@item @samp{5307} @tab @samp{5307}
@item @samp{5329} @tab @samp{5327} @samp{5328} @samp{5329} @samp{532x}
@item @samp{5373} @tab @samp{5372} @samp{5373} @samp{537x}
@item @samp{5407} @tab @samp{5407}
@item @samp{5475} @tab @samp{5470} @samp{5471} @samp{5472} @samp{5473} @samp{5474} @samp{5475} @samp{547x} @samp{5480} @samp{5481} @samp{5482} @samp{5483} @samp{5484} @samp{5485}
@end multitable

@var{arch}が@var{cpu}と互換性がある場合、@option{-mcpu=@var{cpu}}は@option{-march=@var{arch}}をオーバーライドする。 @option{-mcpu}と@option{-march}の他の組み合わせは拒否される。

GCCは、ColdFireターゲット@var{cpu}が選択されているときにマクロ@code {__mcf_cpu_@var{cpu}}を定義する。また、@code{__mcf_family_@var{family}}を定義する。ここで、@var{family}の値は上記の表によって与えられる。

@item -mtune=@var{tune}
@opindex mtune
@option {-march}と@option {-mcpu}で設定された制約内で、特定のマイクロアーキテクチャのコードをチューニングする。M680x0マイクロアーキテクチャは、@samp{68000}、@samp{68010}、@samp{68020}、@samp{68030}、@samp{68040}、@samp{68060}、@samp{cpu32}である。ColdFireのマイクロアーキテクチャは、@samp{cfv1}、@samp{cfv2}、@samp{cfv3}、@samp{cfv4}、@samp{cfv4e}である。

68020、68030、および68040のターゲットで比較的よく動作する必要のあるコードには、@option{-mtune=68020-40}を使用することもできる。@option{-mtune=68020-60}は似ていますが、68060個のターゲットも含む。 これらの2つのオプションは、それぞれ@option{-m68020-40}と@option{-m68020-60}と同じチューニングの決定を選択する。

GCCは680x0アーキテクチャ@var {arch}をチューニングするとき、マクロ@code{__mc@var{arch}}と@code{__mc@var{arch}__}を定義します。
。
また、@ option {-ansi}またはGNU以外の@option {-std}オプションを使用しない限り、@code{mc@var{arch}}も定義する。GCCが@option{-mtune=68020-40}または@option{-mtune=68020-60}で選択されたアーキテクチャの範囲に対してチューニングを行っている場合、GCCは範囲内のすべてのアーキテクチャのマクロを定義する。

GCCはColdFireマイクロアーキテクチャ@var {uarch}のチューニングの際に@code{__m@var{uarch}__}マクロも定義する。ここで、@var{uarch}は上記の引数の1つである。

@item -m68000
@itemx -mc68000
@opindex m68000
@opindex mc68000
68000の出力を生成する。これは、コンパイラが68000ベースのシステム用に構成されている場合のデフォルトである。 @option{-march = 68000}と同じである。

68008、68302、68306、68307、68322、68328、および68356を含む68000またはEC000コアを搭載したマイクロコントローラには、このオプションを使用する。

@item -m68010
@opindex m68010
68010の出力を生成する。これは、コンパイラが68010ベースのシステム用に構成されている場合のデフォルトである。 @option{-march = 68010}と同等である。

@item -m68020
@itemx -mc68020
@opindex m68020
@opindex mc68020
68020の出力を生成する。これは、コンパイラが68020ベースのシステム用に構成されている場合のデフォルトである。 @option{-march = 68020}と同等である。

@item -m68030
@opindex m68030
68030の出力を生成する。これは、コンパイラが68030ベースのシステム用に構成されている場合のデフォルトである。 @option{-march = 68030}と同等である。

@item -m68040
@opindex m68040
68040の出力を生成する。これは、コンパイラが68040ベースのシステム用に構成されている場合のデフォルトである。 @option{-march = 68040}と同等です。

このオプションは、68040のソフトウェアでエミュレートする必要がある68881/68882命令の使用を禁止する。68040にこれらの命令をエミュレートするコードがない場合は、このオプションを使用する。

@item -m68060
@opindex m68060
68060の出力を生成する。これは、コンパイラが68060ベースのシステム用に構成されている場合のデフォルトである。 @option{-march = 68060}と同等である。

このオプションは、68060のソフトウェアでエミュレートする必要のある68020および68881/68882命令の使用を禁止する。68060にこれらの命令をエミュレートするコードがない場合は、このオプションを使用する。

@item -mcpu32
@opindex mcpu32
CPU32の出力を生成する。 コンパイラがCPU32ベースのシステム用に構成されている場合のデフォルトである。 @option{-march=cpu32}と同等である。

68330、68331、68332、68333、68334、68336、68340、68341、68349、68360を含むCPU32またはCPU32 +コアを搭載したマイクロコントローラには、このオプションを使用する。

@item -m5200
@opindex m5200
520X ColdFire CPU用の出力を生成する。 これは、コンパイラが520Xベースのシステム用に設定されている場合のデフォルトである。これは@option{-mcpu=5206}と同等で、現在はそのオプションの方がいいために非推奨である。

MCF5202、MCF5203、MCF5204、MCF5206を含む5200コアのマイクロコントローラには、このオプションを使用する。

@item -m5206e
@opindex m5206e
5206e ColdFire CPU用の出力を生成します。 このオプションは現在非推奨で、対応する@option{-mcpu=5206e}を使用する。

@item -m528x
@opindex m528x
ColdFire 528X族のメンバ用の出力を生成する。 このオプションは現在非推奨で、対応する@option{-mcpu=5206e}を使用する。

@item -m5307
@opindex m5307
ColdFire 5307 CPU用の出力を生成します。このオプションは非推奨になり、対応する@option{-mcpu=5307}を使用する。

@item -m5407
@opindex m5407
ColdFire 5407 CPU用の出力を生成します。このオプションは非推奨になり、対応する@option{-mcpu=5407}を使用する。

@item -mcfv4e
@opindex mcfv4e
ColdFire V4e族CPU用（例えば547x/548x）の出力を生成する。このオプションは@option{-mcpu=547x}と同等で、そのオプションの方がいいために非推奨である。

@item -m68020-40
@opindex m68020-40
新しい命令を使用せずに、68040の出力を生成する。 これにより、68020/68881または68030または68040で比較的効率的に実行できるコードが生成される。生成されたコードでは、68040でエミュレートされる68881命令が使用される。

このオプションは、@option{-march=68020} @option{-mtune=68020-40}と同等である。

@item -m68020-60
@opindex m68020-60
新しい命令を使用せずに、68060の出力を生成する。 これにより、68020/68881または68030または68040で比較的効率的に実行できるコードが生成される。生成されたコードでは、68060でエミュレートされる68881命令が使用される。

このオプションは、@option{-march=68020} @option{-mtune=68020-60}と同等である。

@item -mhard-float
@itemx -m68881
@opindex mhard-float
@opindex m68881
浮動小数点命令を生成する。 これは、68020以上の場合、およびFPUがあるColdFireデバイスの場合はデフォルトである。 これは、M680x0ターゲットでマクロ@code{__ HAVE_68881__}、ColdFireターゲットで@code{__ mcffpu__}を定義する。

@item -msoft-float
@opindex msoft-float
浮動小数点命令を生成しない。 代わりにライブラリ呼び出しを使用する。これは、68000、68010、および68832ターゲットのデフォルトである。 FPUを持たないColdFireデバイスのデフォルト値でもある。

@item -mdiv
@itemx -mno-div
@opindex mdiv
@opindex mno-div
ColdFireのハードウェア除算および剰余命令を生成する（生成しない）。@option{-mcpu}を使用せずに@option{-march}を使用すると、デフォルトはColdFireアーキテクチャでは「オン」、M680x0アーキテクチャでは「オフ」になる。
それ以外の場合、デフォルトはターゲットCPU（デフォルトCPUか@option{-mcpu}で指定されたCPU）から取得される。  たとえば、デフォルトは、@option{-mcpu = 5206}では「オフ」、@option{-mcpu = 5206e}では「オン」である。

GCCは、このオプションを有効にするとマクロ@code{__ mcfhwdiv__}を定義する。

@item -mshort
@opindex mshort
@code{int}型は、@code{short int}のように、16ビット幅であるとみなす。さらに、スタック上で渡されるパラメータは、APIが32ビットへの昇格を要求するターゲットであっても、16ビット境界にアライメントされる。

@item -mno-short
@opindex mno-short
@code{int}型を16ビット幅とみなさない。 これがデフォルトである。

@item -mnobitfield
@itemx -mno-bitfield
@opindex mnobitfield
@opindex mno-bitfield
ビットフィールド命令は使用しない。 @option{-m68000}、@option{-mcpu32}、@option{-m5200}のオプションは@w{@option{-mnobitfield}}を含む。

@item -mbitfield
@opindex mbitfield
ビットフィールド命令を使用する。 @option{-m68020}オプションは、@option{-mbitfield}を含む。これは、68020用に設計された構成を使用する場合のデフォルトである。

@item -mrtd
@opindex mrtd
異なる関数呼び出し規約を使い、引数の数が固定されている関数が@code{rtd}命令で返されるようにする。 これにより、引数をポップする必要がないため、呼び出し元に1つの命令が節約される。

この呼び出し規約は、Unixで通常使用されているものとは互換性がないため、Unixコンパイラでコンパイルされたライブラリを呼び出す必要がある場合は使用できない。

また、可変数の引数（@code{printf}を含む）をとるすべての関数の関数プロトタイプを提供する必要がある。 さもなければ、それらの関数への呼び出しに対して誤ったコードが生成される。

さらに、あまりにも多くの引数を指定して関数を呼び出すと、コードが誤って不正確になる。 （通常、余分な引数は無害に無視される。）

@code{rtd}命令は、68010、68020、68030、68040、68060、およびCPU32プロセッサで動作するが、68000または5200では動作しない。

@item -mno-rtd
@opindex mno-rtd
@option{-mrtd}によって選択された呼び出し規約を使用しない。これがデフォルトである。

@item -malign-int
@itemx -mno-align-int
@opindex malign-int
@opindex mno-align-int
GCCが@code{int}、@code{long}、@code{long long}、@code{float}、@code{double}、@code{long double}を32ビット境界にするか（@option {-mnn-align-int}）および16ビット境界にするか（@option {-mine-align-int}）を指定する。32ビット境界で変数を調整すると、32ビットバスのプロセッサでより高速に実行されるコードが生成され、メモリが増える。

@strong{警告：} @option{-malign-int}スイッチを使用すると、GCCは、上記の型を含む構造体を、m68kの公開アプリケーションバイナリインタフェース仕様とは異なる方法で整列する。

@item -mpcrel
@opindex mpcrel
グローバルオフセットテーブルを使用する代わりに、68000のpc相対アドレッシングモードを直接使用する。 現在のところ、このオプションは@option{-fpic}を意味し、PC相対アドレッシングでは最大16ビットのオフセットが可能である。 @option{-fPIC}は現在、@option{-mpcrel}でサポートされていないが、これは68020以上のプロセッサでサポートされる可能性がある。

@item -mno-strict-align
@itemx -mstrict-align
@opindex mno-strict-align
@opindex mstrict-align
アライメントされていないメモリ参照がシステムによって処理されるとは仮定しない（する）。

@item -msep-data
データセグメントをテキストセグメントとは異なるメモリ領域に配置できるようにするコードを生成する。これにより、仮想メモリ管理のない環境での実行が可能になる。 このオプションは@option{-fPIC}を含む。

@item -mno-sep-data
データセグメントがテキストセグメントに続くことを前提とするコードを生成する。 これがデフォルトである。

@item -mid-shared-library
ライブラリIDメソッドを介して共有ライブラリをサポートするコードを生成する。これにより、仮想メモリー管理のない環境で、現場で実行されたライブラリーおよび共用ライブラリーが可能になる。 このオプションは@option{-fPIC}を含む。

@item -mno-id-shared-library
IDベースの共有ライブラリが使用されていることを前提としないコードを生成します。これがデフォルトである。

@item -mshared-library-id=n
コンパイルされるIDベースの共有ライブラリの識別番号を指定する。 0の値を指定すると、よりコンパクトなコードが生成される。 他の値を指定すると、その番号を現在のライブラリに強制的に割り当てることができるが、このオプションを省略するよりもスペースや時間効率が高くならない。

@item -mxgot
@itemx -mno-xgot
@opindex mxgot
@opindex mno-xgot
ColdFireの位置非依存コードを生成する場合、GOTに8192を超えるエントリがある場合に動作するコードを生成する。 このコードは、このオプションを指定せずに生成されたコードよりも大きく、処理速度が遅くなる。 M680x0プロセッサでは、このオプションは不要である。 @option {-fPIC}で十分である。

GCCは通常、単一の命令を使用してGOTから値をロードする。これは比較的効率的だが、GOTが約64kより小さい場合にのみ機能する。 大きな値を指定すると、リンカーは次のようなエラーを報告する。

@cindex relocation truncated to fit (ColdFire)
@smallexample
relocation truncated to fit: R_68K_GOT16O foobar
@end smallexample

このような場合は、コードを@option{-mxgot}で再コンパイルする必要がある。それは非常に大きなGOTで動作するはずである。 しかし、@option{-mxgot}で生成されたコードは、大域シンボルの値をフェッチするために4つの命令を必要とするため、あまり効率的ではない。

GNUリンカの新しいバージョンを含むいくつかのリンカは、複数のGOTを作成してGOTエントリをソートできることに注意すること。 このようなリンカーがある場合は、8192個を超えるGOTエントリにアクセスする単一のオブジェクトファイルをコンパイルするときに@option{-mxgot}を使用するだけで済む。 それをするのは非常に少ない。

GCCが位置に依存しないコードを生成していない限り、これらのオプションは効果がない。

@item -mlong-jump-table-offsets
@opindex mlong-jump-table-offsets
@code{switch}テーブルでは32ビットのオフセットを使用する。 デフォルトでは、16ビットのオフセットが使用される。

@end table

@node MCore Options
@subsection MCoreオプション 
@cindex MCore options

これらはMotorola M * Coreプロセッサ用に定義された@samp{-m}オプションである。

@table @gcctabopt

@item -mhardlit
@itemx -mno-hardlit
@opindex mhardlit
@opindex mno-hardlit
2命令以下で実行できる場合は、コードストリームへ定数をインライン化する。

@item -mdiv
@itemx -mno-div
@opindex mdiv
@opindex mno-div
除算命令を使う。（デフォルトで有効である）

@item -mrelax-immediate
@itemx -mno-relax-immediate
@opindex mrelax-immediate
@opindex mno-relax-immediate
ビット操作での任意サイズの定数を許可する。

@item -mwide-bitfields
@itemx -mno-wide-bitfields
@opindex mwide-bitfields
@opindex mno-wide-bitfields
常にビットフィールドを@code{int}のサイズとして扱う。

@item -m4byte-functions
@itemx -mno-4byte-functions
@opindex m4byte-functions
@opindex mno-4byte-functions
強制的に全関数を4バイト境界に揃えさせる。

@item -mcallgraph-data
@itemx -mno-callgraph-data
@opindex mcallgraph-data
@opindex mno-callgraph-data
コールグラフ情報を生成する。

@item -mslow-bytes
@itemx -mno-slow-bytes
@opindex mslow-bytes
@opindex mno-slow-bytes
バイト数を読み取るときは、ワードアクセスを優先する。

@item -mlittle-endian
@itemx -mbig-endian
@opindex mlittle-endian
@opindex mbig-endian
リトルエンディアンターゲットのコードを生成する。

@item -m210
@itemx -m340
@opindex m210
@opindex m340
210プロセッサ用のコードを生成する。

@item -mno-lsim
@opindex mno-lsim
実行時のサポートが提供されていると仮定し、リンカのコマンドラインからシミュレータライブラリ（@file{libsim.a}）を省略する。

@item -mstack-increment=@var{size}
@opindex mstack-increment
単一のスタック増分操作の最大量を設定する。 大きな値を指定すると、大量のスタック領域を必要とする関数を含むプログラムの速度が向上する可能性があるが、スタックがあまりにも長くなると、セグメンテーション違反が発生する可能性がある。 デフォルト値は0x1000である。

@end table

@node MeP Options
@subsection MePオプション
@cindex MeP options

@table @gcctabopt

@item -mabsdiff
@opindex mabsdiff
2つのレジスタ間の絶対差である@code{abs}命令を有効にする。

@item -mall-opts
@opindex mall-opts
すべてのオプション命令（平均、乗算、除算、ビット演算、先行ゼロ、絶対差、最小/最大、クリップ、および彩度）を有効にする。

@item -maverage
@opindex maverage
2つのレジスタの平均を計算する@code{ave}命令を有効にする。

@item -mbased=@var{n}
@opindex mbased=
@var{n}バイト以下の変数は、デフォルトで@code{.based}セクションに置かれる。 ベースの変数はベースレジスタとして@code{$tp}レジスタを使い、@code{.based}セクションには128バイトの制限がある。

@item -mbitops
@opindex mbitops
ビット操作命令を有効にする。ビットテスト（@code{btstm}）、セット（@code{bsetm}）、クリア（@code{bclrm}）、反転（@code{bnotm}）、テスト・アンド・セット（@code{tas}）。

@item -mc=@var{name}
@opindex mc=
どのセクションの定数データが配置されるかを選択する。 @var{name}は@samp{tiny}、@samp{near}、@samp{far}である。

@item -mclip
@opindex mclip
@code{clip}命令を有効にする。 @option{-mclips}は、@option{-mminmax}も指定しないと便利ではないことに注意する。

@item -mconfig=@var{name}
@opindex mconfig=
組み込みコア構成の1つを選択する。各MePチップには1つ以上のモジュールがある。 各モジュールには、コアCPUと、さまざまなコプロセッサ、オプションの命令、および周辺機能がある。GCCの一部ではない@code{MeP-Integrator}ツールは、このオプションを通してこれらの設定を提供する。 このオプションを使用することは、対応するすべてのコマンドラインオプションを使用することと同じである。デフォルト設定は@samp{default}である。

@item -mcop
@opindex mcop
コプロセッサ命令を有効にする。 デフォルトでは、これは32ビットコプロセッサです。 コプロセッサは、通常、@option{-mconfig=}オプションで有効になることに注意。

@item -mcop32
@opindex mcop32
32ビットコプロセッサの命令を有効にする。

@item -mcop64
@opindex mcop64
64ビットコプロセッサの命令を有効にする。

@item -mivc2
@opindex mivc2
IVC2スケジューリングを有効にする。 IVC2は64ビットVLIWコプロセッサである。

@item -mdc
@opindex mdc
定数変数を@code {.near}セクションに配置する。

@item -mdiv
@opindex mdiv
@code{div}命令と@code{divu}命令を有効にする。

@item -meb
@opindex meb
ビッグエンディアンコードを生成する。

@item -mel
@opindex mel
リトルエンディアンコードを生成する。

@item -mio-volatile
@opindex mio-volatile
@code{io}属性でマークされた変数がvolatileとみなされることをコンパイラに伝える。

@item -ml
@opindex ml
デフォルトで@code{.far}セクションに変数を代入する。

@item -mleadz
@opindex mleadz
@code{leadz}（リーディングゼロ）命令を有効にする。

@item -mm
@opindex mm
デフォルトで@code{.near}セクションに変数を割り当てるようにする。

@item -mminmax
@opindex mminmax
@code{min}命令と@code{max}命令を有効にする。

@item -mmult
@opindex mmult
乗算命令と積和命令を有効にする。

@item -mno-opts
@opindex mno-opts
@option {-mall-opts}で有効になっているすべてのオプション命令を無効にする。

@item -mrepeat
@opindex mrepeat
低オーバーヘッドループで使用される@code{repeat}と@code{erepeat}命令を有効にする。

@item -ms
@opindex ms
すべての変数をデフォルトで@code{.tiny}セクションにする。このセクションには65536バイトの制限があることに注意。これらの変数へのアクセスは、@code{%gp}ベースレジスタを使用する。

@item -msatur
@opindex msatur
飽和命令を有効にする。 コンパイラは現在これ自身を生成しないが、このオプションは@code{as}のような他のツールとの互換性のために含まれている。

@item -msdram
@opindex msdram
既定のROMベースのランタイムの代わりにSDRAMベースのランタイムをリンクする。

@item -msim
@opindex msim
シミュレータランタイムライブラリをリンクする。

@item -msimnovec
@opindex msimnovec
シミュレータランタイムライブラリをリンクするが、リセットおよび例外ベクタとテーブルのビルトインサポートは除く。

@item -mtf
@opindex mtf
すべての関数をデフォルトで@code{.far}セクションにする。このオプションがなければ、関数はデフォルトで@code {.near}セクションになる。

@item -mtiny=@var{n}
@opindex mtiny=
@var{n}バイト以下の変数は@code{.tiny}セクションに割り当てられる。 これらの変数は、@code{$gp}ベースレジスタを使用する。このオプションのデフォルトは4だが、@code{.tiny}セクションには65536バイトの制限がある。

@end table

@node MicroBlaze Options
@subsection MicroBlazeオプション
@cindex MicroBlaze Options

@table @gcctabopt

@item -msoft-float
@opindex msoft-float
浮動小数点用のソフトウェアエミュレーションを使用する（デフォルト）。

@item -mhard-float
@opindex mhard-float
ハードウェア浮動小数点命令を使用します。

@item -mmemcpy
@opindex mmemcpy
ブロック・ムーブを最適化せず、@code{memcpy}を使う。

@item -mno-clearbss
@opindex mno-clearbss
このオプションは非推奨である。代わりに@option{-fno-zero-initialized-in-bss}を使うこと。

@item -mcpu=@var{cpu-type}
@opindex mcpu=
指定されたCPUの機能を使用し、そのCPUのスケジュールを設定する。サポートされている値は@samp{v@var{X}.@var{YY}.@var{Z}}の形式である。@var{X}はメジャーバージョン、@var{YY}はマイナーバージョン、 @var{Z}は互換コードである。値の例は、@samp{v3.00.a}, @samp{v4.00.b}, @samp{v5.00.a}, @samp{v5.00.b}, @samp{v5.00.b}, @samp{v6.00.a}。

@item -mxl-soft-mul
@opindex mxl-soft-mul
ソフトウェアの乗算エミュレーションを使用する。（デフォルト）

@item -mxl-soft-div
@opindex mxl-soft-div
ソフトウェアの除算エミュレーションを使用する。（デフォルト）

@item -mxl-barrel-shift
@opindex mxl-barrel-shift
ハードウェアのバレル・シフタを使う。

@item -mxl-pattern-compare
@opindex mxl-pattern-compare
パターン比較命令を使う。

@item -msmall-divides
@opindex msmall-divides
小さい符号付き整数除算にテーブル引き最適化を使う。

@item -mxl-stack-check
@opindex mxl-stack-check
このオプションは非推奨である。代わりに@option{-fstack-check}を使うこと。

@item -mxl-gp-opt
@opindex mxl-gp-opt
GP相対の@code{.sdata}/@code{.sbss}セクションを使用する。

@item -mxl-multiply-high
@opindex mxl-multiply-high
32x32乗算の上位部分には、高位乗算命令を使用する。

@item -mxl-float-convert
@opindex mxl-float-convert
ハードウェア浮動小数点変換命令を使う。

@item -mxl-float-sqrt
@opindex mxl-float-sqrt
ハードウェア浮動小数点平方根命令を使う。

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンターゲット用のコードを生成する。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンターゲット用のコードを生成する。

@item -mxl-reorder
@opindex mxl-reorder
並べ替え命令（swapとバイト反転ロード・ストア）を使う。

@item -mxl-mode-@var{app-model}
アプリケーションモデル@var{app-model}を選択する。妥当な値は
@table @samp
@item executable
通常の実行ファイル（デフォルト）、スタートアップコード@file{crt0.o}を使う。

@item xmdstub
xmdstubと呼ばれるザイリンクスマイクロプロセッサデバッガ（XMD）ベースのソフトウェア侵入型デバッグエージェントで使用できる。これは、スタートアップファイル@file{crt1.o}を使用し、プログラムの開始アドレスを0x800に設定する。

@item bootstrap
ブートローダーを使用してロードされるアプリケーション向け。このモデルでは、プロセッサリセットベクトルハンドラを含まない起動ファイル@file{crt2.o}を使用している。これは、アプリケーションではなくブートローダへのプロセッサリセットの制御を転送するのに適している。

@item novectors
MicroBlazeベクタを必要としないアプリケーション向け。 このオプションは、監視アプリケーション内で実行されているアプリケーションに役立つ場合がある。 このモデルでは、@file{crt3.o}をスタートアップファイルとして使用する。
@end table

オプション@option{-xl-mode-@var{app-model}}は、@option {-mxl-mode-@var {app-model}}の非推奨エイリアスである。

@end table

@node MIPS Options
@subsection MIPSオプション
@cindex MIPS options

@table @gcctabopt

@item -EB
@opindex EB
ビッグエンディアンコードを生成する。

@item -EL
@opindex EL
リトルエンディアンコードを生成する。これは@samp{mips*el-*-*}構成でのデフォルトである。

@item -march=@var{arch}
@opindex march
@var{arch}で走るコードを生成し、それは汎用MIPS ISの名前であるか、特定のプロセッサ名である。ISA名は
@samp{mips1}, @samp{mips2}, @samp{mips3}, @samp{mips4},
@samp{mips32}, @samp{mips32r2}, @samp{mips32r3}, @samp{mips32r5},
@samp{mips32r6}, @samp{mips64}, @samp{mips64r2}, @samp{mips64r3},
@samp{mips64r5}, @samp{mips64r6}。プロセッサ名は
@samp{4kc}, @samp{4km}, @samp{4kp}, @samp{4ksc},
@samp{4kec}, @samp{4kem}, @samp{4kep}, @samp{4ksd},
@samp{5kc}, @samp{5kf},
@samp{20kc},
@samp{24kc}, @samp{24kf2_1}, @samp{24kf1_1},
@samp{24kec}, @samp{24kef2_1}, @samp{24kef1_1},
@samp{34kc}, @samp{34kf2_1}, @samp{34kf1_1}, @samp{34kn},
@samp{74kc}, @samp{74kf2_1}, @samp{74kf1_1}, @samp{74kf3_2},
@samp{1004kc}, @samp{1004kf2_1}, @samp{1004kf1_1},
@samp{i6400},
@samp{interaptiv},
@samp{loongson2e}, @samp{loongson2f}, @samp{loongson3a},
@samp{m4k},
@samp{m14k}, @samp{m14kc}, @samp{m14ke}, @samp{m14kec},
@samp{m5100}, @samp{m5101},
@samp{octeon}, @samp{octeon+}, @samp{octeon2}, @samp{octeon3},
@samp{orion},
@samp{p5600},
@samp{r2000}, @samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{r4400},
@samp{r4600}, @samp{r4650}, @samp{r4700}, @samp{r6000}, @samp{r8000},
@samp{rm7000}, @samp{rm9000},
@samp{r10000}, @samp{r12000}, @samp{r14000}, @samp{r16000},
@samp{sb1},
@samp{sr71000},
@samp{vr4100}, @samp{vr4111}, @samp{vr4120}, @samp{vr4130}, @samp{vr4300},
@samp{vr5000}, @samp{vr5400}, @samp{vr5500},
@samp{xlr}, @samp{xlp}.
特別な値@samp{from-abi}は、選択されたABI（つまり、32ビットABIでは@samp{mips1}、64ビットABIでは@samp{mips3}）に対して最も互換性の高いアーキテクチャを選択する。

ネイティブのLinux/GNUツールチェーンは、@samp{native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。gccがプロセッサを認識しない場合、@option{-march = native}は効果がない。

プロセッサ名では、最終的な@samp{000}を@samp{k}と省略することができる（たとえば、@option{-march = r2k}）。 接頭辞はオプションで、@samp {vr}は@samp{r}と書くことができる。

@samp{@var{n}f2_1}という形式の名前は、コアの半分の速度でクロックされるFPUを持つプロセッサを指し、@samp{@var{n}f1_1}形式の名前は、コアと同じ速度でクロックされるFPUを持つプロセッサを指し、@samp{@var{n}f3_2}の形式の名前は、コアに対してFPUが3：2でクロックされているプロセッサを指す。互換性のため、@samp{@var{n}f}は@samp{@var{n}f2_1}の同義語として受け入れられ、@samp{@var{n}x}と@samp{@var{fx}}は@samp{@var{n}f1_1}の同義語として受け入れられる。

GCCは、このオプションの値に基づいて2つのマクロを定義する。最初は@code{_MIPS_ARCH}で、ターゲットアーキテクチャの名前を文字列で示す。2番目の形式は@code{_MIPS_ARCH_@var{foo}}の形式で、ここで@var{foo}は@code{_MIPS_ARCH}の大文字の値である。たとえば、@option{-march = r2000}は@code{_MIPS_ARCH}を@code{"r2000"}に設定し、マクロ@code{_MIPS_ARCH_R2000}を定義する。

@code {_MIPS_ARCH}マクロは、上記のプロセッサ名を使用することに注意せよ。つまり、完全な接頭辞を持ち、@samp{000}を@samp{k}と省略しない。@samp{from-abi}の場合、マクロは解決されたアーキテクチャ（@code{"mips1"}または@code{"mips3"}）に名前を付けます。それは@option{-march}オプションが指定されていない場合のデフォルトアーキテクチャに名前を与える。

@item -mtune=@var{arch}
@opindex mtune
@var{arch}のために最適化する。 とりわけ、このオプションは、命令のスケジューリング方法と、算術演算の知覚されるコストを制御する。 @var{arch}値のリストは、@option{-march}と同じである。

このオプションを使用しないと、GCCは@option{-march}で指定されたプロセッサに対して最適化する。 @option{-march}と@option {-mtune}を一緒に使用することで、プロセッサファミリ上で動作するが、そのファミリの特定のメンバのコードに最適化するコードを生成できる。

@option{-mtune}はマクロ@code {_MIPS_TUNE}と@code{_MIPS_TUNE_@var{foo}}を定義する。これらは上記の@option{-march}と同様に動作する。

@item -mips1
@opindex mips1
@option{-march=mips1}と等価である。

@item -mips2
@opindex mips2
@option{-march=mips2}と等価である。

@item -mips3
@opindex mips3
@option{-march=mips3}と等価である。

@item -mips4
@opindex mips4
@option{-march=mips4}と等価である。

@item -mips32
@opindex mips32
@option{-march=mips32}と等価である。

@item -mips32r3
@opindex mips32r3
@option{-march=mips32r3}と等価である。

@item -mips32r5
@opindex mips32r5
@option{-march=mips32r5}と等価である。

@item -mips32r6
@opindex mips32r6
@option{-march=mips32r6}と等価である。

@item -mips64
@opindex mips64
@option{-march=mips64}と等価である。

@item -mips64r2
@opindex mips64r2
@option{-march=mips64r2}と等価である。

@item -mips64r3
@opindex mips64r3
@option{-march=mips64r3}と等価である。

@item -mips64r5
@opindex mips64r5
@option{-march=mips64r5}と等価である。

@item -mips64r6
@opindex mips64r6
@option{-march=mips64r6}と等価である。

@item -mips16
@itemx -mno-mips16
@opindex mips16
@opindex mno-mips16
MIPS16コードを生成する（しない）。GCCがMIPS32またはMIPS64アーキテクチャをターゲットにしている場合は、MIPS16e ASEを使用する。

MIPS16コードの生成は、@code{mips16}属性と@code{nomips16}属性を使用して、関数ごとに制御することもできる。さらなる情報は@xref{Function Attributes}.

@item -mflip-mips16
@opindex mflip-mips16
交代関数でMIPS16コードを生成する。 このオプションは、MIPS16/非MIPS16混在コード生成の回帰テスト用に提供されていて、ユーザーコードのコンパイルでは通常の使用を意図したものではない。

@item -minterlink-compressed
@itemx -mno-interlink-compressed
@opindex minterlink-compressed
@opindex mno-interlink-compressed
標準（非圧縮）MIPS ISAを使用してそのコードをMIPS16およびmicroMIPSコードとリンク互換にすることを要求する（しない）。

たとえば、標準のISAエンコーディングを使用するコードは、MIPS16またはmicroMIPSコードに直接ジャンプすることはできない。 コールまたは間接ジャンプを使用する必要がある。@option{-minterlink-compressed}はジャンプのターゲットが圧縮されていないことをGCCが知っていない限り直接ジャンプを無効にする。

@item -minterlink-mips16
@itemx -mno-interlink-mips16
@opindex minterlink-mips16
@opindex mno-interlink-mips16
@option{-minterlink-compressed}と@option{-mno-interlink-compressed}の別名。 これらのオプションは、microMIPS ASEより前からあり、下位互換性のために保持されている。

@item -mabi=32
@itemx -mabi=o64
@itemx -mabi=n32
@itemx -mabi=64
@itemx -mabi=eabi
@opindex mabi=32
@opindex mabi=o64
@opindex mabi=n32
@opindex mabi=64
@opindex mabi=eabi
与えられたABI用のコードを生成する。

EABIには32ビット版と64ビット版がある。 GCCは通常、64ビットアーキテクチャを選択すると64ビットコードを生成するが、代わりに@option{-mgp32}を使用して32ビットコードを得ることができる。

O64ABIについては@uref{http://gcc.gnu.org/@/projects/@/mipso64-abi.html}参照。

GCCは浮動小数点レジスタが32ビット幅ではなく64ビットであるo32 ABIの変形をサポートしている。 この組み合わせは、@option{-mabi=32} @option{-mfp64}で選択できる。 このABIは@code{mthc1}命令と@code{mfhc1}命令に依存しているため、MIPS32R2、MIPS32R3、MIPS32R5プロセッサでのみサポートされている。

引数と戻り値のレジスタ割り当ては同じだが、各スカラー値は1組の32ビットレジスタではなく1つの64ビットレジスタに渡される。 たとえば、スカラー浮動小数点値は@samp{$f0}/@samp{$f1}のペアではなく、@samp{$f0}にのみ返される。 また、偶数番号の倍精度レジスタが保存されるため、コールセーブされたレジスタのセットは同じままである。

32ビットから64ビットのレジスタへの遷移を可能にするために、o32 ABIの2つの追加の変種がサポートされている。 FPXX（@option{-mfpxx}）とFP64A（@option{-mfp64} @option {-mno-odd-spreg}）である。
FPXX拡張機能では、32ビットまたは64ビットのレジスタを使用して実行する場合、すべてのコードを正しく実行する必要がある。 コードは、FP32またはFP64のいずれかで相互にリンクできるが、両方ではリンクできない。FP64A拡張はFP64拡張と似ているが、奇数番号の単精度レジスタは使用できない。 これは、MIPS32R5プロセッサのFPUの@code{FRE}モードと組み合わせて使用することができ、FP32とFP64Aの両方のコードをFPUモードを変更せずに同じプロセスで相互リンクして実行することができる。

@item -mabicalls
@itemx -mno-abicalls
@opindex mabicalls
@opindex mno-abicalls
SVR4スタイルの動的オブジェクトに適したコードを生成する（しない）。 @option{-mabicalls}はSVR4ベースのシステムのデフォルトである。

@item -mshared
@itemx -mno-shared
完全な位置に依存せず、したがって共有ライブラリにリンクできるコードを生成する（しない）。 このオプションは@option{-mabicalls}にのみ影響する。

すべての@option{-mabicalls}コードは、@option{-fPIC}や@option {-fpic}のようなオプションにかかわらず、伝統的に位置に依存しなかった。 しかし、拡張として、GNUツールチェーンは、実行可能ファイルがローカルバインディングシンボルに絶対アクセスを使用できるようにする。 より短いGP初期化シーケンスを使用して、ローカル定義関数への直接呼び出しを生成することもできる。 このモードは、@option{-mno-shared}によって選択されます。

@option{-mno-shared}はbinutils 2.16以降に依存し、GNUリンカーによってのみリンクできるオブジェクトを生成する。 ただし、このオプションは最終実行可能ファイルのABIには影響しない。 再配置可能オブジェクトのABIにのみ影響する。 @option{-mno-shared}を使うと、一般的に実行ファイルのサイズが小さくなり、速くなる。

@option{-mshared}がデフォルトである。

@item -mplt
@itemx -mno-plt
@opindex mplt
@opindex mno-plt
静的リンカーと動的リンカーがPLTとコピーの再配置をサポートしていると仮定する（しない）。 このオプションは@option{-mno-shared -mabicalls}にのみ影響する。 n64 ABIの場合、このオプションは@option{-msym32}なしでは効果がない。


@option{-with-mips-plt}でGCCを構成することで、@option{-mplt}をデフォルトにすることができる。デフォルトは、@option{-mno-plt}である。

@item -mxgot
@itemx -mno-xgot
@opindex mxgot
@opindex mno-xgot
グローバルオフセットテーブルのサイズに関する通常の制限を持ち上る（持ち上げない）。

GCCは通常、単一の命令を使用してGOTから値をロードする。これは比較的効率的だが、GOTが約64kより小さい場合にのみ機能する。 大きな値を指定すると、リンカーは次のようなエラーを報告する。

@cindex relocation truncated to fit (MIPS)
@smallexample
relocation truncated to fit: R_MIPS_GOT16 foobar
@end smallexample

このような場合は、コードを@option{-mxgot}で再コンパイルする必要がある。これは非常に大きなGOTで動作するが、グローバルシンボルの値をフェッチするには3つの命令が必要なため、コードの効率も悪い。

いくつかのリンカは複数のGOTを作成できることに注意せよ。 このようなリンカーがある場合は、単一のオブジェクトファイルが64kを超えるGOTエントリにアクセスする場合にのみ、@option{-mxgot}を使用する必要がある。非常に少ない。

GCCが位置独立コードを生成しない限り、これらのオプションは効果がない。

@item -mgp32
@opindex mgp32
汎用目的レジスタが32ビット長であると仮定する。

@item -mgp64
@opindex mgp64
汎用目的レジスタが64ビット長であると仮定する。

@item -mfp32
@opindex mfp32
浮動小数点レジスタが32ビット長であると仮定する。

@item -mfp64
@opindex mfp64
浮動小数点レジスタが64ビット長であると仮定する。

@item -mfpxx
@opindex mfpxx
浮動小数点レジスタの幅を仮定しない。

@item -mhard-float
@opindex mhard-float
浮動小数点コプロセッサ命令を使う。

@item -msoft-float
@opindex msoft-float
浮動小数点コプロセッサ命令を使わない。代わりにライブラリ呼び出しを使って浮動小数点計算を実装する。

@item -mno-float
@opindex mno-float
@option{-msoft-float}と同等だが、コンパイルされるプログラムが浮動小数点演算を実行しないことをさらに主張する。このオプションは現在、一部のベアメタルMIPS構成でのみサポートされている。ここでは、すべての浮動小数点サポート（浮動小数点@code{printf}形式など）が不足している特別なライブラリセットを選択できる。@option{-mno-float}でコンパイルされたコードに、誤って浮動小数点演算が含まれていると、リンク時または実行時にエラーが発生する可能性がある。

@item -msingle-float
@opindex msingle-float
単精度操作のみをサポートする浮動小数点コプロセッサを仮定する。

@item -mdouble-float
@opindex mdouble-float
倍精度操作をサポートする浮動小数点コプロセッサを仮定する。これはデフォルトである。

@item -modd-spreg
@itemx -mno-odd-spreg
@opindex modd-spreg
@opindex mno-odd-spreg
o32 ABIに奇数番号の単精度浮動小数点レジスタを使用可能にする。 これは、これらのレジスタをサポートすることが知られているプロセッサのデフォルトである。 o32 FPXX ABIを使用する場合、デフォルトで@option{-mno-odd-spreg}が設定される。

@item -mabs=2008
@itemx -mabs=legacy
@opindex mabs=2008
@opindex mabs=legacy
これらのオプションは、特別な非数（NaN）IEEE 754浮動小数点データの処理を、@code{abs.@i{fmt}}および@code{neg.@i{fmt}}マシン命令で制御する。

デフォルトで、または@option{-mabs=legacy}を使用すると、従来の処置が選択される。 この場合、これらの命令は算術演算とみなされ、入力オペランドがNaNかもしれず、正しい演算が必要な場合は避けてるべきである。 @option{-ffinite-math-only}オプションも指定されていない限り、手動で浮動小数点データの符号ビットを操作するより長い一連の命令が代わりに使用される。

@option{-mabs=2008}オプションは、IEEE 754-2008処理を選択する。 この場合、これらの命令は非算術とみなされ、したがって、特に入力オペランドがNaNの場合を含むすべての場合において正しく動作する。 したがって、これらの命令は、それぞれの操作に常に使用される。

@item -mnan=2008
@itemx -mnan=legacy
@opindex mnan=2008
@opindex mnan=legacy
これらのオプションは、特殊非数（NaN）IEEE 754浮動小数点データのエンコードを制御する。

@option{-mnan=legacy}オプションは、レガシーエンコーディングを選択する。 この場合、静かなNaN（qNaNs）は、後続の仮数フィールドの最初のビットが0であると示され、シグナリングNaN（sNaNs）は、後続の仮数フィールドの最初のビットが1で表される。

@option{-mnan=2008}オプションは、IEEE 754-2008エンコーディングを選択する。 この場合、qNaNsは、後続の仮数フィールドの最初のビットが1であり、sNaNsは、後続の仮数フィールドの最初のビットが0であることによって示される。

GCCが@option{-with-nan=2008}で構成されていない限り、デフォルトは@option{-mnan=legacy}である。

@item -mllsc
@itemx -mno-llsc
@opindex mllsc
@opindex mno-llsc
アトミックメモリの組み込み関数を実装するために、@samp{ll}、@samp{sc}、@samp{sync}命令を使用しない。いずれのオプションも指定されていない場合、GCCはターゲットアーキテクチャがそれらをサポートしていればその命令を使用する。

@option{-mllsc}は、ランタイム環境で命令をエミュレートできる場合に便利である。また、非標準のISA用にコンパイルする場合は、@option{-mno-llsc}を使用すると便利である。 GCCを@option{-with-llsc}と@option{-without-llsc}でそれぞれ構成することで、いずれかのオプションをデフォルトにすることができる。 @option{-with-llsc}はいくつかの設定ではデフォルトである。 詳細については、インストールマニュアルを参照せよ。

@item -mdsp
@itemx -mno-dsp
@opindex mdsp
@opindex mno-dsp
MIPS DSP ASEのリビジョン1を使用する（しない）。@xref{MIPS DSP Built-in Functions}
このオプションはプリプロセッサマクロ@code{__mips_dsp}を定義する。 また、@code{__mips_dsp_rev}を1に定義する。

@item -mdspr2
@itemx -mno-dspr2
@opindex mdspr2
@opindex mno-dspr2
MIPS DSP ASEのリビジョン2を使用する（しない）。@xref{MIPS DSP Built-in Functions}
このオプションはプリプロセッサマクロ@code{__mips_dsp}を定義する。 また、@code{__mips_dsp_rev}を2に定義する。

@item -msmartmips
@itemx -mno-smartmips
@opindex msmartmips
@opindex mno-smartmips
MIPS SmartMIPS ASEを使用する（しない）。

@item -mpaired-single
@itemx -mno-paired-single
@opindex mpaired-single
@opindex mno-paired-single
組単精度命令を使用する（しない）。@xref{MIPS Paired-Single Support} このオプションはハードウェア浮動小数点サポートを有効にする必要がある。

@item -mdmx
@itemx -mno-mdmx
@opindex mdmx
@opindex mno-mdmx
MIPSデジタルメディア拡張命令を使用する（しない）。このオプションは64ビットコードを生成し、ハードウェア浮動小数点サポートを有効にする必要がある。

@item -mips3d
@itemx -mno-mips3d
@opindex mips3d
@opindex mno-mips3d
MIPS-3D ASEを使用する（しない）。@xref{MIPS-3D Built-in Functions} オプション@option{-mips3d}は@option{-mpaired-single}を含む。

@item -mmicromips
@itemx -mno-micromips
@opindex mmicromips
@opindex mno-mmicromips
microMIPSコードを生成する（しない）。

microMIPSコードの生成は、@code{micromips}属性と@code {nomicromips}属性を使用して、関数ごとに制御することもできる。
さらなる情報は、@xref{Function Attributes}

@item -mmt
@itemx -mno-mt
@opindex mmt
@opindex mno-mt
MTマルチスレッド命令を使用する（しない）。

@item -mmcu
@itemx -mno-mcu
@opindex mmcu
@opindex mno-mcu
MIPS MCU ASE命令を使用する（しない）。

@item -meva
@itemx -mno-eva
@opindex meva
@opindex mno-eva
MIPS拡張仮想アドレス命令を使用する（しない）。

@item -mvirt
@itemx -mno-virt
@opindex mvirt
@opindex mno-virt
MIPS仮想化(VZ)命令を使用する（しない）。

@item -mxpa
@itemx -mno-xpa
@opindex mxpa
@opindex mno-xpa
MIPS拡張物理アドレス（XPA）命令を使用する（しない）。

@item -mlong64
@opindex mlong64
@code{long}型を64ビット長に強制する。デフォルトの説明とポインタサイズの決定方法は
@option{-mlong32}を見よ。

@item -mlong32
@opindex mlong32
@code{long}, @code{int}, ポインタサイズを32ビット長に強制する。

@code{int}と@code{long}のデフォルトサイズはABIに依存する。サポートされている全ABIは32ビットの@code{int}を使う。n64 ABIは64ビットの@code{long}を使う、EABIもそうする。他は32ビットの@code{long}を使う。ポインタは@code{long}と同じサイズか、整数レジスタと同じサイズの、小さい方である。

@item -msym32
@itemx -mno-sym32
@opindex msym32
@opindex mno-sym32
全シンボルが、選択されたABIにかかわらず、32ビット値を持つと仮定する（しない）。このオプションは、@option{-mabi=64}と@option{-mno-abicalls}と組み合わせて使用すると、GCCがシンボリックアドレスへのより短い、より速い参照を生成できるので便利である。

@item -G @var{num}
@opindex G
そのデータが@var{num}バイトより大きくない場合は、外部データの定義を小さなデータセクションに置く。 GCCは、データへのより効率的なアクセスを生成することができる。 詳細は@option{-mgpopt}を参照。

デフォルトの@option{-G}オプションは構成によって異なる。

@item -mlocal-sdata
@itemx -mno-local-sdata
@opindex mlocal-sdata
@opindex mno-local-sdata
@option{-G}の振る舞いをCの静的変数など、ローカルデータにも拡張する（しない）。 @option{-mlocal-sdata}はすべての構成のデフォルトである。

リンカーが、アプリケーションが小さすぎるデータを使用していると不平を言う場合は、@option{-mno-local-sdata}を使用してパフォーマンスが重要でない部分を再構築したいかもしれない。 また、@option{-mno-local-sdata}を使用して大きなライブラリを構築して、ライブラリがメインプログラムのための余地を残したかもしれない。

@item -mextern-sdata
@itemx -mno-extern-sdata
@opindex mextern-sdata
@opindex mno-extern-sdata
そのデータのサイズが@option{-G}の範囲内にある場合、外部定義されたデータが小さなデータセクションにあると仮定する（しない）。@option{-mextern-sdata}はすべての構成のデフォルトである。

@option{-mextern-sdata} @option{-G @var{num}} @option{-mgpopt}でモジュール@var{Mod}をコンパイルし、@var{Mod}が@var{num}バイトより大きくない変数@var{Var}を参照しているならば、@var{Var}が小さなデータセクションに配置されていることを確認する必要がある。 @var{Var}が別のモジュールで定義されている場合は、十分な大きい@option{-G}設定でモジュールをコンパイルするか、@var{Var}の定義に@code{section}属性を付加する必要がある。 @var{Var}が共通の場合は、アプリケーションを十分な大きさの@option{-G}設定でリンクする必要がある。

これらの制限を満たす最も簡単な方法は、すべてのモジュールを同じ@option{-G}オプションでコンパイルしてリンクすることである。 ただし、いくつかの小さなデータ制限をサポートするライブラリを構築することもできる。 サポートされている最高の@option{-G}設定を使用してライブラリをコンパイルし、さらに@option{-mno-extern-sdata}を使用して、ライブラリが外部定義データに関する前提を作成するのを止めることで、これを行うことができる。

@item -mgpopt
@itemx -mno-gpopt
@opindex mgpopt
@opindex mno-gpopt
小さなデータセクションにあることが分かっているシンボルには、GP相対アクセスを使用する（しない）。 @option {-G}、@option{-mlocal-sdata}、@option{-mextern-sdata}参照。 @option {-mgpopt}はすべての構成のデフォルトである。

@option{-mno-gpopt}は、@code{$gp}レジスタが@code{_gp}の値を保持しない場合に便利である。 たとえば、コードがブートモニターで使用されるライブラリーの一部である場合、ブートモニタールーチンを呼び出すプログラムは、未知の値を@code{$gp}に渡す。（このような状況では、通常ブートモニター自体は@option{-G0}でコンパイルされる）。

@option{-mno-gpopt}は@option{-mno-local-sdata}と@option{-mno-extern-sdata}を含む。

@item -membedded-data
@itemx -mno-embedded-data
@opindex membedded-data
@opindex mno-embedded-data
可能であれば、読み取り専用データセクションに変数を割り当て、可能であれば小さなデータセクションに次に変数を割り当て、それ以外の場合はデータに割り当てる。 これは、デフォルトよりもわずかに遅いコードを提供するが、実行時に必要なRAMの量が減るため、一部の組み込みシステムでは望ましいことがある。

@item -muninit-const-in-rodata
@itemx -mno-uninit-const-in-rodata
@opindex muninit-const-in-rodata
@opindex mno-uninit-const-in-rodata
読み込み専用データセクションに初期化されていない@code{const}変数を入れる。このオプションは@option{-membedded-data}との組み合わせでのみ意味がある。

@item -mcode-readable=@var{setting}
@opindex mcode-readable
GCCが実行可能セクションから読み込むコードを生成するかどうかを指定する。可能な設定は3つある。

@table @gcctabopt
@item -mcode-readable=yes
命令は自由に実行可能セクションにアクセスできる。これはデフォルトの設定である。

@item -mcode-readable=pcrel
MIPS16 PC相対ロード命令は実行可能セクションにアクセスできるが、他の命令ではできない。 このオプションは、コードTLBに読み取り禁止ビットが設定されている場合、4KScおよび4KSdプロセッサで有効である。 また、デュアル命令/データSRAMインタフェースを持つように構成することができ、M4Kと同様に、PC相対ロードを自動的に命令RAMにリダイレクトするプロセッサでも便利である。

@item -mcode-readable=no
命令は実行可能セクションにアクセスしてはならない。 このオプションは、デュアル命令/データSRAMインタフェースを持つように構成されているターゲットで有効だが、M4Kとは異なり、PC相対ロードを自動的に命令RAMにリダイレクトしない。
@end table

@item -msplit-addresses
@itemx -mno-split-addresses
@opindex msplit-addresses
@opindex mno-split-addresses
@code{％hi()}および@code{％lo()}アセンブラ再配置演算子の使用を有効（無効）化する。 このオプションは@option{-mexplicit-relocs}に取って代わられたが、下位互換性のために残されている。

@item -mexplicit-relocs
@itemx -mno-explicit-relocs
@opindex mexplicit-relocs
@opindex mno-explicit-relocs
シンボリックアドレスを扱う場合は、アセンブラ再配置演算子を使用する（しない）。 @option{-mno-explicit-relocs}で選択された代替は、代わりにアセンブラマクロを使用することである。

再配置オペレータをサポートするアセンブラを使用するようにGCCを設定した場合、@option{-mexplicit-relocs}がデフォルトである。

@item -mcheck-zero-division
@itemx -mno-check-zero-division
@opindex mcheck-zero-division
@opindex mno-check-zero-division
ゼロによる整数除算をトラップする（しない）。

デフォルトは@option{-mcheck-zero-division}である。

@item -mdivide-traps
@itemx -mdivide-breaks
@opindex mdivide-traps
@opindex mdivide-breaks
MIPSシステムは、条件付きトラップまたはブレーク命令のいずれかを生成することによってゼロ除算をチェックする。 トラップを使用すると、コードが小さくなるが、MIPS II以降でのみサポートされている。 また、Linuxカーネルのバージョンによっては、トラップが適切なシグナル（@code{SIGFPE}）を生成できないバグがある。 @option{-mdivide-traps}を使用すると、それらをサポートするアーキテクチャの条件付きトラップを許可し、@option{-mdivide-breaks}は強制的にブレークを使用できる。

デフォルトは通常@option{-mdivide-traps}だが、構成時に@option{-with-divide=breaks}を使用して上書きすることができる。
ゼロ除算は、@option{-mno-check-zero-division}を使用して完全に無効にすることができる。

@item -mload-store-pairs
@itemx -mno-load-store-pairs
@opindex mload-store-pairs
@opindex mno-load-store-pairs
ロード/ストア結合を有効にするために連続したロード命令またはストア命令をペアにする最適化を有効（無効）化する。 このオプションはデフォルトで有効になっているが、選択したアーキテクチャがボンディングをサポートすることがわかっている場合にのみ効果がある。

@item -mmemcpy
@itemx -mno-memcpy
@opindex mmemcpy
@opindex mno-memcpy
@code{memcpy}の使用が非自明なブロック移動になるよう強制する（しない）。 デフォルトは@option{-mno-memcpy}で、これはGCCがほとんど一定のサイズのコピーをインライン化することを可能にする。

@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
@code{jal}命令の使用を無効にする（しない）。 @code{jal}を使って関数を呼び出すほうが効率的だが、呼び出し元と呼び出し先が同じ256メガバイトのセグメントに存在する必要がある。

このオプションはabicallsコードには影響しない。 デフォルトは@option{-mno-long-calls}である。

@item -mmad
@itemx -mno-mad
@opindex mmad
@opindex mno-mad
R4650 ISAによって提供されている@code{mad}, @code{madu}, @code{mul}の使用を有効（無効）化する。

@item -mimadd
@itemx -mno-imadd
@opindex mimadd
@opindex mno-imadd
@code{madd}と@code{msub}整数命令の使用を有効（無効）化する。デフォルトは@code{madd}と@code{msub}をサポートするアーキテクチャでは@code{-mimadd}だが、例外は74kアーキテクチャで、そこではより遅いコードを生成することがわかっている。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
利用可能な場所では、浮動小数点乗加算命令の使用を有効（無効）化する。デフォルトでは@option{-mfused-madd}。

乗算累算命令が使用されている場合のR8000 CPUでは、中間積は無限精度に計算され、FCSRゼロからゼロへのビットの影響を受けない。 これは、場合によっては望ましくないことがある。 他のプロセッサでは、結果は、別々の乗算、加算、減算、および否定命令を使用した同等の計算と数値的に同じである。

@item -nocpp
@opindex nocpp
MIPSアセンブラにアセンブラを実行する前に、ユーザ・アセンブラ・ファイル（@samp{.s}接尾辞付き）に対してプリプロセッサを実行しないように指示する。

@item -mfix-24k
@itemx -mno-fix-24k
@opindex mfix-24k
@opindex mno-fix-24k
24K E48（リフィル中のストアでのデータ喪失）エラッタを回避する。回避策はGCCではなくアセンブラで実装されている。

@item -mfix-r4000
@itemx -mno-fix-r4000
@opindex mfix-r4000
@opindex mno-fix-r4000
いくつかのR4000 CPUでのエラッタを回避する。
@itemize @minus
@item
整数除算を開始した直後にダブルワードまたは可変シフトを実行すると、不正な結果が返されることがある。
@item
整数乗算が実行されている間にダブルワードまたは可変シフトが実行されると、不正な結果が返されることがある。
@item
分岐の分岐やジャンプの遅延スロットで開始された場合、整数除算で不正な結果が得られることがある。
@end itemize

@item -mfix-r4400
@itemx -mno-fix-r4400
@opindex mfix-r4400
@opindex mno-fix-r4400
いくつかのR4400 CPUでのエラッタを回避する。
@itemize @minus
@item
整数除算を開始した直後にダブルワードまたは可変シフトを実行すると、不正な結果が返されることがある。
@end itemize

@item -mfix-r10000
@itemx -mno-fix-r10000
@opindex mfix-r10000
@opindex mno-fix-r10000
いくつかのR10000 CPUでのエラッタを回避する。
@itemize @minus
@item
@code{ll}/@code{sc}シーケンスは、3.0より前のリビジョンではアトミックに動作しない。 2.6以前のリビジョンではデッドロックする可能性がある。
@end itemize

このオプションは、ターゲットアーキテクチャが分岐予測命令をサポートしている場合にのみ使用できる。 @option{-march = r10000}を使用すると、@option{-mfix-r10000}がデフォルトである。 そうでない場合、@option{-mno-fix-r10000}がデフォルトである。

@item -mfix-rm7000
@itemx -mno-fix-rm7000
@opindex mfix-rm7000
RM7000 @code{dmult}/@code{dmultu}エラッタを回避する。 回避策はGCCではなくアセンブラで実装されている。

@item -mfix-vr4120
@itemx -mno-fix-vr4120
@opindex mfix-vr4120
特定のVR4120エラッタを回避する：
@itemize @minus
@item
@code{dmultu}は必ずしも正しい結果を出すとは限らない。
@item
オペランドの1つが負の場合、@code{div}と@code{ddiv}は常に正しい結果を生成するとは限らない。
@end itemize
除算のエラッタの回避策は@file{libgcc.a}の特別な機能に依存している。 現在のところ、これらの関数は@code{mips64vr*-elf}の構成によってのみ提供される。

他のVR4120のエラッタでは、特定の命令ペアの間にNOPを挿入する必要がある。これらのエラッタはGCC自身ではなく、アセンブラで処理される。

@item -mfix-vr4130
@opindex mfix-vr4130
VR4130 @code{mflo}/@code{mfhi}エラッタを回避する。 回避策は、GCCではなくアセンブラで実装されているが、代わりにVR4130 @code{macc}、@code{macchi}、@code{dmacc}、@code{dmacchi}命令が利用可能な場合には、GCCは@code{mflo}と@code{mfhi}の使用を避ける。

@item -mfix-sb1
@itemx -mno-fix-sb1
@opindex mfix-sb1
特定のSB-1 CPUコアエラッタを回避する。（このフラグは現在、SB-1リビジョン2の 「F1」と 「F2」の浮動小数点エラッタで動作する）。

@item -mr10k-cache-barrier=@var{setting}
@opindex mr10k-cache-barrier
R10Kプロセッサで投機の副作用を避けるために、GCCがキャッシュバリアを挿入するかどうかを指定する。

多くのプロセッサーと共通して、R10Kは条件付き分岐の結果を予測し、 「取られた」分岐からの命令を投機的に実行しようとする。予測結果が間違っている場合は、後でこれらの命令を中止する。しかし、R10Kでは、中断された命令でさえも副作用が生じる可能性がある。

この問題はカーネルストアにのみ影響し、システムに応じてカーネルがロードされる。 一例として、投機的に実行されるストアは、ターゲットメモリをキャッシュにロードし、ストア自体が後で中断されたとしても、キャッシュラインを汚れたとマークし得る。 「汚れた」行がフラッシュされる前にDMA操作が同じメモリー領域に書き込むと、キャッシュされたデータはDMAされたデータを上書きする。 その他の潜在的な問題も含め、詳細な説明はR10Kプロセッサのマニュアルを参照せよ。

回避策の1つは、投機的に実行され、中止されても副作用を持つかもしれないメモリアクセスの前にキャッシュバリア命令を挿入することである。 @option{-mr10k-cache-barrier=@var{setting}}は、この回避策のGCC実装を制御する。次の領域のバイトへの中止されたアクセスには副作用がないものとする。

@enumerate
@item
現在の関数のスタックフレームが占めるメモリ。

@item
入ってくるスタック引数が占めるメモリ。

@item
リンク時定数アドレスのあるオブジェクトが占めるメモリ。
@end enumerate

これらの領域への投機的なアクセスが実際に安全であることを保証するのは、カーネルの責任である。

入力プログラムに次のような関数宣言が含まれているとする。

@smallexample
void foo (void);
@end smallexample

そのとき@code{foo}の実装は@code{j foo}と@code{jal foo}が投機的に実行されるようにする必要がある。 GCCはコンパイルする関数に対してこの制限を認めている。 GCC以外の関数（手書きのアセンブリコードなど）も同じことを期待する。

オプションは3形式ある。

@table @gcctabopt
@item -mr10k-cache-barrier=load-store
投機的に実行され、中止されても副作用を伴うかもしれないロードまたはストアの前にキャッシュ・バリアーを挿入する。

@item -mr10k-cache-barrier=store
投機的に実行され、中止されても副作用を伴うかもしれないストアの前にキャッシュ・バリアーを挿入する。

@item -mr10k-cache-barrier=none
キャッシュバリアの挿入を無効にする。 これがデフォルト設定である。
@end table

@item -mflush-func=@var{func}
@itemx -mno-flush-func
@opindex mflush-func
IおよびDキャッシュをフラッシュするために呼ぶ関数を指定するか、またはそのような関数を呼び出さないように指定する。 呼び出された場合、関数は共通の@code{_flush_func}と同じ引数、つまりキャッシュがフラッシュされるメモリ範囲のアドレス、メモリ範囲のサイズ、 両方のキャッシュ）。 デフォルトはターゲットGCCが設定されているかどうかによって異なるが、通常は@code{_flush_func}または@code{__ cpu_flush}である。

@item mbranch-cost=@var{num}
@opindex mbranch-cost
おおまかに@var{num}の「単純な」命令にブランチのコストを設定する。このコストはヒューリスティックであり、リリース間で一貫した結果を保証するものではない。 ゼロコストは、@option {-mtune}設定に基づくデフォルトを重複して選択する。

@item -mbranch-likely
@itemx -mno-branch-likely
@opindex mbranch-likely
@opindex mno-branch-likely

選択したアーキテクチャのデフォルトにかかわらず、分岐可能命令の使用を有効または無効にする。 デフォルトでは、選択されたアーキテクチャでサポートされている場合、分岐可能命令が生成されることがある。これらのアーキテクチャを実装するMIPS32およびMIPS64アーキテクチャとプロセッサは例外である。 MIPS32およびMIPS64アーキテクチャは特にその使用を非推奨にするため、分岐可能命令はデフォルトで生成されない

@item -mcompact-branches=never
@itemx -mcompact-branches=optimal
@itemx -mcompact-branches=always
@opindex mcompact-branches=never
@opindex mcompact-branches=optimal
@opindex mcompact-branches=always
これらのオプションは、生成される分岐の形式を制御する。 デフォルトは@option{-mcompact-branches=optimal}である。

@option{-mcompact-branches=never}オプションはコンパクトブランチ命令が生成されることがないことを保証する。
@option {-mcompact-branches = always}オプションを指定すると、使用可能なコンパクトブランチ命令が生成される。 コンパクト分岐命令が利用可能でない場合、代わりに分岐の遅延スロット形式が使用される。

このオプションは、MIPSリリース6以降でサポートされている。

@option{-mcompact-branches=optimal}オプションを指定すると、現在のISAで利用可能な遅延スロットがあれば、遅延スロットブランチが使用され、遅延スロットは正常に埋められる。 遅延スロットが満たされていない場合、使用可能なコンパクトブランチが選択される。

@item -mfp-exceptions
@itemx -mno-fp-exceptions
@opindex mfp-exceptions
FP例外を有効にするかどうかを指定する。 これは、FP命令がいくつかのプロセッサーにスケジュールされる方法に影響する。 デフォルトでは、FP例外が有効になっている。

たとえば、SB-1では、FP例外を無効にして64ビットコードを発行している場合は、両方のFPパイプを使用できる。 それ以外の場合は、FPパイプは1つしか使用できない。

@item -mvr4130-align
@itemx -mno-vr4130-align
@opindex mvr4130-align
VR4130パイプラインは2ウェイスーパスカラだが、最初のパイプラインが8バイトアライメントの場合は、2つの命令のみを発行できる。  このオプションを有効にすると、GCCは並列に実行する必要があると考えられる命令のペアを整列させる。

このオプションは、VR4130を最適化する場合にのみ有効である。通常はコードを高速化するが、コードの大きさは犠牲になる。デフォルトでは、最適化レベルの@option{-O3}で有効になる。

@item -msynci
@itemx -mno-synci
@opindex msynci
サポートするアーキテクチャで@code{synci}命令の生成を有効（無効）にする。 @code{__builtin___clear_cache}をコンパイルすると、@code{synci}命令（使用可能な場合）が生成される。

このオプションのデフォルトは@option{-mno-synci}だが、デフォルトはGCCを@option{-with-synci}で構成することで上書きすることができる。

シングルプロセッサシステム用のコードをコンパイルするときは、一般的に@code{synci}を使用しても安全である。 ただし、多くのマルチコア（SMP）システムでは、すべてのコアの命令キャッシュを無効にすることはなく、未定義の動作につながる可能性がある。

@item -mrelax-pic-calls
@itemx -mno-relax-pic-calls
@opindex mrelax-pic-calls
通常は@code{$25}のレジスタを使って直接呼び出されるPICコールをダイレクトコールにするようにする。 リンカがリンク時に宛先を解決でき、宛先が直接呼び出しの範囲内にある場合にのみ可能である。

GCCが@code{.reloc}アセンブリディレクティブをサポートし、@option{-mexplicit-relocs}が有効であるアセンブラとリンカを使用するように設定されている場合、@option{-mrelax-pic-calls}がデフォルトである。@option{-mno-explicit-relocs}を使用すると、コンパイラの助けを借りずにアセンブラとリンカだけでこの最適化を実行できる。

@item -mmcount-ra-address
@itemx -mno-mcount-ra-address
@opindex mmcount-ra-address
@opindex mno-mcount-ra-address
@code{_mcount}が呼び出し関数の戻りアドレスを変更できるようにするコードを発行する（しない）。このオプションを有効にすると、通常の@code{_count}インターフェイスが新しい@var{ra-address}パラメータで拡張される。このパラメータは、@code{intptr_t *}タイプであり、レジスタ@code{$ 2}に渡される。 @code{_mcount}は、次の両方を実行して戻りアドレスを変更できる。
@itemize
@item
新しいアドレスを登録する@code{$31}。
@item
@var{ra-address}がNULLでない場合、新しいアドレスを@code{*@ var{ra-address}}に格納する。
@end itemize

デフォルトは@option{-mno-mcount-ra-address}である。

@item -mframe-header-opt
@itemx -mno-frame-header-opt
@opindex mframe-header-opt
o32 ABIでフレームヘッダーの最適化を有効（無効）にする。o32 ABIを使用する場合、呼び出し関数は呼び出された関数のスタックに16バイトを割り当ててレジスタの引数を書き出す。この最適化を有効にすると、フレームヘッダーが未使用であると判断できる場合、この最適化によってフレームヘッダーの割り当てが抑制される。

この最適化は、デフォルトではすべての最適化レベルでオフになっている。

@item -mlxc1-sxc1
@itemx -mno-lxc1-sxc1
@opindex mlxc1-sxc1
該当する場合は、@code{lwxc1}、@code{swxc1}、@code{ldxc1}、@code{sdxc1}命令の生成を有効（無効）にする。 デフォルトでは有効である。

@item -mmadd4
@itemx -mno-madd4
@opindex mmadd4
該当する場合、4オペランド@code{madd.s}、@code{madd.d}および関連する命令の生成を有効（無効）にする。 デフォルトでは有効である。

@end table

@node MMIX Options
@subsection MMIXオプション
@cindex MMIX Options

これらのオプションは、MMIXに対して定義されている。

@table @gcctabopt
@item -mlibfuncs
@itemx -mno-libfuncs
@opindex mlibfuncs
@opindex mno-libfuncs
サイズに関係なく、すべての値をレジスタで渡し、組み込みライブラリ関数がコンパイルされると指定する。

@item -mepsilon
@itemx -mno-epsilon
@opindex mepsilon
@opindex mno-epsilon
@code{rE}イプシロンレジスタに関して比較する浮動小数点比較命令を生成する。

@item -mabi=mmixware
@itemx -mabi=gnu
@opindex mabi=mmixware
@opindex mabi=gnu
関数のパラメータを渡し、グローバルレジスタ@code{$231}以上を使用するGNU ABIとは対照的に（呼び出された関数内の）値をレジスタ@code{$0}以上で返すコードを生成する。

@item -mzero-extend
@itemx -mno-zero-extend
@opindex mzero-extend
@opindex mno-zero-extend
64ビットより短いサイズのメモリからデータを読み込むときは、符号拡張するのではなく、ゼロ拡張のロード命令をデフォルトで使用するい（しない）。

@item -mknuthdiv
@itemx -mno-knuthdiv
@opindex mknuthdiv
@opindex mno-knuthdiv
残余を生じる除算の結果を除数と同じ符号にする。 デフォルトの@option{-mno-knuthdiv}では、残りの符号は被除数の符号に従う。 両方の方法は算術的に有効であり、後者はほぼ独占的に使用される。

@item -mtoplevel-symbols
@itemx -mno-toplevel-symbols
@opindex mtoplevel-symbols
@opindex mno-toplevel-symbols
アセンブラコードを@code{PREFIX}アセンブリディレクティブと一緒に使用できるように、@samp{:}をすべてのグローバルシンボルの前に追加する（しない）。

@item -melf
@opindex melf
@command{mmix}シミュレータで使用されるデフォルトの@samp{mmo}フォーマットではなく、ELFフォーマットで実行可能ファイルを生成する。

@item -mbranch-predict
@itemx -mno-branch-predict
@opindex mbranch-predict
@opindex mno-branch-predict
静的分岐予測が分岐の可能性が高いことを示す場合に、分岐可能命令を使用する（しない）。

@item -mbase-addresses
@itemx -mno-base-addresses
@opindex mbase-addresses
@opindex mno-base-addresses
@emph{ベースアドレス}を使用するコードを生成する（しない）。ベースアドレスを使用すると、定数がグローバルレジスタに設定されるための要求（アセンブラとリンカによって処理される）が自動的に生成される。レジスタは、レジスタに保持されている値から0〜255の範囲内の1つ以上のベースアドレス要求に対して使用される。一般的に短くて速いコードにつながるが、対処できるさまざまなデータ項目の数は限られている。つまり、多くの静的データを使用するプログラムでは、@option{-mno-base-addresses}が必要になる場合がある。

@item -msingle-exit
@itemx -mno-single-exit
@opindex msingle-exit
@opindex mno-single-exit
生成されたコードに各関数の単一の終了点を強制する（しない）。
@end table

@node MN10300 Options
@subsection MN10300オプション
@cindex MN10300 options

これらの@option{-m}オプションは、Matsushita MN10300アーキテクチャ用に定義されている。

@table @gcctabopt
@item -mmult-bug
@opindex mmult-bug
MN10300プロセッサの乗算命令のバグを回避するコードを生成する。 これがデフォルトである。

@item -mno-mult-bug
@opindex mno-mult-bug
MN10300プロセッサの乗算命令のバグを回避するコードを生成しない。

@item -mam33
@opindex mam33
AM33プロセッサ固有の機能を使用してコードを生成する。

@item -mno-am33
@opindex mno-am33
AM33プロセッサ固有の機能を使用してコードを生成しない。 これがデフォルトである。

@item -mam33-2
@opindex mam33-2
AM33/2.0プロセッサ固有の機能を使用してコードを生成する。

@item -mam34
@opindex mam34
AM34プロセッサ固有の機能を使用してコードを生成する。

@item -mtune=@var{cpu-type}
@opindex mtune
命令をスケジューリングするときは、指定されたCPUタイプのタイミング特性を使用する。 これは、対象のプロセッサタイプを変更しない。 CPUタイプは@samp{mn10300}、@samp{am33}、@samp{am33-2}、@samp{am34}のいずれかでなければならない。

@item -mreturn-pointer-on-d0
@opindex mreturn-pointer-on-d0
ポインタを返す関数を生成するときは、ポインタを@code{a0}と@code{d0}の両方に返す。 そうでなければ、ポインタは@code{a0}でのみ返され、プロトタイプなしでそのような関数を呼び出そうとするとエラーが発生する。 このオプションはデフォルトでオンになっている。 @option{-mno-return-pointer-on-d0}を使用して無効にする。

@item -mno-crt0
@opindex mno-crt0
Cランタイム初期化オブジェクトファイルにはリンクしない。

@item -mrelax
@opindex mrelax
分岐、呼び出し、および絶対メモリアドレスを短縮するリラクゼーション最適化パスを実行する必要があることをリンカーに示す。 このオプションは、最終リンクステップのコマンドライン使用でのみ効果がある。

このオプションはシンボリックデバッグを不可能にする。

@item -mliw
@opindex mliw
ターゲットが@samp {AM33}以上の場合、コンパイラが@emph{ロング命令ワード}命令を生成できるようにする。 これがデフォルトである。 このオプションはプリプロセッサマクロ@code{__LIW__}を定義する。

@item -mnoliw
@opindex mnoliw
コンパイラが@emph{ロング命令ワード}命令を生成することを許可しない。 このオプションはプリプロセッサマクロ@code{__NO_LIW__}を定義する。

@item -msetlb
@opindex msetlb
ターゲットが@samp{AM33}以降の場合、コンパイラが@emph{SETLB}命令と@emph{Lcc}命令を生成できるようにする。 これがデフォルトである。 このオプションはプリプロセッサマクロ@code{__SETLB__}を定義する。

@item -mnosetlb
@opindex mnosetlb
コンパイラが@emph{SETLB}命令または@emph{Lcc}命令を生成することを許可しない。 このオプションはプリプロセッサマクロ@code{__NO_SETLB__}を定義します。

@end table

@node Moxie Options
@subsection Moxieオプション
@cindex Moxie Options

@table @gcctabopt

@item -meb
@opindex meb
ビッグエンディアンコードを生成する。 これは@samp{moxie-*-*}構成のデフォルトである。

@item -mel
@opindex mel
リトルコードを生成する。

@item -mmul.x
@opindex mmul.x
mul.xとumul.x命令を生成する。 これは@samp{moxiebox-*-*}構成のデフォルトである。

@item -mno-crt0
@opindex mno-crt0
Cランタイム初期化オブジェクトファイルにはリンクしない。

@end table

@node MSP430 Options
@subsection MSP430オプション
@cindex MSP430 Options

これらのオプションは、MSP430用に定義されている。

@table @gcctabopt

@item -masm-hex
@opindex masm-hex
アセンブリの出力に常に16進定数を使用するように強制する。 通常、このような定数は符号付き小数だが、このオプションはテストスイートや審美的な目的で利用できる。

@item -mmcu=
@opindex mmcu=
対象とするMCUを選択する。これはMCU名に基づいてCプリプロセッサシンボルを作成し、大文字に変換し、@samp{__}で前後に置く。 これは、@file{msp430.h}ヘッダファイルによってMCU固有の補助ヘッダファイルを選択するために使用される。

このオプションは、使用するISAも設定する。 MCU名が430 ISAのみをサポートすることがわかっているものであれば、それが選択され、そうでなければ430X ISAが選択される。 @samp{msp430}の汎用MCU名を使用して430 ISAを選択することもできる。 同様に、一般的な@samp{msp430x} MCU名は430X ISAを選択する。

さらに、MCU固有のリンカスクリプトがリンカコマンドラインに追加される。 スクリプトの名前は、@file{.ld}が付加されたMCUの名前である。@command{gcc}コマンドラインで@option{-mmcu = xxx}を指定すると、Cプリプロセッサシンボル@code{__ XXX__}が定義され、リンカは@file{xxx.ld}というスクリプトを検索する。

このオプションはアセンブラにも渡される。

@item -mwarn-mcu
@itemx -mno-warn-mcu
@opindex mwarn-mcu
@opindex mno-warn-mcu
このオプションは、@option{-mmcu}オプションで指定したMCU名と@option{-mcpu}オプションで設定したISA間の競合や、@option{-mhwmult}オプションで設定したハードウェア多重サポートを無効にするかどうかの警告を有効または無効にする。 また、認識されないMCU名についての警告を切り替える。 このオプションは、デフォルトでオンになっている。

@item -mcpu=
@opindex mcpu=
使用するISAを指定する。 受け入れられる値は@samp{msp430}、@samp{msp430x}、@samp{msp430xv2}である。 このオプションは非推奨である。@option{-mmcu=}オプションを使用してISAを選択する必要がある。

@item -msim
@opindex msim
シミュレータランタイムライブラリとリンカスクリプトにリンクする。 @option{-mmcu=}オプションで選択されるスクリプトを上書きする。

@item -mlarge
@opindex mlarge
ラージモデルのアドレスを使う。（20ビットポインタ、32ビット@code{size_t}）

@item -msmall
@opindex msmall
スモールモデルのアドレスを使う。（16ビットポインタ、16ビットの@code{size_t}）

@item -mrelax
@opindex mrelax
このオプションはアセンブラとリンカに渡され、リンカは最終的なリンクまで実行できない特定の最適化を実行できるようにする。

@item mhwmult=
@opindex mhwmult=
ターゲットによってサポートされているハードウェア乗算の種類を記述する。受け入れられた値は、ハードウェア乗算がない場合は@samp{none}、初期MCUがサポートする元の16ビットのみ乗算では@samp{16bit}である。それ以降のMCUで16/32ビット乗算でサポートされる@samp{32bit}と、F5シリーズMCUで16/32ビット乗算でサポートされる@samp{f5series}がある。
@samp{auto}の値も与えられる。これは、GCCに、@option{-mmcu}オプションによって提供されるMCU名に基づいてハードウェア乗算サポートを推測するように指示する。@option{-mmcu}オプションが指定されていない場合、またはMCU名が認識されない場合、ハードウェア乗算サポートは想定されない。 @code{auto}がデフォルト設定である。

ハードウェア乗算は、通常、ライブラリルーチンを呼び出すことによって実行される。 これにより、生成されたコードの領域が節約される。 @option{-O3}以上でコンパイルすると、ハードウェア乗数がインラインで呼び出される。 これは、より大きいが速いコードになる。

ハードウェア乗算ルーチンは、終了時に以前の割り込み状態を実行して復元しながら割り込みを無効にする。 これにより、通常のコードと同様に、内部の割り込みハンドラを安全に使用することができる。

@item -minrt
@opindex minrt
静的な初期化子やコンストラクタなしで、最小限の実行時環境を使用できるようにする。 これはメモリが制約されたデバイスを対象としている。 コンパイラには、リンカとランタイムにコードフラグメントが必要であることを伝える、いくつかのオブジェクトに特殊なシンボルが含まれている。

@item -mcode-region=
@itemx -mdata-region=
@opindex mcode-region
@opindex mdata-region
これらのオプションは、@code{lower}、@code{upper}、@code{either}、または@code{section}属性のいずれも持たない関数とデータの配置場所をコンパイラに指示する。 可能な値は@code{lower}、@code{upper}、@code{either}または@code{any}である。 最初の3つは、対応する属性のように動作する。 4番目に可能な値 - @code{any} - がデフォルトである。 これは、リンカスクリプト全体と、標準セクション（@code{.text}、@code{.data}など）をメモリ領域に割り当てる方法で完全に置く。

@item -msilicon-errata=
@opindex msilicon-errata
このオプションは、指定されたシリコンエラッタの修正を有効にするためにアセンブラに要求を渡す。

@item -msilicon-errata-warn=
@opindex msilicon-errata-warn
このオプションは、シリコンエラッタを適用する必要がある場合に警告メッセージを有効にするように、アセンブラに要求を渡す。

@end table

@node NDS32 Options
@subsection NDS32オプション
@cindex NDS32 Options

これらのオプションは、NDS32実装で定義されている。

@table @gcctabopt

@item -mbig-endian
@opindex mbig-endian
ビッグエンディアンモードでコードを生成する。

@item -mlittle-endian
@opindex mlittle-endian
リトルエンディアンモードでコードを生成する。

@item -mreduced-regs
@opindex mreduced-regs
レジスタ割当に縮小セットレジスタを使う。

@item -mfull-regs
@opindex mfull-regs
レジスタ割当に完全セットレジスタを使う。

@item -mcmov
@opindex mcmov
条件付きムーブ命令を生成する。

@item -mno-cmov
@opindex mno-cmov
条件付きムーブ命令を生成しない。

@item -mext-perf
@opindex mperf-ext
パフォーマンス拡張命令を生成する。

@item -mno-ext-perf
@opindex mno-perf-ext
パフォーマンス拡張命令を生成しない。

@item -mext-perf2
@opindex mperf-ext
パフォーマンス拡張２命令を生成する。

@item -mno-ext-perf2
@opindex mno-perf-ext
パフォーマンス拡張２命令を生成しない。

@item -mext-string
@opindex mperf-ext
文字列拡張命令を生成する。

@item -mno-ext-string
@opindex mno-perf-ext
文字列拡張命令を生成しない。

@item -mv3push
@opindex mv3push
v3 push25/pop25命令を生成する。

@item -mno-v3push
@opindex mno-v3push
push25/pop25命令を生成しない。

@item -m16-bit
@opindex m16-bit
16ビット命令を生成する。

@item -mno-16-bit
@opindex mno-16-bit
16ビット命令を生成しない。

@item -misr-vector-size=@var{num}
@opindex misr-vector-size
割り込みベクタごとのサイズを指定する。4か16でなければならない。

@item -mcache-block-size=@var{num}
@opindex mcache-block-size
キャッシュブロックごとのサイズを指定する。4から512までの2のベキ乗でなければならない。

@item -march=@var{arch}
@opindex march
ターゲットアーキテクチャの名前を指定する。

@item -mcmodel=@var{code-model}
@opindex mcmodel
キャッシュモデルは以下の中からセットする。
@table @asis
@item @samp{small}
すべてのデータおよび読み取り専用データセグメントは、512KBのアドレス空間内になければならない。テキストセグメントは16MBのアドレス空間内になければならない。
@item @samp{medium}
データセグメントは512KB以内でなければならず、読み取り専用データセグメントは4GBアドレス空間内にある必要がある。 テキストセグメントは16MB以内でなければならない
@item @samp{large}
すべてのテキストとデータセグメントは4GBのアドレス空間内に置ける。
@end table

@item -mctor-dtor
@opindex mctor-dtor
コンストラクタ・デストラクタの機能を有効にする。

@item -mrelax
@opindex mrelax
リンカに命令を緩和するように示す。

@end table

@node Nios II Options
@subsection Nios IIオプション
@cindex Nios II options
@cindex Altera Nios II options

これらは、アルテラのNios IIプロセッサ用に定義されたオプションである。

@table @gcctabopt

@item -G @var{num}
@opindex G
@cindex smaller data references
@var{num}バイト以下のグローバルおよび静的オブジェクトを、通常のデータまたはBSSセクションではなく小データまたはBSSセクションに配置する。 @var{num}のデフォルト値は8である。

@item -mgpopt=@var{option}
@itemx -mgpopt
@itemx -mno-gpopt
@opindex mgpopt
@opindex mno-gpopt
GP相対アクセスを生成する（しない）。以下の@var{option}名が認識される。

@table @samp

@item none
GP相対アクセスを生成しない。

@item local
外部、弱い、または初期化されていない共通シンボルではない小さなデータオブジェクトに対して、GP相対アクセスを生成する。また、小さなデータセクションに明示的に配置されたオブジェクトには、@code{section}属性でGP相対アドレス指定を使用する。

@item global
@samp{local}と同様に、外部、弱い、または共通の小さなデータオブジェクトに対するGP相対アクセスも生成する。 このオプションを使用する場合は、プログラムのすべての部分（ライブラリを含む）が同じ@option{-G}設定でコンパイルされていることを確認する必要がある。

@item data
プログラム内のすべてのデータオブジェクトに対するGP相対アクセスを生成する。 このオプションを使用する場合は、プログラムのデータおよびBSSセグメント全体が64Kのメモリに収まる必要があり、適切なリンカスクリプトを使用してグローバルポインタのアドレス指定可能な範囲内に割り当てる必要がある。

@item all
関数ポインタとデータポインタのGP相対アドレスを生成する。 このオプションを使用する場合は、プログラムのテキスト、データ、およびBSSセグメント全体が64Kのメモリに収まる必要があり、適切なリンカスクリプトを使用して、グローバルポインタのアドレス指定可能な範囲内に適切なリンカスクリプトを割り当てる必要がある。

@end table

@option{-mgpopt}は@option{-mgpopt=local}と同等で、@option{-mno-gpopt}は@option{-mgpopt=none}と同じである。

位置非依存コードを生成するために@option{-fpic}または@option{-fPIC}が指定されている場合を除いて、デフォルトは@option{-mgpopt}である。Nios II ABIでは、共有ライブラリからのGP相対アクセスは許可されていない。

大規模なGOTデータセクションを含む大量の小さなデータを含むプログラムを構築する場合は、明示的に@option{-mno-gpopt}を指定する必要がある。 この場合、GP相対アドレス指定のための16ビットオフセットは、小さなデータセクション全体にアクセスするのに十分なほど大きくないことがある。

@item -mgprel-sec=@var{regexp}
@opindex mgprel-sec
This option specifies additional section names that can be accessed via
GP-relative addressing.  It is most useful in conjunction with 
@code{section} attributes on variable declarations 
(@pxref{Common Variable Attributes}) and a custom linker script.  
The @var{regexp} is a POSIX Extended Regular Expression.

This option does not affect the behavior of the @option{-G} option, and 
and the specified sections are in addition to the standard @code{.sdata} 
and @code{.sbss} small-data sections that are recognized by @option{-mgpopt}.

@item -mr0rel-sec=@var{regexp}
@opindex mr0rel-sec
This option specifies names of sections that can be accessed via a 
16-bit offset from @code{r0}; that is, in the low 32K or high 32K 
of the 32-bit address space.  It is most useful in conjunction with 
@code{section} attributes on variable declarations 
(@pxref{Common Variable Attributes}) and a custom linker script.  
The @var{regexp} is a POSIX Extended Regular Expression.

In contrast to the use of GP-relative addressing for small data, 
zero-based addressing is never generated by default and there are no 
conventional section names used in standard linker scripts for sections
in the low or high areas of memory.

@item -mel
@itemx -meb
@opindex mel
@opindex meb
それぞれリトルエンディアン（デフォルト）またはビッグエンディアン（実験的）コードを生成する。

@item -march=@var{arch}
@opindex march
ターゲットNios IIアーキテクチャの名前を指定する。 GCCはこの名前を使用して、アセンブリコードを生成するときにどのような命令を発行できるかを判断する。 許可される名前は@samp{r1}、@samp{r2}である。

プリプロセッサマクロの@code{__ nios2_arch__}は、ターゲットISAレベルを示す値1または2のプログラムで使用できる。

@item -mbypass-cache
@itemx -mno-bypass-cache
@opindex mno-bypass-cache
@opindex mbypass-cache
命令のI/Oバリアントを使用して、すべてのロードおよびストア命令が常にキャッシュをバイパスするようにする。 デフォルトでは、キャッシュをバイパスしない。

@item -mno-cache-volatile 
@itemx -mcache-volatile       
@opindex mcache-volatile 
@opindex mno-cache-volatile
揮発性メモリアクセスは、ロードおよびストア命令のI / Oバリアントを使用してキャッシュをバイパスします。 デフォルトでは、キャッシュをバイパスしない。

@item -mno-fast-sw-div
@itemx -mfast-sw-div
@opindex mno-fast-sw-div
@opindex mfast-sw-div
小さい数に対してはテーブルベースの高速除算を使用する。 デフォルトでは、@option{-O3}以上の高速除算が使用される。

@item -mno-hw-mul
@itemx -mhw-mul
@itemx -mno-hw-mulx
@itemx -mhw-mulx
@itemx -mno-hw-div
@itemx -mhw-div
@opindex mno-hw-mul
@opindex mhw-mul
@opindex mno-hw-mulx
@opindex mhw-mulx
@opindex mno-hw-div
@opindex mhw-div
コンパイラが@code{mul}、@code{mulx}、@code{div}命令ファミリを有効または無効にする。 デフォルトでは、@code{mul}を発行し、@code{div}と@code{mulx}は発行しない。

@item -mbmx
@itemx -mno-bmx
@itemx -mcdx
@itemx -mno-cdx
Nios II R2 BMX（ビット操作）およびCDX（コード密度）命令の生成を有効または無効にする。 これらの命令を有効にするには、@option{-march=r2}も必要である。これらの命令はR2アーキテクチャのオプションの拡張であるため、デフォルトではそれらを発行しない。

@item -mcustom-@var{insn}=@var{N}
@itemx -mno-custom-@var{insn}
@opindex mcustom-@var{insn}
@opindex mno-custom-@var{insn}
各@option{-mcustom-@var{insn}=@var{N}}オプションは、@var{insn}を使用するコードを生成するときに@var{N}をエンコードするカスタム命令の使用を可能にする。たとえば、@option{-mcustom-fadds=253}は、ライブラリ呼び出しを使用するデフォルトの動作ではなく、単精度浮動小数点加算演算用のカスタム命令253を生成する。

@var{insn}の以下の値がサポートされている。 特に明記されていない限り、浮動小数点演算は通常のIEEE 754セマンティクスで実装され、C演算子または同等のGCC組み込み関数（@pxref {Other Builtins}）に直接対応している。

単精度浮動小数点数：
@table @asis

@item @samp{fadds}, @samp{fsubs}, @samp{fdivs}, @samp{fmuls}
二項算術命令

@item @samp{fnegs}
単項否定

@item @samp{fabss}
単項絶対値

@item @samp{fcmpeqs}, @samp{fcmpges}, @samp{fcmpgts}, @samp{fcmples}, @samp{fcmplts}, @samp{fcmpnes}
比較操作

@item @samp{fmins}, @samp{fmaxs}
浮動小数点最小・最大。これらの命令は@option{-ffinite-math-only}が指定されたときのみ生成される。

@item @samp{fsqrts}
単項平方根命令。

@item @samp{fcoss}, @samp{fsins}, @samp{ftans}, @samp{fatans}, @samp{fexps}, @samp{flogs}
浮動小数点数三角関数と指数関数。 これらの命令は、@option{-funsafe-math-optimizations}も指定されている場合にのみ生成される。

@end table

倍精度浮動小数点数：
@table @asis

@item @samp{faddd}, @samp{fsubd}, @samp{fdivd}, @samp{fmuld}
二項算術命令

@item @samp{fnegd}
単項否定

@item @samp{fabsd}
単項絶対値

@item @samp{fcmpeqd}, @samp{fcmpged}, @samp{fcmpgtd}, @samp{fcmpled}, @samp{fcmpltd}, @samp{fcmpned}
比較操作

@item @samp{fmind}, @samp{fmaxd}
倍精度最小・最大。これらの命令は@option{-ffinite-math-only}が指定されたときのみ生成される。

@item @samp{fsqrtd}
単項平方根命令。

@item @samp{fcosd}, @samp{fsind}, @samp{ftand}, @samp{fatand}, @samp{fexpd}, @samp{flogd}
倍精度三角関数と指数関数。 これらの命令は、@option{-funsafe-math-optimizations}も指定されている場合にのみ生成される。

@end table

変換：
@table @asis
@item @samp{fextsd}
単精度から倍精度への変換

@item @samp{ftruncds}
倍精度から単精度への変換
Conversion from double precision to single precision.

@item @samp{fixsi}, @samp{fixsu}, @samp{fixdi}, @samp{fixdu}
浮動小数点数から符号付き・符号なし整数への0への切り詰めによる変換。

@item @samp{round}
単精度浮動小数点数から符号付き整数への、0から遠い方向への最近接丸め。
これは@option{-fno-math-errno}が使われたときには@code{__builtin_lroundf}関数に対応する。

@item @samp{floatis}, @samp{floatus}, @samp{floatid}, @samp{floatud}
符号付きまたは符号なし整数型から浮動小数点型への変換。

@end table

さらに、倍精度浮動小数点命令のいずれかを使用するには、内部レジスタXおよびYの次の転送命令をすべて提供する必要がある。 2つの倍精度ソース・オペランドを取るカスタム命令は、64ビット・レジスタXの最初のオペランドを必要とする。他のオペランド（または単項演算のオペランドのみ）は、ソースレジスタ@var{src1}の最下位半分と@var {src2}の最上位半分を持つカスタム算術命令に与えられる。倍精度結果を返すカスタム命令は、デスティネーションレジスタの最上位32ビットと32ビットレジスタYの残りの半分を返す。倍精度浮動小数点命令が使用される場合、GCCは自動的にレジスタXおよび/またはレジスタYを書き込むために必要なコードシーケンスを生成する。

@table @asis

@item @samp{fwrx}
@var{src1}をXの最下位半分に、@var{src2}をXの最上位半分に書き出す。

@item @samp{fwry}
@var{src1}をYへと書き出す。

@item @samp{frdxhi}, @samp{frdxlo}
Xの最上位または最下位（それぞれ）を読み、それを@var{dest}に格納する。

@item @samp{frdy}
Yの値を読み@var{dest}に格納する。
@end table

@code{target("custom@var{insn}=@var{N}")}と@code{target("no-custom-@var{insn}")}関数属性（@pxref{Function Attributes}）またはプラグマ（@pxref{Function Specific Option Pragmas}）を使用してNios IIカスタム命令の生成をローカルで制御することができる。

@item -mcustom-fpu-cfg=@var{name}
@opindex mcustom-fpu-cfg

このオプションは、あらかじめ定義されたカスタム命令エンコーディングのセットを有効にする（上記の@option{-mcustom-@var{insn}}参照）。現在、以下のセットが定義されています。

@option{-mcustom-fpu-cfg=60-1}は以下と同等である。
@gccoptlist{-mcustom-fmuls=252 
-mcustom-fadds=253 
-mcustom-fsubs=254 
-fsingle-precision-constant}

@option{-mcustom-fpu-cfg=60-2}は以下と同等である。
@gccoptlist{-mcustom-fmuls=252 
-mcustom-fadds=253 
-mcustom-fsubs=254 
-mcustom-fdivs=255 
-fsingle-precision-constant}

@option{-mcustom-fpu-cfg=72-3}は以下と同等である。
@gccoptlist{-mcustom-floatus=243 
-mcustom-fixsi=244 
-mcustom-floatis=245 
-mcustom-fcmpgts=246 
-mcustom-fcmples=249 
-mcustom-fcmpeqs=250 
-mcustom-fcmpnes=251 
-mcustom-fmuls=252 
-mcustom-fadds=253 
-mcustom-fsubs=254 
-mcustom-fdivs=255 
-fsingle-precision-constant}

個別の@option{-mcustom-@var{insn}=}オプションで指定されたカスタム命令の割り当ては、コマンドラインでのオプションの順序にかかわらず、@option{-mcustom-fpu-cfg=}で指定されたものを上書きする。

@code{target("custom-fpu-cfg=@var{name}")}関数の属性（@pxref {Function Attributes}）やプラグマ（@pxref{Function Specific Option Pragmas}）を使用することで、FPU構成の選択をより詳細に制御できる。

@end table

これらの追加の@samp {-m}オプションは、アルテラのNios II ELF（ベアメタル）ターゲットで使用できます。

@table @gcctabopt

@item -mhal
@opindex mhal
HAL BSPとのリンク。 これにより、GCC提供のCランタイムスタートアップコードと終了コードとのリンクが抑制され、通常はHAL BSPによって提供される代替起動コードの場所を指定するために@option{-msys-crt0=}と組み合わせて使用される。

@item -msmallc
@opindex msmallc
Newlibではなく、Cライブラリの制限されたバージョンである@option{-lsmallc}とリンクする。

@item -msys-crt0=@var{startfile}
@opindex msys-crt0
@var{startfile}は、リンク時に使用する開始ファイル（crt0）のファイル名である。 このオプションは@option{-mhal}と組み合わせて使用すると便利である。

@item -msys-lib=@var{systemlib}
@opindex msys-lib
@var{systemlib}は、Cライブラリが必要とする低レベルのシステムコールを提供するライブラリのライブラリ名である。例えば、@code{read}と@code {write}である。このオプションは通常、HAL BSPによって提供されるライブラリとリンクするために使用される。

@end table

@node Nvidia PTX Options
@subsection Nvidia PTXオプション
@cindex Nvidia PTX options
@cindex nvptx options

これらのオプションは、Nvidia PTX用に定義されている。

@table @gcctabopt

@item -m32
@itemx -m64
@opindex m32
@opindex m64
32ビットまたは64ビットABI用のコードを生成する。

@item -mmainkernel
@opindex mmainkernel
__mainカーネルのコードをリンクする。 これは、オフロード実行ではなくスタンドアロン用である。

@item -moptimize
@opindex moptimize
パーティション化された実行最適化を適用する。 これは、最適化のレベルが選択されている場合のデフォルトである。

@item -msoft-stack
@opindex msoft-stack
スタック格納のために@code{.local}メモリを直接使用しないコードを生成する。 代わりに、ワープごとのスタックポインタが明示的に保持される。 これにより、可変長配列の割り当て（可変長配列または@code {alloca}）が可能になる。グローバルメモリを基になるストレージに使用すると、他のスレッドやアトミック命令から自動変数にアクセスすることができる。 このコード生成バリアントはOpenMPオフロードに使用されるが、オプションはコンパイラをテストするために単独で公開されている。 OpenMPオフロードを使用してプログラムにリンクするのに適したコードを生成するには、オプション@option{-mgomp}を使用する。

@item -muniform-simt
@opindex muniform-simt
あたかも1つのスレッドしかOpenMP SIMD領域外でアクティブであるかのようにメモリ状態と副作用を維持しながら、各ワープ内のすべてのスレッドを実行できるコード生成バリアントに切り替える。 すべてのアトミック操作とランタイム呼び出し（malloc、free、vprintf）は条件付きで実行される（現在のレーンインデックスがマスタレーンインデックスと等しい場合）。割り当てられるレジスタはマスターレーンからのシャッフル命令によってコピーされる。 SIMD領域の外側では、レーン0がマスタである。 内部では、各スレッドはマスターとして自分自身を見る。 共有メモリ配列@code{int __nvptx_uni []}は、現在のモード（SIMD領域外の0）を示す、各ワープのすべて0またはすべて1のビットマスクを格納する。 各スレッドはビットごとに、ビットマップは@code{tid.y}にあり、現在のレーンインデックスでマスターレーンインデックスを計算できる。

@item -mgomp
@opindex mgomp
OpenMPオフロードで使用するコードを生成する：@option{-msoft-stack}と@option{-muniform-simt}オプションを有効にし、対応するmultilibバリアントを選択する。

@end table

@node PDP-11 Options
@subsection PDP-11オプション
@cindex PDP-11 Options

これらのオプションは、PDP-11用に定義されている

@table @gcctabopt
@item -mfpu
@opindex mfpu
ハードウェアFPP浮動小数点を使用します。 これがデフォルトである。（PDP-11/40上のFIS浮動小数点はサポートされていない。）

@item -msoft-float
@opindex msoft-float
ハードウェア浮動小数点を使用しない。

@item -mac0
@opindex mac0
浮動小数点の結果をac0（UNIXアセンブラの構文ではfr0）で返す。

@item -mno-ac0
@opindex mno-ac0
浮動小数点の結果をメモリに返します。 これがデフォルトである。

@item -m40
@opindex m40
PDP-11/40用コードを生成する。

@item -m45
@opindex m45
PDP-11/45用コードを生成する。 これがデフォルトである。

@item -m10
@opindex m10
PDP-11/10用コードを生成する。

@item -mbcopy-builtin
@opindex mbcopy-builtin
メモリのコピーには、インラインの@code{movmemhi}パターンを使用する。 これがデフォルトである。

@item -mbcopy
@opindex mbcopy
メモリをコピーするためにインライン@code {movmemhi}パターンを使用しない。

@item -mint16
@itemx -mno-int32
@opindex mint16
@opindex mno-int32
16ビットの@code{int}を使う。これがデフォルトである。

@item -mint32
@itemx -mno-int16
@opindex mint32
@opindex mno-int16
32ビットの@code{int}を使う。

@item -mfloat64
@itemx -mno-float32
@opindex mfloat64
@opindex mno-float32
64ビットの@code{float}を使用する。 これがデフォルトです。

@item -mfloat32
@itemx -mno-float64
@opindex mfloat32
@opindex mno-float64
32ビットの@code{float}を使用する。

@item -mabshi
@opindex mabshi
@code{abshi2}パターンを使う。これがデフォルトである。

@item -mno-abshi
@opindex mno-abshi
@code{abshi2}パターンを使わない。

@item -mbranch-expensive
@opindex mbranch-expensive
分岐が高価だと主張する。 これは、コード生成の実験専用である。

@item -mbranch-cheap
@opindex mbranch-cheap
分岐が高価だと主張しない。これがデフォルトである。

@item -munix-asm
@opindex munix-asm
Unixアセンブラ構文を使う。これは@samp{pdp11-*-bsd}で構成された場合のデフォルトである。

@item -mdec-asm
@opindex mdec-asm
DECアセンブラ構文を使う。これはPDP-11が@samp{pdp11-*-bs}以外で構成された場合のデフォルトである。
@end table

@node picoChip Options
@subsection picoChipオプション
@cindex picoChip options

これらの@samp {-m}オプションは、picoChip実装用に定義されている。

@table @gcctabopt

@item -mae=@var{ae_type}
@opindex mcpu
配列要素型@var{ae_type}の命令セット、レジスタセット、および命令スケジューリングパラメータを設定する。 @var{ae_type}にサポートされる値は@samp{ANY}、@samp{MUL}、@samp{MAC}である。

@option{-mae=ANY}は、完全な汎用AEタイプを選択する。 このオプションで生成されるコードは、他のAEタイプのいずれかで実行される。 コードは、特定のAEタイプ用にコンパイルされた場合ほど効率的でなく、いくつかのタイプの操作（例えば、乗算）は、すべてのタイプのAEで適切に機能しない。

@option{-mae = MUL}はMUL AEタイプを選択する。 これは、コンパイルされたコードで最も有用なAEタイプであり、デフォルトである。

@option {-mae = MAC}はDSPスタイルのMAC AEを選択する。 このオプションでコンパイルされたコードは、バイトA/D変換がバイトロード/ストアのハードウェアサポートを提供しないため、バイト（char）操作のパフォーマンスが低下する可能性がある。

@item -msymbol-as-address
コンパイラがロード/ストア命令のアドレスとしてシンボル名を直接使用し、最初にレジスタにロードすることはないようにさせる。 通常、このオプションを使用するとより大きなプログラムが生成され、オプションを使用しない場合よりも速く実行される。 ただし、結果はプログラムによって異なるので、永続的に有効にするのではなく、ユーザーオプションとして残してある。

@item -mno-inefficient-warnings
非効率なコードの生成に関する警告を無効にする。 これらの警告は、たとえば、MAC AEタイプでバイトレベルのメモリ操作を実行するコードをコンパイルするときに生成される。 MAC AEには、バイトレベルのメモリ操作に対するハードウェアサポートがないため、すべてのバイトロード/ストアをワードロード/ストア操作から合成する必要がある。 これは非効率的であり、バイト操作を避けるためにコードを書き直す必要があることを示す警告が生成されるか、または必要なハードウェアサポートを持つAEタイプをターゲットにするよう警告が生成される。 このオプションは、これらの警告を無効にする。

@end table

@node PowerPC Options
@subsection PowerPCオプション
@cindex PowerPC options

@xref{RS/6000 and PowerPC Options}で挙げられている。

@node PowerPC SPE Options
@subsection PowerPC SPE Options
@cindex PowerPC SPE options

These @samp{-m} options are defined for PowerPC SPE:
@table @gcctabopt
@item -mmfcrf
@itemx -mno-mfcrf
@itemx -mpopcntb
@itemx -mno-popcntb
@opindex mmfcrf
@opindex mno-mfcrf
@opindex mpopcntb
@opindex mno-popcntb
You use these options to specify which instructions are available on the
processor you are using.  The default value of these options is
determined when configuring GCC@.  Specifying the
@option{-mcpu=@var{cpu_type}} overrides the specification of these
options.  We recommend you use the @option{-mcpu=@var{cpu_type}} option
rather than the options listed above.

The @option{-mmfcrf} option allows GCC to generate the move from
condition register field instruction implemented on the POWER4
processor and other processors that support the PowerPC V2.01
architecture.
The @option{-mpopcntb} option allows GCC to generate the popcount and
double-precision FP reciprocal estimate instruction implemented on the
POWER5 processor and other processors that support the PowerPC V2.02
architecture.

@item -mcpu=@var{cpu_type}
@opindex mcpu
Set architecture type, register usage, and
instruction scheduling parameters for machine type @var{cpu_type}.
Supported values for @var{cpu_type} are @samp{8540}, @samp{8548},
and @samp{native}.

@option{-mcpu=powerpc} specifies pure 32-bit PowerPC (either
endian), with an appropriate, generic processor model assumed for
scheduling purposes.

Specifying @samp{native} as cpu type detects and selects the
architecture option that corresponds to the host processor of the
system performing the compilation.
@option{-mcpu=native} has no effect if GCC does not recognize the
processor.

The other options specify a specific processor.  Code generated under
those options runs best on that processor, and may not run at all on
others.

The @option{-mcpu} options automatically enable or disable the
following options:

@gccoptlist{-mhard-float  -mmfcrf  -mmultiple 
-mpopcntb -mpopcntd 
-msingle-float -mdouble-float 
-mfloat128}

The particular options set for any particular CPU varies between
compiler versions, depending on what setting seems to produce optimal
code for that CPU; it doesn't necessarily reflect the actual hardware's
capabilities.  If you wish to set an individual option to a particular
value, you may specify it after the @option{-mcpu} option, like
@option{-mcpu=8548}.

@item -mtune=@var{cpu_type}
@opindex mtune
Set the instruction scheduling parameters for machine type
@var{cpu_type}, but do not set the architecture type or register usage,
as @option{-mcpu=@var{cpu_type}} does.  The same
values for @var{cpu_type} are used for @option{-mtune} as for
@option{-mcpu}.  If both are specified, the code generated uses the
architecture and registers set by @option{-mcpu}, but the
scheduling parameters set by @option{-mtune}.

@item -msecure-plt
@opindex msecure-plt
Generate code that allows @command{ld} and @command{ld.so}
to build executables and shared
libraries with non-executable @code{.plt} and @code{.got} sections.
This is a PowerPC
32-bit SYSV ABI option.

@item -mbss-plt
@opindex mbss-plt
Generate code that uses a BSS @code{.plt} section that @command{ld.so}
fills in, and
requires @code{.plt} and @code{.got}
sections that are both writable and executable.
This is a PowerPC 32-bit SYSV ABI option.

@item -misel
@itemx -mno-isel
@opindex misel
@opindex mno-isel
This switch enables or disables the generation of ISEL instructions.

@item -misel=@var{yes/no}
This switch has been deprecated.  Use @option{-misel} and
@option{-mno-isel} instead.

@item -mspe
@itemx -mno-spe
@opindex mspe
@opindex mno-spe
This switch enables or disables the generation of SPE simd
instructions.

@item -mfloat128
@itemx -mno-float128
@opindex mfloat128
@opindex mno-float128
Enable/disable the @var{__float128} keyword for IEEE 128-bit floating point
and use either software emulation for IEEE 128-bit floating point or
hardware instructions.

@item -mfloat-gprs=@var{yes/single/double/no}
@itemx -mfloat-gprs
@opindex mfloat-gprs
This switch enables or disables the generation of floating-point
operations on the general-purpose registers for architectures that
support it.

The argument @samp{yes} or @samp{single} enables the use of
single-precision floating-point operations.

The argument @samp{double} enables the use of single and
double-precision floating-point operations.

The argument @samp{no} disables floating-point operations on the
general-purpose registers.

This option is currently only available on the MPC854x.

@item -mfull-toc
@itemx -mno-fp-in-toc
@itemx -mno-sum-in-toc
@itemx -mminimal-toc
@opindex mfull-toc
@opindex mno-fp-in-toc
@opindex mno-sum-in-toc
@opindex mminimal-toc
Modify generation of the TOC (Table Of Contents), which is created for
every executable file.  The @option{-mfull-toc} option is selected by
default.  In that case, GCC allocates at least one TOC entry for
each unique non-automatic variable reference in your program.  GCC
also places floating-point constants in the TOC@.  However, only
16,384 entries are available in the TOC@.

If you receive a linker error message that saying you have overflowed
the available TOC space, you can reduce the amount of TOC space used
with the @option{-mno-fp-in-toc} and @option{-mno-sum-in-toc} options.
@option{-mno-fp-in-toc} prevents GCC from putting floating-point
constants in the TOC and @option{-mno-sum-in-toc} forces GCC to
generate code to calculate the sum of an address and a constant at
run time instead of putting that sum into the TOC@.  You may specify one
or both of these options.  Each causes GCC to produce very slightly
slower and larger code at the expense of conserving TOC space.

If you still run out of space in the TOC even when you specify both of
these options, specify @option{-mminimal-toc} instead.  This option causes
GCC to make only one TOC entry for every file.  When you specify this
option, GCC produces code that is slower and larger but which
uses extremely little TOC space.  You may wish to use this option
only on files that contain less frequently-executed code.

@item -maix32
@opindex maix32
Disables the 64-bit ABI.  GCC defaults to @option{-maix32}.

@item -mxl-compat
@itemx -mno-xl-compat
@opindex mxl-compat
@opindex mno-xl-compat
Produce code that conforms more closely to IBM XL compiler semantics
when using AIX-compatible ABI@.  Pass floating-point arguments to
prototyped functions beyond the register save area (RSA) on the stack
in addition to argument FPRs.  Do not assume that most significant
double in 128-bit long double value is properly rounded when comparing
values and converting to double.  Use XL symbol names for long double
support routines.

The AIX calling convention was extended but not initially documented to
handle an obscure K&R C case of calling a function that takes the
address of its arguments with fewer arguments than declared.  IBM XL
compilers access floating-point arguments that do not fit in the
RSA from the stack when a subroutine is compiled without
optimization.  Because always storing floating-point arguments on the
stack is inefficient and rarely needed, this option is not enabled by
default and only is necessary when calling subroutines compiled by IBM
XL compilers without optimization.

@item -malign-natural
@itemx -malign-power
@opindex malign-natural
@opindex malign-power
On AIX, 32-bit Darwin, and 64-bit PowerPC GNU/Linux, the option
@option{-malign-natural} overrides the ABI-defined alignment of larger
types, such as floating-point doubles, on their natural size-based boundary.
The option @option{-malign-power} instructs GCC to follow the ABI-specified
alignment rules.  GCC defaults to the standard alignment defined in the ABI@.

On 64-bit Darwin, natural alignment is the default, and @option{-malign-power}
is not supported.

@item -msoft-float
@itemx -mhard-float
@opindex msoft-float
@opindex mhard-float
Generate code that does not use (uses) the floating-point register set.
Software floating-point emulation is provided if you use the
@option{-msoft-float} option, and pass the option to GCC when linking.

@item -msingle-float
@itemx -mdouble-float
@opindex msingle-float
@opindex mdouble-float
Generate code for single- or double-precision floating-point operations.
@option{-mdouble-float} implies @option{-msingle-float}.

@item -mmultiple
@itemx -mno-multiple
@opindex mmultiple
@opindex mno-multiple
Generate code that uses (does not use) the load multiple word
instructions and the store multiple word instructions.  These
instructions are generated by default on POWER systems, and not
generated on PowerPC systems.  Do not use @option{-mmultiple} on little-endian
PowerPC systems, since those instructions do not work when the
processor is in little-endian mode.  The exceptions are PPC740 and
PPC750 which permit these instructions in little-endian mode.

@item -mupdate
@itemx -mno-update
@opindex mupdate
@opindex mno-update
Generate code that uses (does not use) the load or store instructions
that update the base register to the address of the calculated memory
location.  These instructions are generated by default.  If you use
@option{-mno-update}, there is a small window between the time that the
stack pointer is updated and the address of the previous frame is
stored, which means code that walks the stack frame across interrupts or
signals may get corrupted data.

@item -mavoid-indexed-addresses
@itemx -mno-avoid-indexed-addresses
@opindex mavoid-indexed-addresses
@opindex mno-avoid-indexed-addresses
Generate code that tries to avoid (not avoid) the use of indexed load
or store instructions. These instructions can incur a performance
penalty on Power6 processors in certain situations, such as when
stepping through large arrays that cross a 16M boundary.  This option
is enabled by default when targeting Power6 and disabled otherwise.

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
Generate code that uses (does not use) the floating-point multiply and
accumulate instructions.  These instructions are generated by default
if hardware floating point is used.  The machine-dependent
@option{-mfused-madd} option is now mapped to the machine-independent
@option{-ffp-contract=fast} option, and @option{-mno-fused-madd} is
mapped to @option{-ffp-contract=off}.

@item -mno-strict-align
@itemx -mstrict-align
@opindex mno-strict-align
@opindex mstrict-align
On System V.4 and embedded PowerPC systems do not (do) assume that
unaligned memory references are handled by the system.

@item -mrelocatable
@itemx -mno-relocatable
@opindex mrelocatable
@opindex mno-relocatable
Generate code that allows (does not allow) a static executable to be
relocated to a different address at run time.  A simple embedded
PowerPC system loader should relocate the entire contents of
@code{.got2} and 4-byte locations listed in the @code{.fixup} section,
a table of 32-bit addresses generated by this option.  For this to
work, all objects linked together must be compiled with
@option{-mrelocatable} or @option{-mrelocatable-lib}.
@option{-mrelocatable} code aligns the stack to an 8-byte boundary.

@item -mrelocatable-lib
@itemx -mno-relocatable-lib
@opindex mrelocatable-lib
@opindex mno-relocatable-lib
Like @option{-mrelocatable}, @option{-mrelocatable-lib} generates a
@code{.fixup} section to allow static executables to be relocated at
run time, but @option{-mrelocatable-lib} does not use the smaller stack
alignment of @option{-mrelocatable}.  Objects compiled with
@option{-mrelocatable-lib} may be linked with objects compiled with
any combination of the @option{-mrelocatable} options.

@item -mno-toc
@itemx -mtoc
@opindex mno-toc
@opindex mtoc
On System V.4 and embedded PowerPC systems do not (do) assume that
register 2 contains a pointer to a global area pointing to the addresses
used in the program.

@item -mlittle
@itemx -mlittle-endian
@opindex mlittle
@opindex mlittle-endian
On System V.4 and embedded PowerPC systems compile code for the
processor in little-endian mode.  The @option{-mlittle-endian} option is
the same as @option{-mlittle}.

@item -mbig
@itemx -mbig-endian
@opindex mbig
@opindex mbig-endian
On System V.4 and embedded PowerPC systems compile code for the
processor in big-endian mode.  The @option{-mbig-endian} option is
the same as @option{-mbig}.

@item -mdynamic-no-pic
@opindex mdynamic-no-pic
On Darwin and Mac OS X systems, compile code so that it is not
relocatable, but that its external references are relocatable.  The
resulting code is suitable for applications, but not shared
libraries.

@item -msingle-pic-base
@opindex msingle-pic-base
Treat the register used for PIC addressing as read-only, rather than
loading it in the prologue for each function.  The runtime system is
responsible for initializing this register with an appropriate value
before execution begins.

@item -mprioritize-restricted-insns=@var{priority}
@opindex mprioritize-restricted-insns
This option controls the priority that is assigned to
dispatch-slot restricted instructions during the second scheduling
pass.  The argument @var{priority} takes the value @samp{0}, @samp{1},
or @samp{2} to assign no, highest, or second-highest (respectively)
priority to dispatch-slot restricted
instructions.

@item -msched-costly-dep=@var{dependence_type}
@opindex msched-costly-dep
This option controls which dependences are considered costly
by the target during instruction scheduling.  The argument
@var{dependence_type} takes one of the following values:

@table @asis
@item @samp{no}
No dependence is costly.

@item @samp{all}
All dependences are costly.

@item @samp{true_store_to_load}
A true dependence from store to load is costly.

@item @samp{store_to_load}
Any dependence from store to load is costly.

@item @var{number}
Any dependence for which the latency is greater than or equal to
@var{number} is costly.
@end table

@item -minsert-sched-nops=@var{scheme}
@opindex minsert-sched-nops
This option controls which NOP insertion scheme is used during
the second scheduling pass.  The argument @var{scheme} takes one of the
following values:

@table @asis
@item @samp{no}
Don't insert NOPs.

@item @samp{pad}
Pad with NOPs any dispatch group that has vacant issue slots,
according to the scheduler's grouping.

@item @samp{regroup_exact}
Insert NOPs to force costly dependent insns into
separate groups.  Insert exactly as many NOPs as needed to force an insn
to a new group, according to the estimated processor grouping.

@item @var{number}
Insert NOPs to force costly dependent insns into
separate groups.  Insert @var{number} NOPs to force an insn to a new group.
@end table

@item -mcall-sysv
@opindex mcall-sysv
On System V.4 and embedded PowerPC systems compile code using calling
conventions that adhere to the March 1995 draft of the System V
Application Binary Interface, PowerPC processor supplement.  This is the
default unless you configured GCC using @samp{powerpc-*-eabiaix}.

@item -mcall-sysv-eabi
@itemx -mcall-eabi
@opindex mcall-sysv-eabi
@opindex mcall-eabi
Specify both @option{-mcall-sysv} and @option{-meabi} options.

@item -mcall-sysv-noeabi
@opindex mcall-sysv-noeabi
Specify both @option{-mcall-sysv} and @option{-mno-eabi} options.

@item -mcall-aixdesc
@opindex m
On System V.4 and embedded PowerPC systems compile code for the AIX
operating system.

@item -mcall-linux
@opindex mcall-linux
On System V.4 and embedded PowerPC systems compile code for the
Linux-based GNU system.

@item -mcall-freebsd
@opindex mcall-freebsd
On System V.4 and embedded PowerPC systems compile code for the
FreeBSD operating system.

@item -mcall-netbsd
@opindex mcall-netbsd
On System V.4 and embedded PowerPC systems compile code for the
NetBSD operating system.

@item -mcall-openbsd
@opindex mcall-netbsd
On System V.4 and embedded PowerPC systems compile code for the
OpenBSD operating system.

@item -maix-struct-return
@opindex maix-struct-return
Return all structures in memory (as specified by the AIX ABI)@.

@item -msvr4-struct-return
@opindex msvr4-struct-return
Return structures smaller than 8 bytes in registers (as specified by the
SVR4 ABI)@.

@item -mabi=@var{abi-type}
@opindex mabi
Extend the current ABI with a particular extension, or remove such extension.
Valid values are @samp{altivec}, @samp{no-altivec}, @samp{spe},
@samp{no-spe}, @samp{ibmlongdouble}, @samp{ieeelongdouble},
@samp{elfv1}, @samp{elfv2}@.

@item -mabi=spe
@opindex mabi=spe
Extend the current ABI with SPE ABI extensions.  This does not change
the default ABI, instead it adds the SPE ABI extensions to the current
ABI@.

@item -mabi=no-spe
@opindex mabi=no-spe
Disable Book-E SPE ABI extensions for the current ABI@.

@item -mabi=ibmlongdouble
@opindex mabi=ibmlongdouble
Change the current ABI to use IBM extended-precision long double.
This is not likely to work if your system defaults to using IEEE
extended-precision long double.  If you change the long double type
from IEEE extended-precision, the compiler will issue a warning unless
you use the @option{-Wno-psabi} option.

@item -mabi=ieeelongdouble
@opindex mabi=ieeelongdouble
Change the current ABI to use IEEE extended-precision long double.
This is not likely to work if your system defaults to using IBM
extended-precision long double.  If you change the long double type
from IBM extended-precision, the compiler will issue a warning unless
you use the @option{-Wno-psabi} option.

@item -mabi=elfv1
@opindex mabi=elfv1
Change the current ABI to use the ELFv1 ABI.
This is the default ABI for big-endian PowerPC 64-bit Linux.
Overriding the default ABI requires special system support and is
likely to fail in spectacular ways.

@item -mabi=elfv2
@opindex mabi=elfv2
Change the current ABI to use the ELFv2 ABI.
This is the default ABI for little-endian PowerPC 64-bit Linux.
Overriding the default ABI requires special system support and is
likely to fail in spectacular ways.

@item -mgnu-attribute
@itemx -mno-gnu-attribute
@opindex mgnu-attribute
@opindex mno-gnu-attribute
Emit .gnu_attribute assembly directives to set tag/value pairs in a
.gnu.attributes section that specify ABI variations in function
parameters or return values.

@item -mprototype
@itemx -mno-prototype
@opindex mprototype
@opindex mno-prototype
On System V.4 and embedded PowerPC systems assume that all calls to
variable argument functions are properly prototyped.  Otherwise, the
compiler must insert an instruction before every non-prototyped call to
set or clear bit 6 of the condition code register (@code{CR}) to
indicate whether floating-point values are passed in the floating-point
registers in case the function takes variable arguments.  With
@option{-mprototype}, only calls to prototyped variable argument functions
set or clear the bit.

@item -msim
@opindex msim
On embedded PowerPC systems, assume that the startup module is called
@file{sim-crt0.o} and that the standard C libraries are @file{libsim.a} and
@file{libc.a}.  This is the default for @samp{powerpc-*-eabisim}
configurations.

@item -mmvme
@opindex mmvme
On embedded PowerPC systems, assume that the startup module is called
@file{crt0.o} and the standard C libraries are @file{libmvme.a} and
@file{libc.a}.

@item -mads
@opindex mads
On embedded PowerPC systems, assume that the startup module is called
@file{crt0.o} and the standard C libraries are @file{libads.a} and
@file{libc.a}.

@item -myellowknife
@opindex myellowknife
On embedded PowerPC systems, assume that the startup module is called
@file{crt0.o} and the standard C libraries are @file{libyk.a} and
@file{libc.a}.

@item -mvxworks
@opindex mvxworks
On System V.4 and embedded PowerPC systems, specify that you are
compiling for a VxWorks system.

@item -memb
@opindex memb
On embedded PowerPC systems, set the @code{PPC_EMB} bit in the ELF flags
header to indicate that @samp{eabi} extended relocations are used.

@item -meabi
@itemx -mno-eabi
@opindex meabi
@opindex mno-eabi
On System V.4 and embedded PowerPC systems do (do not) adhere to the
Embedded Applications Binary Interface (EABI), which is a set of
modifications to the System V.4 specifications.  Selecting @option{-meabi}
means that the stack is aligned to an 8-byte boundary, a function
@code{__eabi} is called from @code{main} to set up the EABI
environment, and the @option{-msdata} option can use both @code{r2} and
@code{r13} to point to two separate small data areas.  Selecting
@option{-mno-eabi} means that the stack is aligned to a 16-byte boundary,
no EABI initialization function is called from @code{main}, and the
@option{-msdata} option only uses @code{r13} to point to a single
small data area.  The @option{-meabi} option is on by default if you
configured GCC using one of the @samp{powerpc*-*-eabi*} options.

@item -msdata=eabi
@opindex msdata=eabi
On System V.4 and embedded PowerPC systems, put small initialized
@code{const} global and static data in the @code{.sdata2} section, which
is pointed to by register @code{r2}.  Put small initialized
non-@code{const} global and static data in the @code{.sdata} section,
which is pointed to by register @code{r13}.  Put small uninitialized
global and static data in the @code{.sbss} section, which is adjacent to
the @code{.sdata} section.  The @option{-msdata=eabi} option is
incompatible with the @option{-mrelocatable} option.  The
@option{-msdata=eabi} option also sets the @option{-memb} option.

@item -msdata=sysv
@opindex msdata=sysv
On System V.4 and embedded PowerPC systems, put small global and static
data in the @code{.sdata} section, which is pointed to by register
@code{r13}.  Put small uninitialized global and static data in the
@code{.sbss} section, which is adjacent to the @code{.sdata} section.
The @option{-msdata=sysv} option is incompatible with the
@option{-mrelocatable} option.

@item -msdata=default
@itemx -msdata
@opindex msdata=default
@opindex msdata
On System V.4 and embedded PowerPC systems, if @option{-meabi} is used,
compile code the same as @option{-msdata=eabi}, otherwise compile code the
same as @option{-msdata=sysv}.

@item -msdata=data
@opindex msdata=data
On System V.4 and embedded PowerPC systems, put small global
data in the @code{.sdata} section.  Put small uninitialized global
data in the @code{.sbss} section.  Do not use register @code{r13}
to address small data however.  This is the default behavior unless
other @option{-msdata} options are used.

@item -msdata=none
@itemx -mno-sdata
@opindex msdata=none
@opindex mno-sdata
On embedded PowerPC systems, put all initialized global and static data
in the @code{.data} section, and all uninitialized data in the
@code{.bss} section.

@item -mblock-move-inline-limit=@var{num}
@opindex mblock-move-inline-limit
Inline all block moves (such as calls to @code{memcpy} or structure
copies) less than or equal to @var{num} bytes.  The minimum value for
@var{num} is 32 bytes on 32-bit targets and 64 bytes on 64-bit
targets.  The default value is target-specific.

@item -G @var{num}
@opindex G
@cindex smaller data references (PowerPC)
@cindex .sdata/.sdata2 references (PowerPC)
On embedded PowerPC systems, put global and static items less than or
equal to @var{num} bytes into the small data or BSS sections instead of
the normal data or BSS section.  By default, @var{num} is 8.  The
@option{-G @var{num}} switch is also passed to the linker.
All modules should be compiled with the same @option{-G @var{num}} value.

@item -mregnames
@itemx -mno-regnames
@opindex mregnames
@opindex mno-regnames
On System V.4 and embedded PowerPC systems do (do not) emit register
names in the assembly language output using symbolic forms.

@item -mlongcall
@itemx -mno-longcall
@opindex mlongcall
@opindex mno-longcall
By default assume that all calls are far away so that a longer and more
expensive calling sequence is required.  This is required for calls
farther than 32 megabytes (33,554,432 bytes) from the current location.
A short call is generated if the compiler knows
the call cannot be that far away.  This setting can be overridden by
the @code{shortcall} function attribute, or by @code{#pragma
longcall(0)}.

Some linkers are capable of detecting out-of-range calls and generating
glue code on the fly.  On these systems, long calls are unnecessary and
generate slower code.  As of this writing, the AIX linker can do this,
as can the GNU linker for PowerPC/64.  It is planned to add this feature
to the GNU linker for 32-bit PowerPC systems as well.

In the future, GCC may ignore all longcall specifications
when the linker is known to generate glue.

@item -mtls-markers
@itemx -mno-tls-markers
@opindex mtls-markers
@opindex mno-tls-markers
Mark (do not mark) calls to @code{__tls_get_addr} with a relocation
specifying the function argument.  The relocation allows the linker to
reliably associate function call with argument setup instructions for
TLS optimization, which in turn allows GCC to better schedule the
sequence.

@item -mrecip
@itemx -mno-recip
@opindex mrecip
This option enables use of the reciprocal estimate and
reciprocal square root estimate instructions with additional
Newton-Raphson steps to increase precision instead of doing a divide or
square root and divide for floating-point arguments.  You should use
the @option{-ffast-math} option when using @option{-mrecip} (or at
least @option{-funsafe-math-optimizations},
@option{-ffinite-math-only}, @option{-freciprocal-math} and
@option{-fno-trapping-math}).  Note that while the throughput of the
sequence is generally higher than the throughput of the non-reciprocal
instruction, the precision of the sequence can be decreased by up to 2
ulp (i.e.@: the inverse of 1.0 equals 0.99999994) for reciprocal square
roots.

@item -mrecip=@var{opt}
@opindex mrecip=opt
This option controls which reciprocal estimate instructions
may be used.  @var{opt} is a comma-separated list of options, which may
be preceded by a @code{!} to invert the option:

@table @samp

@item all
Enable all estimate instructions.

@item default
Enable the default instructions, equivalent to @option{-mrecip}.

@item none
Disable all estimate instructions, equivalent to @option{-mno-recip}.

@item div
Enable the reciprocal approximation instructions for both
single and double precision.

@item divf
Enable the single-precision reciprocal approximation instructions.

@item divd
Enable the double-precision reciprocal approximation instructions.

@item rsqrt
Enable the reciprocal square root approximation instructions for both
single and double precision.

@item rsqrtf
Enable the single-precision reciprocal square root approximation instructions.

@item rsqrtd
Enable the double-precision reciprocal square root approximation instructions.

@end table

So, for example, @option{-mrecip=all,!rsqrtd} enables
all of the reciprocal estimate instructions, except for the
@code{FRSQRTE}, @code{XSRSQRTEDP}, and @code{XVRSQRTEDP} instructions
which handle the double-precision reciprocal square root calculations.

@item -mrecip-precision
@itemx -mno-recip-precision
@opindex mrecip-precision
Assume (do not assume) that the reciprocal estimate instructions
provide higher-precision estimates than is mandated by the PowerPC
ABI.  Selecting @option{-mcpu=power6}, @option{-mcpu=power7} or
@option{-mcpu=power8} automatically selects @option{-mrecip-precision}.
The double-precision square root estimate instructions are not generated by
default on low-precision machines, since they do not provide an
estimate that converges after three steps.

@item -mpointers-to-nested-functions
@itemx -mno-pointers-to-nested-functions
@opindex mpointers-to-nested-functions
Generate (do not generate) code to load up the static chain register
(@code{r11}) when calling through a pointer on AIX and 64-bit Linux
systems where a function pointer points to a 3-word descriptor giving
the function address, TOC value to be loaded in register @code{r2}, and
static chain value to be loaded in register @code{r11}.  The
@option{-mpointers-to-nested-functions} is on by default.  You cannot
call through pointers to nested functions or pointers
to functions compiled in other languages that use the static chain if
you use @option{-mno-pointers-to-nested-functions}.

@item -msave-toc-indirect
@itemx -mno-save-toc-indirect
@opindex msave-toc-indirect
Generate (do not generate) code to save the TOC value in the reserved
stack location in the function prologue if the function calls through
a pointer on AIX and 64-bit Linux systems.  If the TOC value is not
saved in the prologue, it is saved just before the call through the
pointer.  The @option{-mno-save-toc-indirect} option is the default.

@item -mcompat-align-parm
@itemx -mno-compat-align-parm
@opindex mcompat-align-parm
Generate (do not generate) code to pass structure parameters with a
maximum alignment of 64 bits, for compatibility with older versions
of GCC.

Older versions of GCC (prior to 4.9.0) incorrectly did not align a
structure parameter on a 128-bit boundary when that structure contained
a member requiring 128-bit alignment.  This is corrected in more
recent versions of GCC.  This option may be used to generate code
that is compatible with functions compiled with older versions of
GCC.

The @option{-mno-compat-align-parm} option is the default.

@item -mstack-protector-guard=@var{guard}
@itemx -mstack-protector-guard-reg=@var{reg}
@itemx -mstack-protector-guard-offset=@var{offset}
@itemx -mstack-protector-guard-symbol=@var{symbol}
@opindex mstack-protector-guard
@opindex mstack-protector-guard-reg
@opindex mstack-protector-guard-offset
@opindex mstack-protector-guard-symbol
Generate stack protection code using canary at @var{guard}.  Supported
locations are @samp{global} for global canary or @samp{tls} for per-thread
canary in the TLS block (the default with GNU libc version 2.4 or later).

With the latter choice the options
@option{-mstack-protector-guard-reg=@var{reg}} and
@option{-mstack-protector-guard-offset=@var{offset}} furthermore specify
which register to use as base register for reading the canary, and from what
offset from that base register. The default for those is as specified in the
relevant ABI.  @option{-mstack-protector-guard-symbol=@var{symbol}} overrides
the offset with a symbol reference to a canary in the TLS block.
@end table


@node RISC-V Options
@subsection RISC-Vオプション
@cindex RISC-V Options

これらのコマンドラインオプションは、RISC-Vターゲットに対して定義されている。

@table @gcctabopt
@item -mbranch-cost=@var{n}
@opindex mbranch-cost
分岐のコストをおおよそ@var{n}命令に設定する。

@item -mplt
@itemx -mno-plt
@opindex plt
PICコードを生成するときは、PLTを使用を許可・禁止する。非PICの場合は無視される。デフォルトは@option{-mplt}である。

@item -mabi=@var{ABI-string}
@opindex mabi
整数と浮動小数点の呼び出し規約を指定する。 @var{ABI-string}は、整数型のサイズと浮動小数点型に使用されるレジスタの2つの部分を含んでいる。 たとえば、@samp{-march=rv64ifd -mabi=lp64d}は、@samp{long}とポインタが64ビット（暗黙的に@samp{int}を32ビットと定義している）を意味し、その浮動小数点値は64ビット幅がFレジスタで渡される。 これを@samp{-march=rv64ifd -mabi=lp64f}と比較すると、それではコンパイラはFとDの拡張機能を使用するコードを生成できる、最大32ビットの浮動小数点値のみをレジスタに渡すことができる。 もしくは、@samp{-march=rv64ifd -mabi=lp64}のとき、浮動小数点引数はレジスタに渡されない。

この引数のデフォルトはシステムに依存するが、特定の呼び出し規約を使用するユーザーは明示的に指定する必要がある。 有効な呼び出し規約は、@samp{ilp32}、@samp{ilp32f}、@samp{ilp32d}、@samp{lp64}、@samp{lp64f}、@samp{lp64d}である。一部の呼び出し規約は一部のISAでは実装できない。例えば、@samp{-march=rv32if -mabi=ilp32d}は、 ABIでは64ビットの値をFレジスタに渡す必要があるが、Fレジスタは32ビット幅しかないためは無効である。

@item -mfdiv
@itemx -mno-fdiv
@opindex mfdiv
ハードウェア浮動小数点除算および平方根命令は使用するかしない。これには、浮動小数点レジスタのFまたはD拡張が必要である。 デフォルトでは、指定されたアーキテクチャにこれらの命令がある場合は、それらを使用する。

@item -mdiv
@itemx -mno-div
@opindex mdiv
整数除算にハードウェア命令を使用するかしない。これにはM拡張が必要である。 デフォルトでは、指定されたアーキテクチャにこれらの命令がある場合は、それらを使用する。
   
@item -march=@var{ISA-string}
@opindex march
与えられたRISC-V ISAのコードを生成する（@samp{rv64im}など）。 ISA文字列は小文字でなければならない。 例には、@samp{rv64i}、@samp{rv32g}、@samp{rv32imaf}がある。

@item -mtune=@var{processor-string}
@opindex mtune
マイクロアーキテクチャ名で指定された、指定されたプロセッサの出力を最適化する。

@item -mpreferred-stack-boundary=@var{num}
@opindex mpreferred-stack-boundary
Attempt to keep the stack boundary aligned to a 2 raised to @var{num}
byte boundary.  If @option{-mpreferred-stack-boundary} is not specified,
the default is 4 (16 bytes or 128-bits).

@strong{Warning:} If you use this switch, then you must build all modules with
the same value, including any libraries.  This includes the system libraries
and startup modules.

@item -msmall-data-limit=@var{n}
@opindex msmall-data-limit
@var{n}バイトよりも小さいグローバルデータと静的データを（特定のターゲット上では）特別なセクションに入れる。

@item -msave-restore
@itemx -mno-save-restore
@opindex msave-restore
ライブラリー関数呼び出しを使用するより小さいがより遅いプロローグとエピローグのコードを使用するかしない。 デフォルトでは、高速インラインプロローグとエピローグを使用する。

@item -mstrict-align
@itemx -mno-strict-align
@opindex mstrict-align
アラインされていないメモリアクセスを生成しないかする。 デフォルトは、最適化しているプロセッサが高速のアラインされていないアクセスをサポートしているかどうかによって設定される。
 
@item -mcmodel=medlow
@opindex mcmodel=medlow
中低コードモデル用のコードを生成する。 プログラムとその静的に定義されたシンボルは、単一の2GiBアドレス範囲内になければならず、絶対アドレス@minus{}2 GiBと+2 GiBの間になければならない。 プログラムは静的または動的にリンクできる。 これがデフォルトコードモデルである。
 
@item -mcmodel=medany
@opindex mcmodel=medany
medium-anyコードモデル用のコードを生成する。 プログラムとその静的に定義されたシンボルは、任意の単一の2GiBアドレス範囲内になければならない。 プログラムは静的または動的にリンクできる。

@item -mexplicit-relocs
@itemx -mno-exlicit-relocs
シンボリックアドレスを扱うときは、アセンブラ再配置演算子を使用するか使用しない。 代わりにアセンブラマクロを使用することができる、最適化を制限することがある。

@item -mrelax
@itemx -mno-relax
Take advantage of linker relaxations to reduce the number of instructions
required to materialize symbol addresses. The default is to take advantage of
linker relaxations.

@end table

@node RL78 Options
@subsection RL78オプション
@cindex RL78 Options

@table @gcctabopt

@item -msim
@opindex msim
シミュレータ内の操作をサポートするための追加のターゲットライブラリ内のリンク。

@item -mmul=none
@itemx -mmul=g10
@itemx -mmul=g13
@itemx -mmul=g14
@itemx -mmul=rl78
@opindex mmul
使用するハードウェア乗算および除算サポートのタイプを指定する。 最も簡単なのは、乗算と除算の両方にソフトウェアを使用する@code{none}である。 これがデフォルトである。 値@code{g13}は、RL78/G13（S2コア）ターゲットで検出されたハードウェア乗除算周辺機器の値である。 値@code{g14}は、RL78/G14（S3コア）でサポートされている乗算命令と除算命令の使用を選する。 @code{rl78}は@code{g14}の別名で、@code{mg10}は@code{none}の別名である。

さらに、このオプションの設定に基づいて、Cプリプロセッサマクロが定義されている。 可能な値は、@code{__RL78_MUL_NONE__}、@code{__RL78_MUL_G13__}または@code {__RL78_MUL_G14__}である。

@item -mcpu=g10
@itemx -mcpu=g13
@itemx -mcpu=g14
@itemx -mcpu=rl78
@opindex mcpu
ターゲットにするRL78コアを指定する。デフォルトはG14コアで、S3コアまたはRL78とも呼ばれる。 G13またはS2コアは、乗算および除算命令を持たず、代わりにこれらの操作にハードウェア周辺機器を使用する。 G10またはS1コアにはレジスタバンクがないため、別の呼び出し規約が使用される

このオプションが設定されている場合は、コマンドラインの明示的な@option{-mmul=none}オプションで上書きされない限り、使用するハードウェア乗算サポートのタイプも選択される。したがって、@option{-mcpu = g13}を指定すると、G13ハードウェア乗算周辺機能を使用できる。また、@option{-mcpu=g10}を指定すると、ハードウェア乗算の使用が完全に無効になる。

コマンドラインで@option{-mcpu=g14}または@option{-mcpu=rl78}を指定すると、G4のハードウェア乗算サポートも有効になるため、RL78/G14コアはデフォルトのターゲットだが、ツールチェーンの動作は変更される。これらのオプションがコマンドラインで指定されていない場合、コードがRL78コアをターゲットにしていても、ソフトウェア乗算ルーチンが使用される。これは、ハードウェア乗算および除算サポートを持たない古いツールチェーンとの下位互換性のためである。

さらに、このオプションの設定に基づいて、Cプリプロセッサマクロが定義されている。可能な値は、@code{__RL78_G10__}、@code{__RL78_G13__}または@code{__RL78_G14__}である。

@item -mg10
@itemx -mg13
@itemx -mg14
@itemx -mrl78
@opindex mg10
@opindex mg13
@opindex mg14
@opindex mrl78
これらは対応する@option{-mcpu=}オプションの別名である。 後方互換性のために提供されている。

@item -mallregs
@opindex mallregs
コンパイラが使用可能なすべてのレジスタを使用できるようにする。 デフォルトでは、レジスタ@code{r24..r31}は割り込みハンドラで使用するために予約されている。 このオプションを有効にすると、これらのレジスタは通常の関数でも使用できる。

@item -m64bit-doubles
@itemx -m32bit-doubles
@opindex m64bit-doubles
@opindex m32bit-doubles
@code{double}データ型を64ビット（@option{-m64bit-doubles}）または32ビット（@option{-m32bit-doubles}）のサイズにする。 デフォルトは@option{-m32bit-doubles}である。

@item -msave-mduc-in-interrupts
@itemx -mno-save-mduc-in-interrupts
@opindex msave-mduc-in-interrupts
@opindex mno-save-mduc-in-interrupts
割り込みハンドラ関数がMDUCレジスタを保持する必要があることを指定する。 これは、通常のコードがMDUCレジスタを使用する場合にのみ必要である。たとえば、乗算と除算を実行するため。 デフォルトでは、MDUCレジスタは無視されるため、割り込みハンドラが高速になる。 この機能はG13ターゲット（S2コア）でのみ使用できるため、ターゲットオプション-mg13を渡す必要がある。 MDUCレジスタは、割り込みハンドラが乗算または除算演算を実行するか、または別の関数を呼び出す場合にのみ保存される。

@end table

@node RS/6000 and PowerPC Options
@subsection IBM RS/6000とPowerPCのオプション
@cindex RS/6000 and PowerPC Options
@cindex IBM RS/6000 and PowerPC Options

これらの@samp {-m}オプションは、IBM RS / 6000とPowerPC用に定義されている。
@table @gcctabopt
@item -mpowerpc-gpopt
@itemx -mno-powerpc-gpopt
@itemx -mpowerpc-gfxopt
@itemx -mno-powerpc-gfxopt
@need 800
@itemx -mpowerpc64
@itemx -mno-powerpc64
@itemx -mmfcrf
@itemx -mno-mfcrf
@itemx -mpopcntb
@itemx -mno-popcntb
@itemx -mpopcntd
@itemx -mno-popcntd
@itemx -mfprnd
@itemx -mno-fprnd
@need 800
@itemx -mcmpb
@itemx -mno-cmpb
@itemx -mmfpgpr
@itemx -mno-mfpgpr
@itemx -mhard-dfp
@itemx -mno-hard-dfp
@opindex mpowerpc-gpopt
@opindex mno-powerpc-gpopt
@opindex mpowerpc-gfxopt
@opindex mno-powerpc-gfxopt
@opindex mpowerpc64
@opindex mno-powerpc64
@opindex mmfcrf
@opindex mno-mfcrf
@opindex mpopcntb
@opindex mno-popcntb
@opindex mpopcntd
@opindex mno-popcntd
@opindex mfprnd
@opindex mno-fprnd
@opindex mcmpb
@opindex mno-cmpb
@opindex mmfpgpr
@opindex mno-mfpgpr
@opindex mhard-dfp
@opindex mno-hard-dfp
これらのオプションを使用して、使用しているプロセッサで使用可能な命令を指定する。 これらのオプションのデフォルト値は、GCCを設定するときに決定される。 @option{-mcpu=@var{cpu_type}}を指定すると、これらのオプションの指定が上書きされる。 上記のオプションではなく、@option{-mcpu=@var{cpu_type}}オプションを使用することを推奨する。

@option{-mpowerpc-gpopt}を指定すると、GCCは、汎用目的のグループ（浮動小数点平方根を含む）でオプションのPowerPCアーキテクチャ命令を使用することができる。 @option{-mpowerpc-gfxopt}を指定すると、GCCはグラフィックスグループ内のオプションのPowerPCアーキテクチャ命令（浮動小数点選択を含む）を使用することができる。

@option{-mmfcrf}オプションを使用すると、GCCはPOWER4プロセッサーおよびPowerPC V2.01アーキテクチャーをサポートする他のプロセッサーで実装された条件レコード・フィールド命令からの移動を生成することができる。
@option{-mpopcntb}オプションを使用すると、GCCはPOWER5プロセッサーおよびPowerPC V2.02アーキテクチャーをサポートする他のプロセッサーで実装されたpopcountおよび倍精度のFP逆数推定命令を生成できる。
@option{-mpopcntd}オプションを使用すると、GCCはPOWER7プロセッサーとPowerPC V2.06アーキテクチャーをサポートする他のプロセッサーで実装されたpopcount命令を生成することができる。
@option{-mfprnd}オプションを使用すると、GCCはPOWER5+プロセッサとPowerPC V2.03アーキテクチャをサポートする他のプロセッサで実装されたFP命令の整数命令を生成することができる。
@option{-mpopcntd}オプションを使用すると、GCCはPOWER7プロセッサーとPowerPC V2.06アーキテクチャーをサポートする他のプロセッサーで実装されたpopcount命令を生成することができる。
@option{-mfprnd}オプションを使用すると、GCCはPOWER5+プロセッサとPowerPC V2.03アーキテクチャをサポートする他のプロセッサで実装されたFP命令の整数命令を生成することができる。
@option{-mcmpb}オプションを使用すると、GCCはPower6プロセッサーとPowerPC V2.05アーキテクチャーをサポートする他のプロセッサーで実装された比較バイト命令を生成することができる。
@option{-mmfpgpr}オプションを使用すると、GCCは拡張POWERPC V2.05アーキテクチャーをサポートするPOWER6Xプロセッサーや他のプロセッサーに実装されている汎用レジスタ命令との間でFP移動を発生させることができる。
@option{-mhard-dfp}オプションを使用すると、GCCは一部のPOWERプロセッサで実装された10進浮動小数点命令を生成できる。

@option{-mpowerpc64}オプションを使用すると、GCCは完全なPowerPC64アーキテクチャにある追加の64ビット命令を生成し、GPRを64ビットのダブルワード数として扱うことができる。 GCCのデフォルトは@option{-mno-powerpc64}である。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var{cpu_type}のアーキテクチャタイプ、レジスタ使用法、および命令スケジューリングパラメータを設定する。@var{cpu_type}のサポートされている値は@samp{401}, @samp{403},
@samp{405}, @samp{405fp}, @samp{440}, @samp{440fp}, @samp{464}, @samp{464fp},
@samp{476}, @samp{476fp}, @samp{505}, @samp{601}, @samp{602}, @samp{603},
@samp{603e}, @samp{604}, @samp{604e}, @samp{620}, @samp{630}, @samp{740},
@samp{7400}, @samp{7450}, @samp{750}, @samp{801}, @samp{821}, @samp{823},
@samp{860}, @samp{970}, @samp{8540}, @samp{a2}, @samp{e300c2},
@samp{e300c3}, @samp{e500mc}, @samp{e500mc64}, @samp{e5500},
@samp{e6500}, @samp{ec603e}, @samp{G3}, @samp{G4}, @samp{G5},
@samp{titan}, @samp{power3}, @samp{power4}, @samp{power5}, @samp{power5+},
@samp{power6}, @samp{power6x}, @samp{power7}, @samp{power8},
@samp{power9}, @samp{powerpc}, @samp{powerpc64}, @samp{powerpc64le}, @samp{rs64}, @samp{native}である。

@option{-mcpu=powerpc}, @option{-mcpu=powerpc64}, @option{-mcpu=powerpc64le}は純粋な32ビットPowerPC（エンディアン）、64ビットビッグエンディアンPowerPCおよび64ビットリトルエンディアンPowerPCアーキテクチャの機種を指定し、適切な汎用プロセッサモデルをスケジューリングの目的で使用する。 

cpuタイプとして@samp{native}を指定すると、コンパイルを実行するシステムのホストプロセッサに対応するアーキテクチャオプションが検出され、選択される。 GCCがプロセッサを認識しない場合、@option{-mcpu = native}は効果がない。

他のオプションは、特定のプロセッサを指定する。 これらのオプションで生成されたコードは、そのプロセッサ上で最適に実行され、他のプロセッサ上ではまったく動作しない可能性がある。

@option{-mcpu}オプションは、自動的に次のオプションを有効または無効にする。

@gccoptlist{-maltivec  -mfprnd  -mhard-float  -mmfcrf  -mmultiple 
-mpopcntb -mpopcntd  -mpowerpc64 
-mpowerpc-gpopt  -mpowerpc-gfxopt  -msingle-float -mdouble-float 
-msimple-fpu  -mmulhw  -mdlmzb  -mmfpgpr -mvsx 
-mcrypto -mhtm -mpower8-fusion -mpower8-vector 
-mquad-memory -mquad-memory-atomic -mfloat128 -mfloat128-hardware}

特定のCPUに設定される特定のオプションは、そのCPUに最適なコードを生成するような設定に応じて、コンパイラのバージョンによって異なる。 実際のハードウェアの機能を必ずしも反映しているとは限らない。 個々のオプションを特定の値に設定したい場合は、@option{-mcpu=970 -mno-altivec}のように@option{-mcpu}オプションの後に指定することができる。

AIXでは、@option{-maltivec}および@option{-mpowerpc64}オプションは、AIXがこれらのオプションを完全にサポートしていないため、現在のところ@option{-mcpu}オプションによって使用可能または使用不可にされていない。 あなたの環境で動作することが確実であれば、それらを個別に有効または無効にすることができる。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var{cpu_type}の命令スケジューリングパラメータを設定するが、@option{-mcpu=@var{cpu_type}}のようにアーキテクチャタイプやレジスタの使用方法は設定しない。 @option{-mcpu}と同じ@var{cpu_type}の値が@option{-mtune}に使用される。 どちらも指定されていれば、@option{-mcpu}で設定されたアーキテクチャとレジスタが使用されるが、@option{-mtune}で設定されたスケジューリングパラメータが使用される。

@item -mcmodel=small
@opindex mcmodel=small
小さなモデル用のPowerPC64コードを生成する：TOCは64kに制限されている。

@item -mcmodel=medium
@opindex mcmodel=medium
中間モデル用のPowerPC64コードを生成する：TOCとその他の静的データは合計で4Gまでである。 これは64ビットLinuxのデフォルトです。

@item -mcmodel=large
@opindex mcmodel=large
大型モデルのPowerPC64コードを生成する：TOCのサイズは最大4Gである。 他のデータとコードは、64ビットのアドレス空間によってのみ制限される。

@item -maltivec
@itemx -mno-altivec
@opindex maltivec
@opindex mno-altivec
AltiVec命令を使用する（使用しない）コードを生成し、AltiVec命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にする。 現在のABIをAltiVec ABI拡張で調整するには、@option{-mabi=altivec}を設定する必要がある。

@option{-maltivec=le}や@option{-maltivec=be}ではなく、@option{-maltivec}を使用すると、@code{vec_splat}や@code{vec_extract}などのAltiVec組み込み関数の要素の順序は、 および@code{vec_insert}は、ターゲットのエンディアンに対応する配列要素の順序に一致する。 つまり、要素ゼロは、ビッグエンディアンプラットフォームをターゲットにするときにベクトルレジスタの最も左の要素を識別し、リトルエンディアンプラットフォームをターゲットにするときにベクトルレジスタの最も右の要素を識別する。

@item -maltivec=be
@opindex maltivec=be
ターゲットがビッグエンディアンかリトルエンディアンかにかかわらず、ビッグエンディアンの要素順序を使用してAltiVec命令を生成する。 これは、ビッグエンディアンのプラットフォームをターゲットとする場合のデフォルトである。このオプションは現在非推奨である。この機能のサポートはGCCで取り除かれるだろう。

要素の順序は、@code{vec_splat}、@code{vec_extract}、@code{vec_insert}などのAltiVec組み込み関数の要素番号を解釈するために使用される。 デフォルトでは、ターゲットのエンディアンに対応する配列要素の順序に一致する。
@item -maltivec=le
@opindex maltivec=le
ターゲットがビッグエンディアンかリトルエンディアンかにかかわらず、リトルエンディアンの要素順序を使用してAltiVec命令を生成する。 これは、リトルエンディアンプラットフォームをターゲットとする場合のデフォルトである。 このオプションは、ビッグエンディアンのプラットフォームをターゲットにする場合は現在無視される。

要素の順序は、@code{vec_splat}、@code{vec_extract}、@code{vec_insert}などのAltiVec組み込み関数の要素番号を解釈するために使用される。 デフォルトでは、ターゲットのエンディアンに対応する配列要素の順序に一致する。
@item -mvrsave
@itemx -mno-vrsave
@opindex mvrsave
@opindex mno-vrsave
AltiVecコードを生成するときにVRSAVE命令を生成する。

@item -msecure-plt
@opindex msecure-plt
@command{ld}と@command{ld.so}が実行不可能な@code{.plt}セクションと@code{.got}セクションで実行可能ファイルと共有ライブラリをビルドできるようなコードを生成する。 これはPowerPC 32ビットSYSV ABIオプションである。

@item -mbss-plt
@opindex mbss-plt
@command{ld.so}が書き込むBSS@code {.plt}セクションを使用するコードを生成し、書き込み可能で実行可能な@code{.plt}セクションと@code{.got}セクションを要求する。 これはPowerPC 32ビットSYSV ABIオプションである。

@item -misel
@itemx -mno-isel
@opindex misel
@opindex mno-isel
このスイッチは、ISEL命令の生成を有効または無効にする。

@item -misel=@var{yes/no}
このスイッチは非推奨である。 代わりに、@option{-misel}と@option{-mno-isel}を使うこと。

@item -mpaired
@itemx -mno-paired
@opindex mpaired
@opindex mno-paired
このスイッチは、PAIRED simd命令の生成を有効または無効にする。

@item -mspe=@var{yes/no}
このオプションは非推奨である。 代わりに@option{-mspe}と@option{-mno-spe}を使うこと。

@item -mvsx
@itemx -mno-vsx
@opindex mvsx
@opindex mno-vsx
ベクトル/スカラー（VSX）命令を使用する（しない）コードを生成し、VSX命令セットへのより直接的なアクセスを可能にする組み込み関数の使用も可能にする。

@item -mcrypto
@itemx -mno-crypto
@opindex mcrypto
@opindex mno-crypto
PowerPC ISAのバージョン2.07で追加された暗号化命令に直接アクセスできる組み込み関数の使用を有効（無効）にする。

@item -mhtm
@itemx -mno-htm
@opindex mhtm
@opindex mno-htm
PowerPC ISAのバージョン2.07で追加されたハードウェアトランザクションメモリ（HTM）命令に直接アクセスできる組み込み関数の使用を有効（無効）にする。

@item -mpower8-fusion
@itemx -mno-power8-fusion
@opindex mpower8-fusion
@opindex mno-power8-fusion
Power8以降のプロセッサで命令を融合させるために、整数演算を隣接して保持するコードを生成する。

@item -mpower8-vector
@itemx -mno-power8-vector
@opindex mpower8-vector
@opindex mno-power8-vector
PowerPC ISAのバージョン2.07で追加されたベクトルおよびスカラー命令を使用する（しない）コードを生成する。 また、ベクトル命令へのより直接的なアクセスを可能にする組み込み関数の使用を可能にする。

@item -mquad-memory
@itemx -mno-quad-memory
@opindex mquad-memory
@opindex mno-quad-memory
非アトミック・クワッドワードメモリ命令を使用する（しない）コードを生成する。 @option{-mquad-memory}オプションを使用するには、64ビットモードを使用する必要がある。

@item -mquad-memory-atomic
@itemx -mno-quad-memory-atomic
@opindex mquad-memory-atomic
@opindex mno-quad-memory-atomic
アトミッククワッドワードメモリ命令を使用する（しない）コードを生成する。 @option{-mquad-memory-atomic}オプションを使用するには、64ビットモードを使用する必要がある。

@item -mfloat128
@itemx -mno-float128
@opindex mfloat128
@opindex mno-float128
ソフトウェアエミュレーションまたはハードウェア命令を使用したIEEE 128ビット浮動小数点の@var{__float128}キーワードを有効/無効にする。

IEEE 128ビット浮動小数点サポートを使用するには、VSX命令セット（@option{-mvsx}、@option{-mcpu=power7}、@option{-mcpu=power8}）または@option{-mcpu=power9}を有効にする必要がある。IEEE 128ビット浮動小数点サポートは、PowerPC Linuxシステムでのみ動作する。
 
@option{-mfloat128}のデフォルトは、VSX命令セットを使用するPowerPC Linuxシステムで有効になり、他のシステムでは無効になる。
 
64ビットシステムでISA 3.0命令セット（@option{-mpower9-vector}または@option{-mcpu=power9}）を使用すると、IEEE 128ビット浮動小数点サポートによってISA 3.0 IEEE 128ビット浮動小数点命令の生成も有効になる。 それ以外の場合、ISA 3.0命令の生成を指定していない場合、または32ビットビッグエンディアンシステムをターゲットにしている場合は、IEEE 128ビット浮動小数点がソフトウェアエミュレーションで行われる。

@item -mfloat128-hardware
@itemx -mno-float128-hardware
@opindex mfloat128-hardware
@opindex mno-float128-hardware
@var{__float128}データ型をサポートするためにISA 3.0ハードウェア命令を有効/無効にする。

@option {-mfloat128-hardware}のデフォルトは、ISA 3.0命令セットを使用するPowerPC Linuxシステムで有効になり、他のシステムでは無効になる。

@item -m32
@itemx -m64
@opindex m32
@opindex m64
DarwinおよびSVR4ターゲット（GNU/Linuxを含む）の32ビットまたは64ビット環境用のコードを生成する。 32ビット環境は、int、long、および32ビットへのポインタを設定し、任意のPowerPCバリアントで実行されるコードを生成する。 64ビット環境では、intを32ビット、longとポインタを64ビットに設定し、PowerPC64用のコードを@option{-mpowerpc64}と同様に生成する。

@item -mfull-toc
@itemx -mno-fp-in-toc
@itemx -mno-sum-in-toc
@itemx -mminimal-toc
@opindex mfull-toc
@opindex mno-fp-in-toc
@opindex mno-sum-in-toc
@opindex mminimal-toc
実行可能ファイルごとに作成されるTOC（目次）の生成を変更する。 @option{-mfull-toc}オプションはデフォルトで選択されている。その場合、GCCはプログラム内の一意の非自動変数参照ごとに少なくとも1つのTOCエントリを割り当てる。 GCCは浮動小数点定数もTOCに配置する。ただし、TOCでは16,384エントリしか利用できない。


使用可能なTOC領域がオーバーフローしたというリンカーエラーメッセージが表示された場合は、@option{-mno-fp-in-toc}および@option{-mno-sum-in}で使用されるTOC領域の量を減らすことができる。@option{-mno-fp-in-toc}は、GCCが浮動小数点定数をTOCに入れないようにし、@option{-mno-sum-in-toc}はGCCにアドレスと その合計をTOCに入れるのではなく、実行時に定数を返す。これらのオプションの1つまたは両方を指定することができる。それぞれは、TOCのスペースを節約する代わりに、GCCに非常にわずかに遅く大きなコードを生成させる。

これらのオプションの両方を指定してもTOCのスペースが足りなくなった場合は、代わりに@option{-mminimal-toc}を指定する。 このオプションを指定すると、GCCはすべてのファイルに対してTOCエントリを1つだけ作成する。 このオプションを指定すると、GCCはコードの生成速度が遅くなるが、TOCの容量はごくわずかになる。 このオプションは、実行頻度の低いコードを含むファイルに対してのみ使用したいかもしれない。

@item -maix64
@itemx -maix32
@opindex maix64
@opindex maix32
64ビットのAIX ABIおよび呼び出し規約：64ビット・ポインタ、64ビットの@code{long}タイプ、およびそれらをサポートするために必要なインフラストラクチャを有効にする。@option{-maix64}は@option{-mpowerpc64}を含み、@option{-maix32}は64ビットABIを無効にし、@option{-mno-powerpc64}を含む。 GCCのデフォルトは@option{-maix32}である。

@item -mxl-compat
@itemx -mno-xl-compat
@opindex mxl-compat
@opindex mno-xl-compat
AIX互換のABIを使用している場合、IBM XLコンパイラのセマンティクスに準拠したコードを生成する。引数FPRに加えて、スタック上のレジスタ退避領域（RSA）を超えてプロトタイプ関数に浮動小数点引数を渡す。値を比較してdoubleに変換するとき、128ビットlong double値の最も重要なdoubleが適切に丸められていると仮定しない。long doubleサポート・ルーチンにはXLシンボル名を使用する。

AIXの呼び出し規約は拡張されたが、宣言された引数よりも引数が少ない引数のアドレスを取る関数を呼び出すK＆R Cの不明確なケースを処理するために、最初は文書化されていなかった。IBM XLコンパイラは、サブルーチンが最適化されずにコンパイルされたときにスタックからRSAに収まらない浮動小数点引数にアクセスする。スタックに常に浮動小数点引数を格納するのは非効率的で、めったに必要ないので、このオプションはデフォルトでは有効になっていなく、最適化せずにIBM XLコンパイラでコンパイルされたサブルーチンを呼び出すときにのみ必要である。

@item -mpe
@opindex mpe
@dfn {IBM RS/6000 SP} @dfn {Parallel Environment}（PE）をサポートする。 特別なスタートアップコードでメッセージパッシングを使用するように記述されたアプリケーションをリンクして、アプリケーションを実行できるようにする。 システムはPEを標準の場所（@file{/usr/lpp/ppe.poe/}）にインストールする必要がある。また、適切なディレクトリの場所を指定するために@file{specs}ファイルを@option{-specs=}オプションで上書きする必要がある。 パラレル環境はスレッドをサポートしないため、@option{-mpe}オプションと@option{-pthread}オプションは互換性がない。

@item -malign-natural
@itemx -malign-power
@opindex malign-natural
@opindex malign-power
AIX、32ビットDarwin、および64ビットPowerPC GNU/Linuxの場合、オプション@option{-malign-natural}は浮動小数点倍精度型のような自然なサイズベースの境界より大きな型でのABI定義の整列をオーバーライドする。オプション@option{-malign-power}は、GCCにABI指定のアラインメント規則に従うよう指示しする。 GCCのデフォルトは、ABIで定義されている標準的な配置である。

64ビットDarwinでは、自然な配置がデフォルトであり、@option{-malign-power}はサポートされていない。

@item -msoft-float
@itemx -mhard-float
@opindex msoft-float
@opindex mhard-float
浮動小数点レジスタセットを使用しない（する）コードを生成します。@option{-msoft-float}オプションを使用するとソフトウェア浮動小数点エミュレーションが提供され、リンク時にGCCにオプションが渡される。

@item -msingle-float
@itemx -mdouble-float
@opindex msingle-float
@opindex mdouble-float
単精度または倍精度浮動小数点演算用のコードを生成する。 @option{-mdouble-float}は@option{-msingle-float}を含む。

@item -msimple-fpu
@opindex msimple-fpu
ハードウェア浮動小数点ユニットの@code{sqrt}命令と@code{div}命令を生成しない。

@item -mfpu=@var{name}
@opindex mfpu
浮動小数点ユニットのタイプを指定する。@var{name}の有効な値は@samp{sp_lite}（@option{-msingle-float -msimple-fpu}と同じ）、@samp{dp_lite}（@option{-mdouble-float -msimple-fpu}と同じ）、@samp{sp_full}（@option{-msingle-float}と同じ）、@samp{dp_full}（@option{-mdouble-float}と同じ）である。

@item -mxilinx-fpu
@opindex mxilinx-fpu
ザイリンクスPPC 405/440の浮動小数点ユニットの最適化を実行する。

@item -mmultiple
@itemx -mno-multiple
@opindex mmultiple
@opindex mno-multiple
複数ワードのロード命令とストアの複数ワード命令を使用する（しない）コードを生成する。これらの命令は、デフォルトではPOWERシステムで生成され、PowerPCシステムでは生成されない。リトルエンディアンのPowerPCシステムでは、これらの命令がプロセッサがリトルエンディアンモードの時は動作しないため、@option{-multiple}は使用しないこと。例外は、リトルエンディアンモードでこれらの命令を許可するPPC740とPPC750である。

@item -mupdate
@itemx -mno-update
@opindex mupdate
@opindex mno-update
ベースレジスタを計算されたメモリ位置のアドレスに更新するロードまたはストア命令を使用する（しない）コードを生成する。これらの命令は、デフォルトで生成される。 @option{-mno-update}を使用すると、スタックポインタが更新されてから前のフレームのアドレスが格納されるまでの間に小さなウィンドウが表示され、それはスタックフレームを割り込みまたは信号を迂回して歩くコードは破損したデータを取得する可能性があることを意味する。

@item -mavoid-indexed-addresses
@itemx -mno-avoid-indexed-addresses
@opindex mavoid-indexed-addresses
@opindex mno-avoid-indexed-addresses
インデックス付きのロードまたはストア命令の使用を回避する（しない）コードを生成する。 これらの命令は、16M境界を横切る大きなアレイをステップ実行する場合など、特定の状況でPower6プロセッサでパフォーマンスの低下を招く可能性がある。 このオプションは、Power6をターゲットに設定するとデフォルトで有効になり、それ以外の場合は無効になる。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点乗加算命令を使用する（しない）コードを生成する。 ハードウェア浮動小数点が使用されている場合、これらの命令はデフォルトで生成される。 マシンに依存する@option{-mfused-madd}オプションは、マシンに依存しない@option{-ffp-contract=fast}オプションにマップされ、@option{-mno-fused-madd}は@option{-ffp-contract=off}にマップされる。

@item -mmulhw
@itemx -mno-mulhw
@opindex mmulhw
@opindex mno-mulhw
IBM 405,440,464、および476プロセッサ上のハーフワード乗算命令および乗加算命令を使用する（しない）コードを生成する。これらの命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item -mdlmzb
@itemx -mno-dlmzb
@opindex mdlmzb
@opindex mno-dlmzb
IBM 405、440、464、および476プロセッサーで文字列検索@samp{dlmzb}命令を使用する（しない）コードを生成する。この命令は、これらのプロセッサーを対象とするときにデフォルトで生成される。

@item -mno-bit-align
@itemx -mbit-align
@opindex mno-bit-align
@opindex mbit-align
System V.4および組み込みPowerPCシステムでは、ビットフィールドを含む構造体および共用体をビットフィールドの基本型にアラインメントさせない（させる）。

例えば、デフォルトでは、長さ1の8個の@code{unsigned}ビットフィールドを含む構造体は、4バイト境界にアライメントされ、4バイトのサイズを持つ。 @option{-mno-bit-align}を使用すると、構造体は1バイトの境界に揃えられ、1バイトのサイズになる。

@item -mno-strict-align
@itemx -mstrict-align
@opindex mno-strict-align
@opindex mstrict-align
System V.4および組み込みPowerPCシステムでは、アライメントされていないメモリ参照がシステムによって処理されるとは想定しない。

@item -mrelocatable
@itemx -mno-relocatable
@opindex mrelocatable
@opindex mno-relocatable
実行時に静的な実行可能ファイルを別のアドレスに再配置できるようにする（しない）コードを生成する。 単純な組み込みPowerPCシステムローダーは、@code{.got2}の全内容と、このオプションによって生成された32ビットアドレスのテーブルである@code{.fixup}セクションにリストされている4バイトの場所を再配置する必要がある。 これを行うには、リンクされたすべてのオブジェクトを、@option{-mrelocatable}または@option{-mrelocatable-lib}でコンパイルする必要がある。

@item -mrelocatable-lib
@itemx -mno-relocatable-lib
@opindex mrelocatable-lib
@opindex mno-relocatable-lib
@option{-mrelocatable-lib}は@option{-mrelocatable}と同様に、実行時に静的実行ファイルを再配置できるように@code{.fixup}セクションを生成するが、@option {-mrelocatable-lib}は、@option {-mrelocatable}の小さなスタックアライメントを使用しない。 @option{-mrelocatable-lib}でコンパイルされたオブジェクトは、@option{-mrelocatable}オプションの任意の組み合わせでコンパイルされたオブジェクトとリンクできる。

@item -mno-toc
@itemx -mtoc
@opindex mno-toc
@opindex mtoc
System V.4および組み込みPowerPCシステムでは、レジスタ2に、プログラムで使用されているアドレスを指すグローバル領域へのポインタが含まれているとは想定しない。

@item -mlittle
@itemx -mlittle-endian
@opindex mlittle
@opindex mlittle-endian
System V.4および組み込みPowerPCシステムでは、プロセッサのコードをリトルエンディアンモードでコンパイルする。@option{-mlittle-endian}オプションは@option{-mlittle}と同じである。

@item -mbig
@itemx -mbig-endian
@opindex mbig
@opindex mbig-endian
System V.4および組み込みPowerPCシステムでは、プロセッサのコードをビッグエンディアンモードでコンパイルする。@option{-big-endian}オプションは@option{-mbig}と同じである。

@item -mdynamic-no-pic
@opindex mdynamic-no-pic
DarwinとMac OS Xシステムでは、再配置可能ではないはその外部参照が再配置可能になるようにコードをコンパイルする。 結果のコードは、アプリケーションには適しているが、共有ライブラリには適していない。

@item -msingle-pic-base
@opindex msingle-pic-base
PICアドレッシングに使用するレジスタは、各関数のプロローグに読み込むのではなく、読み取り専用として扱う。 ランタイムシステムは、実行を開始する前にこのレジスタを適切な値で初期化する必要がある。

@item -mprioritize-restricted-insns=@var{priority}
@opindex mprioritize-restricted-insns
このオプションは、2回目のスケジューリングパスでディスパッチスロット制限付き命令に割り当てられる優先度を制御する。 引数@var{priority}は、ディスパッチスロット制限付き命令にno、highest、またはsecond（最高）の優先度を割り当てるために、値@samp{0}、@samp{1}、または@samp{2}をとる。

@item -msched-costly-dep=@var{dependence_type}
@opindex msched-costly-dep
このオプションは、命令スケジューリング中にターゲットによって高価とみなされる依存関係を制御する。 引数@var{dependence_type}は、次のいずれかの値をとる。

@table @asis
@item @samp{no}
どの依存性も高価ではない。

@item @samp{all}
全依存性は高価である。

@item @samp{true_store_to_load}
ストアからロードへの真の依存性が高価である。

@item @samp{store_to_load}
ストアからロードへの全依存性が高価である。

@item @var{number}
レイテンシが@var{number}以上の依存関係は高価である。
@end table

@item -minsert-sched-nops=@var{scheme}
@opindex minsert-sched-nops
このオプションは、2回目のスケジューリングパスで使用されるNOP挿入方式を制御する。 引数@var{scheme}は、次の値のいずれかをとる：

@table @asis
@item @samp{no}
NOPを挿入しない。

@item @samp{pad}
スケジューラのグルーピングに従って、発行スロットが空いているディスパッチグループをNOPで埋める。

@item @samp{regroup_exact}
NOPを挿入して、高価な依存命令を別々のグループに強制する。 推定されたプロセッサグループに従って、命令を新しいグループに強制するために必要な数だけ正確にNOPを挿入する。

@item @var{number}
NOPを挿入して、高価な依存命令を別々のグループに強制する。 @var{number}NOPを挿入して命令を新しいグループに強制する。
@end table

@item -mcall-sysv
@opindex mcall-sysv
System V.4および組み込みPowerPCシステムでは、System V Application Binary InterfaceのPowerPCプロセッサ補足の1995年3月のドラフトを遵守した呼び出し規約を使用してコードをコンパイルする。@samp {powerpc-*-eabiaix}を使ってGCCを設定していない限り、これがデフォルトである。

@item -mcall-sysv-eabi
@itemx -mcall-eabi
@opindex mcall-sysv-eabi
@opindex mcall-eabi
@option{-mcall-sysv}と@option{-meabi}の両方のオプションを指定する。

@item -mcall-sysv-noeabi
@opindex mcall-sysv-noeabi
@option{-mcall-sysv}と@option{-mno-eabi}の両方のオプションを指定する。

@item -mcall-aixdesc
@opindex m
System V.4および組み込みPowerPCシステムで、AIXオペレーティング・システムのコードをコンパイルする。

@item -mcall-linux
@opindex mcall-linux
System V.4および組み込みPowerPCシステムで、LinuxベースのGNUシステムのコードをコンパイルする。

@item -mcall-freebsd
@opindex mcall-freebsd
System V.4および組み込みPowerPCシステムで、FreeBSDオペレーティングシステムのコードをコンパイルする。

@item -mcall-netbsd
@opindex mcall-netbsd
System V.4および組み込みPowerPCシステムで、NetBSDオペレーティングシステムのコードをコンパイルする。

@item -mcall-openbsd
@opindex mcall-netbsd
System V.4および組み込みPowerPCシステムで、OpenBSDオペレーティングシステムのコードをコンパイルする。

@item -mtraceback=@var{traceback_type}
@opindex mtraceback
Select the type of traceback table. Valid values for @var{traceback_type}
are @samp{full}, @samp{part}, and @samp{no}.

@item -maix-struct-return
@opindex maix-struct-return
メモリ内にすべての構造体を返す（AIX ABIで指定）。

@item -msvr4-struct-return
@opindex msvr4-struct-return
8バイトより小さい構造体をレジスタで返す（SVR4 ABIで指定）。

@item -mabi=@var{abi-type}
@opindex mabi
現在のABIを特定の拡張を追加するか、そのような拡張を削除する。可能な値は、@samp{altivec}, @samp{no-altivec}, @samp{spe}, @samp{no-spe}, @samp{ibmlongdouble}, @samp{ieeelongdouble}, @samp{elfv1}, @samp{elfv2}。

@item -mabi=ibmlongdouble
@opindex mabi=ibmlongdouble
現在のABIをIBM拡張精度のlong doubleを使用するように変更する。 これは、システムがデフォルトでIEEE拡張精度long doubleを使用している場合にはうまくいかない可能性がある。 long double型をIEEE拡張精度から変更すると、コンパイラは@option{-Wno-psabi}オプションを使用しないかぎり警告を発行する。

@item -mabi=ieeelongdouble
@opindex mabi=ieeelongdouble
現在のABIをIEEE拡張精度のlong doubleを使用するように変更します。 これは、システムがデフォルトでIBM拡張精度のlong doubleを使用する場合にはうまくいかない可能性がある。 long double型をIBM拡張精度から変更すると、コンパイラは@option{-Wno-psabi}オプションを使用しないかぎり警告を発行する。

@item -mabi=elfv1
@opindex mabi=elfv1
現在のABIをELFv1 ABIを使用するように変更する。これは、ビッグエンディアンのPowerPC 64ビットLinuxのデフォルトのABIである。デフォルトのABIを無効にするには特別なシステムサポートが必要で、壮大な方法で失敗する可能性がある。

@item -mabi=elfv2
@opindex mabi=elfv2
現在のABIをELFv2 ABIを使用するように変更する。これは、ビッグエンディアンのPowerPC 64ビットLinuxのデフォルトのABIである。デフォルトのABIを無効にするには特別なシステムサポートが必要で、壮大な方法で失敗する可能性がある。

@item -mgnu-attribute
@itemx -mno-gnu-attribute
@opindex mgnu-attribute
@opindex mno-gnu-attribute
.gnu_attributeアセンブリディレクティブを発行して、関数パラメータまたは戻り値のABIバリエーションを指定する.gnu.attributesセクションのタグ/値ペアを設定する。

@item -mprototype
@itemx -mno-prototype
@opindex mprototype
@opindex mno-prototype
System V.4および組み込みPowerPCシステムでは、可変引数関数へのすべての呼び出しが適切にプロトタイプ化されていることを前提としている。 それ以外の場合は、コンパイラは、プロトタイプ化されていないすべての呼び出しの前に、条件コードレジスタ(@code{CR})のビット6を設定またはクリアして関数が可変引数をとる場合に浮動小数点値を浮動小数点レジスタに渡すかどうかを示す命令を挿入する必要がある。 @option{-mprototype}では、プロトタイプの可変引数関数への呼び出しだけがビットを設定またはクリアする。

@item -msim
@opindex msim
組み込みPowerPCシステムで、起動モジュールは@file{sim-crt0.o}と呼ばれ、標準Cライブラリは@file{libsim.a}と@file{libc.a}であると仮定する。これは@samp{powerpc-*-eabisim}設定のデフォルトである。

@item -mmvme
@opindex mmvme
組み込みPowerPCシステムで、起動モジュールは@file{crt0.o}と呼ばれ、標準Cライブラリは@file{libmvme.a}と@file{libc.a}であると仮定する。

@item -mads
@opindex mads
組み込みPowerPCシステムで、起動モジュールが@file{crt0.o}と呼ばれ、標準Cライブラリは@file{libads.a}と@file{libc.a}であると仮定する。

@item -myellowknife
@opindex myellowknife
組み込みPowerPCシステムで、起動モジュールは@file{crt0.o}と呼ばれ、標準Cライブラリは@file{libyk.a}と@file{libc.a}であると仮定する。

@item -mvxworks
@opindex mvxworks
System V.4および組み込みPowerPCシステムでは、VxWorksシステム用にコンパイルすることを指定する。

@item -memb
@opindex memb
埋め込みPowerPCシステムでは、ELFフラグヘッダーの@code{PPC_EMB}ビットを設定して、@samp{eabi}拡張再配置が使用されていることを示す。

@item -meabi
@itemx -mno-eabi
@opindex meabi
@opindex mno-eabi
System V.4および組み込みPowerPCシステムで、System V.4仕様の変更セットであるEmbedded Applications Binary Interface（EABI）に準拠する（しない）。@option {-meabi}を選択すると、スタックが8バイトの境界に揃えられ、関数@code{__eabi}が@code{main}から呼び出されてEABI環境が設定され、@option{-msdata} オプションは、@code{r2}と@code{r13}の両方を使用して、2つの別々の小さなデータ領域を指し示すことができる。@option{-mno-eabi}を選択すると、スタックが16バイトの境界に揃えられ、EABI初期化関数は@code{main}から呼び出されず、@option{-msdata}オプションは、単一の小さなデータ領域を指すために@code {r13}だけを使用するようになる。@samp{powerpc*-*-eabi*}オプションの1つを使ってGCCを設定した場合、@option{-meabi}オプションはデフォルトでオンになっている。

@item -msdata=eabi
@opindex msdata=eabi
System V.4および組み込みPowerPCシステムで、小さな初期化された@code{const}グローバルデータと静的データを@code{.sdata2}セクションに置く。このセクションは、@code {r2}によって参照される。 小さな初期化された非@code{const}グローバルデータと静的データを@code{.sdata}セクションに置いてください。これはレジスタ@code{r13}によって指されている。 @code{.sdss}セクションに隣接する@code{.sbss}セクションに、小さな初期化されていないグローバルデータと静的データを配置する。 @option{-msdata=eabi}オプションは、@option{-mrelocatable}オプションと互換性がない。 @option{-msdata=eabi}オプションは@option{-memb}オプションも設定する。

@item -msdata=sysv
@opindex msdata=sysv
System V.4および組み込みPowerPCシステムで、小規模のグローバルおよび静的データを@code{.sdata}セクションに配置する。これは、レジスタ @code{r13}によって指し示される。小さな初期化されていないグローバルデータと静的データを、 @code{.sdss}セクションに隣接する@code{.sbss}セクションに配置する。 @option{-msdata=sysv}オプションは、@option{-mrelocatable}オプションと互換性がない。

@item -msdata=default
@itemx -msdata
@opindex msdata=default
@opindex msdata
System V.4および組み込みPowerPCシステムで、@option{-meabi}を使用する場合、@option{-msdata=eabi}と同じコードをコンパイルする。そうでない場合は、@option{-msdata=sysv}と同じコードをコンパイルする。

@item -msdata=data
@opindex msdata=data
System V.4および組み込みPowerPCシステムで、小さなグローバルデータを@code{.sdata}セクションに配置する。 小さな初期化されていないグローバルデータを@code{.sbss}セクションに入れる。 しかし、小さなデータに対処するためにレジスタ@code{r13}を使用しない。 他の@option{-msdata}オプションを使用しない限り、これはデフォルトの動作である。

@item -msdata=none
@itemx -mno-sdata
@opindex msdata=none
@opindex mno-sdata
組み込みPowerPCシステムで、初期化されたグローバルデータと静的データを@code{.data}セクションに、初期化されていないすべてのデータを@code{.bss}セクションに配置する。

@item -mreadonly-in-sdata
@itemx -mreadonly-in-sdata
@opindex mreadonly-in-sdata
@opindex mno-readonly-in-sdata
Put read-only objects in the @code{.sdata} section as well.  This is the
default.

@item -mblock-move-inline-limit=@var{num}
@opindex mblock-move-inline-limit
@var{num}バイト以下のすべてのブロック移動（@code{memcpy}や構造体コピーの呼び出しなど）をインライン化する。 @var{num}の最小値は、32ビット・ターゲットでは32バイト、64ビット・ターゲットでは64バイトである。 デフォルト値はターゲット固有である。

@item -mblock-compare-inline-limit=@var{num}
@opindex mblock-compare-inline-limit
Generate non-looping inline code for all block compares (such as calls
to @code{memcmp} or structure compares) less than or equal to @var{num}
bytes. If @var{num} is 0, all inline expansion (non-loop and loop) of
block compare is disabled. The default value is target-specific.

@item -mblock-compare-inline-loop-limit=@var{num}
@opindex mblock-compare-inline-loop-limit
Generate an inline expansion using loop code for all block compares that
are less than or equal to @var{num} bytes, but greater than the limit
for non-loop inline block compare expansion. If the block length is not
constant, at most @var{num} bytes will be compared before @code{memcmp}
is called to compare the remainder of the block. The default value is
target-specific.

@item -mstring-compare-inline-limit=@var{num}
@opindex mstring-compare-inline-limit
Generate at most @var{num} pairs of load instructions to compare the
string inline. If the difference or end of string is not found at the
end of the inline compare a call to @code{strcmp} or @code{strncmp} will
take care of the rest of the comparison. The default is 8 pairs of
loads, which will compare 64 bytes on a 64-bit target and 32 bytes on a
32-bit target.

@item -G @var{num}
@opindex G
@cindex smaller data references (PowerPC)
@cindex .sdata/.sdata2 references (PowerPC)
埋め込みPowerPCシステムで、@var{num}バイト以下のグローバルおよび静的アイテムを、通常のデータまたはBSSセクションではなく、小データまたはBSSセクションに配置する。 デフォルトでは、@var{num}は8である。@option{-G @var {num}}スイッチもリンカに渡される。 すべてのモジュールは同じ@option{-G @var {num}}値でコンパイルする必要がある。

@item -mregnames
@itemx -mno-regnames
@opindex mregnames
@opindex mno-regnames
System V.4および組み込みPowerPCシステムでは、シンボリックフォームを使用してアセンブリ言語出力のレジスタ名を発行する（しない）。

@item -mlongcall
@itemx -mno-longcall
@opindex mlongcall
@opindex mno-longcall
デフォルトでは、すべてのコールが遠く離れているため、より長くより高価なコールシーケンスが必要になると想定する。 これは、現在の場所から32メガバイト（33,554,432バイト）を超えた呼び出しに必要である。コンパイラーがその呼び出しを遠くにすることができないことを知っている場合、短い呼び出しが生成される。 この設定は、@code{shortcall}関数の属性、または@code{#pragma longcall（0）}によって無効にすることができる。

いくつかのリンカは、範囲外のコールを検出し、その場でグルーコードを生成することができる。 これらのシステムでは、長い呼び出しは不要で、より遅いコードを生成する。 この記事の執筆時点では、PowerPC/64のGNUリンカーと同様に、AIXリンカーがこれを行うことができる。 この機能を32ビットPowerPCシステムのGNUリンカに追加する予定である。

Darwin/PPCシステムでは、@code{#pragma longcall}は@code{jbsr callee, L42}と@dfn{branch island（分岐島）}（グルーコード）を生成する。 2つのターゲットアドレスは、呼び出し先と分岐島を表します。 Darwin/PPCリンカは、最初のアドレスを優先し、PPC @code{bl}命令が呼び出し先に直接到達すると、@code{bl callee}を生成する。 それ以外の場合、リンカーは分岐島を呼び出すために@code {bl L42}を生成する。分岐島は呼び出し関数の本体に追加される。 呼び出し先の全32ビットアドレスを計算し、そのアドレスにジャンプする。

Mach-O（Darwin）システムでは、このオプションは直接呼び出しごとにコンパイラに前直接呼び出しのグルーを生成するように指示し、Darwinリンカーはそれを使用するか廃棄するかを決定する。

将来、GCCは、リンカーがグルーを生成することが知られている場合、すべてのロングコール仕様を無視するかもしれない。

@item -mtls-markers
@itemx -mno-tls-markers
@opindex mtls-markers
@opindex mno-tls-markers
@code{__tls_get_addr}への呼び出しには、関数の引数を指定して再配置を行う（行わない）。 再配置により、リンカーは関数呼び出しをTLS最適化の引数設定命令に確実に関連付けることができ、これによりGCCはシーケンスをよりよくスケジューリングできるようになる。

@item -mrecip
@itemx -mno-recip
@opindex mrecip
このオプションを使用すると、除算または平方根を実行する代わりに、追加のニュートンラフソンステップを逆数推定と逆平方根推定命令を使用して、精度を上げ浮動小数点引数を除算することができる。 @option{-mrecip}を使うときは、@option{-fastsafe-math-optimizations}、@option{-ffinite-math-only}、@option{-freciprocal-math}と@option{-fno-trapping-math}）を指定する。 シーケンスのスループットは一般に非相反命令のスループットよりも高いが、シーケンスの精度は、逆平方根に対して最大2ulp（すなわち、逆数1.0は0.99999994に等しい）減少させることがありうることに留意すること。

@item -mrecip=@var{opt}
@opindex mrecip=opt
このオプションは、どの逆算見積り命令を使用するかを制御する。 @var{opt}はコンマで区切られたオプションのリストである。オプションの前に@code{!}を付けてオプションを反転することができる：

@table @samp

@item all
すべての見積もり命令を有効にする。

@item default 
@option{-mrecip}と同じデフォルトの命令を有効にする。

@item none 
@option{-mno-recipe}と同等の、すべての見積もり命令を無効にする。

@item div 
単精度と倍精度の両方の逆数近似命令を有効にする。

@item divf 
単精度の逆数近似命令を有効にする。

@item divd 
倍精度の逆数近似命令を有効にする。

@item rsqrt
単精度と倍精度の両方で逆平方根近似命令を有効にする。 

@item rsqrtf 
単精度の逆数平方根近似命令を有効にする。

@item rsqrtd 
倍精度の逆数平方根近似命令を有効にする。

@end table

たとえば、@option{-mrecip=all,!rsqrtd}は倍精度逆数平方根の計算を扱う@code {FRSQRTE}、@code {XSRSQRTEDP}、@code {XVRSQRTEDP}の命令を除いてすべての逆数見積もり命令を有効にする。

@item -mrecip-precision
@itemx -mno-recip-precision
@opindex mrecip-precision
逆数見積もり命令がPowerPC ABIよりも高い精度の見積もりを提供すると仮定する（しない）。@option{-mcpu=power6}、@option{-mcpu=power7}または@option{-mcpu=power8}を選択すると、自動的に@option{-mrecip-precision}が選択される。2倍精度平方根推定命令は、3ステップ後に収束する推定値を提供しないため、低精度機械ではデフォルトで生成されない。

@item -mveclibabi=@var{type}
@opindex mveclibabi
外部ライブラリを使用して組み込み関数をベクトル化するために使用するABIタイプを指定する。 現在サポートされているタイプは@samp{mass}のみで、外部ライブラリを使用して組み込み関数をベクトル化するためにIBMのMASS（Mathematical Acceleration Subsystem）ライブラリを使用することを指定する。GCCは現在、power7のコードを生成するときに、@code{acosd2}, @code{acosf4}, @code{acoshd2}, @code{acoshf4}, @code{asind2}, @code{asinf4},
@code{asinhd2}, @code{asinhf4}, @code{atan2d2}, @code{atan2f4}, @code{atand2}, @code{atanf4}, @code{atanhd2}, @code{atanhf4}, @code{cbrtd2}, @code{cbrtf4}, @code{cosd2}, @code{cosf4}, @code{coshd2}, @code{coshf4}, @code{erfcd2}, @code{erfcf4}, @code{erfd2}, @code{erff4}, @code{exp2d2}, @code{exp2f4}, @code{expd2}, @code{expf4}, @code{expm1d2}, @code{expm1f4}, @code{hypotd2}, @code{hypotf4}, @code{lgammad2}, @code{lgammaf4}, @code{log10d2}, @code{log10f4}, @code{log1pd2}, @code{log1pf4}, @code{log2d2}, @code{log2f4}, @code{logd2}, @code{logf4}, @code{powd2}, @code{powf4}, @code{sind2}, @code{sinf4}, @code{sinhd2}, @code{sinhf4}, @code{sqrtd2}, @code{sqrtf4}, @code{tand2}, @code{tanf4}, @code{tanhd2}, and @code{tanhf4}への呼び出しを生成する。@option{-ftree-vectorize}と@option{-funsafe-math-optimizations}も有効にする必要がある。 MASSライブラリは、リンク時に指定する必要がある。

@item -mfriz
@itemx -mno-friz
@opindex mfriz
@option{-funsafe-math-optimizations}オプションを使用して浮動小数点値の64ビット整数への丸めを最適化し、浮動小数点に戻すときに、@code{friz}命令を生成する（しない）。 浮動小数点数が大きすぎて整数に収まらない場合、@code{friz}命令は同じ値を返さない。

@item -mpointers-to-nested-functions
@itemx -mno-pointers-to-nested-functions
@opindex mpointers-to-nested-functions
関数ポインタが、関数ポインタを与える3ワード・ディスクリプタ、レジスタ@code{r2}にロードされるTOC値、レジスタ@code{r11}にロードされる静的チェーン値を指すAIXと64ビットLinuxシステムでポインタを通して呼び出したとき、静的チェーンレジスタ（@code{r11}）をロードするコードを生成する（しない）。@option{-mpointers-to-nested-functions}はデフォルトでオンになっている。 @option{-mno-pointer-to-nested-functions}を使用すると、ネストした関数へのポインタや静的チェーンを使用する他の言語でコンパイルされた関数へのポインタを呼び出すことはできない。

@item -msave-toc-indirect
@itemx -mno-save-toc-indirect
@opindex msave-toc-indirect
関数がAIXおよび64ビットLinuxシステム上のポインターを呼び出す場合、関数プロローグの予約済みスタック位置にTOC値を保存するコードを生成する（しない）。 TOC値がプロローグに保存されていない場合は、ポインターを呼び出す直前に保存される。 @option{-mno-save-toc-indirect}オプションがデフォルトである。

@item -mcompat-align-parm
@itemx -mno-compat-align-parm
@opindex mcompat-align-parm
GCCの古いバージョンとの互換性のために、最大64ビットのアライメントで構造体パラメータを渡すコードを生成する（しない）。

古いバージョンのGCC（4.9.0より前）では、構造体が128ビット境界を必要とするメンバを含んでいた場合、構造体パラメータが128ビット境界上に正しく配置されなかった。 これはGCCの最近のバージョンで修正されている。 このオプションは、GCCの古いバージョンでコンパイルされた関数と互換性のあるコードを生成するために使用されていない。

@option {-mno-compat-align-parm}オプションがデフォルトである。

@item -mstack-protector-guard=@var{guard}
@itemx -mstack-protector-guard-reg=@var{reg}
@itemx -mstack-protector-guard-offset=@var{offset}
@itemx -mstack-protector-guard-symbol=@var{symbol}
@opindex mstack-protector-guard
@opindex mstack-protector-guard-reg
@opindex mstack-protector-guard-offset
@opindex mstack-protector-guard-symbol
@var{guard}にカナリアを使用してスタック保護コードを生成します。 サポートされている場所は、TLSブロック（GNU libcバージョン2.4以降のデフォルト）でグローバルカナリアンの場合は@samp{global}、スレッドごとカナリアンの場合は@samp{tls}である。

後者のオプションでは、@option{-mstack-protector-guard-reg=@var{reg}}オプションと@option{-mstack-protector-guard-offset=@var{offset}}オプションは、 カナリアを読み取るためのベースレジスタと、そのベースレジスタからのどのオフセットからのものかを示します。 これらのデフォルトは、関連するABIで指定されている。@option{-mstack-protector-guard-symbol=@var{symbol}}は、TLSブロックのカナリアへのシンボル参照でオフセットを上書きする。

@end table

@node RX Options
@subsection RXオプション
@cindex RX Options

これらのコマンドラインオプションは、RXターゲットに対して定義されている。

@table @gcctabopt
@item -m64bit-doubles
@itemx -m32bit-doubles
@opindex m64bit-doubles
@opindex m32bit-doubles
@code{double}データ型を64ビット（@option{-m64bit-doubles}）または32ビット（@option{-m32bit-doubles}）のサイズにする。 デフォルトは@option{-m32bit-doubles}である。 @emph{注意} RX浮動小数点ハードウェアは32ビット値でのみ動作する。そのため、デフォルトは@option{-m32bit-doubles}である。

@item -fpu
@itemx -nofpu
@opindex fpu
@opindex nofpu
RX浮動小数点ハードウェアの使用を有効（@option{-fpu}）または無効（@option{-nofpu}）にする。 デフォルトはRX600シリーズでは有効、RX200シリーズでは無効である。

ただし、浮動小数点命令は32ビット浮動小数点値に対してのみ生成されるため、@option{-m64bit-doubles}オプションが使用されている場合、FPUハードウェアは倍精度には使用されない。

@emph{注意} @option{-fpu}オプションを有効にすると、@option{-funsafe-math-optimizations}も自動的に有効になる。 これは、RX FPU命令自体が危険であるためである。

@item -mcpu=@var{name}
@opindex mcpu
ターゲットにするRX CPUのタイプを選択する。 現在、汎用@samp{RX600}と@samp{RX200}シリーズハードウェアと特定の@samp{RX610}CPUの3種類がサポートされている。 デフォルトは@samp{RX600}である。

@samp{RX600}と@samp {RX610}の唯一の違いは、@code{RX610}が@code{MVTIPL}命令をサポートしていないことである。

@samp{RX200}シリーズにはハードウェア浮動小数点ユニットがないため、このタイプが選択されている場合はデフォルトで@option{-nofpu}が有効になっている。

@item -mbig-endian-data
@itemx -mlittle-endian-data
@opindex mbig-endian-data
@opindex mlittle-endian-data
データをビッグエンディアン形式で格納する（コードはしない）。 デフォルトは@option{-mlittle-endian-data}である。すなわち、リトルエンディアン形式でデータを格納する。

@item -msmall-data-limit=@var{N}
@opindex msmall-data-limit
小さなデータ領域に配置できるグローバルおよび静的変数の最大サイズをバイト単位で指定する。 小さなデータ領域を使用すると、コードが小さくて高速になる可能性があるが、領域のサイズは限られていて、領域がオーバーフローしないかどうかはプログラマにまかされている。 小さなデータ領域が使用されている場合には、RXのレジスタの1つ（通常は@code{r13}）はこの領域を指すために予約されているため、コンパイラでは使用できなくなる。 この結果、変数がこのレジスタに保持されるのではなくスタックにプッシュされると、コードの速度が遅くなりコードが大きくなることもある。

一般的な変数（初期化されていない変数）と定数は、実行可能な出力の他のセクションに割り当てられているため、小さなデータ領域には配置されない。

デフォルト値は0で、この機能は無効になっている。 この機能は、レジスタを予約すると悪影響を受ける可能性があるため、デフォルトでは高度な最適化レベル（@option {-O2}など）では有効になっていない。 この機能がプログラムに有益であるかどうかを実験して発見することはプログラマの責任である。 小さなデータ領域ポインタを保持する実際のレジスタの選択方法については、@option{-mpid}オプションの説明を参照せよ。

@item -msim
@itemx -mno-sim
@opindex msim
@opindex mno-sim
シミュレータランタイムを使用する。 デフォルトでは、libglossボード固有のランタイムを使用する。

@item -mas100-syntax
@itemx -mno-as100-syntax
@opindex mas100-syntax
@opindex mno-as100-syntax
アセンブラ出力を生成する場合に、ルネサスのAS100アセンブラと互換性のある構文を使用する。 この構文はGASアセンブラでも処理できるが、いくつかの制限があり、デフォルトでは生成されない。

@item -mmax-constant-size=@var{N}
@opindex mmax-constant-size
RX命令のオペランドとして使用できる定数の最大サイズをバイト単位で指定する。RX命令セットは、長さが最大4バイトの定数を命令で使用することを可能にするが、より長い値はより長い命令に等しい。したがって、状況によっては、命令で使用される定数のサイズを制限することが有益である。大きすぎる定数は、代わりに定数プールに配置され、レジスタの間接参照によって参照される。

値@var{N}は0と4の間で指定できる。値0（デフォルト）または4は、任意のサイズの定数が許可されることを意味する。

@item -mrelax
@opindex mrelax
リンカーの緩和を有効にする。 リンカー緩和は、リンカーがさまざまな命令の短いバージョンを見つけることによってプログラムのサイズを縮小しようとするプロセスである。 デフォルトでは無効である。

@item -mint-register=@var{N}
@opindex mint-register
高速割り込みハンドラ機能用に予約するレジスタの数を指定する。値@var{N}は0と4の間にある。1という値は、レジスタ@code{r13}が高速割り込みハンドラ専用に予約されていることを意味する。 2の値は@code{r13}と@code{r12}を予約する。3の値は@code{r13}、@code{r12}と@code{r11}を予約し、4の値は@code{r13}から@code{r10}を予約する。デフォルトの値0は、レジスタを予約しない。

@item -msave-acc-in-interrupts
@opindex msave-acc-in-interrupts
割り込みハンドラ関数がアキュムレータレジスタを保持する必要があることを指定する。 これは、たとえば64ビット乗算を実行するなど、通常のコードでアキュムレータレジスタを使用する場合にのみ必要である。 デフォルトでは、アキュムレータは無視されるため、割り込みハンドラが高速になる。

@item -mpid
@itemx -mno-pid
@opindex mpid
@opindex mno-pid
位置に依存しないデータの生成を有効にする。 有効にされると、定数データへのアクセスは、レジスタに保持されたベースアドレスからのオフセットを介して行わる。 これにより、実行可能ファイルの再配置を必要とせずに、実行時に定数データの位置を決定することができる。これは、厳しいメモリ制約を伴う組み込みアプリケーションのメリットである。 このオプションによって、変更可能なデータは影響を受けない。

この機能を使用すると、定数データベースのアドレスには、通常@code{r13}のレジスタが予約される。 これにより、特に複雑な機能では、コードの速度が遅くなることがある。

定数データベースアドレスを保持するために選択された実際のレジスタは、@option{-msmall-data-limit}および/または@option{-mint-register}コマンドラインオプションが有効かどうかによって異なる。レジスタ@code{r13}から始め下方に進み、レジスタは最初に@option{-mint-register}、次に@option {-mpid}、最後に@option{-msmall-data-limit}の要件を満たすように割り当てられる。したがって、@option{-mint-register=4}と@option{-mpid}の両方がコマンドラインで指定されている場合、小さなデータエリアレジスタは@code{r8}になる可能性がある。

デフォルトでは、この機能は有効になっていない。 デフォルトは、@option{-mno-pid}コマンドラインオプションで復元できる。

@item -mno-warn-multiple-fast-interrupts
@itemx -mwarn-multiple-fast-interrupts
@opindex mno-warn-multiple-fast-interrupts
@opindex mwarn-multiple-fast-interrupts
ファイルをコンパイル中に複数の高速割り込みハンドラが見つかった場合、GCCが警告メッセージを出さないようにする。 RXは、このような割り込みの1つのみをサポートするため、デフォルトでは、見つかった追加の高速割り込みハンドラごとに警告を発行する。

@item -mallow-string-insns
@itemx -mno-allow-string-insns
@opindex mallow-string-insns
@opindex mno-allow-string-insns
文字列操作命令@code{SMOVF}、@code{SCMPU}、@code{SMOVB}、@code{SMOVU}、@code{SUNTIL}、@code{SWHILE}、@code{SWILE}、@code{RMPA}命令の使用を有効または無効にする 。 これらの命令はデータをプリフェッチする可能性があり、I / Oレジスタにアクセスする場合は安全ではなお。 （詳細についてはRX62Nグループユーザーズマニュアルの12.2.7節参照）。

デフォルトではこれらの命令が許可されているが、I / Oレジスタにアクセスするために文字列命令が使用される可能性のあるすべての状況をGCCが確実に検出することはできないため、その使用を自動的に無効にすることはできない。 代わりに、プログラムがI/O空間にアクセスする場合、@option{-mno-allow-string-insns}オプションを使用することはプログラマに依存している。

命令が有効になると、GCCはCプリプロセッサシンボル@code{__RX_ALLOW_STRING_INSNS__}を定義する。それ以外の場合はシンボル@code {__RX_DISALLOW_STRING_INSNS__}を定義する。

@item -mjsr
@itemx -mno-jsr
@opindex mjsr
@opindex mno-jsr
関数にアクセスするには@code{JSR}命令だけ（ではなく）使用する。このオプションは、コードサイズが@code{BSR}命令の範囲を超える場合に使用できる。 @option{-mno-jsr}は@code {JSR}を使用しないことを意味するのではなく、任意の種類のブランチを使用できることを意味する。
@end table

@emph{注意：}一般的なGCCのコマンドラインオプション@option{-ffixed-@var{reg}}は、@code{interrupt}関数属性とともに使用するとき、RXポートに対して特別な意味を持つ。 この属性は、高速割り込みを処理する機能を示す。 GCCは、レジスタ@code{r10}、@code{r11}、@code{r12}および/または@code{r13}のみを使用し、対応するレジスタの通常の使用が@option{-ffixed-@var{reg}}または@option {-mint-register}コマンドラインオプションを使用する。

@node S/390 and zSeries Options
@subsection S/390とzSeriesのオプション
@cindex S/390 and zSeries Options

これらは、S / 390およびzSeriesアーキテクチャー用に定義された@samp {-m}オプションである。

@table @gcctabopt
@item -mhard-float
@itemx -msoft-float
@opindex mhard-float
@opindex msoft-float
ハードウェア浮動小数点命令と浮動小数点演算用のレジスタを使用する（しない）。 @option{-msoft-float}を指定すると、@file{libgcc.a}の関数が浮動小数点演算の実行に使用される。 @option{-mhard-float}を指定すると、コンパイラはIEEE浮動小数点命令を生成する。 これがデフォルトである。

@item -mhard-dfp
@itemx -mno-hard-dfp
@opindex mhard-dfp
@opindex mno-hard-dfp
10進浮動小数点演算にはハードウェア10進浮動小数点命令を使用する（しない）。 @option{-mno-hard-dfp}を指定すると、@file{libgcc.a}の関数を使用して10進浮動小数点演算が実行される。 @option{-mhard-dfp}を指定すると、コンパイラは10進浮動小数点ハードウェア命令を生成する。 これは、@option{-march=z9-ec}以上のデフォルトである。

@item -mlong-double-64
@itemx -mlong-double-128
@opindex mlong-double-64
@opindex mlong-double-128
これらのスイッチは、@code{long double}型のサイズを制御する。 64ビットのサイズは、@code{long double}型を@code{double}型と等価にする。 これがデフォルトである。

@item -mbackchain
@itemx -mno-backchain
@opindex mbackchain
@opindex mno-backchain
呼び出し元のフレームのアドレスをバックチェーンポインタとして呼び出し先のスタックフレームに格納する（しない）。DWARFコールフレーム情報を理解していないツールを使用してデバッグを可能にするには、バックチェーンが必要な場合がある。@option{-mno-packed-stack}が有効な場合、バックチェーンポインタはスタックフレームの一番下に格納される。 @option{-mpacked-stack}が有効な場合、バックチェーンは96/160バイトレジスタ保存領域の最上位ワードに配置される。

一般に、@option{-mbackchain}でコンパイルされたコードは、@option{-mmo-backchain}でコンパイルされたコードと呼び出し互換である。 しかし、デバッグの目的でバックチェーンを使用するには、通常、バイナリ全体が@option{-mbackchain}で構築されている必要がある。@option{-mbackchain}、@option{-mpacked-stack}と@option{-mhard-float}の組み合わせはサポートされていないことに注意せよ。 Linuxカーネルを構築するには、@option{-msoft-float}を使用する。

デフォルトはバックチェーンを維持しない。

@item -mpacked-stack
@itemx -mno-packed-stack
@opindex mpacked-stack
@opindex mno-packed-stack
パックされたスタックレイアウトを使用する（しない）。 @option{-mno-packed-stack}を指定すると、コンパイラは96/160バイトレジスタ保存領域のすべてのフィールドをデフォルトの目的でのみ使用する。未使用のフィールドはそれでもスタック領域を占有する。@option{-mpacked-stack}を指定すると、レジスタ退避領域はレジスタ退避領域の先頭に密集して配置される。未使用スペースは他の目的で再利用され、使用可能なスタックスペースをより効率的に使用することができる。ただし、@option{-mbackchain}も有効な場合、保存領域の最上位ワードは常にバックチェーンを格納するために使用され、戻りアドレスレジスタは常にバックチェーンの2ワード下に保存される。

スタックフレームバックチェーンが使用されていない限り、@option{-mpacked-stack}で生成されたコードは、@option{-mno-packed-stack}で生成されたコードと呼び出し互換である。 FSF以外のリリースのGCC 2.95（S/390またはzSeries用）では、デバッグの目的だけでなく、実行時にスタックフレームバックチェーンを使用するコードが生成されたことに注意せよ。 このようなコードは、@option{-mpacked-stack}でコンパイルされたコードとの呼び出し互換性はない。また、@option{-mbackchain}、@option{-mpacked-stack}と@option {-mhard-float}の組み合わせはサポートされていない。Linuxカーネルを構築するには、@option{-msoft-float}を使用する。

デフォルトでは、パックドスタックレイアウトは使用されない。

@item -msmall-exec
@itemx -mno-small-exec
@opindex msmall-exec
@opindex mno-small-exec
サブルーチン呼び出しを行うために@code{bras}命令を使ってコードを生成する（しない）。これは、実行可能な合計サイズが64kを超えない場合にのみ、確実に機能する。 デフォルトでは、@code{basr}命令を代わりに使用し、それにはこの制限はない。

@item -m64
@itemx -m31
@opindex m64
@opindex m31
@option{-m31}を指定すると、S/390 ABI向けGNU/Linuxに準拠したコードを生成する。@option{-m64}を指定すると、zSeries ABI向けGNU/Linuxに準拠したコードが生成される。 これにより、特にGCCは64ビット命令を生成することができる。@samp{s390}ターゲットの場合、デフォルトは@option{-m31}だが、@samp{s390x}ターゲットはデフォルトで@option{-m64}になる。

@item -mzarch
@itemx -mesa
@opindex mzarch
@opindex mesa
@option{-mzarch}を指定すると、z/Architectureで使用可能な命令を使用してコードを生成する。@option{-mesa}を指定した場合は、ESA/390で使用可能な命令を使用してコードを生成する。 @option{-mesa}は@option{-m64}では使用できない。S/390 ABI向けGNU/Linuxに準拠したコードを生成する場合、デフォルトは@option{-mesa}である。zSeries ABI向けGNU/Linuxに準拠したコードを生成する場合、デフォルトは@option{-mzarch}である。

@item -mhtm
@itemx -mno-htm
@opindex mhtm
@opindex mno-htm
@option{-mhtm}オプションは、IBM zEnterprise EC12マシン世代で導入されたトランザクショナル実行機能で使用可能な命令を使用した組み込み関数のセットを使用可能にする。@ref{S/390 System z Built-in Functions}。@option{-mhtm}は、@option{-march=zEC12}を使用している場合、デフォルトで有効になっている。

@item -mvx
@itemx -mno-vx
@opindex mvx
@opindex mno-vx
@option {-mvx}を指定すると、IBM z13マシン生成で導入されたベクトル拡張機能で使用可能な命令を使用してコードを生成する。このオプションは、整列と呼び出し規約に関して、いくつかのベクトル型の値をABIに変更する。 ベクトル型の値がABI関連の文脈で使用されている場合は、GAS @samp{.gnu_attribute}コマンドを使用して、使用されたABIで結果のバイナリをマークする。@option{-mvx}は、@option{-march = z13}を使用すると、デフォルトで有効になる。

@item -mzvector
@itemx -mno-zvector
@opindex mzvector
@opindex mno-zvector
@option{-mzvector}オプションを使用すると、IBM z13マシン生成で導入されたベクトル拡張機能で使用可能な命令を使用して、ベクトル言語拡張および組み込み関数を使用できる。このオプションは、@samp{vector}のサポートを追加し、ベクトル型の変数と引数を定義するキーワードとして使用する。 @samp{vector}は、GNU拡張機能が有効な場合にのみ使用できる。たとえば、@option{-std = c99}を指定するような、標準のコンプライアンスを厳格に要求する場合には展開されない。GCCの低レベルの組み込み関数@option{-mzvector}は、PowerやCellなどのAltiVecスタイルの実装との互換性のために追加された組み込み関数を有効にする。 これらの組み込み関数を使用するには、ヘッダファイル@file{vecintrin.h}をインクルードする必要がある。@option{-mzvector}はデフォルトでは無効になっている。

@item -mmvcle
@itemx -mno-mvcle
@opindex mmvcle
@opindex mno-mvcle
ブロック移動を実行するための@code{mvcle}命令を使用してコードを生成する（しない）。 @option{-mno-mvcle}を指定すると、代わりに@code{mvc}ループを使用する。 サイズを最適化しない限り、これがデフォルトである。

@item -mdebug
@itemx -mno-debug
@opindex mdebug
@opindex mno-debug
コンパイル時に追加のデバッグ情報を出力する（またはしない）。デフォルトでは、デバッグ情報は表示されない。

@item -march=@var{cpu-type}
@opindex march
@var{cpu-type}で実行されるコードを生成する。これは、特定のプロセッサタイプを表すシステムの名前である。 @var{cpu-type}に可能な値は、@samp{z900}/@samp{arch5}, @samp{z990}/@samp{arch6}, @samp{z9-109}, @samp{z9-ec}/@samp{arch7}, @samp{z10}/@samp{arch8}, @samp{z196}/@samp{arch9}, @samp{zEC12}, @samp{z13}/@samp{arch11}, @samp{native}である。

デフォルトは@option{-march=z900}である。 @samp{g5}/@samp{arch3}と@samp{g6}は非推奨であり、将来のリリースで削除される予定である。

@samp{native}をcpuタイプとして指定すると、ホストプロセッサに最適なアーキテクチャオプションを選択できる。gccがプロセッサを認識しない場合、@option{-march=native}は効果がない。

@item -mtune=@var{cpu-type}
@opindex mtune
@var{cpu-type}に対して、ABIと使用可能な命令のセットを除いて、生成されたコードに関するすべてを調整する。@var{cpu-type}の値のリストは、@option{-march}の値と同じである。デフォルトは、@option{-march}に使用される値である。

@item -mtpf-trace
@itemx -mno-tpf-trace
@opindex mtpf-trace
@opindex mno-tpf-trace
TPF OS固有のブランチをオペレーティング・システムのトレース・ルーチンに追加する（しない）コードを生成する。 このオプションは、TPF OS用にコンパイルしていても、デフォルトではオフになっている。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点乗算および累算命令を使用する（しない）コードを生成する。 ハードウェア浮動小数点が使用されている場合、これらの命令はデフォルトで生成される。

@item -mwarn-framesize=@var{framesize}
@opindex mwarn-framesize
現在の関数が指定されたフレームサイズを超えた場合に警告を出す。これはコンパイル時のチェックであるため、プログラムを実行するときに実際の問題である必要はない。おそらくスタックオーバーフローを引き起こす可能性のある関数を識別するためのものである。スタックサイズが制限された環境、例えばLinuxカーネルで使用すると便利である。

@item -mwarn-dynamicstack
@opindex mwarn-dynamicstack
関数が@code{alloca}を呼び出すか、動的にサイズの配列を使用する場合は警告を出る。これは一般的に、制限されたスタックサイズでは悪い考えである。

@item -mstack-guard=@var{stack-guard}
@itemx -mstack-size=@var{stack-size}
@opindex mstack-guard
@opindex mstack-size
973/5000
これらのオプションが提供されている場合、S/390バックエンドは、スタック・サイズが@var{stack-size}よりも@var{stack-guard}バイト大きい場合、トラップを起動する追加の命令を関数プロローグに出す。（S / 390ではスタックが下向きに成長することを思い出すこと）。@var{stack-guard}オプションを省略すると、コンパイルされた関数のフレームサイズよりも大きな2の最小の累乗が選択される。これらのオプションは、スタックオーバーフローの問題のデバッグに役立つ。追加的に放出されるコードは、わずかなオーバーヘッドしか生じさせず、従って、より性能低下のない生産様のシステムにおいても使用されることも可能である。。与えられた値は正確な2のべき乗でなければならず、@var{stack-size}は64kを超えてはならず、@var{stack-guard}より大きくなければならない。効率を上げるために、余分なコードは、スタックが@var{stack-size}によって与えられた値に揃えられたアドレスで開始するという前提を作る。

@item -mhotpatch=@var{pre-halfwords},@var{post-halfwords}
@opindex mhotpatch
ホットパッチオプションを有効にすると、コンパイルユニット内のすべての関数に対して "ホットパッチ"機能のプロローグが生成される。funtionラベルには、指定された2バイトのNOP命令（@var{pre-halfwords}、最大1000000）が付加される。ラベルの後には、アーキテクチャーが許す最大のNOP命令（最大1000000）を使用して、2 * @var{post-halfwords}バイトが追加される。

両方の引数がゼロの場合、ホットパッチは無効になる。

このオプションは、@code{hotpatch}属性を持つ個々の関数に対してオーバーライドできる。
@end table

@node Score Options
@subsection Scoreオプション
@cindex Score Options

これらのオプションは、Score実装で定義されている。

@table @gcctabopt
@item -meb
@opindex meb
ビッグエンディアンモード用にコードをコンパイルする。これがデフォルトである。

@item -mel
@opindex mel
リトルエンディアンモード用にコードをコンパイルする。

@item -mnhwloop
@opindex mnhwloop
@code{bcnz}命令の生成を無効化する。

@item -muls
@opindex muls
アラインされていないロードおよびストア命令の生成を有効にする。

@item -mmac
@opindex mmac
乗加算命令の使用を有効にする。 デフォルトでは無効である。

@item -mscore5
@opindex mscore5
ターゲットアーキテクチャとしてSCORE5を指定する。

@item -mscore5u
@opindex mscore5u
ターゲットアーキテクチャとしてSCORE5Uを指定する。

@item -mscore7
@opindex mscore7
ターゲットアーキテクチャとしてSCORE7を指定する。これはデフォルトである。

@item -mscore7d
@opindex mscore7d
ターゲットアーキテクチャとしてSCORE7Dを指定する。
@end table

@node SH Options
@subsection SHオプション

これらの@samp {-m}オプションはSH実装で定義されている。

@table @gcctabopt
@item -m1
@opindex m1
SH1用のコードを生成する。

@item -m2
@opindex m2
SH2用のコードを生成する。

@item -m2e
SH2e用のコードを生成する。

@item -m2a-nofpu
@opindex m2a-nofpu
FPUを使用しないSH2a、または浮動小数点ユニットが使用されないSH2a-FPU用のコードを生成する。

@item -m2a-single-only
@opindex m2a-single-only
倍精度浮動小数点演算が使用されないSH2a-FPU用のコードを生成する。

@item -m2a-single
@opindex m2a-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH2a-FPU用のコードを生成する。

@item -m2a
@opindex m2a
浮動小数点ユニットがデフォルトで倍精度モードであると仮定して、SH2a-FPU用のコードを生成する。

@item -m3
@opindex m3
SH3用のコードを生成する。

@item -m3e
@opindex m3e
SH3e用のコードを生成する。

@item -m4-nofpu
@opindex m4-nofpu
浮動小数点ユニットなしのSH4用のコードを生成する。

@item -m4-single-only
@opindex m4-single-only
単精度演算のみをサポートする浮動小数点ユニットを使用したSH4用のコードを生成する。

@item -m4-single
@opindex m4-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4用のコードを生成する。

@item -m4
@opindex m4
SH4用のコードを生成する。

@item -m4-100
@opindex m4-100
SH4-100用のコードを生成する。

@item -m4-100-nofpu
@opindex m4-100-nofpu
浮動小数点ユニットを使用しないでSH4-100用のコードを生成する。

@item -m4-100-single
@opindex m4-100-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4-100用のコードを生成する。

@item -m4-100-single-only
@opindex m4-100-single-only
倍精度浮動小数点演算を使用しないでSH4-100用のコードを生成する。

@item -m4-200
@opindex m4-200
SH4-200用のコードを生成する。

@item -m4-200-nofpu
@opindex m4-200-nofpu
浮動小数点ユニットを使用しないでSH4-200のコードを生成する。

@item -m4-200-single
@opindex m4-200-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4-200のコードを生成する。

@item -m4-200-single-only
@opindex m4-200-single-only
倍精度浮動小数点演算を使用しないでSH4-200のコードを生成する。

@item -m4-300
@opindex m4-300
SH4-300用のコードを生成する。

@item -m4-300-nofpu
@opindex m4-300-nofpu
浮動小数点ユニットを使用しないでSH4-300のコードを生成する。

@item -m4-300-single
@opindex m4-300-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4-300のコードを生成する。

@item -m4-300-single-only
@opindex m4-300-single-only
倍精度浮動小数点演算を使用しないでSH4-300のコードを生成する。

@item -m4-340
@opindex m4-340
SH4-340用のコードを生成する（MMUなし、FPUなし）。

@item -m4-500
@opindex m4-500
SH4-500（FPUなし）用のコードを生成します。 @option{-isa=sh4-nofpu}をアセンブラに渡す。

@item -m4a-nofpu
@opindex m4a-nofpu
浮動小数点ユニットを使用しないでSH4al-dspまたはSH4a用のコードを生成する。

@item -m4a-single-only
@opindex m4a-single-only
倍精度浮動小数点演算を使用しないでSH4a用のコードを生成します。

@item -m4a-single
@opindex m4a-single
浮動小数点ユニットがデフォルトで単精度モードであると仮定して、SH4a用のコードを生成する。

@item -m4a
@opindex m4a
SH4a用のコードを生成する。

@item -m4al
@opindex m4al
@option{-m4a-nofpu}と同じだが、暗黙的に@option{-dsp}がアセンブラに渡さる。 GCCは現時点ではDSP命令を生成しない。

@item -mb
@opindex mb
ビッグエンディアンモードでプロセッサのコードをコンパイルする。

@item -ml
@opindex ml
リトルエンディアンモードでプロセッサのコードをコンパイルする。

@item -mdalign
@opindex mdalign
64ビット境界で倍精度を整列させる。 これは呼び出し規約を変更するので、標準Cライブラリの一部の関数は、@option{-mdalign}で最初に再コンパイルしないと機能しない。

@item -mrelax
@opindex mrelax
可能であれば、リンク時にいくつかのアドレス参照を短くする。 リンカオプション@option{-relax}を使用する。

@item -mbigtable
@opindex mbigtable
@code{switch}テーブルでは32ビットのオフセットを使用する。 デフォルトでは、16ビットのオフセットが使用される。

@item -mbitops
@opindex mbitops
SH2Aでビット操作命令を使用できるようにする。

@item -mfmovd
@opindex mfmovd
命令@code{fmovd}の使用を有効にする。 整列の制約については、@option{-mdalign}を確認せよ。

@item -mrenesas
@opindex mrenesas
ルネサスが定めた呼び出し規約に従う。

@item -mno-renesas
@opindex mno-renesas
ルネサスの規約が利用可能になる前に、GCC用に定義された呼び出し規約に従う。 このオプションは、SHツールチェーンのすべてのターゲットのデフォルトである。

@item -mnomacsave
@opindex mnomacsave
@option{-mrenesas}が指定されていても、@code{MAC}レジスタに呼び出しで破壊されるとマークする。

@item -mieee
@itemx -mno-ieee
@opindex mieee
@opindex mno-ieee
浮動小数点比較のIEEE準拠を制御する。比較の結果が順序付けられていない場合の処理に影響する。デフォルトでは、@option{-mieee}は暗黙的に有効になっている。@option{-ffinite-math-only}を有効にすると、@option{-mno-ieee}が暗黙的に設定される。その結果、より高速の浮動小数点のより大きな等価比較とより小さい等しい比較が行われる。 暗黙の設定は、@option{-mieee}または@option{-mno-ieee}のいずれかを指定することによって上書きできる。

@item -minline-ic_invalidate
@opindex minline-ic_invalidate
ネストされた関数トランポリンを設定した後に命令キャッシュエントリを無効にするコードをインライン化する。@option{-musermode}が有効で、選択されたコード生成オプション（@option{-m4}など）で@code{icbi}命令を使用できない場合、このオプションは無効である。選択されたコード生成オプションが@code{icbi}命令の使用を許可せず、@option{-musermode}が有効でない場合、インラインコードは命令キャッシュアドレス配列を連想書き込みで直接操作する。これは、実行時に特権モードを必要とするだけでなく、キャッシュラインが元々TLBを介してマップされていて、マップされなくなった場合にも失敗する。

@item -misize
@opindex misize
アセンブリコードの命令サイズと位置をダンプする。

@item -mpadstruct
@opindex mpadstruct
このオプションは非推奨である。 SH ABIと互換性のない4バイトの倍数に構造体を埋め込む。

@item -matomic-model=@var{model}
@opindex matomic-model=@var{model}
アトミック操作のモデルと追加パラメータをコンマ区切りのリストとして設定する。アトミック組み込み関数の詳細については、@ref {__atomic Builtins}を参照せよ。  次のモデルとパラメータがサポートされている。

@table @samp

@item none
コンパイラが生成したアトミック操作を無効にし、アトミック操作のライブラリ呼び出しを発行する。 ターゲットが@code {sh*-*-linux*}でない場合、これがデフォルトである。

@item soft-gusa
アトミック組み込み関数用のGNU/Linux互換gUSAソフトウェアのアトミック列を生成する。生成されたアトミック列は、システムの割り込み/例外処理コードからの追加サポートを必要とし、SH3*およびSH4*シングルコアシステムにのみ適している。このオプションは、ターゲットが@code{sh*-*-linux*}とSH3*またはSH4*の場合、デフォルトで有効になる。ターゲットがSH4Aの場合、このオプションは@samp{strict}が指定されていない限り、ハードコードの原子命令@code{movli.l}と@code{movco.l}を部分的に利用してより効率的なコードを作成する。

@item soft-tcb
スレッド制御ブロック内の変数を使用するソフトウェアのアトミック列を生成する。これは、SH1*およびSH2*ターゲットでも使用できるgUSAシーケンスのバリエーションである。生成されたアトミック列は、システムの割り込み/例外処理コードからの追加サポートを必要とし、シングルコアシステムにのみ適している。このモデルを使用する場合、@samp{gbr-offset=}パラメータも指定する必要がある。

@item soft-imask
@code{SR.IMASK=1111}を設定して、一時的に割り込みを無効にするソフトウェアのアトミック列を生成する。このモデルは、プログラムが特権モードで動作し、シングルコアシステムにのみ適している場合にのみ機能する。システムの割り込み/例外処理コードからの追加のサポートは必要ない。 このモデルは、ターゲットが@code{sh*-*-linux*}とSH1*またはSH2*の場合、デフォルトで有効になる。

@item hard-llcs
@code{movli.l}命令と@code{movco.l}命令のみを使用して、ハードウェアアトミック列を生成する。これはSH4Aでのみ利用可能で、マルチコアシステムに適している。ハードウェア命令は32ビットのアトミック変数のみをサポートするため、8または16ビット変数へのアクセスは32ビットアクセスでエミュレートされる。このオプションでコンパイルされたコードは、SH4Aシステム上で実行される場合、他のソフトウェアアトミックモデル割り込み/例外処理システムとも互換性がある。このモデルでは、システムの割り込み/例外処理コードの追加サポートは必要ない。

@item gbr-offset=
このパラメータは、@samp{soft-tcb}モデルが選択されているときに、生成されたアトミック列によって使用されるスレッド制御ブロック構造内の変数のオフセットをバイト単位で指定する。他のモデルの場合、このパラメータは無視される。 指定する値は、4の整数倍で、0〜1020の範囲で指定する必要がある。

@item strict
このパラメータは、互換性があっても複数のアトミックモデルを混在して使用することを防ぎ、指定されたモデルのアトミック列のみをコンパイラに生成させる。

@end table

@item -mtas
@opindex mtas
@code{__ atomic_test_and_set}の@code {tas.b}オペコードを生成する。特定のハードウェアとソフトウェアの設定によっては、@code{tas.b}命令によって暗示されるオペランドキャッシュラインフラッシュによって全体的なパフォーマンスが低下する可能性があることに注意せよ。マルチコアSH4Aプロセッサでは、特定のキャッシュ構成でデータが破損する可能性があるため、@code{tas.b}命令は慎重に使用する必要がある。

@item -mprefergot
@opindex mprefergot
位置に依存しないコードを生成する場合は、プロシージャのリンケージテーブルの代わりにグローバルオフセットテーブルを使用して関数呼び出しを発行する。

@item -musermode
@itemx -mno-usermode
@opindex musermode
@opindex mno-usermode
特権モードコードを生成するコンパイラを許可するい（しない）。 @option{-musermode}を指定すると、インラインコードがユーザモードで動作しない場合は、@option{-mno-inline-ic_invalidate}も意味する。 targetが@code{sh*-*-linux*}の場合、@option{-musermode}がデフォルトである。ターゲットがSH1*またはSH2*の場合、@option{-musermode}は効果がない。なぜなら、ユーザーモードがないからである。

@item -multcost=@var{number}
@opindex multcost=@var{number}
乗算命令の想定コストを設定します。

@item -mdiv=@var{strategy}
@opindex mdiv=@var{strategy}
整数除算操作に使用する除算ストラテジーを設定する。 @var{strategy}は次のいずれかである

@table @samp

@item call-div1
単一ステップ除算命令@code{div1}を使用して操作を実行するライブラリ関数を呼び出す。 ゼロ除算は、不特定の結果を計算し、トラップしまない。 これは、SH4、SH2A、およびSHcompactを除くデフォルトである。

@item call-fp
倍精度浮動小数点で演算を実行するライブラリ関数を呼び出す。 ゼロ除算は浮動小数点例外を発生させる。 これはFPUを使用するSHcompactのデフォルトである。 倍精度FPUを持たないターゲットに対してこれを指定すると、デフォルトで@code{call-div1}になる。

@item call-table
小さな除数のルックアップテーブルと@code{div1}命令を使用するライブラリ関数を呼び出し、大きな除数の場合を分岐する。ゼロ除算は、不特定の結果を計算し、トラップしない。これはSH4のデフォルトである。 動的シフト命令を持たないターゲットに対してこれを指定すると、デフォルトでは@code{call-div1}になる。

@end table

分割戦略が指定されていない場合、現在のターゲットに基づいてデフォルト戦略が選択される。 SH2Aの場合、デフォルトの戦略は、ライブラリ関数呼び出しの代わりに@code{divs}命令と@code{divu}命令を使用することである。

@item -maccumulate-outgoing-args
@opindex maccumulate-outgoing-args
各呼び出しの周りではなく、関数のプロローグで発信する引数用に一度スペースを予約する。 パフォーマンスとサイズには一般的に有益である。 また、条件コードの周りのスタックフレームを変更しないようにするための巻き戻しのためにも必要である。

@item -mdivsi3_libfunc=@var{name}
@opindex mdivsi3_libfunc=@var{name}
32ビット符号付き除算に使用するライブラリ関数の名前を@var{name}に設定する。
これは、@samp{call}除算戦略で使用される名前にのみ影響し、このオプションが存在しない場合と同じように、コンパイラは入力/出力/破壊されるレジスタの同じセットを引き続き予測する。

@item -mfixed-range=@var{register-range}
@opindex mfixed-range
与えられたレジスタ範囲を固定レジスタとして扱うコードを生成する。固定レジスタは、レジスタアロケータが使用できないレジスタである。 カーネルコードをコンパイルするときに便利である。レジスタ範囲は、ダッシュで区切られた2つのレジスタとして指定される。カンマで区切って複数のレジスタ範囲を指定することができる。

@item -mbranch-cost=@var{num}
@opindex mbranch-cost=@var{num}
@var{num}を分岐命令のコストと仮定する。可能であれば、より多くのブランチなしのコードを生成しようとする。
指定されていない場合は、コンパイル対象のプロセッサタイプに応じて値が選択される。

@item -mzdcbranch
@itemx -mno-zdcbranch
@opindex mzdcbranch
@opindex mno-zdcbranch
ゼロ置換条件分岐命令@code{bt}と@code{bf}が高速であると仮定する（しない）。@option {-mzdcbranch}を指定すると、コンパイラはゼロ変位分岐コードシーケンスを優先する。これは、SH4とSH4Aのコードを生成するときにデフォルトで有効になる。@option{-mno-zdcbranch}を指定することによって明示的に無効にすることができる。

@item -mcbranch-force-delay-slot
@opindex mcbranch-force-delay-slot
条件付きブランチのための遅延スロットの使用を強制する。これは、適切な命令が見つからない場合、遅延スロットに@code{nop}を詰め込む。デフォルトでは、このオプションは無効になっている。 オリジナルSH7055のハードウェアバグを回避することができる。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点乗加算命令を使用する（しない）コードを生成する。ハードウェア浮動小数点が使用されている場合、これらの命令はデフォルトで生成される。マシンに依存する@option{-mfused-madd}オプションは、マシンに依存しない@option{-ffp-contract=fast}オプションにマップされ、@option{-mno-fused-madd}は@option{-ffp-contract=off}を指定する。

@item -mfsca
@itemx -mno-fsca
@opindex mfsca
@opindex mno-fsca
コンパイラが正弦および余弦の近似のために@code{fsca}命令を出すのを許可する、または許可しない。オプション@option {-mfsca}は、@option{-funsafe-math-optimizations}と組み合わせて使用する必要がある。SH4A用のコードを生成するときは、デフォルトで有効になっている。@option{-mno-fsca}を使用すると、@option{-funsafe-math-optimizations}が有効な場合でも正弦と余弦の近似は無効になる。

@item -mfsrra
@itemx -mno-fsrra
@opindex mfsrra
@opindex mno-fsrra
コンパイラが逆平方根近似のために@code{fsrra}命令を出すのを許可する、または許可しない。
オプション@option{-mfsrra}は、@option{-funsafe-math-optimizations}および@option{-ffinite-math-only}と組み合わせて使用する必要がある。SH4A用のコードを生成するときは、デフォルトで有効になっている。@option{-mno-fsrra}を使用すると、@option{-funsafe-math-optimizations}と@option{-ffinite-math-only}が有効な場合でも、逆数平方根近似が無効になる。

@item -mpretend-cmove
@opindex mpretend-cmove
条件付き移動命令パターンのゼロ変位条件分岐を優先する。 これにより、SH4プロセッサでより高速なコードが生成される可能性がある。

@item -mfdpic
@opindex fdpic
FDPIC ABIを使用してコードを生成する。

@end table

@node Solaris 2 Options
@subsection Solaris 2オプション
@cindex Solaris 2 options

これらの@samp {-m}オプションは、Solaris 2でサポートされている。

@table @gcctabopt
@item -mclear-hwcap
@opindex mclear-hwcap
@option{-mclear-hwcap}は、Solarisアセンブラによって生成されたハードウェア機能を削除するようコンパイラに指示する。  これは、オブジェクトファイルが現在のマシンでサポートされていないISA拡張機能を使用する場合にのみ必要だが、実行時にそれらを使用するかどうかを確認せよ。

@item -mimpure-text
@opindex mimpure-text
@option{-mared-text}は、@option{-shared}に加えて、共有オブジェクトをリンクするときに@option{-z text}をリンカに渡さないようコンパイラに指示する。 このオプションを使用すると、位置依存のコードを共有オブジェクトにリンクできる。

@option{-mimpure-text}は、「再配置は割り当て可能だが書き込み不可能なセクションに残る」リンカーエラーメッセージを抑制する。ただし、必要な再配置によってコピーオンライトが開始され、共有オブジェクトは実際にはプロセス間で共有されない。 @option{-mimpure-text}を使用する代わりに、すべてのソースコードを@option{-fpic}または@option{-fPIC}でコンパイルする必要がある。

@end table

これらのスイッチは、Solaris 2で上記に加えてサポートされている。

@table @gcctabopt
@item -pthreads
@opindex pthreads
これは@option{-pthread}の同義語である。
@end table

@node SPARC Options
@subsection SPARCオプション
@cindex SPARC options

これらの@samp {-m}オプションは、SPARCでサポートされている。

@table @gcctabopt
@item -mno-app-regs
@itemx -mapp-regs
@opindex mno-app-regs
@opindex mapp-regs
SPARC SVR4 ABIがアプリケーション用に予約するグローバルレジスタ2～4を使用して出力を生成するには、@option{-mapp-regs}を指定する。 グローバル・レジスタ1と同様に、各グローバル・レジスタ2～4は、関数呼び出しによって保護される割り当て可能なレジスタとして扱われる。 これがデフォルトである。

一部のパフォーマンス低下を犠牲にして完全にSVR4 ABIに準拠するには、@option{-mno-app-regs}を指定する。 このオプションでライブラリとシステムソフトウェアをコンパイルする必要がある。

@item -mflat
@itemx -mno-flat
@opindex mflat
@opindex mno-flat
@option {-mflat}では、コンパイラは保存/復元命令を生成せず、 「フラット」またはシングルレジスタウィンドウモデルを使用する。このモデルは、正規のレジスタウィンドウモデルと互換性がある。ローカルレジスタおよび入力レジスタ（0～5）は、依然として「コールセーブされた」レジスタとして扱われ、必要に応じてスタックに保存される。

@option{-mno-flat}（デフォルト）では、コンパイラは保存/復元命令を生成する（リーフ関数を除く）。これは通常の動作モードである。

@item -mfpu
@itemx -mhard-float
@opindex mfpu
@opindex mhard-float
浮動小数点命令を含む出力を生成する。 これがデフォルトである。

@item -mno-fpu
@itemx -msoft-float
@opindex mno-fpu
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含む出力を生成する。@strong{注意：}必要なライブラリは、すべてのSPARCターゲットで利用できるわけではない。通常、マシンの通常のCコンパイラの機能が使用されるが、これはクロスコンパイルで直接行うことはできない。クロスコンパイルに適したライブラリ関数を提供するために、独自の手配をしなければならない。 埋め込みターゲット@samp{sparc-*-aout}と@samp {sparclite-*-*}は、ソフトウェア浮動小数点サポートを提供する。

@option{-msoft-float}は、出力ファイルの呼び出し規約を変更する。 したがって、このオプションでプログラムの@emph{すべて}をコンパイルする場合にのみ有用である。特に、GCCに付属のライブラリである@file{libgcc.a}を@option{-msoft-float}とコンパイルする必要がある。

@item -mhard-quad-float
@opindex mhard-quad-float
クワッドワード（long double）浮動小数点命令を含む出力を生成する。

@item -msoft-quad-float
@opindex msoft-quad-float
クワッドワード（long double）浮動小数点命令のライブラリ呼び出しを含む出力を生成する。 呼び出される関数はSPARC ABIで指定された関数である。これがデフォルトである。

この記事の執筆時点では、クワッドワード浮動小数点命令のハードウェアをサポートするSPARC実装はないん。 これらの命令はいずれもこれらの命令のいずれかのトラップハンドラを呼び出し、トラップハンドラは命令の効果をエミュレートする。 トラップハンドラのオーバーヘッドのために、ABIライブラリルーチンを呼び出すよりもはるかに時間がかかる。 したがって、@option{-msoft-quad-float}オプションがデフォルトである。

@item -mno-unaligned-doubles
@itemx -munaligned-doubles
@opindex mno-unaligned-doubles
@opindex munaligned-doubles
倍精度は8バイトのアライメントを持つと仮定する。 これがデフォルトである。

@option{-munaligned-doubles}を指定すると、GCCは、それらが他の型に含まれているか、さもなければ絶対アドレスを保つ場合に限り、double型が8バイトのアライメントを持つとみなす。それ以外の場合は、4バイトのアライメントがあるとみなされる。このオプションを指定すると、他のコンパイラで生成されたコードとの稀な互換性の問題を回避できる。特に浮動小数点コードの場合、パフォーマンスが低下するため、デフォルトではない。

@item -muser-mode
@itemx -mno-user-mode
@opindex muser-mode
@opindex mno-user-mode
スーパーバイザモードでしか実行できないコードを生成しない。 これは、LEON3プロセッサ用に生成された@code{casa}命令にのみ関係する。 これがデフォルトである。

@item -mfaster-structs
@itemx -mno-faster-structs
@opindex mfaster-structs
@opindex mno-faster-structs
@option {-mfaster-structs}を使用すると、構造体は8バイトの境界整列を持つ必要があるとコンパイラは想定する。これにより、@code{ld}と@code{st}の2倍の代わりに、構造割り当てのコピーに@code{ldd}命令と@code{std}命令のペアを使用することができる。ただし、この変更されたアラインメントの使用は、SPARC ABIに直接違反する。したがって、開発者が結果のコードがABIのルールに直接沿ったものではないことを認識しているターゲットでのみ使用することを意図している。

@item -mstd-struct-return
@itemx -mno-std-struct-return
@opindex mstd-struct-return
@opindex mno-std-struct-return
コンパイラは、@option{-mstd-struct-return}を使用して、構造体または共用体を返す関数にチェックコードを生成し、32ビットABIのように関数呼び出しの両側のサイズの不一致を検出する。

デフォルトは@option{-mno-std-struct-return}である。 このオプションは、64ビットモードでは効果がない。

@item -mlra
@itemx -mno-lra
@opindex mlra
@opindex mno-lra
ローカルレジスタ割り付けを有効にする。 これはGCC 7以降のSPARCのデフォルトのため、古いリロードを得るためには@option{-mno-lra}を渡す必要がある。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var {cpu_type}の命令セット、レジスタセット、および命令スケジューリングパラメータを設定する。 @var{cpu_type}のサポートされている値は@samp{v7}, @samp{cypress}, @samp{v8}, @samp{supersparc}, @samp{hypersparc}, @samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{sparclite}, @samp{f930}, @samp{f934}, @samp{sparclite86x}, @samp{sparclet}, @samp{tsc701}, @samp{v9}, @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3}, @samp{niagara4}, @samp{niagara7}, @samp{m8}である。

ネイティブSolarisおよびGNU / Linuxツールチェーンは、@samp{native}という値もサポートしている。これは、ホストプロセッサに最適なアーキテクチャオプションを選択する。GCCがプロセッサを認識しない場合、@option{-mcpu=native}は効果がない。

デフォルトの命令スケジューリングパラメータは、アーキテクチャを選択する値であり、実装ではない。 これらは@samp{v7}、@samp{v8}、@samp{sparclite}、@samp{sparclet}、@samp{v9}である。

サポートされている各アーキテクチャとサポートされている実装の一覧を示す。

@table @asis
@item v7
cypress, leon3v7

@item v8
supersparc, hypersparc, leon, leon3

@item sparclite
f930, f934, sparclite86x

@item sparclet
tsc701

@item v9
ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4,
niagara7, m8
@end table

デフォルトでは（別途設定されていない限り）、GCCはSPARCアーキテクチャのV7版のコードを生成する。 @option{-mcpu=cypress}を使用すると、コンパイラはSPARCStation / SPARCServer 3xxシリーズで使用されているCypress CY7C602チップ用に最適化する。これは古いSPARCStation 1,2、IPXなどにも適している。

@option{-mcpu=v8}を指定すると、GCCはSPARCアーキテクチャのV8版のコードを生成する。 V7コードとの唯一の違いは、コンパイラがSPARC-V8には存在し、SPARC-V7には存在しない整数乗算命令と整数除算命令を発行することである。 @option{-mcpu=supersparc}を指定すると、コンパイラはSPARCStation 10,1000,2000シリーズで使用されているように、SuperSPARCチップ用にコンパイラを最適化する。

@option{-mcpu=sparclite}を使用すると、GCCはSPARCアーキテクチャのSPARCliteバリアントのコードを生成する。これによりSPARCliteには存在するが、SPARC-V7には存在しない整数の乗算、整数除算のステップとスキャン（@code{ffs}）命令が追加される。@option {-mcpu=f930}を使用すると、コンパイラは元のSPARCliteであるFujitsu MB86930チップ（FPUなし）に最適化する。@option{-mcpu=f934}を指定すると、FPU付きのSPARCliteであるFujitsu MB86934チップ用に最適化される。

@option{-mcpu=sparclet}を使用すると、GCCはSPARCアーキテクチャのSPARCletバリアントのコードを生成する。これにより、SPARCletには存在するが、SPARC-V7には存在しない整数の乗算、乗算/累積、整数除算のステップとスキャン（@code{ffs}）命令が追加される。 @option{-mcpu=tsc701}では、TEMIC SPARCletチップ用に最適化されている。

@option {-mcpu=v9}を指定すると、GCCはSPARCアーキテクチャのV9版のコードを生成する。これにより、64ビット整数および浮動小数点移動命令、3つの追加浮動小数点条件コード・レジスタおよび条件付き移動命令が追加される。@option{-mcpu=ultrasparc}を使用すると、コンパイラはSun UltraSPARC I / II / IIiチップ用にコンパイラを最適化する。@option{-mcpu=ultrasparc}を使用すると、コンパイラはSun UltraSPARC I / II / IIiチップ用にコンパイラを最適化する。 @option{-mcpu=ultrasparc3}を使用すると、コンパイラはSun UltraSPARC III / III + / IIIi + / IV / IV +チップ用にコンパイラを最適化する。@option{-mcpu=niagara}を使用すると、コンパイラはSun UltraSPARC T1チップ用にコンパイラを最適化する。@option{-mcpu=niagara2}を使用すると、コンパイラはSun UltraSPARC T2チップ用にコンパイラを最適化する。@option{-mcpu=niagara3}では、コンパイラはSun UltraSPARC T3チップ用にコンパイラを最適化する。@option{-mcpu=niagara4}では、コンパイラはSun UltraSPARC T4チップ用にコンパイラを最適化する。@option{-mcpu=niagara7}を使用すると、コンパイラはOracle SPARC M7チップ用にコンパイラを最適化する。 @option{-mcpu=m8}を指定すると、コンパイラはOracle M8チップ用にコンパイラを最適化する。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var {cpu_type}の命令スケジューリングパラメータを設定するが、オプション@option{-mcpu=@var{cpu_type}}が実行する命令セットまたはレジスタセットは設定しない。

@option{-mcpu=@var{cpu_type}}と同じ値を@option{-mtune=@var{cpu_type}}に使用できるが、唯一有用な値は特定のCPU実装を選択する値であるす。それらは@samp{cypress}, @samp{supersparc}, @samp{hypersparc}, @samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{f930}, @samp{f934}, @samp{sparclite86x}, @samp{tsc701}, @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3}, @samp{niagara4}, @samp{niagara7}, @samp{m8}である。 ネイティブのSolarisおよびGNU/Linuxツールチェーンでは、@samp{native}も使用できる。 

@item -mv8plus
@itemx -mno-v8plus
@opindex mv8plus
@opindex mno-v8plus
@option {-mv8plus}を指定すると、GCCはSPARC-V8 + ABI用のコードを生成する。 V8 ABIとの違いは、グローバルレジスタとアウトレジスタが64ビット幅とみなされることである。これは、すべてのSPARC-V9プロセッサで32ビットモードのSolarisでデフォルトで有効になる。

@item -mvis
@itemx -mno-vis
@opindex mvis
@opindex mno-vis
@option {-mvis}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張機能を利用するコードを生成する。デフォルトは@option {-mno-vis}である。

@item -mvis2
@itemx -mno-vis2
@opindex mvis2
@opindex mno-vis2
@option {-mvis2}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン2.0を利用するコードを生成する。UltraSPARC-III以降など、そのような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mvis2}である。

@item -mvis3
@itemx -mno-vis3
@opindex mvis3
@opindex mno-vis3
@option {-mvis3}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン3.0を利用するコードを生成する。niagara-3以降のような命令をサポートしているCPUを対象とする場合、デフォルトは@option{-mvis3}である。@option {-mvis3}を設定すると、@option {-mvis2}と@option {-mvis}も設定される。

@item -mvis4
@itemx -mno-vis4
@opindex mvis4
@opindex mno-vis4
@option{-mvis4}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン4.0を利用するコードを生成する。 niagara-7以降のような命令をサポートしているCPUを対象にする場合、デフォルトは@option{-mvis4}である。 @option{-mvis4}を設定すると、@option{-mvis3}、@option{-mvis2}、@option{-mvis}も設定される。

@item -mvis4b
@itemx -mno-vis4b
@opindex mvis4b
@opindex mno-vis4b
@option{-mvis4b}を使用すると、GCCはUltraSPARC Visual Instruction Set拡張のバージョン4.0と、Oracle SPARC Architecture 2017で導入された追加のVIS命令を利用するコードを生成する。 m8以降のような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mvis4b}である。 @option{-mvis4b}を設定すると、@option{-mvis4}、@option{-mvis3}、@option{-mvis2}、@option{-mvis}も設定される。

@item -mcbcond
@itemx -mno-cbcond
@opindex mcbcond
@opindex mno-cbcond
@option{-mcbcond}を指定すると、GCCはUltraSPARC条件つきコンペア・アンド・ブランチ命令を利用したコードを生成する。 Niagara-4以降のような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mcbcond}である。

@item -mfmaf
@itemx -mno-fmaf
@opindex mfmaf
@opindex mno-fmaf
@option{-mfmaf}を使用すると、GCCは、UltraSPARC 乗加算融合浮動小数点命令を利用するコードを生成する。 Niagara-3以降のような命令をサポートするCPUを対象とする場合、デフォルトは@option{-mfmaf}である。

@item -mfsmuld
@itemx -mno-fsmuld
@opindex mfsmuld
@opindex mno-fsmuld
@option{-mfsmuld}を使用すると、GCCは浮動小数点倍精度単精度（FsMULd）命令を利用するコードを生成する。@option{-mcpu=leon}を除くFPUでアーキテクチャバージョンV8またはV9をサポートしているCPUを対象とする場合、デフォルトは@option{-mfsmuld}である。

@item -mpopc
@itemx -mno-popc
@opindex mpopc
@opindex mno-popc
@option{-mpopc}を指定すると、GCCはUltraSPARC Population Count命令を利用するコードを生成する。Niagara-2以降のような命令をサポートしているCPUを対象とする場合、デフォルトは@option{-mpopc}である。

@item -msubxc
@itemx -mno-subxc
@opindex msubxc
@opindex mno-subxc
@option{-msubxc}を使用すると、GCCはUltraSPARC キャリー減算拡張命令を利用したコードを生成する。Niagara-7以降のような命令をサポートしているCPUを対象とする場合、デフォルトは@option{-msubxc}である。

@item -mfix-at697f
@opindex mfix-at697f
Atmel AT697Fプロセッサの単一のエラッタ（AT697Eプロセッサのエラータ＃13に対応）について、文書化された回避策を有効にする。

@item -mfix-ut699
@opindex mfix-ut699
UT699プロセッサの浮動小数点エラッタとデータキャッシュ無効化エラータについて、文書化された回避策を有効にする。

@item -mfix-ut700
@opindex mfix-ut700
UT699E/UT700プロセッサのバックツーバックストアエラッタについて、文書化された回避策を有効にする。

@item -mfix-gr712rc
@opindex mfix-gr712rc
GR712RCプロセッサのバックツーバックストアエラッタについて、文書化された回避策を有効にする。
@end table

これらの@samp{-m}オプションは、上記の64ビット環境のSPARC-V9プロセッサでサポートされている。

@table @gcctabopt
@item -m32
@itemx -m64
@opindex m32
@opindex m64
32ビットまたは64ビット環境用のコードを生成します。32ビット環境はint、long、およびポインタを32ビットに設定する。64ビット環境ではintを32ビット、longとポインタ64ビットに設定する。

@item -mcmodel=@var{which}
@opindex mcmodel
コードモデルを次のいずれかに設定する。

@table @samp
@item medlow
中位/低コード・モデル：64ビット・アドレス、プログラムはメモリの低位32ビットにリンクする必要がある。 プログラムは静的または動的にリンクできる。

@item medmid
中位/中コードモデル：64ビットアドレス、プログラムはメモリの低位44ビットにリンクする必要がある。テキストとデータセグメントのサイズは2GB未満で、データセグメントはテキストセグメントの2GB以内に配置する必要がある。

@item medany
中位/任意コードモデル：64ビットアドレス、プログラムはメモリ内のどこにでもリンクできる。テキストとデータセグメントのサイズは2GB未満で、データセグメントはテキストセグメントの2GB以内に配置する必要がある。

@item embmedany
組み込みシステム用の中位/任意コードモデル：64ビットのアドレスでは、テキストセグメントとデータセグメントのサイズは2GB未満でなければならず、どちらもメモリ内の任意の場所（リンク時に決定）から開始する必要がある。  グローバル・レジスタ％g4は、データ・セグメントのベースを指す。プログラムは静的にリンクされており、PICはサポートされていない。
@end table

@item -mmemory-model=@var{mem-model}
@opindex mmemory-model
プロセッサの強制的なメモリモデルを次のいずれかに設定する。

@table @samp
@item default
プロセッサーとオペレーティングシステムのデフォルトのメモリーモデル。

@item rmo
緩和されたメモリ順序

@item pso
部分ストア順序

@item tso
完全ストア順序

@item sc
シーケンシャル一貫性
@end table

これらのメモリモデルは、プロセッサの@code{PSTATE.MM}フィールドで設定されているように、SPARC-V9アーキテクチャマニュアルの付録Dで正式に定義されている。

@item -mstack-bias
@itemx -mno-stack-bias
@opindex mstack-bias
@opindex mno-stack-bias
@option{-mstack-bias}を指定すると、GCCはスタックポインタとフレームポインタが存在すればそれを@minus{}2047でオフセットしているとみなす。これはスタックフレーム参照の際に追加する必要がある。 これは64ビットモードのデフォルトである。それ以外の場合は、そのようなオフセットが存在しないと仮定する。
@end table

@node SPU Options
@subsection SPUオプション
@cindex SPU options

これらの@samp {-m}オプションはSPUでサポートされている：

@table @gcctabopt
@item -mwarn-reloc
@itemx -merror-reloc
@opindex mwarn-reloc
@opindex merror-reloc

SPUのローダーは動的再配置を処理しない。 デフォルトでは、GCCは動的再配置を必要とするコードを生成するとエラーを返す。 @option{-mno-error-reloc}はエラーを無効にし、@option{-mwarn-reloc}は警告を生成する。

@item -msafe-dma
@itemx -munsafe-dma
@opindex msafe-dma
@opindex munsafe-dma

DMAの開始またはテストの完了を指示する命令を、アクセスされているメモリのロードおよびストアに関して並べ替えてはならないと指示する。@option{-munsafe-dma}を使用すると、メモリアクセスを保護するために@code{volatile}キーワードを使用する必要があるが、メモリが変更されないことが分かっている場所で非効率的なコードが発生する可能性がある。 メモリをvolatileとしてマークするのではなく、@option{-msafe-dma}を使用してDMA命令をすべてのメモリに潜在的に影響を及ぼすものとして扱うようにコンパイラに指示することができる。

@item -mbranch-hints
@opindex mbranch-hints

デフォルトでは、GCCは分岐ヒント命令を生成して、常に実行された分岐またはおそらく実行された分岐のパイプラインストールを回避する。ヒントは、そのブランチから8命令以上離れて生成されない。デバッグの目的を除いて、それらを無効にしたり、オブジェクトを少し小さくする理由はほとんどない。

@item -msmall-mem
@itemx -mlarge-mem
@opindex msmall-mem
@opindex mlarge-mem

デフォルトでは、GCCはアドレスが決して18ビットより大きくないと仮定してコードを生成する。完全な32ビットアドレスを前提とした@option{-mlarge-mem}コードが生成される。

@item -mstdmain
@opindex mstdmain

デフォルトでは、GCCはSPUスタイルのメイン関数インタフェース（非定型パラメータリストを持つ）を想定したスタートアップコードとリンクする。@option{-mstdmain}を使うと、GCCはあなたのプログラムを、@code{argv}文字列のローカルコピーを含め、@code {main}へのC99スタイルのインタフェースを想定したスタートアップコードとリンクする。

@item -mfixed-range=@var{register-range}
@opindex mfixed-range
与えられたレジスタ範囲を固定レジスタとして扱うコードを生成する。固定レジスタは、レジスタアロケータが使用できないレジスタである。カーネルコードをコンパイルするときに便利である。 レジスタ範囲は、ダッシュで区切られた2つのレジスタとして指定される。カンマで区切って複数のレジスタ範囲を指定することができる。

@item -mea32
@itemx -mea64
@opindex mea32
@opindex mea64
@code{__ ea}という名前のアドレス空間修飾子を介してアクセスされるPPUアドレス空間へのポインタが32または64ビット幅であると仮定してコードをコンパイルする。 デフォルトは32ビットである。これはABI変更オプションなので、実行可能ファイル内のすべてのオブジェクトコードは同じ設定でコンパイルする必要がある。

@item -maddress-space-conversion
@itemx -mno-address-space-conversion
@opindex maddress-space-conversion
@opindex mno-address-space-conversion
@code{__ ea}アドレス空間を汎用アドレス空間のスーパーセットとして扱うことを許可/禁止する。  これにより、@code{__ ea}と汎用ポインタの間の明示的な型キャストが可能になる。また、@code{__ ea}ポインタへの汎用ポインタの暗黙的な変換も可能である。デフォルトでは、アドレス空間ポインタの変換を許可する。

@item -mcache-size=@var{cache-size}
@opindex mcache-size
このオプションは、コンパイラが実行可能ファイルにリンクするlibgccのバージョンを制御し、特定のキャッシュサイズを持つ@code{__ ea}アドレス空間の変数にアクセスするためのソフトウェア管理キャッシュを選択する。 @var{cache-size}の可能なオプションは@samp{8}、@samp{16}、@samp{32}、@samp{64}、@samp{128}である。 デフォルトのキャッシュサイズは64KBである。

@item -matomic-updates
@itemx -mno-atomic-updates
@opindex matomic-updates
@opindex mno-atomic-updates
このオプションは、コンパイラが実行可能ファイルにリンクするlibgccのバージョンを制御し、PPU側の変数のソフトウェア管理キャッシュのアトミック更新を使用するかどうかを選択する。  アトミック更新を使用する場合、@code{__ ea}という名前のアドレススペース修飾子を使用してSPUコードからPPU変数を変更しても、PPUコードから同じキャッシュラインに存在する他のPPU変数への変更は妨げられない。アトミック更新を使用しない場合、そのような干渉が発生する可能性がある。 しかし、キャッシュラインを書き戻すほうが効率的である。デフォルトの動作では、アトミック更新を使用する。

@item -mdual-nops
@itemx -mdual-nops=@var{n}
@opindex mdual-nops
デフォルトでは、GCCはNOPを挿入して、パフォーマンスを向上させることを期待するときに二重問題を増やす。@var{n}には0から10の値を指定できる。より小さい@var{n}はより少ないNOPを挿入する。10がデフォルトで、0は@option{-mno-dual-nops}と同じである。@option{-Os}で無効になっている。

@item -mhint-max-nops=@var{n}
@opindex mhint-max-nops
分岐ヒントに挿入するNOPの最大数。分岐ヒントは、影響を受けるブランチから少なくとも8命令離れている必要がある。GCCはこれを強制するために@var{n}個のNOPを挿入し、そうでなければ分岐ヒントを生成する。

@item -mhint-max-distance=@var{n}
@opindex mhint-max-distance
分岐ヒント命令の符号化は、影響を与えている分岐の256命令以内にヒントを制限する。 デフォルトでは、GCCは125以内であることを確認する。

@item -msafe-hints
@opindex msafe-hints
SPUが無期限に停止する原因となるハードウェアのバグを回避する。デフォルトでは、GCCは@code{hbrp}命令を挿入して、このストールが起こらないようにする。

@end table

@node System V Options
@subsection System Vオプション

これらの追加オプションは、System V Release 4で、これらのシステム上の他のコンパイラとの互換性のために利用できる。

@table @gcctabopt
@item -G
@opindex G
共有オブジェクトを作成する。代わりに@option{-symbolic}または@option{-shared}を使用することを推奨する。

@item -Qy
@opindex Qy
出力の@code{.ident}アセンブラ指示文で、コンパイラが使用する各ツールのバージョンを指定する。

@item -Qn
@opindex Qn
@code{.ident}ディレクティブを出力ファイルに追加しない（これがデフォルト）。

@item -YP,@var{dirs}
@opindex YP
ディレクトリ@var{dirs}を検索し、@option{-l}で指定されたライブラリを探す。

@item -Ym,@var{dir}
@opindex Ym
ディレクトリ@var{dir}を見て、M4プリプロセッサを見つけてる。アセンブラはこのオプションを使用する。
@c This is supposed to go with a -Yd for predefined M4 macro files, but
@c the generic assembler that comes with Solaris takes just -Ym.
@end table

@node TILE-Gx Options
@subsection TILE-Gxオプション
@cindex TILE-Gx options

これらの@samp {-m}オプションはTILE-Gxでサポートされている：

@table @gcctabopt
@item -mcmodel=small
@opindex mcmodel=small
小さなモデルのコードを生成する。直接呼び出しの距離はどちらの方向にも500Mに制限されている。PC相対アドレスは32ビットです。絶対アドレスは完全なアドレス範囲をサポートする。

@item -mcmodel=large
@opindex mcmodel=large
大型モデル用のコードを生成します。呼び出し距離、PC相対アドレス、または絶対アドレスに制限はない。

@item -mcpu=@var{name}
@opindex mcpu
ターゲットにするCPUのタイプを選択します。 現在サポートされているタイプは@samp{tilegx}のみである。

@item -m32
@itemx -m64
@opindex m32
@opindex m64
32ビットまたは64ビット環境用のコードを生成する。32ビット環境では、int、long、および32ビットへのポインタが設定される。64ビット環境ではintを32ビット、longとポインタを64ビットをに設定する。

@item -mbig-endian
@itemx -mlittle-endian
@opindex mbig-endian
@opindex mlittle-endian
ビッグ/リトルエンディアンモードでコードを生成します。
@end table

@node TILEPro Options
@subsection TILEProオプション
@cindex TILEPro options

これらの@samp{-m}オプションはTILEProでサポートされている：

@table @gcctabopt
@item -mcpu=@var{name}
@opindex mcpu
ターゲットにするCPUのタイプを選択する。 現在サポートされているタイプは@samp{tilepro}のみである。

@item -m32
@opindex m32
int、long、および32ビットへのポインタを設定する32ビット環境用のコードを生成する。 これはサポートされている唯一の動作なので、フラグは本質的に無視される。
@end table

@node V850 Options
@subsection V850オプション
@cindex V850 Options

これらの@samp{-m}オプションは、V850実装で定義されている。

@table @gcctabopt
@item -mlong-calls
@itemx -mno-long-calls
@opindex mlong-calls
@opindex mno-long-calls
すべての呼び出しを遠く（近く）として扱う。 呼び出しが遠くにあると仮定すると、コンパイラは常に関数のアドレスをレジスタにロードし、ポインタを介して間接を呼び出す。

@item -mno-ep
@itemx -mep
@opindex mno-ep
@opindex mep
同じインデックスポインタを使用する基本ブロックを4回以上最適化（最適化）してポインタを@code{ep}レジスタにコピーし、より短い@code{sld}命令と@code{sst}命令を使用しない。@option{-mep}オプションは、最適化するとデフォルトでオンになっている。

@item -mno-prolog-function
@itemx -mprolog-function
@opindex mno-prolog-function
@opindex mprolog-function
関数のプロローグとエピローグでレジスタを保存および復元するために外部関数を使用しない（する）。 外部関数は遅くなるが、複数の関数が同じ数のレジスタを保存する場合は、より少ないコードスペースを使用する。 @option{-mprolog-function}オプションは、最適化するとデフォルトでオンになっている。

@item -mspace
@opindex mspace
できるだけコードを小さくしてみる。 現在のところ、これは@option{-mep}オプションと@option{-mprolog-function}オプションをオンにするだけである。

@item -mtda=@var{n}
@opindex mtda
@var{n}バイト以下の静的変数または大域変数を、@code{ep}の指す小さなデータ領域に入れる。小さなデータ領域は合計で256バイト（バイト参照の場合は128バイト）まで保持できる。

@item -msda=@var{n}
@opindex msda
@var{n}バイト以下の静的変数または大域変数を、@code{gp}を指す小さなデータ領域に入れる。 小さなデータ領域は64キロバイトまで保持できる。

@item -mzda=@var{n}
@opindex mzda
@var{n}バイト以下のサイズの静的変数または大域変数をメモリの最初の32キロバイトに入れる。

@item -mv850
@opindex mv850
ターゲット・プロセッサーがV850であることを指定する。

@item -mv850e3v5
@opindex mv850e3v5
ターゲット・プロセッサーがV850E3V5であることを指定する。 このオプションを使用すると、プリプロセッサ定数@code{__v850e3v5__}が定義される。

@item -mv850e2v4
@opindex mv850e2v4
ターゲット・プロセッサーがV850E3V5であることを指定する。 これは@option{-mv850e3v5}オプションのエイリアスである。

@item -mv850e2v3
@opindex mv850e2v3
ターゲット・プロセッサーがV850E2V3であることを指定する。 このオプションを使用すると、プリプロセッサ定数@code {__v850e2v3__}が定義される。

@item -mv850e2
@opindex mv850e2
ターゲット・プロセッサーがV850E2であることを指定する。 このオプションを使用すると、プリプロセッサ定数@code{__v850e2__}が定義される。

@item -mv850e1
@opindex mv850e1
ターゲット・プロセッサーがV850E1であることを指定する。 このオプションを使用すると、プリプロセッサの定数@code{__v850e1__}と@code{__v850e__}が定義される。

@item -mv850es
@opindex mv850es
ターゲット・プロセッサーがV850ESであることを指定する。 これは@option{-mv850e1}オプションのエイリアスである。

@item -mv850e
@opindex mv850e
ターゲット・プロセッサーがV850Eであることを指定する。このオプションを使用すると、プリプロセッサ定数@code{__v850e__}が定義される。

@option{-mv850}、@option{-mv850e}、@option{-mv850e1}、@option{-mv850e2}、および@option{-mv850e2v3}や@option {-mv850e3v5}のどれも定義されていない場合、デフォルトのターゲット・プロセッサが選択され、関連する@samp{__ v850 * __}プリプロセッサ定数が定義される。

プリプロセッサの定数@code{__ v850}と@code{__ v851__}は、ターゲットとなるプロセッサの種類に関係なく常に定義される。

@item -mdisable-callt
@itemx -mno-disable-callt
@opindex mdisable-callt
@opindex mno-disable-callt
このオプションは、v850アーキテクチャーのv850e、v850e1、v850e2、v850e2v3、およびv850e3v5フレーバーの@code {CALLT}命令の生成を抑制する。

このオプションは、RH850 ABIが使用されている場合（デフォルトでは@option{-mrh850-abi}を参照）、デフォルトで有効になっている。GCC ABIが使用されている場合、デフォルトでは無効になっている。 @code{CALLT}命令が生成されている場合、Cプリプロセッサシンボル@code{__ V850_CALLT__}が定義される。

@item -mrelax
@itemx -mno-relax
@opindex mrelax
@opindex mno-relax
@option{-mrelax}コマンドラインオプションをアセンブラに渡す（渡さない）。

@item -mlong-jumps
@itemx -mno-long-jumps
@opindex mlong-jumps
@opindex mno-long-jumps
PC相対ジャンプ命令の生成を無効にする（または再び有効にする）。

@item -msoft-float
@itemx -mhard-float
@opindex msoft-float
@opindex mhard-float
ハードウェア浮動小数点命令の生成を無効にする（または再び有効にする）。 このオプションは、ターゲット・アーキテクチャーが@samp{V850E2V3}以上の場合にのみ重要である。 ハードウェア浮動小数点命令が生成されている場合は、Cプリプロセッサシンボル@code{__ FPU_OK__}が定義される。そうでない場合、シンボル@code{__NO_FPU__}が定義される。

@item -mloop
@opindex mloop
e3v5 LOOP命令の使用を有効にする。 e3v5アーキテクチャが選択されている場合、その命令の使用はまだ実験的であるので、このデフォルトでは有効になっていない。

@item -mrh850-abi
@itemx -mghs
@opindex mrh850-abi
@opindex mghs
V850 ABIのRH850バージョンのサポートを有効にする。 これがデフォルトである。 このバージョンのABIでは、以下のルールが適用される。

@itemize
@item
整数サイズの構造体と共用体は、レジスタではなくメモリポインタを介して返される。

@item
大きな構造体と共用体（サイズが8バイト以上）は値渡しされる。

@item
関数は16ビットの境界に揃えられる。

@item
@option {-m8byte-align}コマンドラインオプションがサポートされる。

@item
@option {-mdisable-callt}コマンドラインオプションは、デフォルトで有効になっている。@option{-mno-disable-callt}コマンドラインオプションはサポートされていない。
@end itemize

このバージョンのABIを有効にすると、Cプリプロセッサシンボル@code {__ V850_RH850_ABI__}が定義される。

@item -mgcc-abi
@opindex mgcc-abi
古いGCCバージョンのV850 ABIをサポートする。 このバージョンのABIでは、以下のルールが適用される。

@itemize
@item
整数サイズの構造体と共用体はレジスタ@code{r10}に返される。

@item
大きな構造体と共用体（サイズが8バイト以上）は、参照渡しされる。

@item
関数は、サイズを最適化しない限り、32ビットの境界に整列される。

@item
@option{-m8byte-align}コマンドラインオプションはサポートされていない。

@item
@option{-mdisable-callt}コマンドラインオプションはサポートされていないが、デフォルトでは有効になっていない。
@end itemize

このバージョンのABIを有効にすると、Cプリプロセッサシンボル@code{__V850_GCC_ABI__}が定義される。

@item -m8byte-align
@itemx -mno-8byte-align
@opindex m8byte-align
@opindex mno-8byte-align
@code{double}型と@code{long long}型を8バイトの境界に整列させるためのサポートを有効にする。 デフォルトでは、すべてのオブジェクトの配置を最大で4バイトに制限する。 @option{-m8byte-align}が有効な場合、Cプリプロセッサシンボル@code{__V850_8BYTE_ALIGN__}が定義される。

@item -mbig-switch
@opindex mbig-switch
大きなスイッチテーブルに適したコードを生成する。 このオプションは、アセンブラ/リンカがスイッチテーブル内の範囲外の分岐に不平を言う場合にのみ使用する。

@item -mapp-regs
@opindex mapp-regs
このオプションを指定すると、コンパイラによって生成されたコードでr2とr5が使用される。 この設定はデフォルトである。

@item -mno-app-regs
@opindex mno-app-regs
このオプションは、r2とr5を固定レジスタとして扱う。

@end table

@node VAX Options
@subsection VAXオプション
@cindex VAX options

これらの@samp{-m}オプションは、VAXに対して定義されている。

@table @gcctabopt
@item -munix
@opindex munix
VAXのUnixアセンブラが長距離で処理できない特定のジャンプ命令（@code{aobleq}など）を出力しない。

@item -mgnu
@opindex mgnu
GNUアセンブラが使用されていることを前提に、これらのジャンプ命令を出力する。

@item -mg
@opindex mg
D-フォーマットの代わりにG-フォーマット浮動小数点数のコードを出力する。
@end table

@node Visium Options
@subsection Visiumオプション
@cindex Visium options

@table @gcctabopt

@item -mdebug
@opindex mdebug
ファイルI/Oを実行し、MCMターゲット上で実行する予定のプログラムは、このオプションにリンクする必要がある。これにより、ライブラリlibc.aとlibdebug.aがリンクされる。プログラムは、GDBリモートデバッグスタブの制御下でターゲット上で実行する必要がある。

@item -msim
@opindex msim
ファイルI/Oを実行し、シミュレータ上で動作するように設計されたプログラムは、オプションつきでリンクする必要がある。 これにより、ライブラリlibc.aとlibsim.aがリンクされる。

@item -mfpu
@itemx -mhard-float
@opindex mfpu
@opindex mhard-float
浮動小数点命令を含むコードを生成する。 これがデフォルトである。

@item -mno-fpu
@itemx -msoft-float
@opindex mno-fpu
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含むコードを生成する。

@option{-msoft-float}は、出力ファイルの呼び出し規約を変更する。 したがって、このオプションでプログラムの@emph{すべて}をコンパイルする場合にのみ有用である。 特に、GCCに付属のライブラリである@file{libgcc.a}を@option{-msoft-float}とコンパイルする必要がある。

@item -mcpu=@var{cpu_type}
@opindex mcpu
機種@var{cpu_type}の命令セット、レジスタセット、および命令スケジューリングパラメータを設定する。 @var{cpu_type}にサポートされている値は@samp{mcm}、@samp{gr5}、@samp{gr6}である。

@samp{mcm}は、下位互換性のために存在する@samp{gr5}の同義語である。

既定では（別途設定されていない限り）、GCCはVisiumアーキテクチャのGR5バリアントのコードを生成する。

@option{-mcpu=gr6}を指定すると、GCCはVisiumアーキテクチャのGR6バリアントのコードを生成する。 GR5コードとの唯一の違いは、コンパイラがブロック移動命令を生成することである。

@item -mtune=@var{cpu_type}
@opindex mtune
機種@var{cpu_type}の命令スケジューリングパラメータを設定するが、@option{-mcpu=@var{cpu_type}}オプションが設定する命令セットまたはレジスタセットは設定しない。

@item -msv-mode
@opindex msv-mode
汎用レジスタへのアクセスに制限のないスーパバイザ・モード用のコードを生成します。 これがデフォルトである。

@item -muser-mode
@opindex muser-mode
いくつかの汎用レジスタへのアクセスが禁止されているユーザモード用のコードを生成する。GR5では、このモードではレジスタr24〜r31にアクセスできまない。 GR6では、レジスタr29〜r31のみが影響を受ける。
@end table

@node VMS Options
@subsection VMSオプション

これらの@samp {-m}オプションは、VMS実装に対して定義されている。

@table @gcctabopt
@item -mvms-return-codes
@opindex mvms-return-codes
@code{main}からVMS条件コードを返す。 デフォルトでは、POSIXスタイルの条件（たとえばエラー）コードが返される。

@item -mdebug-main=@var{prefix}
@opindex mdebug-main=@var{prefix}
@var{prefix}で始まる名前の最初のルーチンに、デバッガのメインルーチンとしてフラグを立てる。

@item -mmalloc64
@opindex mmalloc64
デフォルトは64ビットメモリ割り当てルーチンである。

@item -mpointer-size=@var{size}
@opindex mpointer-size=@var{size}
ポインタのデフォルトサイズを設定する。@var{size}の可能なオプションは、32ビットポインタの場合は@samp{32}または@samp{short}、64ビットポインタの場合は@samp{64}または@samp{long}、32ビットポインタのみをサポートする@samp{no}。後のオプションは@code{pragma pointer_size}を無効にする。
@end table

@node VxWorks Options
@subsection VxWorksオプション
@cindex VxWorks Options

このセクションのオプションは、すべてのVxWorksターゲットで定義されている。ターゲットハードウェアに固有のオプションは、そのターゲットの他のオプションとともにリストされる。

@table @gcctabopt
@item -mrtp
@opindex mrtp
GCCは、VxWorksカーネルとリアルタイムプロセス（RTP）の両方のコードを生成できる。 このオプションは前者から後者に切り替える。 また、プリプロセッサマクロ@code {__RTP__}も定義する。

@item -non-static
@opindex non-static
静的ライブラリではなく共有ライブラリに対してRTP実行可能ファイルをリンクする。 オプション@option{-static}と@option{-shared}はRTPにも使用できる（@pxref{Link Options}）。 @option{-static}がデフォルトである。

@item -Bstatic
@itemx -Bdynamic
@opindex Bstatic
@opindex Bdynamic
これらのオプションはリンカに渡される。 それらはDiabとの互換性のために定義されている。

@item -Xbind-lazy
@opindex Xbind-lazy
関数呼び出しの遅延バインドを有効にする。 このオプションは@option{-Wl、-z、now}に相当し、Diabとの互換性のために定義されている。

@item -Xbind-now
@opindex Xbind-now
関数呼び出しの遅延バインディングを無効にする。 このオプションはデフォルトであり、Diabとの互換性のために定義されている。
@end table

@node x86 Options
@subsection x86オプション
@cindex x86 Options

これらの@samp {-m}オプションは、x86ファミリのコンピュータで定義されている。

@table @gcctabopt

@item -march=@var{cpu-type}
@opindex march
機種@var{cpu-type}の命令を生成する。@option{-march=@var{cpu-type}}は、指定された@var{cpu-type}の生成コードをチューニングするだけで、@option{-march=@ var{cpu-type}}は、 示されているプロセッサ以外のプロセッサではまったく動作しないコードを生成するためにGCCを使用する。@option{-march=@var{cpu-type}}を指定すると、@option{-mtune=@var{cpu-type}}となる。

@var{cpu-type}の選択肢は次のとおりである。

@table @samp
@item native
これにより、コンパイル時のコードを生成するCPUが選択され、コンパイルマシンのプロセッサタイプが決定される。@option{-march = native}を使用すると、ローカルマシンでサポートされているすべての命令サブセットが有効になる（したがって、結果は異なるマシンでは実行されない可能性がある。）@option{-mtune = native}を使用すると、選択した命令セットの制約の下でローカルマシン用に最適化されたコードが生成される。

@item x86-64
A generic CPU with 64-bit extensions.

@item i386
元々のi386CPU。

@item i486
Intel i486 CPU。 （このチップ用スケジューリングは実装されていない。）

@item i586
@itemx pentium
MMXサポートのないIntel Pentuim CPU。

@item lakemont
Intel Pentium CPUに基づいたIntel Lakemont MCU。

@item pentium-mmx
MMX命令セットサポートを持つPentuimコアに基づいたIntel Pentium MMX CPU。

@item pentiumpro
Intel Pentium Pro CPU。

@item i686
@option{-march}で使ったときは、Pentuim Pro命令セットが使われ、全i686ファミリチップ上で走るコードになる。@option{-mtune}で使ったときは、@samp{generic}と同じ意味である。

@item pentium2
MMX命令セットサポートを持つPentium Proコアに基づいたIntel Pentuim II CPU。

@item pentium3
@itemx pentium3m
MMXとSSEの命令セットサポートを持つPentium Proコアに基づいたIntel Pentuim II CPU。

@item pentium-m
Intel Pentuim M。MMX、SSE、SSE2命令セットサポートを持つIntel Pentuim III CPUの低消費電力バージョン。Centrinoノートブックで使われた。

@item pentium4
@itemx pentium4m
MMX、SSE、SSE2命令セットサポートを持つIntel Pentuim 4 CPU。

@item prescott
MMX、SSE、SSE2、SSE3命令セットサポートを持つIntel Pentuim 4 CPUの改良バージョン。

@item nocona
64ビット拡張、MMX、SSE、SSE2、SSE3命令セットサポートを持つIntel Pentium 4 CPUの改良バージョン。

@item core2
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つIntel Core 2 CPU。

@item nehalem
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT命令セットサポートを持つIntel Nehalem CPU。

@item westmere
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AES、PCLMUL命令セットサポートを持つIntel Westmere CPU。

@item sandybridge
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AES、PCLMUL命令セットサポートを持つIntel Sandy Bridge CPU。

@item ivybridge
64ビット拡張、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AES、PCLMUL、FSGSBASE、RDRND、F16C命令セットサポートを持つIntel Sandy Bridge CPU。

@item haswell
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C命令セットサポートを持つIntel Haswell CPU。

@item broadwell
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW命令セットサポートを持つIntel Broadwell CPU。

@item skylake
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES命令セットサポートを持つIntel Skylake CPU。

@item bonnell
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポート持つIntel Bonnell CPU。

@item silvermont
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AES、PCLMUL、RDRND命令セットサポートを持つIntel Slivermont CPU。

@item knl
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、MFA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、AVX512F、AVX512PF、AVX512ER、AVX512CD命令セットサポート持つIntel Knight's Landing CPU。

@item knm
64-bit拡張, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX5124VNNIW, AVX5124FMAPS, AVX512VPOPCNTDQ命令セットサポート持つIntel Knight's Mill CPU。

@item skylake-avx512
64ビット拡張、MOVBE、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、MFA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、AVX512VL、AVX512BW、AVX512DQ、AVX512CD命令セットサポートを持つIntel SkylakeサーバーCPU。

@item cannonlake
64ビット拡張, MOVBE, MMX, SSE, SSE2,
SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE,
RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC,
XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI,
AVX512IFMA, SHA, UMIP命令セットサポートを持つIntel CannonlakeサーバーCPU。

@item icelake-client
64ビット拡張, MOVBE, MMX, SSE, SSE2,
SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE,
RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC,
XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI,
AVX512IFMA, SHA, CLWB, UMIP, RDPID, GFNI, AVX512VBMI2, AVX512VPOPCNTDQ,
AVX512BITALG, AVX512VNNI, VPCLMULQDQ, VAES命令セットサポートを持つIntel Icelake クライアントCPU 。

@item icelake-server
64ビット拡張, MOVBE, MMX, SSE, SSE2,
SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, PKU, AVX, AVX2, AES, PCLMUL, FSGSBASE,
RDRND, FMA, BMI, BMI2, F16C, RDSEED, ADCX, PREFETCHW, CLFLUSHOPT, XSAVEC,
XSAVES, AVX512F, AVX512VL, AVX512BW, AVX512DQ, AVX512CD, AVX512VBMI,
AVX512IFMA, SHA, CLWB, UMIP, RDPID, GFNI, AVX512VBMI2, AVX512VPOPCNTDQ,
AVX512BITALG, AVX512VNNI, VPCLMULQDQ, VAES, PCONFIG, WBNOINVD命令セットサポートを持つIntel Icelake サーバーCPU 。

@item k6
MMX命令セットサポートを持つAMD K6 CPU。

@item k6-2
@itemx k6-3
MMXと3DNow!命令セットサポートを持つAMD K6の改良されたバージョン。

@item athlon
@itemx athlon-tbird
MMX、3dNOW!、enhanced 3DNow!、SSEプリフェッチ命令サポートを持つAMD Athlon CPU。

@item athlon-4
@itemx athlon-xp
@itemx athlon-mp
MMX、3DNow!、enhanced 3DNow!、完全SSE命令セットサポートを持つ改良されたAMD Athlon CPU。

@item k8
@itemx opteron
@itemx athlon64
@itemx athlon-fx
AMD Opteron、Athlong 64、Athlon 64 FXプロセッサを含む、x86-64命令セットサポートを持つAMD K8コアに基づくプロセッサ。（これは、MMX、SSE、SSE2、3DNow!、enhanced 3DNow!、64ビット命令セット拡張を含む。）

@item k8-sse3
@itemx opteron-sse3
@itemx athlon64-sse3
SSE3命令セットサポートを含むAMD K8コアの改良されたバージョン。

@item amdfam10
@itemx barcelona
x86-64命令セットサポートを持つAMD10世代コアに基づくCPU。（これはMMX、SSE、SSE2、SSE3、SSE4A、3DNow!、enhaned 3DNow!、ABM、64ビット命令セット拡張を含む。）

@item bdver1
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはFMA4、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item bdver2
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはBMI、TBM、F16C、FMA、FMA4、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item bdver3
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはBMI、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、XOP、LWP、AES、PCL_MUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item bdver4
x86-64命令セットサポートを持つAMD15世代コアに基づくCPU。（これはBMI、BMI2、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、AVX2、XOP、LWP、AES、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、64ビット命令セット拡張を含む。）

@item znver1
x86-64命令セットサポートを持つAMD17世代コアに基づくCPU。（これはBMI、BMI2、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、、PCL_MUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVES、CLFULSHOPT、POPCNT、64ビット命令セット拡張を含む。）

@item btver1
x86-64命令セットサポートを持つAMD14世代コアに基づくCPU。（これはMMX、SSE、SSE2、SSE3、SSE4A、CX16、ABM、64ビット命令セット拡張を含む。）

@item btver2
x86-64命令セットサポートを持つAMD16世代コアに基づくCPU。（これはMOVBE、F16C、BMI、AVX、PCL_MUL、AES、SSE4.2、SSE4.1、CX16、ABM、SSE4A、SSSE3、SSE3、SSE2、SSE、MMX、64ビット命令セット拡張を含む。）

@item winchip-c6
追加のMMX命令セットをサポートするi486と同じように処理される、IDT WinChip C6 CPU。

@item winchip2
追加のMMXと3DNow!命令セットをサポートするi486と同じように処理される、IDT WinChip 2 CPU。

@item c3
MMXと3DNow!命令セットサポートを持つVIA C3 CPU。 （このチップ用スケジューリングは実装されていない。）

@item c3-2
MMXとSSE命令セットサポートを持つVIA C3-2 (Nehemiah/C5XL) CPU。（このチップ用スケジューリングは実装されていない。）

@item c7
MMX、SSE、SSE2、SSE3命令セットサポートを持つVIA C7 (Esther) CPU。（このチップ用スケジューリングは実装されていない。）

@item samuel-2
MMXと3DNow!命令セットサポートを持つVIA Eden Samuel 2 CPU。（このチップ用スケジューリングは実装されていない。）

@item nehemiah
MMXとSSE命令セットサポートを持つVIA Eden Nehemiah CPU。（このチップ用スケジューリングは実装されていない。）

@item esther
MMX、SSE、SSE2、SSE3命令セットサポートを持つVIA Eden Esther CPU。（このチップ用スケジューリングは実装されていない。）

@item eden-x2
x86-64、MMX、SSE、SSE2、SSE3命令セットサポートを持つVIA Eden X2 CPU。（このチップ用スケジューリングは実装されていない。）

@item eden-x4
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、AVX、AVX2命令セットサポートを持つVIA Eden X4 CPU。（このチップ用スケジューリングは実装されていない。）

@item nano
x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つ汎用VIA Nano CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-1000
x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つVIA Nano 1xxx CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-2000
x86-64、MMX、SSE、SSE2、SSE3、SSSE3命令セットサポートを持つVIA Nano 2xxx CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-3000
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットサポートを持つVIA Nano 2xxx CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-x2
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットサポートを持つVIA Nano Dual Core CPU。（このチップ用スケジューリングは実装されていない。）

@item nano-x4
x86-64、MMX、SSE、SSE2、SSE3、SSSE3、SSE4.1命令セットサポートを持つVIA Nano Quadl Core CPU。（このチップ用スケジューリングは実装されていない。）

@item geode
MMXと3DNow!命令セットサポートを持つAMD Geode組み込みプロセッサ。
@end table

@item -mtune=@var{cpu-type}
@opindex mtune
ABIと使用可能な命令のセットを除いて、生成されたコードに関するすべてのものを@var{cpu-type}に調整する。特定の@var{cpu-type}を選んでその特定のチップを適切にスケジューリングすると、@option{-march=@var{cpu-type}}オプションを使用しない限り、コンパイラはデフォルトのマシンタイプでは実行できないコードを生成しない。たとえば、GCCがi686-pc-linux-gnu用に設定されている場合、@option{-mtune=pentium4}はPentium 4用にチューニングされたコードを生成するが、i686マシン上で実行できる。

@var{cpu-type}の選択肢は、@option{-march}の選択肢と同じである。さらに、@option{-mtune}は、@var{cpu-type}に対して2つの追加の選択肢をサポートしている：

@table @samp
@item generic
最も一般的なIA32・AMD64・EM64Tプロセッサ用に最適化されたコードを生成する。コードを実行するCPUが分かっている場合は、@option{-mtune = generic}ではなく、対応する@option{-mtune}または@option{-march}オプションを使用するべきである。しかし、アプリケーションのどのCPUユーザーが正確に何を持っているのかわからない場合は、このオプションを使用する必要がある。

新しいプロセッサが市場に展開されると、このオプションの動作が変わる。 したがって、新しいバージョンのGCCにアップグレードすると、このオプションで制御されるコード生成は、GCCのリリース時に最も一般的なプロセッサーを反映して変更される。

@option{-march}はコンパイラが使用できる命令セットを示し、すべてのプロセッサに適用可能な汎用命令セットがないため、@option{-march=generic}オプションはない。 対照的に、@option{-mtune}は、コードが最適化されているプロセッサ（または、この場合はプロセッサの集合）を示す。

@item intel
このバージョンのGCCでは、最新のIntelプロセッサ（HaswellとSilvermont）向けに最適化されたコードを生成する。コードが実行されるCPUを知っているなら、@option{-mtune=intel}の代わりに対応する@option{-mtune}または@option{-march}オプションを使うべきである。しかし、HaswellとSilvermontの両方でアプリケーションのパフォーマンスが向上したい場合は、このオプションを使用する必要がある。

新しいIntelプロセッサが市場に展開されると、このオプションの動作が変更される。 したがって、新しいバージョンのGCCにアップグレードすると、このオプションによって制御されるコード生成は、GCCのバージョンがリリースされた時点の最新のIntelプロセッサを反映して変更される。

@option{-march}は、コンパイラが使用できる命令セットを示し、すべてのプロセッサに共通の命令セットがないため、@option{-march=intel}オプションはない。 対照的に、@option {-mtune}は、コードが最適化されているプロセッサ（または、この場合はプロセッサの集合）を示す。
@end table

@item -mcpu=@var{cpu-type}
@opindex mcpu
@option{-mtune}の非推奨シノニム。

@item -mfpmath=@var{unit}
@opindex mfpmath
選択したユニット@var{unit}の浮動小数点演算を生成する。 @var{unit}の選択肢は次のとおりである。

@table @samp
@item 387
大多数のチップに存在する標準の387浮動小数点コプロセッサを使用し、それ以外の場合はエミュレートする。 このオプションでコンパイルされたコードは、ほぼすべての場所で実行できる。一時的な結果は、型によって指定された精度の代わりに80ビットの精度で計算され、他のほとんどのチップと比較してわずかに異なる結果になる。 より詳しい説明は@option{-ffloat-store}を参照せよ。

これは非Dawrinのx86-32ターゲットのデフォルトの選択肢である。

@item sse
SSE命令セットに存在するスカラー浮動小数点命令を使用する。この命令セットは、Pentium III以上のチップ、Athlon-4、Athlon XP、Athlon MPチップによるAMDラインでサポートされている。 SSE命令セットの以前のバージョンは単精度算術のみをサポートしているため、387を使用して倍精度および拡張精度算術演算が行われる。Pentium 4およびAMD x86-64チップにのみ存在する後のバージョンでは、倍精度算術もある。

x86-32コンパイラでは、SSE拡張を有効にしてこのオプションを有効にするには、@option{-march=@var{cpu-type}}、@option{-msse}または@option{-msse2}スイッチを使用する必要がある。 x86-64コンパイラの場合、これらの拡張機能はデフォルトで有効になっている。

結果のコードは、大部分のケースでかなり速く、387コードの数値的な不安定性の問題を回避するはずであるが、一時的なものが80ビットであることを期待する既存のコードがいくつか破壊される可能性がある。

これは、x86-64コンパイラ、Darwin x86-32ターゲット、および@option{-ffast-math}が有効な場合にSSE2命令セットを持つx86-32ターゲットのデフォルト選択のデフォルト選択である。

@item sse,387
@itemx sse+387
@itemx both
両方の命令セットを同時に使用しようとする。 これにより、使用可能なレジスタの量が効果的に倍増し、387用とSSE用で別々の実行単位を持つチップでは実行リソースも別々になる。 GCCレジスタアロケータは別々の関数ユニットをうまくモデル化せず、結果として不安定なパフォーマンスになるために、まだ実験的なので注意してこのオプションを使用すること。
@end table

@item -masm=@var{dialect}
@opindex masm=@var{dialect}
選択された@var{dialect}を使用してアセンブリ命令を出力する。 基本的な@code{asm}（@pxref{Basic Asm}）と拡張された@code{asm}（@pxref{Extended Asm}）に使われる変種にも影響する。 サポートされている選択肢（ダイアレクト順）は@samp{att}または@samp{intel}である。 デフォルトは@samp{att}である。 Darwinは@samp{intel}をサポートしていない。

@item -mieee-fp
@itemx -mno-ieee-fp
@opindex mieee-fp
@opindex mno-ieee-fp
コンパイラがIEEE浮動小数点比較を使用するかどうかを制御する。 これらは、比較の結果が順序付けられていない場合を正しく処理する。

@item -m80387
@itemx -mhard-float
@opindex 80387
@opindex mhard-float
浮動小数点用に80387命令を含む出力を生成する。

@item -mno-80387
@itemx -msoft-float
@opindex no-80387
@opindex msoft-float
浮動小数点のライブラリ呼び出しを含む出力を生成する。

@strong{警告：}必要なライブラリはGCCの一部ではない。通常、マシンの通常のCコンパイラの機能が使用されるが、これはクロスコンパイルで直接行うことはできない。 クロスコンパイルに適したライブラリ機能を提供するために、独自の手配をしなければならない。

関数が80387レジスタスタックの浮動小数点結果を返すマシンでは、@option{-msoft-float}が使用されていても、一部の浮動小数点オペコードが発行されることがある。

@item -mno-fp-ret-in-387
@opindex mno-fp-ret-in-387
関数の戻り値にFPUレジスタを使用しない。

通常の呼び出し規約では、FPUがない場合でも、関数が@code{float}型と@code{double}型の値をFPUレジスタで返すようになっている。 考え方は、オペレーティングシステムがFPUをエミュレートする必要があるということである。

オプション@option{-mno-fp-ret-in-387}は、そのような値が通常のCPUレジスタに返されるようにする。

@item -mno-fancy-math-387
@opindex mno-fancy-math-387
一部の387エミュレータは、387の@code {sin}、@code {cos}および@code {sqrt}命令をサポートしていない。これらの命令の生成を避けるには、このオプションを指定する。このオプションはOpenBSDとNetBSDのデフォルトである。  このオプションは、@option{-march}がターゲットCPUが常にFPUを持っていることを示し、命令がエミュレーションを必要としないときには無効になる。@option{-funsafe-math-optimizations}スイッチも使用しない限り、これらの命令は生成されない。

@item -malign-double
@itemx -mno-align-double
@opindex malign-double
@opindex mno-align-double
GCCが@code{double}、@code{long double}、@code{long long}の変数を2ワード境界か1ワード境界に揃えるかどうかを制御する。 2ワード境界で@code{double}変数を調整すると、Pentium上でより高速に動作するコードが生成され、より多くのメモリが消費される。

x86-64では、デフォルトで@option{-malign-double}が有効になっている。

@strong{警告:} @option{-malign-double}スイッチを使用すると、上記の型を含む構造体は公開されているx86-32のバイナリインタフェース仕様とは異なった位置に配置され、そのスイッチなしでコンパイルされたコード内の構造体とバイナリ互換性はない。

@item -m96bit-long-double
@itemx -m128bit-long-double
@opindex m96bit-long-double
@opindex m128bit-long-double
これらのスイッチは、@code{long double}型のサイズを制御する。x86-32アプリケーションのバイナリインタフェースでは、サイズを96ビットに指定しているため、32ビットモードではデフォルトで@option{-m96bit-long-double}が使用される。

最近のアーキテクチャー（Pentium以上）は、@code{long double}が8バイト境界または16バイト境界に整列させることを好む。ABIに準拠した配列や構造では、これは不可能である。したがって、@option {-m128bit-long-double}を指定すると、@code{long double}に追加の32ビットのゼロを埋め込むことで、@code{long double}を16バイト境界に揃える。

x86-64コンパイラでは、ABIが@code{long double}が16バイトの境界に揃うように指定するので、@option{-m128bit-long-double}がデフォルトの選択肢である。

これらのオプションのいずれも、@code{long double}の80ビットのx87標準に対する余分な精度を有効にしないことに注意せよ。

@strong{警告:} ターゲットABIのデフォルト値をオーバーライドすると、@code{long double}変数を含む構造体と配列のサイズが変更され、@code{long double}を持つ関数の関数呼び出し規約が変更される。 したがって、スイッチなしでコンパイルされたコードとバイナリ互換性はない。

@item -mlong-double-64
@itemx -mlong-double-80
@itemx -mlong-double-128
@opindex mlong-double-64
@opindex mlong-double-80
@opindex mlong-double-128
これらのスイッチは、@code{long double}型のサイズを制御する。 64ビットのサイズは、@code{long double}型を@code{double}型と等価にする。 これは、32ビットのBionic Cライブラリのデフォルトである。 128ビットのサイズは@code{long double}型を@code{__ float128}型と同等にする。 これは、64ビットのBionic Cライブラリのデフォルトである。

@strong{警告:} ターゲットABIのデフォルト値をオーバーライドすると、@code{long double}変数を含む構造体と配列のサイズが変更され、@code{long double}を持つ関数の関数呼び出し規約が変更される。 したがって、スイッチなしでコンパイルされたコードとバイナリ互換性はない。

@item -malign-data=@var{type}
@opindex malign-data
GCCがどのように変数を整列させるかを制御する。@var{type}のサポートされた値は、GCC 4.8以前で使用されている増加したアラインメント値互換性を使用さうる@samp{compat}、psABIで指定されたアライメント値を使用する@samp{abi}、キャッシュラインのサイズと一致するように増加したアラインメント値を使用する@samp{cacheline}である。@samp{compat}がデフォルトである。

@item -mlarge-data-threshold=@var{threshold}
@opindex mlarge-data-threshold
@option{-mcmodel=medium}を指定すると、@var{threshold}より大きいデータオブジェクトが大きなデータセクションに配置される。 この値は、バイナリにリンクされているすべてのオブジェクトで同じでなければならず、デフォルトは65535である。

@item -mrtd
@opindex mrtd
引数の数が固定されている関数が@code{ret @var {num}}命令で返される別の関数呼び出し規約を使用する。 これにより、引数をポップする必要がないため、呼び出し元に1つの命令が節約される。

関数の属性@code{stdcall}を使用して、この呼び出しシーケンスで個々の関数が呼び出されるように指定することができる。 また、関数属性@code{cdecl}を使用して@option{-mrtd}オプションを上書きすることもできる。 @xref{Function Attributes}.

@strong{警告:} この呼び出し規約はUnixで通常使用されているものと互換性がないため、Unixコンパイラでコンパイルされたライブラリを呼び出す必要がある場合は使用できない。

また、可変数の引数（@code{printf}を含む）をとるすべての関数の関数プロトタイプを提供する必要がある。 それ以外の場合は、それらの関数への呼び出しに対して誤ったコードが生成される。

さらに、あまりにも多くの引数を指定して関数を呼び出すと、コードが深刻に不正確になる。 （通常、余分な引数は無害に無視される。）

@item -mregparm=@var{num}
@opindex mregparm
整数引数を渡すために使用されるレジスタの数を制御する。 デフォルトでは、引数を渡すためにレジスタは使用されず、最大で3つのレジスタを使用できる。 関数の属性@code{regparm}を使用すると、特定の関数のこの動作を制御できる。@xref{Function Attributes}.

@strong{警告:} このスイッチを使用し、@var{num}がゼロ以外の場合は、ライブラリを含めて同じ値を持つすべてのモジュールを構築する必要がある。 これには、システムライブラリと起動モジュールが含まれる。

@item -msseregparm
@opindex msseregparm
floatとdoubleの引数と戻り値には、SSEのレジスタ渡し規則を使用する。 関数の属性@code{sseregparm}を使用すると、特定の関数のこの動作を制御できる。@xref{Function Attributes}.

@strong{警告:} このスイッチを使用する場合は、ライブラリを含め、同じ値を持つモジュールをすべてビルドする必要がある。 これには、システムライブラリと起動モジュールが含まれる。

@item -mvect8-ret-in-mem
@opindex mvect8-ret-in-mem
MMXレジスタの代わりに8バイトのベクトルをメモリに返します。 これは、Solaris@tie{}8および9とVxWorksでは、バージョン12まではSun StudioコンパイラのABIと一致するようにデフォルト設定されている。後のコンパイラバージョン（Studio 12 Update@tie{}1以降）は、他のx86ターゲットで使用されているABIに従う。これはSolaris 10以降のデフォルトである。以前のコンパイラバージョンまたは古いバージョンのGCCで作成された既存のコードとの互換性を保つ必要がある場合に@emph{のみ}、このオプションを使用すること。

@item -mpc32
@itemx -mpc64
@itemx -mpc80
@opindex mpc32
@opindex mpc64
@opindex mpc80

80387浮動小数点精度を32,64、または80ビットに設定する。@option{-mpc32}を指定すると、浮動小数点演算の結果の有効数字は24ビット（単精度）に丸められる。@option{-mpc64}は、浮動小数点演算の結果の有効数字を53ビット（倍精度）に丸め、@option{-mpc80}は浮動小数点演算の結果の有効数字を64ビット（拡張倍精度）に丸め、それがデフォルトである。このオプションを使用すると、FPU制御ワードを明示的に設定せずに、より高い精度での浮動小数点演算をプログラマが使用できなくなる。

浮動小数点演算の丸めをデフォルトの80ビット未満に設定すると、プログラムによっては2％以上の速度が得られることがある。いくつかの数学ライブラリは、拡張精度（80ビット）浮動小数点演算がデフォルトで有効になっていると仮定している。 このオプションを使用して精度を拡張精度以下に設定すると、このようなライブラリのルーチンは、通常、いわゆる「致命的な取り消し」を介して、精度の大幅な低下を被る可能性がある。

@item -mstackrealign
@opindex mstackrealign
入力時にスタックを再調整する。 x86では、@option{-mstackrealign}オプションは、必要に応じてランタイムスタックを再調整する代替のプロローグとエピローグを生成する。 これにより、SSE互換性のために16バイトのスタックアライメントを維持する最新のコードと4バイトのスタックアライメントを維持するレガシーコードの混在がサポートされる。 個々の関数に適用可能な属性@code{force_align_arg_pointer}も参照せよ。

@item -mpreferred-stack-boundary=@var{num}
@opindex mpreferred-stack-boundary
スタックの境界線を2の@var{num}乗バイト境界に合わせて整列させようとする。@option{-mpreferred-stack-boundary}が指定されていない場合、デフォルトは4（16バイトまたは128ビット）である。

@strong{警告:} SSE拡張機能を無効にしてx86-64アーキテクチャー用のコードを生成する場合、@option{-mpreferred-stack-boundary=3}を使用して、スタック境界を8バイト境界に揃えることができる。 x86-64 ABIは16バイトのスタックアライメントを必要とするため、ABIは互換性がなく、スタック領域が重要な制限である制御された環境で使用することを意図している このオプションは、16バイトのスタックアライメント（標準ライブラリの関数など）でコンパイルされた関数が、整列されていないスタックで呼び出されると、間違ったコードになる。 この場合、SSE命令は、不整合なメモリアクセストラップにつながる可能性がある。さらに、可変長引数は、16バイトの整列したオブジェクト（x87 long doubleと__int128を含む）に対して正しく処理されず、結果が正しくない。@option{-mpreferred-stack-boundary=3}（すべてのライブラリを含む）ですべてのモジュールをビルドする必要がある。 これには、システムライブラリと起動モジュールが含まれる。

@item -mincoming-stack-boundary=@var{num}
@opindex mincoming-stack-boundary
入ってくるスタックが2の@var {num}バイト乗の境界に揃えられていると仮定する。@option{-mincoming-stack-boundary}を指定しないと、@option{-mpreferred-stack-boundary}で指定されたものが使用される。

PentiumとPentium Proでは、@code{double}と@code{long double}の値は8バイトの境界（@option{-malign-double}を参照）に合わせるか、さもなければ実行時に大きなパフォーマンス上のペナルティを被る。Pentium IIIでは、Streaming SIMD Extension（SSE）のデータ型@code{__ m128}が16バイト境界でないと正しく動作しないことがある。

スタック上のこの値の適切なアライメントを確実にするためには、スタック境界は、スタックに格納された任意の値が必要とする値と同じ位置になければならない。さらに、スタックを整列させたままにするように、すべての関数を生成する必要がある。したがって、より望まれたスタック境界でコンパイルされた関数を、あまり望まれないスタック境界でコンパイルされた関数から呼び出すと、スタックの位置がずれてしまう可能性が最も高くなる。コールバックを使用するライブラリは、常にデフォルト設定を使用することが推奨される。

この余分な配置は、余分なスタックスペースを消費し、一般にコードサイズを増加させる。 組み込みシステムやオペレーティングシステムのカーネルなど、スタック領域の使用に敏感なコードは、優先されるアラインメントを@option{-mpreferred-stack-boundary=2}に減らしたい場合がある。

@need 200
@item -mmmx
@opindex mmmx
@need 200
@itemx -msse
@opindex msse
@need 200
@itemx -msse2
@opindex msse2
@need 200
@itemx -msse3
@opindex msse3
@need 200
@itemx -mssse3
@opindex mssse3
@need 200
@itemx -msse4
@opindex msse4
@need 200
@itemx -msse4a
@opindex msse4a
@need 200
@itemx -msse4.1
@opindex msse4.1
@need 200
@itemx -msse4.2
@opindex msse4.2
@need 200
@itemx -mavx
@opindex mavx
@need 200
@itemx -mavx2
@opindex mavx2
@need 200
@itemx -mavx512f
@opindex mavx512f
@need 200
@itemx -mavx512pf
@opindex mavx512pf
@need 200
@itemx -mavx512er
@opindex mavx512er
@need 200
@itemx -mavx512cd
@opindex mavx512cd
@need 200
@itemx -mavx512vl
@opindex mavx512vl
@need 200
@itemx -mavx512bw
@opindex mavx512bw
@need 200
@itemx -mavx512dq
@opindex mavx512dq
@need 200
@itemx -mavx512ifma
@opindex mavx512ifma
@need 200
@itemx -mavx512vbmi
@opindex mavx512vbmi
@need 200
@itemx -msha
@opindex msha
@need 200
@itemx -maes
@opindex maes
@need 200
@itemx -mpclmul
@opindex mpclmul
@need 200
@itemx -mclflushopt
@opindex mclflushopt
@need 200
@itemx -mfsgsbase
@opindex mfsgsbase
@need 200
@itemx -mrdrnd
@opindex mrdrnd
@need 200
@itemx -mf16c
@opindex mf16c
@need 200
@itemx -mfma
@opindex mfma
@need 200
@itemx -mpconfig
@opindex mpconfig
@need 200
@itemx -mwbnoinvd
@opindex mwbnoinvd
@need 200
@itemx -mfma4
@opindex mfma4
@need 200
@itemx -mprefetchwt1
@opindex mprefetchwt1
@need 200
@itemx -mxop
@opindex mxop
@need 200
@itemx -mlwp
@opindex mlwp
@need 200
@itemx -m3dnow
@opindex m3dnow
@need 200
@itemx -m3dnowa
@opindex m3dnowa
@need 200
@itemx -mpopcnt
@opindex mpopcnt
@need 200
@itemx -mabm
@opindex mabm
@need 200
@itemx -mbmi
@opindex mbmi
@need 200
@itemx -mbmi2
@need 200
@itemx -mlzcnt
@opindex mlzcnt
@need 200
@itemx -mfxsr
@opindex mfxsr
@need 200
@itemx -mxsave
@opindex mxsave
@need 200
@itemx -mxsaveopt
@opindex mxsaveopt
@need 200
@itemx -mxsavec
@opindex mxsavec
@need 200
@itemx -mxsaves
@opindex mxsaves
@need 200
@itemx -mrtm
@opindex mrtm
@need 200
@itemx -mtbm
@opindex mtbm
@need 200
@itemx -mmpx
@opindex mmpx
@need 200
@itemx -mmwaitx
@opindex mmwaitx
@need 200
@itemx -mclzero
@opindex mclzero
@need 200
@itemx -mpku
@opindex mpku
@need 200
@itemx -mavx512vbmi2
@opindex mavx512vbmi2
@need 200
@itemx -mgfni
@opindex mgfni
@need 200
@itemx -mvaes
@opindex mvaes
@need 200
@itemx -mvpclmulqdq
@opindex mvpclmulqdq
@need 200
@itemx -mavx512bitalg
@opindex mavx512bitalg
@need 200
@itemx -mmovdiri
@opindex mmovdiri
@need 200
@itemx -mmovdir64b
@opindex mmovdir64b
@need 200
@itemx -mavx512vpopcntdq
@opindex mavx512vpopcntdq
これらのスイッチを使用すると、MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, SHA, AES, PCLMUL, FSGSBASE, RDRND, F16C, FMA, SSE4A, FMA4, XOP, LWP, ABM,  AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, BMI, BMI2, VAES,
FXSR, XSAVE, XSAVEOPT, LZCNT, RTM, MPX, MWAITX, PKU, IBT, SHSTK, AVX512VBMI2,
GFNI, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B,
AVX512VPOPCNTDQ3DNow! または強化された3DNow！ 拡張命令セットでの命令の使用を有効にする。それぞれに対応する@option {-mno-}オプションがあり、これらの命令の使用を無効にする。

これらの拡張機能は、組み込み関数としても利用できる。これらのスイッチで有効または無効にする関数の詳細については、@ref{x86 Built-in Functions}を参照せよ。

浮動小数点コード（387命令ではなく）からSSE / SSE2命令を自動的に生成するには、@option{-mfpmath=sse}を参照せよ。

@option{-mavx}を使用するとGCCはSSEx命令を抑制する。 代わりに、必要に応じてすべてのSSEx命令に対して新しいAVX命令またはAVX等価を生成する。

これらのオプションは、GCCが@option{-mfpmath=sse}を使わなくても、生成されたコードでこれらの拡張命令を使用できるようにする。 ランタイムCPU検出を実行するアプリケーションは、適切なフラグを使用して、サポートされているアーキテクチャごとに個別のファイルをコンパイルする必要がある。 特に、CPU検出コードを含むファイルは、これらのオプションなしでコンパイルする必要がある。

@item -mdump-tune-features
@opindex mdump-tune-features
このオプションは、GCCにx86パフォーマンス調整機能の名前とデフォルト設定をダンプするよう指示する。 名前は@option{-mtune-ctrl=@var{feature-list}}で使用できる。

@item -mtune-ctrl=@var{feature-list}
@opindex mtune-ctrl=@var{feature-list}
このオプションは、x86コード生成機能の粒度を細かく制御するために使用される。@var{feature-list}はカンマで区切られた@var{feature}のリストである。@option{-mdump-tune-features}も参照せよ。これが指定されると、@var{feature}は@samp{^}の前になければオンになり、それ以外の場合にはオフになる。@option{-mtune-ctrl=@var{feature-list}}は、GCC開発者が使用するためのものである。これを使用すると、テストでカバーされないコードパスが発生し、コンパイラのICEまたは実行時エラーが発生する可能性がある。

@item -mno-default
@opindex mno-default
このオプションは、GCCにすべてのチューニング可能な機能をオフにするよう指示する。 @option{-mtune-ctrl=@var{feature-list}}と@option{-mdump-tune-features}も参照せよ。

@item -mcld
@opindex mcld
このオプションはGCCに文字列命令を使用する関数のプロローグで@code{cld}命令を出すよう指示する。文字列命令は、DFフラグに依存して、自動インクリメントモードまたは自動デクリメントモードを選択する。ABIは、関数入力時にDFフラグをクリアするよう指定しているが、一部のオペレーティングシステムでは、例外ディスパッチャでDFフラグをクリアしないため、この仕様に違反する。例外ハンドラは、DFフラグがセットされた状態で呼び出すことができる。これは、文字列命令が使用されているときに間違った方向モードにつながる。このオプションは、GCCをconfigureオプション@option{-enable-cld}で設定することで、デフォルトで32ビットx86ターゲットで有効にすることができる。@option{-mno-cld}コンパイラオプションを使用すると、@code{cld}命令の生成を抑止できる。

@item -mvzeroupper
@opindex mvzeroupper
このオプションは、AVXからSSEへの遷移ペナルティを最小限に抑え、不要な@code{zeroupper}組み込み関数を削除するために、関数から制御フローを転送する前にGCCに@code{vzeroupper}命令を発行するよう指示する。

@item -mprefer-avx128
@opindex mprefer-avx128
このオプションは、GCCに、自動ベクトル化器で256ビットAVX命令の代わりに128ビットAVX命令を使用するよう指示する。

@item -mprefer-vector-width=@var{opt}
@opindex mprefer-vector-width
This option instructs GCC to use @var{opt}-bit vector width in instructions
instead of default on the selected platform.

@table @samp
@item none
No extra limitations applied to GCC other than defined by the selected platform.

@item 128
Prefer 128-bit vector width for instructions.

@item 256
Prefer 256-bit vector width for instructions.

@item 512
Prefer 512-bit vector width for instructions.
@end table

@item -mcx16
@opindex mcx16
このオプションを使用すると、GCCは64ビットコードで@code{CMPXCHG16B}命令を生成して、16バイト整列128ビットオブジェクトに対して比較および交換操作を実装できる。これは、1つのマシンワードサイズを超えるデータ構造のアトミック更新に役立つ コンパイラはこの命令を使用して@ref{__ sync Builtins}を実装する。 しかし、128ビット整数で動作する@ref{__ Atomic Builtins}では、常にライブラリ呼び出しが使用される。

@item -msahf
@opindex msahf
このオプションを使用すると、64ビットコードで@code {SAHF}命令を生成できる。2005年12月のPentium 4 G1の導入に先立ち、インテル64をサポートしていた初期のインテルPentium 4 CPUは、AMD64でサポートされている@code{LAHF}と@code{SAHF}命令が欠けていた。これらは、それぞれ特定のステータスフラグのロードおよびストア命令である。64ビットモードでは、@code{fmod}、@code{drem}、および@code{remainder}組み込み関数を最適化するために@code{SAHF}命令が使用される。詳細は@ref {Other Builtins}を参照せよ。

@item -mmovbe
@opindex mmovbe
このオプションは@code{__ builtin_bswap32}と@code{__ builtin_bswap64}を実装するために@code{movbe}命令の使用を可能にする。

@item -mshstk
@opindex mshstk
The @option{-mshstk} option enables shadow stack built-in functions
from x86 Control-flow Enforcement Technology (CET).

@item -mcrc32
@opindex mcrc32
このオプションは組み込み関数@code{__ builtin_ia32_crc32qi}、@code{__ builtin_ia32_crc32hi}、@code{__ builtin_ia32_crc32si}、@code{__ builtin_ia32_crc32di}を使用して@code{crc32}機械命令をする。

@item -mrecip
@opindex mrecip
このオプションは、@code{DIVSS}の代わりに、精度を高めるために追加のNewton-Raphsonステップのある@code{RCPSS}命令と@code{RSQRTSS}命令（およびそのベクトル化された変形@code{RCPPS}と@code{RSQRTPS}と@code{SQRTSS}（およびそれらのベクトル化されたバリアント）を使用する。 これらの命令は、@option{-funsafe-math-optimizations}が@option{-ffinite-math-only}と@option{-fno-trapping-math}とともに有効になっている場合にのみ生成される。シーケンスのスループットは、非相反命令のスループットよりも高いが、シーケンスの精度は2 ulpまで減少することある（すなわち、1.0の逆数は0.99999994に等しい）ことに注意すること。

GCCは@option{-fast-math}ではすでに@code{RSQRTSS}（または@code{RSQRTPS}）の観点から@code {1.0f/sqrtf(@var{x})}を実装しているので、@option{-mrecip}は必要ないことに注意すること。

また、GCCは、既に@option{-ffast-math}（または上のオプションの組み合わせ）ではベクトル化された単精度浮動小数点数除算とベクトル化された@code{sqrtf(@var{x})}に対する追加のNewton-Raphsonステップ付きの上の列を生成するので、@option{-mrecip}は必要ないことに注意すること。

@item -mrecip=@var{opt}
@opindex mrecip=opt
このオプションは、どの逆数見積り命令を使用するかを制御する。 @var{opt}はコンマで区切られたオプションのリストである。オプションの前に@samp {!}を付けてオプションを反転することができる。

@table @samp
@item all
全推測命令を有効にする。

@item default
デフォルトの命令を有効にし、@option{-mrecip}と等価である。

@item none
全推測命令を無効にし、@option{-mno-recip}と等価である。

@item div
スカラー除算の近似を有効にする。

@item vec-div
ベクトル化除算の近似を有効にする。

@item sqrt
スカラー平方根の近似を有効にする。

@item vec-sqrt
ベクトル化平方根の近似を有効にする。
@end table
たとえば、@option{-mrecip=all, !sqrt}は、平方根を除き、すべての逆数近似を有効にする。

@item -mveclibabi=@var{type}
@opindex mveclibabi
外部ライブラリを使用して組み込み関数をベクトル化するために使用するABIタイプを指定する。 @var{type}にサポートされている値は、インテルの短いベクトル演算ライブラリの場合は@samp{svml}、AMD演算コアライブラリの場合は@samp{acml}である。このオプションを使用するには、@option{-ftree-vectorize}と@option{-funsafe-math-optimizations}の両方を有効にし、リンク時にSVMLまたはACML ABI互換ライブラリを指定する必要がある。

GCCは現在、@option {-mveclibabi = svml}が使用されているときは対応する関数型用の@code{vmldExp2}, @code{vmldLn2}, @code{vmldLog102}, @code{vmldLog102}, @code{vmldPow2}, @code{vmldTanh2}, @code{vmldTan2}, @code{vmldAtan2}, @code{vmldAtanh2}, @code{vmldCbrt2}, @code{vmldSinh2}, @code{vmldSin2}, @code{vmldAsinh2}, @code{vmldAsin2}, @code{vmldCosh2}, @code{vmldCos2}, @code{vmldAcosh2}, @code{vmldAcos2}, @code{vmlsExp4}, @code{vmlsLn4}, @code{vmlsLog104}, @code{vmlsLog104}, @code{vmlsPow4}, @code{vmlsTanh4}, @code{vmlsTan4}, @code{vmlsAtan4}, @code{vmlsAtanh4}, @code{vmlsCbrt4}, @code{vmlsSinh4}, @code{vmlsSin4}, @code{vmlsAsinh4}, @code{vmlsAsin4}, @code{vmlsCosh4}, @code{vmlsCos4}, @code{vmlsAcosh4}, @code{vmlsAcos4}への呼び出しを@option{-mveclibabi=svml}が使われたときに使い、@code{__vrd2_sin}, @code{__vrd2_cos}, @code{__vrd2_exp}, @code{__vrd2_log}, @code{__vrd2_log2},
@code{__vrd2_log10}, @code{__vrs4_sinf}, @code{__vrs4_cosf}, @code{__vrs4_expf}, @code{__vrs4_logf}, @code{__vrs4_log2f}, @code{__vrs4_log10f}, @code{__vrs4_powf}への対応する関数型用の呼び出しを、@option{-mveclibabi=acml}が使われたときに生成する。

@item -mabi=@var{name}
@opindex mabi
指定された呼び出し規約のコードを生成する。 GNU / Linuxなどのシステムで使用されるABIでは@samp{sysv}、Microsoft ABIでは@samp{ms}が許容値である。 デフォルトでは、Microsoft WindowsターゲットではMicrosoft ABIを使用し、他のすべてのシステムではSysV ABIを使う。関数の属性@code{ms_abi}と@code{sysv_abi}を使用すると、特定の関数のこの動作を制御できる。@xref{Function Attributes}.

@item -mforce-indirect-call
@opindex mforce-indirect-call
Force all calls to functions to be indirect. This is useful
when using Intel Processor Trace where it generates more precise timing
information for function calls.

@item -mcall-ms2sysv-xlogues
@opindex mcall-ms2sysv-xlogues
@opindex mno-call-ms2sysv-xlogues
Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a
System V ABI function must consider RSI, RDI and XMM6-15 as clobbered.  By
default, the code for saving and restoring these registers is emitted inline,
resulting in fairly lengthy prologues and epilogues.  Using
@option{-mcall-ms2sysv-xlogues} emits prologues and epilogues that
use stubs in the static portion of libgcc to perform these saves and restores,
thus reducing function size at the cost of a few extra instructions.

@item -mtls-dialect=@var{type}
@opindex mtls-dialect
@samp{gnu}または@samp{gnu2}の規則を使用してスレッドローカルストレージにアクセスするコードを生成する。 @samp{gnu}は控えめなデフォルトである。 @samp{gnu2}はより効率的だが、すべてのシステムで満たすことができないコンパイルおよび実行時の要件が追加される可能性がある。

@item -mpush-args
@itemx -mno-push-args
@opindex mpush-args
@opindex mno-push-args
PUSH操作を使用して、送信パラメータを格納する。 この方法は、SUB / MOV操作を使用するメソッドよりも短く、通常は同等に高速で、既定で有効になっている。 ある場合にはこれを向こうにすることでスケジューリングが改善され、依存関係が減少するため、パフォーマンスを向上させる場合がある。

@item -maccumulate-outgoing-args
@opindex maccumulate-outgoing-args
有効な場合、発信引数に必要な最大容量が関数プロローグで計算される。 これは、望まれるスタック境界が2に等しくない場合、依存性の減少、スケジューリングの改善、およびスタック使用率の低下のために、最新のCPUでは高速である。欠点はコードサイズが著しく増加することである。 このスイッチは、@option{-mno-push-args}を含む。

@item -mthreads
@opindex mthreads
MinGWでスレッドセーフな例外処理をサポートする。 スレッドセーフな例外処理に依存するプログラムは、すべてのコードをコンパイルし、@option{-mthreads}オプションでリンクする必要がある。 コンパイル時に、@option{-mthreads}は@option{-D_MT}を定義する。 リンクすると、スレッドごとの例外処理データをクリーンアップする特別なスレッドヘルパーライブラリ@option{-lmingwthrd}にリンクする。

@item -mms-bitfields
@itemx -mno-ms-bitfields
@opindex mms-bitfields
@opindex mno-ms-bitfields

ネイティブMicrosoft Windowsコンパイラと互換性のあるビットフィールドレイアウトを有効/無効にする。

構造体で@code{packed}が使用されている場合、またはビットフィールドが使用されている場合は、Microsoft ABIがGCCの通常の方法とは異なる構造をレイアウトしている可能性がある。 特に、GCCでコンパイルされた関数とネイティブのMicrosoftコンパイラ（関数呼び出しまたはファイル内のデータ）の間でパックされたデータを移動する場合は、どちらの形式にもアクセスする必要がある。

このオプションは、Microsoft Windowsターゲットではデフォルトで有効になっている。 この動作は、変数または型の属性を使用してローカルで制御することもできる。さらなる情報は、@ref{x86 Variable Attributes}と@ref{x86 Type Attributes}.

Microsoftの構造レイアウトアルゴリズムは、ビットフィールドパッキングを除いてかなり簡単である。構造体のメンバーのパディングとアライメント、およびビットフィールドがストレージユニットの境界をまたぐことができるかどうかは、次の規則によって決定される。

@enumerate
@item 構造体のメンバーは宣言された順番で順番に格納される。最初のメンバは最低のメモリアドレスを持ち、最後のメンバは最高のものを持つ。

@item すべてのデータオブジェクトにアラインメント要件がある。 構造体、共用体、および配列を除くすべてのデータの配置要件は、オブジェクトのサイズか、現在のパッキングサイズ（@code{aligned}属性または@code{pack}プラグマで指定）のいずれか小さい方である。 構造体、共用体、および配列の場合、配置要件は、そのメンバーの最大の配置要件である。すべてのオブジェクトには次のようにオフセットが割り当てられる。

@smallexample
offset % alignment_requirement == 0
@end smallexample

@item 整数型が同じサイズで、次のビットフィールドがビットフィールドの共通アラインメント要件によって課せられた境界を横切ることなく現在の割り当て単位に適合するならば、隣接するビットフィールドは同じ1バイト、2バイト、または4バイトの割り当て単位にパックされる 。
@end enumerate

MSVCは、次のようにゼロ長のビットフィールドを解釈する。

@enumerate
@item 通常合体された2つのビットフィールドの間に長さゼロのビットフィールドが挿入されている場合、ビットフィールドは結合されない。例えば：

@smallexample
struct
 @{
   unsigned long bf_1 : 12;
   unsigned long : 0;
   unsigned long bf_2 : 12;
 @} t1;
@end smallexample

@noindent
@code{t1}のサイズは、長さ0のビットフィールドを持つ8バイトである。 長さゼロのビットフィールドが削除された場合、@code{t1}のサイズは4バイトになる。

@item ビットフィールド@code{foo}の後に長さゼロのビットフィールドが挿入され、長さがゼロのビットフィールドの配置がそれに続くメンバーより大きい場合、@code{bar}、@code{bar}は、長さゼロのビットフィールドのタイプとして整列される。

For example:

@smallexample
struct
 @{
   char foo : 4;
   short : 0;
   char bar;
 @} t2;

struct
 @{
   char foo : 4;
   short : 0;
   double bar;
 @} t3;
@end smallexample

@noindent
@code{t2}では、@code{bar}はオフセット1ではなくオフセット2に配置される。したがって、@code{t2}のサイズは4である。@code{t3}では、長さゼロのビットフィールドは@code{bar}のアライメントや構造体のサイズに影響しない。

これを考慮すると、次の点に注意することが重要である。

@enumerate
@item ゼロ長のビットフィールドが通常のビットフィールドの後に続く場合、ゼロ長のビットフィールドのタイプは構造全体のアライメントに影響を与える可能性がある。 たとえば、@code{t2}は4バイトのサイズを持つ。なぜなら、長さゼロのビットフィールドは通常のビットフィールドの後ろにあり、short型であるからである。

@item 長さ0のビットフィールドの後に通常のビットフィールドが続くことがない場合でも、構造の配置にはまだ影響を与える可能性がある：

@smallexample
struct
 @{
   char foo : 6;
   long : 0;
 @} t4;
@end smallexample

@noindent
ここで、@code {t4}は4バイトを占める。
@end enumerate

@item 非ビットフィールドメンバに続くゼロ長ビットフィールドは無視される。

@smallexample
struct
 @{
   char foo;
   long : 0;
   char bar;
 @} t5;
@end smallexample

@noindent
ここで、@code {t5}は2バイトを占める。
@end enumerate


@item -mno-align-stringops
@opindex mno-align-stringops
インライン文字列操作の宛先を揃えない。 このスイッチは、宛先が既に整列されている場合にコードサイズを減らし、パフォーマンスを向上させるが、GCCはそれを知らない。

@item -minline-all-stringops
@opindex minline-all-stringops
デフォルトでは、GCCは、宛先が少なくとも4バイトの境界に位置合わせされていることがわかっている場合にのみ文字列操作をインライン化する。これにより、より多くのインライン化が可能になり、コードサイズは増加するが、短縮された長さの@code{memcpy}、@code{strlen}、@code{memset}に依存するコードのパフォーマンスが向上する可能性がある。

@item -minline-stringops-dynamically
@opindex minline-stringops-dynamically
不明なサイズの文字列操作では、小さなブロックのインラインコードと大きなブロックのライブラリ呼び出しを含む実行時検査を使用する。

@item -mstringop-strategy=@var{alg}
@opindex mstringop-strategy=@var{alg}
文字列操作のインライン化に使用する特定のアルゴリズムの内部決定ヒューリスティックをオーバーライドする。 @var{alg}に許される値は次のとおりである：

@table @samp
@item rep_byte
@itemx rep_4byte
@itemx rep_8byte
指定したサイズのi386接頭辞@code {rep}を使用して展開する。

@item byte_loop
@itemx loop
@itemx unrolled_loop
インラインループに展開する。

@item libcall
常にライブラリ呼び出しを使用する。
@end table

@item -mmemcpy-strategy=@var{strategy}
@opindex mmemcpy-strategy=@var{strategy}
@code{__ builtin_memcpy}をインライン化するかどうかを、コピー操作の予想されるサイズがわかっているときに使用するインラインアルゴリズムを決定するための、内部決定のヒューリスティックをオーバーライドする。 @var{strategy}は@var{alg}:@var{max_size}:@var{dest_align}の三つ組のコンマで区切られたリストである。@var{alg}は@option{-mstringop-strategy}で指定され、@var{max_size}はインラインアルゴリズム@var{alg}が許可される最大バイトサイズを指定する。 最後のトリプレットの場合、@var{max_size}は@code{-1}でなければならない。 リスト内のトリプレットの@var{max_size}は、昇順で指定する必要がある。 @var{alg}の最小バイトサイズは、最初のトリプレットの場合は@code{0}、前の範囲の@code{@var{max_size}+1}である。

@item -mmemset-strategy=@var{strategy}
@opindex mmemset-strategy=@var{strategy}
このオプションは@code{__ builtin_memset}拡張を制御する以外は@option{-mmemcpy-strategy=}と似ている。

@item -momit-leaf-frame-pointer
@opindex momit-leaf-frame-pointer
リーフ機能用のレジスタにフレームポインタを保持しない。 これにより、命令がフレームポインタのセーブ、セットアップ、および復元を回避し、リーフ機能で余分なレジスタを利用できるようになる。 オプション@option{-fomit-leaf-frame-pointer}は、リーフ関数のフレームポインタを削除する。これにより、デバッグが難しくなる可能性がある。

@item -mtls-direct-seg-refs
@itemx -mno-tls-direct-seg-refs
@opindex mtls-direct-seg-refs
TLSセグメントレジスタ（32ビットの場合は@code{％gs}、64ビットの場合は@code{％fs}）からのオフセットを使用してTLS変数にアクセスできるかどうか、スレッドベースポインタを追加する必要があるかどうかを制御する。 これが有効かどうかは、オペレーティングシステムによって異なり、TLSエリア全体をカバーするようにセグメントをマップするかどうかによって異なる。

GNU Cライブラリを使用するシステムの場合、デフォルトはオンである。

@item -msse2avx
@itemx -mno-sse2avx
@opindex msse2avx
アセンブラがVEX接頭辞付きSSE命令をエンコードするように指定する。 @option{-mavx}オプションは、デフォルトでこれを有効にする。

@item -mfentry
@itemx -mno-fentry
@opindex mfentry
プロファイリングがアクティブな場合（@option{-pg}）、プロファイリングカウンタの呼び出しをプロローグの前に置く。
注：x86アーキテクチャでは、@option{-mfentry}と@option{-pg}の属性@code {ms_hook_prologue}は現時点では不可能である。

@item -mrecord-mcount
@itemx -mno-record-mcount
@opindex mrecord-mcount
プロファイリングがアクティブな場合（@option{-pg}）、各プロファイリングコールへのポインタを含む__mcount_locセクションを生成する。 これは、自動的にパッチを当てたり、呼び出しを外したりする場合に便利である。

@item -mnop-mcount
@itemx -mno-nop-mcount
@opindex mnop-mcount
プロファイリングがアクティブな場合（@option{-pg}）、プロファイリング関数への呼び出しをNOPとして生成する。 これは、あとで動的にパッチを適用する必要がある場合に便利である。 これはおそらく@option{-mrecord-mcount}と一緒に使うと便利である。

@item -mskip-rax-setup
@itemx -mno-skip-rax-setup
@opindex mskip-rax-setup
SSE拡張機能を無効にしてx86-64アーキテクチャ用のコードを生成するとき、可変引数がベクタレジスタに渡されていないときは、@option{-mskip-rax-setup}を使用してRAXレジスタの設定をスキップできる。

@strong{警告:} RAXレジスタは、可変引数を渡すときにスタック上のベクトルレジスタを不必要に節約するのを避けるために使用されるため、呼び出し先がスタックスペースを無駄にしたり、ランダムな場所にジャンプしたりする可能性がある。 GCC 4.4以降には、RAXレジスタの値に関係なく、これらの問題はない。

@item -m8bit-idiv
@itemx -mno-8bit-idiv
@opindex m8bit-idiv
Intel Atomのような一部のプロセッサでは、8ビット符号なし整数除算は32ビット/ 64ビット整数除算よりもはるかに高速である。 このオプションは、実行時チェックを生成する。 被除数と除数の両方が0〜255の範囲内にある場合、32ビット/ 64ビット整数除算の代わりに8ビット符号なし整数除算が使用される。

@item -mavx256-split-unaligned-load
@itemx -mavx256-split-unaligned-store
@opindex mavx256-split-unaligned-load
@opindex mavx256-split-unaligned-store
32バイトのAVXのアラインメントされていないロードとストアを分割する。

@item -mstack-protector-guard=@var{guard}
@itemx -mstack-protector-guard-reg=@var{reg}
@itemx -mstack-protector-guard-offset=@var{offset}
@opindex mstack-protector-guard
@opindex mstack-protector-guard-reg
@opindex mstack-protector-guard-offset
@var{guard}にカナリアを使用してスタック保護コードを生成する。サポートされている場所は、グローバルカナリアの@samp{global}およびTLSブロック内のスレッドカナリア（デフォルト）の@samp{tls}である。このオプションは、@option{-fstack-protector}または@option{-fstack-protector-all}が指定されている場合にのみ有効である。

後者の選択肢では、オプション@option{-mstack-protector-guard-reg=@var{reg}}と@option{-mstack-protector-guard-offset=@var{offset}}カナリアを読み込むためのベース・レジスタとして、またそのベース・レジスタからのオフセットから使用するために、@code{%fs}または@code{％gs}を使用する。 これらのデフォルトは、関連するABIで指定されている。

@item -mmitigate-rop
@opindex mmitigate-rop
意図しないリターンオペコードを含むコードシーケンスを生成しないようにして、特定の攻撃の形態を緩和する。 現時点では、このオプションはできることで制限されていて、重大な保護を提供するためには信頼されるべきではない。

@item -mgeneral-regs-only
@opindex mgeneral-regs-only
汎用レジスタのみを使用するコードを生成する。 これにより、コンパイラは浮動小数点、ベクトル、マスク、およびバウンドレジスタを使用できなくなる。

@end table

上記に加えて、これらの@samp {-m}スイッチは、64ビット環境のx86-64プロセッサ上でサポートされている。

@table @gcctabopt
@item -m32
@itemx -m64
@itemx -mx32
@itemx -m16
@itemx -miamcu
@opindex m32
@opindex m64
@opindex mx32
@opindex m16
@opindex miamcu
16ビット、32ビット、または64ビット環境用のコードを生成する。@option{-m32}オプションは、@code {int}、@code{long}、およびポインタ型を32ビットに設定し、任意のi386システムで実行されるコードを生成する。

@option{-m64}オプションは、@code{int}を32ビットに、@code{long}とポインタ型を64ビットに設定し、x86-64アーキテクチャ用のコードを生成する。Darwinの場合、@option{-m64}オプションは@option{-fno-pic}と@option{-mdynamic-no-pic}オプションも無効にする。

@option{-mx32}オプションは、@code{int}、@code{long}、ポインタ型を32ビットに設定し、x86-64アーキテクチャ用のコードを生成する。

@option{-m16}オプションは@option{-m32}と同じだが、アセンブリ出力の先頭に@code{.code16gcc}アセンブリディレクティブを出力し、バイナリを16ビットモードで実行できるようにする 。

@option{-miamcu}オプションはIntel MCU psABIに準拠したコードを生成する。 @option{-m32}オプションをオンにする必要がある。

@item -mno-red-zone
@opindex mno-red-zone
x86-64コードで、いわゆる「レッドゾーン」を使用しない。レッドゾーンは、x86-64 ABIによって必須であり、シグナルによって変更されないスタックポインタの場所を超える128バイトの領域である。@option{-mno-red-zone}フラグは、このレッドゾーンを無効にする。

@item -mcmodel=small
@opindex mcmodel=small
小さなコードモデル用のコードを生成する：プログラムとそのシンボルは、アドレス空間の下位2 GBにリンクされている必要がある。 ポインタは64ビットである。プログラムは静的または動的にリンクできる。 これがデフォルトコードモデルである。

@item -mcmodel=kernel
@opindex mcmodel=kernel
カーネルコードモデル用のコードを生成する。 カーネルは負の2 GBのアドレス空間で動作する。 このモデルは、Linuxのカーネルコードで使用する必要がある。

@item -mcmodel=medium
@opindex mcmodel=medium
中間モデル用のコードを生成する。プログラムはアドレス空間の下位2GBにリンクされる。 小さなシンボルもそこに配置される。 @option{-mlarge-data-threshold}より大きいサイズのシンボルは、大量のデータまたはBSSセクションに格納され、2GBを超える場所に配置できる。 プログラムは静的または動的にリンクできる。

@item -mcmodel=large
@opindex mcmodel=large
大型モデル用のコードを生成する。 このモデルでは、セクションのアドレスとサイズについて前提はない。

@item -maddress-mode=long
@opindex maddress-mode=long
ロングアドレスモード用のコードを生成する。 これは、64ビットおよびx32環境でのみサポートされている。 これは、64ビット環境のデフォルトアドレスモードである。

@item -maddress-mode=short
@opindex maddress-mode=short
ショートアドレスモード用のコードを生成する。 これは、32ビットおよびx32環境でのみサポートされている。 これは、32ビットおよびx32環境のデフォルトアドレスモードである。
@end table

@node x86 Windows Options
@subsection x86 Windows オプション
@cindex x86 Windows Options
@cindex Windows Options for x86

これらの追加オプションは、Microsoft Windowsターゲットで使用できる。

@table @gcctabopt
@item -mconsole
@opindex mconsole
このオプションは、コンソールアプリケーションに必要なPEヘッダーサブシステムタイプをリンカーに設定するように指示することによって、コンソールアプリケーションを生成することを指定する。このオプションは、CygwinおよびMinGWターゲットで使用でき、デフォルトでこれらのターゲットで有効になっている。

@item -mdll
@opindex mdll
このオプションは、CygwinおよびMinGWターゲットで使用できる。 DLL ---ダイナミックリンクライブラリ---を生成し、必要なランタイムスタートアップオブジェクトとエントリポイントの選択を可能にすることを指定する。

@item -mnop-fun-dllimport
@opindex mnop-fun-dllimport
このオプションは、CygwinおよびMinGWターゲットで使用できる。 @code{dllimport}属性を無視することを指定する。

@item -mthread
@opindex mthread
このオプションは、MinGWターゲットで使用できる。 MinGW固有のスレッドサポートが使用されることを指定する。

@item -municode
@opindex municode
このオプションは、MinGW-w64ターゲットで使用できる。 @code{UNICODE}プリプロセッサマクロがあらかじめ定義され、Unicode対応のランタイムスタートアップコードが選択される。

@item -mwin32
@opindex mwin32
このオプションは、CygwinおよびMinGWターゲットで使用できる。 これは、典型的なMicrosoft Windowsの事前定義マクロをプリプロセッサに設定することを指定するが、実行時ライブラリ/起動コードの選択には影響しない。

@item -mwindows
@opindex mwindows
このオプションは、CygwinおよびMinGWターゲットで使用できる。 リンカーにPEヘッダーサブシステムタイプを適切に設定するように指示することによって、GUIアプリケーションを生成することを指定する。

@item -fno-set-stack-executable
@opindex fno-set-stack-executable
このオプションは、MinGWターゲットで使用できる。 ネストされた関数によって使用されるスタックの実行可能フラグが設定されていないことを指定する。 これは、実行可能な特権を設定するために使用されるUser32 APIが利用できないため、Microsoft Windowsのカーネルモードで実行されるバイナリに必要である。

@item -fwritable-relocated-rdata
@opindex fno-writable-relocated-rdata
このオプションは、MinGWおよびCygwinターゲットで使用できる。 読み取り専用セクションの再配置されたデータが@code{.data}セクションに置かれることを指定する。 これは、擬似再配置のための@code{.rdata}セクションの変更をサポートしていない古いランタイムには必要である。

@item -mpe-aligned-commons
@opindex mpe-aligned-commons
このオプションは、CygwinおよびMinGWターゲットで使用できる。 これは、コードを生成する際に、COMMON変数の正しい整列を可能にするPEファイル形式へのGNU拡張を使用することを指定する。 設定中に見つかったターゲットアセンブラがこの機能をサポートしていることをGCCが検出すると、デフォルトで有効になる。
@end table

標準オプションについては、@ref {x86 Options}も参照せよ。

@node Xstormy16 Options
@subsection Xstormy16オプション
@cindex Xstormy16 Options

これらのオプションはXstormy16で定義されている：

@table @gcctabopt
@item -msim
@opindex msim
シミュレータに適した起動ファイルとリンカスクリプトを選択する。
@end table

@node Xtensa Options
@subsection Xtensaオプション
@cindex Xtensa Options

これらのオプションは、Xtensaターゲットでサポートされている。

@table @gcctabopt
@item -mconst16
@itemx -mno-const16
@opindex mconst16
@opindex mno-const16
定数値をロードするための@code{CONST16}命令の使用を有効または無効にする。 @code{CONST16}命令は現在、Tensilicaの標準オプションではない。 有効にすると、標準の@code{L32R}命令の代わりに@code{CONST16}命令が常に使用される。 @code{L32R}命令が利用できない場合に限り、@code{CONST16}の使用はデフォルトで有効になる。

@item -mfused-madd
@itemx -mno-fused-madd
@opindex mfused-madd
@opindex mno-fused-madd
浮動小数点オプションで、融合乗算/加算および乗算/減算命令の使用を有効または無効にする。 浮動小数点オプションも有効になっていない場合は、これは無効である。 融合乗算/加算および乗算/減算命令を無効にすると、コンパイラは乗算演算および加算/減算演算に別々の命令を使用する。これは、厳密なIEEE 754準拠の結果が必要な場合に望ましい場合がある。融合乗算加算/減算命令は中間結果を丸めないため、IEEE標準で指定された精度よりも@emph{多い}ビットの精度で結果を生成する。また、積和加算/減算命令を無効にすることで、プログラムの出力が、乗算と加算/減算の演算を組み合わせるコンパイラの能力に影響されないことが保証される。

@item -mserialize-volatile
@itemx -mno-serialize-volatile
@opindex mserialize-volatile
@opindex mno-serialize-volatile
このオプションを有効にすると、GCCはシーケンシャル一貫性を保証するために@code{MEMW}命令を@code{volatile}メモリ参照の前に挿入する。デフォルトは@option{-mserialize-volatile}である。@code{MEMW}命令を省略するには、@option{-mno-serialize-volatile}を使用する。

@item -mforce-no-pic
@opindex mforce-no-pic
GNU/Linuxのようなターゲット用に、すべてのユーザモードXtensaコードが位置独立コード（PIC）でなければならない場合、このオプションはカーネルコードをコンパイルするためにPICを無効にする。

@item -mtext-section-literals
@itemx -mno-text-section-literals
@opindex mtext-section-literals
@opindex mno-text-section-literals
これらのオプションは、リテラルプールの処理を制御する。 デフォルトは@option{-mno-text-section-literals}で、リテラルは出力ファイルの別のセクションに配置される。 これにより、リテラルプールをデータRAM/ROMに配置することができる。また、リンカーは別々のオブジェクトファイルからのリテラルプールを結合してリテラルを削除し、コードサイズを改善することもできる。 @option{-mtext-section-literals}では、リテラルはテキストセクションに散在して、できるだけそれらの参照にできるだけ近づける。 これは、大規模なアセンブリファイルに必要な場合がある。 各関数のリテラルは、その関数の直前に配置される。

@item -mauto-litpools
@itemx -mno-auto-litpools
@opindex mauto-litpools
@opindex mno-auto-litpools
これらのオプションは、リテラルプールの処理を制御する。デフォルトは@option{-mno-auto-litpools}で、@option{-mtext-section-literals}が使われていない限り、リテラルを出力ファイルの別のセクションに置く。 @option{-mauto-litpools}を使用すると、リテラルはアセンブラによってテキストセクションに散在する。コンパイラは明示的な@code {.literal}指令を生成せず、アセンブラが緩和を行い、必要に応じてリテラルを置くために@code{L32R}ではなく@code{MOVI}命令でレジスタにリテラルをロードする。このオプションを使用すると、アセンブラは関数ごとに複数のリテラルプールを作成し、@option{-mtext-section-literals}では不可能な非常に大きな関数をアセンブルすることができる。

@item -mtarget-align
@itemx -mno-target-align
@opindex mtarget-align
@opindex mno-target-align
このオプションを有効にすると、GCCはコード密度を犠牲にして分岐ペナルティを減らすために命令を自動的に整列させるようにアセンブラに指示する。アセンブラは、分岐命令と呼び出し命令に続く命令を整列させるために密度命令を拡張しようとする。 ターゲットを整列させるのに先行する安全密度命令が十分でない場合、拡幅は行われない。デフォルトは@option{-mtarget-align}である。 これらのオプションは、@code{LOOP}のようなオートアライメントされた命令の処理には影響しない。アセンブラは、密度命令を広げたり、NOP命令を挿入したりして、常に整列する。

@item -mlongcalls
@itemx -mno-longcalls
@opindex mlongcalls
@opindex mno-longcalls
このオプションを有効にすると、GCCはダイレクトコールのターゲットがコール命令で許可された範囲内にあると判断できない限り、ダイレクトコールを間接呼び出しに変換するようにアセンブラに指示する。この変換は、通常、他のソースファイル内の関数への呼び出しで発生する。 具体的には、アセンブラは直接@code{CALL}命令を@code{L32R}と@code{CALLX}命令に変換する。デフォルトは@option{-mno-longcalls}である。このオプションは、コールターゲットが潜在的に範囲外になる可能性のあるプログラムで使用する必要がある。このオプションはコンパイラではなくアセンブラで実装されているので、GCCによって生成されたアセンブリコードはダイレクトコール命令を表示する。実際の命令を見るために逆アセンブルされたオブジェクトコードを見ること。アセンブラは、本当に範囲外のものだけでなく、クロスファイルコールごとに間接呼び出しを使用することに注意せよ。
@end table

@node zSeries Options
@subsection zSeriesオプション
@cindex zSeries options

@xref{S/390 and zSeries Options}でリストされている。


@c man end

@node Spec Files
@section サブプロセスとスイッチを指定してそれらに渡す
@cindex Spec Files

@command{gcc}はドライバプログラムである。 コンパイル、アセンブル、およびリンクの作業を行うために、他のプログラムのシーケンスを呼び出すことによって、そのジョブを実行する。 GCCはコマンドラインパラメータを解釈し、どのプログラムを呼び出すべきか、そしてコマンドラインにどのコマンドラインオプションを置くべきかを推測するためにこれらのパラメータを使用する。この動作は@dfn{spec strings}（仕様文字列）によって制御される。 ほとんどの場合、GCCが呼び出すことができるプログラムごとに1つの仕様文字列があるが、いくつかのプログラムでは、その動作を制御する複数の仕様文字列がありる。 GCCに組み込まれている仕様文字列は、@option{-specs=}コマンドラインスイッチを使用して仕様ファイルを指定することで上書きすることができる。

@dfn{Spec files}（仕様ファイル）は、仕様文字列の作成に使用されるプレーンテキストファイルである。それらは空白行で区切られた一連のディレクティブで構成されている。  ディレクティブのタイプは、行の最初の非空白文字によって決まる。次のいずれかになる。

@table @code
@item %@var{command}
@var{command}を仕様ファイル・プロセッサーに発行する。 ここに表示されるコマンドは次のとおりである。

@table @code
@item %include <@var{file}>
@cindex @code{%include}
@var{file}を検索し、仕様ファイルの現在の点にテキストを挿入します。

@item %include_noerr <@var{file}>
@cindex @code{%include_noerr}
@samp{％include}と似ていますが、インクルードファイルが見つからない場合はエラーメッセージを生成しない。

@item %rename @var{old_name} @var{new_name}
@cindex @code{%rename}
@var{old_name}を@var{new_name}に変更する。

@end table

@item *[@var{spec_name}]:
これは、指定されたspec文字列を作成、上書き、または削除するようにコンパイラに指示する。このディレクティブの次のディレクティブまたは空白行までのすべての行は、仕様文字列のテキストとみなされる。この結果が空の文字列の場合、仕様は削除される。 （または、仕様が存在しない場合、何も起こらない。）それ以外の場合、仕様が現在存在しない場合は、新しい仕様が作成される。仕様が存在する場合、その内容は、このテキストの最初の文字が@samp{+}文字でない限り、このディレクティブのテキストによって上書きされる。この場合、テキストは仕様に追加される。

@item [@var{suffix}]:
新しい@samp{[@var{suffix}] spec}のペアを作成する。このディレクティブの後の次のディレクティブまたは空白行までのすべての行は、指定されたサフィックスの仕様文字列を構成すると見なされる。コンパイラが名前付きサフィックスを持つ入力ファイルを検出すると、そのファイルをコンパイルする方法を理解するために仕様文字列を処理する。 例えば：

@smallexample
.ZZ:
z-compile -input %i
@end smallexample

これは、名前が@samp{.ZZ}で終わる入力ファイルは@samp{z-compile}プログラムに渡されなければならず、これはコマンドラインスイッチ@option{-input}と結果@samp {％i}置換を実行する。 （下記参照。）

仕様文字列を提供する代わりに、接尾辞ディレクティブに続くテキストは、次のいずれかになる。

@table @code
@item @@@var{language}
これは、接尾辞が既知の@var{language}のエイリアスであることを示している。 これは、GCCへの@option{-x}コマンドラインスイッチを使用して明示的に言語を指定するのと同様である。 例えば：

@smallexample
.ZZ:
@@c++
@end smallexample

ZZファイルは実際にはC ++ソースファイルだと言う。

@item #@var{name}
これにより、次のようなエラーメッセージが表示される。

@smallexample
@var{name} compiler not installed on this system.
@end smallexample
@end table

GCCは既にそれに組み込まれているサフィックスの広範なリストを持っている。このディレクティブは、接尾辞のリストの最後にエントリを追加するが、リストは末尾から検索されるため、この手法を使用して以前のエントリをオーバーライドすることは事実上可能である。

@end table

GCCには、以下の仕様文字列が組み込まれている。 仕様ファイルはこれらの文字列を無効にするか、独自のファイルを作成できる。 個々のターゲットは、独自の仕様文字列をこのリストに追加することもできる。

@smallexample
asm          アセンブラに渡されるオプション
asm_final    アセンブラの後処理に渡されるオプション
cpp          Cプリプロセッサに渡されるオプション
cc1          Cコンパイラに渡されるオプション
cc1plus      C++コンパイラに渡されるオプション
endfile      リンクの終わりで入れるオブジェクトファイル
link         ランカに渡されるオプション
lib          リンカにコマンドラインで入れるライブラリ
libgcc       リンカに渡すGCCサポートライブラリを決定する
linker       リンカの名前を設定する
predefines   Cプリプロセッサへ渡すために定義される
signed_char  CPPにデフォルトで@code{char}が符号付きかどうかを決定するために渡すために定義する
startfile    リンクの初めで入れるオブジェクトファイル
@end smallexample

ここに仕様ファイルの小さい例がある。

@smallexample
%rename lib                 old_lib

*lib:
--start-group -lgcc -lc -leval1 --end-group %(old_lib)
@end smallexample

この例では、@samp{lib}という名前を@samp{old_lib}という名前に変更し、以前の@samp{lib}の定義を新しいもので上書きする。新しい定義では、古い定義のテキストを含める前にいくつかの余分なコマンドラインオプションが追加されている。

@dfn{Spec strings}（仕様文字列）は、対応するプログラムに渡すコマンドラインオプションのリストである。  さらに、仕様文字列には、可変テキストを置換するため、または条件付きでテキストをコマンドラインに挿入するための@samp{％}-接頭辞付きのシーケンスを含めることができる。 これらの構文を使用すると、非常に複雑なコマンドラインを生成することができる。

ここに仕様文字列のすべての定義済みの@samp{％}-シーケンスのテーブルがある。これらのシーケンスを展開した結果の周りにスペースは自動的に生成されないことに注意せよ。したがって、それらを連結したり、単一の引数で定数テキストと組み合わせることができる。

@table @code
@item %%
@samp{％}をプログラム名または引数に置き換える。

@item %i
処理中の入力ファイルの名前に置き換える。

@item %b
処理中の入力ファイルの基本名を置き換える。これは、最後のピリオドまで（ディレクトリは含まず）の部分文字列である。

@item %B
これは@samp{％b}と同じだが、ファイルサフィックス（最後の後のテキスト）を含む。

@item %d
@samp{％d}を含むかそれに続く引数を一時ファイル名としてマークし、GCCが正常に終了するとそのファイルが削除されるようにする。 @samp{％g}とは異なり、これは引数にテキストを与えない。

@item %g@var{suffix}
@var{接尾辞}という接尾辞を持ち、コンパイルごとに一度選択されるファイル名に置き換え、@samp{％d}と同じ方法で引数に印を付ける。サービス拒否攻撃に対する被害を軽減するため、以前に選択したファイル名が判明しても予測が困難な方法でファイル名が選択されるようになった。 たとえば、@samp{％g.s @dots{}％g.o @dots{}％g.s} @samp {ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s}に変わる可能性がある。 @var{suffix}は正規表現@samp{[.A-Za-z]*}や特殊文字列@samp{％O}にマッチする。これは@samp{％O}が前処理されたのとまったく同じように扱われる。以前は@samp{％g}は、コンパイルごとに一度選択されたファイル名で置き換えられていた。そのため、通常のテキストと同様に処理されていたため、そのような攻撃は成功する可能性が高くなっていた。

@item %u@var{suffix}
@samp{％g}に似ているが、コンパイルごとに1回ではなく、現れるごとに毎回新しい一時ファイル名が生成される。

@item %U@var{suffix}
@samp{％u@var{suffix}}で生成された最後のファイル名を置き換える。最後のファイル名がない場合は新しいファイル名を生成する。@samp{％u@var{suffix}}がない場合、これは@samp{％g@var{suffix}}と似ているが、それらは同じサフィックス@emph{space}を共有しないので、@samp{%g.s @dots{} %U.s @dots{} %g.s @dots{} %U.s}は、@samp{％g.s}ごとに1つずつ、@samp{％U.s}ごとに1つずつ、2つの異なるファイル名を生成する。以前は、@samp{％U}は直前の@samp{％u}に対して選択されたファイル名で置き換えられていた。

@item %j@var{suffix}
もし存在し、書き込み可能で、@option{-save-temps}が使用されていない場合は、@code{HOST_BIT_BUCKET}の名前を置き換える。 それ以外の場合は、@samp{％u}のように一時ファイルの名前を置き換える。この一時ファイルは、プロセス間の通信ではなく、ジャンク処理メカニズムとして使用される。

@item %|@var{suffix}
@itemx %m@var{suffix}
@option{-pipe}が有効な場合を除いて、@samp{％g}と似ている。その場合、@samp{%|}は単一のダッシュを置き換え、@samp {％m}は何も置き換えない。これらは、プログラムに標準入力から読み込むか標準出力に書き込むかを指示する2つの最も一般的な方法である。もっと精巧なものが必要な場合は、@samp{％@{pipe:@code{X}@}}構文を使用することができる。例については@file{f/lang-specs.h}を参照せよ。

@item %.@var{SUFFIX}
後で@samp{％*}で出力されるときに、一致するスイッチのargsの接尾辞を@var{.SUFFIX}に置き換える。@var{SUFFIX}は次のスペースまたは％で終了する。

@item %w
このコンパイルの指定された出力ファイルとして@samp{％w}を含むかそれに続く引数をマークする。 これは、@samp{％o}が代入する引数のシーケンスに引数を置く。

@item %o
すべての出力ファイルの名前を、それらの周囲に自動的にスペースを入れて置き換える。 @samp{％o}の前後にスペースを入れるべきである。そうしないと、結果は未定義である。@samp{％o}は、リンカを実行するための仕様で使用される。名前に接尾辞が付いていない入力ファイルは、コンパイルされないが、出力ファイルには含まれているため、リンクされる。

@item %O
オブジェクトファイルの接尾辞を置き換える。完全なファイル名を作成する必要があるため、これは@samp{％g, ％u, ％U}の直後にあるときに特別に処理されることに注意せよ。@samp {％g、％u、％U}が現在、例えば@samp{.o}が続くような、@samp{%O}が続く追加の@var{suffix}文字をサポートしていないことを除いて、@samp {％O}は既に置換されているかのように扱われる

@item %p
現在のターゲットマシンの標準マクロ定義を置き換える。 @command {cpp}の実行時にこれを使用します。

@item %P
@samp{%p}と同じだが、@samp{__}で始まるマクロや@samp{_@var{L}}を除いて、各定義済みマクロの名前の前後に@samp {__}を置く。 @var{L}は大文字である。これはISO C向けである。

@item %I
@env{GCC_EXEC_PREFIX}からの@option{-iprefix}、@env{TARGET_SYSTEM_ROOT}からの@option{-isysroot}、@env{COMPILER_PATH}からの@option{-isystem} @option{-B}オプション）と@option{-imultilib}を使用する。

@item %s
現在の引数は、ある種のライブラリまたはスタートアップファイルの名前である。ディレクトリの標準リストでそのファイルを検索し、見つかったフルネームで置き換える。現在の作業ディレクトリは、スキャンされたディレクトリのリストに含まれている。

@item %T
現在の引数は、リンカースクリプトの名前である。 現在のディレクトリのリストでそのファイルを検索し、ライブラリをスキャンする。 ファイルが見つかった場合は、@option{-script}オプションをコマンド行に挿入し、その後に完全なパス名を入力する。 ファイルが見つからない場合は、エラーメッセージを生成する。 注：現在の作業ディレクトリは検索されない。

@item %e@var{str}
@var{str}をエラーメッセージとして出力する。 @var{str}は改行で終了する。一貫性のないオプションが検出された場合に使用する。

@item %(@var{name})
この時点で、spec文字列@var{name}の内容を置き換える。

@item %x@{@var{option}@}
@samp {％X}のオプションを累積する。

@item %X
@option{-Wl}または@samp{％x}指定文字列によって指定された蓄積されたリンカオプションを出力する。

@item %Y
@option{-Wa}で指定した累積アセンブラオプションを出力する。

@item %Z
@option {-Wp}で指定された累積プリプロセッサオプションを出力する。

@item %a
@code{asm}仕様を処理する。 これは、アセンブラに渡されるスイッチを計算するために使用される。

@item %A
@code{asm_final}仕様を処理する。 これは、このようなプログラムが必要な場合に、スイッチをアセンブラポストプロセッサに渡すための仕様文字列である。

@item %l
@code{link}仕様を処理する。 これは、リンカーに渡されたコマンドラインを計算するための仕様である。 通常、@samp{％L％G％S％Dと％E}シーケンスを使用する。

@item %D
GCCがスタートアップファイルを含んでいる可能性のあるディレクトリごとに@option{-L}オプションをダンプする。 ターゲットがマルチブロックをサポートしている場合、現在のmultilibディレクトリがこれらのパスのそれぞれに付加される。

@item %L
@code {lib}仕様を処理する。 これは、どのライブラリがリンカーへのコマンドラインに含まれるかを決めるための仕様文字列である。

@item %G
@code {libgcc}仕様を処理する。 これは、どのGCCサポートライブラリがリンカのコマンドラインに含まれているかを決定するための仕様文字列である。

@item %S
@code{startfile}仕様を処理する。 これは、どのオブジェクトファイルが最初にリンカに渡されるかを決定するための仕様である。通常、これは@file{crt0.o}という名前のファイルである。

@item %E
@code{endfile}仕様を処理する。 これは、リンカに渡された最後のオブジェクトファイルを指定する仕様文字列である。

@item %C
@code{cpp}仕様を処理する。 これは、Cプリプロセッサに渡す引数を作成するために使用される。

@item %1
@code{cc1}仕様を処理する。 これは、実際のCコンパイラ（@command{cc1}）に渡すオプションを構築するために使用される。

@item %2
@code{cc1plus}仕様を処理する。 これは、実際のC++コンパイラ（@command{cc1plus}）に渡すオプションを構築するために使用される。

@item %*
一致するオプションの可変部分を代入する。 下記参照。置換文字列の各カンマは単一のスペースで置き換えられることに注意せよ。

@item %<S
コマンドラインから@code{-S}をすべて削除する。 注---このコマンドは位置によって異なる。これより前の@samp{%}コマンドは@code{-S}を見て、これよりあとの@samp{%}コマンドは見ない。

@item %:@var{function}(@var{args})
名前付き関数@var{function}を呼び出し、@var{args}を渡す。 @var{args}はネストされた仕様文字列として最初に処理され、通常の方法で引数ベクトルに分割される。 関数は現在の仕様の一部として文字通り現れたかのように処理される文字列を返す。

以下のビルトイン仕様関数が用意されている。

@table @code
@item @code{getenv}
@code{getenv}仕様関数は、環境変数名と文字列という2つの引数をとる。 環境変数が定義されていない場合、致命的なエラーが発行される。それ以外の場合、戻り値は文字列と連結された環境変数の値である。たとえば、@env{TOPDIR}が@file{/path/to/top}として定義されている場合、次のようになる。

@smallexample
%:getenv(TOPDIR /include)
@end smallexample

は@file{/path/to/top/include}へと展開される。

@item @code{if-exists}
@code{if-exists}仕様関数は1つの引数、ファイルへの絶対パス名をとる。 ファイルが存在する場合、@code{if-exists}はパス名を返す。 その使い方の小さな例がある：

@smallexample
*startfile:
crt0%O%s %:if-exists(crti%O%s) crtbegin%O%s
@end smallexample

@item @code{if-exists-else}
@code{if-exists-else}仕様関数は、2つの引数を取る点を除いて、@code{if-exists}仕様関数と似ている。最初の引数は、ファイルへの絶対パス名である。ファイルが存在する場合、@code{if-exists-else}はパス名を返す。存在しない場合は、2番目の引数を返す。このようにして、@code{if-exists-else}を使用して、最初のファイルの存在に基づいて1つのファイルまたは別のファイルを選択することができる。その使い方の小さな例があります：

@smallexample
*startfile:
crt0%O%s %:if-exists(crti%O%s) \
%:if-exists-else(crtbeginT%O%s crtbegin%O%s)
@end smallexample

@item @code{replace-outfile}
@code{replace-outfile}仕様関数は2つの引数をとる。これは、outfiles配列の最初の引数を探し、それを2番目の引数に置き換える。 その使い方の小さな例がある：

@smallexample
%@{fgnu-runtime:%:replace-outfile(-lobjc -lobjc-gnu)@}
@end smallexample

@item @code{remove-outfile}
@code{remove-outfile}仕様関数は1つの引数をとる。 これは、outfiles配列の最初の引数を探し、それを削除する。 その使用例を以下に示す。

@smallexample
%:remove-outfile(-lm)
@end smallexample

@item @code{pass-through-libs}
@code{pass-through-libs}仕様関数は任意の数の引数をとる。任意の@option{-l}オプションと@file{.a}（リンカ入力ライブラリアーカイブファイルの名前であると仮定する）で終わるオプション以外を見つけ出し、それぞれの先頭に@option{-plugin-opt=-pass-through=}を入力し、スペースで結合する。このリストは、LTOリンカー・プラグインに渡されることを意図している。

@smallexample
%:pass-through-libs(%G %L %G)
@end smallexample

@item @code{print-asm-header}
@code{print-asm-header}関数は引数をとらず、単純に次のようなバナーを出力する：

@smallexample
Assembler options
=================

Use "-Wa,OPTION" to pass "OPTION" to the assembler.
@end smallexample

@option{-target-help}出力のアセンブラオプションからコンパイラオプションを分離するために使用される。
@end table

@item %@{S@}
スイッチがGCCに与えられている場合は、@code{-S}スイッチに置き換える。そのスイッチが指定されていない場合、これは何も置き換えない。先頭のダッシュはこのオプションを指定するときは省略され、置換が実行されると自動的に挿入されることに注意せよ。したがって、仕様文字列@samp{％@{foo@}}は、コマンドラインオプション@option{-foo}と一致し、コマンドラインオプション@option{-foo}を出力する。

@item %W@{S@}
％@{@code{S}@}と似ているが、失敗したときに削除するファイルとして指定された最後の引数をマークする。

@item %@{S*@}
指定されたすべてのスイッチをGCCに代入する。名前は@code{-S}で始まるだけでなく、引数もとる。これは、@option{-o}、@option{-D}、@option{-I}などのスイッチに使用される。GCCは@option{-o foo}を@samp{o}で始まる1つのスイッチとみなす。 ％@{o*@}はスペースを含めてこのテキストを置き換えるます。 したがって、2つの引数が生成される。

@item %@{S*&T*@}
％@{@code{S}*@}と似ているが、@code{S}と@code {T}オプションの順序を保持する（仕様の@code{S}と@code{T}の順序は重要ではない）。アンパサンドで区切られた変数はいくつでもよい。 ワイルドカードはそれぞれオプションである。@samp{％@{D*＆U*＆A*@}}としてCPPに役立つ。

@item %@{S:X@}
@option{-S}スイッチがGCCに与えられている場合、@code {X}に置き換えられる。

@item %@{!S:X@}
@option{-S}スイッチがGCCに対して与えられて@emph{いない}場合、@code {X}に置き換えられる。

@item %@{S*:X@}
名前が@code{-S}で始まるスイッチがGCCに指定されている場合は、@code {X}に置き換える。通常、@code{X}はスイッチの数にかかわらず一度だけ置換される。しかし、@code{％*}が@code{X}のどこかに現れた場合、@code {X}は、一致するスイッチごとに1回置き換えられ、@code {%*}は@code {*}に一致するスイッチの一部で置き換えられる。

@code{％*}が仕様列の最後の部分として現れた場合、最後の置換の終了後にスペースが追加される。ただし、列内にテキストがさらに存在する場合は、スペースは生成されない。 これにより、より大きな文字列の一部として@code{％*}置換を使用することができる。たとえば、次のような列文字列があると：

@smallexample
%@{mcu=*:--script=%*/memory.ld@}
@end smallexample

@noindent
@option{-mcu = newchip}のようなオプションをマッチさせると次のようになる：

@smallexample
--script=newchip/memory.ld
@end smallexample

@item %@{.S:X@}
接尾辞@code{S}を持つファイルを処理する場合は、@code{X}に置き換える。

@item %@{!.S:X@}
接尾辞@code{S}を持つファイルを処理@emph{しない}場合は、@code{X}に置き換える。

@item %@{,S:X@}
言語@code{S}のファイルを処理する場合は、@code {X}に置き換える。

@item %@{!,S:X@}
言語@code{S}のファイルを処理していない場合は、@code{X}に置き換える。

@item %@{S|P:X@}
@code{-S}か@code{-P}のどちらかがGCCに与えられた場合、@code{X}に置き換える。これは@samp{!}、@samp{.}、@samp{,}、@code {*}シーケンスと組み合わせても問題ないが、結合は@samp{|}よりも強くなる。 @code{X*}に@code{％*}が含まれている場合は、すべての選択肢に星印を付ける必要があり、最初の一致する選択肢のみが置換される。

たとえば、次のような仕様文字列があると、

@smallexample
%@{.c:-foo@} %@{!.c:-bar@} %@{.c|d:-baz@} %@{!.c|d:-boggle@}
@end smallexample

@noindent
次の入力コマンドラインオプションから次のコマンドラインオプションを出力する。

@smallexample
fred.c        -foo -baz
jim.d         -bar -boggle
-d fred.c     -foo -baz -boggle
-d jim.d      -bar -baz -boggle
@end smallexample

@item %@{S:X; T:Y; :D@}
GCCに@code{S}が与えられていれば、@code{X}に置き換えられる。 そうでなければ、GCCに@code{T}が与えられていれば、@code{Y}に置き換える。さもなければ@code{D}を代入する。必要だけ多くの節をできる。 これは、必要に応じて@code{.}、@code{,}、@code{!}、@code{|}、@code{*}と組み合わせることができる。

@item -mindirect-branch=@var{choice}
@opindex -mindirect-branch
間接呼び出しとジャンプを@var{choice}を使って変換する。 デフォルトは@samp{keep}で、これは間接呼び出しとジャンプを保持する。@samp{thunk}は間接呼び出しとジャンプを、サンクの呼び出しと復帰に変換する。@samp{thunk-inline}は間接呼び出しとジャンプをインライン化されたサンクの呼び出しと復帰に変換する。@samp{thunk-extern}は間接呼び出しとジャンプを別のオブジェクトファイルで提供されたサンクへの外部呼び出しと復帰に変換する。関数属性@code{indirect_branch}を使用すると、特定の関数のこの動作を制御できる。 @xref{Function Attributes}

大きなコードモデルでは、サンク関数に到達できない可能性があるため、@option{-mcmodel=large}は@option{-mindirect-branch=thunk}や@option {-mindirect-branch=thunk-extern}と互換性がないことに注意せよ。

外部のサンクを制御フローチェックを無効にするように変更することはできないので、@option{-mindirect-branch=thunk-extern}は@option{-fcf-protection=branch}や@option {-fcheck-pointer-bounds}と互換性がないことに注意せよ。

@item -mfunction-return=@var{choice}
@opindex -mfunction-return
@var{choice}で関数復帰を変換する。 デフォルトは@samp{keep}で、関数復帰は変更されない。 @samp{thunk}は関数復帰をサンクの呼び出しと復帰に変換する。 @samp{thunk-inline}は、関数復帰をインライン化されたサンクの呼び出しと復帰に変換する。 @samp {thunk-extern}は、関数復帰を、別のオブジェクトファイルで提供されるサンクの呼び出しと復帰に変換する。 特定の関数に対してこの動作を制御するには、関数属性@code{function_return}を使用する。@xref{Function Attributes}.

大きなコードモデルでは、サンク関数に到達できない可能性があるため、@option{-mcmodel=large}は@option{-mfunction-return=thunk}や@option {-mfunction-return=thunk-extern}と互換性がないことに注意せよ。

@item -mindirect-branch-register
@opindex -mindirect-branch-register
レジスタ経由の間接呼び出しとジャンプを強制する。

@end table

@samp{％@{S@}}や@samp{％@{S:X@}}やそれに類する構文のテキストの@code {S}にマッチするスイッチは、バックスラッシュを使って次の文字の特殊な意味を無視することができ、これにより、特別に扱われる文字のリテラルマッチングが可能になる。@option{-std=iso9899:1999}オプションが指定されている場合、@samp{％@{std=iso9899\:1999:X@}}は@code{X}を置き換える。

@samp{%@{S:X@}}内の条件付きテキスト@code{X}や他の同様の構文には、他のネストされた@samp{％}構造体やスペース、あるいは改行文字が含まれている。 これらは上記のように通常通り処理される。@code{X}の末尾の空白は無視される。 空白は、@code{.}や@code {*}とそれに対応する単語を除いて、これらの構造体のコロンの左側の任意の場所に表示されることもある。

@option{-O}、@option{-f}、@option{-m}、および@option{-W}スイッチは、これらの構造体で特に処理される。@option{-O}の別の値または@option{-f}、@option{-m}、または@option{-W}スイッチの否定された形式がコマンドラインの後のほうにある場合、以前のスイッチ値@{@code{S}*@}を除いて無視される。ここで@code {S}はすべての一致するオプションを渡す単一文字である。

述語テキストの先頭にある文字@samp{|}は、コマンドが次のコマンドにパイプされるべきであることを示すために使用されるが、それは@option{-pipe}が指定されている場合のみである。

それはどのスイッチが引数を取ってどれが取らないかがGCCに組み込まれている。（各コンパイラの仕様によって、どのスイッチが引数を取るかを言うために、これを一般化することが有用であると考えるかもしれない。  しかし、これは一貫した方法で行うことはできない。  GCCはどのスイッチが引数を取るかを知らずにどの入力ファイルが指定されたのかを判断することもできず、実行するコンパイラを知らせるためにどの入力ファイルをコンパイルするのかを知る必要がある。）

GCCはまた、@option{-l}で始まる引数がコンパイラの出力ファイルとして扱われ、他の出力ファイルの中の適切な位置にリンカに渡されることを暗黙のうちに知っている。

@node Environment Variables
@section GCCに影響を与える環境変数
@cindex environment variables

@c man begin ENVIRONMENT
このセクションでは、GCCの動作に影響を与えるいくつかの環境変数について説明する。それらの中には、さまざまな種類のファイルを検索するときに使用するディレクトリや接頭辞を指定するものもある。 いくつかは、コンパイル環境の他の側面を指定するために使用される。

@option {-B}、@option {-I}、@option {-L}などのオプションを使用して検索する場所を指定することもできる。 (@pxref{Directory Options})。 これらは環境変数を使用して指定された場所よりも優先される。環境変数はGCCの設定で指定された場所よりも優先される。@xref{Driver,, Controlling the Compilation Driver @file{gcc}, gccint,
GNU Compiler Collection (GCC) Internals}.

@table @env
@item LANG
@itemx LC_CTYPE
@c @itemx LC_COLLATE
@itemx LC_MESSAGES
@c @itemx LC_MONETARY
@c @itemx LC_NUMERIC
@c @itemx LC_TIME
@itemx LC_ALL
@findex LANG
@findex LC_CTYPE
@c @findex LC_COLLATE
@findex LC_MESSAGES
@c @findex LC_MONETARY
@c @findex LC_NUMERIC
@c @findex LC_TIME
@findex LC_ALL
@cindex locale
これらの環境変数は、GCCがローカリゼーション情報を使用する方法を制御する。これにより、GCCはさまざまな国の慣習に従って動作することができる。 GCCはロケールカテゴリ@env{LC_CTYPE}と@env{LC_MESSAGES}が設定されているかどうかを調べる。これらのロケールカテゴリは、インストールでサポートされている任意の値に設定できる。典型的な値は、UTF-8でエンコードされた英国の英語の@samp{en_GB.UTF-8}である。

@env{LC_CTYPE}環境変数は、文字の分類を指定する。 GCCはそれを使用して文字列内の文字境界を判断する。 これは、引用符とエスケープ文字を含むマルチバイトエンコーディングの場合に必要である。これは、文字列の終わりまたはエスケープとして解釈される。

@env{LC_MESSAGES}環境変数は、診断メッセージに使用する言語を指定する。

@env{LC_ALL}環境変数が設定されている場合、@env{LC_CTYPE}と@env{LC_MESSAGES}の値が上書きされる。 そうでない場合、@env{LC_CTYPE}と@env{LC_MESSAGES}はデフォルトで@env{LANG}環境変数の値になる。 これらの変数のいずれも設定されていない場合、GCCのデフォルトは従来のC言語の動作になる。

@item TMPDIR
@findex TMPDIR
@env{TMPDIR}が設定されている場合は、一時ファイルに使用するディレクトリを指定する。 GCCは一時ファイルを使用して、次の段階への入力として使用されるコンパイルの1段階の出力を保持する。たとえば、コンパイラの適切な入力であるプリプロセッサの出力である。

@item GCC_COMPARE_DEBUG
@findex GCC_COMPARE_DEBUG
@env{GCC_COMPARE_DEBUG}を設定することは、@option{-fcompare-debug}をコンパイラドライバに渡すこととほぼ同じである。 詳細については、このオプションのドキュメントを参照せよ。

@item GCC_EXEC_PREFIX
@findex GCC_EXEC_PREFIX
@env{GCC_EXEC_PREFIX}が設定されている場合、コンパイラによって実行されるサブプログラムの名前に使用する接頭辞を指定する。 このプレフィックスとサブプログラムの名前を組み合わせた場合、スラッシュは追加されないが、必要に応じてスラッシュで終わる接頭辞を指定できる。

@env{GCC_EXEC_PREFIX}が設定されていない場合、GCCは呼び出されたパス名に基づいて適切な接頭辞を探し出す。

GCCが指定された接頭辞を使用してサブプログラムを見つけることができない場合、GCCは通常の場所でサブプログラムを探す。

@env{GCC_EXEC_PREFIX}のデフォルト値は@file{@var {prefix}/lib/gcc/}である。ここで、@var{prefix}はインストールされたコンパイラの接頭辞である。 多くの場合、@var{prefix}は、@file{configure}スクリプトを実行したときの@code{prefix}の値である。

@option{-B}で指定された他の接頭辞は、この接頭辞よりも優先される。

この接頭辞は、リンクに使用される@file{crt0.o}のようなファイルを見つけるためにも使用される。

さらに、接頭辞は、ヘッダーファイルを検索するディレクトリを見つける際に通常とは異なる方法で使用される。名前が通常@samp{/usr/local/lib/gcc}で始まる標準ディレクトリ（より正確には@env{GCC_INCLUDE_DIR}の値）ごとに、GCCは代替ディレクトリ名を生成するために指定された接頭辞で始まるものを置き換えようとする。 したがって、@option{-Bfoo /}で、GCCは標準ディレクトリ@file {/usr/local/lib/bar}を検索する直前に@file{foo/bar}を検索する。標準ディレクトリが設定された@var{prefix}で始まる場合、@var{prefix}の値はヘッダファイルを探すときに@env {GCC_EXEC_PREFIX}に置き換えらる。

@item COMPILER_PATH
@findex COMPILER_PATH
@env{COMPILER_PATH}の値は、@env{PATH}と同様に、コロンで区切られたディレクトリのリストである。 @env{GCC_EXEC_PREFIX}を使用してサブプログラムが見つからない場合、GCCはサブプログラムを検索するときにこのように指定されたディレクトリを試す。

@item LIBRARY_PATH
@findex LIBRARY_PATH
@env{LIBRARY_PATH}の値は、@env{PATH}と同様に、コロンで区切られたディレクトリのリストである。ネイティブコンパイラとして設定された場合、GCCは@env{GCC_EXEC_PREFIX}を使用してそれらを見つけることができない場合、特別なリンカファイルを検索するときに指定されたディレクトリを試す。GCCを使用してリンクすると、@option{-l}オプションの通常のライブラリを検索する際にもこれらのディレクトリが使用される（しかし、@option {-L}で指定されたディレクトリが最初に来る）。

@item LANG
@findex LANG
@cindex locale definition
この変数は、ロケール情報をコンパイラに渡すために使用される。この情報が使用される1つの方法は、文字リテラル、文字列リテラルおよびコメントがCおよびC++で解析されるときに使用される文字セットを決定することである。コンパイラがマルチバイト文字を許可するように設定されている場合、次の@env{LANG}の値が認識されます。

@table @samp
@item C-JIS
JIS文字を認識する。
@item C-SJIS
SJIS文字を認識する。
@item C-EUCJP
EUCJP文字を認識する。
@end table

@env{LANG}が定義されていない場合、または他の値がある場合、コンパイラはデフォルトロケールで定義されている@code{mblen}と@code{mbtowc}を使用して、マルチバイト文字を認識して変換する。
@end table

@noindent
いくつかの追加の環境変数は、プリプロセッサの動作に影響する。

@include cppenv.texi

@c man end

@node Precompiled Headers
@section コンパイル済みヘッダを使う
@cindex precompiled headers
@cindex speed of compilation

多くの場合、大きなプロジェクトには、すべてのソースファイルに含まれるヘッダファイルが多数ある。 コンパイラがこれらのヘッダファイルを何度も処理するのにかかる時間は、プロジェクトを構築するのに必要な時間のほとんどすべてを占めることがある。 ビルドを高速化するために、GCCではヘッダファイルを@dfn{precompile}（プリコンパイル）することができる。

プリコンパイル済みのヘッダーファイルを作成するには、必要に応じて@option{-x}オプションを使用してドライバでCまたはC++ヘッダーファイルとして扱うように、他のファイルと同様にコンパイルする。 @command{make}のようなツールを使用して、プリコンパイルされたヘッダーに変更が含まれている場合、そのヘッダーを最新の状態に保つことができる。

コンパイル時に@code{#include}が見えた時、プリコンパイルされたヘッダファイルが検索される。 インクルードされたファイル(@pxref{Search Path,,Search Path,cpp,The C Preprocessor}) を検索すると、コンパイラはそのディレクトリのインクルードファイルを探す直前に各ディレクトリのプリコンパイル済みヘッダを探す。 検索される名前は、@code{#include}で指定されたものに@samp{.gch}が付加された名前である。 プリコンパイルされたヘッダーファイルを使用できない場合は無視される。

たとえば、@code{#include "all.h"}を持ち、@file{all.h}と同じディレクトリに@file{all.h.gch}がある場合、可能であればプリコンパイルされたヘッダファイルが使用される。 さもなければ元のヘッダーが使用される。

あるいは、プリコンパイルされたヘッダーファイルをディレクトリに入れ、@option{-I}を使用して元のヘッダーを含むディレクトリの前に（またはその代わりに）ディレクトリを検索することもできる。次に、プリコンパイルされたヘッダファイルが常に使用されていることを確認したい場合は、@code{#error}コマンドを含む元のヘッダと同じ名前のファイルをこのディレクトリに置くことができる。

これは@option {-include}でも有効である。プリコンパイルされたヘッダーを使用するもう1つの方法は、プリコンパイルされたヘッダーファイルを考慮して設計されていないプロジェクトに適している。プロジェクトで使用されるヘッダーファイルの大半を取り込み、別のヘッダーファイルからインクルードし、 プリコンパイルされたヘッダーを@option{-include}する。ヘッダーファイルに複数のインクルードが含まれている場合、ヘッダーファイルは既にインクルードされているため（プリコンパイル済みヘッダー内にあるため）、スキップされる。

異なる言語、ターゲット、またはコンパイラ・オプションに対して同じヘッダー・ファイルをプリコンパイルする必要がある場合は、代わりに@emph{ディレクトリ}を@file {all.h.gch}のように作成して、各プリコンパイルされたヘッダーをディレクトリに入れて、 おそらく@option{-o}を使用する。あなたがディレクトリ内のファイルと呼ぶものは重要ではない。 ディレクトリ内のすべてのプリコンパイル済みヘッダーが考慮される。このコンパイルで有効な、ディレクトリ内で最初にプリコンパイルされたヘッダーが使用される。 それらは特別な順序で検索されることはない。

他にも多くの可能性がある。あなたの想像力、良識、ビルドシステムの制約によってのみ制限される。

プリコンパイル済みヘッダーファイルは、次の条件が当てはまる場合にのみ使用できる。

@itemize
@item
特定のコンパイルでは、1つのプリコンパイル済みヘッダーしか使用できない。

@item
最初のCトークンが見えると、プリコンパイルされたヘッダーは使用できない。 プリコンパイルされたヘッダの前にプリプロセッサディレクティブを置くことができる。 別のヘッダーの中からプリコンパイルされたヘッダーを含めることはできない。

@item
プリコンパイルされたヘッダーファイルは、現在のコンパイルと同じ言語で作成する必要がある。 C++コンパイルにCプリコンパイル済みヘッダーを使用することはできない。

@item
プリコンパイルされたヘッダーファイルは、現在のコンパイルが使用しているのと同じコンパイラバイナリによって生成されている必要がある。

@item
プリコンパイル済みヘッダーが含まれる前に定義されたマクロは、プリコンパイル済みヘッダーの生成時と同じ方法で定義するか、プリコンパイル済みヘッダーに影響を与えてはならない。

@option{-D}オプションは、プリコンパイルされたヘッダがインクルードされる前にマクロを定義する方法の1つである。 @code{#define}を使うこともできる。@option{-O}や@option{-Wdeprecated}のように暗黙的にマクロを定義するオプションもある。 この方法で定義されたマクロにも同じ規則が適用される。

@item @option{-g}などを使用してプリコンパイル済みヘッダーを使用するときにデバッグ情報が出力された場合、プリコンパイル済みヘッダーを構築するときに、同じ種類のデバッグ情報が出力されている必要がある。 ただし、デバッグ情報が出力されていない場合は、コンパイル時に@option{-g}を使用してビルドされたプリコンパイル済みヘッダーを使用できる。

@item プリコンパイルされたヘッダーを構築して使用するときは、通常、同じ@option {-m}オプションを使用する必要がある。この規則が緩和される場合は@xref{Submodel Options}にある。

@item プリコンパイル済みヘッダーを作成して使用する場合は、次の各オプションを同じにする必要がある。

@gccoptlist{-fexceptions}

@item
@option{-f}、@option{-p}、または@option{-O}で始まるいくつかのコマンドラインオプションは、プリコンパイル済みヘッダーが生成されたときと同じ方法で定義する必要がある。  現在、どのオプションを変更するのが安全かどうかは明らかではない。 最も安全な選択は、プリコンパイル済みヘッダーを生成して使用するときに、まったく同じオプションを使用することである。以下は安全であることが知られている：

@gccoptlist{-fmessage-length=  -fpreprocessed  -fsched-interblock 
-fsched-spec  -fsched-spec-load  -fsched-spec-load-dangerous 
-fsched-verbose=@var{number}  -fschedule-insns  -fvisibility= 
-pedantic-errors}

@end itemize
最後のものを除くこれらすべての場合、条件が満たされない場合、コンパイラはプリコンパイル済みヘッダーを自動的に無視する。オプションの組み合わせがうまくいかず、コンパイルされたヘッダーが無視されない場合は、バグレポートを提出することを検討せよ。@ref{Bugs}参照。

プリコンパイル済みヘッダーを生成して使用する際に異なるオプションを使用する場合、実際の動作はオプションの動作の混合である。 たとえば、プリコンパイル済みヘッダーを生成するのに@option{-g}を使用するが、使うときにはしない場合は、プリコンパイル済みヘッダー内のルーチンのデバッグ情報を取得することも、取得しないこともできる。
