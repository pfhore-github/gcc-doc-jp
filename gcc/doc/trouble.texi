@c Copyright (C) 1988-2020 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node Trouble
@chapter GCCの問題の既知の原因
@cindex bugs, known
@cindex installation trouble
@cindex known causes of trouble

このセクションでは、GCCのユーザーに影響する既知の問題について説明する。 これらのほとんどはGCCのバグではない。もしそうならば、修正されているだろう。 しかし、ユーザーにとっての結果は、バグの結果のようなものかもしれない。

これらの問題のいくつかは、他のソフトウェアのバグに起因するものもあれば、追加するにはあまりにも多くの作業が欠けているものもあれば、最良のものについて人々の意見が異なるところもある。

@menu
* Actual Bugs::         あとで修正する予定のバグ
* Interoperation::      他のコンパイラ、あるリンカ、アセンブラ、デバッガとともにGCCを使ったときの問題
* Incompatibilities::   GCCは伝統的なCと非互換である
* Fixed Headers::       GCCはシステムヘッダファイルの修正されたバージョンを使う。
                        これは必須だが、いつもスムーズに動くわけではない
* Standard Libraries::  GCCはシステムCライブラリを使うが、それはISO C標準に準拠していないかもしれない
* Disappointments::     残念なことに我々は変更できないが、全くのバグではない
* C++ Misunderstandings:: GNU C++でのよくある誤解
* Non-bugs::            我々は正しいと考えているが、同意していない人もいる
* Warnings and Errors:: 警告を出す問題とエラーを出す問題
@end menu

@node Actual Bugs
@section まだ修正していない実際のバグ

@itemize @bullet
@item
@code{fixincludes}スクリプトはオートマウンタとうまくやり取りしない。 システムヘッダファイルのディレクトリが自動マウントされていると、@ code{fixincludes}の実行中にアンマウントされる傾向がある。 これはオートマウンタのバグのようである。 我々はそれを回避する良い方法を知らない。
@end itemize

@node Interoperation
@section 相互運用

このセクションでは、他のコンパイラやアセンブラ、リンカ、ライブラリ、特定のシステム上のデバッガと一緒にGCCを使用する際に遭遇するさまざまな問題をリストする。

@itemize @bullet
@item
多くのプラットフォームでは、GCCは他のコンパイラとは異なるC++用ABIをサポートしているため、GCCでコンパイルされたオブジェクトファイルは別のC++コンパイラで生成されたオブジェクトファイルでは使用できない。

違いが最も顕著な領域は名前のマングリングである。 より微妙な問題からあなたを守るために、異なる名前のマングリングの使用は意図的である。コンパイラは、クラスインスタンスのレイアウト方法、多重継承の実装方法、仮想関数呼び出しの処理方法など、C++実装の多くの内部的な詳細について異なる。 名前のエンコーディングが同じになった場合、あなたのプログラムは他のコンパイラから提供されたライブラリとリンクするが、実行するとプログラムがクラッシュする。 互換性のないライブラリは、実行時ではなくリンク時に検出される。

@item
Ultrixのいくつかのバージョンを含むいくつかのBSDシステムでは、プロファイリングを使用すると、静的変数デストラクタ（現在はC++でのみ使用されている）が実行されなくなる。

@item
SPARCでは、GCCは8バイト境界で@code{double}型のすべての値を整列させ、すべての@code{double}がそのように整列することを期待している。 Sunコンパイラは通常、@code{double}の値に8バイトのアライメントを与えるが、1つの例外がある：@code{double}型の関数の引数は整列されないかもしれない。

その結果、Sun CCでコンパイルされた関数が@code{double}型の引数のアドレスを受け取り、このコードを@code{double *}の型にGCCでコンパイルされた関数に渡すと、ポインタの逆参照により致命的なシグナルを起こすかもしれない。

この問題を解決する1つの方法は、プログラム全体をGCCでコンパイルすることである。 別の解決策は、引数をローカル変数にコピーするためにSun CCでコンパイルされた関数を変更することである。 ローカル変数は常に正しく整列される。 3番目の解決方法は、直接@samp{*}ではなく、次の関数@code{access_double}を使用してポインタを使用する関数を参照解除することである。

@smallexample
inline double
access_double (double *unaligned_ptr)
@{
  union d2i @{ double d; int i[2]; @};

  union d2i *p = (union d2i *) unaligned_ptr;
  union d2i u;

  u.i[0] = p->i[0];
  u.i[1] = p->i[1];

  return u.d;
@}
@end smallexample

@noindent
ポインターへの格納は、同じユニオンで同様に行うことができる。

@item
Solarisでは、@file{libmalloc.a}ライブラリの@code{malloc}関数は、4バイトだけのアラインメントのメモリを割り当てる。 SPARCのGCCでは、倍精度が8バイト境界になっていると仮定しているため、倍精度が@file{libmalloc.a}ライブラリによって割り当てられたメモリに格納されていると、致命的なシグナルが発生する可能性がある。

解決策は、@file{libmalloc.a}ライブラリを使用しないことである。 @file{libc.a}の@code{malloc}や関連する関数を使用すること。それらはこの問題を抱えていない。

@item
HP PAマシンでは、GCCでコンパイルされた関数でADBが動作しないことがある。 具体的には、@code{alloca}や可変長配列を使用する関数では機能しない。 これは、GCCがそのような機能のHP-UX unwind descriptorを生成しないためである。 それを生成することは不可能かもしれない。

@item
予備GNUツールを使用しない限り、デバッグ（@option{-g}）はHP PAマシンではサポートされていない。

@item
ラベルのアドレスをとると、HP-UX PAアセンブラからエラーが発生する可能性がある。 PAのGASにはこの問題はない。

@item
HPアセンブラを使用しているときは、静的関数への間接呼び出しに浮動小数点パラメータを使用しても機能しない。 GCCは、HPアセンブラを使用するときに、スタティック関数の引数を保持するレジスタを指定する方法がない。 PAのGASにはこの問題はない。

@item
非常に大きな関数がいくつか含まれている非常にまれなケースでは、範囲外のブランチオフセットについて不平を言うHPリンカからエラーを受け取ることがある。 これはGCCの以前のバージョンでより頻繁に発生していたが、現在はまれである。 それを実行する必要がある場合は、関数を小さくすることで回避できる。

@item
GCCコンパイルされたコードでは、次の形式のHP-UXアセンブラから警告が出力されることがある。

@smallexample
(warning) Use of GR3 when
  frame >= 8192 may cause conflict.
@end smallexample

これらの警告は無害であり、安全に無視することができる。

@item
非常に大きな関数がいくつか含まれている非常にまれなケースでは、大きすぎる変位について不平を言うAIXアセンブラからエラーを受け取ることがある。 それを実行する必要がある場合は、関数を小さくすることで回避できる。

@item
GCCの@file{libstdc++.a}ライブラリは、特にC++ストリーム機能に必要な、ライブラリとアプリケーション間のグローバルシンボルをマージするSVR4ダイナミックリンカのセマンティクスに依存している。 これは、AIX共有ライブラリーと動的リンクのデフォルトの動作ではない。@file{libstdc++.a}は、「ランタイムリンク」が有効になっているAIX上に構築されているため、シンボルのマージが可能である。 この機能を利用するには、@file{libstdc++.a}にリンクされているアプリケーションでリンク行に@option{-Wl,-brtl}フラグを含める必要がある。 G++はこれを強制することはできない。なぜなら、このオプションはユーザプログラムのセマンティクスを妨げる可能性があり、ユーザは@samp{g++}を使用してアプリケーションをリンクするとは限らない。アプリケーションは、リンク行で@option{-Wl,-brtl}フラグを使用する必要はない。シンボル統合のセマンティクスに依存しない残りの@file{libstdc++.a}ライブラリは引き続き正しく機能する。

@item
アプリケーションは、@file{libstdc++.a}で呼び出された関数の独自の関数定義を、AIXで使用可能な「ランタイム・リンク」に置き換えることができる。 これを実現するには、アプリケーションを「ランタイムリンク」オプションでリンクする必要があり、明示的にアプリケーションからエクスポートする必要がある（@option {-Wl,-brtl,-bE:exportfile}）。

@item
RS/6000上のAIXは、米国以外の環境でのサポート（NLS）を提供する。 コンパイラとアセンブラは、浮動小数点数（小数点を区切る文字が@samp{.}か@samp{,}）を含むさまざまなオブジェクトのロケール固有の表現をサポートするためにNLSを使用する。 GCCにリンクされたライブラリが、アセンブラが受け付けるのと同じ浮動小数点フォーマットを生成しないという問題が報告されている。 この問題がある場合は、環境変数@env{LANG}を@samp{C}または@samp {En_US}に設定する。

@item
@opindex fdollars-in-identifiers
@option{-fdollars-in-identifiers}を指定しても、IBMアセンブラの制限のためにRS/6000の識別子に@samp{$}を正常に使用することはできない。 GASはこれらの識別子をサポートしている。

@end itemize

@node Incompatibilities
@section GCCの非互換性
@cindex incompatibilities of GCC
@opindex traditional

GNU CとK＆R（非ISO）バージョンの間には、いくつかの非互換性がある。

@itemize @bullet
@cindex string constants
@cindex read-only strings
@cindex shared strings
@item
GCCは通常、文字列定数を読み取り専用にする。 同じ見た目の文字列定数が複数使用されている場合、GCCは文字列のコピーを1つだけ格納する。

@cindex @code{mktemp}, and constant strings
1つの結果として、文字定数の引数で@code {mktemp}を呼び出すことはできない。 関数@code{mktemp}は、引数が指す文字列を常に変更する。

@cindex @code{sscanf}, and constant strings
@cindex @code{fscanf}, and constant strings
@cindex @code{scanf}, and constant strings
もう1つの結果は、@code{sscanf}は、フォーマット制御文字列または入力として文字列定数を渡すと、非常に古いシステムでは動作しないということである。 これは、@code{sscanf}が文字列定数に誤って書き込もうとするためである。 @code{fscanf}と@code{scanf}も同様。

これらの問題を解決するには、文字列定数ではなく、これらの目的のために初期化文字列で@code{char}配列変数を使用するようにプログラムを変更することである。

@item
@code{-2147483648}は正である。

これは、2147483648が@code{int}型に収まりきらないためであり、（ISO Cの規則に従って）そのデータ型は@code{unsigned long int}である。 この値を否定すると、再び2147483648が返される。

@item
GCCは、文字列定数の内部に現れたときにマクロ引数を置換しない。 たとえば、GCCの次のマクロ

@smallexample
#define foo(a) "a"
@end smallexample

@noindent
は@var{a}の引数に関係なく、出力@code{"a"}を生成する。

@cindex @code{setjmp} incompatibilities
@cindex @code{longjmp} incompatibilities
@item
@code{setjmp}と@code{longjmp}を使用すると、有効であることが保証されている唯一の自動変数は@code{volatile}と宣言されたものである。 これは自動レジスタ割り付けの結果である。 この関数を考えてみる：

@smallexample
jmp_buf j;

foo ()
@{
  int a, b;

  a = fun1 ();
  if (setjmp (j))
    return a;

  a = fun2 ();
  /* @r{@code{longjmp (j)} may occur in @code{fun3}.} */
  return a + fun3 ();
@}
@end smallexample

ここで@code{a}は、@code{longjmp}が発生したときに最初の値に復元される場合とされない場合がある。 @code{a}がレジスタに割り当てられている場合、その最初の値が復元される。 それ以外の場合は、最後に保存された値を保持する。

@opindex W
@option{-W}オプションを@option{-O}オプションとともに使用すると、GCCがそのような問題が発生する可能性があると判断した場合に警告が表示される。

@item
マクロ引数の途中で前処理ディレクティブを使用するプログラムは、GCCでは動作しない。 たとえば、次のようなプログラムは動作しない。

@smallexample
@group
foobar (
#define luser
        hack)
@end group
@end smallexample

ISO Cはそのような構成を許可していない。

@item
K＆Rコンパイラは、コメントがインクルード境界（つまり、インクルードファイルで開始され、そのインクルードファイルで終了する）を横切るのを許可する。

@cindex external declaration scope
@cindex scope of external declarations
@cindex declaration scope
@item
ブロック内の外部変数および関数の宣言は、宣言を含むブロックにのみ適用される。 言い換えれば、それらは同じ場所で他の宣言と同じスコープを持っている。

他のCコンパイラでは、@code{extern}宣言は、ブロック内で発生したとしても残りのすべてのファイルに影響する。

@item
伝統的なCでは、以下に示すように@code{long}などをtypedef名と組み合わせることができる：

@smallexample
typedef int foo;
typedef long foo bar;
@end smallexample

ISO Cでは、これは許されない：@code{long}と他の型修飾子は明示的な@code{int}を必要とする。

@cindex typedef names as function parameters
@item
PCCでは、typedef名を関数パラメータとして使用できる。

@item
伝統的なCでは、次のような誤った宣言のペアを指定のスコープで一緒に表示できる。

@smallexample
typedef int foo;
typedef foo foo;
@end smallexample

@item
GCCは、識別子のすべての文字を有効として扱う。 K＆R-1（2.2）によると、「最初の8文字より後は重要ではないが、使うことはできる。」 また、K＆R-1（2.2）によると、「識別子は文字と数字のシーケンスで、最初の文字は文字でなければならない。下線_は文字としてカウントされる。」しかしGCCでは識別子でドル記号も使用できる。

@cindex whitespace
@item
PCCでは、@samp{+=}のような複合代入演算子の中間に空白を入れることができる。 GCCは、ISO標準に従って、これを許可していない。

@cindex apostrophes
@cindex @code{'}
@item
GCCは、失敗した前処理条件の中で、終端されていない文字定数について不平を言う。 一部のプログラムでは、条件付きで囲まれた英語のコメントが失敗することが保証されている。 これらのコメントにアポストロフィが含まれていると、GCCはおそらくエラーを報告する。 たとえば、次のコードではエラーが発生する。

@smallexample
#if 0
You can't expect this to work.
#endif
@end smallexample

このような問題に対する最良の解決策は、テキストを@samp{/*@dots{}*/}で区切られた実際のCコメントに入れることである。

@item
多くのユーザープログラムには、@samp{long time ();}という宣言が含まれている。 以前は、多くのシステムのシステムヘッダファイルは実際に@code{time}を宣言していなかったので、プログラムが返すと宣言したタイプは関係なかった。 しかしISO Cヘッダを持つシステムでは、@code{time}は@code {time_t}を返すと宣言され、それが@code{long}と同じでない場合、@samp{long time();}は間違っている。

解決策は、システムヘッダーファイルが宣言しているならば、プログラムが適切なシステムヘッダー（ISO Cヘッダーを持つシステムで@code{<time.h>}）を使用して@code{time}を宣言しないようにプログラムを変更するか、さもなければ@code{time}の戻り値の型として@code {time_t}を使用することである。

@cindex @code{float} as function value type
@item
@code{float}を返す関数をコンパイルするとき、PCCはそれをdoubleに変換する。 GCCは実際に@code{float}を返す。 PCCの互換性に関心がある場合は、@code{double}を返す関数を宣言する必要がある。あなたは同様に何を意図するかを言うべきである。

@cindex structures
@cindex unions
@item
構造体または共用体を返す関数をコンパイルするとき、GCC出力コードは通常、ほとんどのバージョンのUnixで使用されているものとは異なる方法を使用する。 その結果、GCCでコンパイルされたコードは、PCCでコンパイルされた構造体戻り関数を呼び出すことはできず、その逆できない。

GCCで使用される方法は、次のとおりである。1,2,4または8バイトの長さの構造体または共用体がスカラーのように返される。 他のサイズの構造体または共用体は、呼び出し元によって指定されたアドレスに格納される（通常、特殊な固定レジスタがあるが、一部のマシンではスタックに渡される）。 ターゲットフック@code{TARGET_STRUCT_VALUE_RTX}は、このアドレスをどこに渡すべきかをGCCに伝える。

対照的に、ほとんどのターゲットマシン上のPCCは、静的ストレージの領域にデータをコピーし、そのストレージのアドレスをポインタ値のように返すことによって、任意のサイズの構造体および共用体を返す。 呼び出し元は、そのメモリ領域から値が必要な場所にデータをコピーする必要がある。 この方法は遅く、非リエントラントなので、GCCではこの方法は使用しない。

より新しいいくつかのマシンでは、PCCはすべての構造体および共用体が戻ってくるための再入可能な規則を使用する。 これらのマシンの大部分のGCCは構造体と共用体をメモリに戻すときに互換性のある規約を使用するが、小さな構造体と共用体をレジスタに返す。

@opindex fpcc-struct-return
@option {-fpcc-struct-return}オプションを指定して返されるすべての構造体および共用体に対して、互換性のある規約を使用するようにGCCに指示できる。

@cindex preprocessing tokens
@cindex preprocessing numbers
@item
GCCは、@samp{0x74ae-0x4000}のようなマイナス演算子で区切られた2つの16進定数のように見えるプログラムフラグメントについて文句を言う。 実際には、この文字列は単一の@dfn{preprocessing token}（前処理トークン）である。 このような各トークンは、C内の1つのトークンに対応しなければならない。 これはしていないので、GCCはエラーメッセージを表示する。 オペレータと2つの値が意味されていることは明らかだが、ISO C標準では、特にこれが誤ったものとして扱われることを要求している。

@dfn{preprocessing token}（前処理トークン）は、数字で始まり、文字、アンダースコア、数字、ピリオド、@samp{e+}、@samp{e-}、@samp{E+}、@samp{E-}、@samp{p+}、@samp{p-}、@samp{P+}、または@samp{P-}の文字シーケンスである。 （厳密なC90モードでは、シーケンス@samp{p+}、@samp{p-}、@samp{P+}と@samp{P-}は前処理番号に現れない）

上記のプログラムフラグメントを有効にするには、空白をマイナス記号の前に置く。 この空白は前処理番号を終了する。
@end itemize

@node Fixed Headers
@section 修正されたヘッダファイル

GCCはいくつかのシステムヘッダファイルの修正版をインストールする必要がある。 これは、ほとんどのターゲットシステムには、変更されない限り、GCCで動作しないヘッダファイルがいくつかあるためである。 バグを持つものもあれば、ISO Cと互換性がないものもあれば、他のコンパイラの特殊機能に依存するものもある。

GCCをインストールすると、@code{fixincludes}というプログラムを実行することによって、固定ヘッダファイルが自動的に作成され、インストールされる。 通常、これに注意する必要はない。 しかし、自動的に正しいことをしないケースがある。

@itemize @bullet
@item
新しいシステムバージョンをインストールするなど、システムのヘッダーファイルを更新すると、GCCの固定ヘッダーファイルは自動的に更新されない。 @file{@var{libexecdir}/gcc/@var{target}/@var{version}/install-tools/}にインストールされている@command{mkheaders}スクリプトを使用して更新できる。

@item
いくつかのシステムでは、ヘッダーファイルのディレクトリには、特定の場所にマシン固有のシンボリックリンクが含まれている。 これにより、異なるマシンモデル上の同じバージョンのシステムを実行しているホスト間でほとんどのヘッダーファイルを共有することができる。

ヘッダーファイルを修正するプログラムは、シンボリックリンクを使用するこの特別な方法を理解していない。 したがって、固定ヘッダファイルのディレクトリは、それを構築するために使用されたマシンモデルに対してのみ有効である。

異なるマシンモデル用の固定ヘッダーファイルを別々に作成し、適切なセットを使用するようにシンボリックリンクの構造を調整することは可能だが、手動で行う必要がある。
@end itemize

@node Standard Libraries
@section 標準ライブラリ

@opindex Wall
GCCはそれ自体、自立的実装の適合を試みている。これが何を意味するかについては、@xref{Standards、GCCでサポートされている言語標準}を参照せよ。 このような実装に必要なライブラリの機能以外にも、Cライブラリの残りの部分はオペレーティングシステムのベンダーによって提供される。 そのCライブラリがCの標準に準拠していない場合、あなたのプログラムは警告を受け取ることがある（特に、@option{-Wall}を使用する場合）。

たとえば、SunOS 4.1.3の@code{sprintf}関数は@code{char *}を返すが、C標準では@code{sprintf}は@code{int}を返す。 @code{fixincludes}プログラムは、この関数のプロトタイプをStandardと一致させることができるが、それでも関数は@code{char *}を返すので間違っている。

標準準拠ライブラリが必要な場合は、GCCが提供していないライブラリを検索する必要がある。 GNU Cライブラリ（@code{glibc}）は、GNU/LinuxおよびHURDベースのGNUシステム用のISO C、POSIX、BSD、SystemV、X / Openの互換性を提供する。 最近のバージョンでは他のシステムをサポートしていないが、非常に古いバージョンがしていた。 GNU Cライブラリのバージョン2.2には、ほぼ完全なC99サポートが含まれている。 新しいライブラリが利用可能かどうかは、オペレーティングシステムのベンダーに問い合わせることもできる。

@node Disappointments
@section 失望と誤解

これらの問題はおそらく残念だが、私たちはそれに関する実用的な方法を知らない。

@itemize @bullet
@item
最適化を使用してコンパイルすると、特定のローカル変数がデバッガによって認識されない。

これは、時々GCCが変数を最適化するために発生する。 デバッガにそのような変数が「持っていた」値を計算する方法を伝える方法はなく、とにかくそれが望ましいともはっきりしていない。 そこで、GCCは、デバッグ情報を書き込むときに排除された変数について言及しない。

最適化を使用するときは、実行可能ファイルとソースコードの間にある程度の不一致が予想される。

@cindex conflicting types
@cindex scope of declaration
@item
GCCが次のようなコードでエラーを報告すると、ユーザはしばしばバグだと思う：

@smallexample
int foo (struct mumble *);

struct mumble @{ @dots{} @};

int foo (struct mumble *x)
@{ @dots{} @}
@end smallexample

プロトタイプの@code{struct mumble}のスコープはそれを含む引数リストに限定されているので、このコードは本当に間違っている。 これは、すぐ下のファイルスコープで定義された@code{struct mumble}を参照するものではない。スコープの異なる類似の名前の2つの無関係な型である。

しかし、@code{foo}の定義では、それが引き継いで利用可能であるのでファイルスコープタイプが使用される。 したがって、定義とプロトタイプが一致せず、エラーが発生する。

この動作はばかげて見えるかもしれないが、ISO規格で規定されている。 @code{struct mumble}の定義をプロトタイプの上に移動することで、コードを動作させるのは簡単である。 上の例のエラーを避けるために、ISO Cとの互換性がなくす価値はない。

@item
揮発性オブジェクトであってもビットフィールドへのアクセスは、バイトやワードなどのより大きなオブジェクトにアクセスすることで機能する。 ビットフィールドを読み書きするためにアクセスするオブジェクトのサイズに依存することはできない。 それは、正確な使用法に従って、所与のビットフィールドについてさえ変化するかもしれない。

アクセスされるメモリの量を気にする必要がある場合は、volatileを使用し、ビットフィールドは使用してはならない。

@item
GCCには、システムヘッダファイルの既知の問題を解決するためのシェルスクリプトが付属している。 それらはGCCだけが特別なディレクトリを探し出す特別なディレクトリに、さまざまなヘッダファイルの修正されたコピーをインストールする。 スクリプトは、私たちが知っている問題のケースについて、すべてのシステムヘッダファイルを検索することによって、さまざまなシステムに適応する。

新しいシステムヘッダファイルがインストールされている場合、修正されたヘッダファイルを自動的に更新することはない。 @file{@var{libexecdir}/gcc/@var{target}/@var{version}/install-tools/}にインストールされている@command {mkheaders}スクリプトを使用して更新できる。

@item
@cindex floating point precision
たとえば、68000およびx86システムでは、浮動小数点数の正確な値をテストすると逆説的な結果が得られる。 たとえば、NaNではない浮動小数点値がそれ自身と等しくないことがわかる。 これは、浮動小数点レジスタがメモリ内の@code{double}に収まる精度よりも少し高い精度を保持しているためである。 コンパイルされたコードは、都合の良いときにメモリと浮動小数点レジスタの間で値を移動し、それらをメモリに移動すると、それらを切り捨てる。

@opindex ffloat-store
@option{-ffloat-store}オプション（@pxref{Optimize Options}）を使うと、この問題を部分的に回避できる。

@item
AIXや弱いシンボルをサポートしない他のプラットフォームでは、テンプレートを明示的にインスタンス化する必要があり、テンプレートの静的メンバーのシンボルは生成されない。

@item
AIXでは、GCCは、リンカーが参照されていないシンボルをプルーニングする前に、アプリケーションをリンクするときに静的コンストラクターとデストラクタのオブジェクトファイルとライブラリアーカイブをスキャンする。 これは、AIXリンカーが、静的コンストラクターまたはデストラクタが未使用であると誤って判断し、スキャンを実行する前にそれらを削除しないようにするために必要である。 見つかったすべての静的コンストラクタとデストラクタは、それらのモジュールがプログラムによって使用されない場合でも参照される。 これにより、実行可能なサイズが大きくなり、予期しないシンボル参照が発生する可能性がある。
@end itemize

@node C++ Misunderstandings
@section GNU C++でのよくある誤解

@cindex misunderstandings in C++
@cindex surprises in C++
@cindex C++ misunderstandings
C ++は複雑な言語であり、進化していて、その標準定義（ISO C ++標準）は最近完成したばかりである。 その結果、あなたのC++コンパイラは、その動作が正しい時でさえあなたを驚かせるかもしれない。 このセクションでは、この種の問題を頻繁に引き起こすいくつかの分野について説明する。

@menu
* Static Definitions::  静的メンバ宣言は定義ではない
* Name lookup::         名前検索、テンプレート、基底クラスのメンバのアクセス
* Temporaries::         一時値は予期したよりも前に消えるかもしれない
* Copy Assignment::     コピー代入演算子は仮想基底を２度コピーする
@end menu

@node Static Definitions
@subsection 静的メンバの宣言@emph{と}定義

@cindex C++ static data, declaring and defining
@cindex static data in C++, declaring and defining
@cindex declaring static data in C++
@cindex defining static data in C++
クラスに静的データメンバーがある場合、静的メンバーを@emph{宣言}するだけでは不十分である。それを@emph{定義}する必要もある。 例えば：

@smallexample
class Foo
@{
  @dots{}
  void method();
  static int bar;
@};
@end smallexample

この宣言は、@code{Foo}クラスが@code{Foo::bar}という名前の@code{int}と@code{Foo::method}という名前のメンバ関数を持つことのみを確立する。 しかし、@emph{メソッド}と@code{bar}を別の場所で定義する必要がある。 ISO標準によると、次のような1つのソースファイルでイニシャライザを指定する必要がある。

@smallexample
int Foo::bar = 0;
@end smallexample

他のC++コンパイラは、標準的な動作を正しく実装していないかもしれない。 結果として、これらのコンパイラの1つから@command{g++}に切り替えると、実際に正常に動作するように見えるプログラムが標準に準拠していないことがわかる。@command{g++}は、定義のない静的データメンバーを未定義シンボルとして報告する。


@node Name lookup
@subsection  名前検索、テンプレート、基底クラスのメンバのアクセス

@cindex base class members
@cindex two-stage name lookup
@cindex dependent name lookup

C++標準では、テンプレート関数またはクラスの解析時に、テンプレートパラメータに依存しないすべての名前が現在の定義にバインドされていることが規定されている。@footnote{C++標準では、テンプレートパラメータの型または値に依存する名前に"依存している"という用語を使用している。 この短い用語は、このセクションの残りの部分でも使用される。} 依存している名前のみがインスタンス化の時点で参照される。 たとえば、

@smallexample
  void foo(double);

  struct A @{
    template <typename T>
    void f () @{
      foo (1);        // @r{1}
      int i = N;      // @r{2}
      T t;
      t.bar();        // @r{3}
      foo (t);        // @r{4}
    @}

    static const int N;
  @};
@end smallexample

ここで、@code{foo}と@code{N}という名前は、@code{T}のタイプに依存しないコンテキスト内に現れる。 したがって、コンパイラは、インスタンス化のポイントの前だけでなく、テンプレートでの使用のコンテキストで定義されていることを要求し、ここではそれぞれ、@code{::foo(double)}と@code{A::N}を使用する。  特に、整数値を@code{::foo(double)}に渡すときに整数値を@code {double}に変換する。

逆に、@code{bar}と4番目のマーク付き行の@code{foo}への呼び出しは、@code{T}の型に依存するコンテキストで使用されるため、インスタンス化の時点でのみ検索され、 テンプレートを宣言した後、インスタンス化する前に宣言を提供することができる。 特に、@code{A::f<int>}をインスタンス化すると、最後の行は@code{struct A}の宣言の後であっても、オーバーロードされた@code{: foo(int)}が提供されていればそれを呼び出す。

従属名と非従属名の参照の区別は、2段階（または依存）の名前参照と呼ばれる。 G++はバージョン3.4からそれを実装している。

2段階の名前検索では、テンプレート以外のコードとは異なる動作が発生することがある。 最も一般的なのはおそらくこれである：

@smallexample
  template <typename T> struct Base @{
    int i;
  @};

  template <typename T> struct Derived : public Base<T> @{
    int get_i() @{ return i; @}
  @};
@end smallexample

@code{get_i()}では、@code{i}は従属コンテキストでは使用されないので、コンパイラは囲む名前空間スコープ（ここではグローバルスコープ）で宣言された名前を探す。 これは依存しているので、基本クラスを調べない。@code{Derived}を宣言した後でも、@code{Base}の特殊化を宣言することができるので、コンパイラは@code{i}が参照するものを本当に知ることができない。 グローバル変数@code{i}がない場合は、エラーメッセージが表示される。

基本クラスのメンバーが必要であることを明確にするために、基本クラスが分かっているインスタンス化時点までルックアップを延期する必要がある。 このためには、@code{this->i}（@code{this}は@code{Derived<T>*}型であり、明らかに依存していることを思い出す）か、または@code{Base<T>::i}のどちらかを使って、依存コンテキストで@code{i}にアクセスする必要がある。 代わりに、@code{Base<T>::i}を@code{using}宣言でスコープに入れることもできる。

別の同様の例では、基本クラスのメンバー関数を呼び出すことがある。

@smallexample
  template <typename T> struct Base @{
      int f();
  @};

  template <typename T> struct Derived : Base<T> @{
      int g() @{ return f(); @};
  @};
@end smallexample

ここでも、@code{f()}の呼び出しはテンプレート引数に依存しない（@code{T}の型に依存する引数はなく、呼び出しが依存コンテキストにないはずである）。 したがって、そのような関数のグローバル宣言は、基本クラスのインスタンスがインスタンス化時間まで可視ではないため、利用可能でなければならない。 結果的に、コンパイラは次のエラーメッセージを生成する。

@smallexample
  x.cc: In member function `int Derived<T>::g()':
  x.cc:6: error: there are no arguments to `f' that depend on a template
     parameter, so a declaration of `f' must be available
  x.cc:6: error: (if you use `-fpermissive', G++ will accept your code, but
     allowing the use of an undeclared name is deprecated)
@end smallexample

コードを有効にするには、@code{this->f()}または@code{Base<T>::f()}を使用する。 @option{-fpermissive}フラグを使用すると、インスタンス化時に後で参照するためのテンプレートの定義時に、宣言が表示されていないすべての関数呼び出しを、依存呼び出しかのようにマーキングすることによって、コンパイラにコードを受け付けることができる。 無効なコードを回避するために@option{-fpermissive}を使用することはお勧めできません。また、上記の例のように、基本クラスの変数が使用される場所ではなく、基本クラスの関数が呼び出されるケースだけを検出する。

いくつかのコンパイラ（3.4より前のG++バージョンを含む）では、これらの例が間違っていて、上記のコードをエラーなく受け入れることに注意せよ。 これらのコンパイラは、2段階の名前検索を正しく実装していない。


@node Temporaries
@subsection 一時値はあなたが期待する前に消えるかもしれない

@cindex temporaries, lifetime of
@cindex portions of temporary objects, pointers to
一時オブジェクトの@emph{部分}へのポインタや参照を使うのは危険である。 コンパイラは、予期する前にオブジェクトをすっかり削除し、ポインタをゴミとして残すかもしれない。 この問題が発生する最も一般的な場所は、文字列クラスのようなクラスである。特に、@code{char *}や@code{const char *}を入力する変換関数を定義するものである。これが、標準@code{string}クラスでは、@code{c_str}メンバ関数を呼び出す必要がある理由のひとつである。 しかし、内部構造体へのポインタを返すクラスであれば、この問題が発生する可能性がある。

例えば、プログラムは@code{string}オブジェクトを返す関数@code{strfunc}と、@code{char}へのポインタで動作する別の関数@code{charfunc}を使うかもしれない

@smallexample
string strfunc ();
void charfunc (const char *);

void
f ()
@{
  const char *p = strfunc().c_str();
  @dots{}
  charfunc (p);
  @dots{}
  charfunc (p);
@}
@end smallexample

@noindent
このような状況では、@code{c_str}メンバ関数から返されたC文字列へのポインタを保存し、@code{c_str}を繰り返し呼び出すのではなく、そのポインタを使用するのが妥当と思われるかもしれない。 しかし、@code {strfunc}の呼び出しによって作成された一時的な文字列は、@code{p}が初期化された後に破棄される。

このようなコードは、通常のローカル変数とともに一時値を削除する、古くなったcfrontベースのコンパイラなど、他のコンパイラでは正常に動作する可能性がある。 しかし、GNU C++の動作は標準に準拠しているので、プログラムが一時的なものの遅い破壊に依存している場合、移植性がない。

そのようなコードを書くための安全な方法は、一時的な名前を付けることで名前のスコープの終わりまでそれを強制的に残すことである。 例えば：

@smallexample
const string& tmp = strfunc ();
charfunc (tmp.c_str ());
@end smallexample

@node Copy Assignment
@subsection 仮想基底の暗黙のコピー代入

基本クラスが仮想の場合、基本クラスの1つのサブオブジェクトのみが各完全オブジェクトに属する。 また、コンストラクタとデストラクタは一度だけ呼び出され、最も派生したクラスから呼び出される。 ただし、そのようなオブジェクトは代入時には未規定の振る舞いをする。 例えば：

@smallexample
struct Base@{
  char *name;
  Base(char *n) : name(strdup(n))@{@}
  Base& operator= (const Base& other)@{
   free (name);
   name = strdup (other.name);
  @}
@};

struct A:virtual Base@{
  int val;
  A():Base("A")@{@}
@};

struct B:virtual Base@{
  int bval;
  B():Base("B")@{@}
@};

struct Derived:public A, public B@{
  Derived():Base("Derived")@{@}
@};

void func(Derived &d1, Derived &d2)
@{
  d1 = d2;
@}
@end smallexample

C ++標準では、@samp{Base::Base}はDerivedオブジェクトを構築またはコピーするときに一度しか呼び出されないことを指定している。 例の@samp{func}の中にあるように、派生オブジェクトの暗黙のコピー代入が呼び出されたときに、@samp{Base::operator=}が複数回呼び出されるかどうかは不明である。

G++は、コピー割り当てのための「直感的な」アルゴリズムを実装している。すべての直接基底を代入し、すべてのメンバーを代入する。 このアルゴリズムでは、仮想基底のサブオブジェクトに複数回出会う可能性がある。 この例では、@samp{val}、@samp{name}（@code{strdup}経由で）、@samp{bval}、@samp{name}の順にコピーが進行する。

アプリケーションコードがコピー代入に依存する場合、ユーザ定義のコピー代入演算子は不確実性を取り除く。 このような演算子を使用すると、アプリケーションは仮想基底サブオブジェクトの割り当ての有無とその方法を定義できる。

@node Non-bugs
@section 私たちがしたくない変更

このセクションでは、人々が頻繁に要求するが、GCCにない方がよいと考えているため、私たちは行っていない変更をリストアップしている。

@itemize @bullet
@item
昔ながらの定義を持ち、プロトタイプを持たない関数の引数の数と型を調べる。

このような機能は、定義に続いて、呼び出された関数と同じファイルに表示される呼び出しに対してのみ、ときどき動作する。 すべての呼び出しを確実にチェックする唯一の方法は、関数のプロトタイプを追加することである。 しかし、プロトタイプを追加することで、この機能の動機づけがなくなる。 だからこの機能は価値がない。

@item
型がシフト・カウントとして符号付きの式を使用することについての警告。

おそらく、シフト・カウント・オペランドは、符号なしよりも符号ありのほうが多い。これについての警告は、善よりもはるかに面倒を引き起こすであろう。

@item
符号なしの値に符号付きの値を代入することについての警告。

そのような代入は間違いなく非常にありふれている。 それらについての警告は善よりも迷惑を引き起こすであろう。

@item
非void関数の値が無視されるときの警告。

Cには、ほとんどのプログラムが無視する値を返す多くの標準関数が含まれている。 1つの明白な例は@code{printf}である。 この実例についての警告は、防御プログラマーが何十回も@code{void}にキャストしてプログラムを乱雑にしてなるだけである。そのようなキャストは非常に頻繁に必要とされ、視覚的ノイズとなる。 これらのキャストを書くことはとても自動化され、プログラマーの意図についての有益な情報をもはや伝えない。 戻り値を決して無視すべきではない関数の場合、@code{warn_unused_result}関数属性（@pxref {Function Attributes}）を使うこと。

@item
@opindex fshort-enums
@option {-fshort-enums}をデフォルトにする。

これにより、ストレージレイアウトは他のほとんどのCコンパイラと互換性がなくなる。 同じ結果を他の方法で得ることができるので、それは非常に重要とは思われない。 最も重要なのは、列挙型オブジェクトが構造体の内部にある場合である。この場合、フィールド幅を明示的に指定できる。

@item
「ABI標準」がそうするように言われている特定のマシンでは、デフォルトでビットフィールドを符号なしにする。

ISO C標準は、@code{int}が明示的に宣言されているビットフィールドが符号付きかどうかを実装に任せる。 これは事実上、Cの2つの代替変種を生成する。

@opindex fsigned-bitfields
@opindex funsigned-bitfields
GNU Cコンパイラは両方の変種をサポートしている。 @option{-fsigned-bitfields}と@option{-funsigned-bitfields}で符号の変種を指定することができる。 しかし、これはデフォルトでどの変種を使うべきかという疑問を残す。

現在のところ、この変種の方が単純なので、プレーンなビットフィールドは符号つきにする。 @code{int}は他のすべてのコンテキストで@code{signed int}と同じなので、ビットフィールドでも同じであることが最もきれいである。

いくつかのコンピュータ製造業者は、プレーンビットフィールドが符号なしであるべきであることを指定するアプリケーションバイナリインタフェース規格を公開している。 しかし、ABIでこの問題について何か言っているのは間違いである。 これは、単純なビットフィールドの扱いがCの2つの変種を区別するためである。どちらの変種も、あらゆるタイプのマシンで意味がある。 同じデータ構造内の同じビットフィールドにアクセスしても、特定のオブジェクトファイルが符号付きビットフィールドを使用してコンパイルされたか、符号なしででされたかは無関係である。

与えられたプログラムは、これら2つの変種の一方または他方に書き込まれる。 このプログラムは、適切な変種でコンパイルされている場合、ほとんどのマシンで動作する可能性がある。 間違った方言でコンパイルすると、まったく動作しない可能性がある。

GNU Cコンパイラは、マシン間で統一された環境を提供するため、多くのユーザがGNU Cコンパイラを高く評価している。 これらのユーザは、コンパイラが特定のマシン上でプレーンビットフィールドを別々に扱う場合には不便である。

ユーザーは、特定のマシンタイプのみを対象としたプログラムを作成することがある。 このような場合、GNU Cコンパイラが、デフォルトで、そのマシン上の他のコンパイラと同じ変種をサポートしていれば、ユーザは利益を得るだろう。 しかし、そのようなアプリケーションはまれである。 また、複数のタイプのマシンで動作するプログラムを作成しているユーザーは、この種の互換性の恩恵を受けることはできない。

このため、GCCは（デフォルトで）すべてのタイプのマシンで同じ方法でプレーンビットフィールドを処理する。

ビットフィールドをデフォルトですべてのマシンで符号なしにするための引数がいくつかある。 例えば、これが普遍的なデファクトスタンダードになった場合、GCCがそれに沿って進むことは理にかなっている。 これは将来考えられるものである。

（もちろん、移植性を強く心配しているユーザは、各ビットフィールドに、符号ありかどうかを明示的に示す必要がある。こうして、両方のC言語で同じ意味を持つプログラムを作成する。）

@item
@opindex ansi
@opindex std
@option {-ansi}が使用されていない場合は、@code {__ STDC__}の定義を解除する。

現在、GCCは無条件に@code{__STDC__}を定義している。 これは、実際に良好な結果をもたらす。

プログラマは、通常、関数プロトタイプやISOトークン連結など、ISO Cの特定の機能を使用するのが安全かどうかを尋ねるために、@code{__ STDC__}の条件を使用する。素の@command{gcc}はISO Cのすべての機能をサポートしているので、これらの質問に対する正解は「はい」である。

一部のユーザーは、@code{__STDC__}を使用して、特定のライブラリ機能の可用性をチェックしようとする。 これは、実際にはISO Cプログラムで誤った使い方である。ISO C標準では、ライブラリー機能を持たないにもかかわらず、適合する自立実装で@code{__STDC__}を定義する必要があるためである。 @samp{gcc -ansi -pedantic}は準拠した自立実装であるため、ISO Cライブラリが付属していないにもかかわらず、@code{__STDC__}を定義する必要がある。

時々ISO C標準に完全に準拠していないコンパイラで@code {__ STDC__}を定義すると、何らかの形で規格に違反してしまうことがあると言われる。 これは非合理である。 標準は@samp{gcc -ansi}のようなISO Cをサポートすると主張するコンパイラの標準であり、プレーン@command {gcc}のような他のコンパイラのものではないということになる。ISO C標準が言うことは何でも、@option{-ansi}のない単純な@command{gcc}の設計に関係していて、要求ではない。

GCCは通常、@code{__STDC__}を1と定義し、ISO Cのあるバージョンに厳密に準拠させるために@option{-ansi}オプションまたは@option{-std}オプションを指定する場合は@code{__STRICT_ANSI__}を定義する。いくつかのホストでは、システムインクルードファイルでは、@code{__ STDC__}は通常0であるが、ユーザーがC標準に厳密に準拠していると指定した場合は1である。 GCCはシステムインクルードファイルを処理する際にホスト規約に従うが、ユーザファイルを処理するときは通常のGNU C規約に従う。

@item
C++で@code{__STDC__}の定義を解除する。

C++からCへの変換プログラムでコンパイルするために書かれたプログラムは、後で使用されるCコンパイラに付属する@code{__STDC__}の値を取得する。 これらのプログラムは、コンパイラがどのような種類のCプリプロセッサを使用するかを決定するために@code{__STDC__}をテストしなければならない：ISO C形式または従来の形式でトークンを連結する必要があるかどうか。

これらのプログラムは、@code{__STDC__}が定義されている場合、GNU C++で適切に動作する。そうでなければ働かない。

さらに、ISO Cではプロトタイプを提供するために多くのヘッダファイルが記述されているが、従来のCではプロトタイプを提供していない。これらのヘッダファイルの多くは、@code{__ STDC__}が定義されていればC++で変更することなく動作する。 @code{__STDC__}が定義されていない場合、それらはすべて失敗し、C++のために明示的にテストするために変更する必要がある。

@item
「空の」ループを削除する。

歴史的に、GCCは、あなたがプログラムに入れようとするもっともらしい理由が遅延であり、それらを削除しても、実際のプログラムを速く走らせることはできないと仮定して、 「空の」ループを削除していない。

しかしながら、ここでの理論的根拠は、空でないループの最適化が空ではないことである。 これは、より強力ではないオプティマイザでコンパイルされた慎重に書かれたCで保持されるが、注意深く書かれたC++やより強力なオプティマイザで常にそうとは限らない。 したがって、GCCは、それらの操作が外部から見ることができないと判断できるときはいつでもループから操作を削除する（もちろんそれらを実行するのに時間は別である）。 ループが有限であることが証明できる場合、GCCはループ自体も削除する。

タイミングテストを実行するときに注意せよ。例えば、@code{some_expression}がどのようなグローバル状態も変更しないので、次のループは完全に削除される。

@smallexample
@{
   int sum = 0;
   int ix;

   for (ix = 0; ix != 10000; ix++)
      sum += some_expression;
@}
@end smallexample

ループ内に@code{sum}が累積されていても、その集計は使用されないので、加算を削除することができる。

@item
他のコンパイラと同じ順序で副作用を起こす。

@cindex side effects, order of evaluation
@cindex order of evaluation, side effects
副作用の評価の順序に依存することは決して安全ではない。 たとえば、このような関数呼び出しでは、あるコンパイラと別のコンパイラで異なる動作をする可能性がある。

@smallexample
void func (int, int);

int i = 2;
func (i++, i++);
@end smallexample

インクリメントが特定の順序で評価されることは保証されていない（CまたはC++標準言語定義のいずれかでも）。 いずれかのインクリメントが最初に起こるかもしれない。 @code{func}は引数@samp{2,3}を得るかもしれないし、@samp{3,2}、あるいは@samp{2,2}を得るかもしれない。

@item
既定では、特定の警告にエラーが発生させる。

一部のISO Cテストスイートでは、コンパイラが特定のプログラムのエラーメッセージを生成しない場合にエラーが報告される。

@opindex pedantic-errors
ISO Cでは、特定の種類の無効なプログラムに対しては「診断」メッセージが必要だが、警告はGCCによって診断としてカウントするように定義されている。 GCCが警告を出してもエラーは発生しない場合、それは正しいISO Cのサポートである。 テストスイートがこの「失敗」を呼び出す場合は、GCCオプションの@option{-pedantic-errors}を実行して、これらの警告をエラーにする必要がある。

@end itemize

@node Warnings and Errors
@section 警告メッセージとエラーメッセージ

@cindex error messages
@cindex warnings vs errors
@cindex messages, warning and error
GNUコンパイラは、エラーと警告という2種類の診断を生成することができる。 それぞれの種類は異なる目的を持っている：

@itemize @w{}
@item
@dfn{Errors}（エラー）はプログラムをコンパイルできない問題を報告する。 GCCは、問題が明らかなソースファイル名と行番号でエラーを報告する。

@item
@dfn{Warnings}（警告）は、コード内で問題を示す@emph{可能性がある}がコンパイルは続行できる（そして実行する）他の異常な状態を報告する。 警告メッセージはソースファイル名と行番号も報告するが、エラーメッセージと区別するために@samp{warning:}というテキストを含む。
@end itemize

警告は、あなたのプログラムがあなたが意図したことを本当にしていることを確認するためにチェックすべき危険点を示すかもしれない。 または古くなった機能の使用、及びGNU CまたはC++の非標準機能を使用する場合。 @option{-Wall}がさまざまな有用な警告を要求するなど、@option{-W}オプションの1つを使用すると、多くの警告が発行される。

@opindex pedantic
@opindex pedantic-errors
可能であれば、GCCは常にあなたのプログラムをコンパイルしようとする。意味が明確なプログラムを（例えば）単にそれが規格に準拠していないために無償で拒絶することは決してない。 しかし、場合によっては、CおよびC++標準では、特定の拡張が禁止されていることを指定しており、適合するコンパイラによって診断を発行する@emph{必要がある}。  @option{-pedantic}オプションは、このような場合に警告を出すようにGCCに指示する。 @option{-pedantic-errors}は、それらの代わりにエラーを出すと言う。 これは、@ emph{すべての}非ISO構造が警告またはエラーを受け取ることを意味しない。

これらとそれに関連したコマンドラインオプションの詳細は@xref{Warning Options,,Options to Request or Suppress Warnings}
