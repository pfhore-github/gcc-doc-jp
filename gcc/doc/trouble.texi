@c Copyright (C) 1988-2018 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node Trouble
@chapter GCCの問題の既知の原因
@cindex bugs, known
@cindex installation trouble
@cindex known causes of trouble

このセクションでは、GCCのユーザーに影響する既知の問題について説明する。 これらのほとんどはGCCのバグではない。もしそうならば、修正されているだろう。 しかし、ユーザーにとっての結果は、バグの結果のようなものかもしれない。

これらの問題のいくつかは、他のソフトウェアのバグに起因するものもあれば、追加するにはあまりにも多くの作業が欠けているものもあれば、最良のものについて人々の意見が異なるところもある。

@menu
* Actual Bugs::         あとで修正する予定のバグ
* Interoperation::      他のコンパイラ、あるリンカ、アセンブラ、デバッガとともにGCCを使ったときの問題
* Incompatibilities::   GCCは伝統的なCと非互換である
* Fixed Headers::       GCCはシステムヘッダファイルの修正されたバージョンを使う。
                        これは必須だが、いつもスムーズに動くわけではない
* Standard Libraries::  GCCはシステムCライブラリを使うが、それはISO C標準に準拠していないかもしれない
* Disappointments::     残念なことに我々は変更できないが、全くのバグではない
* C++ Misunderstandings:: GNU C++でのよくある誤解
* Non-bugs::            我々は正しいと考えているが、同意していない人もいる
* Warnings and Errors:: 警告を出す問題とエラーを出す問題
@end menu

@node Actual Bugs
@section まだ修正していない実際のバグ

@itemize @bullet
@item
@code{fixincludes}スクリプトはオートマウンタとうまくやり取りしない。 システムヘッダファイルのディレクトリが自動マウントされていると、@ code{fixincludes}の実行中にアンマウントされる傾向がある。 これはオートマウンタのバグのようである。 我々はそれを回避する良い方法を知らない。
@end itemize

@node Interoperation
@section 相互運用

このセクションでは、他のコンパイラやアセンブラ、リンカ、ライブラリ、特定のシステム上のデバッガと一緒にGCCを使用する際に遭遇するさまざまな問題をリストする。

@itemize @bullet
@item
多くのプラットフォームでは、GCCは他のコンパイラとは異なるC++用ABIをサポートしているため、GCCでコンパイルされたオブジェクトファイルは別のC++コンパイラで生成されたオブジェクトファイルでは使用できない。

違いが最も顕著な領域は名前のマングリングである。 より微妙な問題からあなたを守るために、異なる名前のマングリングの使用は意図的である。コンパイラは、クラスインスタンスのレイアウト方法、多重継承の実装方法、仮想関数呼び出しの処理方法など、C++実装の多くの内部的な詳細について異なる。 名前のエンコーディングが同じになった場合、あなたのプログラムは他のコンパイラから提供されたライブラリとリンクするが、実行するとプログラムがクラッシュする。 互換性のないライブラリは、実行時ではなくリンク時に検出される。

@item
Ultrixのいくつかのバージョンを含むいくつかのBSDシステムでは、プロファイリングを使用すると、静的変数デストラクタ（現在はC++でのみ使用されている）が実行されなくなる。

@item
SPARCでは、GCCは8バイト境界で@code{double}型のすべての値を整列させ、すべての@code{double}がそのように整列することを期待している。 Sunコンパイラは通常、@code{double}の値に8バイトのアライメントを与えるが、1つの例外がある：@code{double}型の関数の引数は整列されないかもしれない。

その結果、Sun CCでコンパイルされた関数が@code{double}型の引数のアドレスを受け取り、このコードを@code{double *}の型にGCCでコンパイルされた関数に渡すと、ポインタの逆参照により致命的なシグナルを起こすかもしれない。

この問題を解決する1つの方法は、プログラム全体をGCCでコンパイルすることである。 別の解決策は、引数をローカル変数にコピーするためにSun CCでコンパイルされた関数を変更することである。 ローカル変数は常に正しく整列される。 3番目の解決方法は、直接@samp{*}ではなく、次の関数@code{access_double}を使用してポインタを使用する関数を参照解除することである。

@smallexample
inline double
access_double (double *unaligned_ptr)
@{
  union d2i @{ double d; int i[2]; @};

  union d2i *p = (union d2i *) unaligned_ptr;
  union d2i u;

  u.i[0] = p->i[0];
  u.i[1] = p->i[1];

  return u.d;
@}
@end smallexample

@noindent
ポインターへの格納は、同じユニオンで同様に行うことができる。

@item
Solarisでは、@file{libmalloc.a}ライブラリの@code{malloc}関数は、4バイトだけのアラインメントのメモリを割り当てる。 SPARCのGCCでは、倍精度が8バイト境界になっていると仮定しているため、倍精度が@file{libmalloc.a}ライブラリによって割り当てられたメモリに格納されていると、致命的なシグナルが発生する可能性がある。

解決策は、@file{libmalloc.a}ライブラリを使用しないことである。 @file{libc.a}の@code{malloc}や関連する関数を使用すること。それらはこの問題を抱えていない。

@item
HP PAマシンでは、GCCでコンパイルされた関数でADBが動作しないことがある。 具体的には、@code{alloca}や可変長配列を使用する関数では機能しない。 これは、GCCがそのような機能のHP-UX unwind descriptorを生成しないためである。 それを生成することは不可能かもしれない。

@item
予備GNUツールを使用しない限り、デバッグ（@option{-g}）はHP PAマシンではサポートされていない。

@item
ラベルのアドレスをとると、HP-UX PAアセンブラからエラーが発生する可能性がある。 PAのGASにはこの問題はない。

@item
HPアセンブラを使用しているときは、静的関数への間接呼び出しに浮動小数点パラメータを使用しても機能しない。 GCCは、HPアセンブラを使用するときに、スタティック関数の引数を保持するレジスタを指定する方法がない。 PAのGASにはこの問題はない。

@item
非常に大きな関数がいくつか含まれている非常にまれなケースでは、範囲外のブランチオフセットについて不平を言うHPリンカからエラーを受け取ることがある。 これはGCCの以前のバージョンでより頻繁に発生していたが、現在はまれである。 それを実行する必要がある場合は、関数を小さくすることで回避できる。

@item
GCCコンパイルされたコードでは、次の形式のHP-UXアセンブラから警告が出力されることがある。

@smallexample
(warning) Use of GR3 when
  frame >= 8192 may cause conflict.
@end smallexample

これらの警告は無害であり、安全に無視することができる。

@item
非常に大きな関数がいくつか含まれている非常にまれなケースでは、大きすぎる変位について不平を言うAIXアセンブラからエラーを受け取ることがある。 それを実行する必要がある場合は、関数を小さくすることで回避できる。

@item
GCCの@file{libstdc++.a}ライブラリは、特にC++ストリーム機能に必要な、ライブラリとアプリケーション間のグローバルシンボルをマージするSVR4ダイナミックリンカのセマンティクスに依存している。 これは、AIX共有ライブラリーと動的リンクのデフォルトの動作ではない。@file{libstdc++.a}は、「ランタイムリンク」が有効になっているAIX上に構築されているため、シンボルのマージが可能である。 この機能を利用するには、@file{libstdc++.a}にリンクされているアプリケーションでリンク行に@option{-Wl,-brtl}フラグを含める必要がある。 G++はこれを強制することはできない。なぜなら、このオプションはユーザプログラムのセマンティクスを妨げる可能性があり、ユーザは@samp{g++}を使用してアプリケーションをリンクするとは限らない。アプリケーションは、リンク行で@option{-Wl,-brtl}フラグを使用する必要はない。シンボル統合のセマンティクスに依存しない残りの@file{libstdc++.a}ライブラリは引き続き正しく機能する。

@item
アプリケーションは、@file{libstdc++.a}で呼び出された関数の独自の関数定義を、AIXで使用可能な「ランタイム・リンク」に置き換えることができる。 これを実現するには、アプリケーションを「ランタイムリンク」オプションでリンクする必要があり、明示的にアプリケーションからエクスポートする必要がある（@option {-Wl,-brtl,-bE:exportfile}）。

@item
RS/6000上のAIXは、米国以外の環境でのサポート（NLS）を提供する。 コンパイラとアセンブラは、浮動小数点数（小数点を区切る文字が@samp{.}か@samp{,}）を含むさまざまなオブジェクトのロケール固有の表現をサポートするためにNLSを使用する。 GCCにリンクされたライブラリが、アセンブラが受け付けるのと同じ浮動小数点フォーマットを生成しないという問題が報告されている。 この問題がある場合は、環境変数@env{LANG}を@samp{C}または@samp {En_US}に設定する。

@item
@opindex fdollars-in-identifiers
@option{-fdollars-in-identifiers}を指定しても、IBMアセンブラの制限のためにRS/6000の識別子に@samp{$}を正常に使用することはできない。 GASはこれらの識別子をサポートしている。

@end itemize

@node Incompatibilities
@section GCCの非互換性
@cindex incompatibilities of GCC
@opindex traditional

GNU CとK＆R（非ISO）バージョンの間には、いくつかの非互換性がある。

@itemize @bullet
@cindex string constants
@cindex read-only strings
@cindex shared strings
@item
GCCは通常、文字列定数を読み取り専用にする。 同じ見た目の文字列定数が複数使用されている場合、GCCは文字列のコピーを1つだけ格納する。

@cindex @code{mktemp}, and constant strings
1つの結果として、文字定数の引数で@code {mktemp}を呼び出すことはできない。 関数@code{mktemp}は、引数が指す文字列を常に変更する。

@cindex @code{sscanf}, and constant strings
@cindex @code{fscanf}, and constant strings
@cindex @code{scanf}, and constant strings
もう1つの結果は、@code{sscanf}は、フォーマット制御文字列または入力として文字列定数を渡すと、非常に古いシステムでは動作しないということである。 これは、@code{sscanf}が文字列定数に誤って書き込もうとするためである。 @code{fscanf}と@code{scanf}も同様。

これらの問題を解決するには、文字列定数ではなく、これらの目的のために初期化文字列で@code{char}配列変数を使用するようにプログラムを変更することである。

@item
@code{-2147483648}は正である。

これは、2147483648が@code{int}型に収まりきらないためであり、（ISO Cの規則に従って）そのデータ型は@code{unsigned long int}である。 この値を否定すると、再び2147483648が返される。

@item
GCCは、文字列定数の内部に現れたときにマクロ引数を置換しない。 たとえば、GCCの次のマクロ

@smallexample
#define foo(a) "a"
@end smallexample

@noindent
は@var{a}の引数に関係なく、出力@code{"a"}を生成する。

@cindex @code{setjmp} incompatibilities
@cindex @code{longjmp} incompatibilities
@item
@code{setjmp}と@code{longjmp}を使用すると、有効であることが保証されている唯一の自動変数は@code{volatile}と宣言されたものである。 これは自動レジスタ割り付けの結果である。 この関数を考えてみる：

@smallexample
jmp_buf j;

foo ()
@{
  int a, b;

  a = fun1 ();
  if (setjmp (j))
    return a;

  a = fun2 ();
  /* @r{@code{longjmp (j)} may occur in @code{fun3}.} */
  return a + fun3 ();
@}
@end smallexample

ここで@code{a}は、@code{longjmp}が発生したときに最初の値に復元される場合とされない場合がある。 @code{a}がレジスタに割り当てられている場合、その最初の値が復元される。 それ以外の場合は、最後に保存された値を保持する。

@opindex W
@option{-W}オプションを@option{-O}オプションとともに使用すると、GCCがそのような問題が発生する可能性があると判断した場合に警告が表示される。

@item
マクロ引数の途中で前処理ディレクティブを使用するプログラムは、GCCでは動作しない。 たとえば、次のようなプログラムは動作しない。

@smallexample
@group
foobar (
#define luser
        hack)
@end group
@end smallexample

ISO Cはそのような構成を許可していない。

@item
K＆Rコンパイラは、コメントがインクルード境界（つまり、インクルードファイルで開始され、そのインクルードファイルで終了する）を横切るのを許可する。

@cindex external declaration scope
@cindex scope of external declarations
@cindex declaration scope
@item
ブロック内の外部変数および関数の宣言は、宣言を含むブロックにのみ適用される。 言い換えれば、それらは同じ場所で他の宣言と同じスコープを持っている。

他のCコンパイラでは、@code{extern}宣言は、ブロック内で発生したとしても残りのすべてのファイルに影響する。

@item
伝統的なCでは、以下に示すように@code{long}などをtypedef名と組み合わせることができる：

@smallexample
typedef int foo;
typedef long foo bar;
@end smallexample

ISO Cでは、これは許されない：@code{long}と他の型修飾子は明示的な@code{int}を必要とする。

@cindex typedef names as function parameters
@item
PCCでは、typedef名を関数パラメータとして使用できる。

@item
伝統的なCでは、次のような誤った宣言のペアを指定のスコープで一緒に表示できる。

@smallexample
typedef int foo;
typedef foo foo;
@end smallexample

@item
GCCは、識別子のすべての文字を有効として扱う。 K＆R-1（2.2）によると、「最初の8文字より後は重要ではないが、使うことはできる。」 また、K＆R-1（2.2）によると、「識別子は文字と数字のシーケンスで、最初の文字は文字でなければならない。下線_は文字としてカウントされる。」しかしGCCでは識別子でドル記号も使用できる。

@cindex whitespace
@item
PCCでは、@samp{+=}のような複合代入演算子の中間に空白を入れることができる。 GCCは、ISO標準に従って、これを許可していない。

@cindex apostrophes
@cindex @code{'}
@item
GCCは、失敗した前処理条件の中で、終端されていない文字定数について不平を言う。 一部のプログラムでは、条件付きで囲まれた英語のコメントが失敗することが保証されている。 これらのコメントにアポストロフィが含まれていると、GCCはおそらくエラーを報告する。 たとえば、次のコードではエラーが発生する。

@smallexample
#if 0
You can't expect this to work.
#endif
@end smallexample

このような問題に対する最良の解決策は、テキストを@samp{/*@dots{}*/}で区切られた実際のCコメントに入れることである。

@item
多くのユーザープログラムには、@samp{long time ();}という宣言が含まれている。 以前は、多くのシステムのシステムヘッダファイルは実際に@code{time}を宣言していなかったので、プログラムが返すと宣言したタイプは関係なかった。 しかしISO Cヘッダを持つシステムでは、@code{time}は@code {time_t}を返すと宣言され、それが@code{long}と同じでない場合、@samp{long time();}は間違っている。

解決策は、システムヘッダーファイルが宣言しているならば、プログラムが適切なシステムヘッダー（ISO Cヘッダーを持つシステムで@code{<time.h>}）を使用して@code{time}を宣言しないようにプログラムを変更するか、さもなければ@code{time}の戻り値の型として@code {time_t}を使用することである。

@cindex @code{float} as function value type
@item
@code{float}を返す関数をコンパイルするとき、PCCはそれをdoubleに変換する。 GCCは実際に@code{float}を返す。 PCCの互換性に関心がある場合は、@code{double}を返す関数を宣言する必要がある。あなたは同様に何を意図するかを言うべきである。

@cindex structures
@cindex unions
@item
構造体または共用体を返す関数をコンパイルするとき、GCC出力コードは通常、ほとんどのバージョンのUnixで使用されているものとは異なる方法を使用する。 その結果、GCCでコンパイルされたコードは、PCCでコンパイルされた構造体戻り関数を呼び出すことはできず、その逆できない。

GCCで使用される方法は、次のとおりである。1,2,4または8バイトの長さの構造体または共用体がスカラーのように返される。 他のサイズの構造体または共用体は、呼び出し元によって指定されたアドレスに格納される（通常、特殊な固定レジスタがあるが、一部のマシンではスタックに渡される）。 ターゲットフック@code{TARGET_STRUCT_VALUE_RTX}は、このアドレスをどこに渡すべきかをGCCに伝える。

対照的に、ほとんどのターゲットマシン上のPCCは、静的ストレージの領域にデータをコピーし、そのストレージのアドレスをポインタ値のように返すことによって、任意のサイズの構造体および共用体を返す。 呼び出し元は、そのメモリ領域から値が必要な場所にデータをコピーする必要がある。 この方法は遅く、非リエントラントなので、GCCではこの方法は使用しない。

より新しいいくつかのマシンでは、PCCはすべての構造体および共用体が戻ってくるための再入可能な規則を使用する。 これらのマシンの大部分のGCCは構造体と共用体をメモリに戻すときに互換性のある規約を使用するが、小さな構造体と共用体をレジスタに返す。

@opindex fpcc-struct-return
@option {-fpcc-struct-return}オプションを指定して返されるすべての構造体および共用体に対して、互換性のある規約を使用するようにGCCに指示できる。

@cindex preprocessing tokens
@cindex preprocessing numbers
@item
GCCは、@samp{0x74ae-0x4000}のようなマイナス演算子で区切られた2つの16進定数のように見えるプログラムフラグメントについて文句を言う。 実際には、この文字列は単一の@dfn{preprocessing token}（前処理トークン）である。 このような各トークンは、C内の1つのトークンに対応しなければならない。 これはしていないので、GCCはエラーメッセージを表示する。 オペレータと2つの値が意味されていることは明らかだが、ISO C標準では、特にこれが誤ったものとして扱われることを要求している。

@dfn{preprocessing token}（前処理トークン）は、数字で始まり、文字、アンダースコア、数字、ピリオド、@samp{e+}、@samp{e-}、@samp{E+}、@samp{E-}、@samp{p+}、@samp{p-}、@samp{P+}、または@samp{P-}の文字シーケンスである。 （厳密なC90モードでは、シーケンス@samp{p+}、@samp{p-}、@samp{P+}と@samp{P-}は前処理番号に現れない）

上記のプログラムフラグメントを有効にするには、空白をマイナス記号の前に置く。 この空白は前処理番号を終了する。
@end itemize

@node Fixed Headers
@section 修正されたヘッダファイル

GCCはいくつかのシステムヘッダファイルの修正版をインストールする必要がある。 これは、ほとんどのターゲットシステムには、変更されない限り、GCCで動作しないヘッダファイルがいくつかあるためである。 バグを持つものもあれば、ISO Cと互換性がないものもあれば、他のコンパイラの特殊機能に依存するものもある。

GCCをインストールすると、@code{fixincludes}というプログラムを実行することによって、固定ヘッダファイルが自動的に作成され、インストールされる。 通常、これに注意する必要はない。 しかし、自動的に正しいことをしないケースがある。

@itemize @bullet
@item
新しいシステムバージョンをインストールするなど、システムのヘッダーファイルを更新すると、GCCの固定ヘッダーファイルは自動的に更新されない。 @file{@var{libexecdir}/gcc/@var{target}/@var{version}/install-tools/}にインストールされている@command{mkheaders}スクリプトを使用して更新できる。

@item
いくつかのシステムでは、ヘッダーファイルのディレクトリには、特定の場所にマシン固有のシンボリックリンクが含まれている。 これにより、異なるマシンモデル上の同じバージョンのシステムを実行しているホスト間でほとんどのヘッダーファイルを共有することができる。

ヘッダーファイルを修正するプログラムは、シンボリックリンクを使用するこの特別な方法を理解していない。 したがって、固定ヘッダファイルのディレクトリは、それを構築するために使用されたマシンモデルに対してのみ有効である。

異なるマシンモデル用の固定ヘッダーファイルを別々に作成し、適切なセットを使用するようにシンボリックリンクの構造を調整することは可能だが、手動で行う必要がある。
@end itemize

@node Standard Libraries
@section 標準ライブラリ

@opindex Wall
GCCはそれ自体、自立的実装の適合を試みている。これが何を意味するかについては、@xref{Standards、GCCでサポートされている言語標準}を参照せよ。 このような実装に必要なライブラリの機能以外にも、Cライブラリの残りの部分はオペレーティングシステムのベンダーによって提供される。 そのCライブラリがCの標準に準拠していない場合、あなたのプログラムは警告を受け取ることがある（特に、@option{-Wall}を使用する場合）。

たとえば、SunOS 4.1.3の@code{sprintf}関数は@code{char *}を返すが、C標準では@code{sprintf}は@code{int}を返す。 @code{fixincludes}プログラムは、この関数のプロトタイプをStandardと一致させることができるが、それでも関数は@code{char *}を返すので間違っている。

標準準拠ライブラリが必要な場合は、GCCが提供していないライブラリを検索する必要がある。 GNU Cライブラリ（@code{glibc}）は、GNU/LinuxおよびHURDベースのGNUシステム用のISO C、POSIX、BSD、SystemV、X / Openの互換性を提供する。 最近のバージョンでは他のシステムをサポートしていないが、非常に古いバージョンがしていた。 GNU Cライブラリのバージョン2.2には、ほぼ完全なC99サポートが含まれている。 新しいライブラリが利用可能かどうかは、オペレーティングシステムのベンダーに問い合わせることもできる。

@node Disappointments
@section 失望と誤解

これらの問題はおそらく残念だが、私たちはそれに関する実用的な方法を知らない。

@itemize @bullet
@item
最適化を使用してコンパイルすると、特定のローカル変数がデバッガによって認識されない。

これは、時々GCCが変数を最適化するために発生する。 デバッガにそのような変数が「持っていた」値を計算する方法を伝える方法はなく、とにかくそれが望ましいともはっきりしていない。 そこで、GCCは、デバッグ情報を書き込むときに排除された変数について言及しない。

最適化を使用するときは、実行可能ファイルとソースコードの間にある程度の不一致が予想される。

@cindex conflicting types
@cindex scope of declaration
@item
GCCが次のようなコードでエラーを報告すると、ユーザはしばしばバグだと思う：

@smallexample
int foo (struct mumble *);

struct mumble @{ @dots{} @};

int foo (struct mumble *x)
@{ @dots{} @}
@end smallexample

プロトタイプの@code{struct mumble}のスコープはそれを含む引数リストに限定されているので、このコードは本当に間違っている。 これは、すぐ下のファイルスコープで定義された@code{struct mumble}を参照するものではない。スコープの異なる類似の名前の2つの無関係な型である。

しかし、@code{foo}の定義では、それが引き継いで利用可能であるのでファイルスコープタイプが使用される。 したがって、定義とプロトタイプが一致せず、エラーが発生する。

この動作はばかげて見えるかもしれないが、ISO規格で規定されている。 @code{struct mumble}の定義をプロトタイプの上に移動することで、コードを動作させるのは簡単である。 上の例のエラーを避けるために、ISO Cとの互換性がなくす価値はない。

@item
揮発性オブジェクトであってもビットフィールドへのアクセスは、バイトやワードなどのより大きなオブジェクトにアクセスすることで機能する。 ビットフィールドを読み書きするためにアクセスするオブジェクトのサイズに依存することはできない。 それは、正確な使用法に従って、所与のビットフィールドについてさえ変化するかもしれない。

アクセスされるメモリの量を気にする必要がある場合は、volatileを使用し、ビットフィールドは使用してはならない。

@item
GCCには、システムヘッダファイルの既知の問題を解決するためのシェルスクリプトが付属している。 それらはGCCだけが特別なディレクトリを探し出す特別なディレクトリに、さまざまなヘッダファイルの修正されたコピーをインストールする。 スクリプトは、私たちが知っている問題のケースについて、すべてのシステムヘッダファイルを検索することによって、さまざまなシステムに適応する。

新しいシステムヘッダファイルがインストールされている場合、修正されたヘッダファイルを自動的に更新することはない。 @file{@var{libexecdir}/gcc/@var{target}/@var{version}/install-tools/}にインストールされている@command {mkheaders}スクリプトを使用して更新できる。

@item
@cindex floating point precision
たとえば、68000およびx86システムでは、浮動小数点数の正確な値をテストすると逆説的な結果が得られる。 たとえば、NaNではない浮動小数点値がそれ自身と等しくないことがわかる。 これは、浮動小数点レジスタがメモリ内の@code{double}に収まる精度よりも少し高い精度を保持しているためである。 コンパイルされたコードは、都合の良いときにメモリと浮動小数点レジスタの間で値を移動し、それらをメモリに移動すると、それらを切り捨てる。

@opindex ffloat-store
@option{-ffloat-store}オプション（@pxref{Optimize Options}）を使うと、この問題を部分的に回避できる。

@item
AIXや弱いシンボルをサポートしない他のプラットフォームでは、テンプレートを明示的にインスタンス化する必要があり、テンプレートの静的メンバーのシンボルは生成されない。

@item
AIXでは、GCCは、リンカーが参照されていないシンボルをプルーニングする前に、アプリケーションをリンクするときに静的コンストラクターとデストラクタのオブジェクトファイルとライブラリアーカイブをスキャンする。 これは、AIXリンカーが、静的コンストラクターまたはデストラクタが未使用であると誤って判断し、スキャンを実行する前にそれらを削除しないようにするために必要である。 見つかったすべての静的コンストラクタとデストラクタは、それらのモジュールがプログラムによって使用されない場合でも参照される。 これにより、実行可能なサイズが大きくなり、予期しないシンボル参照が発生する可能性がある。
@end itemize

@node C++ Misunderstandings
@section GNU C++でのよくある誤解

@cindex misunderstandings in C++
@cindex surprises in C++
@cindex C++ misunderstandings
C ++は複雑な言語であり、進化していて、その標準定義（ISO C ++標準）は最近完成したばかりである。 その結果、あなたのC++コンパイラは、その動作が正しい時でさえあなたを驚かせるかもしれない。 このセクションでは、この種の問題を頻繁に引き起こすいくつかの分野について説明する。

@menu
* Static Definitions::  静的メンバ宣言は定義ではない
* Name lookup::         名前検索、テンプレート、基底クラスのメンバのアクセス
* Temporaries::         一時値は予期したよりも前に消えるかもしれない
* Copy Assignment::     コピー代入演算子は仮想基底を２度コピーする
@end menu

@node Static Definitions
@subsection 静的メンバの宣言@emph{と}定義

@cindex C++ static data, declaring and defining
@cindex static data in C++, declaring and defining
@cindex declaring static data in C++
@cindex defining static data in C++
クラスに静的データメンバーがある場合、静的メンバーを@emph{宣言}するだけでは不十分である。それを@emph{定義}する必要もある。 例えば：

@smallexample
class Foo
@{
  @dots{}
  void method();
  static int bar;
@};
@end smallexample

この宣言は、@code{Foo}クラスが@code{Foo::bar}という名前の@code{int}と@code{Foo::method}という名前のメンバ関数を持つことのみを確立する。 しかし、@emph{メソッド}と@code{bar}を別の場所で定義する必要がある。 ISO標準によると、次のような1つのソースファイルでイニシャライザを指定する必要がある。

@smallexample
int Foo::bar = 0;
@end smallexample

他のC++コンパイラは、標準的な動作を正しく実装していないかもしれない。 結果として、これらのコンパイラの1つから@command{g++}に切り替えると、実際に正常に動作するように見えるプログラムが標準に準拠していないことがわかる。@command{g++}は、定義のない静的データメンバーを未定義シンボルとして報告する。


@node Name lookup
@subsection  名前検索、テンプレート、基底クラスのメンバのアクセス

@cindex base class members
@cindex two-stage name lookup
@cindex dependent name lookup

C++標準では、テンプレート関数またはクラスの解析時に、テンプレートパラメータに依存しないすべての名前が現在の定義にバインドされていることが規定されている。@footnote{C++標準では、テンプレートパラメータの型または値に依存する名前に"依存している"という用語を使用している。 この短い用語は、このセクションの残りの部分でも使用される。} 依存している名前のみがインスタンス化の時点で参照される。 たとえば、

@smallexample
  void foo(double);

  struct A @{
    template <typename T>
    void f () @{
      foo (1);        // @r{1}
      int i = N;      // @r{2}
      T t;
      t.bar();        // @r{3}
      foo (t);        // @r{4}
    @}

    static const int N;
  @};
@end smallexample

ここで、@code{foo}と@code{N}という名前は、@code{T}のタイプに依存しないコンテキスト内に現れる。 したがって、コンパイラは、インスタンス化のポイントの前だけでなく、テンプレートでの使用のコンテキストで定義されていることを要求し、ここではそれぞれ、@code{::foo(double)}と@code{A::N}を使用する。  特に、整数値を@code{::foo(double)}に渡すときに整数値を@code {double}に変換する。

逆に、@code{bar}と4番目のマーク付き行の@code{foo}への呼び出しは、@code{T}の型に依存するコンテキストで使用されるため、インスタンス化の時点でのみ検索され、 テンプレートを宣言した後、インスタンス化する前に宣言を提供することができる。 特に、@code{A::f<int>}をインスタンス化すると、最後の行は@code{struct A}の宣言の後であっても、オーバーロードされた@code{: foo(int)}が提供されていればそれを呼び出す。

従属名と非従属名の参照の区別は、2段階（または依存）の名前参照と呼ばれる。 G++はバージョン3.4からそれを実装している。

2段階の名前検索では、テンプレート以外のコードとは異なる動作が発生することがある。 最も一般的なのはおそらくこれである：

@smallexample
  template <typename T> struct Base @{
    int i;
  @};

  template <typename T> struct Derived : public Base<T> @{
    int get_i() @{ return i; @}
  @};
@end smallexample

@code{get_i()}では、@code{i}は従属コンテキストでは使用されないので、コンパイラは囲む名前空間スコープ（ここではグローバルスコープ）で宣言された名前を探す。 これは依存しているので、基本クラスを調べない。@code{Derived}を宣言した後でも、@code{Base}の特殊化を宣言することができるので、コンパイラは@code{i}が参照するものを本当に知ることができない。 グローバル変数@code{i}がない場合は、エラーメッセージが表示される。

基本クラスのメンバーが必要であることを明確にするために、基本クラスが分かっているインスタンス化時点までルックアップを延期する必要がある。 このためには、@code{this->i}（@code{this}は@code{Derived<T>*}型であり、明らかに依存していることを思い出す）か、または@code{Base<T>::i}のどちらかを使って、依存コンテキストで@code{i}にアクセスする必要がある。 代わりに、@code{Base<T>::i}を@code{using}宣言でスコープに入れることもできる。

別の同様の例では、基本クラスのメンバー関数を呼び出すことがある。

@smallexample
  template <typename T> struct Base @{
      int f();
  @};

  template <typename T> struct Derived : Base<T> @{
      int g() @{ return f(); @};
  @};
@end smallexample

ここでも、@code{f()}の呼び出しはテンプレート引数に依存しない（@code{T}の型に依存する引数はなく、呼び出しが依存コンテキストにないはずである）。 したがって、そのような関数のグローバル宣言は、基本クラスのインスタンスがインスタンス化時間まで可視ではないため、利用可能でなければならない。 結果的に、コンパイラは次のエラーメッセージを生成する。

@smallexample
  x.cc: In member function `int Derived<T>::g()':
  x.cc:6: error: there are no arguments to `f' that depend on a template
     parameter, so a declaration of `f' must be available
  x.cc:6: error: (if you use `-fpermissive', G++ will accept your code, but
     allowing the use of an undeclared name is deprecated)
@end smallexample

コードを有効にするには、@code{this->f()}または@code{Base<T>::f()}を使用する。 @option{-fpermissive}フラグを使用すると、インスタンス化時に後で参照するためのテンプレートの定義時に、宣言が表示されていないすべての関数呼び出しを、依存呼び出しかのようにマーキングすることによって、コンパイラにコードを受け付けることができる。 無効なコードを回避するために@option{-fpermissive}を使用することはお勧めできません。また、上記の例のように、基本クラスの変数が使用される場所ではなく、基本クラスの関数が呼び出されるケースだけを検出する。

いくつかのコンパイラ（3.4より前のG++バージョンを含む）では、これらの例が間違っていて、上記のコードをエラーなく受け入れることに注意せよ。 これらのコンパイラは、2段階の名前検索を正しく実装していない。


@node Temporaries
@subsection 一時値はあなたが期待する前に消えるかもしれない

@cindex temporaries, lifetime of
@cindex portions of temporary objects, pointers to
一時オブジェクトの@emph{部分}へのポインタや参照を使うのは危険である。 コンパイラは、予期する前にオブジェクトをすっかり削除し、ポインタをゴミとして残すかもしれない。 この問題が発生する最も一般的な場所は、文字列クラスのようなクラスである。特に、@code{char *}や@code{const char *}を入力する変換関数を定義するものである。これが、標準@code{string}クラスでは、@code{c_str}メンバ関数を呼び出す必要がある理由のひとつである。 しかし、内部構造体へのポインタを返すクラスであれば、この問題が発生する可能性がある。

例えば、プログラムは@code{string}オブジェクトを返す関数@code{strfunc}と、@code{char}へのポインタで動作する別の関数@code{charfunc}を使うかもしれない

@smallexample
string strfunc ();
void charfunc (const char *);

void
f ()
@{
  const char *p = strfunc().c_str();
  @dots{}
  charfunc (p);
  @dots{}
  charfunc (p);
@}
@end smallexample

@noindent
このような状況では、@code{c_str}メンバ関数から返されたC文字列へのポインタを保存し、@code{c_str}を繰り返し呼び出すのではなく、そのポインタを使用するのが妥当と思われるかもしれない。 しかし、@code {strfunc}の呼び出しによって作成された一時的な文字列は、@code{p}が初期化された後に破棄される。

このようなコードは、通常のローカル変数とともに一時値を削除する、古くなったcfrontベースのコンパイラなど、他のコンパイラでは正常に動作する可能性がある。 しかし、GNU C++の動作は標準に準拠しているので、プログラムが一時的なものの遅い破壊に依存している場合、移植性がない。

そのようなコードを書くための安全な方法は、一時的な名前を付けることで名前のスコープの終わりまでそれを強制的に残すことである。 例えば：

@smallexample
const string& tmp = strfunc ();
charfunc (tmp.c_str ());
@end smallexample

@node Copy Assignment
@subsection 仮想基底の暗黙のコピー代入

基本クラスが仮想の場合、基本クラスの1つのサブオブジェクトのみが各完全オブジェクトに属する。 また、コンストラクタとデストラクタは一度だけ呼び出され、最も派生したクラスから呼び出される。 ただし、そのようなオブジェクトは代入時には未規定の振る舞いをする。 例えば：

@smallexample
struct Base@{
  char *name;
  Base(char *n) : name(strdup(n))@{@}
  Base& operator= (const Base& other)@{
   free (name);
   name = strdup (other.name);
  @}
@};

struct A:virtual Base@{
  int val;
  A():Base("A")@{@}
@};

struct B:virtual Base@{
  int bval;
  B():Base("B")@{@}
@};

struct Derived:public A, public B@{
  Derived():Base("Derived")@{@}
@};

void func(Derived &d1, Derived &d2)
@{
  d1 = d2;
@}
@end smallexample

C ++標準では、@samp{Base::Base}はDerivedオブジェクトを構築またはコピーするときに一度しか呼び出されないことを指定している。 例の@samp{func}の中にあるように、派生オブジェクトの暗黙のコピー代入が呼び出されたときに、@samp{Base::operator=}が複数回呼び出されるかどうかは不明である。

G++は、コピー割り当てのための「直感的な」アルゴリズムを実装している。すべての直接基底を代入し、すべてのメンバーを代入する。 このアルゴリズムでは、仮想基底のサブオブジェクトに複数回出会う可能性がある。 この例では、@samp{val}、@samp{name}（@code{strdup}経由で）、@samp{bval}、@samp{name}の順にコピーが進行する。

アプリケーションコードがコピー代入に依存する場合、ユーザ定義のコピー代入演算子は不確実性を取り除く。 このような演算子を使用すると、アプリケーションは仮想基底サブオブジェクトの割り当ての有無とその方法を定義できる。

@node Non-bugs
@section Certain Changes We Don't Want to Make

This section lists changes that people frequently request, but which
we do not make because we think GCC is better without them.

@itemize @bullet
@item
Checking the number and type of arguments to a function which has an
old-fashioned definition and no prototype.

Such a feature would work only occasionally---only for calls that appear
in the same file as the called function, following the definition.  The
only way to check all calls reliably is to add a prototype for the
function.  But adding a prototype eliminates the motivation for this
feature.  So the feature is not worthwhile.

@item
Warning about using an expression whose type is signed as a shift count.

Shift count operands are probably signed more often than unsigned.
Warning about this would cause far more annoyance than good.

@item
Warning about assigning a signed value to an unsigned variable.

Such assignments must be very common; warning about them would cause
more annoyance than good.

@item
Warning when a non-void function value is ignored.

C contains many standard functions that return a value that most
programs choose to ignore.  One obvious example is @code{printf}.
Warning about this practice only leads the defensive programmer to
clutter programs with dozens of casts to @code{void}.  Such casts are
required so frequently that they become visual noise.  Writing those
casts becomes so automatic that they no longer convey useful
information about the intentions of the programmer.  For functions
where the return value should never be ignored, use the
@code{warn_unused_result} function attribute (@pxref{Function
Attributes}).

@item
@opindex fshort-enums
Making @option{-fshort-enums} the default.

This would cause storage layout to be incompatible with most other C
compilers.  And it doesn't seem very important, given that you can get
the same result in other ways.  The case where it matters most is when
the enumeration-valued object is inside a structure, and in that case
you can specify a field width explicitly.

@item
Making bit-fields unsigned by default on particular machines where ``the
ABI standard'' says to do so.

The ISO C standard leaves it up to the implementation whether a bit-field
declared plain @code{int} is signed or not.  This in effect creates two
alternative dialects of C@.

@opindex fsigned-bitfields
@opindex funsigned-bitfields
The GNU C compiler supports both dialects; you can specify the signed
dialect with @option{-fsigned-bitfields} and the unsigned dialect with
@option{-funsigned-bitfields}.  However, this leaves open the question of
which dialect to use by default.

Currently, the preferred dialect makes plain bit-fields signed, because
this is simplest.  Since @code{int} is the same as @code{signed int} in
every other context, it is cleanest for them to be the same in bit-fields
as well.

Some computer manufacturers have published Application Binary Interface
standards which specify that plain bit-fields should be unsigned.  It is
a mistake, however, to say anything about this issue in an ABI@.  This is
because the handling of plain bit-fields distinguishes two dialects of C@.
Both dialects are meaningful on every type of machine.  Whether a
particular object file was compiled using signed bit-fields or unsigned
is of no concern to other object files, even if they access the same
bit-fields in the same data structures.

A given program is written in one or the other of these two dialects.
The program stands a chance to work on most any machine if it is
compiled with the proper dialect.  It is unlikely to work at all if
compiled with the wrong dialect.

Many users appreciate the GNU C compiler because it provides an
environment that is uniform across machines.  These users would be
inconvenienced if the compiler treated plain bit-fields differently on
certain machines.

Occasionally users write programs intended only for a particular machine
type.  On these occasions, the users would benefit if the GNU C compiler
were to support by default the same dialect as the other compilers on
that machine.  But such applications are rare.  And users writing a
program to run on more than one type of machine cannot possibly benefit
from this kind of compatibility.

This is why GCC does and will treat plain bit-fields in the same
fashion on all types of machines (by default).

There are some arguments for making bit-fields unsigned by default on all
machines.  If, for example, this becomes a universal de facto standard,
it would make sense for GCC to go along with it.  This is something
to be considered in the future.

(Of course, users strongly concerned about portability should indicate
explicitly in each bit-field whether it is signed or not.  In this way,
they write programs which have the same meaning in both C dialects.)

@item
@opindex ansi
@opindex std
Undefining @code{__STDC__} when @option{-ansi} is not used.

Currently, GCC defines @code{__STDC__} unconditionally.  This provides
good results in practice.

Programmers normally use conditionals on @code{__STDC__} to ask whether
it is safe to use certain features of ISO C, such as function
prototypes or ISO token concatenation.  Since plain @command{gcc} supports
all the features of ISO C, the correct answer to these questions is
``yes''.

Some users try to use @code{__STDC__} to check for the availability of
certain library facilities.  This is actually incorrect usage in an ISO
C program, because the ISO C standard says that a conforming
freestanding implementation should define @code{__STDC__} even though it
does not have the library facilities.  @samp{gcc -ansi -pedantic} is a
conforming freestanding implementation, and it is therefore required to
define @code{__STDC__}, even though it does not come with an ISO C
library.

Sometimes people say that defining @code{__STDC__} in a compiler that
does not completely conform to the ISO C standard somehow violates the
standard.  This is illogical.  The standard is a standard for compilers
that claim to support ISO C, such as @samp{gcc -ansi}---not for other
compilers such as plain @command{gcc}.  Whatever the ISO C standard says
is relevant to the design of plain @command{gcc} without @option{-ansi} only
for pragmatic reasons, not as a requirement.

GCC normally defines @code{__STDC__} to be 1, and in addition
defines @code{__STRICT_ANSI__} if you specify the @option{-ansi} option,
or a @option{-std} option for strict conformance to some version of ISO C@.
On some hosts, system include files use a different convention, where
@code{__STDC__} is normally 0, but is 1 if the user specifies strict
conformance to the C Standard.  GCC follows the host convention when
processing system include files, but when processing user files it follows
the usual GNU C convention.

@item
Undefining @code{__STDC__} in C++.

Programs written to compile with C++-to-C translators get the
value of @code{__STDC__} that goes with the C compiler that is
subsequently used.  These programs must test @code{__STDC__}
to determine what kind of C preprocessor that compiler uses:
whether they should concatenate tokens in the ISO C fashion
or in the traditional fashion.

These programs work properly with GNU C++ if @code{__STDC__} is defined.
They would not work otherwise.

In addition, many header files are written to provide prototypes in ISO
C but not in traditional C@.  Many of these header files can work without
change in C++ provided @code{__STDC__} is defined.  If @code{__STDC__}
is not defined, they will all fail, and will all need to be changed to
test explicitly for C++ as well.

@item
Deleting ``empty'' loops.

Historically, GCC has not deleted ``empty'' loops under the
assumption that the most likely reason you would put one in a program is
to have a delay, so deleting them will not make real programs run any
faster.

However, the rationale here is that optimization of a nonempty loop
cannot produce an empty one. This held for carefully written C compiled
with less powerful optimizers but is not always the case for carefully
written C++ or with more powerful optimizers.
Thus GCC will remove operations from loops whenever it can determine
those operations are not externally visible (apart from the time taken
to execute them, of course).  In case the loop can be proved to be finite,
GCC will also remove the loop itself.

Be aware of this when performing timing tests, for instance the
following loop can be completely removed, provided
@code{some_expression} can provably not change any global state.

@smallexample
@{
   int sum = 0;
   int ix;

   for (ix = 0; ix != 10000; ix++)
      sum += some_expression;
@}
@end smallexample

Even though @code{sum} is accumulated in the loop, no use is made of
that summation, so the accumulation can be removed.

@item
Making side effects happen in the same order as in some other compiler.

@cindex side effects, order of evaluation
@cindex order of evaluation, side effects
It is never safe to depend on the order of evaluation of side effects.
For example, a function call like this may very well behave differently
from one compiler to another:

@smallexample
void func (int, int);

int i = 2;
func (i++, i++);
@end smallexample

There is no guarantee (in either the C or the C++ standard language
definitions) that the increments will be evaluated in any particular
order.  Either increment might happen first.  @code{func} might get the
arguments @samp{2, 3}, or it might get @samp{3, 2}, or even @samp{2, 2}.

@item
Making certain warnings into errors by default.

Some ISO C testsuites report failure when the compiler does not produce
an error message for a certain program.

@opindex pedantic-errors
ISO C requires a ``diagnostic'' message for certain kinds of invalid
programs, but a warning is defined by GCC to count as a diagnostic.  If
GCC produces a warning but not an error, that is correct ISO C support.
If testsuites call this ``failure'', they should be run with the GCC
option @option{-pedantic-errors}, which will turn these warnings into
errors.

@end itemize

@node Warnings and Errors
@section Warning Messages and Error Messages

@cindex error messages
@cindex warnings vs errors
@cindex messages, warning and error
The GNU compiler can produce two kinds of diagnostics: errors and
warnings.  Each kind has a different purpose:

@itemize @w{}
@item
@dfn{Errors} report problems that make it impossible to compile your
program.  GCC reports errors with the source file name and line
number where the problem is apparent.

@item
@dfn{Warnings} report other unusual conditions in your code that
@emph{may} indicate a problem, although compilation can (and does)
proceed.  Warning messages also report the source file name and line
number, but include the text @samp{warning:} to distinguish them
from error messages.
@end itemize

Warnings may indicate danger points where you should check to make sure
that your program really does what you intend; or the use of obsolete
features; or the use of nonstandard features of GNU C or C++.  Many
warnings are issued only if you ask for them, with one of the @option{-W}
options (for instance, @option{-Wall} requests a variety of useful
warnings).

@opindex pedantic
@opindex pedantic-errors
GCC always tries to compile your program if possible; it never
gratuitously rejects a program whose meaning is clear merely because
(for instance) it fails to conform to a standard.  In some cases,
however, the C and C++ standards specify that certain extensions are
forbidden, and a diagnostic @emph{must} be issued by a conforming
compiler.  The @option{-pedantic} option tells GCC to issue warnings in
such cases; @option{-pedantic-errors} says to make them errors instead.
This does not mean that @emph{all} non-ISO constructs get warnings
or errors.

@xref{Warning Options,,Options to Request or Suppress Warnings}, for
more detail on these and related command-line options.
